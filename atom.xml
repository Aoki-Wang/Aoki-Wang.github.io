<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Aoki&#39;s Blog</title>
  
  <subtitle>“吾生也有涯，而知无涯”</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://wanqbin.xyz/"/>
  <updated>2019-08-07T13:51:06.335Z</updated>
  <id>http://wanqbin.xyz/</id>
  
  <author>
    <name>Aoki</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>vim的使用</title>
    <link href="http://wanqbin.xyz/2019/08/07/vim%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>http://wanqbin.xyz/2019/08/07/vim的使用/</id>
    <published>2019-08-07T12:24:00.000Z</published>
    <updated>2019-08-07T13:51:06.335Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、vim"><a href="#一、vim" class="headerlink" title="一、vim"></a>一、vim</h2><p><img src="/2019/08/07/vim的使用/1.PNG" alt="vim"></p><p>&emsp;&emsp;vim是从vi发展出来的一个文本编辑器。代码补全、编译及错误跳转等方便编程的功能特别丰富，在程序员中被广泛使用，和Emacs并列称为类Unix系统用户最喜欢的文本编辑器。</p><p>&emsp;vim的设计理念是命令的组合。用户学习了各种各样的文本间移动/跳转的命令和其他的普通模式的编辑命令，并且能够灵活使用的话，能够比那些没有模式的编辑器是更加高效地进行文本编辑。同时vim与很多快捷键设置和正则表达式类似，可以辅助记忆，并且vim针对程序员做了优化。</p><h2 id="二、vim的使用"><a href="#二、vim的使用" class="headerlink" title="二、vim的使用"></a>二、vim的使用</h2><ol><li><h4 id="光标移动"><a href="#光标移动" class="headerlink" title="光标移动"></a>光标移动</h4></li></ol><table><thead><tr><th>按键</th><th>动作</th></tr></thead><tbody><tr><td>k</td><td>上</td></tr><tr><td>j</td><td>下</td></tr><tr><td>h</td><td>左</td></tr><tr><td>l</td><td>右</td></tr><tr><td>0</td><td>到行首</td></tr><tr><td>shift+4（即$)</td><td>到行尾</td></tr><tr><td>gg</td><td>移动到文件头</td></tr><tr><td>G</td><td>移动到文件尾部</td></tr><tr><td>nG（n为行数）</td><td>移动到某一行</td></tr></tbody></table><ol start="2"><li><h4 id="删除内容"><a href="#删除内容" class="headerlink" title="删除内容"></a>删除内容</h4></li></ol><table><thead><tr><th>按键</th><th>动作</th></tr></thead><tbody><tr><td>x</td><td>删除光标所在字母</td></tr><tr><td>u</td><td>撤销</td></tr><tr><td>X</td><td>删除光标前面的内容</td></tr><tr><td>dw</td><td>从光标删除一个单词</td></tr><tr><td>d0</td><td>删除光标到行首</td></tr><tr><td>D</td><td>删除光标到行尾</td></tr><tr><td>dd</td><td>删除光标所在行</td></tr><tr><td>ndd</td><td>删除光标所在行开始n行</td></tr></tbody></table><ol start="3"><li><h4 id="复制粘贴与可视模式"><a href="#复制粘贴与可视模式" class="headerlink" title="复制粘贴与可视模式"></a>复制粘贴与可视模式</h4></li></ol><table><thead><tr><th>按键</th><th>动作</th></tr></thead><tbody><tr><td>yy</td><td>复制一行内容</td></tr><tr><td>dd</td><td>剪切一方内容</td></tr><tr><td>nyy</td><td>复制n行内容</td></tr><tr><td>p</td><td>粘贴到当前行</td></tr><tr><td>P</td><td>粘贴到上一行</td></tr><tr><td>r</td><td>替换一个字母（输入r之后，再输入一个字母）</td></tr></tbody></table><p>   可视模式：</p><ul><li><p>按v进入可视模式</p></li><li><p>移动光标选中内容</p></li><li><p>按y复制内容</p></li><li><p>移动光标到目的地</p></li><li><p>按p/P将内容粘贴</p></li></ul><ol start="4"><li><h4 id="查找-amp-格式调整-amp-查看"><a href="#查找-amp-格式调整-amp-查看" class="headerlink" title="查找&amp;格式调整&amp;查看"></a>查找&amp;格式调整&amp;查看</h4><p>内容查找：</p><ul><li>/要查找的字符或字符串</li><li>n/N进行遍历，向前或向后</li><li>?要查找的字符或字符串</li><li>光标移动到字符串上，按#也可以查找该字符串</li></ul><p>格式调整：</p><ul><li>gg=G 文件整体调整格式</li><li><code>&gt;&gt;</code>当前光标所在行右移一个Tab</li><li><code>&lt;&lt;</code>光标所在行左移一个Tab</li><li>n<code>&gt;&gt;</code>光标开始n行左移一个Tab</li></ul></li><li><h4 id="从命令模式到编辑模式"><a href="#从命令模式到编辑模式" class="headerlink" title="从命令模式到编辑模式"></a>从命令模式到编辑模式</h4><p>命令模式变为编辑模式：</p><ul><li><code>i</code>在光标前插入</li><li><code>a</code>在光标后插入</li><li><code>I</code>在行首插入</li><li><code>A</code>在行尾插入</li><li><code>o/O</code>在下一行或上一行插入</li><li><code>s</code>删除当前字母，进入插入模式</li><li><code>S</code>删除当前行，进入插入模式</li></ul></li><li><h4 id="末行查找替换与保存退出"><a href="#末行查找替换与保存退出" class="headerlink" title="末行查找替换与保存退出"></a>末行查找替换与保存退出</h4><p>末行模式：</p><ul><li><code>:s/被替换内容/替换内容</code>只替换当前行第一个匹配的“被替换内容”为“替换内容”</li><li><code>:s/被替换内容/替换内容/g</code>替换当前行所有的“被替换类同”为“替换内容”</li><li><code>:%s/被替换内容/替换内容</code>替换所有行的第一个匹配“被替换内容”为“替换内容”</li><li><code>:%s/被替换内容/替换内容/g</code>替换文件内所有的“被替换内容”为“替换内容”</li></ul><p>保存退出：</p><ul><li><code>wq</code>保存退出</li><li><code>:w</code>只保存</li><li><code>:q</code>只退出，文件不能修改</li><li><code>:q!</code>强退，不保存</li><li><code>:x</code>保存退出</li><li><code>ZZ</code>保存退出（命令模式下）</li></ul></li><li><h4 id="分屏"><a href="#分屏" class="headerlink" title="分屏"></a>分屏</h4><p><code>:sp filename</code>横分</p><p><code>:vsp filename</code>竖分</p><p><img src="/2019/08/07/vim的使用/2.PNG" alt="分屏——横分"></p><p><img src="/2019/08/07/vim的使用/3.PNG" alt="分屏——竖分"></p><p>退出：<br><code>:q</code>退出一个文件</p><p><code>:qall</code>全部文件退出</p><p><code>:wqall</code>全部保存退出</p><p>切换屏幕：</p><p>​    Ctrl+w+w</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、vim&quot;&gt;&lt;a href=&quot;#一、vim&quot; class=&quot;headerlink&quot; title=&quot;一、vim&quot;&gt;&lt;/a&gt;一、vim&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;/2019/08/07/vim的使用/1.PNG&quot; alt=&quot;vim&quot;&gt;&lt;/p&gt;
&lt;p&gt;&amp;ems
      
    
    </summary>
    
      <category term="Linux命令" scheme="http://wanqbin.xyz/categories/Linux%E5%91%BD%E4%BB%A4/"/>
    
    
      <category term="Ubuntu" scheme="http://wanqbin.xyz/tags/Ubuntu/"/>
    
      <category term="Linux" scheme="http://wanqbin.xyz/tags/Linux/"/>
    
      <category term="Vim" scheme="http://wanqbin.xyz/tags/Vim/"/>
    
  </entry>
  
  <entry>
    <title>Linux压缩解压命令及其他命令</title>
    <link href="http://wanqbin.xyz/2019/08/07/Linux%E5%8E%8B%E7%BC%A9%E8%A7%A3%E5%8E%8B%E5%91%BD%E4%BB%A4%E5%8F%8A%E5%85%B6%E4%BB%96%E5%91%BD%E4%BB%A4/"/>
    <id>http://wanqbin.xyz/2019/08/07/Linux压缩解压命令及其他命令/</id>
    <published>2019-08-07T11:43:00.000Z</published>
    <updated>2019-08-07T12:11:04.076Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、压缩解压命令"><a href="#一、压缩解压命令" class="headerlink" title="一、压缩解压命令"></a>一、压缩解压命令</h2><ol><li><h3 id="压缩解压命令：gzip"><a href="#压缩解压命令：gzip" class="headerlink" title="压缩解压命令：gzip"></a>压缩解压命令：<code>gzip</code></h3><ul><li><p>命令名称：gzip</p></li><li><p>命令英文原意：GUN zip</p></li><li><p>命令所在路径：/bin/gzip</p></li><li><p>执行权限：所有用户</p></li><li><p>语法：gzip [文件]</p></li><li><p>功能描述：压缩文件</p></li><li><p>压缩后文件格式：.gz</p></li><li><p>注意：</p><ul><li><p>gizp只能压缩文件，不能压缩目录</p></li><li><p>压缩之后不保留原文件</p></li></ul></li></ul><p><img src="/2019/08/07/Linux压缩解压命令及其他命令/1.PNG" alt="压缩解压命令"></p></li><li><h3 id="压缩解压命令：gunzip"><a href="#压缩解压命令：gunzip" class="headerlink" title="压缩解压命令：gunzip"></a>压缩解压命令：<code>gunzip</code></h3><ul><li><p>命令名称：gunzip</p></li><li><p>命令英文原意：GUN unzip</p></li><li><p>命令所在路径：/bin/gunzip</p></li><li><p>执行权限：所有用户</p></li><li><p>语法： gunzip [压缩文件]</p></li><li><p>功能描述： 解压缩.gz的压缩文件</p></li></ul><p><img src="/2019/08/07/Linux压缩解压命令及其他命令/2.PNG" alt="压缩解压命令"></p></li><li><h3 id="压缩解压命令：tar"><a href="#压缩解压命令：tar" class="headerlink" title="压缩解压命令：tar"></a>压缩解压命令：<code>tar</code></h3><ul><li><p>命令名称：tar</p></li><li><p>命令所在路径：/bin/tar</p></li><li><p>执行权限：所有用户</p></li><li><p>语法：tar 选项[-zcf] [压缩后文件名] [目录]</p><p>-c 打包</p><p>-v 显示详细信息</p><p>-f 指定文件名</p><p>-z 打包同时压缩</p></li><li><p>功能描述：打包目录</p></li><li><p>压缩后文件格式：<code>.tar.gz</code></p></li></ul><p><img src="/2019/08/07/Linux压缩解压命令及其他命令/3.PNG" alt="压缩解压缩命令"></p></li><li><h3 id="压缩解压缩命令：tar"><a href="#压缩解压缩命令：tar" class="headerlink" title="压缩解压缩命令：tar"></a>压缩解压缩命令：<code>tar</code></h3><ul><li><p>tar命令解压缩语法：</p><p>​    -x 解包</p><p>​    -v 显示详细信息</p><p>​    -f 指定解压文件</p><p>​    -z 解压缩</p></li></ul><p><img src="/2019/08/07/Linux压缩解压命令及其他命令/4.PNG" alt="压缩解压命令"></p></li><li><h3 id="压缩解压缩命令：zip"><a href="#压缩解压缩命令：zip" class="headerlink" title="压缩解压缩命令：zip"></a>压缩解压缩命令：<code>zip</code></h3><ul><li><p>命令名称：zip</p></li><li><p>命令所在路径：/usr/bin/zip</p></li><li><p>执行权限：所有用户</p></li><li><p>语法： zip 选项 [-r] [压缩后文件名] [文件或目录] </p><p>​     -r 压缩目录</p></li><li><p>功能描述：压缩文件或目录</p></li><li><p>压缩后文件格式：zip</p></li><li><p>压缩之后可以保留原文件</p></li></ul><p><img src="/2019/08/07/Linux压缩解压命令及其他命令/5.PNG" alt="压缩解压命令"></p></li><li><h3 id="压缩解压缩命令：unzip"><a href="#压缩解压缩命令：unzip" class="headerlink" title="压缩解压缩命令：unzip"></a>压缩解压缩命令：<code>unzip</code></h3><ul><li><p>命令名称：unzip</p></li><li><p>命令所在路径：/usr/bin/unzip</p></li><li><p>执行权限：所有用户</p></li><li><p>语法：unzip [压缩文件]</p></li><li><p>功能描述：解压.zip的压缩文件</p></li></ul><p><img src="/2019/08/07/Linux压缩解压命令及其他命令/6.PNG" alt="压缩解压命令"></p></li><li><h3 id="压缩解压缩命令：bzip2"><a href="#压缩解压缩命令：bzip2" class="headerlink" title="压缩解压缩命令：bzip2"></a>压缩解压缩命令：<code>bzip2</code></h3><ul><li><p>命令名称：bzip2</p></li><li><p>命令所在路径：/usr/bin/bzip2</p></li><li><p>执行权限：所有用户</p></li><li><p>语法：bzip2 选项[-k] [文件]</p><p>​    -k 产生压缩文件后保留原文件</p></li><li><p>功能描述：压缩文件</p></li><li><p>压缩后文件格式：.bz2</p></li><li><p>不能压缩目录</p></li></ul><p><img src="/2019/08/07/Linux压缩解压命令及其他命令/7.PNG" alt="压缩解压命令"></p></li><li><h3 id="压缩解压缩命令：bunzip2"><a href="#压缩解压缩命令：bunzip2" class="headerlink" title="压缩解压缩命令：bunzip2"></a>压缩解压缩命令：<code>bunzip2</code></h3><ul><li><p>命令名称：bunzip2</p></li><li><p>命令所在权限：所有用户</p></li><li><p>语法：bunzip2 选项[-k] [压缩文件]</p><p>​        -k 解压缩后保留原文件</p></li><li><p>功能描述：解压缩</p></li></ul><p><img src="/2019/08/07/Linux压缩解压命令及其他命令/8.PNG" alt="压缩解压命令"></p></li></ol><h2 id="二、用户管理命令"><a href="#二、用户管理命令" class="headerlink" title="二、用户管理命令"></a>二、用户管理命令</h2><ol><li><h3 id="用户管理命令：useradd"><a href="#用户管理命令：useradd" class="headerlink" title="用户管理命令：useradd"></a>用户管理命令：<code>useradd</code></h3><ul><li><p>命令名称：useradd</p></li><li><p>命令所在路径：/usr/sbin/useradd</p></li><li><p>执行权限：root</p></li><li><p>语法：useradd 用户名</p></li><li><p>功能描述：添加新用户</p></li></ul></li><li><h3 id="用户管理命令：passwd"><a href="#用户管理命令：passwd" class="headerlink" title="用户管理命令：passwd"></a>用户管理命令：<code>passwd</code></h3><ul><li><p>命令名称：passwd</p></li><li><p>命令所在路径：/usr/bin/passwd</p></li><li><p>执行权限：所有用户</p></li><li><p>语法：passwd 用户名</p></li><li><p>功能描述：设置用户密码</p></li></ul><p><img src="/2019/08/07/Linux压缩解压命令及其他命令/9.PNG" alt="用户管理命令"></p></li><li><h3 id="用户管理命令：who"><a href="#用户管理命令：who" class="headerlink" title="用户管理命令：who"></a>用户管理命令：<code>who</code></h3><ul><li><p>命令名称：who</p></li><li><p>命令所在路径：/usr/bin/who</p></li><li><p>执行权限：所有用户</p></li><li><p>语法：who</p></li><li><p>功能描述：查看登录用户信息</p></li></ul><p><img src="/2019/08/07/Linux压缩解压命令及其他命令/10.PNG" alt="用户管理命令"></p></li></ol><h2 id="三、帮助命令"><a href="#三、帮助命令" class="headerlink" title="三、帮助命令"></a>三、帮助命令</h2><ol><li><h3 id="帮助命令：man"><a href="#帮助命令：man" class="headerlink" title="帮助命令：man"></a>帮助命令：<code>man</code></h3><ul><li><p>命令名称：man</p></li><li><p>命令英文原意：mannual</p></li><li><p>命令所在路径：/usr/bin/man</p></li><li><p>执行权限：所有用户</p></li><li><p>语法： man [命令或配置文件]  //配置文件不写绝对路径</p></li><li><p>功能描述：获得帮助信息</p></li></ul><p><img src="/2019/08/07/Linux压缩解压命令及其他命令/11.PNG" alt="帮助命令"></p></li><li><h3 id="帮助命令：help"><a href="#帮助命令：help" class="headerlink" title="帮助命令：help"></a>帮助命令：<code>help</code></h3><ul><li><p>命令名称：help</p></li><li><p>命令所在路径：Shell内置命令</p></li><li><p>执行权限：所有用户</p></li><li><p>语法 ：help 命令</p></li><li><p>功能描述：获得shell 内置命令的帮助信息</p></li><li><p>范例：$help umask</p><p>​            查看umask命令的帮助信息</p></li></ul><p><img src="/2019/08/07/Linux压缩解压命令及其他命令/12.PNG" alt="帮助命令"></p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、压缩解压命令&quot;&gt;&lt;a href=&quot;#一、压缩解压命令&quot; class=&quot;headerlink&quot; title=&quot;一、压缩解压命令&quot;&gt;&lt;/a&gt;一、压缩解压命令&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;h3 id=&quot;压缩解压命令：gzip&quot;&gt;&lt;a href=&quot;#压缩解压命令：gz
      
    
    </summary>
    
      <category term="Linux命令" scheme="http://wanqbin.xyz/categories/Linux%E5%91%BD%E4%BB%A4/"/>
    
    
      <category term="Linux命令" scheme="http://wanqbin.xyz/tags/Linux%E5%91%BD%E4%BB%A4/"/>
    
      <category term="Ubuntu" scheme="http://wanqbin.xyz/tags/Ubuntu/"/>
    
      <category term="Linux压缩解压" scheme="http://wanqbin.xyz/tags/Linux%E5%8E%8B%E7%BC%A9%E8%A7%A3%E5%8E%8B/"/>
    
      <category term="Linux用户管理" scheme="http://wanqbin.xyz/tags/Linux%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86/"/>
    
      <category term="Linux帮助命令" scheme="http://wanqbin.xyz/tags/Linux%E5%B8%AE%E5%8A%A9%E5%91%BD%E4%BB%A4/"/>
    
  </entry>
  
  <entry>
    <title>Linux文件搜索命令</title>
    <link href="http://wanqbin.xyz/2019/08/07/Linux%E6%96%87%E4%BB%B6%E6%90%9C%E7%B4%A2%E5%91%BD%E4%BB%A4/"/>
    <id>http://wanqbin.xyz/2019/08/07/Linux文件搜索命令/</id>
    <published>2019-08-07T09:02:00.000Z</published>
    <updated>2019-08-07T11:19:13.674Z</updated>
    
    <content type="html"><![CDATA[<ol><li><p>文件搜索命令：<code>find</code></p><p>注意：搜索会占用大量服务器资源。</p><ul><li><p>命令名称：find</p></li><li><p>命令所在路径：/bin/find</p></li><li><p>执行权限：所有用户</p></li><li><p>语法：find [搜索范围] [匹配条件]</p></li><li><p>执行权限： 所有用户</p></li><li><p>语法：find [文件搜索] [匹配条件]</p></li><li><p>功能描述：文件搜索</p></li></ul><p><code>$find aokis -name cpp</code></p><p>在目录<code>aokis</code>中查找文件<code>cpp</code></p><p><img src="/2019/08/07/Linux文件搜索命令/1.PNG" alt="文件搜索命令"></p><p><code>$find aokis -size +1024</code></p><p>+n代表大于， -n代表小于， n 表示等于</p><p><img src="/2019/08/07/Linux文件搜索命令/2.PNG" alt="文件搜索命令"></p><p><code>$find aokis -user aoki</code></p><p>在目录<code>aokis</code>中查找所有者为<code>aoki</code>的文件</p><p><code>-group</code>为根据所属组查找</p><p><code>$find aokis -cmin -120</code></p><p>在目录aokis下查找120分钟内修改过的文件和目录。</p><p><img src="/2019/08/07/Linux文件搜索命令/4.PNG" alt="文件搜索命令"></p><p><code>-amin</code> 访问时间access</p><p><code>-cmin</code> 文件属性change，改变文件属性的时间</p><p><code>-mmin</code> 文件内modify,文件内容被改变</p><p><code>find aokis -size +0 -a -size -1024</code></p><p>在aokis目录下查找大于0，小于1024的文件</p><p><img src="/2019/08/07/Linux文件搜索命令/5.PNG" alt="文件搜索命令"></p><p><code>-a</code>两个条件同时满足</p><p><code>-o</code>两个条件满足任意一个即可。</p><p><code>$find aokis -name aoki -exec cat {} \;</code></p><p>在aokis下查找aoki文件，并对其进行查看操作</p><p><code>-exec/-ok 命令{}\</code>对搜索结果执行操作</p><p><code>-type</code>根据文件类型查找</p><ul><li><code>-f</code>文件 <code>-d</code>目录  <code>-l</code>软链接文件</li></ul><p><code>-inum</code>根据i结点查找</p><p><img src="/2019/08/07/Linux文件搜索命令/6.PNG" alt="文件搜索命令"></p></li><li><p>文件搜索命令：<code>locate</code></p><ul><li><p>命令名称：locate</p></li><li><p>命令所在路径：/usr/bin/locate</p></li><li><p>执行权限:所有用户</p></li><li><p>语法：locate 文件名</p></li><li><p>功能描述：在文件资料库中查找文件</p></li><li><p>updatedb 更新locate文件资料库</p></li><li><p>注意：</p><ul><li>/tmp临时文件并不在locate的文件资料库中</li><li>locate 严格区分大小写</li><li>locate -i 不严格区分大小写</li></ul></li></ul><p><img src="/2019/08/07/Linux文件搜索命令/7.PNG" alt="文件搜索命令"></p></li><li><p>文件搜索命令：<code>which</code></p><ul><li><p>命令名称：which</p></li><li><p>命令所在路径：/usr/bin/which</p></li><li><p>执行权限：所有用户</p></li><li><p>语法：which 命令</p></li><li><p>功能描述：搜索命令所在目录及别名信息</p></li></ul><p><img src="/2019/08/07/Linux文件搜索命令/8.PNG" alt="文件搜索命令"></p></li><li><p>文件搜索命令：<code>grep</code></p><ul><li><p>命令名称：grep</p></li><li><p>命令所在路径：/bin/grep</p></li><li><p>执行权限：所有用户</p></li><li><p>语法：grep -iv [指定字符串] [文件]</p></li><li><p>功能描述：在文件中搜寻字符串匹配的行并输出</p><p>​                    -i  不区分大小写</p><p>​                    -v  排除指定字串</p><p><img src="/2019/08/07/Linux文件搜索命令/9.PNG" alt="文件搜索命令"></p><p><img src="/2019/08/07/Linux文件搜索命令/10.PNG" alt="文件搜索命令"></p></li></ul></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;&lt;p&gt;文件搜索命令：&lt;code&gt;find&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;注意：搜索会占用大量服务器资源。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;命令名称：find&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;命令所在路径：/bin/find&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;执行
      
    
    </summary>
    
      <category term="Linux命令" scheme="http://wanqbin.xyz/categories/Linux%E5%91%BD%E4%BB%A4/"/>
    
    
      <category term="Linux命令" scheme="http://wanqbin.xyz/tags/Linux%E5%91%BD%E4%BB%A4/"/>
    
      <category term="Ubuntu" scheme="http://wanqbin.xyz/tags/Ubuntu/"/>
    
      <category term="Linux文件搜索" scheme="http://wanqbin.xyz/tags/Linux%E6%96%87%E4%BB%B6%E6%90%9C%E7%B4%A2/"/>
    
  </entry>
  
  <entry>
    <title>Linux链接命令及权限管理命令</title>
    <link href="http://wanqbin.xyz/2019/08/07/Linux%E9%93%BE%E6%8E%A5%E5%91%BD%E4%BB%A4%E5%8F%8A%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86%E5%91%BD%E4%BB%A4/"/>
    <id>http://wanqbin.xyz/2019/08/07/Linux链接命令及权限管理命令/</id>
    <published>2019-08-07T07:45:00.000Z</published>
    <updated>2019-08-07T08:26:16.332Z</updated>
    
    <content type="html"><![CDATA[<ol><li><h3 id="文件处理命令：ln"><a href="#文件处理命令：ln" class="headerlink" title="文件处理命令：ln"></a>文件处理命令：<code>ln</code></h3><ul><li><p>命令名称：ln</p></li><li><p>命令英文原意：link</p></li><li><p>命令所在路径：/bin/ln</p></li><li><p>执行权限：所有用户</p></li><li><p>语法：ln -s [原文件] [目标文件]</p><p>​            -s 创建软链接</p></li><li><p>功能描述：生成链接文件</p></li></ul><p><img src="/2019/08/07/Linux链接命令及权限管理命令/1.PNG" alt="链接命令"></p><p>软链接特征：类似于Windos快捷方式</p><ul><li><code>lrwxrwxrwx</code> l代表软链接</li><li>文件大小只是符号链接的大小</li><li>cpp.soft-&gt;aokis/cpp 指向源文件</li></ul><p>硬链接特征：</p><ul><li>相当于执行了‘cp -p’命令，复制了相同属性的文件，且硬链接可以同步更新</li><li>通过i结点识别</li><li>不能跨分区</li><li>不能针对目录使用</li></ul><p><img src="/2019/08/07/Linux链接命令及权限管理命令/2.PNG" alt="硬链接"></p></li><li><h3 id="权限管理命令：chmod"><a href="#权限管理命令：chmod" class="headerlink" title="权限管理命令：chmod"></a>权限管理命令：<code>chmod</code></h3><ul><li>命令名称：chmod</li><li>命令英文原意：<strong>ch</strong>ange the  permissions <strong>mod</strong>e of a file</li><li>命令所在路径：/bin/chmod</li><li>执行权限：所有用户</li><li>语法：chmod  [{ugoa} {+-=} {rwx}] [文件或目录]   a表示所有人   u 表示所有者 g表示所属组  o表示other，其他人</li></ul><p>​            [mode=421] [文件或目录]          </p><p>​            -R 递归修改</p><ul><li><p>功能描述：改变文件或目录权限</p></li><li><p>权限的数字表示：</p><p>r —-4</p><p>w —-2</p><p>x —–l</p><p>rwxrw-r–</p><p>7  6  4</p></li></ul></li></ol><table><thead><tr><th>代表字符</th><th>权限</th><th>对文件的含义</th><th>对目录的含义</th></tr></thead><tbody><tr><td>r</td><td>读权限</td><td>可以查看文件内容</td><td>可以列出目录中的内容</td></tr><tr><td>w</td><td>写权限</td><td>可以修改文件内容</td><td>可以在目录中创建、删除文件</td></tr><tr><td>x</td><td>执行权限</td><td>可以执行文件内容</td><td>可以进入目录</td></tr></tbody></table><p>   <img src="/2019/08/07/Linux链接命令及权限管理命令/3.PNG" alt="权限管理命令"></p><ol start="3"><li><h3 id="权限管理命令：useradd-amp-groupadd"><a href="#权限管理命令：useradd-amp-groupadd" class="headerlink" title="权限管理命令：useradd &amp; groupadd"></a>权限管理命令：<code>useradd &amp; groupadd</code></h3><p>添加用户：<code>useradd</code></p><p><img src="/2019/08/07/Linux链接命令及权限管理命令/4.PNG" alt="添加用户"></p><p>添加结果：</p><p><img src="/2019/08/07/Linux链接命令及权限管理命令/5.PNG" alt="添加结果"></p><p>添加组：</p><p><img src="/2019/08/07/Linux链接命令及权限管理命令/6.PNG" alt="添加组"></p></li><li><h3 id="权限管理命令：chown"><a href="#权限管理命令：chown" class="headerlink" title="权限管理命令：chown"></a>权限管理命令：<code>chown</code></h3><ul><li><p>权限管理命令：chown</p></li><li><p>命令名称：chown</p></li><li><p>命令英文原意：change  owership file</p></li><li><p>命令所在路径：/bin/chown</p></li><li><p>执行权限：所有用户</p></li><li><p>语法：chown [用户] [文件或目录]</p></li><li><p>功能描述：改变文件或目录的所有者</p></li></ul><p><img src="/2019/08/07/Linux链接命令及权限管理命令/7.PNG" alt="权限管理命令"></p></li><li><h3 id="权限管理命令：chgrp"><a href="#权限管理命令：chgrp" class="headerlink" title="权限管理命令：chgrp"></a>权限管理命令：<code>chgrp</code></h3><ul><li><p>权限管理命令：chgrp</p></li><li><p>命令名称：chgrp</p></li><li><p>命令英文原意：change file group ownership</p></li><li><p>命令所在路径：/bin/chgrp</p></li><li><p>执行权限：所有用户</p></li><li><p>语法：chgrp [用户组] [文件或目录]</p></li><li><p>功能描述：改变文件或目录的所属组</p></li></ul><p><img src="/2019/08/07/Linux链接命令及权限管理命令/8.PNG" alt="权限管理命令"></p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;&lt;h3 id=&quot;文件处理命令：ln&quot;&gt;&lt;a href=&quot;#文件处理命令：ln&quot; class=&quot;headerlink&quot; title=&quot;文件处理命令：ln&quot;&gt;&lt;/a&gt;文件处理命令：&lt;code&gt;ln&lt;/code&gt;&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;命令名称：ln&lt;/p&gt;
      
    
    </summary>
    
      <category term="Linux命令" scheme="http://wanqbin.xyz/categories/Linux%E5%91%BD%E4%BB%A4/"/>
    
    
      <category term="Ubuntu" scheme="http://wanqbin.xyz/tags/Ubuntu/"/>
    
      <category term="Linux" scheme="http://wanqbin.xyz/tags/Linux/"/>
    
      <category term="文件处理命令" scheme="http://wanqbin.xyz/tags/%E6%96%87%E4%BB%B6%E5%A4%84%E7%90%86%E5%91%BD%E4%BB%A4/"/>
    
  </entry>
  
  <entry>
    <title>Linux文件处理命令</title>
    <link href="http://wanqbin.xyz/2019/08/07/Linux%E6%96%87%E4%BB%B6%E5%A4%84%E7%90%86%E5%91%BD%E4%BB%A4/"/>
    <id>http://wanqbin.xyz/2019/08/07/Linux文件处理命令/</id>
    <published>2019-08-07T07:01:00.000Z</published>
    <updated>2019-08-07T07:29:18.560Z</updated>
    
    <content type="html"><![CDATA[<ol><li><h3 id="文件处理命令：touch"><a href="#文件处理命令：touch" class="headerlink" title="文件处理命令：touch"></a>文件处理命令：touch</h3><ul><li><p>命令名称：touch</p></li><li><p>命令所在路径：/bin/touch</p></li><li><p>执行权限：所有用户</p></li><li><p>语法：touh [文件名] </p></li><li><p>功能描述：创建空文件</p></li><li><p>范例：</p><p>​    touch program files //会在当前目录下创建两个文件，一个为program，另一个为files</p><p>​    创建一个文件 ：touch “program files” //不建议加空格</p><p><img src="/2019/08/07/Linux文件处理命令/1.PNG" alt="文件处理命令"></p></li></ul></li><li><h3 id="文件处理命令：cat"><a href="#文件处理命令：cat" class="headerlink" title="文件处理命令：cat"></a>文件处理命令：cat</h3><ul><li><p>文件处理命令：cat</p></li><li><p>命令名称：cat</p></li><li><p>命令所在路径：/bin/cat</p></li><li><p>执行权限：所有用户</p></li><li><p>语法：cat [文件名]</p></li><li><p>功能描述：显示文件内容</p><p>​                    -n 显示行号</p><p><img src="/2019/08/07/Linux文件处理命令/2.PNG" alt="文件处理命令"></p></li></ul></li><li><h3 id="文件处理命令：more"><a href="#文件处理命令：more" class="headerlink" title="文件处理命令：more"></a>文件处理命令：more</h3><ul><li><p>文件处理命令：more</p></li><li><p>命令名称：more</p></li><li><p>命令所在路径：/bin/more</p></li><li><p>执行权限：所有用户</p></li><li><p>语法：more [文件名]</p><p>​            (空格)或f   翻页</p><p>​        （Enter） 换行</p><p>​            q或Q         退出</p></li><li><p>功能描述：分页显示文件内容</p></li></ul><p><img src="/2019/08/07/Linux文件处理命令/3.PNG" alt="文件处理命令"></p></li><li><h3 id="文件处理命令：less"><a href="#文件处理命令：less" class="headerlink" title="文件处理命令：less"></a>文件处理命令：less</h3><ul><li>文件处理命令：less</li><li>命令名称：less</li><li>命令所在路径： /usr/bin/less</li><li>执行权限：所有用户</li><li>语法：less [文件名]</li><li>功能描述：分页显示文件内容 （可向上翻页）</li></ul></li><li><h3 id="文件处理命令：head"><a href="#文件处理命令：head" class="headerlink" title="文件处理命令：head"></a>文件处理命令：head</h3><ul><li><p>文件处理命令：head</p></li><li><p>命令名称：head</p></li><li><p>命令所在路径：/usr/bin/head</p></li><li><p>执行权限：所有用户</p></li><li><p>语法：head [文件名]</p></li><li><p>功能描述：显示文件前面几行</p><p>​                    -n 指定行数</p></li></ul><p><img src="/2019/08/07/Linux文件处理命令/4.PNG" alt="文件处理命令"></p></li><li><h3 id="文件处理命令：tail"><a href="#文件处理命令：tail" class="headerlink" title="文件处理命令：tail"></a>文件处理命令：tail</h3><ul><li><p>文件处理命令：tail</p></li><li><p>命令名称：tail</p></li><li><p>命令所在路径：/usr/bin/tail</p></li><li><p>执行权限：所有用户</p></li><li><p>语法： tail [文件名]</p></li><li><p>功能描述：显示文件后面几行</p><p>​                -n 指定行数</p><p>​                -f 动态显示文件末尾内容</p></li></ul><p><img src="/2019/08/07/Linux文件处理命令/5.PNG" alt="文件处理命令"></p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;&lt;h3 id=&quot;文件处理命令：touch&quot;&gt;&lt;a href=&quot;#文件处理命令：touch&quot; class=&quot;headerlink&quot; title=&quot;文件处理命令：touch&quot;&gt;&lt;/a&gt;文件处理命令：touch&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;命令名称：touch&lt;/
      
    
    </summary>
    
      <category term="Linux命令" scheme="http://wanqbin.xyz/categories/Linux%E5%91%BD%E4%BB%A4/"/>
    
    
      <category term="Linux命令" scheme="http://wanqbin.xyz/tags/Linux%E5%91%BD%E4%BB%A4/"/>
    
      <category term="Ubuntu" scheme="http://wanqbin.xyz/tags/Ubuntu/"/>
    
      <category term="Linux文件处理命令" scheme="http://wanqbin.xyz/tags/Linux%E6%96%87%E4%BB%B6%E5%A4%84%E7%90%86%E5%91%BD%E4%BB%A4/"/>
    
  </entry>
  
  <entry>
    <title>Linux目录及常用命令</title>
    <link href="http://wanqbin.xyz/2019/08/07/Linux%E7%9B%AE%E5%BD%95%E5%8F%8A%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    <id>http://wanqbin.xyz/2019/08/07/Linux目录及常用命令/</id>
    <published>2019-08-07T06:16:00.000Z</published>
    <updated>2019-08-07T06:45:48.272Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、Ubuntu各目录含义"><a href="#一、Ubuntu各目录含义" class="headerlink" title="一、Ubuntu各目录含义"></a>一、Ubuntu各目录含义</h2><table><thead><tr><th>目录名</th><th>作用</th></tr></thead><tbody><tr><td>/boot/</td><td>启动目录，保存系统启动相关文件</td></tr><tr><td>/boot/grub/</td><td>grub引导其器相关的配置文件</td></tr><tr><td>/dev/</td><td>设备文件保存位置。Linux中所有内容以文件形式保存，包括硬件。那么这个目录就是用来保存所有硬件设备文件的</td></tr><tr><td>/proc/</td><td>虚拟文件目录，该目录中的数据并不保存到硬盘当中，而是保存到内存中。主要保存系统同的内核、进程、外部设备状态和网络状态灯</td></tr><tr><td>/mnt/</td><td>挂载目录，系统建议用来挂载NFS服务的共享目录。只要是一个已经建立的空目录就可以作为挂载点。系统虽然准备了三个默认挂载点/media、/mnt、/misc，但是到底哪个目录挂载什么设备都可以由管理员自己决定。</td></tr><tr><td>/media/</td><td>挂载目录，系统建议用来挂载媒体设备的，例如光盘和软盘</td></tr><tr><td>/root/</td><td>超级用户的家目录。普通用户家目录在/home下，超级用户家目录直接在/下</td></tr><tr><td>/home/用户名/</td><td>普通用户的家目录，创建一个一般用户账号时，默认的用户主文件夹就在该目录下</td></tr><tr><td>/bin/</td><td>存放系统命令的目录，普通用户和超级用户都可以执行</td></tr><tr><td>/sbin/</td><td>保存和系统环境设置相关的命令，只有超级用户可以使用这些命令进行系统环境设置</td></tr><tr><td>/lib/</td><td>系统调用的函数库保存位置</td></tr><tr><td>/etc/</td><td>配置文件保存位置。</td></tr><tr><td>/etc/init.d/</td><td>System V分类风格的启动脚本</td></tr><tr><td>/etc/X11/</td><td>图形界面配置文件</td></tr><tr><td>/lost+found</td><td>包含了系统修复时的恢复文件</td></tr><tr><td>/sys/</td><td>虚拟文件系统。和/proc目录相似，都是保存在内存当中的，主要保存与内核相关信息</td></tr><tr><td>/usr</td><td>Unix Software Resouce,即Unix操作系统软件资源放在该目录，而不是用户的是数据</td></tr><tr><td>/usr/bin</td><td>用户可使用的大部分命令都放在这儿</td></tr><tr><td>/usr/include</td><td>存放C/C++等程序语言的头文件和目标文件</td></tr><tr><td>/usr/lib</td><td>包含各应用软件的函数库，目标文件</td></tr><tr><td>/usr/local</td><td>系统管理员在本机执行下载自行安装的软件</td></tr><tr><td>/var</td><td>动态数据保存位置。主要保存缓存，日志以及软件运行所产生的文件</td></tr><tr><td>/var/cache</td><td>应用缓存目录</td></tr><tr><td>/var/lib</td><td>存放程序执行过程中，需要使用到的数据文件</td></tr><tr><td>/var/lock</td><td>它是/run/lock目录的软链接，某些设备或文件一次只能被一个应用所使用</td></tr><tr><td>var/log</td><td>日志文件目录</td></tr></tbody></table><h2 id="二、Linux相关知识"><a href="#二、Linux相关知识" class="headerlink" title="二、Linux相关知识"></a>二、Linux相关知识</h2><ol><li>Linux严格区分大小写</li><li>Linux中所有内容以文件形式保存，包括硬件<ul><li>硬盘文件是/dev/sd[a-p]</li><li>光盘文件是/dev/sr0等</li></ul></li><li>Linux不靠扩展名区分文件类型<ul><li>压缩包：.gz、.bz、.tar、.bz2、.tgz</li><li>二进制软件包：.rpm</li><li>网页文件：.html、.php</li><li>脚本文件：.ssh</li><li>配置文件：.conf</li></ul></li><li>Linux所有的存储设备都必须挂载之后用户才能使用，包括硬盘，U盘，光盘。</li><li>Windows下的程序不能直接在Linux中安装和运行</li></ol><h2 id="三、Linux目录处理命令"><a href="#三、Linux目录处理命令" class="headerlink" title="三、Linux目录处理命令"></a>三、Linux目录处理命令</h2><ol><li><p>命令格式</p><p>命令格式： <code>命令 [-选项] [参数]</code></p><p>例如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls -la</span><br></pre></td></tr></table></figure><p>说明：</p><ul><li>个别命令使用不遵循此格式</li><li>当有多个选项时，可以写在一起</li><li>简化选项与完整选项 -a等于–all</li></ul></li><li><p>目录处理命令：ls</p><ul><li><p>命令名称：ls</p></li><li><p>命令英文原意：list</p></li><li><p>命令所在路径：/bin/ls</p></li><li><p>执行权限：所有用户</p></li><li><p>功能描述：显示目录文件夹</p></li><li><p>语法： ls 选项[-add] [文件或目录]</p><p>​            -a 显示所有文件，包括隐藏文件</p><p>​            -l详细信息显示</p><p>​            -d查看指定目录的详细信息</p><p>​            -i 查询任何一个文件的id</p><p><img src="/2019/08/07/Linux目录及常用命令/1.PNG" alt="目录处理命令"></p><p><img src="/2019/08/07/Linux目录及常用命令/2.PNG" alt="目录处理命令"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls -lh  #人性化显示</span><br></pre></td></tr></table></figure><p><img src="/2019/08/07/Linux目录及常用命令/3.%E4%BA%BA%E6%80%A7%E5%8C%96%E6%98%BE%E7%A4%BA.PNG" alt="人性化显示"></p></li></ul></li><li><p>目录处理命令：mkdir</p><ul><li><p>命令名称：mkdir</p></li><li><p>命令英文原意：make directories【目录】</p></li><li><p>命令所在路径:/bin/mkdir</p></li><li><p>执行权限：所有用户</p></li><li><p>语法：mkdir -p[目录名]</p></li><li><p>功能描述：创建新目录</p><p>​                    -p   递归创建</p><p><img src="/2019/08/07/Linux目录及常用命令/4.PNG" alt="目录处理命令mkdir"></p></li></ul></li><li><p>目录处理命令：cd</p><ul><li><p>命令名称：cd</p></li><li><p>命令英文原意：change directory</p></li><li><p>命令所在路径：shell内置命令</p></li><li><p>执行权限：所有用户</p></li><li><p>语法：cd [目录]</p></li><li><p>功能描述：切换目录</p></li></ul></li><li><p>目录处理命令：pwd</p><ul><li><p>目录处理命令：pwd</p></li><li><p>命令名称：pwd</p></li><li><p>命令英文原意：print working directory</p></li><li><p>命令所在路径：/bin/pwd</p></li><li><p>执行权限：所有用户</p></li><li><p>语法：pwd</p></li><li><p>功能描述：显示当前目录</p></li></ul><p><img src="/2019/08/07/Linux目录及常用命令/5.PNG" alt="目录处理命令"></p></li><li><p>目录处理命令：rmdir</p><ul><li><p>命令名称：rmdir</p></li><li><p>命令英文原意：remove empty directories</p></li><li><p>命令所在路径：/bin/rmdir</p></li><li><p>执行权限：所有用户</p></li><li><p>语法：rmdir [目录名]</p></li><li><p>功能：删除空目录</p></li></ul><p><img src="/2019/08/07/Linux目录及常用命令/6.PNG" alt="目录处理命令"></p><p>当目录非空时，使用rmdir无法删除目录。</p><p>将目录为空时，可以使用rmdir删除目录。这里删除了xiaoming目录下的文件，删除成功。</p><p><img src="/2019/08/07/Linux目录及常用命令/7.PNG" alt="目录处理命令"></p></li><li><p>目录处理命令：cp</p><ul><li><p>命令名称：cp</p></li><li><p>命令英文原意：copy</p></li><li><p>命令所在路径：/bin/cp</p></li><li><p>执行权限：所有用户</p></li><li><p>语法： cd -rp [原文件或目录] [目标目录]</p><p>​            -r 复制目录</p><p>​            -p 保留文件属性</p></li><li><p>功能：复制文件或目录</p><p>​            可以同时复制多个文件</p></li></ul><p><img src="/2019/08/07/Linux目录及常用命令/8.PNG" alt="目录处理命令"></p></li><li><p>目录处理命令：mv</p><ul><li><p>命令名称：mv</p></li><li><p>命令英文原意：move</p></li><li><p>命令所在路径：/bin/mv</p></li><li><p>执行权限：所有用户</p></li><li><p>语法：mv [原文件或目录] [目标目录]</p></li><li><p>功能描述：剪切文件、改名</p></li></ul><p><img src="/2019/08/07/Linux目录及常用命令/9.PNG" alt="目录处理命令"></p><p>上图所示操作将<code>/xiaohong/xiaoming</code>目录下的<code>my</code>目录剪切到了<code>/xiaohong</code>目录下，并改名为<code>aokis</code>。</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、Ubuntu各目录含义&quot;&gt;&lt;a href=&quot;#一、Ubuntu各目录含义&quot; class=&quot;headerlink&quot; title=&quot;一、Ubuntu各目录含义&quot;&gt;&lt;/a&gt;一、Ubuntu各目录含义&lt;/h2&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;目录名&lt;
      
    
    </summary>
    
      <category term="Linux命令" scheme="http://wanqbin.xyz/categories/Linux%E5%91%BD%E4%BB%A4/"/>
    
    
      <category term="Linux命令" scheme="http://wanqbin.xyz/tags/Linux%E5%91%BD%E4%BB%A4/"/>
    
      <category term="Ubuntu" scheme="http://wanqbin.xyz/tags/Ubuntu/"/>
    
      <category term="目录处理命令" scheme="http://wanqbin.xyz/tags/%E7%9B%AE%E5%BD%95%E5%A4%84%E7%90%86%E5%91%BD%E4%BB%A4/"/>
    
  </entry>
  
  <entry>
    <title>Linux进程管理（二）</title>
    <link href="http://wanqbin.xyz/2019/08/07/Linux%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <id>http://wanqbin.xyz/2019/08/07/Linux进程管理（二）/</id>
    <published>2019-08-07T03:44:00.000Z</published>
    <updated>2019-08-07T06:44:21.993Z</updated>
    
    <content type="html"><![CDATA[<h2 id="三、进程创建"><a href="#三、进程创建" class="headerlink" title="三、进程创建"></a>三、进程创建</h2><ol><li><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>&emsp;&emsp;在创建进程时，Windows等操作系统都提供了产生（spawn)进程的机制，即首先在新的地址空间里创建进程，读入可执行文件，最后开始执行。Linux采用了一种不同的方式，它把上述过程分解到两个单独的函数(fork()和exec())中去执行。</p><p>&emsp;&emsp;首先<code>fork()</code>函数通过复制当前进程创建一个子进程，子进程与父进程的唯一区别是<code>task_struct</code>不同；接着<code>exec()</code>函数负责读取可执行文件并将其载入地址空间开始运行。</p><p>&emsp;&emsp;在Linux中，除了<code>init</code>进程外，所有进程都是由其他进程创建的。为此，Linux提供了三个函数来创建一个新的进程，分别是<code>fork()</code>、<code>vfork()</code>和<code>clone()</code>,内核中提供了三个与它们相对应的系统调用，分别是<code>sys_fork()</code>、<code>sys_vfork()</code>和<code>sys_clone()</code>，而这三个系统调用其实最终都是通过调用一个叫做<code>do_fork()</code>函数来完成一个进程的创建的。</p></li><li><h3 id="写时复制"><a href="#写时复制" class="headerlink" title="写时复制"></a>写时复制</h3><p>&emsp;&emsp;在创建进程时，传统的<code>fork()</code>函数的系统调用直接把所有的资源复制到新创建的进程内存空间，这种实现过于简单并且效率低下，因为如果新进程打算立即执行新的映像，那么所有的复制都将是无用的。</p><p>&emsp;&emsp;为了克服这个缺点，Linux在创建进程时，采用“写时复制”（copy-on-write)技术，即指在创建进程时并不将父进程的所有资源都复制到子进程，而是在需要的时候才进行资源的复制，采用该方法可以大大提高Linux的系统性能。该技术之所以有时可以避免数据复制，是因为在产生子进程时，并不复制父进程的所有页面，而是置父进程所有页面的写时复制位，子进程共享父进程的所有页面，直到父进程或子进程写某个页面时，就会发生一个保护性错误，并复制该页面。也就是说资源的复制只有在需要写入的时候才进行，在这之前，只是以只读的方式共享。</p></li><li><h3 id="fork-、vfork-与clone"><a href="#fork-、vfork-与clone" class="headerlink" title="fork()、vfork()与clone()"></a>fork()、vfork()与clone()</h3><ul><li><p>fork()函数</p><p><code>fork()</code>函数调用一次返回两次：一次在父进程，一次在子进程。如果在子进程中，则返回0；如果在父进程中，则将返回子进程的<code>pid</code>。<code>fork()</code>函数通过系统调用<code>sys_fork()</code>来实现，<code>sys_fork()</code>函数的实现依赖于体系结构，因为它的参数需要系统寄存器来传递。</p><p>在x86体系结构下该函数定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">asminkage <span class="keyword">int</span> <span class="title">sys_fork</span><span class="params">(struct pt_regs regs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> do_fork(SIGCHILD,reg.esp,&amp;reg,<span class="number">0</span>,<span class="literal">NULL</span>,<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ol><ul><li><p>vfork()函数</p><p><code>vfork()</code>函数和<code>fork()</code>函数类似，但前者的父进程一直阻塞，直到子进程退出或者调用<code>exec()</code>函数。之所以引进该函数，是因为当时还没有引入“写时复制”技术，调用<code>fork()</code>来创建新的进程需要复制整个父进程的数据，在有些情况下，这样会降低系统的利用率，引入<code>vfork()</code>就是为了在创建进程时子进程不复制父进程的页表项。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">asmlinkage <span class="keyword">int</span> <span class="title">sys_vfork</span><span class="params">(struct pt_regs regs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> do_fork(CLONE_VFORK|CLONE_VM|SIGCHLD,regs.esp,&amp;regs,<span class="number">0</span>,<span class="literal">NULL</span>,<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>clone()函数</p><p><code>clone()</code>函数不同于<code>fork()</code>和<code>vfork()</code>函数，它接受一个指向函数的指针和该函数的参数，由<code>do_fork()</code>创建的子进程刚一创建就去调用这个函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">asmlinkage <span class="keyword">int</span> <span class="title">sys_clone</span><span class="params">(struct pt_regs regs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> clone_flags;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> newsp;</span><br><span class="line">    <span class="keyword">int</span> _user *parent_tidptr,*child_tidptr;</span><br><span class="line">    clone_flags=regs.ebx;</span><br><span class="line">    newsp=reg.ecx;</span><br><span class="line">    parent_tidptr=(<span class="keyword">int</span> _user *)regs.edx;</span><br><span class="line">    child_tidptr=(<span class="keyword">int</span> _user *)regs.edi;</span><br><span class="line">    <span class="keyword">if</span>(!newsp)</span><br><span class="line">        newsp=regs.esp;</span><br><span class="line">    <span class="keyword">return</span> do_fork(clone_flags,newsp,&amp;regs,<span class="number">0</span>,parent_tidptr,child_tidptr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>do_fork()函数</p><p>我们知道需要通过调用<code>fork()</code>、<code>vfork()</code>、<code>clone()</code>来创建进程，这三个函数调用相应的系统调用<code>sys_fork()</code>、<code>sys_vfork()</code>和<code>sys_clone()</code>，而这三个系统调用的区别在于调用<code>do_fork()</code>函数时设置的那些标志不同，该函数实现真正的进程创建。函数原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">do_fork</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> clone_flags,<span class="keyword">unsigned</span> <span class="keyword">long</span> stack_start,struct pt_regs *regs,<span class="keyword">unsigned</span> <span class="keyword">long</span> stack_size,<span class="keyword">int</span> _user *parent_tidptr,<span class="keyword">int</span> _user *child_tidptr)</span></span>;</span><br></pre></td></tr></table></figure><p>其中，参数<code>stack_start</code>表示栈的起始地址，参数<code>regs</code>表示存储所有寄存器的结构指针，参数<code>stack_size</code>表示栈的大小，参数<code>parent_tidptr</code>表示父进程的用户态变量<code>pid</code>地址，参数<code>child_tidptr</code>表示子进程的用户态变量<code>pid</code>地址，<code>clone_flags</code>表示<code>clone</code>标志位，包括<code>CLONE_VM</code>,<code>CLONE_FILES</code>,<code>CLONE_SIGHAND</code>,<code>CLONE_PID</code>,<code>CLONE_VFORK</code>等，任何一位被置1则表明创建的子进程和父进程共享该位对应的资源。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CSIGNAL                         0x000000ff <span class="comment">/*进程退出时需要传递的信号*/</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CLONE_VM                        0x00000100 <span class="comment">/*父子进程共享地址空间*/</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CLONE_FS                        0x00000200 <span class="comment">/*父子进程共享文件系统信息*/</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CLONE_FILES                     0x00000400 <span class="comment">/*父子进程共享已打开的文件*/</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CLONE_SIGHAND                   0x00000800 <span class="comment">/*父子进程共享信号处理*/</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CLONE_PTRACE                    0x00002000 <span class="comment">/*继续调试子进程*/</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CLONE_VFORK                     0x00004000 <span class="comment">/*调用vfork(),父进程休眠*/</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CLONE_PARENT                    0x00008000 <span class="comment">/*设置一个共有的父进程*/</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CLONE_THREAD                    0x00010000 <span class="comment">/*父子进程在同一个线程组*/</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CLONE_NEWNS                     0x00020000 <span class="comment">/*为子进程创建一个新的命名空间*/</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CLONE_SYSVSEM                   0x00040000 <span class="comment">/*父子进程共享system V SEM_UNDO*/</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CLONE_SETTLES                   0x00080000 <span class="comment">/*为子进程创建新的TLS*/</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CLONE_PARENT_SETTID             0x00100000 <span class="comment">/*设置父进程TID*/</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CLONE_CHILD_CLEARTID            0x00200000 <span class="comment">/*清除子进程TID*/</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CLONE_DETACHED                  0x00400000 <span class="comment">/*Unused,ignored*/</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CLONE_UNTRACED                  0x00800000 <span class="comment">/*不允许调试子进程*/</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CLONE_CHILD_SETTID              0x01000000 <span class="comment">/*设置子进程TID*/</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CLONE_STOPPED                   0x02000000 <span class="comment">/*设置进程停止状态*/</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CLONE_NEWUTS                    0x04000000 <span class="comment">/*创建新的utsname组*/</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CLONE_NEWIPC                    0x08000000 <span class="comment">/*创建新的IPC*/</span></span></span><br></pre></td></tr></table></figure></li></ul><h2 id="四、进程终止"><a href="#四、进程终止" class="headerlink" title="四、进程终止"></a>四、进程终止</h2><ol><li><h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><p>&emsp;&emsp;进程的终止方式有两种：<br>（1）正常结束，即在进程执行过程中调用<code>exit()</code>函数，或者在<code>main</code>函数中执行<code>return</code>语句，或者是main函数执行完，进程就正常结束了。<br>（2）异常结束，在进程运行过程中出现了错误或故障被迫结束。这类错误或故障有很多，常见的有：进程收到自己不能处理的一个信号，进程在内核执行期间可能产生一个异常，进程可能收到SIGABRT或其他终止信号等。</p><p>无论进程以哪一种方式终止，Linux内核并不是在进程终止的同时就将与进程相关的所有资源都释放掉，而是分为两步执行的：</p><ul><li>首先，通过调用<code>do_eait()</code>函数，释放掉与进程相关的大部分资源，并使进程处于ZMOBIE（僵死）状态，但此时进程描述符并没有释放。</li><li>然后，根据父进程是否终止，对子进程进行相应的处理。若子进程先于父进程终止了，则子进程会一直处于僵死状态直到父进程调用<code>wait()</code>或<code>waitpid()</code>，当父进程调用了<code>wait()</code>或<code>waitpid()</code>函数时，子进程的进程描述符和所有其独享的资源都将被释放掉；若父进程先于子进程终止，则内核必须首先为子进程找到一个新的父进程，方法是首先给子进程在当前进程组内找一个进程作为其父进程，如果该方法不行则让<code>init</code>进程作该进程的父进程。</li></ul><p>下面详细说明父进程是如何获得子进程死亡的消息以及内核是如何完成进程终止的第二步。</p><ul><li>当一个进程进入僵死状态后，尽管它已经不能再次被调度运行了，但是并不能将其马上就释放掉，而是应该保存其进程描述符，这样可以使得系统在子进程终止了的情况下仍然可以获得它的信息。</li><li>当子进程终止时，父进程会收到内核发送给它的SIGCHLD信号，父进程可以通过调用<code>wait()</code>函数来处理信号，<code>wait()</code>函数族有两个作用:获取子进程终止的消息和清除子进程的所有独享资源。<code>wait()</code>函数首先会挂起调用它的进程，直到该进程的一个子进程终止，此时，该函数会返回该子进程的pid给父进程。</li></ul></li><li><h3 id="do-exit-函数"><a href="#do-exit-函数" class="headerlink" title="do_exit()函数"></a>do_exit()函数</h3><p>&emsp;&emsp;在Linux中不管是以何种方式结束进程，最终都要调用内核函数<code>do_exit()</code>。该函数释放掉与该进程有关系的大多数资源（如果进程是这些资源的唯一使用者），进程运行该函数后将不再可以运行，处于<code>TASK_ZOMBIE</code>状态，此时进程占有的所有资源就是内核栈、<code>thread_info</code>结构和<code>task_struct</code>结构，用于向它的父进程提供信息。</p><p>&emsp;&emsp;<code>do_exit()</code>函数的大致处理流程：</p><ul><li>排除一些无效的特殊情况，即确保该进程不处于中断处理中，确保该进程不是<code>idle进程(pid=0)</code>。如果该进程正在被追踪并且设置了<code>PT_TRACE_EXIT</code>标志，就传递退出码并通知父进程。</li><li>对重读调用<code>do_exit</code>进行处理，并把进程的标志置为<code>PF_EXITING</code>，表明进程正在关闭。</li><li>如果进程审计功能开启，则记录进程的运行信息。</li><li>进程资源释放。例如，更新内存信息，然后调用<code>exit_mm()</code>函数释放进程所占用的内存，并释放<code>mm_struct</code>结构；调用<code>exit_sem()</code>函数把进程从任一IPC信号量中释放出来；调用<code>_exit_files()</code>函数释放分配给进程的所有文件，减少文件描述符的个数；调用<code>module_put()</code>函数减少模块的引用数。</li><li>调用<code>exit_notify()</code>函数向父进程发送信号，将子进程的父进程重新设置为线程组中的其他线程或者<code>init</code>进程，并把进程的状态设置为<code>TASK_ZOMBIE</code>状态。</li><li>最后调用<code>schedule()</code>函数切换到其他进程。</li></ul></li><li><h3 id="wait-函数"><a href="#wait-函数" class="headerlink" title="wait()函数"></a>wait()函数</h3><p>&emsp;&emsp;在调用了<code>do_exit()</code>函数之后，尽管进程已经僵死不能再运行了，但是系统还保留了它的进程描述符，系统可以通过<code>wait()</code>函数来获取进程信息。父进程可以选择调用<code>wait()</code>函数族中的4个函数之一。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pid_t</span> wait(<span class="keyword">int</span> *status);</span><br><span class="line"><span class="keyword">pid_t</span> waitpid(<span class="keyword">pid_t</span> pid,<span class="keyword">int</span> *status,<span class="keyword">int</span> options);</span><br><span class="line"><span class="keyword">pid_t</span> wait3(<span class="keyword">int</span> *status,<span class="keyword">int</span> options,struct rusage*rusage);</span><br><span class="line"><span class="keyword">pid_t</span> wait4(<span class="keyword">pid_t</span> pid,<span class="keyword">int</span> * status,<span class="keyword">int</span> options,struct rusage *rusage);</span><br></pre></td></tr></table></figure><p>每个函数又会调用系统调用<code>sys_wait4</code>，而<code>sys_wait4</code>只做一些错误检查，随后调用<code>do_wait()</code>函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">long</span> <span class="title">do_wait</span><span class="params">(<span class="keyword">pid_t</span> pid,<span class="keyword">int</span> options,struct signinfo _user *infop,<span class="keyword">int</span> _user *stat_addr,struct rusage _user *ru)</span></span>;</span><br></pre></td></tr></table></figure><p>其中参数<code>pid</code>表示目标进程的<code>pid</code>，<code>options</code>表示传递给该函数的标志，<code>infop</code>指向进程的信号信息的指针，<code>stat_addr</code>表示子进程退出状态应存放的地址，<code>ru</code>表示子进程资源使用信息应存放的地址。<code>do_wait()</code>函数的处理流程如下:</p><ul><li>把当前进程放到等待队列中，设置进程的状态为<code>TASK_INTERRUPRIBLE</code></li><li>检查进程的每个子进程的状态。如果进程正在睡眠、就绪或者运行，则什么都不做；如果进程停止或僵死，调用<code>wait_task_zombie()</code>函数，对僵死进程进行处理。</li><li>将进程的状态再一次置为<code>TASK_RUNNING</code>，从等待队列中删除该进程。</li></ul></li></ol><h2 id="五、线程的实现"><a href="#五、线程的实现" class="headerlink" title="五、线程的实现"></a>五、线程的实现</h2><ol><li><h3 id="用户线程"><a href="#用户线程" class="headerlink" title="用户线程"></a>用户线程</h3><p>&emsp;&emsp;线程的概念是现代操作系统中比较重要的一个概念，线程的引入实现了程序的并发执行，改善了资源的利用率，并提高了系统的吞吐量，通常情况下将线程看做是进程内的一个执行单元，一般定义为：线程是进程内的一个相对独立的、可独立调度和指派的执行单元。进程是资源管理的最小单位，线程时程序执行的最小单位。在操作系统设计上，从进程演化出线程，最主要的目的就是更好地支持SMP(对称多处理)以及减小（进程/线程）上下文切换开销。</p><p>&emsp;&emsp;在Linux中线程的实现比较特殊，它不像其他操作系统将进程与线程严格分开对待和处理，并在系统内核中提供专门的支持线程的机制，而是将系统中所有的线程都当作进程来实现的，在内核中没有准备一个特定的数据结构来表示线程，也没有为线程定义它们自己的调度策略，相反在Linux中线程仅仅是被看作一个与其他进程共享某些资源的进程。</p><p>&emsp;&emsp;正是由于Linux并没有将线程作为一个单独的对象来对待，在Linux中创建一个线程与一个进程非常相似，唯一的区别就是调用特定的函数的时候所传递的参数不同，在Linux中可以通过系统调用<code>clone()</code>来创建一个线程，它与创建进程的区别就在于调用<code>clone()</code>的时候需要传递一些参数来指定需要共享的资源。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clone(CLONE_VM|CLONE_FS|CLONE_FILES|CLONE_SIGHAND,<span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;上面的代码产生的结果和调用<code>fork()</code>差不多，只是“父子俩”共享地址空间、文件系统资源、文件描述符和信号处理程序。</p></li><li><h3 id="内核线程"><a href="#内核线程" class="headerlink" title="内核线程"></a>内核线程</h3></li></ol><p>&emsp;&emsp;内核经常需要在后台执行一些操作。这种任务可以通过内核线程完成——独立运行在内核空间的标准进程。内核线程和普通进程间的区别在于内核线程没有独立的地址空间，它们只是在内核空间运行，从来不切换到用户空间去。内核线程和普通进程一样，可以被调度，也可以被抢占。</p><p>&emsp;&emsp;Linux确实会把一些任务交给内核线程去做，像<code>pdflush</code>和<code>ksoftrqd</code>这些任务就是明显的例子。这些线程在系统启动时由另外一些内核线程启动。实际上，内核线程也只能由其他内核线程创建。内核通过<code>kernel_thread()</code>函数来创建内核线程，该函数的实现与体系结构有关。在x86体系结构中，该函数定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kernel_thread</span><span class="params">(<span class="keyword">int</span>(*fn)(<span class="keyword">void</span>*),<span class="keyword">void</span>* arg,<span class="keyword">unsigned</span> <span class="keyword">long</span> flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/*声明一个寄存器变量，并对其进行初始化*/</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pt_regs</span> <span class="title">regs</span>;</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;regs,<span class="number">0</span>,<span class="keyword">sizeof</span>(regs));</span><br><span class="line">    regs.ebx=(<span class="keyword">unsigned</span> <span class="keyword">long</span>)fn;</span><br><span class="line">    regs.edx=(<span class="keyword">unsigned</span> <span class="keyword">long</span>)arg;</span><br><span class="line">    regs.xds=_USER_DS;</span><br><span class="line">    regs.xes=_USER_DS;</span><br><span class="line">    regs.xfs=_KERNEL_PERCPU;</span><br><span class="line">    regs.orig_eax=<span class="number">-1</span>;</span><br><span class="line">    regs.eip=(<span class="keyword">unsigned</span> <span class="keyword">long</span>)kernel_thread_helper;</span><br><span class="line">    regs.xcs=_KERNEL_CS|get_kernel_rpl();</span><br><span class="line">    regs.eflags=x86_EFLAGS_IF|X86_EFLAGS_SF|X86_EFLAGS_PF|<span class="number">0X2</span>;</span><br><span class="line">    <span class="comment">/*调用do_fork()函数创建一个内核线程*/</span></span><br><span class="line">    <span class="keyword">return</span> do_fork(flags|CLONE_VM|CLONE_UNTRACED,<span class="number">0</span>,&amp;regs,<span class="number">0</span>,<span class="literal">NULL</span>,<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;三、进程创建&quot;&gt;&lt;a href=&quot;#三、进程创建&quot; class=&quot;headerlink&quot; title=&quot;三、进程创建&quot;&gt;&lt;/a&gt;三、进程创建&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;h3 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; tit
      
    
    </summary>
    
      <category term="Linux内核" scheme="http://wanqbin.xyz/categories/Linux%E5%86%85%E6%A0%B8/"/>
    
    
      <category term="Linux" scheme="http://wanqbin.xyz/tags/Linux/"/>
    
      <category term="Linux进程管理" scheme="http://wanqbin.xyz/tags/Linux%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/"/>
    
      <category term="Linux进程创建" scheme="http://wanqbin.xyz/tags/Linux%E8%BF%9B%E7%A8%8B%E5%88%9B%E5%BB%BA/"/>
    
      <category term="Linux进程终止" scheme="http://wanqbin.xyz/tags/Linux%E8%BF%9B%E7%A8%8B%E7%BB%88%E6%AD%A2/"/>
    
  </entry>
  
  <entry>
    <title>Linux进程管理（一）</title>
    <link href="http://wanqbin.xyz/2019/08/06/Linux%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>http://wanqbin.xyz/2019/08/06/Linux进程管理（一）/</id>
    <published>2019-08-06T12:31:00.000Z</published>
    <updated>2019-08-07T03:47:06.505Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、进程描述"><a href="#一、进程描述" class="headerlink" title="一、进程描述"></a>一、进程描述</h2><p>&emsp;&emsp;进程的定义：进程是可并发执行的程序在一个数据集合上的运行过程。进程具有动态性、并发性、独立性、异步性等基本特征。</p><p>&emsp;&emsp;为了使参与并发执行的每个程序（含数据）都能独立地运行，在操作系统中必须为之配置一个专门的数据结构，称为进程控制块（PCB）。系统利用PCB来描述进程的基本情况和活动过程，进而控制和管理进程。这样，由程序段、相关数据段和PCB三部分便构成了进程实体。进程的程序段就是该进程所对应静态程序实体在进程地址空间中的映像，而数据段就是进程数据工作集合在进程地址空间中的映像。</p><p>&emsp;&emsp;进程控制块是系统为了管理进程而设置的专门数据结构，用于记录进程的外部特征，描述进程的运动变化过程；它包含了有关进程的描述信息、控制信息以及资源信息，是进程动态特征的集中反映。因此，系统同利用PCB来控制和管理进程。PCB是系统感知进程存在的唯一标志，所以进程与PCB是一一对应的。也就是说，进程的创建以PCB的产生为标志，进程的消亡以PCB的删除为标志。</p><h3 id="1-Linux进程描述符"><a href="#1-Linux进程描述符" class="headerlink" title="1.Linux进程描述符"></a>1.Linux进程描述符</h3><p>&emsp;&emsp;在Linux中，PCB使用<code>task_struct</code>结构来描述，该结构定义在&lt;Linux/sched.h&gt;文件中，称为Linux进程描述符。该描述符结构<code>task_struct</code>存放在任务对内的双向链表<code>task_list</code>中，当有新的程序创建的时候，系统从内存中分配一个新的<code>task_struct</code>结构，并把它放到双向链表中，为了便于查找，系统用全局指针<code>current</code>指向当前运行进程的<code>task_struct</code>。</p><p>&emsp;&emsp;进程描述符<code>task_struct</code>结构包括了许多字段，下面按照字段进程管理过程中的不同作用，分为以下几类来介绍其中的基本功能。</p><ul><li>进程的基本属性</li><li>进程之间的关系</li><li>调度相关</li><li>进程地址空间</li><li>进程的文件系统信息</li><li>进程的信号处理</li><li>进程的访问权限</li><li>资源限制</li></ul><h4 id="1）进程的基本属性"><a href="#1）进程的基本属性" class="headerlink" title="1）进程的基本属性"></a>1）进程的基本属性</h4><ul><li><p><code>volatile long state</code></p><p>用于保存进程的状态，在进程的生命期内，可以从该域获得自己的状态，在2.6中进程可以有以下几种状态：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TASK_RUNNING 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TASK_INTERRUPTIABLE 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TASK_UNINTERRUPTIBLE 2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TASK_STOPPED 4</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TASK_TRACED 8</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EXIT_ZOMBIE 16</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EXIT_DEAD 32</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TASK_DEAD 64</span></span><br></pre></td></tr></table></figure><p><code>TASK_RUNNING</code>：进程当前正在运行，或者正在运行队列中等待调度</p><p><code>TASK_INTERRUPTIABLE</code>：进程处于睡眠状态，正在等待某些事件发生。进程可以被信号中断。进程被显式唤醒或接收到信号之后，将转变为<code>TASK_RUNNING</code>状态。</p><p><code>TASK_UNINTERRUPTIBLE</code>：进程状态类似<code>TASK_INTERRUPTIABLE</code>，只是它不会处理信号。中断处于这种状态的进程是不合适的，因为它可能正在完成某些重要的任务。当它所等待的事件发生时，进程将被唤醒。</p><p><code>TASK_STOPPED</code>：进程已中止执行，它没有运行，并且不能运行，接收到<code>SIGSTOP</code>和<code>SIGSTP</code>等信号时，进程将进入这种状态。接收到<code>SIGCONT</code>信号之后，进程将再次变得可运行。</p><p><code>TASK_TRACED</code>：正在被调试程序等其他进程监控时，进程将进入这种状态。</p><p><code>EXIT_ZOMBIE</code>:进程已终止，它正等待其父进程收集关于它的一些统计信息。</p><p><code>EXIT_DEAD</code>:最终状态，将进程从系统中删除时，它将会进入此状态，因为其父进程已经通过<code>wait4()</code>和<code>waitpid()</code>调用收集了所有统计信息。</p><p><code>TASK_DEAD</code>：表示已经退出且不需要父进程回收的进程的状态。</p><p><img src="/2019/08/06/Linux进程管理（一）/Linux.PNG" alt="Linux进程状态转换图"></p></li><li><p><code>atomic_t usage</code></p><p>表示对该结构的引用次数，在进程退出时，只有当对该结构的引用次数为0时，才可以删除该结构。</p></li><li><p><code>int lock_depth</code></p><p>表示大内核锁深度，主要用于实现内核的同步机制。</p></li><li><p><code>pid_t pid</code></p><p>进程标识符，系统通过进程标识符唯一地标识一个进程。<code>pid_t</code>是一个隐含类型，实际上就是一个int类型，为了与老版本的UNIX和Linux兼容，pid的最大默认值为32768(short int短整型数的最大值).如果需要更大的取值范围，可以修改<code>/proc/sys/kernel/pid_max</code>，从而提高进程数的上限。</p></li><li><p><code>struct pid_link pids[PIDTYPE_MAX]</code></p><p>标识该进程的pid所对应的哈希链表。</p></li><li><p><code>pid_t tgid</code></p><p>表示线程组的ID</p></li><li><p><code>unsigned int flags</code></p><p>定义了该进程的特殊属性，flags的值定义在Linux/sched.h中。</p></li><li><p><code>int exit_code, exit_signal</code></p><p>系统强行退出时发出的信号，父进程通过这两个值来获取子进程的退出状态。exit_code表示进程的退出值，exit_signal表示进程通过信号被终止的信号值。</p></li><li><p><code>struct Linux_binfmt *binfmt</code></p><p>Linux支持多种可执行文件格式，每种可执行文件格式都定义了一种数据结构，指明程序代码如何被载入内存。</p></li><li><p><code>unsigned int ptrace</code></p><p>当调用ptrace()系统调用时，prtace被设置，ptrace的值定义在linux/ptrace.h中。</p></li><li><p><code>char comm[TASK_COMM_LEN]</code></p><p>通常在命令行调用一个可执行程序来创建进程，当在命令行调用可执行程序的时候用comm表示其命令名称。</p></li></ul><h4 id="2）进程之间的关系"><a href="#2）进程之间的关系" class="headerlink" title="2）进程之间的关系"></a>2）进程之间的关系</h4><ul><li><p><code>struct task_struct *group_leader</code></p><p>每个进程组都有一个被定义为该组领头的进程，如果进程是某个组的成员，<code>group_leader</code>则是一个指向其组领头的进程描述符的指针，组领头进程拥有自己的终端设备<code>tty</code>，它就是从这个终端创建的。</p></li><li><p><code>struct list_head thread_group</code></p><p>指向该进程所在进程组的所有进程链表。</p></li><li><p><code>struct task_struct *real_parent</code></p><p>指向当前进程的父进程，如果父进程已经死亡，则指向init进程。</p></li><li><p><code>struct task_struct *parent</code></p><p>指向当前进程的父进程，这个值通常和<code>real_parent</code>相同，但在某些情况会和<code>real_parent</code>不同，例如使用gdb对程序进行调试时，parent指向gdb进程。</p></li><li><p><code>struct list_head children</code></p><p>指向当前进程的子进程的链表</p></li><li><p><code>struct list_head sibling</code></p><p>指向当前进程的兄弟进程的链表。</p></li></ul><p>&emsp;&emsp;Linux系统进程之间存在明显的继承关系，所有的进程都是init进程的后代，内核在系统启动的最后阶段启动此进程。系统中的每个进程都有一个父进程，相应地，每个进程可以拥有0个或多个子进程，拥有相同父进程的所有进程都成为兄弟。</p><h4 id="3）进程调度"><a href="#3）进程调度" class="headerlink" title="3）进程调度"></a>3）进程调度</h4><ul><li><p><code>int prio,static_prio,normal_prio</code></p><p>prio表示进程的动态优先级，取值范围[0,139]。根据进程prio取值的不同，可以把进程分为实时进程（prio$\in$[0,99])和非实时进程（普通进程，prio$\in$[100,139]),针对他们分别由不同的调度策略。动态优先级prio是调度器选择候选进程next的主要依据，数值越小，进程的优先级越高，越早被调度到。</p><p>static_prio是进程的静态优先级，取值范围[0,139]，进程刚被创建时从父进程继承而来，主要用于进程初始时间片的计算和动态优先级prio的计算。</p><p>normal_prio是常规动态优先级，使用“优先级继承协议”时，可能会临时提升进程的优先级，但提升后应该立即返回到其应有的优先级上。这个成员保存的正是这个“应有的优先级”。</p></li><li><p><code>struct list_head run_list</code></p><p>指向就绪队列<code>runqueue</code></p></li><li><p><code>const struct sched_class *sched_class</code></p><p>调度类，该调度类类似一个模块链，协助内核调度程序工作。每个调度程序模块需要实现<code>struct sched_class</code>建议的一组函数。</p></li><li><p><code>struct sched_entitu se</code></p><p>该结构包含了关于调度的完整信息，用于实现对于单个任务或任务组的调度，调度实体可能与进程没有关联。</p></li><li><p><code>undigned int policy</code></p><p>进程的调度策略。包括实时调度和非实时调度。</p></li><li><p><code>cpumask_t cpus_allowed</code></p><p>当存在多个处理器时，用它来指明该进程可以由哪个CPU来执行。</p></li><li><p><code>unsigned int time_slice</code></p><p>进程的时间片余额，相当于内核2.4的<code>counter</code>，但不再直接影响进程的动态优先级。</p></li><li><p><code>unsigned int rt_priority</code></p><p>实时进程的优先级，在调用<code>schedule()</code>时被更新，仅对实时进程有效。</p></li><li><p><code>unsigned long nvcsw,nivcsw</code></p><p>nvcsw，主动的上下文切换数，计算非基于内核抢占的上下文切换数。nivcsw，被动的上下文切换数，计算进程被内核抢占的次数，其值仅当进程从内核返回的时候才增加。</p></li></ul><h4 id="4）进程地址空间和文件系统"><a href="#4）进程地址空间和文件系统" class="headerlink" title="4）进程地址空间和文件系统"></a>4）进程地址空间和文件系统</h4><ul><li><p><code>struct mm_struct *mm,*active_mm</code></p><p>mm是一个指向地址空间和内存管理相关的信息，active_mm是一个指向最近最常使用的地址空间的指针。</p></li><li><p><code>struct fs_struct *fs,*files</code></p><p>fs保存了进程本身与VFS的关系信息，files包含了进程当前所打开的文件列表。</p></li></ul><h4 id="5）进程的信号管理"><a href="#5）进程的信号管理" class="headerlink" title="5）进程的信号管理"></a>5）进程的信号管理</h4><ul><li><p><code>sigset_t saved_sigmask</code></p><p>进程所能接收信号的位掩码。置位表示屏蔽，复位表示不屏蔽。</p></li><li><p><code>struct sigpending pending</code></p><p>存放进程中所有挂起的信号，即记录进程所有已经触发但是还未处理的信号</p></li><li><p><code>struct signal_struct *signal</code></p><p>指向进程信号的描述符</p></li><li><p><code>struct sughand_struct *sighand</code></p><p>指向信号的处理标识符</p></li><li><p><code>int pdeath_signal</code></p><p>是父进程死亡时设置的信号</p></li></ul><h4 id="6）进程的访问权限"><a href="#6）进程的访问权限" class="headerlink" title="6）进程的访问权限"></a>6）进程的访问权限</h4><ul><li><p><code>uid</code>和<code>gid</code></p><p>该进程的用户ID，通常是进程的创建者。因为每个用户可能属于多个组，所以还需要gid来表示该进程属于哪个用户组。</p></li><li><p><code>euid</code>和<code>egid</code></p><p>有效的<code>uid</code>和<code>gid</code>,处于系统安全权限的考虑，运行程序时要检查<code>euid</code>和<code>egid</code>的合法性。通常，uid等于euid，gid等于egid。有时候，系统会赋予一般用户暂时拥有root的uid和gid，以便于进行运作。</p></li><li><p><code>suid</code>和<code>sgid</code></p><p>根据POSIX标准引入的，在系统调用改变uid和gid时，用于保留真正的uid和gid</p></li><li><p><code>fsuid</code>和<code>fsgid</code></p><p>文件系统的uid和gid，用于对文件系统操作时的合法性检查，是Linux独特的标识类型。它们一般分别和euid和egid一致，但在NFS文件系统中NFS服务器需要一个特殊的进程访问文件，这时只修改客户进程的fsuid和fsgid以便确保对于该文件的访问权限。</p></li><li><p><code>struct group_info *group_info</code></p><p>一个Linux进程可以属于多个用户组，group_info保存与这些组相关的信息。</p></li></ul><h2 id="二、进程的组织形式"><a href="#二、进程的组织形式" class="headerlink" title="二、进程的组织形式"></a>二、进程的组织形式</h2><p>&emsp;&emsp;为了高效地对进程进行管理，内核中采用了不同的数据结构将系统中的进程通过不同方式组织起来，以满足进程管理子系统中各种不同需求。</p><ol><li><h3 id="进程链表"><a href="#进程链表" class="headerlink" title="进程链表"></a>进程链表</h3><p>Linux采用了双向链表将系统中的所有进程连接起来，该双向链表基于进程描述符中类型为<code>struct list_head</code>的成员变量<code>tasks</code>。</p><p>Linux内核提供了宏定义<code>for_each_process()</code>用于遍历系统中的每一个进程，该宏定义在需要对系统中每一个进程进行操作时非常有用。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> for_each_process(p)\</span></span><br><span class="line"><span class="keyword">for</span>(p=&amp;init_task;(p=next_task(p))!=&amp;init_task;)</span><br></pre></td></tr></table></figure><p>其中，init_task是系统初始化过程中创建的第一个进程的进程描述符，宏定义next_task表示链表的下一个进程。</p></li></ol><table><thead><tr><th>函数原型</th><th>说明</th></tr></thead><tbody><tr><td>next_task(p)</td><td>当前进程p的下一进程</td></tr><tr><td>add_task(p)</td><td>从p的父进程孩子链表中添加该进程</td></tr><tr><td>remove_task(p)</td><td>从p的父进程孩子链表中删除该进程</td></tr></tbody></table><ol start="2"><li><h3 id="哈希链表"><a href="#哈希链表" class="headerlink" title="哈希链表"></a>哈希链表</h3><p>&emsp;&emsp;内核中使用一个进程描述符来表示一个进程，因此通过进程描述符的地址来访问一个进程再方便不过了。但是POSIX规范中规定，每一个进程要有进程号，而且POSIX规范中规定的系统调用<code>kill()</code>是基于进程号向其他进程发送信号的。这就需要一种机制来高效地完成从进程号到进程描述符地址的转换。Linux内核引入了哈希表来完成进程号到进程描述符<code>task_struct</code>结构的映射。</p><p>&emsp;&emsp;根据进程类型的不同以及效率上的考虑，内核设置了<code>PIDTYPE_MAX</code>（默认值为3）个不同用途的哈希表，哈希表的类型使用枚举类型<code>pid_type</code>进行定义。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> pid_type</span><br><span class="line">&#123;</span><br><span class="line">PIDTYPE_PID,</span><br><span class="line">PIDTYPE_PGID,</span><br><span class="line">PIDTYPE_SID,</span><br><span class="line">PIDTYPE_MAX</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;其中，PIDTYPE_PID代表了进程号（Process ID）哈希表，系统中所有进程（包括线程）的进程号都在该哈希表中有相应的存储位置。PIDTYPE_PGID代表了进程组号（Process）哈希表。PIDTYPE_SID代表了会话号（Session ID）哈希表。</p><p>&emsp;&emsp;为了查找哈希表，需要知道进程号（pid）与哈希表中位置之间的映射函数——哈希函数，定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pid_hashfn(nr,ns)</span></span><br><span class="line">Hash_long((<span class="keyword">unsigned</span> <span class="keyword">long</span>)nr+(<span class="keyword">unsigned</span> <span class="keyword">long</span>)ns,pidhash_shift)</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;其中nr表示进程的pid，ns表示进程的pid命名空间结构<code>pid_namespace</code>,<code>pidhash_shift</code>表示哈希表的大小（1&lt;&lt;pidhash_shift).</p><p>&emsp;&emsp;Linux把通过哈希函数计算得到的哈希值作为数组pid_Hash的下标，并且把哈希值相同的进程组成哈希链表，我们称该链表为哈希链表的主链表。链表中的每个哈希结点（hlist_node结构）表示进程的pid。</p><h4 id="1-相关的数据结构"><a href="#1-相关的数据结构" class="headerlink" title="(1)相关的数据结构"></a>(1)相关的数据结构</h4><p>&emsp;&emsp;随着在Linux内核2.6.24中引入了pid命名空间，结构pid被分割成结构pid和结构upid，其定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">upid</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> nr;<span class="comment">/*pid值*/</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pid_namespace</span> *<span class="title">ns</span>;</span><span class="comment">/*所在的命名空间*/</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hlist_node</span> <span class="title">pid_chain</span>;</span><span class="comment">/*哈希链表节点*/</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pid</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">atomic_t</span> count;<span class="comment">/*引用计数*/</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hlist_head</span> <span class="title">tasks</span>[<span class="title">PIDTYPE_MAX</span>];</span><span class="comment">/*保存所有使用此pid的进程*/</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rcu_head</span> <span class="title">rcu</span>;</span><span class="comment">/*读写锁*/</span></span><br><span class="line">    <span class="keyword">int</span> level;<span class="comment">/*包含upid结构的个数*/</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">upid</span> <span class="title">numbers</span>[1];</span><span class="comment">/*包含的upid结构*/</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在pid结构中，包含一个struct hlist_head类型的成员变量tasks，该变量把具有相同pid值的进程联系起来，如同一个进程组的进程拥有相同的进程组号pgid，此时可以将同一个进程组的进程通过该变量联系起来，我们称该链表尾哈希链表的从链表。</p><p>&emsp;&emsp;在进程描述符<code>task_struct</code>中存在成员变量pids，定义如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pid_link</span> <span class="title">pids</span>[<span class="title">PIDTYPE_MAX</span>];</span></span><br></pre></td></tr></table></figure><p>该成员变量的数据类型<code>pid_link</code>的定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pid_link</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hlist_nnode</span> <span class="title">node</span>;</span><span class="comment">/*从哈希表节点*/</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pid</span> *<span class="title">pid</span>;</span><span class="comment">/*进程对应的pid结构*/</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>该结构是表示进程描述符<code>task_struct</code>与结构<code>pid</code>之间的映射关系。使用这个变量可以根据pid结构找出对应的描述符。</p></li></ol><h4 id="2-哈希表相关的操作"><a href="#2-哈希表相关的操作" class="headerlink" title="(2)哈希表相关的操作"></a>(2)哈希表相关的操作</h4><ul><li><p><code>find_pid()</code>函数根据nr的值，利用哈希函数计算其哈希值，从哈希表pid_Hash中找出哈希链表头节点，然后遍历整个链表，找出哈希值为nr的pid结构。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct pid* <span class="title">find_pidd</span><span class="params">(<span class="keyword">int</span> nr)</span></span>;<span class="comment">/*nr表示进程的pid值*/</span></span><br></pre></td></tr></table></figure></li></ul><ul><li><p><code>pid_task()</code>函数根据pid返回其对应的进程描述符地址</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct task_struct *fastcall <span class="title">pid</span><span class="params">(struct pid* pid,<span class="keyword">enum</span> pid_type type)</span></span>;<span class="comment">/*参数type表示pid的类型*/</span></span><br></pre></td></tr></table></figure></li></ul><ul><li><p><code>transfer_pid()</code>函数使用新的继承描述符new替换旧的进程描述符</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> fastcall <span class="title">transfer_pid</span><span class="params">(struct task_struct *old,struct task_struct *<span class="keyword">new</span> ,<span class="keyword">enum</span> pid_type type)</span></span>;</span><br></pre></td></tr></table></figure></li></ul><ul><li><p><code>attach_pid()</code>函数建立进程描述符task与结构pid之间的映射关系，并将pid添加到相应的哈希链表的开头。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> fastcall <span class="title">attach_pid</span><span class="params">(struct task_struct *task,<span class="keyword">enum</span> pid_type,struct pid* pid)</span></span>;</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>当进程被销毁时需要将进程在哈希表中的映射关系解除，这一过程通过函数<code>detach_pid()</code>完成。该函数首先解除进程描述符与哈希链表的映射关系，然后检查pid结构中是否还包含别的进程，如果不是，则释放pid结构。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> fastcall <span class="title">detach_pid</span><span class="params">(struct task_struct *task,<span class="keyword">enum</span> pid_type type)</span></span>;</span><br></pre></td></tr></table></figure></li></ul><ol start="3"><li><h3 id="等待队列"><a href="#等待队列" class="headerlink" title="等待队列"></a>等待队列</h3><p>&emsp;&emsp;当进程等待一个外部事件发生时，就把它从运行队列中删除并放到等待队列上。</p><p>&emsp;&emsp;在Linux内核中，使用<code>wait_queue_t</code>结构的双向链表来表示一个等待队列。在每个等待队列链表中，以<code>wait_queue_head_t</code>结构表示等待队列的表头，<code>wait_queue_t</code>表示等待队列中的每一个节点，它记录了等待进程所需要的所有信息。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">wait_queue_head</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">spinlock_t</span> lock;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">task_list</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _ <span class="title">wait_queue_head</span> <span class="title">wait_queue_head_t</span>;</span></span><br></pre></td></tr></table></figure><p><code>lock</code>用于保护该等待队列中数据的一致性。</p><p><code>task_list</code>表示睡眠在该等待队列上的所有进程构成的链表的表头</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _ <span class="title">wait_queue</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> flags;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> WQ_FLAG_EXCLUSIVE 0X01</span></span><br><span class="line">    <span class="keyword">void</span> *<span class="keyword">private</span>;</span><br><span class="line">    <span class="keyword">wait_queue_func_t</span> func;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">task_list</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _ <span class="title">wait_queue</span> <span class="title">wait_queue_t</span>;</span></span><br></pre></td></tr></table></figure><p>flags:它指示了该结点对应进程的环形方式，取值为<code>WQ_FLAG_EXCLUSIVE</code>或0；<code>WQ_FLAG_EXCLUSIVE</code>表示节点对应进程对临界区资源使用是排他性的，即进程是独占式进程。</p><p>private:一个私有数据指针，通常保存了睡眠进程的进程描述符task_struct的地址</p><p>func:存放函数的一个结构，这个函数用于唤醒等待队列上的进程。这个域的默认值为<code>default_wake_function()</code>函数，该函数负责将变量private指示的进程设置为可运行状态并插入到合适的运行队列中。</p></li><li><h3 id="当前进程"><a href="#当前进程" class="headerlink" title="当前进程"></a>当前进程</h3><p>&emsp;&emsp;Linux关于进程管理的大部分代码都需要获得或设置当前进程的信息，因此，是否能快速、高效地找到当前进程的描述符task_struct对系统的性能有很大的影响。Linux内核2.2开始采用了宏定义<code>current</code>来获取当前进程的描述符。硬件体系结构把不同，该宏的定义也不同，它必须针对专门的硬件体系结构作处理。有的硬件体系结构可以拿出一个专门的寄存器来存放指向当前进程描述符task_struct的指针，而像x86这样的体系由于寄存器并不富余，就只能在当前内核栈的尾端创建<code>thread_info</code>结构，通过计算偏移间接地查找task_struct结构。</p><p>&emsp;&emsp;在x86体系结构中，每个进程拥有一个内核栈，且通过寄存器<code>%esp</code>即可访问内核栈的元素。基于这种思想，内核首先将当前进程的地址以及需要快速访问的其他状态标记记录在数据结构<code>struct thread info</code>中，然后将该数据结构保存到内核栈空间中的最低地址位置。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">union</span> thread_union</span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">thread_info</span> <span class="title">thread_info</span>;</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="built_in">stack</span>[THREAD_SIZE/<span class="keyword">sizeof</span>(<span class="keyword">long</span>)];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>从该结构中可以看出，内核栈<code>stack</code>和数据结构<code>thread_info</code>共享同一块内存。</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、进程描述&quot;&gt;&lt;a href=&quot;#一、进程描述&quot; class=&quot;headerlink&quot; title=&quot;一、进程描述&quot;&gt;&lt;/a&gt;一、进程描述&lt;/h2&gt;&lt;p&gt;&amp;emsp;&amp;emsp;进程的定义：进程是可并发执行的程序在一个数据集合上的运行过程。进程具有动态性、并发性
      
    
    </summary>
    
      <category term="Linux内核" scheme="http://wanqbin.xyz/categories/Linux%E5%86%85%E6%A0%B8/"/>
    
    
      <category term="Linux" scheme="http://wanqbin.xyz/tags/Linux/"/>
    
      <category term="Linux内核" scheme="http://wanqbin.xyz/tags/Linux%E5%86%85%E6%A0%B8/"/>
    
      <category term="Liinux进程管理" scheme="http://wanqbin.xyz/tags/Liinux%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>关于Linux内核</title>
    <link href="http://wanqbin.xyz/2019/08/06/%E5%85%B3%E4%BA%8ELinux%E5%86%85%E6%A0%B8/"/>
    <id>http://wanqbin.xyz/2019/08/06/关于Linux内核/</id>
    <published>2019-08-06T06:55:00.000Z</published>
    <updated>2019-08-07T03:47:13.725Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、Linux内核特征"><a href="#一、Linux内核特征" class="headerlink" title="一、Linux内核特征"></a>一、Linux内核特征</h2><p>&emsp;&emsp;&emsp;Linux操作系统的内核稳定而高效，以独占的方式执行最底层任务，保证其他程序的正常运行。它是整个系统的核心，具有独特的性质。</p><ol><li><h3 id="接口特色"><a href="#接口特色" class="headerlink" title="接口特色"></a>接口特色</h3><p>&emsp;&emsp;按照POSIX标准，一个可以运行UNIX程序的系统就是UNIX。Linux系统提供和一般UNIX系统相同的标准界面，包括程序级和用户级的界面。</p><p>&emsp;&emsp;在程序级，Linux系统提供标准的UNIX函数库，一个在Linux下开发的应用程序，几乎不经过任何改动就可以在其他UNIX系统下编译执行，完成同样的功能。</p><p>&emsp;&emsp;Linux系统对用户同时提供图形和文本用户界面，文本界面是shell接口，图形界面是X-Window系统。UNIX下的基本命令在Linux下的功能和使用方式都完全相同。而最早在UNIX平台开发的图形用户界面X-Window系统，在Linux系统下运行良好并可以展示与其他版本UNIX系统下相同甚至更好的效果。</p></li><li><h3 id="功能特色"><a href="#功能特色" class="headerlink" title="功能特色"></a>功能特色</h3><p>&emsp;&emsp;Linux系统可以支持多种硬件设备。Linux系统下的驱动程序开发和Windows系统相比简单得多。</p><p>&emsp;&emsp;Linux自身使用的专用的文件系统为Ext3，可以提供方便有效的文件共享及保护机制。同时，它可以通过虚拟文件系统的技术，支持包括微软系列操作系统所使用的FAT16、FAT32和NTFS等文件系统在内的几十种现有的文件系统。</p><p>&emsp;&emsp;Linux系统具有内置的TCP/IP协议栈，可以提供各种高效的网络功能，包括基本的进程间通信、网络文件服务等。</p></li><li><h3 id="结构特征"><a href="#结构特征" class="headerlink" title="结构特征"></a>结构特征</h3><p>&emsp;&emsp;Linux内核基本采用模块结构，单内核模式，这使得系统具有很高的运行效率，但系统的可扩展性及移植性会受到一定的影响。为了解决这个问题，Linux使用了附加模块技术。利用模块技术，可以方便地在内核中添加新的组件或卸载不再需要的内核组件，而且这种装载和卸载可以动态进行。</p><p>&emsp;&emsp;内核模块的引入也带来了对系统性能、内存利用和系统稳定性的一些影响，可动态装卸的模块需要系统增加额外的资源来记录、管理，而装入的内核模块和其他内核部分一样，具有相同的访问权限，差的内核模块会导致系统不稳定甚至崩溃，一些恶意的内核模块可能对系统安全造成极大的威胁。</p><p>&emsp;&emsp;总的来说，Linux内核基本采用模块式结构构造，同时加入动态的模块技术，在追求系统整体效率的同时，实现了内核的动态可伸缩性。这样的结构给系统移植带来一定的负面影响。</p></li></ol><h2 id="二、Linux内核体系结构"><a href="#二、Linux内核体系结构" class="headerlink" title="二、Linux内核体系结构"></a>二、Linux内核体系结构</h2><p>&emsp;&emsp;Linux内核主要由5个模块构成，分别是进程调度模块、内存管理模块、虚拟文件系统模块、进程间通信模块和网络接口模块。</p><p><img src="/2019/08/06/关于Linux内核/1.Linux%E5%86%85%E6%A0%B8%E5%AD%90%E7%B3%BB%E7%BB%9F%E5%8F%8A%E5%85%B6%E5%85%B3%E7%B3%BB.PNG" alt="Linux内核子系统及其关系"></p><p>&emsp;（1）进程调度模块：进程调度模块程序是内核的重要组成部分，它选择下一个要运行的进程并负责控制进程对CPU资源的使用，调度程序采用一种策略使各个进程能够公平合理地访问CPU，同时保证内核能够实时地执行必要的硬件操作。</p><p>&emsp;（2）内存管理模块：内存管理模块负责管理系统，用于确保所有进程能够安全地共享计算机的内存，同时，内存管理模块还支持虚拟内存，使得Linux能够支持进程使用比实际内存空间更大的内存地址空间。</p><p>&emsp;（3）虚拟文件系统模块：虚拟文件系统（VFS）模块通过向所有的外部存储设备提供一个通用的文件接口，隐藏了各种硬件的不同细节，从而提供并支持与其他操作系统兼容的多种文件系统。Linux最好的特征之一就是它支持多种文件系统，用户不仅可以从它自己的文件系统如Ext2，Ext3，ReiserFS等查看文件，而且可以从与其他操作相关的文件系统插卡文件。对用户来说，从一种文件系统到另一种文件系统就没有任何差异，只要是Linux支持的文件系统类型，用户就可以很方便地将它安装到Linux系统中使用。</p><p>&emsp;（4）进程间通信模块：进程间通信模块主要负责进程之间如何进行信息交换或共享信息等工作，Linux提供了多种进程之间的通信机制，其中信号和管道是最基本的两种。除此之外，Linux还提供了System V特有的进程间通信机制，包括消息队列，信号量，共享内存等，为了支持网络通信，Linux还引入了套接字（Socket）机制。</p><p>&emsp;（5）网络接口模块：网络接口模块提供对多种网络通信标准的访问并支持许多网络硬件，网络接口分为网络协议和网络驱动程序，其中网络协议部分负责实现网络传输协议，网络驱动程序部分负责与硬件设备的通信。</p><p>&emsp;（6）进程调度与内存管理模块之间的关系：这两个子系统互相依赖。在多道程序环境下，程序要运行必须为之创建进程，而创建进程的第一件事情就是将程序和数据装入内存。</p><p>&emsp;（7）进程间通信与内存管理之间的关系：进程间通信子系统要依赖内存管理支持共享内存机制，这种机制允许两个进程除了拥有自己的私有空间，还可以存取共同的内存区域。</p><p>&emsp;（8）虚拟文件系统与网络接口和内存管理之间的关系：虚拟文件系统利用网络接口支持网络文件系统（NFS），也利用内存管理支持RAMDISK设备。</p><p>&emsp;（9）内存管理与虚拟文件系统之间的关系：内存管理利用虚拟文件系统支持交换，交换进程(swapd)定期由调度程序调度，这也是内存管理依赖于进程调度的唯一原因。当一个进程存取的内存映射被换出时，内存管理向文件系统发出请求，同时，挂起当前正在运行的进程。</p><h2 id="三、单内核与微内核"><a href="#三、单内核与微内核" class="headerlink" title="三、单内核与微内核"></a>三、单内核与微内核</h2><p>&emsp;&emsp;微内核（MicroKernel Kernel）:在微内核中，大部分内核都作为独立的进程在特权状态下运行，它们通过消息传递进行通信。在典型情况下，每个概念模块都有一个进程。因此，如果在设计中有一个系统调用模块，那么就必然有一个相应的进程来接收系统调用，并和能够执行系统调用的其他进程（或模块）通信以完成所需任务。</p><p>&emsp;&emsp;微内核设计的一个优点是在不影响系统其他部分的情况下，更高效地实现代替现有的文件系统模块的工作将会更加容易。我们甚至可以在系运行时将开发出的新系统模块或者需要替换现有模块的模块直接而且迅速地加入系统。另外一个优点是不需要的模块将不会被加载到内存中，因此微内核就可以更有效地利用内存。</p><p>&emsp;&emsp;单内核（Monolithic kernel):单内核是一个很大的进程。它的内部又可以被分为若干模块（或者是层次或其他）。但是在运行的时候，它是一个独立的二进制大映像。其模块间的通信是通过直接调用其他模块中的函数实现的，而不是消息传递。</p><p>&emsp;&emsp;单内核的支持者声称微内核的消息传递开销引起了效率的损失，微内核的支持者则认为因此而增加的内核设计的灵活性和可维护性可以弥补任何损失。</p><p>&emsp;&emsp;Linux是一个单内核结构，也就是说，Linux运行在单独的内核地址空间。同时吸收了微内核的优点：模块化设计，支持动态装载内核模块。Linux还避免了微内核设计上的缺陷，让一切都运行在内核态，直接调用函数，无需消息传递。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、Linux内核特征&quot;&gt;&lt;a href=&quot;#一、Linux内核特征&quot; class=&quot;headerlink&quot; title=&quot;一、Linux内核特征&quot;&gt;&lt;/a&gt;一、Linux内核特征&lt;/h2&gt;&lt;p&gt;&amp;emsp;&amp;emsp;&amp;emsp;Linux操作系统的内核稳定而高
      
    
    </summary>
    
      <category term="Linux内核" scheme="http://wanqbin.xyz/categories/Linux%E5%86%85%E6%A0%B8/"/>
    
    
      <category term="Linux" scheme="http://wanqbin.xyz/tags/Linux/"/>
    
      <category term="微内核" scheme="http://wanqbin.xyz/tags/%E5%BE%AE%E5%86%85%E6%A0%B8/"/>
    
      <category term="单内核" scheme="http://wanqbin.xyz/tags/%E5%8D%95%E5%86%85%E6%A0%B8/"/>
    
      <category term="操作系统" scheme="http://wanqbin.xyz/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>map容器</title>
    <link href="http://wanqbin.xyz/2019/08/03/map%E5%AE%B9%E5%99%A8/"/>
    <id>http://wanqbin.xyz/2019/08/03/map容器/</id>
    <published>2019-08-03T08:42:00.000Z</published>
    <updated>2019-08-03T09:07:30.397Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、map容器概述"><a href="#一、map容器概述" class="headerlink" title="一、map容器概述"></a>一、map容器概述</h2><p>&emsp;&emsp;map的特性是，所有元素都会根据元素的键值被自动排序。map所有元素都是<code>pair</code>，同时拥有实值(value)和键值(key)。pair的第一元素被视为键值，第二元素被视为实值。map并不允许两个元素拥有相同的键值。</p><p>&emsp;&emsp;我们不可以通过map的迭代器改变map的键值，因为map的键值关系到map元素的排列规则，任意改变map键值将会严重破坏map组织。如果想要修改元素的实值，是可以的。</p><p>&emsp;&emsp;map和list拥有相同的某些性质，当对它的容器元素进行新增操作或者删除操作时，操作之前的所有迭代器，在操作完成之后依然有效，当然被删除的那个元素的迭代器必然是个例外。</p><p>&emsp;&emsp;multimap和map的操作类似，唯一区别是multimap键值可重复。</p><p>&emsp;&emsp;map和multimap都是以RB-tree为底层机制。又由于map所开放的各种操作接口，RB-tree也都提供了，所以几乎所有map操作行为的，都只是转调用RB-tree的操作行为而已。</p><h2 id="二、map-multimap容器常用API"><a href="#二、map-multimap容器常用API" class="headerlink" title="二、map/multimap容器常用API"></a>二、map/multimap容器常用API</h2><ul><li>map构造函数</li></ul>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">map</span>&lt;T1,T2&gt; mapTT;<span class="comment">//map默认构造函数</span></span><br><span class="line"><span class="built_in">map</span>(<span class="keyword">const</span> <span class="built_in">map</span>&amp;<span class="built_in">map</span>);<span class="comment">//拷贝构造函数</span></span><br></pre></td></tr></table></figure><ul><li>map赋值操作</li></ul>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">map</span>&amp;<span class="keyword">operator</span>=(<span class="keyword">const</span> <span class="built_in">map</span>&amp;mp);<span class="comment">//重载等号操作符</span></span><br><span class="line">swap(mp);<span class="comment">//交换两个集合容器</span></span><br></pre></td></tr></table></figure><ul><li>map大小操作</li></ul>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">size();<span class="comment">//返回容器中元素的数目</span></span><br><span class="line">empty();<span class="comment">//判断容器是否为空</span></span><br></pre></td></tr></table></figure><ul><li>map插入数据元素操作</li></ul>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">map</span>.insert(<span class="number">1</span>);<span class="comment">//往容器中插入元素，返回pair&lt;iterator,bool&gt;</span></span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>,<span class="built_in">string</span>&gt;mapStu;<span class="comment">//通过pair方式插入对象</span></span><br><span class="line">mapStu.insert(pair&lt;<span class="keyword">int</span>,<span class="built_in">string</span>&gt;(<span class="number">3</span>,<span class="string">"Aoki"</span>));<span class="comment">//通过pair方式插入对象</span></span><br><span class="line">mapStu.insert(make_pair(<span class="number">-1</span>,<span class="string">"Aoki"</span>));<span class="comment">//通过value_type的方式插入对象</span></span><br><span class="line">mapStu.insert(<span class="built_in">map</span>&lt;<span class="keyword">int</span>,<span class="built_in">string</span>&gt;::value_type(<span class="number">1</span>,<span class="string">"Aoki"</span>));</span><br><span class="line">mapStu[<span class="number">3</span>]=<span class="string">"Aoki"</span>;</span><br><span class="line">mapStu[<span class="number">5</span>]=<span class="string">"青木"</span>;</span><br></pre></td></tr></table></figure><ul><li>map删除操作</li></ul>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">clear();<span class="comment">//删除所有元素</span></span><br><span class="line">erase(pos);<span class="comment">//删除pos迭代器所指元素，返回下一个元素的迭代器</span></span><br><span class="line">erase(beg,end);<span class="comment">//删除区间[beg,end)的所有元素，返回下一个元素的迭代器</span></span><br><span class="line">erase(keyElem);<span class="comment">//删除容器中key为keyElem的对组</span></span><br></pre></td></tr></table></figure><ul><li>map查找操作</li></ul>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">find(key);<span class="comment">//查找键key是否存在，若存在，返回该键的元素的迭代器，若不存在，返回map.end()</span></span><br><span class="line">count(keyElem);<span class="comment">//返回容器中key为keyElem的对组个数。对于map来说，要么是0，要么是1，对于multimap来说，值可能大于1</span></span><br><span class="line">lower_bound(keyElem);<span class="comment">//返回第一个key&gt;=keyElem元素的迭代器</span></span><br><span class="line">upper_bound(keyElem);<span class="comment">//返回第一个key&gt;keyElem元素的迭代器</span></span><br><span class="line">equal_range(keyElem);<span class="comment">//返回容器中key与keyElem相等的上下限的两个迭代器</span></span><br></pre></td></tr></table></figure><h2 id="三、map容器示例"><a href="#三、map容器示例" class="headerlink" title="三、map容器示例"></a>三、map容器示例</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt; m1;</span><br><span class="line">m1.insert(make_pair(<span class="number">1</span>, <span class="string">"张三"</span>));</span><br><span class="line">m1.insert(make_pair(<span class="number">2</span>, <span class="string">"李四"</span>));</span><br><span class="line">m1.insert(pair&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt;(<span class="number">3</span>, <span class="string">"李五"</span>));</span><br><span class="line">m1.insert(<span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt;::value_type(<span class="number">4</span>, <span class="string">"张六"</span>));</span><br><span class="line">m1[<span class="number">5</span>] = <span class="string">"张四"</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt;::iterator it = m1.begin(); it != m1.end(); it++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"ID:"</span> &lt;&lt; it-&gt;first &lt;&lt; <span class="string">"  姓名："</span> &lt;&lt; it-&gt;second &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (m1.empty())</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"map为空"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"size="</span> &lt;&lt; m1.size() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果：</p><p><img src="/2019/08/03/map容器/test01.PNG" alt="执行结果"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;m2;</span><br><span class="line">m2.insert(make_pair(<span class="number">1</span>, <span class="number">10</span>));</span><br><span class="line">m2.insert(make_pair(<span class="number">2</span>, <span class="number">50</span>));</span><br><span class="line">m2.insert(make_pair(<span class="number">3</span>, <span class="number">40</span>));</span><br><span class="line">m2.insert(make_pair(<span class="number">4</span>, <span class="number">60</span>));</span><br><span class="line">m2.insert(make_pair(<span class="number">5</span>, <span class="number">10</span>));</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;::iterator it1 = m2.begin(); it1 != m2.end(); it1++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"key:"</span> &lt;&lt; (*it1).first &lt;&lt; <span class="string">" value:"</span> &lt;&lt; (*it1).second &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">m2.erase(<span class="number">3</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;::iterator it1 = m2.begin(); it1 != m2.end(); it1++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"key:"</span> &lt;&lt; (*it1).first &lt;&lt; <span class="string">" value:"</span> &lt;&lt; (*it1).second &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (m2.find(<span class="number">5</span>) != m2.end())</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"找到了"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"ID:"</span> &lt;&lt; m2.find(<span class="number">5</span>)-&gt;first &lt;&lt; <span class="string">" value:"</span> &lt;&lt; m2.find(<span class="number">5</span>)-&gt;second &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"没有找到"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;::iterator pos = m2.lower_bound(<span class="number">4</span>);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"ID:"</span> &lt;&lt; pos-&gt;first &lt;&lt; <span class="string">" value:"</span> &lt;&lt; pos-&gt;second &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;::iterator pos1 = m2.upper_bound(<span class="number">4</span>);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"ID:"</span> &lt;&lt; pos-&gt;first &lt;&lt; <span class="string">" value:"</span> &lt;&lt; pos-&gt;second &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">pair&lt;<span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;::iterator, <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;::iterator&gt;ret = m2.equal_range(<span class="number">4</span>);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"ID:"</span> &lt;&lt; ret.first-&gt;first &lt;&lt; <span class="string">" value:"</span> &lt;&lt; ret.first-&gt;second &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"ID:"</span> &lt;&lt; ret.second-&gt;first &lt;&lt; <span class="string">" value:"</span> &lt;&lt; ret.second-&gt;second &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果：</p><p><img src="/2019/08/03/map容器/test02.PNG" alt="执行结果"></p><h2 id="四、multimap示例"><a href="#四、multimap示例" class="headerlink" title="四、multimap示例"></a>四、multimap示例</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test03</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">multimap</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;mulmap;</span><br><span class="line">mulmap.insert(make_pair(<span class="number">1</span>, <span class="number">15</span>));</span><br><span class="line">mulmap.insert(make_pair(<span class="number">1</span>, <span class="number">20</span>));</span><br><span class="line">mulmap.insert(make_pair(<span class="number">1</span>, <span class="number">25</span>));</span><br><span class="line">mulmap.insert(make_pair(<span class="number">1</span>, <span class="number">5</span>));</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">multimap</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;::iterator it0 = mulmap.begin(); it0 != mulmap.end(); it0++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"ID："</span> &lt;&lt; it0-&gt;first &lt;&lt; <span class="string">"  value:"</span> &lt;&lt; it0-&gt;second &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"键值为1的对组的个数："</span> &lt;&lt; mulmap.count(<span class="number">1</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果：</p><p><img src="/2019/08/03/map容器/test03.PNG" alt="执行结果"></p><h2 id="五、源码地址"><a href="#五、源码地址" class="headerlink" title="五、源码地址"></a>五、源码地址</h2><p>​            <a href="https://github.com/Aoki-Wang/CheckStation/tree/master/STL/map" target="_blank" rel="noopener">map示例源码</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、map容器概述&quot;&gt;&lt;a href=&quot;#一、map容器概述&quot; class=&quot;headerlink&quot; title=&quot;一、map容器概述&quot;&gt;&lt;/a&gt;一、map容器概述&lt;/h2&gt;&lt;p&gt;&amp;emsp;&amp;emsp;map的特性是，所有元素都会根据元素的键值被自动排序。map
      
    
    </summary>
    
      <category term="STL" scheme="http://wanqbin.xyz/categories/STL/"/>
    
    
      <category term="STL" scheme="http://wanqbin.xyz/tags/STL/"/>
    
      <category term="map容器" scheme="http://wanqbin.xyz/tags/map%E5%AE%B9%E5%99%A8/"/>
    
      <category term="multimap" scheme="http://wanqbin.xyz/tags/multimap/"/>
    
      <category term="C++" scheme="http://wanqbin.xyz/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>set容器</title>
    <link href="http://wanqbin.xyz/2019/08/03/set%E5%AE%B9%E5%99%A8/"/>
    <id>http://wanqbin.xyz/2019/08/03/set容器/</id>
    <published>2019-08-03T07:05:00.000Z</published>
    <updated>2019-08-03T07:30:56.829Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、关联式容器"><a href="#一、关联式容器" class="headerlink" title="一、关联式容器"></a>一、关联式容器</h2><p>&emsp;&emsp;标准的STL关联式容器分为set(集合)和map(映射表)两大类，以及这两大类的衍生体<code>multiset</code>（多键集合）和<code>multimap</code>（多键映射表）。这些容器的底层机制均以<code>RB-tree</code>(红黑树)完成。RB-tree也是一个独立的容器，但并不开放给外界使用。</p><p>&emsp;所谓关联式容器，观念上类似关联式数据库（实际上则简单的多）：每笔数据（每个元素）都有一个键值（key）和一个实值（value）。当元素被插入到关联式容器中时，容器内部结构便依照其键值大小，以某种特定规则将这个元素放置在适当的位置。关联式容器没有所谓头尾，所以不会有所谓<code>push_back()、push_front()、pop_back()、pop_front()、begin()、end()</code>这样的操作行为。</p><p>&emsp;&emsp;一般而言，关联式容器的内部结构是一个平衡二叉树，以便获得良好的搜寻效率。平衡二叉树有许多种类型，包括AVL-tree、RB-tree、AA-tree,其中最被广泛运用于STL的是RB-tree(红黑树)。</p><h2 id="二、set"><a href="#二、set" class="headerlink" title="二、set"></a>二、set</h2><p>&emsp;&emsp;set的特性是，所有元素都会根据元素的键值自动被排序。set不像map那样可以同时拥有实值(value)和键值(key)，set元素的键值就是实值，实值就是键值。set不允许两个元素有相同的键值。</p><p>&emsp;&emsp;我们不可以通过set的迭代器改变set元素的值，因为set元素的值就是其键值，关系到set元素的排序规则。如果任意改变set元素值，会严重破坏set组织。在set源代码中，<code>set&lt;T&gt;::iterator</code>被定义为底层RB-tree的<code>const_iterator</code>。换句话说，set iterator是一种<code>constanit iterators</code>。</p><p>&emsp;&emsp;set拥有与list相同的某些性质：当客户端对它进行元素新增操作(insert)或删除操作(erase)时，操作之前的所有迭代器，在操作完成之后都依然有效。当然被删除的那个元素的迭代器必然是个例外。</p><p>&emsp;&emsp;由于RB-tree是一种平衡二叉树，自动排序的效果很不错，所以标准的STL set即以RB-tree为底层机制。又由于set所开放的各种操作接口，RB-tree也都提供了，所以几乎所有的set操作行为，都只是转调RB-tree的操作行为而已。</p><h4 id="1）set常用API"><a href="#1）set常用API" class="headerlink" title="1）set常用API"></a>1）set常用API</h4><ul><li>set构造函数</li></ul>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span>&lt;T&gt; st;<span class="comment">//set默认构造函数</span></span><br><span class="line"><span class="built_in">multiset</span>&lt;T&gt; mst;<span class="comment">//multiset默认构造函数</span></span><br><span class="line"><span class="built_in">set</span>(<span class="keyword">const</span> <span class="built_in">set</span>&amp;st);<span class="comment">//拷贝构造函数</span></span><br></pre></td></tr></table></figure><ul><li>set赋值操作</li></ul>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span>&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> <span class="built_in">set</span>&amp; st);<span class="comment">//重载等号操作符</span></span><br><span class="line">swap(st);<span class="comment">//交换两个集合容器</span></span><br></pre></td></tr></table></figure><ul><li>set大小操作</li></ul>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">size();<span class="comment">//返回容器中元素的数目</span></span><br><span class="line">empty();<span class="comment">//判断容器是否为空</span></span><br></pre></td></tr></table></figure><ul><li>set插入和删除操作</li></ul>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">insert(elem);<span class="comment">//在容器中插入元素</span></span><br><span class="line">clear();<span class="comment">//清除所有元素</span></span><br><span class="line">erase(pos);<span class="comment">//删除pos迭代器所指的元素，返回下一个元素的迭代器</span></span><br><span class="line">erase(beg,end);<span class="comment">//删除区间[beg,end)的所有元素，返回下一个元素的迭代器</span></span><br><span class="line">erase(elem);<span class="comment">//删除容器中值为elem的元素</span></span><br></pre></td></tr></table></figure><ul><li>set查找操作</li></ul>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">find(key);<span class="comment">//查找键key是否存在，若存在，返回该键的元素的迭代器；若不存在，返回set.end()</span></span><br><span class="line">count(key);<span class="comment">//查找键key的元素个数</span></span><br><span class="line">lower_bound(keyElem);<span class="comment">//返回第一个key&gt;=keyElem元素的迭代器</span></span><br><span class="line">upper_bound(keyElem);<span class="comment">//返回第一个key&gt;keyElem元素的迭代器</span></span><br><span class="line">equal_range(keyElem);<span class="comment">//返回容器中key与keyElem相等的上下限的两个迭代器</span></span><br></pre></td></tr></table></figure><h4 id="2）示例"><a href="#2）示例" class="headerlink" title="2）示例"></a>2）示例</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; st = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span> &#125;;</span><br><span class="line">DisplaySet(st);<span class="comment">//输出set中的元素</span></span><br><span class="line"><span class="keyword">if</span> (st.empty())</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"set为空"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"size="</span> &lt;&lt; st.size() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">st.erase(st.begin());</span><br><span class="line">DisplaySet(st);</span><br><span class="line">st.erase(<span class="number">6</span>);</span><br><span class="line">DisplaySet(st);</span><br><span class="line">st.insert(<span class="number">15</span>);</span><br><span class="line">st.insert(<span class="number">10</span>);</span><br><span class="line">DisplaySet(st);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果：</p><p><img src="/2019/08/03/set容器/test01.PNG" alt="执行结果"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;st;</span><br><span class="line">st.insert(<span class="number">5</span>);</span><br><span class="line">st.insert(<span class="number">1</span>);</span><br><span class="line">st.insert(<span class="number">9</span>);</span><br><span class="line">st.insert(<span class="number">3</span>);</span><br><span class="line">st.insert(<span class="number">7</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//查找操作</span></span><br><span class="line"><span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;::iterator it1 = st.find(<span class="number">3</span>);</span><br><span class="line"><span class="keyword">if</span> (it1 != st.end())</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"找到了，值为："</span> &lt;&lt; *it1 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"没有找到"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;::iterator it0 = st.find(<span class="number">8</span>);</span><br><span class="line"><span class="keyword">if</span> (it0 != st.end())</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"找到了，值为："</span> &lt;&lt; *it0 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"没有找到"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> num = st.count(<span class="number">2</span>);<span class="comment">//2的个数</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"2的个数为："</span> &lt;&lt; num &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="comment">//lower_bound(keyElem);//返回第一个key&gt;=keyElem元素的迭代器</span></span><br><span class="line"><span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;::iterator pos = st.lower_bound(<span class="number">3</span>);</span><br><span class="line"><span class="keyword">if</span> (pos != st.end())</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"lower_bound(3)的值为："</span> &lt;&lt; *pos &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"没有找到"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//upper_bound(keyElem);//返回第一个key&gt;keyElem元素的迭代器</span></span><br><span class="line"><span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;::iterator it2 = st.upper_bound(<span class="number">3</span>);</span><br><span class="line"><span class="keyword">if</span> (it2 != st.end())</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"找到了upper_bound(3)的值为："</span> &lt;&lt; *it2 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"没有找到"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//equal_range(keyElem);//返回容器中key与keyElem相等的上下限的两个迭代器</span></span><br><span class="line">pair&lt;<span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;::iterator, <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;::iterator&gt;ret = st.equal_range(<span class="number">3</span>);</span><br><span class="line"><span class="keyword">if</span> (ret.first != st.end())</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"找到equal_range中lower_bound的值为："</span> &lt;&lt; *(ret.first) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"没有找到"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (ret.second != st.end())</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"找到equal_range中upper_bound为："</span> &lt;&lt; *(ret.second) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"没有找到"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果：</p><p><img src="/2019/08/03/set容器/test02.PNG" alt="执行结果"></p><h2 id="三、multiset容器"><a href="#三、multiset容器" class="headerlink" title="三、multiset容器"></a>三、multiset容器</h2><p>&emsp;&emsp;multiset特性及用于和set完全相同，唯一的差别在于它允许键值重复。</p><h4 id="1）示例"><a href="#1）示例" class="headerlink" title="1）示例"></a>1）示例</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test03</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">multiset</span>&lt;<span class="keyword">int</span>&gt;muset;</span><br><span class="line">muset.insert(<span class="number">15</span>);</span><br><span class="line">muset.insert(<span class="number">20</span>);</span><br><span class="line">muset.insert(<span class="number">15</span>);</span><br><span class="line">DisplayMultiset(muset);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"元素个数为："</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; muset.size() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果：<br><img src="/2019/08/03/set容器/multiset%E6%89%A7%E8%A1%8C%E7%BB%93%E6%9E%9C.PNG" alt="执行结果"></p><h2 id="四、对组（pair）"><a href="#四、对组（pair）" class="headerlink" title="四、对组（pair）"></a>四、对组（pair）</h2><p>&emsp;&emsp;对组(pair)将一对值组合成一个值，这一对值可以具有不同的数据类型，两个值可以分别用pair的两个公有属性first和second访问。</p><h4 id="1）示例-1"><a href="#1）示例-1" class="headerlink" title="1）示例"></a>1）示例</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Compare</span></span></span><br><span class="line"><span class="class">&#123;</span><span class="comment">//利用仿函数指定排序规则</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(pair&lt;<span class="built_in">string</span>,<span class="keyword">int</span>&gt; p1,pair&lt;<span class="built_in">string</span>,<span class="keyword">int</span>&gt;p2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> p1.second &gt; p2.second;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test04</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">pair&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; p1(<span class="string">"Aoki"</span>, <span class="number">23</span>);</span><br><span class="line">pair&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; p2(<span class="string">"张三"</span>, <span class="number">25</span>);</span><br><span class="line">pair&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; p3(<span class="string">"李四"</span>, <span class="number">26</span>);</span><br><span class="line"><span class="built_in">set</span>&lt;pair&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt;, Compare&gt; pSt;;</span><br><span class="line">pSt.insert(p1);</span><br><span class="line">pSt.insert(p2);</span><br><span class="line">pSt.insert(p3);</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">set</span>&lt;pair&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt;, Compare&gt;::iterator it = pSt.begin(); it != pSt.end(); it++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"姓名："</span> &lt;&lt; it-&gt;first &lt;&lt; <span class="string">"  年龄："</span> &lt;&lt; it-&gt;second &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果：</p><p><img src="/2019/08/03/set容器/test04.PNG" alt="执行结果"></p><h2 id="五、源码地址"><a href="#五、源码地址" class="headerlink" title="五、源码地址"></a>五、源码地址</h2><p>​        <a href="https://github.com/Aoki-Wang/CheckStation/tree/master/STL/Set" target="_blank" rel="noopener">set示例源码</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、关联式容器&quot;&gt;&lt;a href=&quot;#一、关联式容器&quot; class=&quot;headerlink&quot; title=&quot;一、关联式容器&quot;&gt;&lt;/a&gt;一、关联式容器&lt;/h2&gt;&lt;p&gt;&amp;emsp;&amp;emsp;标准的STL关联式容器分为set(集合)和map(映射表)两大类，以及这两大
      
    
    </summary>
    
      <category term="STL" scheme="http://wanqbin.xyz/categories/STL/"/>
    
    
      <category term="C++" scheme="http://wanqbin.xyz/tags/C/"/>
    
      <category term="set容器" scheme="http://wanqbin.xyz/tags/set%E5%AE%B9%E5%99%A8/"/>
    
      <category term="pair" scheme="http://wanqbin.xyz/tags/pair/"/>
    
      <category term="Multiset" scheme="http://wanqbin.xyz/tags/Multiset/"/>
    
      <category term="关联式容器" scheme="http://wanqbin.xyz/tags/%E5%85%B3%E8%81%94%E5%BC%8F%E5%AE%B9%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>选择排序——直接选择排序和堆排序的实现</title>
    <link href="http://wanqbin.xyz/2019/08/02/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F%E2%80%94%E2%80%94%E7%9B%B4%E6%8E%A5%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F%E5%92%8C%E5%A0%86%E6%8E%92%E5%BA%8F%E7%9A%84%E5%AE%9E%E7%8E%B0/"/>
    <id>http://wanqbin.xyz/2019/08/02/选择排序——直接选择排序和堆排序的实现/</id>
    <published>2019-08-02T12:19:00.000Z</published>
    <updated>2019-08-03T02:21:13.001Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、选择排序概述"><a href="#一、选择排序概述" class="headerlink" title="一、选择排序概述"></a>一、选择排序概述</h2><p>&emsp;&emsp;选择排序的基本思想是：不断从待排序的对象集合中选取关键码最小的对象放到已排序对象集合的后面，直到集合这两个所有对象都取完为止。</p><p>&emsp;&emsp;常用的选择排序方法有直接排序法和堆排序法。</p><h2 id="二、直接选择排序的实现"><a href="#二、直接选择排序的实现" class="headerlink" title="二、直接选择排序的实现"></a>二、直接选择排序的实现</h2><p>&emsp;&emsp;直接选择排序是一种简单且直观的排序方法。直接选择排序的思想是：从待排序的对象集合中选择关键码最小的对象，并将它与原始对象集合中的第一个对象交换位置；然后从不包括第一个位置对象的对象集合中选取关键码最小的对象，并将它与原始对象集合中的第二个元素交换位置；如此重复，直到对象集合中只剩下一个对象为止。</p><h3 id="1-直接选择排序的实现"><a href="#1-直接选择排序的实现" class="headerlink" title="1)直接选择排序的实现"></a>1)直接选择排序的实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">DirectSelectSort</span>(<span class="title">T</span> <span class="title">arr</span>[], <span class="title">int</span> <span class="title">n</span>)</span></span><br><span class="line"><span class="class">&#123;</span><span class="comment">//对arr[0]~arr[n-1]进行排序</span></span><br><span class="line">T temp;</span><br><span class="line"><span class="keyword">int</span> CurrentMin;<span class="comment">//当前最小值的位置</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n ; i++)</span><br><span class="line">&#123;</span><br><span class="line">CurrentMin = i;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n ; j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (arr[j] &lt; arr[CurrentMin])</span><br><span class="line">&#123;</span><br><span class="line">CurrentMin = j;<span class="comment">//记录当前最小值的下标</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (CurrentMin != i)</span><br><span class="line">&#123;</span><br><span class="line">temp = arr[i];</span><br><span class="line">arr[i] = arr[CurrentMin];</span><br><span class="line">arr[CurrentMin] = temp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-测试函数"><a href="#2-测试函数" class="headerlink" title="2)测试函数"></a>2)测试函数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> arr[] = &#123; <span class="number">64</span>,<span class="number">55</span>,<span class="number">7</span>,<span class="number">5</span>,<span class="number">89</span>,<span class="number">15</span>,<span class="number">22</span>,<span class="number">25</span> &#125;;</span><br><span class="line"><span class="keyword">int</span> n = <span class="keyword">sizeof</span>(arr) / <span class="keyword">sizeof</span>(arr[<span class="number">0</span>]);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"原始数组为："</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; arr[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">DirectSelectSort&lt;<span class="keyword">int</span>&gt;(arr, n);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"排序结果为："</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; arr[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3）执行结果"><a href="#3）执行结果" class="headerlink" title="3）执行结果"></a>3）执行结果</h3><p><img src="/2019/08/02/选择排序——直接选择排序和堆排序的实现/%E7%9B%B4%E6%8E%A5%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F%E5%AE%9E%E7%8E%B0.PNG" alt="直接选择排序执行结果"></p><h3 id="4）时空复杂度分析"><a href="#4）时空复杂度分析" class="headerlink" title="4）时空复杂度分析"></a>4）时空复杂度分析</h3><ul><li>时间复杂度<ul><li>在直接选择排序中，第1次排序要进行n-1次比较，第2次排序要进行n-2次比较，……，第n-1次排序要进行1次比较。所以总比较次数为$\frac{n(n-1)}{2}$</li><li>在各次排序中，对象的移动次数最好为0，最坏为3次。</li><li>时间复杂度为O($n^2$)</li></ul></li><li>空间复杂度<ul><li>直接选择排序算法的空间复杂度为O(1)</li><li>直接选择排序算法是一种稳定的排序方法</li></ul></li></ul><h3 id="5）源码地址"><a href="#5）源码地址" class="headerlink" title="5）源码地址"></a>5）源码地址</h3><p>​        <a href="https://github.com/Aoki-Wang/CheckStation/tree/master/Data%20Structure/Select%20Sort/Direct%20Select%20Sort" target="_blank" rel="noopener">直接插入排序实现源码</a></p><h2 id="三、堆排序的实现"><a href="#三、堆排序的实现" class="headerlink" title="三、堆排序的实现"></a>三、堆排序的实现</h2><p>&emsp;&emsp;堆排序是利用堆数据结构进行的排序方法。堆式结点间数据元素的关键码具有层次次序关系的完全二叉树。堆排序算法的思想是：建立一个堆结构的数组对象，不断删除堆顶对象并依次存于数组后面空出的存储单元中，当n个对象的数组中第n-1个对象被这样操作后，数组中的对象即排好序了。</p><h3 id="1）堆排序的实现"><a href="#1）堆排序的实现" class="headerlink" title="1）堆排序的实现"></a>1）堆排序的实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">HeapSort</span>(<span class="title">T</span> <span class="title">arr</span>[], <span class="title">int</span> <span class="title">n</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">MaxHeap&lt;T&gt; heap(arr, n);</span><br><span class="line">T temp;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--)</span><br><span class="line">&#123;</span><br><span class="line">temp = heap.Delete();</span><br><span class="line">arr[i] = temp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>堆排序的实现借助了之前实现的最大堆，最大堆的堆顶始终是最大值。</p><h3 id="2）测试函数"><a href="#2）测试函数" class="headerlink" title="2）测试函数"></a>2）测试函数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> arr[] = &#123; <span class="number">64</span>,<span class="number">55</span>,<span class="number">7</span>,<span class="number">5</span>,<span class="number">89</span>,<span class="number">15</span>,<span class="number">22</span>,<span class="number">25</span> &#125;;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"原数组元素为："</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">int</span> n = <span class="keyword">sizeof</span>(arr) / <span class="keyword">sizeof</span>(arr[<span class="number">0</span>]);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (<span class="keyword">sizeof</span>(arr) / <span class="keyword">sizeof</span>(arr[<span class="number">0</span>])); i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; arr[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">HeapSort&lt;<span class="keyword">int</span>&gt;(arr, (<span class="keyword">sizeof</span>(arr) / <span class="keyword">sizeof</span>(arr[<span class="number">0</span>])));</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"利用最大堆排序结果："</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; arr[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3）执行结果-1"><a href="#3）执行结果-1" class="headerlink" title="3）执行结果"></a>3）执行结果</h3><p><img src="/2019/08/02/选择排序——直接选择排序和堆排序的实现/%E5%A0%86%E6%8E%92%E5%BA%8F%E5%AE%9E%E7%8E%B0%E7%BB%93%E6%9E%9C.PNG" alt="堆排序执行结果"></p><h3 id="4）时空复杂度分析-1"><a href="#4）时空复杂度分析-1" class="headerlink" title="4）时空复杂度分析"></a>4）时空复杂度分析</h3><ul><li>堆化数组最坏情况的时间复杂度为<code>O(nlgn)</code>，在堆中删除一个元素最坏情况的时间复杂度为<code>O(lgn)</code>。因此，堆排序算法最坏情况的时间复杂度是<code>O(nlgn)</code></li><li>堆排序算法的空间复杂度为<code>O(1)</code>。</li><li>堆排序是一种不稳定的排序方法。</li></ul><h3 id="5）源码地址-1"><a href="#5）源码地址-1" class="headerlink" title="5）源码地址"></a>5）源码地址</h3><p>​        <a href="https://github.com/Aoki-Wang/CheckStation/tree/master/Data%20Structure/Select%20Sort/Heap%20Sort" target="_blank" rel="noopener">堆排序实现源码</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、选择排序概述&quot;&gt;&lt;a href=&quot;#一、选择排序概述&quot; class=&quot;headerlink&quot; title=&quot;一、选择排序概述&quot;&gt;&lt;/a&gt;一、选择排序概述&lt;/h2&gt;&lt;p&gt;&amp;emsp;&amp;emsp;选择排序的基本思想是：不断从待排序的对象集合中选取关键码最小的对象放
      
    
    </summary>
    
      <category term="数据结构" scheme="http://wanqbin.xyz/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="C++" scheme="http://wanqbin.xyz/tags/C/"/>
    
      <category term="排序" scheme="http://wanqbin.xyz/tags/%E6%8E%92%E5%BA%8F/"/>
    
      <category term="选择排序" scheme="http://wanqbin.xyz/tags/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/"/>
    
      <category term="直接选择排序" scheme="http://wanqbin.xyz/tags/%E7%9B%B4%E6%8E%A5%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/"/>
    
      <category term="堆排序" scheme="http://wanqbin.xyz/tags/%E5%A0%86%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>堆——最小堆和最大堆的实现</title>
    <link href="http://wanqbin.xyz/2019/08/02/%E5%A0%86%E2%80%94%E2%80%94%E6%9C%80%E5%B0%8F%E5%A0%86%E5%92%8C%E6%9C%80%E5%A4%A7%E5%A0%86%E7%9A%84%E5%AE%9E%E7%8E%B0/"/>
    <id>http://wanqbin.xyz/2019/08/02/堆——最小堆和最大堆的实现/</id>
    <published>2019-08-02T09:18:00.000Z</published>
    <updated>2019-08-03T01:50:55.285Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、堆概述"><a href="#一、堆概述" class="headerlink" title="一、堆概述"></a>一、堆概述</h2><ul><li>堆(Heap)是结点间数据元素的关键码具有层次次序关系的完全二叉树；</li><li>堆是二叉树的顺序存储结构的一个应用；</li><li>堆可用于应用程序希望能直接访问一个表中的最小或最大数据元素的应用问题；</li><li>堆结构的重要价值在于，在所有能直接访问一个表中的最小或最大数据元素的算法中，堆结构方法是时间效率最高的一种。</li></ul><h2 id="二、堆定义"><a href="#二、堆定义" class="headerlink" title="二、堆定义"></a>二、堆定义</h2><p>&emsp;&emsp;设数据元素是一个有多个域的复合结构，其中有一个称为关键码的域，定义n个数据元素$d_0$、$d_1$、$d_2$、……、$d_{n-1}$所对应的关键码域为$k_0$、$k_1$、$k_2$、……、$k_{n-1}$，假设数据元素$d_0$、$d_1$、$d_2$、……、$d_{n-1}$按完全二叉树的顺序存放在一个一维数组中，当2i+1&lt;n时有：</p><p>$k_i&lt;=k_{2i+1}$($k_i$中的i是元素在数组中的下标)</p><p>当2i+2&lt;n时有：</p><p>$k_i&lt;=k_{2i+2}$($k_i$中的i是元素在数组中的下标)</p><p>这样的数据元素集合称为<code>最小堆</code>。</p><p>与此类似，当2i+1&lt;n时有：</p><p>$k_i&gt;=k_{2i+1}$($k_i$中的i是元素在数组中的下标)</p><p>当2i+2&lt;n时有：</p><p>$k_i&gt;=k_{2i+2}$($k_i$中的i是元素在数组中的下标)</p><p>这样的数据元素集合称为<code>最大堆</code>。</p><p>根据堆的定义可以推知堆有下面两个性质：</p><ul><li>最小堆的根结点时堆中值最小的数据元素，最大堆的根结点时堆中值最大的数据元素，我们称之为堆顶元素</li><li>对于最小堆，从根结点到每个叶结点的路径上，数据元素组成的的序列都是非递减有序的。对于最大堆，从根结点到每个叶结点的路径上，数据元素组成的序列都是非递增有序的</li></ul><h2 id="三、最小堆的实现"><a href="#三、最小堆的实现" class="headerlink" title="三、最小堆的实现"></a>三、最小堆的实现</h2><h4 id="1）最小堆类"><a href="#1）最小堆类" class="headerlink" title="1）最小堆类"></a>1）最小堆类</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">MinHeap</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">MinHeap(<span class="keyword">int</span> maxsize);<span class="comment">//构造函数</span></span><br><span class="line">MinHeap(T arr[], <span class="keyword">int</span> n);<span class="comment">//拷贝构造函数，将n个arr元素堆化</span></span><br><span class="line">~MinHeap();<span class="comment">//析构函数</span></span><br><span class="line"><span class="comment">//最小堆的相关操作</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Insert</span><span class="params">(<span class="keyword">const</span> T&amp; item)</span></span>;<span class="comment">//插入元素item</span></span><br><span class="line"><span class="function">T <span class="title">Delete</span><span class="params">()</span></span>;<span class="comment">//删除堆中最小元素</span></span><br><span class="line"><span class="function">T <span class="title">GetHeapTop</span><span class="params">()</span></span>;<span class="comment">//获取堆顶元素</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">HeapSize</span><span class="params">()</span></span>;<span class="comment">//获取堆中元素个数</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isHeapEmpty</span><span class="params">()</span></span>;<span class="comment">//堆是否为空</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isHeapFull</span><span class="params">()</span></span>;<span class="comment">//堆是否已满</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Display</span><span class="params">()</span></span>;<span class="comment">//打印堆</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">T* heapArray;<span class="comment">//存放数据元素的数组</span></span><br><span class="line"><span class="keyword">int</span> markArray;<span class="comment">//标记</span></span><br><span class="line"><span class="keyword">int</span> MaxHeapSize;<span class="comment">//可存元素个数</span></span><br><span class="line"><span class="keyword">int</span> heapSize;<span class="comment">//当前元素个数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FilterUp</span><span class="params">(<span class="keyword">int</span> i)</span></span>;<span class="comment">//插入元素后进行堆化</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FilterDown</span><span class="params">(<span class="keyword">int</span> i)</span></span>;<span class="comment">//删除元素后进行堆化</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="2-最小堆类部分成员函数的实现"><a href="#2-最小堆类部分成员函数的实现" class="headerlink" title="2)最小堆类部分成员函数的实现"></a>2)最小堆类部分成员函数的实现</h4><p>&emsp;&emsp;插入成员函数是在原先的数据元素已经是堆的基础上，插入一个数据元素后，调整使之继续维持为一个堆。我们把要插入的数据元素放在堆尾。虽然插入前的数据元素集合构成堆，但是新的数据元素插入后可能违背堆的定义。</p><p>&emsp;&emsp;插入新元素后继续维持为一个最小堆的算法是</p><ul><li>看新插入元素的值是否小于其双亲的值，如果不小于，则仍维持为一个最小堆，算法结束；</li><li>如果小于，则交换两者的值；</li><li>交换后有可能在更上一层仍然不能满足最小堆的定义，需继续交换，直到满足最小堆的定义为止。</li></ul><p>最小堆插入图示：</p><p><img src="/2019/08/02/堆——最小堆和最大堆的实现/%E5%8E%9F%E5%A7%8B%E5%A0%86.PNG" alt="原始堆"></p><p><img src="/2019/08/02/堆——最小堆和最大堆的实现/%E5%A0%861.PNG" alt="插入步骤1"></p><p><img src="/2019/08/02/堆——最小堆和最大堆的实现/%E5%A0%862.PNG" alt="插入步骤2"></p><p><img src="/2019/08/02/堆——最小堆和最大堆的实现/%E5%A0%863.PNG" alt="插入步骤3"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//插入元素时重新堆化</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">MinHeap</span>&lt;T&gt;:</span>:FilterUp(<span class="keyword">int</span> i)</span><br><span class="line">&#123;<span class="comment">//调整插入的新元素使之上升到合适的结点位置</span></span><br><span class="line"><span class="keyword">int</span> currentPos, parentPos;</span><br><span class="line">T target;</span><br><span class="line">currentPos = i;</span><br><span class="line">target = heapArray[i];</span><br><span class="line">parentPos = (i<span class="number">-1</span>)/<span class="number">2</span>;<span class="comment">//获取结点i的双亲结点位置</span></span><br><span class="line"><span class="keyword">while</span> (currentPos != <span class="number">0</span>)</span><br><span class="line">&#123;<span class="comment">//到根结点为止</span></span><br><span class="line"><span class="keyword">if</span> (heapArray[parentPos] &lt;= target)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">heapArray[currentPos] = heapArray[parentPos];<span class="comment">//双亲结点下降</span></span><br><span class="line">currentPos = parentPos;<span class="comment">//当前结点为双亲结点，重新开始</span></span><br><span class="line">parentPos = (currentPos - <span class="number">1</span>) / <span class="number">2</span>;<span class="comment">//计算当前结点的双亲结点</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">heapArray[currentPos] = target;<span class="comment">//插入新元素</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//插入</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">MinHeap</span>&lt;T&gt;:</span>:Insert(<span class="keyword">const</span> T&amp; item)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (heapSize == MaxHeapSize)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"堆已满！"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">heapArray[heapSize] = item;</span><br><span class="line">FilterUp(heapSize);<span class="comment">//新插入结点上移，进行堆化</span></span><br><span class="line">heapSize++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;删除成员函数是删除堆顶的最小的数据元素。删除堆顶元素后，我们用堆中最后一个元素填充堆顶位置，此时必然违反堆的定义。</p><p>&emsp;&emsp;删除后继续维持为一个最小堆的算法是：</p><ul><li>令堆顶位置为当前位置，看当前位置元素的值时候小于其左右孩子中的最小值，如果不小于，则仍然维持为一个最小堆，算法结束；</li><li>如果小于，则交换两者的值；</li><li>交换后有可能在更下一层仍然不满足最小堆的定义，需继续交换，直到满足堆的定义为止。</li></ul><p>最小堆删除图示：</p><p><img src="/2019/08/02/堆——最小堆和最大堆的实现/%E5%88%A0%E9%99%A4%E5%8E%9F%E5%A7%8B%E5%A0%86.PNG" alt="原始堆"></p><p><img src="/2019/08/02/堆——最小堆和最大堆的实现/%E5%88%A0%E9%99%A41.PNG" alt="删除步骤1"></p><p><img src="/2019/08/02/堆——最小堆和最大堆的实现/%E5%88%A0%E9%99%A42.PNG" alt="删除步骤2"></p><p><img src="/2019/08/02/堆——最小堆和最大堆的实现/%E5%88%A0%E9%99%A43.PNG" alt="删除步骤3"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//删除元素时重新堆化</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">MinHeap</span>&lt;T&gt;:</span>:FilterDown(<span class="keyword">int</span> i)</span><br><span class="line">&#123;<span class="comment">//调整第i个结点使之下移到合适的位置</span></span><br><span class="line"><span class="keyword">int</span> currentPos, childPos;</span><br><span class="line">T target;</span><br><span class="line">currentPos = i;</span><br><span class="line">childPos = <span class="number">2</span> * i + <span class="number">1</span>;<span class="comment">//计算左孩子结点</span></span><br><span class="line">target = heapArray[i];</span><br><span class="line"><span class="keyword">while</span> (childPos &lt; heapSize)</span><br><span class="line">&#123;<span class="comment">//childPos为当前结点的左右孩子中值较小的孩子结点位置</span></span><br><span class="line"><span class="keyword">if</span> (childPos &lt; heapSize &amp;&amp; (heapArray[childPos + <span class="number">1</span>] &lt;= heapArray[childPos])&amp;&amp;childPos+<span class="number">1</span>&lt;heapSize)</span><br><span class="line">&#123;</span><br><span class="line">childPos = childPos + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (target &lt; heapArray[childPos])</span><br><span class="line"><span class="keyword">break</span>;<span class="comment">//满足最小堆的定义</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">heapArray[currentPos] = heapArray[childPos];<span class="comment">//孩子结点上升</span></span><br><span class="line">currentPos = childPos;<span class="comment">//从孩子结点位置重新开始</span></span><br><span class="line">childPos = childPos * <span class="number">2</span> + <span class="number">1</span>;<span class="comment">//当前结点的孩子结点</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">heapArray[currentPos] = target;<span class="comment">//把填充的堆顶元素插入</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除堆中最小元素</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">T</span> <span class="title">MinHeap</span>&lt;T&gt;:</span>:Delete()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (heapSize == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"堆为空！"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">T item = heapArray[<span class="number">0</span>];<span class="comment">//保存原堆顶元素</span></span><br><span class="line">heapArray[<span class="number">0</span>] = heapArray[heapSize - <span class="number">1</span>];<span class="comment">//用最后一个元素填充堆顶位置</span></span><br><span class="line">heapSize--;</span><br><span class="line"></span><br><span class="line">FilterDown(<span class="number">0</span>);<span class="comment">//下移当前堆顶元素</span></span><br><span class="line"><span class="keyword">return</span> item;<span class="comment">//返回原堆顶元素</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;数组的堆化是把一个有n个数据元素的非堆的数组构造为一个堆。</p><p>&emsp;&emsp;数组的堆化过程可以设计成递推过程。在完全二叉树形式的数组中，所有叶结点都满足堆的定义，令最后一个叶结点的双亲结点为当前结点，其下标为：<br><code>currentPos=((n-1)-1)/2</code></p><p>&emsp;&emsp;对于结点<code>currentPos</code>，其左右孩子结点已满足堆的定义，使结点<code>currentPos</code>也满足堆的定义的过程与插入过程中使用的<code>FilterDown</code>相同。因此使用参数<code>currentPos</code>调用<code>FilterDown(currentPos)</code>；在结点<code>currentPos</code>满足最小堆的定义后，使当前结点<code>currentPos=currentPos-1</code>，对于结点<code>currentPos</code>，其左右孩子结点已满足最小堆的定义，再次用参数<code>currentPos</code>调用<code>FilterDown(currentPos)</code>；这样的过程一直进行到当前结点<code>currentPos=0</code>，即到达根结点为止。</p><p>数组堆化图示：</p><p><img src="/2019/08/02/堆——最小堆和最大堆的实现/%E5%8E%9F%E5%A7%8B%E6%95%B0%E7%BB%84.PNG" alt="原始数组"></p><p><img src="/2019/08/02/堆——最小堆和最大堆的实现/%E5%A0%86%E5%8C%961.PNG" alt="堆化步骤1"></p><p><img src="/2019/08/02/堆——最小堆和最大堆的实现/%E5%A0%86%E5%8C%962.PNG" alt="堆化步骤2"></p><p><img src="/2019/08/02/堆——最小堆和最大堆的实现/%E5%A0%86%E5%8C%963.PNG" alt="堆化步骤3"></p><p><img src="/2019/08/02/堆——最小堆和最大堆的实现/%E5%A0%86%E5%8C%964.PNG" alt="堆化步骤4"></p><p><img src="/2019/08/02/堆——最小堆和最大堆的实现/%E5%A0%86%E5%8C%965.PNG" alt="堆化步骤5"></p><p><img src="/2019/08/02/堆——最小堆和最大堆的实现/%E5%A0%86%E5%8C%966.PNG" alt="堆化步骤6"></p><p><img src="/2019/08/02/堆——最小堆和最大堆的实现/%E5%A0%86%E5%8C%967.PNG" alt="堆化步骤7"></p><p><img src="/2019/08/02/堆——最小堆和最大堆的实现/%E5%A0%86%E5%8C%968.PNG" alt="堆化步骤8"></p><p><img src="/2019/08/02/堆——最小堆和最大堆的实现/%E5%A0%86%E5%8C%969.PNG" alt="堆化步骤9"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将数组堆化</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">MinHeap</span>&lt;T&gt;:</span>:MinHeap(T arr[], <span class="keyword">int</span> n)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (n &lt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"非法参数!"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">MaxHeapSize = n;</span><br><span class="line">heapSize = n;</span><br><span class="line">heapArray = arr;</span><br><span class="line"><span class="keyword">int</span> currentPos = (n - <span class="number">1</span>) / <span class="number">2</span>;<span class="comment">//计算第一个非叶子结点</span></span><br><span class="line"><span class="keyword">while</span> (currentPos &gt;= <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">FilterDown(currentPos);<span class="comment">//调整结点currentPos使之下移到合适的位置</span></span><br><span class="line">currentPos--;</span><br><span class="line">&#125;</span><br><span class="line">markArray = <span class="number">1</span>;<span class="comment">//置构造函数标记</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-测试函数"><a href="#3-测试函数" class="headerlink" title="3)测试函数"></a>3)测试函数</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> arr[] = &#123; <span class="number">24</span>,<span class="number">10</span>,<span class="number">90</span>,<span class="number">77</span>,<span class="number">16</span>,<span class="number">25</span>,<span class="number">33</span>,<span class="number">89</span>,<span class="number">67</span> &#125;;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"原数组元素为："</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (<span class="keyword">sizeof</span>(arr) / <span class="keyword">sizeof</span>(arr[<span class="number">0</span>])); i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; arr[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">MinHeap&lt;<span class="keyword">int</span>&gt; heap(arr, (<span class="keyword">sizeof</span>(arr) / <span class="keyword">sizeof</span>(arr[<span class="number">0</span>])));</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"输出堆中元素："</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">heap.Display();</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; heap.Delete() &lt;&lt; <span class="string">"已被删除！"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"输出堆中元素："</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">heap.Display();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4）执行结果"><a href="#4）执行结果" class="headerlink" title="4）执行结果"></a>4）执行结果</h4><p><img src="/2019/08/02/堆——最小堆和最大堆的实现/%E6%9C%80%E5%B0%8F%E5%A0%86%E6%89%A7%E8%A1%8C%E7%BB%93%E6%9E%9C.PNG" alt="最小堆测试执行结果"></p><h4 id="5-源码地址"><a href="#5-源码地址" class="headerlink" title="5)源码地址"></a>5)源码地址</h4><p>​        <a href="https://github.com/Aoki-Wang/CheckStation/tree/master/Data%20Structure/Heap/Min%20Heap" target="_blank" rel="noopener">最小堆的实现源码</a></p><h2 id="四、最大堆的实现"><a href="#四、最大堆的实现" class="headerlink" title="四、最大堆的实现"></a>四、最大堆的实现</h2><h4 id="1-最大堆类"><a href="#1-最大堆类" class="headerlink" title="1)最大堆类"></a>1)最大堆类</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">MaxHeap</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">MaxHeap(<span class="keyword">int</span> maxsize);<span class="comment">//构造函数</span></span><br><span class="line">MaxHeap(T arr[], <span class="keyword">int</span> n);<span class="comment">//拷贝构造函数，将n个arr元素堆化</span></span><br><span class="line">~MaxHeap();<span class="comment">//析构函数</span></span><br><span class="line"><span class="comment">//最小堆的相关操作</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Insert</span><span class="params">(<span class="keyword">const</span> T&amp; item)</span></span>;<span class="comment">//插入元素item</span></span><br><span class="line"><span class="function">T <span class="title">Delete</span><span class="params">()</span></span>;<span class="comment">//删除堆中最大元素</span></span><br><span class="line"><span class="function">T <span class="title">GetHeapTop</span><span class="params">()</span></span>;<span class="comment">//获取堆顶元素</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">HeapSize</span><span class="params">()</span></span>;<span class="comment">//获取堆中元素个数</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isHeapEmpty</span><span class="params">()</span></span>;<span class="comment">//堆是否为空</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isHeapFull</span><span class="params">()</span></span>;<span class="comment">//堆是否已满</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Display</span><span class="params">()</span></span>;<span class="comment">//打印堆</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">T* heapArray;<span class="comment">//存放数据元素的数组</span></span><br><span class="line"><span class="keyword">int</span> markArray;<span class="comment">//标记</span></span><br><span class="line"><span class="keyword">int</span> MaxHeapSize;<span class="comment">//可存元素个数</span></span><br><span class="line"><span class="keyword">int</span> heapSize;<span class="comment">//当前元素个数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FilterUp</span><span class="params">(<span class="keyword">int</span> i)</span></span>;<span class="comment">//插入元素后进行堆化</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FilterDown</span><span class="params">(<span class="keyword">int</span> i)</span></span>;<span class="comment">//删除元素后进行堆化</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="2-最大堆类部分成员函数的实现"><a href="#2-最大堆类部分成员函数的实现" class="headerlink" title="2)最大堆类部分成员函数的实现"></a>2)最大堆类部分成员函数的实现</h4><p>最大堆类的成员函数的实现与最小堆类成员函数的实现基本相同，这里只列出部分成员的函数实现，不做解释。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">MaxHeap</span>&lt;T&gt;:</span>:MaxHeap( T arr[], <span class="keyword">int</span> n)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (n &lt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"非法参数！"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">heapArray = arr;</span><br><span class="line">heapSize = n;</span><br><span class="line">MaxHeapSize = n;</span><br><span class="line">markArray = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> currentPos = (n - <span class="number">1</span>) / <span class="number">2</span>;<span class="comment">//计算第一个非叶子结点的位置</span></span><br><span class="line"><span class="keyword">while</span> (currentPos &gt;= <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">FilterDown(currentPos);<span class="comment">//下移当前结点到合适的位置</span></span><br><span class="line">currentPos--;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> <span class="title">MaxHeap</span>&lt;T&gt;:</span>:Insert(<span class="keyword">const</span> T&amp; item)</span><br><span class="line">&#123;<span class="comment">//插入元素</span></span><br><span class="line"><span class="keyword">if</span> (heapSize == MaxHeapSize)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"非法参数！"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">heapArray[heapSize] = item;</span><br><span class="line">FilterUp(heapSize);</span><br><span class="line">heapSize++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">T</span> <span class="title">MaxHeap</span>&lt;T&gt;:</span>:Delete()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (heapSize == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"堆为空！"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">T item = heapArray[<span class="number">0</span>];</span><br><span class="line">heapArray[<span class="number">0</span>] = heapArray[heapSize - <span class="number">1</span>];<span class="comment">//用最后一个元素填充堆顶元素</span></span><br><span class="line">heapSize--;</span><br><span class="line">FilterDown(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">return</span> item;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> <span class="title">MaxHeap</span>&lt;T&gt;:</span>:FilterUp(<span class="keyword">int</span> i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> currentPos, ParentPos;</span><br><span class="line">T target = heapArray[i];</span><br><span class="line">currentPos = i;</span><br><span class="line">ParentPos = (i - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">while</span> (currentPos != <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (heapArray[ParentPos] &gt;= target)<span class="comment">//已经是最大堆</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">heapArray[currentPos] = heapArray[ParentPos];<span class="comment">//双亲结点下移</span></span><br><span class="line">currentPos = ParentPos;<span class="comment">//双亲结点为当前结点</span></span><br><span class="line">ParentPos = (currentPos - <span class="number">1</span>) / <span class="number">2</span>;<span class="comment">//找到当前结点的双亲结点</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">heapArray[currentPos] = target;<span class="comment">//插入新元素</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> <span class="title">MaxHeap</span>&lt;T&gt;:</span>:FilterDown(<span class="keyword">int</span> i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> currentPos,childPos;</span><br><span class="line">T target = heapArray[i];</span><br><span class="line">currentPos = i;</span><br><span class="line">childPos = i * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (childPos &lt; heapSize)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (childPos + <span class="number">1</span> &lt; heapSize &amp;&amp; (heapArray[childPos + <span class="number">1</span>] &gt;= heapArray[childPos])&amp;&amp;childPos+<span class="number">1</span>&lt;heapSize)</span><br><span class="line">childPos = childPos + <span class="number">1</span>;<span class="comment">//选择两个孩子结点中较大的一个作为孩子结点为位置</span></span><br><span class="line"><span class="keyword">if</span> (target &gt;= heapArray[childPos])</span><br><span class="line"><span class="keyword">break</span>;<span class="comment">//满足最大堆的性质</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">heapArray[currentPos] = heapArray[childPos];<span class="comment">//孩子结点上移</span></span><br><span class="line">currentPos = childPos;<span class="comment">//当前孩子结点作为当前结点</span></span><br><span class="line">childPos = childPos * <span class="number">2</span> + <span class="number">1</span>;<span class="comment">//当前结点的孩子结点位置</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">heapArray[currentPos] = target;<span class="comment">//把填充的堆顶元素插入</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3）测试函数"><a href="#3）测试函数" class="headerlink" title="3）测试函数"></a>3）测试函数</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> arr[] = &#123; <span class="number">24</span>,<span class="number">10</span>,<span class="number">90</span>,<span class="number">77</span>,<span class="number">16</span>,<span class="number">25</span>,<span class="number">33</span>,<span class="number">89</span>,<span class="number">67</span> &#125;;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"原数组元素为："</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (<span class="keyword">sizeof</span>(arr) / <span class="keyword">sizeof</span>(arr[<span class="number">0</span>])); i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; arr[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">MaxHeap&lt;<span class="keyword">int</span>&gt; heap(arr, (<span class="keyword">sizeof</span>(arr) / <span class="keyword">sizeof</span>(arr[<span class="number">0</span>])));</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"输出堆中元素："</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">heap.Display();</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; heap.Delete() &lt;&lt; <span class="string">"已被删除！"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"输出堆中元素："</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">heap.Display();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4）执行结果-1"><a href="#4）执行结果-1" class="headerlink" title="4）执行结果"></a>4）执行结果</h4><p><img src="/2019/08/02/堆——最小堆和最大堆的实现/%E6%9C%80%E5%A4%A7%E5%A0%86%E6%89%A7%E8%A1%8C%E7%BB%93%E6%9E%9C.PNG" alt="最大堆测试执行结果"></p><h4 id="5）源码地址"><a href="#5）源码地址" class="headerlink" title="5）源码地址"></a>5）源码地址</h4><p>​        <a href="https://github.com/Aoki-Wang/CheckStation/tree/master/Data%20Structure/Heap/Max%20Heap" target="_blank" rel="noopener">最大堆的实现源码</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、堆概述&quot;&gt;&lt;a href=&quot;#一、堆概述&quot; class=&quot;headerlink&quot; title=&quot;一、堆概述&quot;&gt;&lt;/a&gt;一、堆概述&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;堆(Heap)是结点间数据元素的关键码具有层次次序关系的完全二叉树；&lt;/li&gt;
&lt;li&gt;堆是二叉树的顺序
      
    
    </summary>
    
      <category term="数据结构" scheme="http://wanqbin.xyz/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="C++" scheme="http://wanqbin.xyz/tags/C/"/>
    
      <category term="堆" scheme="http://wanqbin.xyz/tags/%E5%A0%86/"/>
    
      <category term="最大堆" scheme="http://wanqbin.xyz/tags/%E6%9C%80%E5%A4%A7%E5%A0%86/"/>
    
      <category term="最小堆" scheme="http://wanqbin.xyz/tags/%E6%9C%80%E5%B0%8F%E5%A0%86/"/>
    
      <category term="优先队列" scheme="http://wanqbin.xyz/tags/%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>交换排序——冒泡快速和快速排序的实现</title>
    <link href="http://wanqbin.xyz/2019/08/01/%E4%BA%A4%E6%8D%A2%E6%8E%92%E5%BA%8F%E2%80%94%E2%80%94%E5%86%92%E6%B3%A1%E5%BF%AB%E9%80%9F%E5%92%8C%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E7%9A%84%E5%AE%9E%E7%8E%B0/"/>
    <id>http://wanqbin.xyz/2019/08/01/交换排序——冒泡快速和快速排序的实现/</id>
    <published>2019-08-01T09:04:00.000Z</published>
    <updated>2019-08-02T04:05:08.588Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h2><p>&emsp;&emsp;利用交换对象的位置进行排序的方法称之为<code>交换排序</code>。常用的交换排序方法有冒泡排序法和快速排序法。快速排序法是一种分区交换排序方法。</p><h2 id="二、冒泡排序"><a href="#二、冒泡排序" class="headerlink" title="二、冒泡排序"></a>二、冒泡排序</h2><ul><li>冒泡排序法是一种简单常用的排序方法。</li><li>冒泡排序的思想是：对n个对象的对象集合，设第一个对象下标为0，依次把对象下标i定为0,1,2,3,……，n-2，然后依次将待排序对象集合中下标为i对象的关键码与下标为i+1对象的关键码进行比较，若前者大于后者，则交换两者的位置；后者不交换。</li><li>当这样的过程完成后，n个对象的数组的最后一个单元中就存放了对象集合中关键码最大的对象。</li><li>然后，不考虑这个已排好序对的对象，重新进行这样的过程，当这样的过程完成后，n-1个对象的数组的最后一个单元中就存放了对象集合中关键码最大的对象。当这样的过程进行n-1次，对象集合中就是排好序的对象集合。</li></ul><h4 id="1）冒泡排序的实现"><a href="#1）冒泡排序的实现" class="headerlink" title="1）冒泡排序的实现"></a>1）冒泡排序的实现</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">BubbleSort</span>(<span class="title">T</span> <span class="title">arr</span>[], <span class="title">int</span> <span class="title">n</span>)</span></span><br><span class="line"><span class="class">&#123;</span><span class="comment">//对arr数组元素进行排序</span></span><br><span class="line"><span class="keyword">int</span> i, j, flag=<span class="number">1</span>;</span><br><span class="line">T temp;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n &amp;&amp; flag == <span class="number">1</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">flag = <span class="number">0</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">flag用于标记本次交换排序过程是否</span></span><br><span class="line"><span class="comment">有交换动作，若本次交换排序过程没有交换动作，</span></span><br><span class="line"><span class="comment">则说明对象集合已全部排好序，就可提前结束排序过程</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; n-i; j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>])</span><br><span class="line">&#123;</span><br><span class="line">flag = <span class="number">1</span>;</span><br><span class="line">temp = arr[j];</span><br><span class="line">arr[j] = arr[j + <span class="number">1</span>];</span><br><span class="line">arr[j + <span class="number">1</span>] = temp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2）测试函数"><a href="#2）测试函数" class="headerlink" title="2）测试函数"></a>2）测试函数</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> arr[] = &#123; <span class="number">5</span>,<span class="number">15</span>,<span class="number">1</span>,<span class="number">48</span>,<span class="number">23</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">9</span> &#125;;</span><br><span class="line"><span class="keyword">int</span> n = <span class="keyword">sizeof</span>(arr) / <span class="keyword">sizeof</span>(arr[<span class="number">0</span>])<span class="number">-1</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"原数组为："</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; arr[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">BubbleSort(arr, n);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"排序结果为："</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; arr[j] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3）执行结果"><a href="#3）执行结果" class="headerlink" title="3）执行结果"></a>3）执行结果</h4><p><img src="/2019/08/01/交换排序——冒泡快速和快速排序的实现/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%E6%89%A7%E8%A1%8C%E7%BB%93%E6%9E%9C.PNG" alt="冒泡排序执行结果"></p><h4 id="4）时空复杂度分析"><a href="#4）时空复杂度分析" class="headerlink" title="4）时空复杂度分析"></a>4）时空复杂度分析</h4><ul><li><p>时间复杂度:</p><ul><li><p>冒泡排序算法的最好情况是对象集合已全部排好序，这时循环n-1次，每次循环都因没有交换动作而退出，因此冒泡排序最好情况的时间复杂度是O(n);</p></li><li><p>冒泡排序的最坏情况是对象集合全部逆序存放，这时循环n-1次，整个循环的比较次数和移动次数为：</p><p>比较次数=$\sum^{1}_{i=n-1}{i}$=$\frac{n(n-1)}{2}$</p><p>移动次数=3$\sum^{i}_{i=n-1}{i}$=$\frac{3n(n-1)}{2}$</p><p>因此，冒泡排序算法最坏情况的时间复杂度为O($n^2$)</p></li></ul></li><li><p>空间复杂度：</p><p>冒泡排序算法的空间复杂度为O(1)。显然，冒泡排序算法是一种稳定的排序方法。</p></li></ul><h4 id="5）源码地址"><a href="#5）源码地址" class="headerlink" title="5）源码地址"></a>5）源码地址</h4><p>​        <a href="https://github.com/Aoki-Wang/CheckStation/tree/master/Data%20Structure/Exchange%20Sort/BubbleSort" target="_blank" rel="noopener">冒泡排序实现源码</a></p><h2 id="三、快速排序"><a href="#三、快速排序" class="headerlink" title="三、快速排序"></a>三、快速排序</h2><ul><li>快速排序又称为分区交换排序。</li><li>快速排序算法的基本思想是：从待排序的对象数组中任取一个个对象（通常是取对象数组中的第一个对象）作为基准，调整对象数组中各个对象在数组中的位置，使排在该对象前面对象的关键码均小于该对象的关键码，使排在该对象后面对象的关键码均大于该对象的关键码。</li><li>这样的交换过程结束后，一方面将该对象放在未来排好序的对象数组中该对象应在的位置上；另一方面将该对象数组中的对象以该对象为基准划分成了两个子对象数组，位于该基准对象左边子对象数组中对象的关键码均小于该对象的关键码，位于该基准对象右边子对象数组中对象的关键码均大于等于该对象的关键码。</li><li>对于这两个子对象数组中的对象分别再进行方法类同的快速排序，当各个子对象数组中的对象个数均小于1时，排序过程结束。显然，快速排序算法过程是递归的过程。</li></ul><h4 id="1）快速排序的实现"><a href="#1）快速排序的实现" class="headerlink" title="1）快速排序的实现"></a>1）快速排序的实现</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">int</span> <span class="title">Partition</span>(<span class="title">T</span> <span class="title">arr</span>[], <span class="title">int</span> <span class="title">low</span>, <span class="title">int</span> <span class="title">high</span>)</span></span><br><span class="line"><span class="class">&#123;</span><span class="comment">//表的划分</span></span><br><span class="line">T pivot;<span class="comment">//基准</span></span><br><span class="line">Swap(arr, low, (low + high) / <span class="number">2</span>);<span class="comment">//交换第一个元素与中间元素</span></span><br><span class="line">pivot = arr[low];<span class="comment">//将交换过来的中间元素作为基准</span></span><br><span class="line"><span class="keyword">int</span> last_small = low;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = low + <span class="number">1</span>; i &lt;= high; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (arr[i] &lt; pivot)</span><br><span class="line">&#123;</span><br><span class="line">last_small = last_small + <span class="number">1</span>;</span><br><span class="line">Swap(arr, last_small, i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">Swap(arr, low, last_small);</span><br><span class="line"><span class="keyword">return</span> last_small;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">QuickSort</span>(<span class="title">T</span> <span class="title">arr</span>[], <span class="title">int</span> <span class="title">low</span>, <span class="title">int</span> <span class="title">high</span>)</span></span><br><span class="line"><span class="class">&#123;</span><span class="comment">//快速排序</span></span><br><span class="line"><span class="keyword">int</span> q;</span><br><span class="line"><span class="keyword">if</span> (low &lt; high)</span><br><span class="line">&#123;</span><br><span class="line">q = Partition&lt;T&gt;(arr, low, high);</span><br><span class="line">QuickSort(arr, low, q - <span class="number">1</span>);</span><br><span class="line">QuickSort(arr, q + <span class="number">1</span>, high);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-快速排序的过程"><a href="#2-快速排序的过程" class="headerlink" title="2)快速排序的过程"></a>2)快速排序的过程</h4><p>&emsp;&emsp;在快速排序中，<code>Partition</code>函数的构造比较重要。<code>Partition</code>函数的算策略有几种，有的策略比本文中的算法要快，但却复杂并且容易出错。本文中的算法更加简单而且易于理解，当然也不慢。实际上，在所有的算法中，它所进行的键比较的次数可能是最少的。</p><p>&emsp;&emsp;对于基准的选择，并非一定要选择顺序表的首个元素作为基准，我们可以选择任意一个元素并在划分表的循环开始之前将它与表中的第一个元素交换。实际上，首个元素作为基准经常是一种拙劣的选择，因为一旦此顺序表是已经排过序的，则不会有其他元素再小于此基准，这将导致其中的一个子表为空表。因此，我们在表的近中央位置处选择了一个基准，希望这种选择可以把关键码划分在基准两边约各占一半。</p><p>&emsp;&emsp;给定一个基准<code>pivot</code>，我们必须重新排列表中的元素并计算一个下标<code>pivot_position</code>，使得基准位于<code>pivot_position</code>，在此下标左边的所有元素的关键码均小于<code>pivot</code>，在其右边的所有元素的关键码均大于或等于<code>pivot</code>。</p><p><img src="/2019/08/01/交换排序——冒泡快速和快速排序的实现/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E7%A4%BA%E6%84%8F%E5%9B%BE.PNG" alt="快速排序"></p><h5 id="第一趟排序过程："><a href="#第一趟排序过程：" class="headerlink" title="第一趟排序过程："></a>第一趟排序过程：</h5><p><img src="/2019/08/01/交换排序——冒泡快速和快速排序的实现/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B.PNG" alt="快速排序第一趟排序"></p><h4 id="3）测试函数"><a href="#3）测试函数" class="headerlink" title="3）测试函数"></a>3）测试函数</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> arr[] = &#123; <span class="number">5</span>,<span class="number">15</span>,<span class="number">1</span>,<span class="number">48</span>,<span class="number">23</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">9</span> &#125;;</span><br><span class="line"><span class="keyword">int</span> n = <span class="keyword">sizeof</span>(arr) / <span class="keyword">sizeof</span>(arr[<span class="number">0</span>])<span class="number">-1</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"原数组为："</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; arr[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">QuickSort(arr, <span class="number">0</span>, n);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"排序结果为："</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; arr[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4）执行结果"><a href="#4）执行结果" class="headerlink" title="4）执行结果"></a>4）执行结果</h4><p><img src="/2019/08/01/交换排序——冒泡快速和快速排序的实现/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E6%89%A7%E8%A1%8C%E7%BB%93%E6%9E%9C.PNG" alt="快速排序执行结果"></p><h4 id="5）时空复杂度分析"><a href="#5）时空复杂度分析" class="headerlink" title="5）时空复杂度分析"></a>5）时空复杂度分析</h4><ul><li>时间复杂度：<ul><li>快速排序算法的时间复杂度和各次基准对象的值关系很大。如果每次取得的基准对象的值都能使该对象处于当前对象数组的中间位置上，将原来的对象数组分为两个大小相等的子对象数组，这样的快速排序算法过程相当于一个完全二叉树（即每个结点都把当前对象数组分为两个大小相等的子对象数组结点，n个对象数组的根结点的分解次数就构成一棵完全二叉树）。</li><li>这时分解次数等于n个结点的完全二叉树的深度lg2n</li><li>每次快速排序过程无论把对象数组怎样划分，全部的比较次数都基本等于n次，所以<code>最好情况</code>下快速排序算法的时间复杂度为<code>O(lgn)</code>。</li><li>快速排序算法的最坏情况是n个对象数组的根结点的分解次数构成一棵二叉退化树，一棵二叉退化树的深度为n，所以<code>最坏情况</code>下快速排序算法的时间复杂度为O($n^2$).</li><li>一般情况下，基准对象值的分布式随机的，而随机的基准对象值的n个对象数组的根结点的分解次数构成一棵二叉树，这样的二叉树的深度接近lgn，所以快速排序算法的<code>平均时间复杂度</code>为<code>O(nlgn)</code>。</li></ul></li><li>空间复杂度：<ul><li>快速排序算法需要堆栈空间临时保存递归调用参数，堆栈空间的使用个数与递归调用次数（即n个结点的二叉树的深度）有关，和上述时间复杂度分析类似，<code>最好情况</code>下快速排序算法的空间复杂度<code>为O(lgn)</code>;</li><li><code>最坏情况</code>下快速排序算法的空间复杂度为<code>O(n)</code>；</li><li>快速排序算法的<code>平均空间复杂度</code>为<code>O(lgn)</code></li></ul></li></ul><h4 id="5）源码地址-1"><a href="#5）源码地址-1" class="headerlink" title="5）源码地址"></a>5）源码地址</h4><p>​        <a href="https://github.com/Aoki-Wang/CheckStation/tree/master/Data%20Structure/Exchange%20Sort/QuickSort" target="_blank" rel="noopener">快速排序实现源码</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、概述&quot;&gt;&lt;a href=&quot;#一、概述&quot; class=&quot;headerlink&quot; title=&quot;一、概述&quot;&gt;&lt;/a&gt;一、概述&lt;/h2&gt;&lt;p&gt;&amp;emsp;&amp;emsp;利用交换对象的位置进行排序的方法称之为&lt;code&gt;交换排序&lt;/code&gt;。常用的交换排序方法有冒泡排
      
    
    </summary>
    
      <category term="数据结构" scheme="http://wanqbin.xyz/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="C++" scheme="http://wanqbin.xyz/tags/C/"/>
    
      <category term="排序" scheme="http://wanqbin.xyz/tags/%E6%8E%92%E5%BA%8F/"/>
    
      <category term="冒泡排序" scheme="http://wanqbin.xyz/tags/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/"/>
    
      <category term="快速排序" scheme="http://wanqbin.xyz/tags/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>插入排序及其实现</title>
    <link href="http://wanqbin.xyz/2019/08/01/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F%E5%8F%8A%E5%85%B6%E5%AE%9E%E7%8E%B0/"/>
    <id>http://wanqbin.xyz/2019/08/01/插入排序及其实现/</id>
    <published>2019-08-01T03:19:00.000Z</published>
    <updated>2019-08-01T11:23:06.438Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、排序的基本概念"><a href="#一、排序的基本概念" class="headerlink" title="一、排序的基本概念"></a>一、排序的基本概念</h2><p>&emsp;&emsp;<code>排序</code>是将一个无序的数据元素集合整理成按<code>关键码</code>递增（或递减）排列的有规律有序集合的过程。关键码是所定义的数据元素类型中的一个域。</p><ol><li><h4 id="关键码"><a href="#关键码" class="headerlink" title="关键码"></a>关键码</h4><p>要排序的对象集合可能有多个域，关键码是当前排序时进行比较以确定各个对象位置的域。</p><p>在对象集合中，不同的对象其关键码值一定不相同的关键码称为<code>主关键码</code>;不同的对象其关键码值有可能相同的关键码称为<code>次关键码</code>。</p></li><li><h4 id="排序算法的稳定性"><a href="#排序算法的稳定性" class="headerlink" title="排序算法的稳定性"></a>排序算法的稳定性</h4><p>&emsp;&emsp;任何排序算法在使用主关键码进行排序时，其排序结果是相同的。当排序算法使用次关键码进行排序时，其排序结果可能相同，也可能不同。</p><p>&emsp;&emsp;对于有n个对象集合中的次关键码<code>K[i](i=0,1,2……，n-1)</code>，若<code>K[i]</code>等于<code>K[j](j=0,1,2……，n-1,j!=i)</code>,其在排序之前，对象<code>R[i]</code>排在对象<code>R[j]</code>之前，如果在排序之后对象<code>R[i]</code>仍在对象<code>R[j]</code>的前面的排序算法称为<code>稳定的排序算法</code>。否则称为<code>不稳定的排序算法</code>。</p><p>&emsp;&emsp;显然，对于一组给定的对象集合，所有稳定的排序算法的排序结果都是相同的，不稳定的排序算法的排序结果有可能相同，也有可能不同。稳定的排序算法通常是应用问题所希望的，因此，排序算法的稳定性是衡量排序算法好坏的一个重要标准。</p></li><li><h4 id="排序算法的时间复杂度"><a href="#排序算法的时间复杂度" class="headerlink" title="排序算法的时间复杂度"></a>排序算法的时间复杂度</h4><p>&emsp;&emsp;和所有算法一样，时间复杂度是衡量排序算法好坏的一个重要标准。排序算法的时间复杂度主要表现在算法中对象关键码的比较和对象的移动上。对于有n个对象的集合的排序问题，因为从该集合中找出一个最大（或最小）对象一定要遍历该集合，其时间复杂度为O(n),而进一步将n个对象均排列整齐的最理想情况可对应成完全二叉树结果，其时间复杂度为<code>O(nlgn)</code>,因此排序算法最好的时间复杂度为<code>O(nlgn)</code></p></li><li><h4 id="排序算法的空间复杂度"><a href="#排序算法的空间复杂度" class="headerlink" title="排序算法的空间复杂度"></a>排序算法的空间复杂度</h4><p>&emsp;&emsp;和所有算法一样，空间复杂度是衡量排序算法好坏的一个重要标准。排序算法的空间复杂度也就是算法中使用的辅助存储单元的多少。当排序算法中使用的存储单元与排序对象的个数n无关时，其空间复杂度为O(1),因此排序算法最好的空间复杂度为O(1)。空间复杂度为O(1)的排序算法也称为原地排序算法。原地排序算法就是在原来存放对象的数组空间中重新按关键码大小排放对象集合。</p></li></ol><h2 id="二、插入排序"><a href="#二、插入排序" class="headerlink" title="二、插入排序"></a>二、插入排序</h2><p>&emsp;&emsp;插入排序是一种由初始空集开始，不断地把新的对象插入到数组合适位置的排序方法，常用的插入排序法有直接插入排序、链表插入排序、希尔排序。</p><ol><li><h3 id="直接插入排序"><a href="#直接插入排序" class="headerlink" title="直接插入排序"></a>直接插入排序</h3><ul><li><p>直接插入排序的基本思想是：顺序地把待排序的对象按其关键码值的大小插入到已排序对象集合的适当位置。</p></li><li><p>假设待排序的对象为<code>R[0]、R[1]、R[2]、……、R[n-1]</code>,开始排序时对象集合<code>R[0]</code>因只有一个对象，所以已排好序。</p></li><li><p>第一次循环准备将对象<code>R[1]</code>插入到已排好序的对象集合<code>R[0]</code>中，这只需要比较<code>K[0]</code>和<code>K[1]</code>，若<code>K[0]&lt;=K[1]</code>，则已排好序，否则将<code>R[1]</code>插入到<code>R[0]</code>之前，这样，对象集合<code>R[0],R[1]</code>已排好序。</p></li><li><p>第二次循环准备将<code>R[2]</code>插入到已排好序的对象集合<code>R[0],R[1]</code>中，这需要先比较<code>K[2]</code>和<code>K[1]</code>以确定是否需要把<code>R[2]</code>插入到<code>R[1]</code>之前，然后比较<code>K[2]</code>和<code>K[0]</code>以确定是否需要把<code>R[2]</code>插入到<code>R[0]</code>之前。</p></li><li><p>这样的循环过程一直进行到<code>R[n-1]</code>插入完为止。这时对象集合<code>R[0]、R[1]、R[2]、……、R[n-1]</code>就全部排好序了。</p></li></ul><h4 id="1）直接插入排序的实现"><a href="#1）直接插入排序的实现" class="headerlink" title="1）直接插入排序的实现"></a>1）直接插入排序的实现</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">InsertSort</span>(<span class="title">T</span> <span class="title">a</span>[], <span class="title">int</span> <span class="title">n</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> i, j;</span><br><span class="line">T temp;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">temp = a[i + <span class="number">1</span>];</span><br><span class="line">j = i;</span><br><span class="line"><span class="keyword">while</span> (j &gt; <span class="number">-1</span> &amp;&amp; temp &lt; a[j])</span><br><span class="line">&#123;</span><br><span class="line">a[j + <span class="number">1</span>] = a[j];</span><br><span class="line">j--;</span><br><span class="line">&#125;</span><br><span class="line">a[j + <span class="number">1</span>] = temp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h4 id="2）测试函数"><a href="#2）测试函数" class="headerlink" title="2）测试函数"></a>2）测试函数</h4>   <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> sort[] = &#123; <span class="number">15</span>,<span class="number">22</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">56</span>,<span class="number">89</span>,<span class="number">14</span> &#125;;</span><br><span class="line">   <span class="keyword">int</span> n = <span class="keyword">sizeof</span>(sort) / <span class="keyword">sizeof</span>(sort[<span class="number">0</span>])<span class="number">-1</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"原数组为："</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; sort[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">InsertSort(sort, n);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"排序结果为："</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; sort[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3）执行结果"><a href="#3）执行结果" class="headerlink" title="3）执行结果"></a>3）执行结果</h4><p>   <img src="/2019/08/01/插入排序及其实现/%E7%9B%B4%E6%8E%A5%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F%E6%89%A7%E8%A1%8C%E7%BB%93%E6%9E%9C.PNG" alt="直接插入排序执行结果"></p><h4 id="4）时空复杂度分析"><a href="#4）时空复杂度分析" class="headerlink" title="4）时空复杂度分析"></a>4）时空复杂度分析</h4><ul><li><p>直接插入排序算法的时间复杂度分析可分为最好和最坏两种情况考虑：</p><ul><li><p>最好的情况是原始对象集合已全部排好序。此时while循环的循环次数均为0。这样在每次排序过程中关键码的比较次数为1，对象的移动次数为2，因此整个排序过程中关键码的比较次数为n-1，对象的移动次数为2(n-1)，所以最好情况的时间复杂度为O(n)</p></li><li><p>最坏的情况是原始对象集合逆序排列。这种情况下第<code>i</code>次排序时算法中的while循环的循环次数均为<code>i</code>。这样在整个排序过程中关键码的比较次数和对象移动次数可计算如下：</p><p>​        比较次数=$\sum^{ n-1}_{i=1}{(i+1)}$=$\frac {(n-1)(n+2)}{2}$</p><p>​        移动次数=$\sum_{i=1}^{n-1}{i+2}$=$\frac{(n-1)(n+4)}{2}$</p><p>因此，最坏情况下其时间复杂度为O($n^2$)。</p></li></ul></li><li><p>空间复杂度</p><ul><li>直接插入排序算法的空间复杂度为O(1)</li></ul></li><li><p>直接插入排序算法是一种稳定的排序算法</p><h4 id="5）源码地址"><a href="#5）源码地址" class="headerlink" title="5）源码地址"></a>5）源码地址</h4><p>​            <a href="https://github.com/Aoki-Wang/CheckStation/tree/master/Data%20Structure/Insert%20Sort/Direct%20Insert%20Sort" target="_blank" rel="noopener">直接插入排序实现源码</a></p></li></ul><ol start="2"><li><h3 id="链表插入排序"><a href="#链表插入排序" class="headerlink" title="链表插入排序"></a>链表插入排序</h3><p>&emsp;&emsp;链表插入排序的最终排序结果将把对象集合按关键码大小依次链接地存储在一个链表中。这时链表中每个结点的结构除数据域外要增加一个指向结点类型的指针域。</p><ul><li>链表插入排序的思想是：初始时链表为空，第一个对象<code>R[0]</code>直接插入到链表中。第二个对象<code>R[1]</code>插入到链表中的位置由<code>K[0]</code>和<code>K[1]</code>比较确定：若K[1]<code>&lt;</code>K[0]<code>，则把</code>R[1]<code>插入到</code>R[0]<code>前；否则把R[1]插入到R[0]</code>后.</li><li>第三个对象<code>R[2]</code>插入到链表中的位置由K[2]<code>和</code>K[1]<code>、K[0]</code>比较确定。若<code>K[2]&lt;K[0]</code>,则把<code>K[2]</code>插入到<code>K[0]</code>前。若<code>K[2]&gt;K[0]</code>，应比较<code>K[2]、K[1]</code>；</li><li>若<code>K[2]&lt;K[1]</code>，则把<code>R[2]</code>插入到<code>R[0]</code>后，<code>R[1]</code>前，若<code>K[2]&gt;K[1]</code>，则把<code>R[2]</code>插入到<code>R[1]</code>后。</li><li>这样的插入过程进行到<code>R[n-1]</code>插入完成后，则原始对象集合按关键码大小依次链接在一个链表中。</li></ul><h4 id="1）链表插入排序的实现"><a href="#1）链表插入排序的实现" class="headerlink" title="1）链表插入排序的实现"></a>1）链表插入排序的实现</h4><h5 id="链表中结点的数据类型定义："><a href="#链表中结点的数据类型定义：" class="headerlink" title="链表中结点的数据类型定义："></a>链表中结点的数据类型定义：</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">T data;<span class="comment">//数据域</span></span><br><span class="line">Node* next;<span class="comment">//指针域</span></span><br><span class="line">Node(Node* p = <span class="literal">NULL</span>) :next(p) &#123;&#125;<span class="comment">//用于构造头结点</span></span><br><span class="line">Node(T item,Node*p=<span class="literal">NULL</span>):data(item),next(p)&#123;&#125;<span class="comment">//构造其他存放数据元素的结点</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol><h5 id="链表插入排序的实现："><a href="#链表插入排序的实现：" class="headerlink" title="链表插入排序的实现："></a>链表插入排序的实现：</h5>   <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">LinkListInsertSort</span>(<span class="title">T</span> <span class="title">a</span>[], <span class="title">Node</span>&lt;T&gt;*&amp; <span class="title">list</span>, <span class="title">int</span> <span class="title">n</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">Node&lt;T&gt;* curr, * pre, * q;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line">curr = <span class="built_in">list</span>-&gt;next;</span><br><span class="line">pre = <span class="built_in">list</span>;</span><br><span class="line">q = <span class="keyword">new</span> Node&lt;T&gt;(a[i]);</span><br><span class="line"><span class="keyword">while</span> (curr != <span class="literal">NULL</span> &amp;&amp; curr-&gt;data &lt;= a[i])</span><br><span class="line">&#123;</span><br><span class="line">pre = curr;</span><br><span class="line">curr = curr-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">q-&gt;next = pre-&gt;next;</span><br><span class="line">pre-&gt;next = q;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2）测试函数-1"><a href="#2）测试函数-1" class="headerlink" title="2）测试函数"></a>2）测试函数</h4>   <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> arr[]= &#123; <span class="number">15</span>,<span class="number">22</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">56</span>,<span class="number">89</span>,<span class="number">14</span> &#125;;</span><br><span class="line">   <span class="keyword">int</span> n = <span class="keyword">sizeof</span>(arr) / <span class="keyword">sizeof</span>(arr[<span class="number">0</span>])<span class="number">-1</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"原数组为："</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; arr[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">Node&lt;<span class="keyword">int</span>&gt;* <span class="built_in">list</span> = <span class="keyword">new</span> Node&lt;<span class="keyword">int</span>&gt;;</span><br><span class="line">LinkListInsertSort(arr, <span class="built_in">list</span>, n);</span><br><span class="line">Display(<span class="built_in">list</span>);<span class="comment">//输出链表</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3）执行结果-1"><a href="#3）执行结果-1" class="headerlink" title="3）执行结果"></a>3）执行结果</h4><p>   <img src="/2019/08/01/插入排序及其实现/%E9%93%BE%E8%A1%A8%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F%E6%89%A7%E8%A1%8C%E7%BB%93%E6%9E%9C.PNG" alt="链表插入排序执行结果"></p><h4 id="4）时空复杂度分析-1"><a href="#4）时空复杂度分析-1" class="headerlink" title="4）时空复杂度分析"></a>4）时空复杂度分析</h4><ul><li><p>最坏时间复杂度</p><p>链表插入排序算法不需要移动数据对象，每插入一个对象时，最小关键码比较次数等于1，最大关键码比较次数等于链表中已排好序的对象的个数，即：</p><p>​        最小比较次数=n-1​</p><p>​        最大比较次数=$\sum^{n-1}_{i=1}{i}$=$\frac{n(n-1)}{2}$</p><p>所以，链表插入排序算法最坏情况的时间复杂度为O($n^2$)。</p></li><li><p>空间复杂度</p><p>链表插入排序算法另外需要n个结点存放排好序的数据对象，所以，链表插入排序算法的空间复杂度为O(n).</p></li><li><p>链表插入排序算法是一种稳定的排序算法。</p><h4 id="5）源码地址-1"><a href="#5）源码地址-1" class="headerlink" title="5）源码地址"></a>5）源码地址</h4><p>​            <a href="https://github.com/Aoki-Wang/CheckStation/tree/master/Data%20Structure/Insert%20Sort/List%20Insert%20Sort" target="_blank" rel="noopener">链表插入排序实现源码</a></p></li></ul><ol start="3"><li><h3 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h3><p>&emsp;&emsp;希尔排序又称作最小增量排序，希尔排序算法的思想是：不断把待排序的对象分成若干个小组，对同一小组内的对象用直接插入法进行排序，当完成了所有对象都分在一个小组内的排序之后，排序过程结束。</p><p>&emsp;&emsp;希尔排序是在分组概念上的插入排序，即在不断缩小组的个数时把原各小组的对象插入到新组中的合适位置上。</p><p>&emsp;&emsp;原始对象集合越接近有序，直接插入排序算法的时间效率越高，这也是希尔排序算法能够成立的基础。希尔排序算法把待排序对象分成若干小组，在小组内用直接插入排序算法排序，当把小的小组合并为一些大的小组时，其中的对象集合将会接近有序，从而使直接插入排序算法的时间效率很高。</p><h4 id="1）希尔排序的实现"><a href="#1）希尔排序的实现" class="headerlink" title="1）希尔排序的实现"></a>1）希尔排序的实现</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">ShellSort</span>(<span class="title">T</span> <span class="title">arr</span>[], <span class="title">int</span> <span class="title">n</span>, <span class="title">int</span> <span class="title">increment</span>[], <span class="title">int</span> <span class="title">numOfIncrement</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">T temp;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> m = <span class="number">0</span>; m &lt; numOfIncrement; m++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; increment[m]; k++)</span><br><span class="line">&#123;<span class="comment">//每个小组内按直接插入排序算法排序，区别只是每次不是增1，而是increment[m]</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = k; i &lt; n - increment[m]; i = i + increment[m])</span><br><span class="line">&#123;</span><br><span class="line">temp = arr[i + increment[m]];</span><br><span class="line"><span class="keyword">int</span> j = i;</span><br><span class="line"><span class="keyword">while</span> (j &gt; <span class="number">-1</span> &amp;&amp; temp &lt;= arr[j])</span><br><span class="line">&#123;</span><br><span class="line">arr[j + increment[m]] = arr[j];</span><br><span class="line">j = j - increment[m];</span><br><span class="line">&#125;</span><br><span class="line">arr[j + increment[m]] = temp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2）希尔排序过程"><a href="#2）希尔排序过程" class="headerlink" title="2）希尔排序过程"></a>2）希尔排序过程</h4><p>当增量increment=4时：</p><p><img src="/2019/08/01/插入排序及其实现/increment=4.PNG" alt="希尔排序过程1"></p><p>当增量increment=3时：</p><p><img src="/2019/08/01/插入排序及其实现/increment=3.PNG" alt="希尔排序过程2"></p><p>当增量increment=1时：</p><p><img src="/2019/08/01/插入排序及其实现/increment=1.PNG" alt="希尔排序过程3"></p><h4 id="3）测试函数"><a href="#3）测试函数" class="headerlink" title="3）测试函数"></a>3）测试函数</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> arr[]= &#123; <span class="number">15</span>,<span class="number">22</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">56</span>,<span class="number">89</span>,<span class="number">14</span> &#125;;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"原数组为："</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">   <span class="keyword">int</span> n = <span class="keyword">sizeof</span>(arr) / <span class="keyword">sizeof</span>(arr[<span class="number">0</span>])<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; arr[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">int</span> increment[] = &#123; <span class="number">4</span>,<span class="number">3</span>,<span class="number">1</span> &#125;;</span><br><span class="line"><span class="keyword">int</span> numOfIncrement = <span class="keyword">sizeof</span>(increment) / <span class="keyword">sizeof</span>(increment[<span class="number">0</span>]);</span><br><span class="line">ShellSort(arr, n, increment, numOfIncrement);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"排序结果："</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; arr[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h4 id="4）执行结果"><a href="#4）执行结果" class="headerlink" title="4）执行结果"></a>4）执行结果</h4><p>   <img src="/2019/08/01/插入排序及其实现/%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F%E6%89%A7%E8%A1%8C%E7%BB%93%E6%9E%9C1.PNG" alt="希尔排序执行结果"></p><h4 id="5）时空复杂度"><a href="#5）时空复杂度" class="headerlink" title="5）时空复杂度"></a>5）时空复杂度</h4><ul><li><p>时间复杂度：</p><ul><li>比较希尔排序和直接排序算法可见，直接插入排序算法是两重循环，希尔排序算法是四重循环，但分析希尔排序算法中四重循环的循环数值可以发现，四重循环每重的循环数值都很小，并且当增量递减、小组变大时，小组内的对象数值已经基本有序了，而我们知道，越接近有序的直接插入，排序算法的时间效率越高。因此，希尔排序算法的时间复杂度较直接插入排序算法的时间复杂度改善了很多。</li><li>希尔排序算法的时间复杂度分析比较复杂，实际所需的时间取决于各次排序时增量的个数和增量的取值。研究证明，若增量的取值合理，希尔排序算法的时间复杂度约为O(n$({lgn})^2$)。</li></ul></li><li><p>空间复杂度：</p><p>希尔排序算法的空间复杂度为O(1)。由于希尔排序算法是按增量分组进行的排序，所以希尔排序是一种不稳定的排序算法。</p><h4 id="5）源码地址-2"><a href="#5）源码地址-2" class="headerlink" title="5）源码地址"></a>5）源码地址</h4><p>​            <a href="https://github.com/Aoki-Wang/CheckStation/tree/master/Data%20Structure/Insert%20Sort/Shell%20Sort" target="_blank" rel="noopener">希尔排序实现源码</a></p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、排序的基本概念&quot;&gt;&lt;a href=&quot;#一、排序的基本概念&quot; class=&quot;headerlink&quot; title=&quot;一、排序的基本概念&quot;&gt;&lt;/a&gt;一、排序的基本概念&lt;/h2&gt;&lt;p&gt;&amp;emsp;&amp;emsp;&lt;code&gt;排序&lt;/code&gt;是将一个无序的数据元素集合整理
      
    
    </summary>
    
      <category term="数据结构" scheme="http://wanqbin.xyz/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="排序" scheme="http://wanqbin.xyz/tags/%E6%8E%92%E5%BA%8F/"/>
    
      <category term="插入排序" scheme="http://wanqbin.xyz/tags/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/"/>
    
      <category term="直接插入排序" scheme="http://wanqbin.xyz/tags/%E7%9B%B4%E6%8E%A5%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/"/>
    
      <category term="链表插入排序" scheme="http://wanqbin.xyz/tags/%E9%93%BE%E8%A1%A8%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/"/>
    
      <category term="希尔排序" scheme="http://wanqbin.xyz/tags/%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>二叉搜索树及其实现</title>
    <link href="http://wanqbin.xyz/2019/07/31/%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E5%8F%8A%E5%85%B6%E5%AE%9E%E7%8E%B0/"/>
    <id>http://wanqbin.xyz/2019/07/31/叉搜索树及其实现/</id>
    <published>2019-07-31T15:36:00.000Z</published>
    <updated>2019-07-31T15:49:49.145Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、二叉搜索树概述"><a href="#一、二叉搜索树概述" class="headerlink" title="一、二叉搜索树概述"></a>一、二叉搜索树概述</h2><p>&emsp;&emsp;一棵二叉搜索树(Binary Search Tree,BST)是以一棵二叉树来组织的。BST是满足下面条件的二叉树，该条件即二叉搜索树属性：</p><ul><li>对于二叉搜索树的一个结点，设其值为K，则该结点左子树任意一个结点的值都小于K</li><li>该结点右子树中任意一个结点的值都大于或等于K。</li></ul><p>&emsp;二叉查找树的特点是，如果按照中序周游将各个结点打印出来，就会得到由小到大排列结点。</p><p>&emsp;&emsp;从根结点开始，在BST中检索值K。如果根结点存储的值为K，则检索结束。如果不是，则必须检索树的更深一层。BST的效率在于只需检索两棵子树之一。如果K小于根结点的值，则只需检索左子树；如果K大于根结点的值，则只需检索右子树。这个过程一直持续到K被找到或遇到一个叶结点为止。如果遇到叶结点仍没有发现K，那么K就不在这个BST中。</p><h2 id="二、二叉搜索树的实现"><a href="#二、二叉搜索树的实现" class="headerlink" title="二、二叉搜索树的实现"></a>二、二叉搜索树的实现</h2><h4 id="emsp-二叉搜索树结点类的定义："><a href="#emsp-二叉搜索树结点类的定义：" class="headerlink" title="&emsp;二叉搜索树结点类的定义："></a>&emsp;二叉搜索树结点类的定义：</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;<span class="title">class</span> <span class="title">BinarySearchTree</span>;</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;<span class="title">class</span> <span class="title">BitreeNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">BinarySearchTree</span>&lt;T&gt;;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">T data;<span class="comment">//数据域</span></span><br><span class="line">BitreeNode() :leftChild(<span class="literal">NULL</span>), rightChild(<span class="literal">NULL</span>) &#123;&#125;<span class="comment">//构造函数</span></span><br><span class="line">BitreeNode(T item, BitreeNode&lt;T&gt;* left = <span class="literal">NULL</span>, BitreeNode&lt;T&gt;* right = <span class="literal">NULL</span>)</span><br><span class="line">:data(item), leftChild(left), rightChild(right) &#123;&#125;</span><br><span class="line">~BitreeNode() &#123;&#125;<span class="comment">//析构函数</span></span><br><span class="line">BitreeNode&lt;T&gt;*&amp; Left()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> leftChild;</span><br><span class="line">&#125;</span><br><span class="line">BitreeNode&lt;T&gt;*&amp; Right()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> rightChild;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">BitreeNode&lt;T&gt;* leftChild;<span class="comment">//左子树指针</span></span><br><span class="line">BitreeNode&lt;T&gt;* rightChild;<span class="comment">//右子树指针</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>二叉搜索树是以二叉树来组织的，所以其结点类的定义于二叉树结点类的定义相同。</p><h4 id="二叉搜索树类的定义："><a href="#二叉搜索树类的定义：" class="headerlink" title="二叉搜索树类的定义："></a>二叉搜索树类的定义：</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;<span class="title">class</span> <span class="title">BinarySearchTree</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">BinarySearchTree() :root(<span class="literal">NULL</span>) &#123;&#125;<span class="comment">//无参构造参数</span></span><br><span class="line">BinarySearchTree(<span class="keyword">const</span> BinarySearchTree&amp; rhs);<span class="comment">//有参构造函数</span></span><br><span class="line">~BinarySearchTree();<span class="comment">//析构函数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">const</span> T&amp; <span class="title">findMax</span><span class="params">()</span> <span class="keyword">const</span></span>;<span class="comment">//寻找最大值</span></span><br><span class="line"><span class="function"><span class="keyword">const</span> T&amp; <span class="title">findMin</span><span class="params">()</span> <span class="keyword">const</span></span>;<span class="comment">//寻找最小值</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">contains</span><span class="params">(<span class="keyword">const</span> T&amp; value)</span> <span class="keyword">const</span></span>;<span class="comment">//判断value是否存在</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isEmpty</span><span class="params">()</span> <span class="keyword">const</span></span>;<span class="comment">//二叉搜索树是否为空</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InOrder</span><span class="params">(<span class="keyword">void</span>(*visit)(T item))</span> <span class="keyword">const</span></span>;<span class="comment">//输出树结点</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">makeEmpty</span><span class="params">()</span></span>;<span class="comment">//清空树</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">const</span> T&amp;value)</span></span>;<span class="comment">//插入</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">remove</span><span class="params">(<span class="keyword">const</span> T&amp;value)</span></span>;<span class="comment">//删除值为value的结点</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">BitreeNode&lt;T&gt;* root;<span class="comment">//根结点</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">const</span> T&amp; value, BitreeNode&lt;T&gt;*&amp; t)</span> <span class="keyword">const</span></span>;<span class="comment">//插入新结点</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">remove</span><span class="params">(<span class="keyword">const</span> T&amp; value, BitreeNode&lt;T&gt;*&amp; t)</span> <span class="keyword">const</span></span>;<span class="comment">//删除结点</span></span><br><span class="line">BitreeNode&lt;T&gt;* finMin(BitreeNode&lt;T&gt;* t) <span class="keyword">const</span>;<span class="comment">//查找二叉搜索树中值最小的结点</span></span><br><span class="line">BitreeNode&lt;T&gt;* finMax(BitreeNode&lt;T&gt;* t) <span class="keyword">const</span>;<span class="comment">//查找二叉搜索树中值最大的结点</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">contains</span><span class="params">(<span class="keyword">const</span> T&amp; value, BitreeNode&lt;T&gt;* t)</span> <span class="keyword">const</span></span>;<span class="comment">//判断二叉搜索树中是否存在一个值为value的结点</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">makeEmpty</span><span class="params">(BitreeNode&lt;T&gt;*&amp; t)</span></span>;<span class="comment">//清空结点</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InOrder</span><span class="params">(BitreeNode&lt;T&gt;* t, <span class="keyword">void</span>(*visit)(T item))</span><span class="keyword">const</span></span>;<span class="comment">//中序输出结点</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PreOrder</span><span class="params">(BitreeNode&lt;T&gt;* t, <span class="keyword">void</span>(*visit)(T item))</span> <span class="keyword">const</span></span>;<span class="comment">//前序输出结点</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PostOrder</span><span class="params">(BitreeNode&lt;T&gt;* t, <span class="keyword">void</span>(*visit)(T item))</span> <span class="keyword">const</span></span>;<span class="comment">//后序输出结点</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>二叉搜索树的一个最重要的应用就是它们在查找中的应用。虽然任意复杂的项在C++中都很容易处理，但是为了简单起见，先假设它们都是整数。</p><p>其实现的部分代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">bool</span> <span class="title">BinarySearchTree</span>&lt;T&gt;:</span>:contains(<span class="keyword">const</span> T&amp; value) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> contains(value, root);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">bool</span> <span class="title">BinarySearchTree</span>&lt;T&gt;:</span>:contains(<span class="keyword">const</span> T&amp; value, BitreeNode&lt;T&gt;* t) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (t == <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (value &lt; t-&gt;data)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> contains(value, t-&gt;leftChild);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (value &gt; t-&gt;data)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> contains(value, t-&gt;rightChild);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>contains</code>函数用来判断二叉树中是否存在值为value的结点。如果在树中存在该结点，那么该函数返回<code>true</code>,否则返回<code>false</code>.树的结构使得该操作很简单。如果树为空，则返回<code>false</code>,否则，如果根结点的值为value，则返回<code>true</code>。若以上两种情况都不成立，则根据value与根结点值的大小关系决定对左子树还是右子树进行递归调用。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> <span class="title">BinarySearchTree</span>&lt;T&gt;:</span>:InOrder(BitreeNode&lt;T&gt;* t,<span class="keyword">void</span>(*visit)(T item)) <span class="keyword">const</span></span><br><span class="line">&#123;<span class="comment">//中序遍历</span></span><br><span class="line"><span class="keyword">if</span> (t != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">printTree(t-&gt;leftChild, visit);</span><br><span class="line">visit(t-&gt;data);</span><br><span class="line">printTree(t-&gt;rightChild, visit);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> <span class="title">BinarySearchTree</span>&lt;T&gt;:</span>:PreOrder(BitreeNode&lt;T&gt;* t, <span class="keyword">void</span>(*visit)(T item)) <span class="keyword">const</span></span><br><span class="line">&#123;<span class="comment">//前序遍历</span></span><br><span class="line"><span class="keyword">if</span> (t != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">visit(t-&gt;data);</span><br><span class="line">PreOrder(t-&gt;leftChild, visit);</span><br><span class="line">PreOrder(t-&gt;rightChild, visit);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> <span class="title">BinarySearchTree</span>&lt;T&gt;:</span>:PostOrder(BitreeNode&lt;T&gt;* t, <span class="keyword">void</span>(*visit)(T item)) <span class="keyword">const</span></span><br><span class="line">&#123;<span class="comment">//后序遍历</span></span><br><span class="line"><span class="keyword">if</span> (t != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">PostOrder(t-&gt;leftChild,visit);</span><br><span class="line">PostOrder(t-&gt;rightChild, visit);</span><br><span class="line">visit(t-&gt;data);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上分别为中序遍历，前序遍历和后序遍历。其中，中序遍历的输出结果是从小到大进行排列的，这也是二叉搜索树的一个特点。中序遍历(LDR)、前序遍历(DLR)、后序遍历(LRD)。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">BitreeNode</span>&lt;T&gt;* <span class="title">BinarySearchTree</span>&lt;T&gt;:</span>:finMin(BitreeNode&lt;T&gt;* t) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (t != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span> (t-&gt;leftChild != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">t = t-&gt;leftChild;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">BitreeNode</span>&lt;T&gt;* <span class="title">BinarySearchTree</span>&lt;T&gt;:</span>:finMax(BitreeNode&lt;T&gt;* t) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (t != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span> (t-&gt;rightChild != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">t = t-&gt;rightChild;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上两个函数是用来查找最大值和最小值。由于二叉搜索函树的性质，所以查找最大值和最小值也比较方便。对于最小值，还需要查找到最左叶子结点，即为最小值；而最大值则需要查找到最右叶子节点，即为最大值。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> <span class="title">BinarySearchTree</span>&lt;T&gt;:</span>:insert(<span class="keyword">const</span> T&amp; value, BitreeNode&lt;T&gt;*&amp; t) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (t == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">t = <span class="keyword">new</span> BitreeNode&lt;T&gt;(value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (value &lt; t-&gt;data)</span><br><span class="line">&#123;</span><br><span class="line">insert(value, t-&gt;leftChild);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (value &gt; t-&gt;data)</span><br><span class="line">&#123;</span><br><span class="line">insert(value, t-&gt;rightChild);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于一个二叉搜索树来说，<code>insert</code>函数相对来说比较重要，因为二叉搜索树的属性是左孩子始终比双亲结点小，而右孩子始终比双亲结点大。此时需要注意的是，此二叉搜索树并不能处理插入已存在数据的操作，即二叉树结点中的每一项的值是各不相同的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> <span class="title">BinarySearchTree</span>&lt;T&gt;:</span>:remove(<span class="keyword">const</span> T&amp; value,BitreeNode&lt;T&gt;*&amp; t) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (t == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (value &lt; t-&gt;data)</span><br><span class="line">&#123;</span><br><span class="line">remove(value, t-&gt;leftChild);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (value &gt; t-&gt;data)</span><br><span class="line">&#123;</span><br><span class="line">remove(value, t-&gt;rightChild);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (t-&gt;leftChild != <span class="literal">NULL</span> &amp;&amp; t-&gt;rightChild != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">t-&gt;data = findMin(t-&gt;right)-&gt;data;</span><br><span class="line">remove(t-&gt;data, t-&gt;rightChild);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">BitreeNode&lt;T&gt;* oldNode = t;</span><br><span class="line">t = (t-&gt;leftChild != <span class="literal">NULL</span>) ? t-&gt;leftChild : t-&gt;rightChild;</span><br><span class="line"><span class="keyword">delete</span> oldNode;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最值得注意的是删除操作，即<code>remove</code>。删除操作需要考虑多种情况。</p><ul><li>当要删除的对象为叶子结点时，可以直接删除该叶子结点。</li><li>如果结点有一个孩子，则该结点可以在其父结点调整它的链以绕过该结点后被删除。图示如下：</li></ul><p><img src="/2019/07/31/叉搜索树及其实现/%E5%85%B7%E6%9C%89%E4%B8%80%E4%B8%AA%E5%84%BF%E5%AD%90%E7%9A%84%E7%BB%93%E7%82%B94%E5%88%A0%E9%99%A4%E5%89%8D%E5%90%8E%E7%9A%84%E6%83%85%E5%86%B5.PNG" alt="删除具有一个孩子的结点4前后的情况"></p><p>​    在该树中，我们删除了具有一个孩子的结点4。</p><ul><li>复杂的情况是，处理具有两个孩子的结点。一般的删除策略是用其右子树的最小数据代替该结点的数据并递归地删除该结点。因为右子树中的最小的结点不可能有左孩子，所以第二次<code>remove</code>就很容易了。图示如下：</li></ul><p><img src="/2019/07/31/叉搜索树及其实现/%E5%88%A0%E9%99%A4%E5%85%B7%E6%9C%89%E4%B8%A4%E4%B8%AA%E5%AD%A9%E5%AD%90%E7%9A%84%E7%BB%93%E7%82%B92%E5%89%8D%E5%90%8E%E7%9A%84%E6%83%85%E5%86%B5.PNG" alt="删除具有两个孩子的结点2前后的情况"></p><p>​    在该树中，我们删除了具有两个孩子的结点4，其中虚线连接的结点代表已经删除了。右边的图是删除后的结果。在删除后，它被右子树中最小的值，即3代替了。</p><h2 id="三、主函数及执行结果"><a href="#三、主函数及执行结果" class="headerlink" title="三、主函数及执行结果"></a>三、主函数及执行结果</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">"BST.h"</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">BinarySearchTree&lt;<span class="keyword">int</span>&gt; BST;</span><br><span class="line">BST.insert(<span class="number">20</span>);</span><br><span class="line">BST.insert(<span class="number">18</span>);</span><br><span class="line">BST.insert(<span class="number">5</span>);</span><br><span class="line">BST.insert(<span class="number">10</span>);</span><br><span class="line">BST.insert(<span class="number">25</span>);</span><br><span class="line">BST.insert(<span class="number">4</span>);</span><br><span class="line">BST.insert(<span class="number">21</span>);</span><br><span class="line">BST.insert(<span class="number">18</span>);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"最大值："</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; BST.findMax() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"最小值："</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; BST.findMin() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">int</span> temp = <span class="number">18</span>;</span><br><span class="line"><span class="keyword">if</span> (BST.contains(temp))</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"BST中存在"</span> &lt;&lt;temp&lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"BST中不存在"</span>&lt;&lt;temp &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">BST.InOrder(Visit);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">BST.makeEmpty();</span><br><span class="line"><span class="keyword">if</span> (BST.isEmpty())</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"BST为空！"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"BST非空！"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">system(<span class="string">"pause"</span>);</span><br><span class="line"><span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="执行结果："><a href="#执行结果：" class="headerlink" title="执行结果："></a>执行结果：</h4><p><img src="/2019/07/31/叉搜索树及其实现/%E6%89%A7%E8%A1%8C%E7%BB%93%E6%9E%9C.PNG" alt="执行结果"></p><h2 id="四、源码地址"><a href="#四、源码地址" class="headerlink" title="四、源码地址"></a>四、源码地址</h2><p>​            <a href="https://github.com/Aoki-Wang/CheckStation/tree/master/Data%20Structure/Binary%20Search%20Tree" target="_blank" rel="noopener">二叉搜索树的实现源码</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、二叉搜索树概述&quot;&gt;&lt;a href=&quot;#一、二叉搜索树概述&quot; class=&quot;headerlink&quot; title=&quot;一、二叉搜索树概述&quot;&gt;&lt;/a&gt;一、二叉搜索树概述&lt;/h2&gt;&lt;p&gt;&amp;emsp;&amp;emsp;一棵二叉搜索树(Binary Search Tree,BST
      
    
    </summary>
    
      <category term="数据结构" scheme="http://wanqbin.xyz/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="二叉树" scheme="http://wanqbin.xyz/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
      <category term="二叉搜索树" scheme="http://wanqbin.xyz/tags/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/"/>
    
      <category term="BST" scheme="http://wanqbin.xyz/tags/BST/"/>
    
  </entry>
  
  <entry>
    <title>二叉树的实现</title>
    <link href="http://wanqbin.xyz/2019/07/31/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%AE%9E%E7%8E%B0/"/>
    <id>http://wanqbin.xyz/2019/07/31/二叉树的实现/</id>
    <published>2019-07-31T15:20:00.000Z</published>
    <updated>2019-08-01T01:36:46.795Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、二叉树结点类定义"><a href="#一、二叉树结点类定义" class="headerlink" title="一、二叉树结点类定义"></a>一、二叉树结点类定义</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;<span class="title">class</span> <span class="title">BinaryTree</span>;</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;<span class="title">class</span> <span class="title">BiTreeNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">BinaryTree</span>&lt;T&gt;;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">T data;<span class="comment">//数据域</span></span><br><span class="line">BiTreeNode() :leftChild(<span class="literal">NULL</span>), rightChild(<span class="literal">NULL</span>) &#123;&#125;<span class="comment">//构造函数</span></span><br><span class="line">BiTreeNode(T item,BiTreeNode&lt;T&gt;*left=<span class="literal">NULL</span>,BiTreeNode&lt;T&gt;*right=<span class="literal">NULL</span>)<span class="comment">//构造函数</span></span><br><span class="line">:data(item),leftChild(left),rightChild(right)&#123;&#125;</span><br><span class="line">~BiTreeNode()&#123;&#125;<span class="comment">//析构函数</span></span><br><span class="line"></span><br><span class="line">BiTreeNode&lt;T&gt;*&amp; Left()</span><br><span class="line">&#123;<span class="comment">//获得左孩子</span></span><br><span class="line"><span class="keyword">return</span> leftChild;</span><br><span class="line">&#125;</span><br><span class="line">BiTreeNode&lt;T&gt;*&amp; Right()</span><br><span class="line">&#123;<span class="comment">//获得右孩子</span></span><br><span class="line"><span class="keyword">return</span> rightChild;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">BiTreeNode&lt;T&gt;* leftChild;<span class="comment">//左子树指针</span></span><br><span class="line">BiTreeNode&lt;T&gt;* rightChild;<span class="comment">//右子树指针</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="二、二叉树类定义"><a href="#二、二叉树类定义" class="headerlink" title="二、二叉树类定义"></a>二、二叉树类定义</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;<span class="title">class</span> <span class="title">BinaryTree</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">BinaryTree() :root(<span class="literal">NULL</span>)&#123;&#125;;<span class="comment">//构造函数</span></span><br><span class="line">~BinaryTree() &#123;&#125;;<span class="comment">//析构函数</span></span><br><span class="line"><span class="comment">//构造二叉树</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MakeTree</span><span class="params">(<span class="keyword">const</span> T&amp; item)</span></span>;</span><br><span class="line"><span class="comment">//第一类操作的成员函数</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Root</span><span class="params">()</span></span>;<span class="comment">//使根结点为当前结点</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Parent</span><span class="params">()</span></span>;<span class="comment">//使双亲结点为当前结点</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">LeftChild</span><span class="params">()</span></span>;<span class="comment">//使左孩子结点为当前结点</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">RightChild</span><span class="params">()</span></span>;<span class="comment">//使右孩子结点为当前结点</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//第二类操作的成员函数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InsertChild</span><span class="params">(<span class="keyword">const</span> T &amp;value)</span></span>;<span class="comment">//使根结点为当前结点</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DeleteSubTree</span><span class="params">(BiTreeNode&lt;T&gt;*&amp; t)</span></span>;<span class="comment">//删除以t为根结点的子树</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span></span>;<span class="comment">//清空树</span></span><br><span class="line"><span class="comment">//第三类操作的成员函数</span></span><br><span class="line"><span class="comment">//遍历访问二叉树</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PreOrder</span><span class="params">(<span class="keyword">void</span>(*visit)(T item))</span></span>;<span class="comment">//前序遍历访问树</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InOrder</span><span class="params">(<span class="keyword">void</span>(*visit)(T item))</span></span>;<span class="comment">//中序遍历访问树</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PostOrder</span><span class="params">(<span class="keyword">void</span>(*visit)(T item))</span></span>;<span class="comment">//后序遍历访问树</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">BiTreeNode&lt;T&gt;* root;<span class="comment">//根结点指针</span></span><br><span class="line">BiTreeNode&lt;T&gt;* current;<span class="comment">//当前结点指针</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Current</span><span class="params">(BiTreeNode&lt;T&gt;*&amp; t)</span></span>;<span class="comment">//使当前结点为t所指结点</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PreOrder</span><span class="params">(BiTreeNode&lt;T&gt;*&amp; t, <span class="keyword">void</span>(*visit)(T item))</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InOrder</span><span class="params">(BiTreeNode&lt;T&gt;*&amp; t, <span class="keyword">void</span>(*visit)(T item))</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PostOrder</span><span class="params">(BiTreeNode&lt;T&gt;*&amp; t, <span class="keyword">void</span>(*visit)(T item))</span></span>;</span><br><span class="line"><span class="comment">//插入</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Insert</span><span class="params">(<span class="keyword">const</span> T&amp; value, BiTreeNode&lt;T&gt;*&amp; t)</span></span>;</span><br><span class="line"><span class="comment">//在树root中回溯查找s的双亲结点</span></span><br><span class="line">BiTreeNode&lt;T&gt;* SearchParent(BiTreeNode&lt;T&gt;*&amp; root, BiTreeNode&lt;T&gt;*&amp; s);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="三、二叉树实现的部分代码"><a href="#三、二叉树实现的部分代码" class="headerlink" title="三、二叉树实现的部分代码"></a>三、二叉树实现的部分代码</h2><h4 id="前序遍历"><a href="#前序遍历" class="headerlink" title="前序遍历"></a>前序遍历</h4><p>即DLR，也叫做先根遍历、先序遍历、前序周游，记作根左右。前序遍历首先访问根结点，然后遍历左子树，最后遍历右子树。</p><p>这里使用<code>visit(item)</code>函数来输出结点数据域值，同时，<code>visit(item)</code>函数经过修改之后，也可以输出自定义数据类型中需要输出的数据。</p><p><code>visit(item)</code>函数的实现如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">Visit</span>(<span class="title">T</span> <span class="title">item</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; item &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> <span class="title">BinaryTree</span>&lt;T&gt;:</span>:PreOrder(<span class="keyword">void</span>(*visit)(T item))</span><br><span class="line">&#123;</span><br><span class="line">PreOrder(root,Visit);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> <span class="title">BinaryTree</span>&lt;T&gt;:</span>:PreOrder(BiTreeNode&lt;T&gt;*&amp; t, <span class="keyword">void</span>(*visit)(T item))</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (t != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">visit(t-&gt;data);</span><br><span class="line">PreOrder(t-&gt;leftChild,visit);</span><br><span class="line">PreOrder(t-&gt;rightChild,visit);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h4><p>即DLR，也叫中根遍历、中序周游。可记作根左右。在二叉树中，中序遍历首先遍历左子树，然后访问根结点，最后遍历右子树。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> <span class="title">BinaryTree</span>&lt;T&gt;:</span>:InOrder(<span class="keyword">void</span>(*visit)(T item))</span><br><span class="line">&#123;</span><br><span class="line">InOrder(root,Visit);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> <span class="title">BinaryTree</span>&lt;T&gt;:</span>:InOrder(BiTreeNode&lt;T&gt;*&amp; t, <span class="keyword">void</span>(*visit)(T item))</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (t != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">InOrder(t-&gt;leftChild, visit);</span><br><span class="line">visit(t-&gt;data);</span><br><span class="line">InOrder(t-&gt;rightChild, visit);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h4><p>即LRD，也叫后根遍历、后序变周游，可记作左右根。在二叉树中，首先遍历左子树，然后遍历右子树，最后访问根结点。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> <span class="title">BinaryTree</span>&lt;T&gt;:</span>:PostOrder(<span class="keyword">void</span>(*visit)(T item))</span><br><span class="line">&#123;</span><br><span class="line">PostOrder(root,Visit);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> <span class="title">BinaryTree</span>&lt;T&gt;:</span>:PostOrder(BiTreeNode&lt;T&gt;*&amp; t, <span class="keyword">void</span>(*visit)(T item))</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (t != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">PostOrder(t-&gt;leftChild, visit);</span><br><span class="line">PostOrder(t-&gt;rightChild, visit);</span><br><span class="line">visit(t-&gt;data);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="删除子树"><a href="#删除子树" class="headerlink" title="删除子树"></a>删除子树</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> <span class="title">BinaryTree</span>&lt;T&gt;:</span>:DeleteSubTree(BiTreeNode&lt;T&gt;*&amp; t)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (t == <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">BiTreeNode&lt;T&gt;* q=t-&gt;leftChild, *p;</span><br><span class="line"><span class="keyword">while</span> (q != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">p = q-&gt;rightChild;</span><br><span class="line">DeleteSubTree(q);</span><br><span class="line">q = p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">delete</span> t;</span><br><span class="line">t = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="插入结点"><a href="#插入结点" class="headerlink" title="插入结点"></a>插入结点</h4><p>在此实现中，对于二叉树结点的插入基本与二叉搜索树相同。当根结点为空时，新插入的结点作为根结点。当新插入的结点值小于根结点值时，插入到左子树；当新插入的结点值大于根结点值时，插入到右子树。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> <span class="title">BinaryTree</span>&lt;T&gt;:</span>:InsertChild(<span class="keyword">const</span> T&amp; value)</span><br><span class="line">&#123;</span><br><span class="line">Insert(value, root);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> <span class="title">BinaryTree</span>&lt;T&gt;:</span>:Insert(<span class="keyword">const</span> T&amp; value, BiTreeNode&lt;T&gt;*&amp; t)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (t == <span class="literal">NULL</span>)</span><br><span class="line">t = <span class="keyword">new</span> BiTreeNode&lt;T&gt;(value);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (value &lt; t-&gt;data)</span><br><span class="line">&#123;</span><br><span class="line">Insert(value, t-&gt;leftChild);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (value &gt; t-&gt;data)</span><br><span class="line">&#123;</span><br><span class="line">Insert(value, t-&gt;rightChild);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="四、主函数及执行结果"><a href="#四、主函数及执行结果" class="headerlink" title="四、主函数及执行结果"></a>四、主函数及执行结果</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">BinaryTree&lt;<span class="keyword">int</span>&gt;BiTree;</span><br><span class="line">BiTree.InsertChild(<span class="number">15</span>);</span><br><span class="line">BiTree.InsertChild(<span class="number">5</span>);</span><br><span class="line">BiTree.InsertChild(<span class="number">6</span>);</span><br><span class="line">BiTree.InsertChild(<span class="number">8</span>);</span><br><span class="line">BiTree.InsertChild(<span class="number">20</span>);</span><br><span class="line">BiTree.InsertChild(<span class="number">22</span>);</span><br><span class="line">BiTree.InsertChild(<span class="number">16</span>);</span><br><span class="line">BiTree.InsertChild(<span class="number">18</span>);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"前序："</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">BiTree.PreOrder(Visit);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span> &lt;&lt; <span class="string">"中序:"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">BiTree.InOrder(Visit);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span> &lt;&lt; <span class="string">"后序:"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">BiTree.PostOrder(Visit);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">BiTree.clear();</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"前序："</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">BiTree.PreOrder(Visit);</span><br><span class="line">system(<span class="string">"pause"</span>);</span><br><span class="line"><span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果：</p><p><img src="/2019/07/31/二叉树的实现/%E6%89%A7%E8%A1%8C%E7%BB%93%E6%9E%9C.PNG" alt="执行结果"></p><h2 id="五、源码地址"><a href="#五、源码地址" class="headerlink" title="五、源码地址"></a>五、源码地址</h2><p>​        <a href="https://github.com/Aoki-Wang/CheckStation/tree/master/Data%20Structure/BinaryTree" target="_blank" rel="noopener">二叉树的实现源码</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、二叉树结点类定义&quot;&gt;&lt;a href=&quot;#一、二叉树结点类定义&quot; class=&quot;headerlink&quot; title=&quot;一、二叉树结点类定义&quot;&gt;&lt;/a&gt;一、二叉树结点类定义&lt;/h2&gt;&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;
      
    
    </summary>
    
      <category term="数据结构" scheme="http://wanqbin.xyz/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="二叉树" scheme="http://wanqbin.xyz/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
      <category term="二叉树的遍历" scheme="http://wanqbin.xyz/tags/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86/"/>
    
  </entry>
  
  <entry>
    <title>多态</title>
    <link href="http://wanqbin.xyz/2019/07/31/%E5%A4%9A%E6%80%81/"/>
    <id>http://wanqbin.xyz/2019/07/31/多态/</id>
    <published>2019-07-31T02:22:00.000Z</published>
    <updated>2019-07-31T06:56:19.899Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、多态"><a href="#一、多态" class="headerlink" title="一、多态"></a>一、多态</h2><p>&emsp;多态是面向对象程序设计语言中数据抽象和继承之外的第三个基本特征。</p><p>&emsp;多态性(Polymorphism)提供接口与具体实现之间的另一层隔离，从而实现将“what”和“how”分离开来。多态性改善了代码的可读性和组织性，同时也使创建的程序具有可扩展性。项目不仅在最初创建时期可以扩展，而且当项目在需要有新功能时也能扩展。</p><p>&emsp;C++支持编译时多态（静态多态）和运行时多态（动态多态），运算符重载和函数重载就是编译时多态，而派生类和虚函数实现运行时多态。</p><h2 id="二、静态联编和动态联编"><a href="#二、静态联编和动态联编" class="headerlink" title="二、静态联编和动态联编"></a>二、静态联编和动态联编</h2><p>静态多态和动态多态的区别就是函数地址是早绑定（静态联编）还是晚绑定（动态联编）。如果函数的调用，在编译阶段就可以确定函数的调用地址，并产生代码，就是静态多态（联编时多态），也就是说地址是早绑定的。而如果函数的调用地址不能在编译期间确定，而需要在运行时才能决定，这就属于晚绑定（运行时多态）。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">speak</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"动物在说话"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span>:</span><span class="keyword">public</span> Animal</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">speak</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"喵喵喵"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doSpeak</span><span class="params">(Animal&amp;animal)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">animal.speak();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Cat cat;</span><br><span class="line">doSpeak(cat);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当主函数调用<code>dospeak()</code>函数时，执行结果如下：</p><p><img src="/2019/07/31/多态/%E9%9D%99%E6%80%81%E8%81%94%E7%BC%96.PNG" alt="静态联编"></p><p>&emsp;我们可以看到输出结果为“动物在说话”,这是因为当调用<code>dospeak</code>函数时，<code>speak</code>函数的地址早就绑定好了，早绑定，即动态联编，在编译近阶段就确定好了地址。</p><p>&emsp;如果想调用猫的<code>speak</code>函数，就不能提前绑定好地址，所以需要在运行的时候再去确定函数地址，即动态联编，将<code>dospeak</code>方法改为虚函数，写法是在父类上声明虚函数，发生多态。发生多态时，父类的引用或指针指向了子类对象。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">speak</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"动物在说话"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>此时运行结果为：</p><p><img src="/2019/07/31/多态/%E5%8A%A8%E6%80%81%E8%81%94%E7%BC%96.PNG" alt="动态联编"></p><h2 id="三、多态原理"><a href="#三、多态原理" class="headerlink" title="三、多态原理"></a>三、多态原理</h2><h4 id="动态绑定的实现："><a href="#动态绑定的实现：" class="headerlink" title="动态绑定的实现："></a>动态绑定的实现：</h4><p>&emsp;&emsp;当编译器发现我们的类中有虚函数时，编译器会创建一张虚函数表，把虚函数的函数入口地址放到虚函数表中，并且在类中秘密增加一个指针，这个指针就是<code>vfptr</code>，即<code>virtual function pointer</code>，这个指针是指向对象的虚函数表。在多态调用对的时候，根据<code>vfptr</code>指针，找到虚函数表来实现动态绑定。</p><p>&emsp;子类<code>Cat</code>写父类的虚函数<code>speak</code>，这中写法为重写。重写要求返回值、参数个数、类型、顺序都相同。</p><p>&emsp;当父类中有虚函数后，父类的内部结构就发生了变化。借助开发人员命令提示符为我们可以看到类的内部结构。</p><p>改变前的情况下图所示：</p><p><img src="/2019/07/31/多态/%E6%94%B9%E5%8F%98%E5%89%8D.PNG" alt="改变前"></p><p>改变后的情况如下图所示：</p><p><img src="/2019/07/31/多态/%E6%94%B9%E5%8F%98%E5%90%8E.PNG" alt="改变后"></p><p>我们可以看到，父类的内部结构发生了明显的变化，内部多了一个<code>vfptr</code>，且其大小也发生了变化。所谓<code>vfptr</code>即<code>virtual function pointer</code>，虚函数表指针，指向虚函数表。</p><p>而子类会继承父类的<code>vfptr table</code>，在构造函数中，子类会将虚函数表指针，指向自己的虚函数表。当发生重写时，会替换掉虚函数表中原有的<code>speak</code>，改为<code>&amp;Cat::speak</code></p><p>子类Cat的内部结构如下：</p><p><img src="/2019/07/31/多态/%E5%A4%9A%E6%80%81%5C%E5%AD%90%E7%B1%BB%E5%86%85%E9%83%A8%E7%BB%93%E6%9E%84.PNG" alt="Cat内部结构"></p><h2 id="四、抽象基类和纯虚函数"><a href="#四、抽象基类和纯虚函数" class="headerlink" title="四、抽象基类和纯虚函数"></a>四、抽象基类和纯虚函数</h2><p>&emsp;&emsp;在设计时，常常希望基类仅仅作为其派生类的一个接口。这就是说，仅想对基类进行向上类型转换，使用它的接口，而不希望用户实际地创建一个基类的对象。同时创建一个纯虚函数允许接口中放置成员函数，而不一定要提供一段可能对这个函数毫无意义的代码。</p><p>&emsp;&emsp;做到这一点，可以在基类中加入至少一个纯虚函数（pure virtual function)，使得基类称为抽象类(abstract class)。</p><ul><li>纯虚函数使用关键字<code>virtual</code>，并在其后面加上<code>=0</code>。如果试图去实例化一个抽象类，编译器会阻止这种操作。</li><li>当继承一个抽象类时，必须实现所有的纯虚函数，否则由抽象类派生的类也是一个抽象类。</li><li><code>virtual void func()=0;</code>告诉把编译器在<code>vtable</code>中为函数保留一个位置，但在在这个特定位置不放地址。</li></ul><blockquote><p>创建公共接口的目的是：为了将子类的公共操作抽象出来，可以通过一个公共接口来操纵一组类，且这个公共交界口不需要事先（或者不要完全实现）。可以创建一个公共类。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">speak</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span> :</span><span class="keyword">public</span> Animal</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">speak</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"喵喵喵"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"猫在吃饭"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> :</span><span class="keyword">public</span> Animal</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">speak</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"汪汪汪"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"狗在吃饭"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doEat</span><span class="params">(Animal&amp; animal)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">animal.eat();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doSpeak</span><span class="params">(Animal&amp; animal)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">animal.speak();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Cat cat;</span><br><span class="line">Dog dog;</span><br><span class="line">doSpeak(cat);</span><br><span class="line">doEat(cat);</span><br><span class="line">doSpeak(dog);</span><br><span class="line">doEat(dog);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果：<br><img src="/2019/07/31/多态/%E6%8A%BD%E8%B1%A1%E5%9F%BA%E7%B1%BB%E5%92%8C%E7%BA%AF%E8%99%9A%E5%87%BD%E6%95%B0.PNG" alt="抽象基类和纯虚函数"></p><h4 id="多态成立的条件："><a href="#多态成立的条件：" class="headerlink" title="多态成立的条件："></a>多态成立的条件：</h4><ul><li>有继承</li><li>子类重写父类虚函数<ul><li>返回值、函数名、函数参数必须与父类完全一致</li><li>子类中virtual关键字可不写</li></ul></li><li>类型兼容，父类指针或父类引用指向子类对象</li></ul><h2 id="五、虚析构和纯虚析构函数"><a href="#五、虚析构和纯虚析构函数" class="headerlink" title="五、虚析构和纯虚析构函数"></a>五、虚析构和纯虚析构函数</h2><ol><li><h4 id="虚析构函数"><a href="#虚析构函数" class="headerlink" title="虚析构函数"></a>虚析构函数</h4><p>普通的析构函数不会调用子类的析构函数，这可能会导致释放不干净。可以利用虚析构来解决这个问题。</p><p>虚析构函数时为了解决基类的指针指向派生类对象，并用基类的指针删除派生类对象。</p></li></ol>   <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">People</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">People()</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"People的构造函数"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">showName</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"><span class="keyword">virtual</span> ~People()</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"People的虚析构函数"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Worker</span> :</span><span class="keyword">public</span> People</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Worker()</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Worker的构造函数"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">name = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">10</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">showName</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"打印子类的名字"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">~Worker()</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Worker的析构函数"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">if</span> (name != <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">delete</span> name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">char</span>* name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test03</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">People* people = <span class="keyword">new</span> Worker;</span><br><span class="line">people-&gt;~People();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>   执行结果:</p><p>   <img src="/2019/07/31/多态/%E8%99%9A%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0.PNG" alt="虚析构函数"></p><ol start="2"><li><h4 id="纯虚析构函数"><a href="#纯虚析构函数" class="headerlink" title="纯虚析构函数"></a>纯虚析构函数</h4><p>纯虚析构函数在C++是合法的，但是在使用的时候有一个额外的限制：必须为纯虚析构函数提供一个函数体。</p><p>那么问题是：如果给虚析构函数提供了函数体，那怎么还能称为纯虚析构函数呢？<br>纯虚析构函数与非纯虚析构函数之间唯一的不同之处在于纯虚析构函数使得基类是抽象类，不能创建基类的对象。</p><p>纯虚析构函数需要声明和实现，在类内声明，类外实现。如果函数中出现了纯虚析构函数，那么这个类是抽象类，不可以实例化对象。</p></li></ol><h2 id="六、纯虚函数和多继承"><a href="#六、纯虚函数和多继承" class="headerlink" title="六、纯虚函数和多继承"></a>六、纯虚函数和多继承</h2><p>&emsp;&emsp;多继承带来了一些争议，但是接口继承可以说是一种毫无争议的运用。</p><p>&emsp;&emsp;绝大多数面向对象语言都不支持多继承，但是绝大多数面向对象语言都支持接口的概念，C++没有接口的概念，但是可以通过纯虚函数实现接口</p><blockquote><p>接口类中只有函数原型定义，没有任何数据定义</p></blockquote><p>&emsp;&emsp;多重继承接口不会带来二义性和复杂性问题。接口类知识一个功能声明，并不是功能实现，子类需要根据功能说明定义功能实现。</p><p>除了析构函数外，其他声明都是纯虚函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">speak</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"动物说话"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">virtual</span> ~Animal() = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Animal::~Animal()<span class="comment">//纯虚析构函数的实现</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Animal的纯虚析构函数调用"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span> :</span><span class="keyword">public</span> Animal</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Cat(<span class="keyword">const</span> <span class="built_in">string</span> name)</span><br><span class="line">&#123;</span><br><span class="line">m_Name = name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">speak</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"小猫"</span>&lt;&lt;m_Name&lt;&lt;<span class="string">"在说话"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">~Cat()</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Cat的析构函数调用"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="built_in">string</span> m_Name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test04</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//Animal animal;//抽象基类不可实例化</span></span><br><span class="line"><span class="built_in">string</span> name = <span class="string">"Mimi"</span>;</span><br><span class="line"><span class="function">Cat <span class="title">cat</span><span class="params">(name)</span></span>;</span><br><span class="line">cat.speak();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果：</p><p><img src="/2019/07/31/多态/%E7%BA%AF%E8%99%9A%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0.PNG" alt="纯虚析构函数"></p><h2 id="七、向上类型转换和向下类型转换"><a href="#七、向上类型转换和向下类型转换" class="headerlink" title="七、向上类型转换和向下类型转换"></a>七、向上类型转换和向下类型转换</h2><p>基类转派生类，即向下类型转换，是不安全的。</p><p>派生类转基类，即向上类型转换，是安全的。</p><p>如果发生了多态，就总是安全的。</p><h4 id="向下类型转换的可访问性："><a href="#向下类型转换的可访问性：" class="headerlink" title="向下类型转换的可访问性："></a>向下类型转换的可访问性：</h4><p>&emsp;&emsp;派生类向基类的转换是否可以访问由使用该转换的代码决定，同时，派生类的派生访问说明符也会有影响。假定D继承自B：</p><ul><li>只有当D公有继承B时，用户代码才能使用派生类向基类的转换；如果D继承B的方式是受保护的或者私有的，则用户代码不能使用该转换。</li><li>不论D以什么方式继承B，D的成员函数和友元都能使用派生类向基类的转换；派生类向其直接基类的转换对于派生类的成员和友元来说是永远可访问的。</li><li>如果D继承B的方式是公有的，或受保护的，则D的派生类成员可以使用D向B的类型转换，反之，如果D继承B对的方式是私有的，那么不能使用。</li></ul><h2 id="八、指向类成员的指针"><a href="#八、指向类成员的指针" class="headerlink" title="八、指向类成员的指针"></a>八、指向类成员的指针</h2><ol><li><h4 id="指向成员变量的指针"><a href="#指向成员变量的指针" class="headerlink" title="指向成员变量的指针"></a>指向成员变量的指针</h4><p>定义格式</p><blockquote><p><code>&lt;数据类型&gt;&lt;类名&gt;::*&lt;指针名&gt;</code></p><p>例如：<code>int A::*pPram;</code></p></blockquote><p>赋值/初始化</p><blockquote><p><code>&lt;数据类型&gt;&lt;类名&gt;::*&lt;指针名&gt;=&amp;&lt;类名&gt;::&lt;非静态数据成员&gt;</code></p><p>例如：<code>int A::*pParam=&amp;A::param</code></p></blockquote><p>解引用</p><blockquote><p><code>&lt;类对象名&gt;.*&lt;非静态数据成员指针&gt;</code></p><p><code>&lt;类对象指针&gt;-&gt;*&lt;非静态数据成员指针&gt;</code></p><p>例如：</p><p><code>A a;</code></p><p><code>a.*pParam;</code></p><p><code>a-&gt;*pParam</code></p></blockquote></li></ol>   <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">A(<span class="keyword">int</span> param)</span><br><span class="line">&#123;</span><br><span class="line">mParam = param;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> mParam;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test05</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">A <span class="title">a1</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">A* a2 = <span class="keyword">new</span> A(<span class="number">200</span>);</span><br><span class="line"><span class="keyword">int</span>* p1 = &amp;a1.mParam;</span><br><span class="line"><span class="keyword">int</span> A::* p2 = &amp;A::mParam;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"*p1:"</span> &lt;&lt; *p1 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"a1.p2:"</span> &lt;&lt; a1.*p2 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"a2-&gt;*p2:"</span> &lt;&lt; a2-&gt;*p2 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>   执行结果：</p><p>   <img src="/2019/07/31/多态/%E6%8C%87%E5%90%91%E6%95%B0%E6%8D%AE%E6%88%90%E5%91%98%E7%9A%84%E6%8C%87%E9%92%88.PNG" alt="指向成员变量的指针"></p><ol start="2"><li><h4 id="指向成员函数的指针"><a href="#指向成员函数的指针" class="headerlink" title="指向成员函数的指针"></a>指向成员函数的指针</h4><p>定义格式化</p><blockquote><p><code>&lt;返回类型&gt;(&lt;类名&gt;::*&lt;指针名&gt;)(&lt;参数列表&gt;)</code></p><p>例如：</p><p><code>void(A::*pFunc)(int,int);</code></p></blockquote><p>赋值/初始化</p><blockquote><p><code>&lt;返回类型&gt;(&lt;类名&gt;::*&lt;指针名&gt;)(&lt;参数列表&gt;)=&amp;&lt;类名&gt;::&lt;非静态数据函数&gt;</code></p><p>例如：</p><p><code>void(A::pFunc(int,int)=&amp;A::func;</code></p></blockquote><p>解引用</p><blockquote><p><code>(&lt;类对象名&gt;.*&lt;非静态成员函数&gt;)(&lt;参数列表&gt;)</code></p><p><code>(&lt;类对象指针&gt;-&gt;*&lt;非静态成员函数&gt;)(&lt;参数列表&gt;)</code></p><p>例如：</p><p><code>A a;</code></p><p><code>(a.*pFunc)(10,20);</code></p><p><code>(a-&gt;*pFunc)(10,20);</code></p></blockquote></li></ol>   <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">A()</span><br><span class="line">&#123;</span><br><span class="line">mParam = <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line">A(<span class="keyword">int</span> param)</span><br><span class="line">&#123;</span><br><span class="line">mParam = param;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> mParam;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test06</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">A a1;</span><br><span class="line">A* a2 = <span class="keyword">new</span> A;</span><br><span class="line"><span class="comment">//初始化成员函数指针</span></span><br><span class="line"><span class="keyword">int</span>(A:: * pFunc)(<span class="keyword">int</span>, <span class="keyword">int</span>) = &amp;A::func;</span><br><span class="line"><span class="comment">//指针解引用</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"(a1.*pFunc(10,20)="</span> &lt;&lt; (a1.*pFunc)(<span class="number">10</span>, <span class="number">20</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"(a2-&gt;*pFunc(10,20)="</span> &lt;&lt; (a2-&gt;*pFunc)(<span class="number">10</span>, <span class="number">20</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>   执行结果：</p><p>   <img src="/2019/07/31/多态/%E6%8C%87%E5%90%91%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E7%9A%84%E6%8C%87%E9%92%88.PNG" alt="指向成员函数的指针"></p><ol start="3"><li><h4 id="指向静态成员的指针"><a href="#指向静态成员的指针" class="headerlink" title="指向静态成员的指针"></a>指向静态成员的指针</h4><ul><li><p>指向静态数据成员的指针</p><p>指向静态数据成员的指针的定义和使用与普通指针相同，在定义时无须和类向关联，在使用时也无须和具体的对象相关联。</p></li><li><p>指向类静态成员函数的指针</p><p>指向静态成员函数的指针和普通指针相同，在定义时无须和类相关联，在使用时也无须和具体的对象相关联。</p></li></ul></li></ol><pre><code><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">A()</span><br><span class="line">&#123;</span><br><span class="line">mParam = <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line">A(<span class="keyword">int</span> param)</span><br><span class="line">&#123;</span><br><span class="line">mParam = param;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">dis</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; data &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> data;</span><br><span class="line"><span class="keyword">int</span> mParam;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> A::data = <span class="number">555</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test07</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span>* p = &amp;A::data;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; *p &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">void</span>(*pfunc)() = &amp;A::dis;</span><br><span class="line">pfunc();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre><p>   执行结果：</p><p>   <img src="/2019/07/31/多态/%E6%8C%87%E5%90%91%E9%9D%99%E6%80%81%E6%88%90%E5%91%98%E7%9A%84%E6%8C%87%E9%92%88.PNG" alt="指向静态成员的指针"></p><h2 id="九、源码地址"><a href="#九、源码地址" class="headerlink" title="九、源码地址"></a>九、源码地址</h2><p>​            <a href="https://github.com/Aoki-Wang/CheckStation/tree/master/C%2B%2B/Polymorphism" target="_blank" rel="noopener">多态源码示例</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、多态&quot;&gt;&lt;a href=&quot;#一、多态&quot; class=&quot;headerlink&quot; title=&quot;一、多态&quot;&gt;&lt;/a&gt;一、多态&lt;/h2&gt;&lt;p&gt;&amp;emsp;多态是面向对象程序设计语言中数据抽象和继承之外的第三个基本特征。&lt;/p&gt;
&lt;p&gt;&amp;emsp;多态性(Polymo
      
    
    </summary>
    
      <category term="C++" scheme="http://wanqbin.xyz/categories/C/"/>
    
    
      <category term="C++" scheme="http://wanqbin.xyz/tags/C/"/>
    
      <category term="多态" scheme="http://wanqbin.xyz/tags/%E5%A4%9A%E6%80%81/"/>
    
      <category term="虚函数" scheme="http://wanqbin.xyz/tags/%E8%99%9A%E5%87%BD%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>树的实现</title>
    <link href="http://wanqbin.xyz/2019/07/30/%E6%A0%91%E7%9A%84%E5%AE%9E%E7%8E%B0/"/>
    <id>http://wanqbin.xyz/2019/07/30/树的实现/</id>
    <published>2019-07-30T11:32:00.000Z</published>
    <updated>2019-07-30T11:38:14.753Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、树结点类"><a href="#一、树结点类" class="headerlink" title="一、树结点类"></a>一、树结点类</h2><p>&emsp;这里我们使用使用孩子兄弟结点表示法表示树的每个结点，每个结点包括三个域：数据域、第一个孩子结点指针域和下一个兄弟结点指针域。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;<span class="title">class</span> <span class="title">Tree</span>;</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;<span class="title">class</span> <span class="title">TreeNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">Tree</span>&lt;T&gt;;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">T data;<span class="comment">//数据域</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//构造函数</span></span><br><span class="line">TreeNode(T value, TreeNode&lt;T&gt;* fc = <span class="literal">nullptr</span>, TreeNode&lt;T&gt;* ns = <span class="literal">nullptr</span>)</span><br><span class="line">:data(value), firstChild(fc), nextSibling(ns) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//访问指针域的成员函数</span></span><br><span class="line">TreeNode&lt;T&gt;*&amp; FirstChild()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> firstChild;</span><br><span class="line">&#125;</span><br><span class="line">TreeNode&lt;T&gt;*&amp; NextSibling()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> nextSibling;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">TreeNode&lt;T&gt;* firstChild;<span class="comment">//第一个孩子结点指针域</span></span><br><span class="line">TreeNode&lt;T&gt;* nextSibling;<span class="comment">//下一个兄弟结点指针域</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="二、树类"><a href="#二、树类" class="headerlink" title="二、树类"></a>二、树类</h2><p>&emsp;树类的数据成员有根结点和当前结点指针。树类设计为树结点类的友元，树类成员函数可直接操作树结点内的私有数据成员，所以这里树类的成员函数是直接对树结点类的私有数据成员<code>firstChild</code>和<code>nextSibling</code>进行操作的。对于外部应用，可通过成员函数<code>FirstChild()</code>和<code>NextSilibing()</code>取得树结点类的私有数据成员<code>firstChild</code>和<code>nextSibling</code>的值和修改它们的值。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">"treeNode.h"</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; <span class="title">class</span> <span class="title">Tree</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Tree() &#123; root = current = <span class="literal">nullptr</span>; &#125;<span class="comment">//构造函数</span></span><br><span class="line">~Tree() &#123; DeleteSubTree(root); &#125;<span class="comment">//析构函数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//第一类操作的成员函数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Root</span><span class="params">()</span></span>;<span class="comment">//使根结点为当前结点</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Parent</span><span class="params">()</span></span>;<span class="comment">//使当前结点的双亲结点为当前结点</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">FirstChild</span><span class="params">()</span></span>;<span class="comment">//使当前结点的第一个孩子结点为当前结点</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">NextSilibing</span><span class="params">()</span></span>;<span class="comment">//使当前结点的兄弟结点为当前结点</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//第二类操作的成员函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Insert</span><span class="params">(T value)</span></span>;<span class="comment">//把value插入到当前结点的最后一个结点</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DeleteSubTree</span><span class="params">(TreeNode&lt;T&gt;*&amp; t)</span></span>;<span class="comment">//删除以t为根结点的子树</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DeleteChile</span><span class="params">(<span class="keyword">int</span> i)</span></span>;<span class="comment">//删除当前结点的第i个孩子结点</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//第三类操作的成员函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DisplayTree</span><span class="params">()</span></span>;<span class="comment">//按先根遍历次序显示树的数据域值</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">TreeNode&lt;T&gt;* root;<span class="comment">//根结点指针</span></span><br><span class="line">TreeNode&lt;T&gt;* current;<span class="comment">//当前结点指针</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//私有成员函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PreOrderTree</span><span class="params">(TreeNode&lt;T&gt;*&amp; t)</span></span>;<span class="comment">//显示以t为根节点的树的数据域，先根遍历</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PosOrderTree</span><span class="params">(TreeNode&lt;T&gt;*&amp; t)</span></span>;<span class="comment">//后根遍历</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Current</span><span class="params">(TreeNode&lt;T&gt;*&amp; t)</span></span>;<span class="comment">//使当前节点为t所指结点</span></span><br><span class="line"><span class="comment">//在树root中回溯查找结点s的双亲结点</span></span><br><span class="line">TreeNode&lt;T&gt;* SearchParent(TreeNode&lt;T&gt;*&amp; root, TreeNode&lt;T&gt;*&amp; s);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="三、树类成员函数的实现"><a href="#三、树类成员函数的实现" class="headerlink" title="三、树类成员函数的实现"></a>三、树类成员函数的实现</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">int</span> <span class="title">Tree</span>&lt;T&gt;:</span>:Root()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (root == <span class="literal">nullptr</span>)</span><br><span class="line">&#123;</span><br><span class="line">current = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> Current(root);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">int</span> <span class="title">Tree</span>&lt;T&gt;:</span>:Parent()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (root == <span class="literal">nullptr</span>)</span><br><span class="line">&#123;</span><br><span class="line">current = root;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">TreeNode&lt;T&gt;* p = SearchParent(root, current);</span><br><span class="line"><span class="keyword">if</span> (p == <span class="literal">nullptr</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> Current(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">int</span> <span class="title">Tree</span>&lt;T&gt;:</span>:FirstChild()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (current != <span class="literal">nullptr</span> &amp;&amp; current-&gt;firstChild != <span class="literal">nullptr</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> Current(current-&gt;firstChild);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">int</span> <span class="title">Tree</span>&lt;T&gt;:</span>:NextSilibing()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (current != <span class="literal">nullptr</span> &amp;&amp; current-&gt;nextSibling != <span class="literal">nullptr</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> Current(current-&gt;nextSibling);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> <span class="title">Tree</span>&lt;T&gt;:</span>:Insert(T value)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//把value插入到当前结点的最后一个结点</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">分为三种情况</span></span><br><span class="line"><span class="comment">1. 空树</span></span><br><span class="line"><span class="comment">2. 当前结点无孩子结点</span></span><br><span class="line"><span class="comment">3. 当前结点已有孩子结点</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">TreeNode&lt;T&gt;* newNode = <span class="keyword">new</span> TreeNode&lt;T&gt;(value);</span><br><span class="line"><span class="keyword">if</span> (root == <span class="literal">nullptr</span>)</span><br><span class="line">&#123;</span><br><span class="line">root = current = newNode;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (current-&gt;firstChild == <span class="literal">nullptr</span>)<span class="comment">//当前结点无孩子结点</span></span><br><span class="line">&#123;</span><br><span class="line">current-&gt;firstChild = newNode;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">TreeNode&lt;T&gt;* p = current-&gt;firstChild;</span><br><span class="line"><span class="keyword">while</span> (p-&gt;nextSibling != <span class="literal">nullptr</span>)</span><br><span class="line">&#123;</span><br><span class="line">p = p-&gt;nextSibling;</span><br><span class="line">&#125;</span><br><span class="line">p-&gt;nextSibling = newNode;</span><br><span class="line">&#125;</span><br><span class="line">Current(newNode);<span class="comment">//使当前结点为新节点</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> <span class="title">Tree</span>&lt;T&gt;:</span>:DeleteSubTree(TreeNode&lt;T&gt;*&amp; t)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (t == <span class="literal">nullptr</span>)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">TreeNode&lt;T&gt;* q = t-&gt;firstChild, * p;</span><br><span class="line"><span class="keyword">while</span> (q != <span class="literal">nullptr</span>)</span><br><span class="line">&#123;</span><br><span class="line">p = q-&gt;nextSibling;</span><br><span class="line">DeleteSubTree(q);</span><br><span class="line">q = p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">delete</span> t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> <span class="title">Tree</span>&lt;T&gt;:</span>:DeleteChile(<span class="keyword">int</span> i)</span><br><span class="line">&#123;</span><br><span class="line">TreeNode&lt;T&gt;* r = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="keyword">if</span> (i == <span class="number">1</span>)<span class="comment">//当删除当前结点的第一棵子树</span></span><br><span class="line">&#123;</span><br><span class="line">r = current-&gt;firstChild;</span><br><span class="line"><span class="keyword">if</span> (r == <span class="literal">nullptr</span>)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">current-&gt;firstChild = r-&gt;nextSibling;<span class="comment">//脱链要删除的子树</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> k = <span class="number">1</span>;</span><br><span class="line">TreeNode&lt;T&gt;* p = current-&gt;firstChild;</span><br><span class="line"><span class="keyword">while</span> (p != <span class="literal">nullptr</span> &amp;&amp; k &lt;= i - <span class="number">1</span>)</span><br><span class="line">&#123;<span class="comment">//寻找指向要删除子树的指针</span></span><br><span class="line">p = p-&gt;nextSibling;</span><br><span class="line">k++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (p != <span class="literal">nullptr</span>)</span><br><span class="line">&#123;</span><br><span class="line">r = p-&gt;nextSibling;</span><br><span class="line"><span class="keyword">if</span> (r != <span class="literal">nullptr</span>)</span><br><span class="line">&#123;</span><br><span class="line">p-&gt;nextSibling = r-&gt;nextSibling;<span class="comment">//脱链要删除的子树</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span>;<span class="comment">//要删除的子树为空时返回</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span>;<span class="comment">//查找失败</span></span><br><span class="line">&#125;</span><br><span class="line">DeleteSubTree(r);<span class="comment">//删除找到的要删除的子树</span></span><br><span class="line"><span class="keyword">return</span>;<span class="comment">//删除成功</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> <span class="title">Tree</span>&lt;T&gt;:</span>:DisplayTree()</span><br><span class="line">&#123;</span><br><span class="line">PreOrderTree(root);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> <span class="title">Tree</span>&lt;T&gt;:</span>:PreOrderTree(TreeNode&lt;T&gt;*&amp; t)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (t == <span class="literal">nullptr</span>)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; t-&gt;data &lt;&lt; <span class="string">" "</span>;<span class="comment">//显示根节点数据</span></span><br><span class="line"><span class="keyword">if</span> (t-&gt;firstChild != <span class="literal">nullptr</span>)</span><br><span class="line">PreOrderTree(t-&gt;firstChild);</span><br><span class="line"><span class="keyword">if</span> (t-&gt;nextSibling != <span class="literal">NULL</span>)</span><br><span class="line">PreOrderTree(t-&gt;nextSibling);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> <span class="title">Tree</span>&lt;T&gt;:</span>:PosOrderTree(TreeNode&lt;T&gt;*&amp; t)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (t == <span class="literal">nullptr</span>)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">if</span> (t-&gt;firstChild != <span class="literal">nullptr</span>)</span><br><span class="line">PosOrderTree(t-&gt;firstChild);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; t-&gt;data &lt;&lt; <span class="string">" "</span>;<span class="comment">//显示根节点</span></span><br><span class="line"><span class="keyword">if</span> (t-&gt;nextSibling != <span class="literal">nullptr</span>)</span><br><span class="line">PosOrderTree(t-&gt;nextSibling);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">int</span> <span class="title">Tree</span>&lt;T&gt;:</span>:Current(TreeNode&lt;T&gt;*&amp; t)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (t == <span class="literal">nullptr</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">current = t;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">TreeNode</span>&lt;T&gt;* <span class="title">Tree</span>&lt;T&gt;:</span>:SearchParent(TreeNode&lt;T&gt;*&amp; root, TreeNode&lt;T&gt;*&amp; s)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//在树root中回溯查找结点s的双亲结点</span></span><br><span class="line"><span class="comment">//查找到时使current指向s结点的双亲结点</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (current == <span class="literal">nullptr</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line"><span class="keyword">if</span> (root-&gt;firstChild == s || root-&gt;nextSibling == s)</span><br><span class="line"><span class="keyword">return</span> root;</span><br><span class="line">TreeNode&lt;T&gt;* p;</span><br><span class="line"><span class="keyword">if</span> ((p = SearchParent(root-&gt;firstChild, s)) != <span class="literal">nullptr</span>)</span><br><span class="line"><span class="keyword">return</span> p;</span><br><span class="line"><span class="keyword">if</span> ((p = SearchParent(root-&gt;nextSibling, s)) != <span class="literal">nullptr</span>)</span><br><span class="line"><span class="keyword">return</span> p;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>四、源码地址</p><p>​            <a href="https://github.com/Aoki-Wang/CheckStation/tree/master/Data%20Structure/tree" target="_blank" rel="noopener">树的实现源码</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、树结点类&quot;&gt;&lt;a href=&quot;#一、树结点类&quot; class=&quot;headerlink&quot; title=&quot;一、树结点类&quot;&gt;&lt;/a&gt;一、树结点类&lt;/h2&gt;&lt;p&gt;&amp;emsp;这里我们使用使用孩子兄弟结点表示法表示树的每个结点，每个结点包括三个域：数据域、第一个孩子结点指
      
    
    </summary>
    
      <category term="数据结构" scheme="http://wanqbin.xyz/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="数据结构" scheme="http://wanqbin.xyz/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="树的实现" scheme="http://wanqbin.xyz/tags/%E6%A0%91%E7%9A%84%E5%AE%9E%E7%8E%B0/"/>
    
      <category term="树" scheme="http://wanqbin.xyz/tags/%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>二叉树</title>
    <link href="http://wanqbin.xyz/2019/07/30/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <id>http://wanqbin.xyz/2019/07/30/二叉树/</id>
    <published>2019-07-30T11:09:00.000Z</published>
    <updated>2019-07-30T11:10:21.062Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、二叉树的定义"><a href="#一、二叉树的定义" class="headerlink" title="一、二叉树的定义"></a>一、二叉树的定义</h2><p>&emsp;二叉树（Binary Tree）是n（n&gt;=0)个有限结点构成的集合。n=0的树称为空二叉树；n&gt;0的二叉树由一个根节点和两个互不相交、分别称作左子树和右子树的子二叉树构成。</p><p>&emsp;二叉树是一种有序树。二叉树中某个结点即使只有一个子树，也要区分是左子树还是右子树。</p><p>&emsp;二叉树中所有结点的形态共有5种：空结点、无左右子树结点、只有左子树结点、只有右子树结点和左右子树均存在的结点。</p><p>&emsp;满二叉树。在一棵二叉树中，如果所有分支结点都存在左子树和右子树，并且所有叶子结点在同一层上，这样的二叉树称为<code>满二叉树</code>。</p><p>&emsp;完全二叉树。如果一棵具有n个结点的二叉树的结构与满二叉树的前n个结点的结构相同，这样的二叉树称为完全二叉树。</p><h2 id="二、二叉树的性质"><a href="#二、二叉树的性质" class="headerlink" title="二、二叉树的性质"></a>二、二叉树的性质</h2><ul><li>性质1：若规定根结点的层次为0，则一棵非空二叉树的第i层上最多有$2^i$(i&gt;=0)个结点。</li><li>性质2：若规定空树的深度为-1，则深度为k的二叉树的最大结点数是$2^{k+1}-1$(k&gt;=-1)个。</li><li>性质3：对于一棵非空的二叉树，如果叶节点的个数为$n_0$，度为2的结点数为$n_2$,则有$n_0=n_2+1$.</li><li>性质4：对于具有n个结点的完全二叉树，如果按照从上至下和从左至右的顺序对所有结点从0开始顺序编号，则对于任意的序号为i的结点，有：<ol><li>如果i&gt;0,则序号为i结点的双亲结点的序号为（i-1)/2，如果i=0，则序号为i的结点为根结点，无双亲结点。</li><li>如果2i+1&lt;n，则序号为i结点的左孩子结点的序号为2i+1；如果2i+1&gt;=n,则序号为i结点无左孩子。</li><li>如果2i+2&lt;n,则序号为i结点的右孩子结点的序号为2i+2;如果2i+2&gt;=n,则序号为i的结点无右孩子。</li></ol></li></ul><h2 id="三、二叉树的操作"><a href="#三、二叉树的操作" class="headerlink" title="三、二叉树的操作"></a>三、二叉树的操作</h2><p>&emsp;二叉树是由一个根结点和两个互不相交的、分别称为左子树和右子树的子二叉树构成。因此，二叉树的操作和树的操作多数及基本类同，只在子树操作上略有不同。</p><p>&emsp;二叉树的操作也分为三类：第一类，找满足某种特定关系的结点；第二类，插入或删除某个结点；第三类，遍历树中每个结点。</p><ol><li>第一类操作<ul><li>寻找根结点使之成为当前结点</li><li>寻找当前结点的双亲结点使之成为当前结点</li><li>寻找当前结点的左孩子结点使之成为当前结点</li><li>寻找当前结点的右孩子结点使之成为当前结点</li></ul></li><li>第二类操作<ul><li>在二叉树的当前结点上插入一个新结点，使新插入的节点称为当前结点的左孩子结点</li><li>在二叉树的当前结点上插入一个新结点，使新插入结点成为当前结点的右孩子结点</li><li>在二叉树的当前结点插入一个新子树，使新插入子树称为当前结点的左子树</li><li>在二叉树的当前结点插入一个新子树，使新插入子树称为当前结点的右子树</li><li>删除二叉树的当前结点的左孩子结点</li><li>删除二叉树的当前结点的右孩子结点</li><li>删除二叉树的当前结点的左子树</li><li>删除二叉树的当前结点的右子树</li></ul></li><li>第三类操作<ul><li>按某种方式遍历一棵二叉树显示二叉树中每个结点的数据域值</li><li>按某种方式遍历一棵二叉树寻找数据元素域为某一值的结点</li><li>先序遍历（DLR）递归算法<ul><li>访问根结点</li><li>前序遍历根结点的左子树</li><li>前序遍历根结点的右子树</li></ul></li><li>中序遍历（LDR）递归算法<ul><li>中序遍历根结点的左子树</li><li>访问根结点</li><li>中序遍历根结点的右子树</li></ul></li><li>后序遍历（LRD）递归算法<ul><li>后序遍历根结点的左子树</li><li>后序遍历根结点的右子树</li><li>访问根结点</li></ul></li><li>二叉树还有层序遍历。二叉树的层序遍历要求按照从根结点至叶结点、从左子树至右子树的次序访问二叉树的结点。二叉树的层序遍历算法为：<ul><li>初始化设置一个队列，并把根结点加入队列</li><li>当队列非空时，循环下面注明的步骤③到步骤⑤；否则到步骤⑥</li><li>出队列取得一个结点，访问该结点的（步骤③）</li><li>若该结点的左子树非空，则将该结点的左子树入队列</li><li>若该结点的右子树非空，则将该结点的右子树入队列（步骤⑤）</li><li>结束。</li></ul></li></ul></li></ol><h2 id="四、二叉树的存储结构"><a href="#四、二叉树的存储结构" class="headerlink" title="四、二叉树的存储结构"></a>四、二叉树的存储结构</h2><p>&emsp;二叉树的存储结构主要有三种：顺序存储结构、链式存储结构和仿真指针存储结构。</p><ol><li><p>二叉树的顺序存储结构</p><p>&emsp;对于一般的二叉树，如果按从上至下和从左至右的次序存储在一组从0开始的连续内存单元中，则数据下标之间的关系就不能反映二叉树中结点之间的逻辑关系。此时，可在一般二叉树中增添一些并不存在的空结点使之变成完全二叉树的形态，然后再用二叉树的顺序存储结构存储。</p><p>&emsp;完全二叉树使用顺序存储结构存储时，既能节省存储空间，又能使二叉树的操作实现简单。但对于一般二叉树，如果它接近于完全二叉树，需要增加的空结点数目不多时，可采用顺序存储结构存储。但如果需要增加许多空结点时，就不宜采用顺序存储结构存储。最坏的情况是右单只树，一棵深度为k的右单只树只有k个结点，却需分配$2^k$-1个存储单元。</p></li><li><p>二叉树的链式存储结构</p><p>&emsp;二叉树的链式存储结构方式用指针建立二叉树中结点之间的关系。二叉树最常用的链式存储结构是二叉链。二叉链存储结构的每个结点包含三个域：数据域data，左子树指针域<code>leftChild</code>和右子树指针域<code>rightChild</code>。</p><p>&emsp;二叉树的二叉链存储结构是一种常用的二叉树存储结构。二叉链存储结构的优点是：结构简单，可以方便地构造任意需要的二叉树，可以方便地实现二叉树操作中的大多数操作。二叉链仓促结构的缺点是查找当前结点的双亲结点操作实现起来比较麻烦。</p><p>&emsp;二叉树的另一种常用的存储结构是三叉链。三叉链式在二叉链的基础上再增加一个双亲结点指针域parent。三叉链除基于二叉链的优点外，对于查找当前结点的双亲结点操作实现起来也很容易。相对于二叉链，三叉链的缺点是结构更为复杂，因而每个结点占用的内存单元也更多一些。</p></li><li><p>二叉树的仿真指针存储结构</p><p>&emsp;二叉树的仿真指针存储结构是用数组存储二叉树中的结点，再增加仿真指针域仿真常规指针建立二叉树中结点之间的关系。二叉树的仿真指针存储结构有仿真二叉链存储结构和仿真三叉链存储结构。</p><p>&emsp;仿真指针存储结构的最大优点是遍历操作实现非常容易。用for循环或while循环就可实现。仿真指针存储结构的最大缺点是可存储的结点个数受初始化定义的数组元素个数限制。</p></li></ol><h2 id="五、树和二叉树的转换"><a href="#五、树和二叉树的转换" class="headerlink" title="五、树和二叉树的转换"></a>五、树和二叉树的转换</h2><ol><li>树转换为二叉树<ul><li>树中所有相同双亲结点的兄弟结点之间加一条连线</li><li>对树中不是双亲结点第一个孩子的结点，只保留它与左兄弟结点之间的连线，删去该结点与双亲结点之间的连线</li><li>整理所有保留的和添加的连线，使每个结点的孩子结点连线位于左孩子指针位置，使每个结点的右兄弟结点连线位于右孩子指针位置</li></ul></li><li>二叉树还原为树<ul><li>若某结点是其双亲结点的左孩子，则把该结点的右孩子、右孩子的右孩子……都与该结点的双亲结点用线连起来</li><li>删除原二叉树中所有双亲结点与右孩子结点的连线</li><li>整理所有保留的和添加的连线，使每个结点的孩子结点连线顺序位于下方孩子结点位置</li></ul></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、二叉树的定义&quot;&gt;&lt;a href=&quot;#一、二叉树的定义&quot; class=&quot;headerlink&quot; title=&quot;一、二叉树的定义&quot;&gt;&lt;/a&gt;一、二叉树的定义&lt;/h2&gt;&lt;p&gt;&amp;emsp;二叉树（Binary Tree）是n（n&amp;gt;=0)个有限结点构成的集合。n=
      
    
    </summary>
    
      <category term="数据结构" scheme="http://wanqbin.xyz/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="二叉树" scheme="http://wanqbin.xyz/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
      <category term="数据结构" scheme="http://wanqbin.xyz/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
</feed>

<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Aoki&#39;s Blog</title>
  
  <subtitle>“吾生也有涯，而知无涯”</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://wanqbin.xyz/"/>
  <updated>2019-08-02T12:03:08.181Z</updated>
  <id>http://wanqbin.xyz/</id>
  
  <author>
    <name>Aoki</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>堆——最小堆和最大堆的实现</title>
    <link href="http://wanqbin.xyz/2019/08/02/%E5%A0%86%E2%80%94%E2%80%94%E6%9C%80%E5%B0%8F%E5%A0%86%E5%92%8C%E6%9C%80%E5%A4%A7%E5%A0%86%E7%9A%84%E5%AE%9E%E7%8E%B0/"/>
    <id>http://wanqbin.xyz/2019/08/02/堆——最小堆和最大堆的实现/</id>
    <published>2019-08-02T09:18:00.000Z</published>
    <updated>2019-08-02T12:03:08.181Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、堆概述"><a href="#一、堆概述" class="headerlink" title="一、堆概述"></a>一、堆概述</h2><ul><li>堆(Heap)是结点间数据元素的关键码具有层次次序关系的完全二叉树；</li><li>堆是二叉树的顺序存储结构的一个应用；</li><li>堆可用于应用程序希望能直接访问一个表中的最小或最大数据元素的应用问题；</li><li>堆结构的重要价值在于，在所有能直接访问一个表中的最小或最大数据元素的算法中，堆结构方法是时间效率最高的一种。</li></ul><h2 id="二、堆定义"><a href="#二、堆定义" class="headerlink" title="二、堆定义"></a>二、堆定义</h2><p>&emsp;&emsp;设数据元素是一个有多个域的复合结构，其中有一个称为关键码的域，定义n个数据元素$d_0$、$d_1$、$d_2$、……、$d_{n-1}$所对应的关键码域为$k_0$、$k_1$、$k_2$、……、$k_{n-1}$，假设数据元素$d_0$、$d_1$、$d_2$、……、$d_{n-1}$按完全二叉树的顺序存放在一个一维数组中，当2i+1&lt;n时有：</p><p>$k_i&lt;=k_{2i+1}$($k_i$中的i是元素在数组中的下标)</p><p>当2i+2&lt;n时有：</p><p>$k_i&lt;=k_{2i+2}$($k_i$中的i是元素在数组中的下标)</p><p>这样的数据元素集合称为<code>最小堆</code>。</p><p>与此类似，当2i+1&lt;n时有：</p><p>$k_i&gt;=k_{2i+1}$($k_i$中的i是元素在数组中的下标)</p><p>当2i+2&lt;n时有：</p><p>$k_i&gt;=k_{2i+2}$($k_i$中的i是元素在数组中的下标)</p><p>这样的数据元素集合称为<code>最大堆</code>。</p><p>根据堆的定义可以推知堆有下面两个性质：</p><ul><li>最小堆的根结点时堆中值最小的数据元素，最大堆的根结点时堆中值最大的数据元素，我们称之为堆顶元素</li><li>对于最小堆，从根结点到每个叶结点的路径上，数据元素组成的的序列都是非递减有序的。对于最大堆，从根结点到每个叶结点的路径上，数据元素组成的序列都是非递增有序的</li></ul><h2 id="三、最小堆的实现"><a href="#三、最小堆的实现" class="headerlink" title="三、最小堆的实现"></a>三、最小堆的实现</h2><h4 id="1）最小堆类"><a href="#1）最小堆类" class="headerlink" title="1）最小堆类"></a>1）最小堆类</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">MinHeap</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">MinHeap(<span class="keyword">int</span> maxsize);<span class="comment">//构造函数</span></span><br><span class="line">MinHeap(T arr[], <span class="keyword">int</span> n);<span class="comment">//拷贝构造函数，将n个arr元素堆化</span></span><br><span class="line">~MinHeap();<span class="comment">//析构函数</span></span><br><span class="line"><span class="comment">//最小堆的相关操作</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Insert</span><span class="params">(<span class="keyword">const</span> T&amp; item)</span></span>;<span class="comment">//插入元素item</span></span><br><span class="line"><span class="function">T <span class="title">Delete</span><span class="params">()</span></span>;<span class="comment">//删除堆中最小元素</span></span><br><span class="line"><span class="function">T <span class="title">GetHeapTop</span><span class="params">()</span></span>;<span class="comment">//获取堆顶元素</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">HeapSize</span><span class="params">()</span></span>;<span class="comment">//获取堆中元素个数</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isHeapEmpty</span><span class="params">()</span></span>;<span class="comment">//堆是否为空</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isHeapFull</span><span class="params">()</span></span>;<span class="comment">//堆是否已满</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Display</span><span class="params">()</span></span>;<span class="comment">//打印堆</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">T* heapArray;<span class="comment">//存放数据元素的数组</span></span><br><span class="line"><span class="keyword">int</span> markArray;<span class="comment">//标记</span></span><br><span class="line"><span class="keyword">int</span> MaxHeapSize;<span class="comment">//可存元素个数</span></span><br><span class="line"><span class="keyword">int</span> heapSize;<span class="comment">//当前元素个数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FilterUp</span><span class="params">(<span class="keyword">int</span> i)</span></span>;<span class="comment">//插入元素后进行堆化</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FilterDown</span><span class="params">(<span class="keyword">int</span> i)</span></span>;<span class="comment">//删除元素后进行堆化</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="2-最小堆类部分成员函数的实现"><a href="#2-最小堆类部分成员函数的实现" class="headerlink" title="2)最小堆类部分成员函数的实现"></a>2)最小堆类部分成员函数的实现</h4><p>&emsp;&emsp;插入成员函数是在原先的数据元素已经是堆的基础上，插入一个数据元素后，调整使之继续维持为一个堆。我们把要插入的数据元素放在堆尾。虽然插入前的数据元素集合构成堆，但是新的数据元素插入后可能违背堆的定义。</p><p>&emsp;&emsp;插入新元素后继续维持为一个最小堆的算法是</p><ul><li>看新插入元素的值是否小于其双亲的值，如果不小于，则仍维持为一个最小堆，算法结束；</li><li>如果小于，则交换两者的值；</li><li>交换后有可能在更上一层仍然不能满足最小堆的定义，需继续交换，直到满足最小堆的定义为止。</li></ul><p>最小堆插入图示：</p><p><img src="/2019/08/02/堆——最小堆和最大堆的实现/原始堆.PNG" alt="原始堆"></p><p><img src="/2019/08/02/堆——最小堆和最大堆的实现/堆1.PNG" alt="插入步骤1"></p><p><img src="/2019/08/02/堆——最小堆和最大堆的实现/堆2.PNG" alt="插入步骤2"></p><p><img src="/2019/08/02/堆——最小堆和最大堆的实现/堆3.PNG" alt="插入步骤3"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//插入元素时重新堆化</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">MinHeap</span>&lt;T&gt;:</span>:FilterUp(<span class="keyword">int</span> i)</span><br><span class="line">&#123;<span class="comment">//调整插入的新元素使之上升到合适的结点位置</span></span><br><span class="line"><span class="keyword">int</span> currentPos, parentPos;</span><br><span class="line">T target;</span><br><span class="line">currentPos = i;</span><br><span class="line">target = heapArray[i];</span><br><span class="line">parentPos = heapArray[(i - <span class="number">1</span>) / <span class="number">2</span>];<span class="comment">//获取结点i的双亲结点位置</span></span><br><span class="line"><span class="keyword">while</span> (currentPos != <span class="number">0</span>)</span><br><span class="line">&#123;<span class="comment">//到根结点为止</span></span><br><span class="line"><span class="keyword">if</span> (heapArray[parentPos] &lt;= target)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">heapArray[currentPos] = heapArray[parentPos];<span class="comment">//双亲结点下降</span></span><br><span class="line">currentPos = parentPos;<span class="comment">//当前结点为双亲结点，重新开始</span></span><br><span class="line">parentPos = (currentPos - <span class="number">1</span>) / <span class="number">2</span>;<span class="comment">//计算当前结点的双亲结点</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">heapArray[currentPos] = target;<span class="comment">//插入新元素</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//插入</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">MinHeap</span>&lt;T&gt;:</span>:Insert(<span class="keyword">const</span> T&amp; item)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (heapSize == MaxHeapSize)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"堆已满！"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">heapArray[heapSize] = item;</span><br><span class="line">FilterUp(heapSize);<span class="comment">//新插入结点上移，进行堆化</span></span><br><span class="line">heapSize++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;删除成员函数是删除堆顶的最小的数据元素。删除堆顶元素后，我们用堆中最后一个元素填充堆顶位置，此时必然违反堆的定义。</p><p>&emsp;&emsp;删除后继续维持为一个最小堆的算法是：</p><ul><li>令堆顶位置为当前位置，看当前位置元素的值时候小于其左右孩子中的最小值，如果不小于，则仍然维持为一个最小堆，算法结束；</li><li>如果小于，则交换两者的值；</li><li>交换后有可能在更下一层仍然不满足最小堆的定义，需继续交换，直到满足堆的定义为止。</li></ul><p>最小堆删除图示：</p><p><img src="/2019/08/02/堆——最小堆和最大堆的实现/删除原始堆.PNG" alt="原始堆"></p><p><img src="/2019/08/02/堆——最小堆和最大堆的实现/删除1.PNG" alt="删除步骤1"></p><p><img src="/2019/08/02/堆——最小堆和最大堆的实现/删除2.PNG" alt="删除步骤2"></p><p><img src="/2019/08/02/堆——最小堆和最大堆的实现/删除3.PNG" alt="删除步骤3"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//删除元素时重新堆化</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">MinHeap</span>&lt;T&gt;:</span>:FilterDown(<span class="keyword">int</span> i)</span><br><span class="line">&#123;<span class="comment">//调整第i个结点使之下移到合适的位置</span></span><br><span class="line"><span class="keyword">int</span> currentPos, childPos;</span><br><span class="line">T target;</span><br><span class="line">currentPos = i;</span><br><span class="line">childPos = <span class="number">2</span> * i + <span class="number">1</span>;<span class="comment">//计算左孩子结点</span></span><br><span class="line">target = heapArray[i];</span><br><span class="line"><span class="keyword">while</span> (childPos &lt; heapSize)</span><br><span class="line">&#123;<span class="comment">//childPos为当前结点的左右孩子中值较小的孩子结点位置</span></span><br><span class="line"><span class="keyword">if</span> (childPos &lt; heapSize &amp;&amp; (heapArray[childPos + <span class="number">1</span>] &lt;= heapArray[childPos]))</span><br><span class="line">&#123;</span><br><span class="line">childPos = childPos + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (target &lt; heapArray[childPos])</span><br><span class="line"><span class="keyword">break</span>;<span class="comment">//满足最小堆的定义</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">heapArray[currentPos] = heapArray[childPos];<span class="comment">//孩子结点上升</span></span><br><span class="line">currentPos = childPos;<span class="comment">//从孩子结点位置重新开始</span></span><br><span class="line">childPos = childPos * <span class="number">2</span> + <span class="number">1</span>;<span class="comment">//当前结点的孩子结点</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">heapArray[currentPos] = target;<span class="comment">//把填充的堆顶元素插入</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除堆中最小元素</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">T</span> <span class="title">MinHeap</span>&lt;T&gt;:</span>:Delete()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (heapSize == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"堆为空！"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">T item = heapArray[<span class="number">0</span>];<span class="comment">//保存原堆顶元素</span></span><br><span class="line">heapArray[<span class="number">0</span>] = heapArray[heapSize - <span class="number">1</span>];<span class="comment">//用最后一个元素填充堆顶位置</span></span><br><span class="line">heapSize--;</span><br><span class="line"></span><br><span class="line">FilterDown(<span class="number">0</span>);<span class="comment">//下移当前堆顶元素</span></span><br><span class="line"><span class="keyword">return</span> item;<span class="comment">//返回原堆顶元素</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;数组的堆化是把一个有n个数据元素的非堆的数组构造为一个堆。</p><p>&emsp;&emsp;数组的堆化过程可以设计成递推过程。在完全二叉树形式的数组中，所有叶结点都满足堆的定义，令最后一个叶结点的双亲结点为当前结点，其下标为：<br><code>currentPos=((n-1)-1)/2</code></p><p>&emsp;&emsp;对于结点<code>currentPos</code>，其左右孩子结点已满足堆的定义，使结点<code>currentPos</code>也满足堆的定义的过程与插入过程中使用的<code>FilterDown</code>相同。因此使用参数<code>currentPos</code>调用<code>FilterDown(currentPos)</code>；在结点<code>currentPos</code>满足最小堆的定义后，使当前结点<code>currentPos=currentPos-1</code>，对于结点<code>currentPos</code>，其左右孩子结点已满足最小堆的定义，再次用参数<code>currentPos</code>调用<code>FilterDown(currentPos)</code>；这样的过程一直进行到当前结点<code>currentPos=0</code>，即到达根结点为止。</p><p>数组堆化图示：</p><p><img src="/2019/08/02/堆——最小堆和最大堆的实现/原始数组.PNG" alt="原始数组"></p><p><img src="/2019/08/02/堆——最小堆和最大堆的实现/堆化1.PNG" alt="堆化步骤1"></p><p><img src="/2019/08/02/堆——最小堆和最大堆的实现/堆化2.PNG" alt="堆化步骤2"></p><p><img src="/2019/08/02/堆——最小堆和最大堆的实现/堆化3.PNG" alt="堆化步骤3"></p><p><img src="/2019/08/02/堆——最小堆和最大堆的实现/堆化4.PNG" alt="堆化步骤4"></p><p><img src="/2019/08/02/堆——最小堆和最大堆的实现/堆化5.PNG" alt="堆化步骤5"></p><p><img src="/2019/08/02/堆——最小堆和最大堆的实现/堆化6.PNG" alt="堆化步骤6"></p><p><img src="/2019/08/02/堆——最小堆和最大堆的实现/堆化7.PNG" alt="堆化步骤7"></p><p><img src="/2019/08/02/堆——最小堆和最大堆的实现/堆化8.PNG" alt="堆化步骤8"></p><p><img src="/2019/08/02/堆——最小堆和最大堆的实现/堆化9.PNG" alt="堆化步骤9"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将数组堆化</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">MinHeap</span>&lt;T&gt;:</span>:MinHeap(T arr[], <span class="keyword">int</span> n)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (n &lt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"非法参数!"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">MaxHeapSize = n;</span><br><span class="line">heapSize = n;</span><br><span class="line">heapArray = arr;</span><br><span class="line"><span class="keyword">int</span> currentPos = (n - <span class="number">1</span>) / <span class="number">2</span>;<span class="comment">//计算第一个非叶子结点</span></span><br><span class="line"><span class="keyword">while</span> (currentPos &gt;= <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">FilterDown(currentPos);<span class="comment">//调整结点currentPos使之下移到合适的位置</span></span><br><span class="line">currentPos--;</span><br><span class="line">&#125;</span><br><span class="line">markArray = <span class="number">1</span>;<span class="comment">//置构造函数标记</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-测试函数"><a href="#3-测试函数" class="headerlink" title="3)测试函数"></a>3)测试函数</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> arr[] = &#123; <span class="number">24</span>,<span class="number">10</span>,<span class="number">90</span>,<span class="number">77</span>,<span class="number">16</span>,<span class="number">25</span>,<span class="number">33</span>,<span class="number">89</span>,<span class="number">67</span> &#125;;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"原数组元素为："</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (<span class="keyword">sizeof</span>(arr) / <span class="keyword">sizeof</span>(arr[<span class="number">0</span>])); i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; arr[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">MinHeap&lt;<span class="keyword">int</span>&gt; heap(arr, (<span class="keyword">sizeof</span>(arr) / <span class="keyword">sizeof</span>(arr[<span class="number">0</span>])));</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"输出堆中元素："</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">heap.Display();</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; heap.Delete() &lt;&lt; <span class="string">"已被删除！"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"输出堆中元素："</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">heap.Display();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4）执行结果"><a href="#4）执行结果" class="headerlink" title="4）执行结果"></a>4）执行结果</h4><p><img src="/2019/08/02/堆——最小堆和最大堆的实现/最小堆执行结果.PNG" alt="最小堆测试执行结果"></p><h4 id="5-源码地址"><a href="#5-源码地址" class="headerlink" title="5)源码地址"></a>5)源码地址</h4><p>​        <a href="https://github.com/Aoki-Wang/CheckStation/tree/master/Data%20Structure/Heap/Min%20Heap" target="_blank" rel="noopener">最小堆的实现源码</a></p><h2 id="四、最大堆的实现"><a href="#四、最大堆的实现" class="headerlink" title="四、最大堆的实现"></a>四、最大堆的实现</h2><h4 id="1-最大堆类"><a href="#1-最大堆类" class="headerlink" title="1)最大堆类"></a>1)最大堆类</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">MaxHeap</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">MaxHeap(<span class="keyword">int</span> maxsize);<span class="comment">//构造函数</span></span><br><span class="line">MaxHeap(T arr[], <span class="keyword">int</span> n);<span class="comment">//拷贝构造函数，将n个arr元素堆化</span></span><br><span class="line">~MaxHeap();<span class="comment">//析构函数</span></span><br><span class="line"><span class="comment">//最小堆的相关操作</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Insert</span><span class="params">(<span class="keyword">const</span> T&amp; item)</span></span>;<span class="comment">//插入元素item</span></span><br><span class="line"><span class="function">T <span class="title">Delete</span><span class="params">()</span></span>;<span class="comment">//删除堆中最大元素</span></span><br><span class="line"><span class="function">T <span class="title">GetHeapTop</span><span class="params">()</span></span>;<span class="comment">//获取堆顶元素</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">HeapSize</span><span class="params">()</span></span>;<span class="comment">//获取堆中元素个数</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isHeapEmpty</span><span class="params">()</span></span>;<span class="comment">//堆是否为空</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isHeapFull</span><span class="params">()</span></span>;<span class="comment">//堆是否已满</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Display</span><span class="params">()</span></span>;<span class="comment">//打印堆</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">T* heapArray;<span class="comment">//存放数据元素的数组</span></span><br><span class="line"><span class="keyword">int</span> markArray;<span class="comment">//标记</span></span><br><span class="line"><span class="keyword">int</span> MaxHeapSize;<span class="comment">//可存元素个数</span></span><br><span class="line"><span class="keyword">int</span> heapSize;<span class="comment">//当前元素个数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FilterUp</span><span class="params">(<span class="keyword">int</span> i)</span></span>;<span class="comment">//插入元素后进行堆化</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FilterDown</span><span class="params">(<span class="keyword">int</span> i)</span></span>;<span class="comment">//删除元素后进行堆化</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="2-最大堆类部分成员函数的实现"><a href="#2-最大堆类部分成员函数的实现" class="headerlink" title="2)最大堆类部分成员函数的实现"></a>2)最大堆类部分成员函数的实现</h4><p>最大堆类的成员函数的实现与最小堆类成员函数的实现基本相同，这里只列出部分成员的函数实现，不做解释。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">MaxHeap</span>&lt;T&gt;:</span>:MaxHeap( T arr[], <span class="keyword">int</span> n)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (n &lt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"非法参数！"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">heapArray = arr;</span><br><span class="line">heapSize = n;</span><br><span class="line">MaxHeapSize = n;</span><br><span class="line">markArray = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> currentPos = (n - <span class="number">1</span>) / <span class="number">2</span>;<span class="comment">//计算第一个非叶子结点的位置</span></span><br><span class="line"><span class="keyword">while</span> (currentPos &gt;= <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">FilterDown(currentPos);<span class="comment">//下移当前结点到合适的位置</span></span><br><span class="line">currentPos--;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> <span class="title">MaxHeap</span>&lt;T&gt;:</span>:Insert(<span class="keyword">const</span> T&amp; item)</span><br><span class="line">&#123;<span class="comment">//插入元素</span></span><br><span class="line"><span class="keyword">if</span> (heapSize == MaxHeapSize)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"非法参数！"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">heapArray[heapSize] = item;</span><br><span class="line">FilterUp(heapSize);</span><br><span class="line">heapSize++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">T</span> <span class="title">MaxHeap</span>&lt;T&gt;:</span>:Delete()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (heapSize == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"堆为空！"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">T item = heapArray[<span class="number">0</span>];</span><br><span class="line">heapArray[<span class="number">0</span>] = heapArray[heapSize - <span class="number">1</span>];<span class="comment">//用最后一个元素填充堆顶元素</span></span><br><span class="line">heapSize--;</span><br><span class="line">FilterDown(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">return</span> item;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> <span class="title">MaxHeap</span>&lt;T&gt;:</span>:FilterUp(<span class="keyword">int</span> i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> currentPos, ParentPos;</span><br><span class="line">T target = heapArray[i];</span><br><span class="line">currentPos = i;</span><br><span class="line">ParentPos = (i - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">while</span> (currentPos != <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (heapArray[ParentPos] &gt;= target)<span class="comment">//已经是最大堆</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">heapArray[currentPos] = heapArray[ParentPos];<span class="comment">//双亲结点下移</span></span><br><span class="line">currentPos = ParentPos;<span class="comment">//双亲结点为当前结点</span></span><br><span class="line">ParentPos = (currentPos - <span class="number">1</span>) / <span class="number">2</span>;<span class="comment">//找到当前结点的双亲结点</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">heapArray[currentPos] = target;<span class="comment">//插入新元素</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> <span class="title">MaxHeap</span>&lt;T&gt;:</span>:FilterDown(<span class="keyword">int</span> i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> currentPos,childPos;</span><br><span class="line">T target = heapArray[i];</span><br><span class="line">currentPos = i;</span><br><span class="line">childPos = i * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (childPos &lt; heapSize)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (childPos + <span class="number">1</span> &lt; heapSize &amp;&amp; (heapArray[childPos + <span class="number">1</span>] &gt;= heapArray[childPos]))</span><br><span class="line">childPos = childPos + <span class="number">1</span>;<span class="comment">//选择两个孩子结点中较大的一个作为孩子结点为位置</span></span><br><span class="line"><span class="keyword">if</span> (target &gt;= heapArray[childPos])</span><br><span class="line"><span class="keyword">break</span>;<span class="comment">//满足最大堆的性质</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">heapArray[currentPos] = heapArray[childPos];<span class="comment">//孩子结点上移</span></span><br><span class="line">currentPos = childPos;<span class="comment">//当前孩子结点作为当前结点</span></span><br><span class="line">childPos = childPos * <span class="number">2</span> + <span class="number">1</span>;<span class="comment">//当前结点的孩子结点位置</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">heapArray[currentPos] = target;<span class="comment">//把填充的堆顶元素插入</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3）测试函数"><a href="#3）测试函数" class="headerlink" title="3）测试函数"></a>3）测试函数</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> arr[] = &#123; <span class="number">24</span>,<span class="number">10</span>,<span class="number">90</span>,<span class="number">77</span>,<span class="number">16</span>,<span class="number">25</span>,<span class="number">33</span>,<span class="number">89</span>,<span class="number">67</span> &#125;;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"原数组元素为："</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (<span class="keyword">sizeof</span>(arr) / <span class="keyword">sizeof</span>(arr[<span class="number">0</span>])); i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; arr[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">MaxHeap&lt;<span class="keyword">int</span>&gt; heap(arr, (<span class="keyword">sizeof</span>(arr) / <span class="keyword">sizeof</span>(arr[<span class="number">0</span>])));</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"输出堆中元素："</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">heap.Display();</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; heap.Delete() &lt;&lt; <span class="string">"已被删除！"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"输出堆中元素："</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">heap.Display();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4）执行结果-1"><a href="#4）执行结果-1" class="headerlink" title="4）执行结果"></a>4）执行结果</h4><p><img src="/2019/08/02/堆——最小堆和最大堆的实现/最大堆执行结果.PNG" alt="最大堆测试执行结果"></p><h4 id="5）源码地址"><a href="#5）源码地址" class="headerlink" title="5）源码地址"></a>5）源码地址</h4><p>​        <a href="https://github.com/Aoki-Wang/CheckStation/tree/master/Data%20Structure/Heap/Max%20Heap" target="_blank" rel="noopener">最大堆的实现源码</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、堆概述&quot;&gt;&lt;a href=&quot;#一、堆概述&quot; class=&quot;headerlink&quot; title=&quot;一、堆概述&quot;&gt;&lt;/a&gt;一、堆概述&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;堆(Heap)是结点间数据元素的关键码具有层次次序关系的完全二叉树；&lt;/li&gt;
&lt;li&gt;堆是二叉树的顺序
      
    
    </summary>
    
      <category term="数据结构" scheme="http://wanqbin.xyz/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="C++" scheme="http://wanqbin.xyz/tags/C/"/>
    
      <category term="堆" scheme="http://wanqbin.xyz/tags/%E5%A0%86/"/>
    
      <category term="最大堆" scheme="http://wanqbin.xyz/tags/%E6%9C%80%E5%A4%A7%E5%A0%86/"/>
    
      <category term="最小堆" scheme="http://wanqbin.xyz/tags/%E6%9C%80%E5%B0%8F%E5%A0%86/"/>
    
      <category term="优先队列" scheme="http://wanqbin.xyz/tags/%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>交换排序——冒泡快速和快速排序的实现</title>
    <link href="http://wanqbin.xyz/2019/08/01/%E4%BA%A4%E6%8D%A2%E6%8E%92%E5%BA%8F%E2%80%94%E2%80%94%E5%86%92%E6%B3%A1%E5%BF%AB%E9%80%9F%E5%92%8C%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E7%9A%84%E5%AE%9E%E7%8E%B0/"/>
    <id>http://wanqbin.xyz/2019/08/01/交换排序——冒泡快速和快速排序的实现/</id>
    <published>2019-08-01T09:04:00.000Z</published>
    <updated>2019-08-02T04:05:08.588Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h2><p>&emsp;&emsp;利用交换对象的位置进行排序的方法称之为<code>交换排序</code>。常用的交换排序方法有冒泡排序法和快速排序法。快速排序法是一种分区交换排序方法。</p><h2 id="二、冒泡排序"><a href="#二、冒泡排序" class="headerlink" title="二、冒泡排序"></a>二、冒泡排序</h2><ul><li>冒泡排序法是一种简单常用的排序方法。</li><li>冒泡排序的思想是：对n个对象的对象集合，设第一个对象下标为0，依次把对象下标i定为0,1,2,3,……，n-2，然后依次将待排序对象集合中下标为i对象的关键码与下标为i+1对象的关键码进行比较，若前者大于后者，则交换两者的位置；后者不交换。</li><li>当这样的过程完成后，n个对象的数组的最后一个单元中就存放了对象集合中关键码最大的对象。</li><li>然后，不考虑这个已排好序对的对象，重新进行这样的过程，当这样的过程完成后，n-1个对象的数组的最后一个单元中就存放了对象集合中关键码最大的对象。当这样的过程进行n-1次，对象集合中就是排好序的对象集合。</li></ul><h4 id="1）冒泡排序的实现"><a href="#1）冒泡排序的实现" class="headerlink" title="1）冒泡排序的实现"></a>1）冒泡排序的实现</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">BubbleSort</span>(<span class="title">T</span> <span class="title">arr</span>[], <span class="title">int</span> <span class="title">n</span>)</span></span><br><span class="line"><span class="class">&#123;</span><span class="comment">//对arr数组元素进行排序</span></span><br><span class="line"><span class="keyword">int</span> i, j, flag=<span class="number">1</span>;</span><br><span class="line">T temp;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n &amp;&amp; flag == <span class="number">1</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">flag = <span class="number">0</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">flag用于标记本次交换排序过程是否</span></span><br><span class="line"><span class="comment">有交换动作，若本次交换排序过程没有交换动作，</span></span><br><span class="line"><span class="comment">则说明对象集合已全部排好序，就可提前结束排序过程</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; n-i; j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>])</span><br><span class="line">&#123;</span><br><span class="line">flag = <span class="number">1</span>;</span><br><span class="line">temp = arr[j];</span><br><span class="line">arr[j] = arr[j + <span class="number">1</span>];</span><br><span class="line">arr[j + <span class="number">1</span>] = temp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2）测试函数"><a href="#2）测试函数" class="headerlink" title="2）测试函数"></a>2）测试函数</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> arr[] = &#123; <span class="number">5</span>,<span class="number">15</span>,<span class="number">1</span>,<span class="number">48</span>,<span class="number">23</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">9</span> &#125;;</span><br><span class="line"><span class="keyword">int</span> n = <span class="keyword">sizeof</span>(arr) / <span class="keyword">sizeof</span>(arr[<span class="number">0</span>])<span class="number">-1</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"原数组为："</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; arr[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">BubbleSort(arr, n);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"排序结果为："</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; arr[j] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3）执行结果"><a href="#3）执行结果" class="headerlink" title="3）执行结果"></a>3）执行结果</h4><p><img src="/2019/08/01/交换排序——冒泡快速和快速排序的实现/冒泡排序执行结果.PNG" alt="冒泡排序执行结果"></p><h4 id="4）时空复杂度分析"><a href="#4）时空复杂度分析" class="headerlink" title="4）时空复杂度分析"></a>4）时空复杂度分析</h4><ul><li><p>时间复杂度:</p><ul><li><p>冒泡排序算法的最好情况是对象集合已全部排好序，这时循环n-1次，每次循环都因没有交换动作而退出，因此冒泡排序最好情况的时间复杂度是O(n);</p></li><li><p>冒泡排序的最坏情况是对象集合全部逆序存放，这时循环n-1次，整个循环的比较次数和移动次数为：</p><p>比较次数=$\sum^{1}_{i=n-1}{i}$=$\frac{n(n-1)}{2}$</p><p>移动次数=3$\sum^{i}_{i=n-1}{i}$=$\frac{3n(n-1)}{2}$</p><p>因此，冒泡排序算法最坏情况的时间复杂度为O($n^2$)</p></li></ul></li><li><p>空间复杂度：</p><p>冒泡排序算法的空间复杂度为O(1)。显然，冒泡排序算法是一种稳定的排序方法。</p></li></ul><h4 id="5）源码地址"><a href="#5）源码地址" class="headerlink" title="5）源码地址"></a>5）源码地址</h4><p>​        <a href="https://github.com/Aoki-Wang/CheckStation/tree/master/Data%20Structure/Exchange%20Sort/BubbleSort" target="_blank" rel="noopener">冒泡排序实现源码</a></p><h2 id="三、快速排序"><a href="#三、快速排序" class="headerlink" title="三、快速排序"></a>三、快速排序</h2><ul><li>快速排序又称为分区交换排序。</li><li>快速排序算法的基本思想是：从待排序的对象数组中任取一个个对象（通常是取对象数组中的第一个对象）作为基准，调整对象数组中各个对象在数组中的位置，使排在该对象前面对象的关键码均小于该对象的关键码，使排在该对象后面对象的关键码均大于该对象的关键码。</li><li>这样的交换过程结束后，一方面将该对象放在未来排好序的对象数组中该对象应在的位置上；另一方面将该对象数组中的对象以该对象为基准划分成了两个子对象数组，位于该基准对象左边子对象数组中对象的关键码均小于该对象的关键码，位于该基准对象右边子对象数组中对象的关键码均大于等于该对象的关键码。</li><li>对于这两个子对象数组中的对象分别再进行方法类同的快速排序，当各个子对象数组中的对象个数均小于1时，排序过程结束。显然，快速排序算法过程是递归的过程。</li></ul><h4 id="1）快速排序的实现"><a href="#1）快速排序的实现" class="headerlink" title="1）快速排序的实现"></a>1）快速排序的实现</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">int</span> <span class="title">Partition</span>(<span class="title">T</span> <span class="title">arr</span>[], <span class="title">int</span> <span class="title">low</span>, <span class="title">int</span> <span class="title">high</span>)</span></span><br><span class="line"><span class="class">&#123;</span><span class="comment">//表的划分</span></span><br><span class="line">T pivot;<span class="comment">//基准</span></span><br><span class="line">Swap(arr, low, (low + high) / <span class="number">2</span>);<span class="comment">//交换第一个元素与中间元素</span></span><br><span class="line">pivot = arr[low];<span class="comment">//将交换过来的中间元素作为基准</span></span><br><span class="line"><span class="keyword">int</span> last_small = low;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = low + <span class="number">1</span>; i &lt;= high; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (arr[i] &lt; pivot)</span><br><span class="line">&#123;</span><br><span class="line">last_small = last_small + <span class="number">1</span>;</span><br><span class="line">Swap(arr, last_small, i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">Swap(arr, low, last_small);</span><br><span class="line"><span class="keyword">return</span> last_small;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">QuickSort</span>(<span class="title">T</span> <span class="title">arr</span>[], <span class="title">int</span> <span class="title">low</span>, <span class="title">int</span> <span class="title">high</span>)</span></span><br><span class="line"><span class="class">&#123;</span><span class="comment">//快速排序</span></span><br><span class="line"><span class="keyword">int</span> q;</span><br><span class="line"><span class="keyword">if</span> (low &lt; high)</span><br><span class="line">&#123;</span><br><span class="line">q = Partition&lt;T&gt;(arr, low, high);</span><br><span class="line">QuickSort(arr, low, q - <span class="number">1</span>);</span><br><span class="line">QuickSort(arr, q + <span class="number">1</span>, high);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-快速排序的过程"><a href="#2-快速排序的过程" class="headerlink" title="2)快速排序的过程"></a>2)快速排序的过程</h4><p>&emsp;&emsp;在快速排序中，<code>Partition</code>函数的构造比较重要。<code>Partition</code>函数的算策略有几种，有的策略比本文中的算法要快，但却复杂并且容易出错。本文中的算法更加简单而且易于理解，当然也不慢。实际上，在所有的算法中，它所进行的键比较的次数可能是最少的。</p><p>&emsp;&emsp;对于基准的选择，并非一定要选择顺序表的首个元素作为基准，我们可以选择任意一个元素并在划分表的循环开始之前将它与表中的第一个元素交换。实际上，首个元素作为基准经常是一种拙劣的选择，因为一旦此顺序表是已经排过序的，则不会有其他元素再小于此基准，这将导致其中的一个子表为空表。因此，我们在表的近中央位置处选择了一个基准，希望这种选择可以把关键码划分在基准两边约各占一半。</p><p>&emsp;&emsp;给定一个基准<code>pivot</code>，我们必须重新排列表中的元素并计算一个下标<code>pivot_position</code>，使得基准位于<code>pivot_position</code>，在此下标左边的所有元素的关键码均小于<code>pivot</code>，在其右边的所有元素的关键码均大于或等于<code>pivot</code>。</p><p><img src="/2019/08/01/交换排序——冒泡快速和快速排序的实现/快速排序示意图.PNG" alt="快速排序"></p><h5 id="第一趟排序过程："><a href="#第一趟排序过程：" class="headerlink" title="第一趟排序过程："></a>第一趟排序过程：</h5><p><img src="/2019/08/01/交换排序——冒泡快速和快速排序的实现/快速排序执行过程.PNG" alt="快速排序第一趟排序"></p><h4 id="3）测试函数"><a href="#3）测试函数" class="headerlink" title="3）测试函数"></a>3）测试函数</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> arr[] = &#123; <span class="number">5</span>,<span class="number">15</span>,<span class="number">1</span>,<span class="number">48</span>,<span class="number">23</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">9</span> &#125;;</span><br><span class="line"><span class="keyword">int</span> n = <span class="keyword">sizeof</span>(arr) / <span class="keyword">sizeof</span>(arr[<span class="number">0</span>])<span class="number">-1</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"原数组为："</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; arr[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">QuickSort(arr, <span class="number">0</span>, n);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"排序结果为："</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; arr[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4）执行结果"><a href="#4）执行结果" class="headerlink" title="4）执行结果"></a>4）执行结果</h4><p><img src="/2019/08/01/交换排序——冒泡快速和快速排序的实现/快速排序执行结果.PNG" alt="快速排序执行结果"></p><h4 id="5）时空复杂度分析"><a href="#5）时空复杂度分析" class="headerlink" title="5）时空复杂度分析"></a>5）时空复杂度分析</h4><ul><li>时间复杂度：<ul><li>快速排序算法的时间复杂度和各次基准对象的值关系很大。如果每次取得的基准对象的值都能使该对象处于当前对象数组的中间位置上，将原来的对象数组分为两个大小相等的子对象数组，这样的快速排序算法过程相当于一个完全二叉树（即每个结点都把当前对象数组分为两个大小相等的子对象数组结点，n个对象数组的根结点的分解次数就构成一棵完全二叉树）。</li><li>这时分解次数等于n个结点的完全二叉树的深度lg2n</li><li>每次快速排序过程无论把对象数组怎样划分，全部的比较次数都基本等于n次，所以<code>最好情况</code>下快速排序算法的时间复杂度为<code>O(lgn)</code>。</li><li>快速排序算法的最坏情况是n个对象数组的根结点的分解次数构成一棵二叉退化树，一棵二叉退化树的深度为n，所以<code>最坏情况</code>下快速排序算法的时间复杂度为O($n^2$).</li><li>一般情况下，基准对象值的分布式随机的，而随机的基准对象值的n个对象数组的根结点的分解次数构成一棵二叉树，这样的二叉树的深度接近lgn，所以快速排序算法的<code>平均时间复杂度</code>为<code>O(nlgn)</code>。</li></ul></li><li>空间复杂度：<ul><li>快速排序算法需要堆栈空间临时保存递归调用参数，堆栈空间的使用个数与递归调用次数（即n个结点的二叉树的深度）有关，和上述时间复杂度分析类似，<code>最好情况</code>下快速排序算法的空间复杂度<code>为O(lgn)</code>;</li><li><code>最坏情况</code>下快速排序算法的空间复杂度为<code>O(n)</code>；</li><li>快速排序算法的<code>平均空间复杂度</code>为<code>O(lgn)</code></li></ul></li></ul><h4 id="5）源码地址-1"><a href="#5）源码地址-1" class="headerlink" title="5）源码地址"></a>5）源码地址</h4><p>​        <a href="https://github.com/Aoki-Wang/CheckStation/tree/master/Data%20Structure/Exchange%20Sort/QuickSort" target="_blank" rel="noopener">快速排序实现源码</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、概述&quot;&gt;&lt;a href=&quot;#一、概述&quot; class=&quot;headerlink&quot; title=&quot;一、概述&quot;&gt;&lt;/a&gt;一、概述&lt;/h2&gt;&lt;p&gt;&amp;emsp;&amp;emsp;利用交换对象的位置进行排序的方法称之为&lt;code&gt;交换排序&lt;/code&gt;。常用的交换排序方法有冒泡排
      
    
    </summary>
    
      <category term="数据结构" scheme="http://wanqbin.xyz/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="C++" scheme="http://wanqbin.xyz/tags/C/"/>
    
      <category term="冒泡排序" scheme="http://wanqbin.xyz/tags/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/"/>
    
      <category term="快速排序" scheme="http://wanqbin.xyz/tags/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/"/>
    
      <category term="排序" scheme="http://wanqbin.xyz/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>插入排序及其实现</title>
    <link href="http://wanqbin.xyz/2019/08/01/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F%E5%8F%8A%E5%85%B6%E5%AE%9E%E7%8E%B0/"/>
    <id>http://wanqbin.xyz/2019/08/01/插入排序及其实现/</id>
    <published>2019-08-01T03:19:00.000Z</published>
    <updated>2019-08-01T11:23:06.438Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、排序的基本概念"><a href="#一、排序的基本概念" class="headerlink" title="一、排序的基本概念"></a>一、排序的基本概念</h2><p>&emsp;&emsp;<code>排序</code>是将一个无序的数据元素集合整理成按<code>关键码</code>递增（或递减）排列的有规律有序集合的过程。关键码是所定义的数据元素类型中的一个域。</p><ol><li><h4 id="关键码"><a href="#关键码" class="headerlink" title="关键码"></a>关键码</h4><p>要排序的对象集合可能有多个域，关键码是当前排序时进行比较以确定各个对象位置的域。</p><p>在对象集合中，不同的对象其关键码值一定不相同的关键码称为<code>主关键码</code>;不同的对象其关键码值有可能相同的关键码称为<code>次关键码</code>。</p></li><li><h4 id="排序算法的稳定性"><a href="#排序算法的稳定性" class="headerlink" title="排序算法的稳定性"></a>排序算法的稳定性</h4><p>&emsp;&emsp;任何排序算法在使用主关键码进行排序时，其排序结果是相同的。当排序算法使用次关键码进行排序时，其排序结果可能相同，也可能不同。</p><p>&emsp;&emsp;对于有n个对象集合中的次关键码<code>K[i](i=0,1,2……，n-1)</code>，若<code>K[i]</code>等于<code>K[j](j=0,1,2……，n-1,j!=i)</code>,其在排序之前，对象<code>R[i]</code>排在对象<code>R[j]</code>之前，如果在排序之后对象<code>R[i]</code>仍在对象<code>R[j]</code>的前面的排序算法称为<code>稳定的排序算法</code>。否则称为<code>不稳定的排序算法</code>。</p><p>&emsp;&emsp;显然，对于一组给定的对象集合，所有稳定的排序算法的排序结果都是相同的，不稳定的排序算法的排序结果有可能相同，也有可能不同。稳定的排序算法通常是应用问题所希望的，因此，排序算法的稳定性是衡量排序算法好坏的一个重要标准。</p></li><li><h4 id="排序算法的时间复杂度"><a href="#排序算法的时间复杂度" class="headerlink" title="排序算法的时间复杂度"></a>排序算法的时间复杂度</h4><p>&emsp;&emsp;和所有算法一样，时间复杂度是衡量排序算法好坏的一个重要标准。排序算法的时间复杂度主要表现在算法中对象关键码的比较和对象的移动上。对于有n个对象的集合的排序问题，因为从该集合中找出一个最大（或最小）对象一定要遍历该集合，其时间复杂度为O(n),而进一步将n个对象均排列整齐的最理想情况可对应成完全二叉树结果，其时间复杂度为<code>O(nlgn)</code>,因此排序算法最好的时间复杂度为<code>O(nlgn)</code></p></li><li><h4 id="排序算法的空间复杂度"><a href="#排序算法的空间复杂度" class="headerlink" title="排序算法的空间复杂度"></a>排序算法的空间复杂度</h4><p>&emsp;&emsp;和所有算法一样，空间复杂度是衡量排序算法好坏的一个重要标准。排序算法的空间复杂度也就是算法中使用的辅助存储单元的多少。当排序算法中使用的存储单元与排序对象的个数n无关时，其空间复杂度为O(1),因此排序算法最好的空间复杂度为O(1)。空间复杂度为O(1)的排序算法也称为原地排序算法。原地排序算法就是在原来存放对象的数组空间中重新按关键码大小排放对象集合。</p></li></ol><h2 id="二、插入排序"><a href="#二、插入排序" class="headerlink" title="二、插入排序"></a>二、插入排序</h2><p>&emsp;&emsp;插入排序是一种由初始空集开始，不断地把新的对象插入到数组合适位置的排序方法，常用的插入排序法有直接插入排序、链表插入排序、希尔排序。</p><ol><li><h3 id="直接插入排序"><a href="#直接插入排序" class="headerlink" title="直接插入排序"></a>直接插入排序</h3><ul><li><p>直接插入排序的基本思想是：顺序地把待排序的对象按其关键码值的大小插入到已排序对象集合的适当位置。</p></li><li><p>假设待排序的对象为<code>R[0]、R[1]、R[2]、……、R[n-1]</code>,开始排序时对象集合<code>R[0]</code>因只有一个对象，所以已排好序。</p></li><li>第一次循环准备将对象<code>R[1]</code>插入到已排好序的对象集合<code>R[0]</code>中，这只需要比较<code>K[0]</code>和<code>K[1]</code>，若<code>K[0]&lt;=K[1]</code>，则已排好序，否则将<code>R[1]</code>插入到<code>R[0]</code>之前，这样，对象集合<code>R[0],R[1]</code>已排好序。</li><li>第二次循环准备将<code>R[2]</code>插入到已排好序的对象集合<code>R[0],R[1]</code>中，这需要先比较<code>K[2]</code>和<code>K[1]</code>以确定是否需要把<code>R[2]</code>插入到<code>R[1]</code>之前，然后比较<code>K[2]</code>和<code>K[0]</code>以确定是否需要把<code>R[2]</code>插入到<code>R[0]</code>之前。</li><li>这样的循环过程一直进行到<code>R[n-1]</code>插入完为止。这时对象集合<code>R[0]、R[1]、R[2]、……、R[n-1]</code>就全部排好序了。</li></ul><h4 id="1）直接插入排序的实现"><a href="#1）直接插入排序的实现" class="headerlink" title="1）直接插入排序的实现"></a>1）直接插入排序的实现</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">InsertSort</span>(<span class="title">T</span> <span class="title">a</span>[], <span class="title">int</span> <span class="title">n</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> i, j;</span><br><span class="line">T temp;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">temp = a[i + <span class="number">1</span>];</span><br><span class="line">j = i;</span><br><span class="line"><span class="keyword">while</span> (j &gt; <span class="number">-1</span> &amp;&amp; temp &lt; a[j])</span><br><span class="line">&#123;</span><br><span class="line">a[j + <span class="number">1</span>] = a[j];</span><br><span class="line">j--;</span><br><span class="line">&#125;</span><br><span class="line">a[j + <span class="number">1</span>] = temp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h4 id="2）测试函数"><a href="#2）测试函数" class="headerlink" title="2）测试函数"></a>2）测试函数</h4>   <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> sort[] = &#123; <span class="number">15</span>,<span class="number">22</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">56</span>,<span class="number">89</span>,<span class="number">14</span> &#125;;</span><br><span class="line">   <span class="keyword">int</span> n = <span class="keyword">sizeof</span>(sort) / <span class="keyword">sizeof</span>(sort[<span class="number">0</span>])<span class="number">-1</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"原数组为："</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; sort[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">InsertSort(sort, n);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"排序结果为："</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; sort[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3）执行结果"><a href="#3）执行结果" class="headerlink" title="3）执行结果"></a>3）执行结果</h4><p>   <img src="/2019/08/01/插入排序及其实现/直接插入排序执行结果.PNG" alt="直接插入排序执行结果"></p><h4 id="4）时空复杂度分析"><a href="#4）时空复杂度分析" class="headerlink" title="4）时空复杂度分析"></a>4）时空复杂度分析</h4><ul><li><p>直接插入排序算法的时间复杂度分析可分为最好和最坏两种情况考虑：</p><ul><li><p>最好的情况是原始对象集合已全部排好序。此时while循环的循环次数均为0。这样在每次排序过程中关键码的比较次数为1，对象的移动次数为2，因此整个排序过程中关键码的比较次数为n-1，对象的移动次数为2(n-1)，所以最好情况的时间复杂度为O(n)</p></li><li><p>最坏的情况是原始对象集合逆序排列。这种情况下第<code>i</code>次排序时算法中的while循环的循环次数均为<code>i</code>。这样在整个排序过程中关键码的比较次数和对象移动次数可计算如下：</p><p>​        比较次数=$\sum^{ n-1}_{i=1}{(i+1)}$=$\frac {(n-1)(n+2)}{2}$</p><p>​        移动次数=$\sum_{i=1}^{n-1}{i+2}$=$\frac{(n-1)(n+4)}{2}$</p><p>因此，最坏情况下其时间复杂度为O($n^2$)。</p></li></ul></li><li><p>空间复杂度</p><ul><li>直接插入排序算法的空间复杂度为O(1)</li></ul></li><li><p>直接插入排序算法是一种稳定的排序算法</p><h4 id="5）源码地址"><a href="#5）源码地址" class="headerlink" title="5）源码地址"></a>5）源码地址</h4><p>​            <a href="https://github.com/Aoki-Wang/CheckStation/tree/master/Data%20Structure/Insert%20Sort/Direct%20Insert%20Sort" target="_blank" rel="noopener">直接插入排序实现源码</a></p></li></ul><ol><li><h3 id="链表插入排序"><a href="#链表插入排序" class="headerlink" title="链表插入排序"></a>链表插入排序</h3><p>&emsp;&emsp;链表插入排序的最终排序结果将把对象集合按关键码大小依次链接地存储在一个链表中。这时链表中每个结点的结构除数据域外要增加一个指向结点类型的指针域。</p><ul><li>链表插入排序的思想是：初始时链表为空，第一个对象<code>R[0]</code>直接插入到链表中。第二个对象<code>R[1]</code>插入到链表中的位置由<code>K[0]</code>和<code>K[1]</code>比较确定：若K[1]<code>&lt;</code>K[0]<code>，则把</code>R[1]<code>插入到</code>R[0]<code>前；否则把R[1]插入到R[0]</code>后.</li><li>第三个对象<code>R[2]</code>插入到链表中的位置由K[2]<code>和</code>K[1]<code>、K[0]</code>比较确定。若<code>K[2]&lt;K[0]</code>,则把<code>K[2]</code>插入到<code>K[0]</code>前。若<code>K[2]&gt;K[0]</code>，应比较<code>K[2]、K[1]</code>；</li><li>若<code>K[2]&lt;K[1]</code>，则把<code>R[2]</code>插入到<code>R[0]</code>后，<code>R[1]</code>前，若<code>K[2]&gt;K[1]</code>，则把<code>R[2]</code>插入到<code>R[1]</code>后。</li><li>这样的插入过程进行到<code>R[n-1]</code>插入完成后，则原始对象集合按关键码大小依次链接在一个链表中。</li></ul><h4 id="1）链表插入排序的实现"><a href="#1）链表插入排序的实现" class="headerlink" title="1）链表插入排序的实现"></a>1）链表插入排序的实现</h4><h5 id="链表中结点的数据类型定义："><a href="#链表中结点的数据类型定义：" class="headerlink" title="链表中结点的数据类型定义："></a>链表中结点的数据类型定义：</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">T data;<span class="comment">//数据域</span></span><br><span class="line">Node* next;<span class="comment">//指针域</span></span><br><span class="line">Node(Node* p = <span class="literal">NULL</span>) :next(p) &#123;&#125;<span class="comment">//用于构造头结点</span></span><br><span class="line">Node(T item,Node*p=<span class="literal">NULL</span>):data(item),next(p)&#123;&#125;<span class="comment">//构造其他存放数据元素的结点</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol><h5 id="链表插入排序的实现："><a href="#链表插入排序的实现：" class="headerlink" title="链表插入排序的实现："></a>链表插入排序的实现：</h5>   <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">LinkListInsertSort</span>(<span class="title">T</span> <span class="title">a</span>[], <span class="title">Node</span>&lt;T&gt;*&amp; <span class="title">list</span>, <span class="title">int</span> <span class="title">n</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">Node&lt;T&gt;* curr, * pre, * q;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line">curr = <span class="built_in">list</span>-&gt;next;</span><br><span class="line">pre = <span class="built_in">list</span>;</span><br><span class="line">q = <span class="keyword">new</span> Node&lt;T&gt;(a[i]);</span><br><span class="line"><span class="keyword">while</span> (curr != <span class="literal">NULL</span> &amp;&amp; curr-&gt;data &lt;= a[i])</span><br><span class="line">&#123;</span><br><span class="line">pre = curr;</span><br><span class="line">curr = curr-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">q-&gt;next = pre-&gt;next;</span><br><span class="line">pre-&gt;next = q;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2）测试函数-1"><a href="#2）测试函数-1" class="headerlink" title="2）测试函数"></a>2）测试函数</h4>   <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> arr[]= &#123; <span class="number">15</span>,<span class="number">22</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">56</span>,<span class="number">89</span>,<span class="number">14</span> &#125;;</span><br><span class="line">   <span class="keyword">int</span> n = <span class="keyword">sizeof</span>(arr) / <span class="keyword">sizeof</span>(arr[<span class="number">0</span>])<span class="number">-1</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"原数组为："</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; arr[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">Node&lt;<span class="keyword">int</span>&gt;* <span class="built_in">list</span> = <span class="keyword">new</span> Node&lt;<span class="keyword">int</span>&gt;;</span><br><span class="line">LinkListInsertSort(arr, <span class="built_in">list</span>, n);</span><br><span class="line">Display(<span class="built_in">list</span>);<span class="comment">//输出链表</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3）执行结果-1"><a href="#3）执行结果-1" class="headerlink" title="3）执行结果"></a>3）执行结果</h4><p>   <img src="/2019/08/01/插入排序及其实现/链表插入排序执行结果.PNG" alt="链表插入排序执行结果"></p><h4 id="4）时空复杂度分析-1"><a href="#4）时空复杂度分析-1" class="headerlink" title="4）时空复杂度分析"></a>4）时空复杂度分析</h4><ul><li><p>最坏时间复杂度</p><p>链表插入排序算法不需要移动数据对象，每插入一个对象时，最小关键码比较次数等于1，最大关键码比较次数等于链表中已排好序的对象的个数，即：</p><p>​        最小比较次数=n-1​</p><p>​        最大比较次数=$\sum^{n-1}_{i=1}{i}$=$\frac{n(n-1)}{2}$</p><p>所以，链表插入排序算法最坏情况的时间复杂度为O($n^2$)。</p></li><li><p>空间复杂度</p><p>链表插入排序算法另外需要n个结点存放排好序的数据对象，所以，链表插入排序算法的空间复杂度为O(n).</p></li><li><p>链表插入排序算法是一种稳定的排序算法。</p><h4 id="5）源码地址-1"><a href="#5）源码地址-1" class="headerlink" title="5）源码地址"></a>5）源码地址</h4><p>​            <a href="https://github.com/Aoki-Wang/CheckStation/tree/master/Data%20Structure/Insert%20Sort/List%20Insert%20Sort" target="_blank" rel="noopener">链表插入排序实现源码</a></p></li></ul><ol><li><h3 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h3><p>&emsp;&emsp;希尔排序又称作最小增量排序，希尔排序算法的思想是：不断把待排序的对象分成若干个小组，对同一小组内的对象用直接插入法进行排序，当完成了所有对象都分在一个小组内的排序之后，排序过程结束。</p><p>&emsp;&emsp;希尔排序是在分组概念上的插入排序，即在不断缩小组的个数时把原各小组的对象插入到新组中的合适位置上。</p><p>&emsp;&emsp;原始对象集合越接近有序，直接插入排序算法的时间效率越高，这也是希尔排序算法能够成立的基础。希尔排序算法把待排序对象分成若干小组，在小组内用直接插入排序算法排序，当把小的小组合并为一些大的小组时，其中的对象集合将会接近有序，从而使直接插入排序算法的时间效率很高。</p><h4 id="1）希尔排序的实现"><a href="#1）希尔排序的实现" class="headerlink" title="1）希尔排序的实现"></a>1）希尔排序的实现</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">ShellSort</span>(<span class="title">T</span> <span class="title">arr</span>[], <span class="title">int</span> <span class="title">n</span>, <span class="title">int</span> <span class="title">increment</span>[], <span class="title">int</span> <span class="title">numOfIncrement</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">T temp;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> m = <span class="number">0</span>; m &lt; numOfIncrement; m++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; increment[m]; k++)</span><br><span class="line">&#123;<span class="comment">//每个小组内按直接插入排序算法排序，区别只是每次不是增1，而是increment[m]</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = k; i &lt; n - increment[m]; i = i + increment[m])</span><br><span class="line">&#123;</span><br><span class="line">temp = arr[i + increment[m]];</span><br><span class="line"><span class="keyword">int</span> j = i;</span><br><span class="line"><span class="keyword">while</span> (j &gt; <span class="number">-1</span> &amp;&amp; temp &lt;= arr[j])</span><br><span class="line">&#123;</span><br><span class="line">arr[j + increment[m]] = arr[j];</span><br><span class="line">j = j - increment[m];</span><br><span class="line">&#125;</span><br><span class="line">arr[j + increment[m]] = temp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2）希尔排序过程"><a href="#2）希尔排序过程" class="headerlink" title="2）希尔排序过程"></a>2）希尔排序过程</h4><p>当增量increment=4时：</p><p><img src="/2019/08/01/插入排序及其实现/increment=4.PNG" alt="希尔排序过程1"></p><p>当增量increment=3时：</p><p><img src="/2019/08/01/插入排序及其实现/increment=3.PNG" alt="希尔排序过程2"></p><p>当增量increment=1时：</p><p><img src="/2019/08/01/插入排序及其实现/increment=1.PNG" alt="希尔排序过程3"></p><h4 id="3）测试函数"><a href="#3）测试函数" class="headerlink" title="3）测试函数"></a>3）测试函数</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> arr[]= &#123; <span class="number">15</span>,<span class="number">22</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">56</span>,<span class="number">89</span>,<span class="number">14</span> &#125;;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"原数组为："</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">   <span class="keyword">int</span> n = <span class="keyword">sizeof</span>(arr) / <span class="keyword">sizeof</span>(arr[<span class="number">0</span>])<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; arr[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">int</span> increment[] = &#123; <span class="number">4</span>,<span class="number">3</span>,<span class="number">1</span> &#125;;</span><br><span class="line"><span class="keyword">int</span> numOfIncrement = <span class="keyword">sizeof</span>(increment) / <span class="keyword">sizeof</span>(increment[<span class="number">0</span>]);</span><br><span class="line">ShellSort(arr, n, increment, numOfIncrement);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"排序结果："</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; arr[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h4 id="4）执行结果"><a href="#4）执行结果" class="headerlink" title="4）执行结果"></a>4）执行结果</h4><p>   <img src="/2019/08/01/插入排序及其实现/希尔排序执行结果1.PNG" alt="希尔排序执行结果"></p><h4 id="5）时空复杂度"><a href="#5）时空复杂度" class="headerlink" title="5）时空复杂度"></a>5）时空复杂度</h4><ul><li><p>时间复杂度：</p><ul><li>比较希尔排序和直接排序算法可见，直接插入排序算法是两重循环，希尔排序算法是四重循环，但分析希尔排序算法中四重循环的循环数值可以发现，四重循环每重的循环数值都很小，并且当增量递减、小组变大时，小组内的对象数值已经基本有序了，而我们知道，越接近有序的直接插入，排序算法的时间效率越高。因此，希尔排序算法的时间复杂度较直接插入排序算法的时间复杂度改善了很多。</li><li>希尔排序算法的时间复杂度分析比较复杂，实际所需的时间取决于各次排序时增量的个数和增量的取值。研究证明，若增量的取值合理，希尔排序算法的时间复杂度约为O(n$({lgn})^2$)。</li></ul></li><li><p>空间复杂度：</p><p>希尔排序算法的空间复杂度为O(1)。由于希尔排序算法是按增量分组进行的排序，所以希尔排序是一种不稳定的排序算法。</p><h4 id="5）源码地址-2"><a href="#5）源码地址-2" class="headerlink" title="5）源码地址"></a>5）源码地址</h4><p>​            <a href="https://github.com/Aoki-Wang/CheckStation/tree/master/Data%20Structure/Insert%20Sort/Shell%20Sort" target="_blank" rel="noopener">希尔排序实现源码</a></p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、排序的基本概念&quot;&gt;&lt;a href=&quot;#一、排序的基本概念&quot; class=&quot;headerlink&quot; title=&quot;一、排序的基本概念&quot;&gt;&lt;/a&gt;一、排序的基本概念&lt;/h2&gt;&lt;p&gt;&amp;emsp;&amp;emsp;&lt;code&gt;排序&lt;/code&gt;是将一个无序的数据元素集合整理
      
    
    </summary>
    
      <category term="数据结构" scheme="http://wanqbin.xyz/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="排序" scheme="http://wanqbin.xyz/tags/%E6%8E%92%E5%BA%8F/"/>
    
      <category term="插入排序" scheme="http://wanqbin.xyz/tags/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/"/>
    
      <category term="直接插入排序" scheme="http://wanqbin.xyz/tags/%E7%9B%B4%E6%8E%A5%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/"/>
    
      <category term="链表插入排序" scheme="http://wanqbin.xyz/tags/%E9%93%BE%E8%A1%A8%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/"/>
    
      <category term="希尔排序" scheme="http://wanqbin.xyz/tags/%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>二叉搜索树及其实现</title>
    <link href="http://wanqbin.xyz/2019/07/31/%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E5%8F%8A%E5%85%B6%E5%AE%9E%E7%8E%B0/"/>
    <id>http://wanqbin.xyz/2019/07/31/叉搜索树及其实现/</id>
    <published>2019-07-31T15:36:00.000Z</published>
    <updated>2019-07-31T15:49:49.145Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、二叉搜索树概述"><a href="#一、二叉搜索树概述" class="headerlink" title="一、二叉搜索树概述"></a>一、二叉搜索树概述</h2><p>&emsp;&emsp;一棵二叉搜索树(Binary Search Tree,BST)是以一棵二叉树来组织的。BST是满足下面条件的二叉树，该条件即二叉搜索树属性：</p><ul><li>对于二叉搜索树的一个结点，设其值为K，则该结点左子树任意一个结点的值都小于K</li><li>该结点右子树中任意一个结点的值都大于或等于K。</li></ul><p>&emsp;二叉查找树的特点是，如果按照中序周游将各个结点打印出来，就会得到由小到大排列结点。</p><p>&emsp;&emsp;从根结点开始，在BST中检索值K。如果根结点存储的值为K，则检索结束。如果不是，则必须检索树的更深一层。BST的效率在于只需检索两棵子树之一。如果K小于根结点的值，则只需检索左子树；如果K大于根结点的值，则只需检索右子树。这个过程一直持续到K被找到或遇到一个叶结点为止。如果遇到叶结点仍没有发现K，那么K就不在这个BST中。</p><h2 id="二、二叉搜索树的实现"><a href="#二、二叉搜索树的实现" class="headerlink" title="二、二叉搜索树的实现"></a>二、二叉搜索树的实现</h2><h4 id="emsp-二叉搜索树结点类的定义："><a href="#emsp-二叉搜索树结点类的定义：" class="headerlink" title="&emsp;二叉搜索树结点类的定义："></a>&emsp;二叉搜索树结点类的定义：</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;<span class="title">class</span> <span class="title">BinarySearchTree</span>;</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;<span class="title">class</span> <span class="title">BitreeNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">BinarySearchTree</span>&lt;T&gt;;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">T data;<span class="comment">//数据域</span></span><br><span class="line">BitreeNode() :leftChild(<span class="literal">NULL</span>), rightChild(<span class="literal">NULL</span>) &#123;&#125;<span class="comment">//构造函数</span></span><br><span class="line">BitreeNode(T item, BitreeNode&lt;T&gt;* left = <span class="literal">NULL</span>, BitreeNode&lt;T&gt;* right = <span class="literal">NULL</span>)</span><br><span class="line">:data(item), leftChild(left), rightChild(right) &#123;&#125;</span><br><span class="line">~BitreeNode() &#123;&#125;<span class="comment">//析构函数</span></span><br><span class="line">BitreeNode&lt;T&gt;*&amp; Left()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> leftChild;</span><br><span class="line">&#125;</span><br><span class="line">BitreeNode&lt;T&gt;*&amp; Right()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> rightChild;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">BitreeNode&lt;T&gt;* leftChild;<span class="comment">//左子树指针</span></span><br><span class="line">BitreeNode&lt;T&gt;* rightChild;<span class="comment">//右子树指针</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>二叉搜索树是以二叉树来组织的，所以其结点类的定义于二叉树结点类的定义相同。</p><h4 id="二叉搜索树类的定义："><a href="#二叉搜索树类的定义：" class="headerlink" title="二叉搜索树类的定义："></a>二叉搜索树类的定义：</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;<span class="title">class</span> <span class="title">BinarySearchTree</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">BinarySearchTree() :root(<span class="literal">NULL</span>) &#123;&#125;<span class="comment">//无参构造参数</span></span><br><span class="line">BinarySearchTree(<span class="keyword">const</span> BinarySearchTree&amp; rhs);<span class="comment">//有参构造函数</span></span><br><span class="line">~BinarySearchTree();<span class="comment">//析构函数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">const</span> T&amp; <span class="title">findMax</span><span class="params">()</span> <span class="keyword">const</span></span>;<span class="comment">//寻找最大值</span></span><br><span class="line"><span class="function"><span class="keyword">const</span> T&amp; <span class="title">findMin</span><span class="params">()</span> <span class="keyword">const</span></span>;<span class="comment">//寻找最小值</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">contains</span><span class="params">(<span class="keyword">const</span> T&amp; value)</span> <span class="keyword">const</span></span>;<span class="comment">//判断value是否存在</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isEmpty</span><span class="params">()</span> <span class="keyword">const</span></span>;<span class="comment">//二叉搜索树是否为空</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InOrder</span><span class="params">(<span class="keyword">void</span>(*visit)(T item))</span> <span class="keyword">const</span></span>;<span class="comment">//输出树结点</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">makeEmpty</span><span class="params">()</span></span>;<span class="comment">//清空树</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">const</span> T&amp;value)</span></span>;<span class="comment">//插入</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">remove</span><span class="params">(<span class="keyword">const</span> T&amp;value)</span></span>;<span class="comment">//删除值为value的结点</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">BitreeNode&lt;T&gt;* root;<span class="comment">//根结点</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">const</span> T&amp; value, BitreeNode&lt;T&gt;*&amp; t)</span> <span class="keyword">const</span></span>;<span class="comment">//插入新结点</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">remove</span><span class="params">(<span class="keyword">const</span> T&amp; value, BitreeNode&lt;T&gt;*&amp; t)</span> <span class="keyword">const</span></span>;<span class="comment">//删除结点</span></span><br><span class="line">BitreeNode&lt;T&gt;* finMin(BitreeNode&lt;T&gt;* t) <span class="keyword">const</span>;<span class="comment">//查找二叉搜索树中值最小的结点</span></span><br><span class="line">BitreeNode&lt;T&gt;* finMax(BitreeNode&lt;T&gt;* t) <span class="keyword">const</span>;<span class="comment">//查找二叉搜索树中值最大的结点</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">contains</span><span class="params">(<span class="keyword">const</span> T&amp; value, BitreeNode&lt;T&gt;* t)</span> <span class="keyword">const</span></span>;<span class="comment">//判断二叉搜索树中是否存在一个值为value的结点</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">makeEmpty</span><span class="params">(BitreeNode&lt;T&gt;*&amp; t)</span></span>;<span class="comment">//清空结点</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InOrder</span><span class="params">(BitreeNode&lt;T&gt;* t, <span class="keyword">void</span>(*visit)(T item))</span><span class="keyword">const</span></span>;<span class="comment">//中序输出结点</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PreOrder</span><span class="params">(BitreeNode&lt;T&gt;* t, <span class="keyword">void</span>(*visit)(T item))</span> <span class="keyword">const</span></span>;<span class="comment">//前序输出结点</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PostOrder</span><span class="params">(BitreeNode&lt;T&gt;* t, <span class="keyword">void</span>(*visit)(T item))</span> <span class="keyword">const</span></span>;<span class="comment">//后序输出结点</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>二叉搜索树的一个最重要的应用就是它们在查找中的应用。虽然任意复杂的项在C++中都很容易处理，但是为了简单起见，先假设它们都是整数。</p><p>其实现的部分代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">bool</span> <span class="title">BinarySearchTree</span>&lt;T&gt;:</span>:contains(<span class="keyword">const</span> T&amp; value) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> contains(value, root);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">bool</span> <span class="title">BinarySearchTree</span>&lt;T&gt;:</span>:contains(<span class="keyword">const</span> T&amp; value, BitreeNode&lt;T&gt;* t) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (t == <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (value &lt; t-&gt;data)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> contains(value, t-&gt;leftChild);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (value &gt; t-&gt;data)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> contains(value, t-&gt;rightChild);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>contains</code>函数用来判断二叉树中是否存在值为value的结点。如果在树中存在该结点，那么该函数返回<code>true</code>,否则返回<code>false</code>.树的结构使得该操作很简单。如果树为空，则返回<code>false</code>,否则，如果根结点的值为value，则返回<code>true</code>。若以上两种情况都不成立，则根据value与根结点值的大小关系决定对左子树还是右子树进行递归调用。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> <span class="title">BinarySearchTree</span>&lt;T&gt;:</span>:InOrder(BitreeNode&lt;T&gt;* t,<span class="keyword">void</span>(*visit)(T item)) <span class="keyword">const</span></span><br><span class="line">&#123;<span class="comment">//中序遍历</span></span><br><span class="line"><span class="keyword">if</span> (t != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">printTree(t-&gt;leftChild, visit);</span><br><span class="line">visit(t-&gt;data);</span><br><span class="line">printTree(t-&gt;rightChild, visit);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> <span class="title">BinarySearchTree</span>&lt;T&gt;:</span>:PreOrder(BitreeNode&lt;T&gt;* t, <span class="keyword">void</span>(*visit)(T item)) <span class="keyword">const</span></span><br><span class="line">&#123;<span class="comment">//前序遍历</span></span><br><span class="line"><span class="keyword">if</span> (t != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">visit(t-&gt;data);</span><br><span class="line">PreOrder(t-&gt;leftChild, visit);</span><br><span class="line">PreOrder(t-&gt;rightChild, visit);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> <span class="title">BinarySearchTree</span>&lt;T&gt;:</span>:PostOrder(BitreeNode&lt;T&gt;* t, <span class="keyword">void</span>(*visit)(T item)) <span class="keyword">const</span></span><br><span class="line">&#123;<span class="comment">//后序遍历</span></span><br><span class="line"><span class="keyword">if</span> (t != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">PostOrder(t-&gt;leftChild,visit);</span><br><span class="line">PostOrder(t-&gt;rightChild, visit);</span><br><span class="line">visit(t-&gt;data);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上分别为中序遍历，前序遍历和后序遍历。其中，中序遍历的输出结果是从小到大进行排列的，这也是二叉搜索树的一个特点。中序遍历(LDR)、前序遍历(DLR)、后序遍历(LRD)。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">BitreeNode</span>&lt;T&gt;* <span class="title">BinarySearchTree</span>&lt;T&gt;:</span>:finMin(BitreeNode&lt;T&gt;* t) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (t != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span> (t-&gt;leftChild != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">t = t-&gt;leftChild;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">BitreeNode</span>&lt;T&gt;* <span class="title">BinarySearchTree</span>&lt;T&gt;:</span>:finMax(BitreeNode&lt;T&gt;* t) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (t != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span> (t-&gt;rightChild != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">t = t-&gt;rightChild;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上两个函数是用来查找最大值和最小值。由于二叉搜索函树的性质，所以查找最大值和最小值也比较方便。对于最小值，还需要查找到最左叶子结点，即为最小值；而最大值则需要查找到最右叶子节点，即为最大值。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> <span class="title">BinarySearchTree</span>&lt;T&gt;:</span>:insert(<span class="keyword">const</span> T&amp; value, BitreeNode&lt;T&gt;*&amp; t) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (t == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">t = <span class="keyword">new</span> BitreeNode&lt;T&gt;(value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (value &lt; t-&gt;data)</span><br><span class="line">&#123;</span><br><span class="line">insert(value, t-&gt;leftChild);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (value &gt; t-&gt;data)</span><br><span class="line">&#123;</span><br><span class="line">insert(value, t-&gt;rightChild);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于一个二叉搜索树来说，<code>insert</code>函数相对来说比较重要，因为二叉搜索树的属性是左孩子始终比双亲结点小，而右孩子始终比双亲结点大。此时需要注意的是，此二叉搜索树并不能处理插入已存在数据的操作，即二叉树结点中的每一项的值是各不相同的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> <span class="title">BinarySearchTree</span>&lt;T&gt;:</span>:remove(<span class="keyword">const</span> T&amp; value,BitreeNode&lt;T&gt;*&amp; t) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (t == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (value &lt; t-&gt;data)</span><br><span class="line">&#123;</span><br><span class="line">remove(value, t-&gt;leftChild);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (value &gt; t-&gt;data)</span><br><span class="line">&#123;</span><br><span class="line">remove(value, t-&gt;rightChild);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (t-&gt;leftChild != <span class="literal">NULL</span> &amp;&amp; t-&gt;rightChild != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">t-&gt;data = findMin(t-&gt;right)-&gt;data;</span><br><span class="line">remove(t-&gt;data, t-&gt;rightChild);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">BitreeNode&lt;T&gt;* oldNode = t;</span><br><span class="line">t = (t-&gt;leftChild != <span class="literal">NULL</span>) ? t-&gt;leftChild : t-&gt;rightChild;</span><br><span class="line"><span class="keyword">delete</span> oldNode;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最值得注意的是删除操作，即<code>remove</code>。删除操作需要考虑多种情况。</p><ul><li>当要删除的对象为叶子结点时，可以直接删除该叶子结点。</li><li>如果结点有一个孩子，则该结点可以在其父结点调整它的链以绕过该结点后被删除。图示如下：</li></ul><p><img src="/2019/07/31/叉搜索树及其实现/具有一个儿子的结点4删除前后的情况.PNG" alt="删除具有一个孩子的结点4前后的情况"></p><p>​    在该树中，我们删除了具有一个孩子的结点4。</p><ul><li>复杂的情况是，处理具有两个孩子的结点。一般的删除策略是用其右子树的最小数据代替该结点的数据并递归地删除该结点。因为右子树中的最小的结点不可能有左孩子，所以第二次<code>remove</code>就很容易了。图示如下：</li></ul><p><img src="/2019/07/31/叉搜索树及其实现/删除具有两个孩子的结点2前后的情况.PNG" alt="删除具有两个孩子的结点2前后的情况"></p><p>​    在该树中，我们删除了具有两个孩子的结点4，其中虚线连接的结点代表已经删除了。右边的图是删除后的结果。在删除后，它被右子树中最小的值，即3代替了。</p><h2 id="三、主函数及执行结果"><a href="#三、主函数及执行结果" class="headerlink" title="三、主函数及执行结果"></a>三、主函数及执行结果</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">"BST.h"</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">BinarySearchTree&lt;<span class="keyword">int</span>&gt; BST;</span><br><span class="line">BST.insert(<span class="number">20</span>);</span><br><span class="line">BST.insert(<span class="number">18</span>);</span><br><span class="line">BST.insert(<span class="number">5</span>);</span><br><span class="line">BST.insert(<span class="number">10</span>);</span><br><span class="line">BST.insert(<span class="number">25</span>);</span><br><span class="line">BST.insert(<span class="number">4</span>);</span><br><span class="line">BST.insert(<span class="number">21</span>);</span><br><span class="line">BST.insert(<span class="number">18</span>);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"最大值："</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; BST.findMax() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"最小值："</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; BST.findMin() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">int</span> temp = <span class="number">18</span>;</span><br><span class="line"><span class="keyword">if</span> (BST.contains(temp))</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"BST中存在"</span> &lt;&lt;temp&lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"BST中不存在"</span>&lt;&lt;temp &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">BST.InOrder(Visit);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">BST.makeEmpty();</span><br><span class="line"><span class="keyword">if</span> (BST.isEmpty())</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"BST为空！"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"BST非空！"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">system(<span class="string">"pause"</span>);</span><br><span class="line"><span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="执行结果："><a href="#执行结果：" class="headerlink" title="执行结果："></a>执行结果：</h4><p><img src="/2019/07/31/叉搜索树及其实现/执行结果.PNG" alt="执行结果"></p><h2 id="四、源码地址"><a href="#四、源码地址" class="headerlink" title="四、源码地址"></a>四、源码地址</h2><p>​            <a href="https://github.com/Aoki-Wang/CheckStation/tree/master/Data%20Structure/Binary%20Search%20Tree" target="_blank" rel="noopener">二叉搜索树的实现源码</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、二叉搜索树概述&quot;&gt;&lt;a href=&quot;#一、二叉搜索树概述&quot; class=&quot;headerlink&quot; title=&quot;一、二叉搜索树概述&quot;&gt;&lt;/a&gt;一、二叉搜索树概述&lt;/h2&gt;&lt;p&gt;&amp;emsp;&amp;emsp;一棵二叉搜索树(Binary Search Tree,BST
      
    
    </summary>
    
      <category term="数据结构" scheme="http://wanqbin.xyz/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="二叉树" scheme="http://wanqbin.xyz/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
      <category term="二叉搜索树" scheme="http://wanqbin.xyz/tags/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/"/>
    
      <category term="BST" scheme="http://wanqbin.xyz/tags/BST/"/>
    
  </entry>
  
  <entry>
    <title>二叉树的实现</title>
    <link href="http://wanqbin.xyz/2019/07/31/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%AE%9E%E7%8E%B0/"/>
    <id>http://wanqbin.xyz/2019/07/31/二叉树的实现/</id>
    <published>2019-07-31T15:20:00.000Z</published>
    <updated>2019-08-01T01:36:46.795Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、二叉树结点类定义"><a href="#一、二叉树结点类定义" class="headerlink" title="一、二叉树结点类定义"></a>一、二叉树结点类定义</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;<span class="title">class</span> <span class="title">BinaryTree</span>;</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;<span class="title">class</span> <span class="title">BiTreeNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">BinaryTree</span>&lt;T&gt;;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">T data;<span class="comment">//数据域</span></span><br><span class="line">BiTreeNode() :leftChild(<span class="literal">NULL</span>), rightChild(<span class="literal">NULL</span>) &#123;&#125;<span class="comment">//构造函数</span></span><br><span class="line">BiTreeNode(T item,BiTreeNode&lt;T&gt;*left=<span class="literal">NULL</span>,BiTreeNode&lt;T&gt;*right=<span class="literal">NULL</span>)<span class="comment">//构造函数</span></span><br><span class="line">:data(item),leftChild(left),rightChild(right)&#123;&#125;</span><br><span class="line">~BiTreeNode()&#123;&#125;<span class="comment">//析构函数</span></span><br><span class="line"></span><br><span class="line">BiTreeNode&lt;T&gt;*&amp; Left()</span><br><span class="line">&#123;<span class="comment">//获得左孩子</span></span><br><span class="line"><span class="keyword">return</span> leftChild;</span><br><span class="line">&#125;</span><br><span class="line">BiTreeNode&lt;T&gt;*&amp; Right()</span><br><span class="line">&#123;<span class="comment">//获得右孩子</span></span><br><span class="line"><span class="keyword">return</span> rightChild;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">BiTreeNode&lt;T&gt;* leftChild;<span class="comment">//左子树指针</span></span><br><span class="line">BiTreeNode&lt;T&gt;* rightChild;<span class="comment">//右子树指针</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="二、二叉树类定义"><a href="#二、二叉树类定义" class="headerlink" title="二、二叉树类定义"></a>二、二叉树类定义</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;<span class="title">class</span> <span class="title">BinaryTree</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">BinaryTree() :root(<span class="literal">NULL</span>)&#123;&#125;;<span class="comment">//构造函数</span></span><br><span class="line">~BinaryTree() &#123;&#125;;<span class="comment">//析构函数</span></span><br><span class="line"><span class="comment">//构造二叉树</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MakeTree</span><span class="params">(<span class="keyword">const</span> T&amp; item)</span></span>;</span><br><span class="line"><span class="comment">//第一类操作的成员函数</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Root</span><span class="params">()</span></span>;<span class="comment">//使根结点为当前结点</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Parent</span><span class="params">()</span></span>;<span class="comment">//使双亲结点为当前结点</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">LeftChild</span><span class="params">()</span></span>;<span class="comment">//使左孩子结点为当前结点</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">RightChild</span><span class="params">()</span></span>;<span class="comment">//使右孩子结点为当前结点</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//第二类操作的成员函数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InsertChild</span><span class="params">(<span class="keyword">const</span> T &amp;value)</span></span>;<span class="comment">//使根结点为当前结点</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DeleteSubTree</span><span class="params">(BiTreeNode&lt;T&gt;*&amp; t)</span></span>;<span class="comment">//删除以t为根结点的子树</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span></span>;<span class="comment">//清空树</span></span><br><span class="line"><span class="comment">//第三类操作的成员函数</span></span><br><span class="line"><span class="comment">//遍历访问二叉树</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PreOrder</span><span class="params">(<span class="keyword">void</span>(*visit)(T item))</span></span>;<span class="comment">//前序遍历访问树</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InOrder</span><span class="params">(<span class="keyword">void</span>(*visit)(T item))</span></span>;<span class="comment">//中序遍历访问树</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PostOrder</span><span class="params">(<span class="keyword">void</span>(*visit)(T item))</span></span>;<span class="comment">//后序遍历访问树</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">BiTreeNode&lt;T&gt;* root;<span class="comment">//根结点指针</span></span><br><span class="line">BiTreeNode&lt;T&gt;* current;<span class="comment">//当前结点指针</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Current</span><span class="params">(BiTreeNode&lt;T&gt;*&amp; t)</span></span>;<span class="comment">//使当前结点为t所指结点</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PreOrder</span><span class="params">(BiTreeNode&lt;T&gt;*&amp; t, <span class="keyword">void</span>(*visit)(T item))</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InOrder</span><span class="params">(BiTreeNode&lt;T&gt;*&amp; t, <span class="keyword">void</span>(*visit)(T item))</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PostOrder</span><span class="params">(BiTreeNode&lt;T&gt;*&amp; t, <span class="keyword">void</span>(*visit)(T item))</span></span>;</span><br><span class="line"><span class="comment">//插入</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Insert</span><span class="params">(<span class="keyword">const</span> T&amp; value, BiTreeNode&lt;T&gt;*&amp; t)</span></span>;</span><br><span class="line"><span class="comment">//在树root中回溯查找s的双亲结点</span></span><br><span class="line">BiTreeNode&lt;T&gt;* SearchParent(BiTreeNode&lt;T&gt;*&amp; root, BiTreeNode&lt;T&gt;*&amp; s);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="三、二叉树实现的部分代码"><a href="#三、二叉树实现的部分代码" class="headerlink" title="三、二叉树实现的部分代码"></a>三、二叉树实现的部分代码</h2><h4 id="前序遍历"><a href="#前序遍历" class="headerlink" title="前序遍历"></a>前序遍历</h4><p>即DLR，也叫做先根遍历、先序遍历、前序周游，记作根左右。前序遍历首先访问根结点，然后遍历左子树，最后遍历右子树。</p><p>这里使用<code>visit(item)</code>函数来输出结点数据域值，同时，<code>visit(item)</code>函数经过修改之后，也可以输出自定义数据类型中需要输出的数据。</p><p><code>visit(item)</code>函数的实现如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">Visit</span>(<span class="title">T</span> <span class="title">item</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; item &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> <span class="title">BinaryTree</span>&lt;T&gt;:</span>:PreOrder(<span class="keyword">void</span>(*visit)(T item))</span><br><span class="line">&#123;</span><br><span class="line">PreOrder(root,Visit);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> <span class="title">BinaryTree</span>&lt;T&gt;:</span>:PreOrder(BiTreeNode&lt;T&gt;*&amp; t, <span class="keyword">void</span>(*visit)(T item))</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (t != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">visit(t-&gt;data);</span><br><span class="line">PreOrder(t-&gt;leftChild,visit);</span><br><span class="line">PreOrder(t-&gt;rightChild,visit);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h4><p>即DLR，也叫中根遍历、中序周游。可记作根左右。在二叉树中，中序遍历首先遍历左子树，然后访问根结点，最后遍历右子树。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> <span class="title">BinaryTree</span>&lt;T&gt;:</span>:InOrder(<span class="keyword">void</span>(*visit)(T item))</span><br><span class="line">&#123;</span><br><span class="line">InOrder(root,Visit);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> <span class="title">BinaryTree</span>&lt;T&gt;:</span>:InOrder(BiTreeNode&lt;T&gt;*&amp; t, <span class="keyword">void</span>(*visit)(T item))</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (t != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">InOrder(t-&gt;leftChild, visit);</span><br><span class="line">visit(t-&gt;data);</span><br><span class="line">InOrder(t-&gt;rightChild, visit);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h4><p>即LRD，也叫后根遍历、后序变周游，可记作左右根。在二叉树中，首先遍历左子树，然后遍历右子树，最后访问根结点。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> <span class="title">BinaryTree</span>&lt;T&gt;:</span>:PostOrder(<span class="keyword">void</span>(*visit)(T item))</span><br><span class="line">&#123;</span><br><span class="line">PostOrder(root,Visit);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> <span class="title">BinaryTree</span>&lt;T&gt;:</span>:PostOrder(BiTreeNode&lt;T&gt;*&amp; t, <span class="keyword">void</span>(*visit)(T item))</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (t != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">PostOrder(t-&gt;leftChild, visit);</span><br><span class="line">PostOrder(t-&gt;rightChild, visit);</span><br><span class="line">visit(t-&gt;data);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="删除子树"><a href="#删除子树" class="headerlink" title="删除子树"></a>删除子树</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> <span class="title">BinaryTree</span>&lt;T&gt;:</span>:DeleteSubTree(BiTreeNode&lt;T&gt;*&amp; t)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (t == <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">BiTreeNode&lt;T&gt;* q=t-&gt;leftChild, *p;</span><br><span class="line"><span class="keyword">while</span> (q != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">p = q-&gt;rightChild;</span><br><span class="line">DeleteSubTree(q);</span><br><span class="line">q = p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">delete</span> t;</span><br><span class="line">t = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="插入结点"><a href="#插入结点" class="headerlink" title="插入结点"></a>插入结点</h4><p>在此实现中，对于二叉树结点的插入基本与二叉搜索树相同。当根结点为空时，新插入的结点作为根结点。当新插入的结点值小于根结点值时，插入到左子树；当新插入的结点值大于根结点值时，插入到右子树。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> <span class="title">BinaryTree</span>&lt;T&gt;:</span>:InsertChild(<span class="keyword">const</span> T&amp; value)</span><br><span class="line">&#123;</span><br><span class="line">Insert(value, root);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> <span class="title">BinaryTree</span>&lt;T&gt;:</span>:Insert(<span class="keyword">const</span> T&amp; value, BiTreeNode&lt;T&gt;*&amp; t)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (t == <span class="literal">NULL</span>)</span><br><span class="line">t = <span class="keyword">new</span> BiTreeNode&lt;T&gt;(value);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (value &lt; t-&gt;data)</span><br><span class="line">&#123;</span><br><span class="line">Insert(value, t-&gt;leftChild);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (value &gt; t-&gt;data)</span><br><span class="line">&#123;</span><br><span class="line">Insert(value, t-&gt;rightChild);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="四、主函数及执行结果"><a href="#四、主函数及执行结果" class="headerlink" title="四、主函数及执行结果"></a>四、主函数及执行结果</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">BinaryTree&lt;<span class="keyword">int</span>&gt;BiTree;</span><br><span class="line">BiTree.InsertChild(<span class="number">15</span>);</span><br><span class="line">BiTree.InsertChild(<span class="number">5</span>);</span><br><span class="line">BiTree.InsertChild(<span class="number">6</span>);</span><br><span class="line">BiTree.InsertChild(<span class="number">8</span>);</span><br><span class="line">BiTree.InsertChild(<span class="number">20</span>);</span><br><span class="line">BiTree.InsertChild(<span class="number">22</span>);</span><br><span class="line">BiTree.InsertChild(<span class="number">16</span>);</span><br><span class="line">BiTree.InsertChild(<span class="number">18</span>);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"前序："</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">BiTree.PreOrder(Visit);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span> &lt;&lt; <span class="string">"中序:"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">BiTree.InOrder(Visit);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span> &lt;&lt; <span class="string">"后序:"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">BiTree.PostOrder(Visit);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">BiTree.clear();</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"前序："</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">BiTree.PreOrder(Visit);</span><br><span class="line">system(<span class="string">"pause"</span>);</span><br><span class="line"><span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果：</p><p><img src="/2019/07/31/二叉树的实现/执行结果.PNG" alt="执行结果"></p><h2 id="五、源码地址"><a href="#五、源码地址" class="headerlink" title="五、源码地址"></a>五、源码地址</h2><p>​        <a href="https://github.com/Aoki-Wang/CheckStation/tree/master/Data%20Structure/BinaryTree" target="_blank" rel="noopener">二叉树的实现源码</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、二叉树结点类定义&quot;&gt;&lt;a href=&quot;#一、二叉树结点类定义&quot; class=&quot;headerlink&quot; title=&quot;一、二叉树结点类定义&quot;&gt;&lt;/a&gt;一、二叉树结点类定义&lt;/h2&gt;&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;
      
    
    </summary>
    
      <category term="数据结构" scheme="http://wanqbin.xyz/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="二叉树" scheme="http://wanqbin.xyz/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
      <category term="二叉树的遍历" scheme="http://wanqbin.xyz/tags/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86/"/>
    
  </entry>
  
  <entry>
    <title>多态</title>
    <link href="http://wanqbin.xyz/2019/07/31/%E5%A4%9A%E6%80%81/"/>
    <id>http://wanqbin.xyz/2019/07/31/多态/</id>
    <published>2019-07-31T02:22:00.000Z</published>
    <updated>2019-07-31T06:56:19.899Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、多态"><a href="#一、多态" class="headerlink" title="一、多态"></a>一、多态</h2><p>&emsp;多态是面向对象程序设计语言中数据抽象和继承之外的第三个基本特征。</p><p>&emsp;多态性(Polymorphism)提供接口与具体实现之间的另一层隔离，从而实现将“what”和“how”分离开来。多态性改善了代码的可读性和组织性，同时也使创建的程序具有可扩展性。项目不仅在最初创建时期可以扩展，而且当项目在需要有新功能时也能扩展。</p><p>&emsp;C++支持编译时多态（静态多态）和运行时多态（动态多态），运算符重载和函数重载就是编译时多态，而派生类和虚函数实现运行时多态。</p><h2 id="二、静态联编和动态联编"><a href="#二、静态联编和动态联编" class="headerlink" title="二、静态联编和动态联编"></a>二、静态联编和动态联编</h2><p>静态多态和动态多态的区别就是函数地址是早绑定（静态联编）还是晚绑定（动态联编）。如果函数的调用，在编译阶段就可以确定函数的调用地址，并产生代码，就是静态多态（联编时多态），也就是说地址是早绑定的。而如果函数的调用地址不能在编译期间确定，而需要在运行时才能决定，这就属于晚绑定（运行时多态）。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">speak</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"动物在说话"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span>:</span><span class="keyword">public</span> Animal</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">speak</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"喵喵喵"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doSpeak</span><span class="params">(Animal&amp;animal)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">animal.speak();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Cat cat;</span><br><span class="line">doSpeak(cat);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当主函数调用<code>dospeak()</code>函数时，执行结果如下：</p><p><img src="/2019/07/31/多态/静态联编.PNG" alt="静态联编"></p><p>&emsp;我们可以看到输出结果为“动物在说话”,这是因为当调用<code>dospeak</code>函数时，<code>speak</code>函数的地址早就绑定好了，早绑定，即动态联编，在编译近阶段就确定好了地址。</p><p>&emsp;如果想调用猫的<code>speak</code>函数，就不能提前绑定好地址，所以需要在运行的时候再去确定函数地址，即动态联编，将<code>dospeak</code>方法改为虚函数，写法是在父类上声明虚函数，发生多态。发生多态时，父类的引用或指针指向了子类对象。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">speak</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"动物在说话"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>此时运行结果为：</p><p><img src="/2019/07/31/多态/动态联编.PNG" alt="动态联编"></p><h2 id="三、多态原理"><a href="#三、多态原理" class="headerlink" title="三、多态原理"></a>三、多态原理</h2><h4 id="动态绑定的实现："><a href="#动态绑定的实现：" class="headerlink" title="动态绑定的实现："></a>动态绑定的实现：</h4><p>&emsp;&emsp;当编译器发现我们的类中有虚函数时，编译器会创建一张虚函数表，把虚函数的函数入口地址放到虚函数表中，并且在类中秘密增加一个指针，这个指针就是<code>vfptr</code>，即<code>virtual function pointer</code>，这个指针是指向对象的虚函数表。在多态调用对的时候，根据<code>vfptr</code>指针，找到虚函数表来实现动态绑定。</p><p>&emsp;子类<code>Cat</code>写父类的虚函数<code>speak</code>，这中写法为重写。重写要求返回值、参数个数、类型、顺序都相同。</p><p>&emsp;当父类中有虚函数后，父类的内部结构就发生了变化。借助开发人员命令提示符为我们可以看到类的内部结构。</p><p>改变前的情况下图所示：</p><p><img src="/2019/07/31/多态/改变前.PNG" alt="改变前"></p><p>改变后的情况如下图所示：</p><p><img src="/2019/07/31/多态/改变后.PNG" alt="改变后"></p><p>我们可以看到，父类的内部结构发生了明显的变化，内部多了一个<code>vfptr</code>，且其大小也发生了变化。所谓<code>vfptr</code>即<code>virtual function pointer</code>，虚函数表指针，指向虚函数表。</p><p>而子类会继承父类的<code>vfptr table</code>，在构造函数中，子类会将虚函数表指针，指向自己的虚函数表。当发生重写时，会替换掉虚函数表中原有的<code>speak</code>，改为<code>&amp;Cat::speak</code></p><p>子类Cat的内部结构如下：</p><p><img src="/2019/07/31/多态/子类内部结构.PNG" alt="Cat内部结构"></p><h2 id="四、抽象基类和纯虚函数"><a href="#四、抽象基类和纯虚函数" class="headerlink" title="四、抽象基类和纯虚函数"></a>四、抽象基类和纯虚函数</h2><p>&emsp;&emsp;在设计时，常常希望基类仅仅作为其派生类的一个接口。这就是说，仅想对基类进行向上类型转换，使用它的接口，而不希望用户实际地创建一个基类的对象。同时创建一个纯虚函数允许接口中放置成员函数，而不一定要提供一段可能对这个函数毫无意义的代码。</p><p>&emsp;&emsp;做到这一点，可以在基类中加入至少一个纯虚函数（pure virtual function)，使得基类称为抽象类(abstract class)。</p><ul><li>纯虚函数使用关键字<code>virtual</code>，并在其后面加上<code>=0</code>。如果试图去实例化一个抽象类，编译器会阻止这种操作。</li><li>当继承一个抽象类时，必须实现所有的纯虚函数，否则由抽象类派生的类也是一个抽象类。</li><li><code>virtual void func()=0;</code>告诉把编译器在<code>vtable</code>中为函数保留一个位置，但在在这个特定位置不放地址。</li></ul><blockquote><p>创建公共接口的目的是：为了将子类的公共操作抽象出来，可以通过一个公共接口来操纵一组类，且这个公共交界口不需要事先（或者不要完全实现）。可以创建一个公共类。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">speak</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span> :</span><span class="keyword">public</span> Animal</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">speak</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"喵喵喵"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"猫在吃饭"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> :</span><span class="keyword">public</span> Animal</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">speak</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"汪汪汪"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"狗在吃饭"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doEat</span><span class="params">(Animal&amp; animal)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">animal.eat();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doSpeak</span><span class="params">(Animal&amp; animal)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">animal.speak();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Cat cat;</span><br><span class="line">Dog dog;</span><br><span class="line">doSpeak(cat);</span><br><span class="line">doEat(cat);</span><br><span class="line">doSpeak(dog);</span><br><span class="line">doEat(dog);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果：<br><img src="/2019/07/31/多态/抽象基类和纯虚函数.PNG" alt="抽象基类和纯虚函数"></p><h4 id="多态成立的条件："><a href="#多态成立的条件：" class="headerlink" title="多态成立的条件："></a>多态成立的条件：</h4><ul><li>有继承</li><li>子类重写父类虚函数<ul><li>返回值、函数名、函数参数必须与父类完全一致</li><li>子类中virtual关键字可不写</li></ul></li><li>类型兼容，父类指针或父类引用指向子类对象</li></ul><h2 id="五、虚析构和纯虚析构函数"><a href="#五、虚析构和纯虚析构函数" class="headerlink" title="五、虚析构和纯虚析构函数"></a>五、虚析构和纯虚析构函数</h2><ol><li><h4 id="虚析构函数"><a href="#虚析构函数" class="headerlink" title="虚析构函数"></a>虚析构函数</h4><p>普通的析构函数不会调用子类的析构函数，这可能会导致释放不干净。可以利用虚析构来解决这个问题。</p><p>虚析构函数时为了解决基类的指针指向派生类对象，并用基类的指针删除派生类对象。</p></li></ol>   <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">People</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">People()</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"People的构造函数"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">showName</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"><span class="keyword">virtual</span> ~People()</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"People的虚析构函数"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Worker</span> :</span><span class="keyword">public</span> People</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Worker()</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Worker的构造函数"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">name = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">10</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">showName</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"打印子类的名字"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">~Worker()</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Worker的析构函数"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">if</span> (name != <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">delete</span> name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">char</span>* name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test03</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">People* people = <span class="keyword">new</span> Worker;</span><br><span class="line">people-&gt;~People();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>   执行结果:</p><p>   <img src="/2019/07/31/多态/虚析构函数.PNG" alt="虚析构函数"></p><ol><li><h4 id="纯虚析构函数"><a href="#纯虚析构函数" class="headerlink" title="纯虚析构函数"></a>纯虚析构函数</h4><p>纯虚析构函数在C++是合法的，但是在使用的时候有一个额外的限制：必须为纯虚析构函数提供一个函数体。</p><p>那么问题是：如果给虚析构函数提供了函数体，那怎么还能称为纯虚析构函数呢？<br>纯虚析构函数与非纯虚析构函数之间唯一的不同之处在于纯虚析构函数使得基类是抽象类，不能创建基类的对象。</p><p>纯虚析构函数需要声明和实现，在类内声明，类外实现。如果函数中出现了纯虚析构函数，那么这个类是抽象类，不可以实例化对象。</p></li></ol><h2 id="六、纯虚函数和多继承"><a href="#六、纯虚函数和多继承" class="headerlink" title="六、纯虚函数和多继承"></a>六、纯虚函数和多继承</h2><p>&emsp;&emsp;多继承带来了一些争议，但是接口继承可以说是一种毫无争议的运用。</p><p>&emsp;&emsp;绝大多数面向对象语言都不支持多继承，但是绝大多数面向对象语言都支持接口的概念，C++没有接口的概念，但是可以通过纯虚函数实现接口</p><blockquote><p>接口类中只有函数原型定义，没有任何数据定义</p></blockquote><p>&emsp;&emsp;多重继承接口不会带来二义性和复杂性问题。接口类知识一个功能声明，并不是功能实现，子类需要根据功能说明定义功能实现。</p><p>除了析构函数外，其他声明都是纯虚函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">speak</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"动物说话"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">virtual</span> ~Animal() = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Animal::~Animal()<span class="comment">//纯虚析构函数的实现</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Animal的纯虚析构函数调用"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span> :</span><span class="keyword">public</span> Animal</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Cat(<span class="keyword">const</span> <span class="built_in">string</span> name)</span><br><span class="line">&#123;</span><br><span class="line">m_Name = name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">speak</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"小猫"</span>&lt;&lt;m_Name&lt;&lt;<span class="string">"在说话"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">~Cat()</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Cat的析构函数调用"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="built_in">string</span> m_Name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test04</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//Animal animal;//抽象基类不可实例化</span></span><br><span class="line"><span class="built_in">string</span> name = <span class="string">"Mimi"</span>;</span><br><span class="line"><span class="function">Cat <span class="title">cat</span><span class="params">(name)</span></span>;</span><br><span class="line">cat.speak();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果：</p><p><img src="/2019/07/31/多态/纯虚析构函数.PNG" alt="纯虚析构函数"></p><h2 id="七、向上类型转换和向下类型转换"><a href="#七、向上类型转换和向下类型转换" class="headerlink" title="七、向上类型转换和向下类型转换"></a>七、向上类型转换和向下类型转换</h2><p>基类转派生类，即向下类型转换，是不安全的。</p><p>派生类转基类，即向上类型转换，是安全的。</p><p>如果发生了多态，就总是安全的。</p><h4 id="向下类型转换的可访问性："><a href="#向下类型转换的可访问性：" class="headerlink" title="向下类型转换的可访问性："></a>向下类型转换的可访问性：</h4><p>&emsp;&emsp;派生类向基类的转换是否可以访问由使用该转换的代码决定，同时，派生类的派生访问说明符也会有影响。假定D继承自B：</p><ul><li>只有当D公有继承B时，用户代码才能使用派生类向基类的转换；如果D继承B的方式是受保护的或者私有的，则用户代码不能使用该转换。</li><li>不论D以什么方式继承B，D的成员函数和友元都能使用派生类向基类的转换；派生类向其直接基类的转换对于派生类的成员和友元来说是永远可访问的。</li><li>如果D继承B的方式是公有的，或受保护的，则D的派生类成员可以使用D向B的类型转换，反之，如果D继承B对的方式是私有的，那么不能使用。</li></ul><h2 id="八、指向类成员的指针"><a href="#八、指向类成员的指针" class="headerlink" title="八、指向类成员的指针"></a>八、指向类成员的指针</h2><ol><li><h4 id="指向成员变量的指针"><a href="#指向成员变量的指针" class="headerlink" title="指向成员变量的指针"></a>指向成员变量的指针</h4><p>定义格式</p><blockquote><p><code>&lt;数据类型&gt;&lt;类名&gt;::*&lt;指针名&gt;</code></p><p>例如：<code>int A::*pPram;</code></p></blockquote><p>赋值/初始化</p><blockquote><p><code>&lt;数据类型&gt;&lt;类名&gt;::*&lt;指针名&gt;=&amp;&lt;类名&gt;::&lt;非静态数据成员&gt;</code></p><p>例如：<code>int A::*pParam=&amp;A::param</code></p></blockquote><p>解引用</p><blockquote><p><code>&lt;类对象名&gt;.*&lt;非静态数据成员指针&gt;</code></p><p><code>&lt;类对象指针&gt;-&gt;*&lt;非静态数据成员指针&gt;</code></p><p>例如：</p><p><code>A a;</code></p><p><code>a.*pParam;</code></p><p><code>a-&gt;*pParam</code></p></blockquote></li></ol>   <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">A(<span class="keyword">int</span> param)</span><br><span class="line">&#123;</span><br><span class="line">mParam = param;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> mParam;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test05</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">A <span class="title">a1</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">A* a2 = <span class="keyword">new</span> A(<span class="number">200</span>);</span><br><span class="line"><span class="keyword">int</span>* p1 = &amp;a1.mParam;</span><br><span class="line"><span class="keyword">int</span> A::* p2 = &amp;A::mParam;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"*p1:"</span> &lt;&lt; *p1 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"a1.p2:"</span> &lt;&lt; a1.*p2 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"a2-&gt;*p2:"</span> &lt;&lt; a2-&gt;*p2 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>   执行结果：</p><p>   <img src="/2019/07/31/多态/指向数据成员的指针.PNG" alt="指向成员变量的指针"></p><ol><li><h4 id="指向成员函数的指针"><a href="#指向成员函数的指针" class="headerlink" title="指向成员函数的指针"></a>指向成员函数的指针</h4><p>定义格式化</p><blockquote><p><code>&lt;返回类型&gt;(&lt;类名&gt;::*&lt;指针名&gt;)(&lt;参数列表&gt;)</code></p><p>例如：</p><p><code>void(A::*pFunc)(int,int);</code></p></blockquote><p>赋值/初始化</p><blockquote><p><code>&lt;返回类型&gt;(&lt;类名&gt;::*&lt;指针名&gt;)(&lt;参数列表&gt;)=&amp;&lt;类名&gt;::&lt;非静态数据函数&gt;</code></p><p>例如：</p><p><code>void(A::pFunc(int,int)=&amp;A::func;</code></p></blockquote><p>解引用</p><blockquote><p><code>(&lt;类对象名&gt;.*&lt;非静态成员函数&gt;)(&lt;参数列表&gt;)</code></p><p><code>(&lt;类对象指针&gt;-&gt;*&lt;非静态成员函数&gt;)(&lt;参数列表&gt;)</code></p><p>例如：</p><p><code>A a;</code></p><p><code>(a.*pFunc)(10,20);</code></p><p><code>(a-&gt;*pFunc)(10,20);</code></p></blockquote></li></ol>   <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">A()</span><br><span class="line">&#123;</span><br><span class="line">mParam = <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line">A(<span class="keyword">int</span> param)</span><br><span class="line">&#123;</span><br><span class="line">mParam = param;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> mParam;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test06</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">A a1;</span><br><span class="line">A* a2 = <span class="keyword">new</span> A;</span><br><span class="line"><span class="comment">//初始化成员函数指针</span></span><br><span class="line"><span class="keyword">int</span>(A:: * pFunc)(<span class="keyword">int</span>, <span class="keyword">int</span>) = &amp;A::func;</span><br><span class="line"><span class="comment">//指针解引用</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"(a1.*pFunc(10,20)="</span> &lt;&lt; (a1.*pFunc)(<span class="number">10</span>, <span class="number">20</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"(a2-&gt;*pFunc(10,20)="</span> &lt;&lt; (a2-&gt;*pFunc)(<span class="number">10</span>, <span class="number">20</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>   执行结果：</p><p>   <img src="/2019/07/31/多态/指向成员函数的指针.PNG" alt="指向成员函数的指针"></p><ol><li><h4 id="指向静态成员的指针"><a href="#指向静态成员的指针" class="headerlink" title="指向静态成员的指针"></a>指向静态成员的指针</h4><ul><li><p>指向静态数据成员的指针</p><p>指向静态数据成员的指针的定义和使用与普通指针相同，在定义时无须和类向关联，在使用时也无须和具体的对象相关联。</p></li><li><p>指向类静态成员函数的指针</p><p>指向静态成员函数的指针和普通指针相同，在定义时无须和类相关联，在使用时也无须和具体的对象相关联。</p></li></ul></li></ol><pre><code> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">A()</span><br><span class="line">&#123;</span><br><span class="line">mParam = <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line">A(<span class="keyword">int</span> param)</span><br><span class="line">&#123;</span><br><span class="line">mParam = param;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">dis</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; data &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> data;</span><br><span class="line"><span class="keyword">int</span> mParam;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> A::data = <span class="number">555</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test07</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span>* p = &amp;A::data;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; *p &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">void</span>(*pfunc)() = &amp;A::dis;</span><br><span class="line">pfunc();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre><p>   执行结果：</p><p>   <img src="/2019/07/31/多态/指向静态成员的指针.PNG" alt="指向静态成员的指针"></p><h2 id="九、源码地址"><a href="#九、源码地址" class="headerlink" title="九、源码地址"></a>九、源码地址</h2><p>​            <a href="https://github.com/Aoki-Wang/CheckStation/tree/master/C%2B%2B/Polymorphism" target="_blank" rel="noopener">多态源码示例</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、多态&quot;&gt;&lt;a href=&quot;#一、多态&quot; class=&quot;headerlink&quot; title=&quot;一、多态&quot;&gt;&lt;/a&gt;一、多态&lt;/h2&gt;&lt;p&gt;&amp;emsp;多态是面向对象程序设计语言中数据抽象和继承之外的第三个基本特征。&lt;/p&gt;
&lt;p&gt;&amp;emsp;多态性(Polymo
      
    
    </summary>
    
      <category term="C++" scheme="http://wanqbin.xyz/categories/C/"/>
    
    
      <category term="C++" scheme="http://wanqbin.xyz/tags/C/"/>
    
      <category term="多态" scheme="http://wanqbin.xyz/tags/%E5%A4%9A%E6%80%81/"/>
    
      <category term="虚函数" scheme="http://wanqbin.xyz/tags/%E8%99%9A%E5%87%BD%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>树的实现</title>
    <link href="http://wanqbin.xyz/2019/07/30/%E6%A0%91%E7%9A%84%E5%AE%9E%E7%8E%B0/"/>
    <id>http://wanqbin.xyz/2019/07/30/树的实现/</id>
    <published>2019-07-30T11:32:00.000Z</published>
    <updated>2019-07-30T11:38:14.753Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、树结点类"><a href="#一、树结点类" class="headerlink" title="一、树结点类"></a>一、树结点类</h2><p>&emsp;这里我们使用使用孩子兄弟结点表示法表示树的每个结点，每个结点包括三个域：数据域、第一个孩子结点指针域和下一个兄弟结点指针域。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;<span class="title">class</span> <span class="title">Tree</span>;</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;<span class="title">class</span> <span class="title">TreeNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">Tree</span>&lt;T&gt;;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">T data;<span class="comment">//数据域</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//构造函数</span></span><br><span class="line">TreeNode(T value, TreeNode&lt;T&gt;* fc = <span class="literal">nullptr</span>, TreeNode&lt;T&gt;* ns = <span class="literal">nullptr</span>)</span><br><span class="line">:data(value), firstChild(fc), nextSibling(ns) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//访问指针域的成员函数</span></span><br><span class="line">TreeNode&lt;T&gt;*&amp; FirstChild()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> firstChild;</span><br><span class="line">&#125;</span><br><span class="line">TreeNode&lt;T&gt;*&amp; NextSibling()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> nextSibling;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">TreeNode&lt;T&gt;* firstChild;<span class="comment">//第一个孩子结点指针域</span></span><br><span class="line">TreeNode&lt;T&gt;* nextSibling;<span class="comment">//下一个兄弟结点指针域</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="二、树类"><a href="#二、树类" class="headerlink" title="二、树类"></a>二、树类</h2><p>&emsp;树类的数据成员有根结点和当前结点指针。树类设计为树结点类的友元，树类成员函数可直接操作树结点内的私有数据成员，所以这里树类的成员函数是直接对树结点类的私有数据成员<code>firstChild</code>和<code>nextSibling</code>进行操作的。对于外部应用，可通过成员函数<code>FirstChild()</code>和<code>NextSilibing()</code>取得树结点类的私有数据成员<code>firstChild</code>和<code>nextSibling</code>的值和修改它们的值。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">"treeNode.h"</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; <span class="title">class</span> <span class="title">Tree</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Tree() &#123; root = current = <span class="literal">nullptr</span>; &#125;<span class="comment">//构造函数</span></span><br><span class="line">~Tree() &#123; DeleteSubTree(root); &#125;<span class="comment">//析构函数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//第一类操作的成员函数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Root</span><span class="params">()</span></span>;<span class="comment">//使根结点为当前结点</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Parent</span><span class="params">()</span></span>;<span class="comment">//使当前结点的双亲结点为当前结点</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">FirstChild</span><span class="params">()</span></span>;<span class="comment">//使当前结点的第一个孩子结点为当前结点</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">NextSilibing</span><span class="params">()</span></span>;<span class="comment">//使当前结点的兄弟结点为当前结点</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//第二类操作的成员函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Insert</span><span class="params">(T value)</span></span>;<span class="comment">//把value插入到当前结点的最后一个结点</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DeleteSubTree</span><span class="params">(TreeNode&lt;T&gt;*&amp; t)</span></span>;<span class="comment">//删除以t为根结点的子树</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DeleteChile</span><span class="params">(<span class="keyword">int</span> i)</span></span>;<span class="comment">//删除当前结点的第i个孩子结点</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//第三类操作的成员函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DisplayTree</span><span class="params">()</span></span>;<span class="comment">//按先根遍历次序显示树的数据域值</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">TreeNode&lt;T&gt;* root;<span class="comment">//根结点指针</span></span><br><span class="line">TreeNode&lt;T&gt;* current;<span class="comment">//当前结点指针</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//私有成员函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PreOrderTree</span><span class="params">(TreeNode&lt;T&gt;*&amp; t)</span></span>;<span class="comment">//显示以t为根节点的树的数据域，先根遍历</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PosOrderTree</span><span class="params">(TreeNode&lt;T&gt;*&amp; t)</span></span>;<span class="comment">//后根遍历</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Current</span><span class="params">(TreeNode&lt;T&gt;*&amp; t)</span></span>;<span class="comment">//使当前节点为t所指结点</span></span><br><span class="line"><span class="comment">//在树root中回溯查找结点s的双亲结点</span></span><br><span class="line">TreeNode&lt;T&gt;* SearchParent(TreeNode&lt;T&gt;*&amp; root, TreeNode&lt;T&gt;*&amp; s);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="三、树类成员函数的实现"><a href="#三、树类成员函数的实现" class="headerlink" title="三、树类成员函数的实现"></a>三、树类成员函数的实现</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">int</span> <span class="title">Tree</span>&lt;T&gt;:</span>:Root()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (root == <span class="literal">nullptr</span>)</span><br><span class="line">&#123;</span><br><span class="line">current = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> Current(root);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">int</span> <span class="title">Tree</span>&lt;T&gt;:</span>:Parent()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (root == <span class="literal">nullptr</span>)</span><br><span class="line">&#123;</span><br><span class="line">current = root;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">TreeNode&lt;T&gt;* p = SearchParent(root, current);</span><br><span class="line"><span class="keyword">if</span> (p == <span class="literal">nullptr</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> Current(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">int</span> <span class="title">Tree</span>&lt;T&gt;:</span>:FirstChild()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (current != <span class="literal">nullptr</span> &amp;&amp; current-&gt;firstChild != <span class="literal">nullptr</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> Current(current-&gt;firstChild);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">int</span> <span class="title">Tree</span>&lt;T&gt;:</span>:NextSilibing()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (current != <span class="literal">nullptr</span> &amp;&amp; current-&gt;nextSibling != <span class="literal">nullptr</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> Current(current-&gt;nextSibling);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> <span class="title">Tree</span>&lt;T&gt;:</span>:Insert(T value)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//把value插入到当前结点的最后一个结点</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">分为三种情况</span></span><br><span class="line"><span class="comment">1. 空树</span></span><br><span class="line"><span class="comment">2. 当前结点无孩子结点</span></span><br><span class="line"><span class="comment">3. 当前结点已有孩子结点</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">TreeNode&lt;T&gt;* newNode = <span class="keyword">new</span> TreeNode&lt;T&gt;(value);</span><br><span class="line"><span class="keyword">if</span> (root == <span class="literal">nullptr</span>)</span><br><span class="line">&#123;</span><br><span class="line">root = current = newNode;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (current-&gt;firstChild == <span class="literal">nullptr</span>)<span class="comment">//当前结点无孩子结点</span></span><br><span class="line">&#123;</span><br><span class="line">current-&gt;firstChild = newNode;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">TreeNode&lt;T&gt;* p = current-&gt;firstChild;</span><br><span class="line"><span class="keyword">while</span> (p-&gt;nextSibling != <span class="literal">nullptr</span>)</span><br><span class="line">&#123;</span><br><span class="line">p = p-&gt;nextSibling;</span><br><span class="line">&#125;</span><br><span class="line">p-&gt;nextSibling = newNode;</span><br><span class="line">&#125;</span><br><span class="line">Current(newNode);<span class="comment">//使当前结点为新节点</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> <span class="title">Tree</span>&lt;T&gt;:</span>:DeleteSubTree(TreeNode&lt;T&gt;*&amp; t)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (t == <span class="literal">nullptr</span>)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">TreeNode&lt;T&gt;* q = t-&gt;firstChild, * p;</span><br><span class="line"><span class="keyword">while</span> (q != <span class="literal">nullptr</span>)</span><br><span class="line">&#123;</span><br><span class="line">p = q-&gt;nextSibling;</span><br><span class="line">DeleteSubTree(q);</span><br><span class="line">q = p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">delete</span> t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> <span class="title">Tree</span>&lt;T&gt;:</span>:DeleteChile(<span class="keyword">int</span> i)</span><br><span class="line">&#123;</span><br><span class="line">TreeNode&lt;T&gt;* r = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="keyword">if</span> (i == <span class="number">1</span>)<span class="comment">//当删除当前结点的第一棵子树</span></span><br><span class="line">&#123;</span><br><span class="line">r = current-&gt;firstChild;</span><br><span class="line"><span class="keyword">if</span> (r == <span class="literal">nullptr</span>)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">current-&gt;firstChild = r-&gt;nextSibling;<span class="comment">//脱链要删除的子树</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> k = <span class="number">1</span>;</span><br><span class="line">TreeNode&lt;T&gt;* p = current-&gt;firstChild;</span><br><span class="line"><span class="keyword">while</span> (p != <span class="literal">nullptr</span> &amp;&amp; k &lt;= i - <span class="number">1</span>)</span><br><span class="line">&#123;<span class="comment">//寻找指向要删除子树的指针</span></span><br><span class="line">p = p-&gt;nextSibling;</span><br><span class="line">k++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (p != <span class="literal">nullptr</span>)</span><br><span class="line">&#123;</span><br><span class="line">r = p-&gt;nextSibling;</span><br><span class="line"><span class="keyword">if</span> (r != <span class="literal">nullptr</span>)</span><br><span class="line">&#123;</span><br><span class="line">p-&gt;nextSibling = r-&gt;nextSibling;<span class="comment">//脱链要删除的子树</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span>;<span class="comment">//要删除的子树为空时返回</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span>;<span class="comment">//查找失败</span></span><br><span class="line">&#125;</span><br><span class="line">DeleteSubTree(r);<span class="comment">//删除找到的要删除的子树</span></span><br><span class="line"><span class="keyword">return</span>;<span class="comment">//删除成功</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> <span class="title">Tree</span>&lt;T&gt;:</span>:DisplayTree()</span><br><span class="line">&#123;</span><br><span class="line">PreOrderTree(root);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> <span class="title">Tree</span>&lt;T&gt;:</span>:PreOrderTree(TreeNode&lt;T&gt;*&amp; t)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (t == <span class="literal">nullptr</span>)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; t-&gt;data &lt;&lt; <span class="string">" "</span>;<span class="comment">//显示根节点数据</span></span><br><span class="line"><span class="keyword">if</span> (t-&gt;firstChild != <span class="literal">nullptr</span>)</span><br><span class="line">PreOrderTree(t-&gt;firstChild);</span><br><span class="line"><span class="keyword">if</span> (t-&gt;nextSibling != <span class="literal">NULL</span>)</span><br><span class="line">PreOrderTree(t-&gt;nextSibling);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> <span class="title">Tree</span>&lt;T&gt;:</span>:PosOrderTree(TreeNode&lt;T&gt;*&amp; t)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (t == <span class="literal">nullptr</span>)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">if</span> (t-&gt;firstChild != <span class="literal">nullptr</span>)</span><br><span class="line">PosOrderTree(t-&gt;firstChild);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; t-&gt;data &lt;&lt; <span class="string">" "</span>;<span class="comment">//显示根节点</span></span><br><span class="line"><span class="keyword">if</span> (t-&gt;nextSibling != <span class="literal">nullptr</span>)</span><br><span class="line">PosOrderTree(t-&gt;nextSibling);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">int</span> <span class="title">Tree</span>&lt;T&gt;:</span>:Current(TreeNode&lt;T&gt;*&amp; t)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (t == <span class="literal">nullptr</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">current = t;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">TreeNode</span>&lt;T&gt;* <span class="title">Tree</span>&lt;T&gt;:</span>:SearchParent(TreeNode&lt;T&gt;*&amp; root, TreeNode&lt;T&gt;*&amp; s)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//在树root中回溯查找结点s的双亲结点</span></span><br><span class="line"><span class="comment">//查找到时使current指向s结点的双亲结点</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (current == <span class="literal">nullptr</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line"><span class="keyword">if</span> (root-&gt;firstChild == s || root-&gt;nextSibling == s)</span><br><span class="line"><span class="keyword">return</span> root;</span><br><span class="line">TreeNode&lt;T&gt;* p;</span><br><span class="line"><span class="keyword">if</span> ((p = SearchParent(root-&gt;firstChild, s)) != <span class="literal">nullptr</span>)</span><br><span class="line"><span class="keyword">return</span> p;</span><br><span class="line"><span class="keyword">if</span> ((p = SearchParent(root-&gt;nextSibling, s)) != <span class="literal">nullptr</span>)</span><br><span class="line"><span class="keyword">return</span> p;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>四、源码地址</p><p>​            <a href="https://github.com/Aoki-Wang/CheckStation/tree/master/Data%20Structure/tree" target="_blank" rel="noopener">树的实现源码</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、树结点类&quot;&gt;&lt;a href=&quot;#一、树结点类&quot; class=&quot;headerlink&quot; title=&quot;一、树结点类&quot;&gt;&lt;/a&gt;一、树结点类&lt;/h2&gt;&lt;p&gt;&amp;emsp;这里我们使用使用孩子兄弟结点表示法表示树的每个结点，每个结点包括三个域：数据域、第一个孩子结点指
      
    
    </summary>
    
      <category term="数据结构" scheme="http://wanqbin.xyz/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="数据结构" scheme="http://wanqbin.xyz/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="树的实现" scheme="http://wanqbin.xyz/tags/%E6%A0%91%E7%9A%84%E5%AE%9E%E7%8E%B0/"/>
    
      <category term="树" scheme="http://wanqbin.xyz/tags/%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>二叉树</title>
    <link href="http://wanqbin.xyz/2019/07/30/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <id>http://wanqbin.xyz/2019/07/30/二叉树/</id>
    <published>2019-07-30T11:09:00.000Z</published>
    <updated>2019-07-30T11:10:21.062Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、二叉树的定义"><a href="#一、二叉树的定义" class="headerlink" title="一、二叉树的定义"></a>一、二叉树的定义</h2><p>&emsp;二叉树（Binary Tree）是n（n&gt;=0)个有限结点构成的集合。n=0的树称为空二叉树；n&gt;0的二叉树由一个根节点和两个互不相交、分别称作左子树和右子树的子二叉树构成。</p><p>&emsp;二叉树是一种有序树。二叉树中某个结点即使只有一个子树，也要区分是左子树还是右子树。</p><p>&emsp;二叉树中所有结点的形态共有5种：空结点、无左右子树结点、只有左子树结点、只有右子树结点和左右子树均存在的结点。</p><p>&emsp;满二叉树。在一棵二叉树中，如果所有分支结点都存在左子树和右子树，并且所有叶子结点在同一层上，这样的二叉树称为<code>满二叉树</code>。</p><p>&emsp;完全二叉树。如果一棵具有n个结点的二叉树的结构与满二叉树的前n个结点的结构相同，这样的二叉树称为完全二叉树。</p><h2 id="二、二叉树的性质"><a href="#二、二叉树的性质" class="headerlink" title="二、二叉树的性质"></a>二、二叉树的性质</h2><ul><li>性质1：若规定根结点的层次为0，则一棵非空二叉树的第i层上最多有$2^i$(i&gt;=0)个结点。</li><li>性质2：若规定空树的深度为-1，则深度为k的二叉树的最大结点数是$2^{k+1}-1$(k&gt;=-1)个。</li><li>性质3：对于一棵非空的二叉树，如果叶节点的个数为$n_0$，度为2的结点数为$n_2$,则有$n_0=n_2+1$.</li><li>性质4：对于具有n个结点的完全二叉树，如果按照从上至下和从左至右的顺序对所有结点从0开始顺序编号，则对于任意的序号为i的结点，有：<ol><li>如果i&gt;0,则序号为i结点的双亲结点的序号为（i-1)/2，如果i=0，则序号为i的结点为根结点，无双亲结点。</li><li>如果2i+1<n，则序号为i结点的左孩子结点的序号为2i+1；如果2i+1>=n,则序号为i结点无左孩子。</n，则序号为i结点的左孩子结点的序号为2i+1；如果2i+1></li><li>如果2i+2<n,则序号为i结点的右孩子结点的序号为2i+2;如果2i+2>=n,则序号为i的结点无右孩子。</n,则序号为i结点的右孩子结点的序号为2i+2;如果2i+2></li></ol></li></ul><h2 id="三、二叉树的操作"><a href="#三、二叉树的操作" class="headerlink" title="三、二叉树的操作"></a>三、二叉树的操作</h2><p>&emsp;二叉树是由一个根结点和两个互不相交的、分别称为左子树和右子树的子二叉树构成。因此，二叉树的操作和树的操作多数及基本类同，只在子树操作上略有不同。</p><p>&emsp;二叉树的操作也分为三类：第一类，找满足某种特定关系的结点；第二类，插入或删除某个结点；第三类，遍历树中每个结点。</p><ol><li>第一类操作<ul><li>寻找根结点使之成为当前结点</li><li>寻找当前结点的双亲结点使之成为当前结点</li><li>寻找当前结点的左孩子结点使之成为当前结点</li><li>寻找当前结点的右孩子结点使之成为当前结点</li></ul></li><li>第二类操作<ul><li>在二叉树的当前结点上插入一个新结点，使新插入的节点称为当前结点的左孩子结点</li><li>在二叉树的当前结点上插入一个新结点，使新插入结点成为当前结点的右孩子结点</li><li>在二叉树的当前结点插入一个新子树，使新插入子树称为当前结点的左子树</li><li>在二叉树的当前结点插入一个新子树，使新插入子树称为当前结点的右子树</li><li>删除二叉树的当前结点的左孩子结点</li><li>删除二叉树的当前结点的右孩子结点</li><li>删除二叉树的当前结点的左子树</li><li>删除二叉树的当前结点的右子树</li></ul></li><li>第三类操作<ul><li>按某种方式遍历一棵二叉树显示二叉树中每个结点的数据域值</li><li>按某种方式遍历一棵二叉树寻找数据元素域为某一值的结点</li><li>先序遍历（DLR）递归算法<ul><li>访问根结点</li><li>前序遍历根结点的左子树</li><li>前序遍历根结点的右子树</li></ul></li><li>中序遍历（LDR）递归算法<ul><li>中序遍历根结点的左子树</li><li>访问根结点</li><li>中序遍历根结点的右子树</li></ul></li><li>后序遍历（LRD）递归算法<ul><li>后序遍历根结点的左子树</li><li>后序遍历根结点的右子树</li><li>访问根结点</li></ul></li><li>二叉树还有层序遍历。二叉树的层序遍历要求按照从根结点至叶结点、从左子树至右子树的次序访问二叉树的结点。二叉树的层序遍历算法为：<ul><li>初始化设置一个队列，并把根结点加入队列</li><li>当队列非空时，循环下面注明的步骤③到步骤⑤；否则到步骤⑥</li><li>出队列取得一个结点，访问该结点的（步骤③）</li><li>若该结点的左子树非空，则将该结点的左子树入队列</li><li>若该结点的右子树非空，则将该结点的右子树入队列（步骤⑤）</li><li>结束。</li></ul></li></ul></li></ol><h2 id="四、二叉树的存储结构"><a href="#四、二叉树的存储结构" class="headerlink" title="四、二叉树的存储结构"></a>四、二叉树的存储结构</h2><p>&emsp;二叉树的存储结构主要有三种：顺序存储结构、链式存储结构和仿真指针存储结构。</p><ol><li><p>二叉树的顺序存储结构</p><p>&emsp;对于一般的二叉树，如果按从上至下和从左至右的次序存储在一组从0开始的连续内存单元中，则数据下标之间的关系就不能反映二叉树中结点之间的逻辑关系。此时，可在一般二叉树中增添一些并不存在的空结点使之变成完全二叉树的形态，然后再用二叉树的顺序存储结构存储。</p><p>&emsp;完全二叉树使用顺序存储结构存储时，既能节省存储空间，又能使二叉树的操作实现简单。但对于一般二叉树，如果它接近于完全二叉树，需要增加的空结点数目不多时，可采用顺序存储结构存储。但如果需要增加许多空结点时，就不宜采用顺序存储结构存储。最坏的情况是右单只树，一棵深度为k的右单只树只有k个结点，却需分配$2^k$-1个存储单元。</p></li><li><p>二叉树的链式存储结构</p><p>&emsp;二叉树的链式存储结构方式用指针建立二叉树中结点之间的关系。二叉树最常用的链式存储结构是二叉链。二叉链存储结构的每个结点包含三个域：数据域data，左子树指针域<code>leftChild</code>和右子树指针域<code>rightChild</code>。</p><p>&emsp;二叉树的二叉链存储结构是一种常用的二叉树存储结构。二叉链存储结构的优点是：结构简单，可以方便地构造任意需要的二叉树，可以方便地实现二叉树操作中的大多数操作。二叉链仓促结构的缺点是查找当前结点的双亲结点操作实现起来比较麻烦。</p><p>&emsp;二叉树的另一种常用的存储结构是三叉链。三叉链式在二叉链的基础上再增加一个双亲结点指针域parent。三叉链除基于二叉链的优点外，对于查找当前结点的双亲结点操作实现起来也很容易。相对于二叉链，三叉链的缺点是结构更为复杂，因而每个结点占用的内存单元也更多一些。</p></li><li><p>二叉树的仿真指针存储结构</p><p>&emsp;二叉树的仿真指针存储结构是用数组存储二叉树中的结点，再增加仿真指针域仿真常规指针建立二叉树中结点之间的关系。二叉树的仿真指针存储结构有仿真二叉链存储结构和仿真三叉链存储结构。</p><p>&emsp;仿真指针存储结构的最大优点是遍历操作实现非常容易。用for循环或while循环就可实现。仿真指针存储结构的最大缺点是可存储的结点个数受初始化定义的数组元素个数限制。</p></li></ol><h2 id="五、树和二叉树的转换"><a href="#五、树和二叉树的转换" class="headerlink" title="五、树和二叉树的转换"></a>五、树和二叉树的转换</h2><ol><li>树转换为二叉树<ul><li>树中所有相同双亲结点的兄弟结点之间加一条连线</li><li>对树中不是双亲结点第一个孩子的结点，只保留它与左兄弟结点之间的连线，删去该结点与双亲结点之间的连线</li><li>整理所有保留的和添加的连线，使每个结点的孩子结点连线位于左孩子指针位置，使每个结点的右兄弟结点连线位于右孩子指针位置</li></ul></li><li>二叉树还原为树<ul><li>若某结点是其双亲结点的左孩子，则把该结点的右孩子、右孩子的右孩子……都与该结点的双亲结点用线连起来</li><li>删除原二叉树中所有双亲结点与右孩子结点的连线</li><li>整理所有保留的和添加的连线，使每个结点的孩子结点连线顺序位于下方孩子结点位置</li></ul></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、二叉树的定义&quot;&gt;&lt;a href=&quot;#一、二叉树的定义&quot; class=&quot;headerlink&quot; title=&quot;一、二叉树的定义&quot;&gt;&lt;/a&gt;一、二叉树的定义&lt;/h2&gt;&lt;p&gt;&amp;emsp;二叉树（Binary Tree）是n（n&amp;gt;=0)个有限结点构成的集合。n=
      
    
    </summary>
    
      <category term="数据结构" scheme="http://wanqbin.xyz/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="二叉树" scheme="http://wanqbin.xyz/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
      <category term="数据结构" scheme="http://wanqbin.xyz/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>树</title>
    <link href="http://wanqbin.xyz/2019/07/30/%E6%A0%91/"/>
    <id>http://wanqbin.xyz/2019/07/30/树/</id>
    <published>2019-07-30T10:24:00.000Z</published>
    <updated>2019-07-30T10:25:32.909Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、仿真指针"><a href="#一、仿真指针" class="headerlink" title="一、仿真指针"></a>一、仿真指针</h2><p>&emsp;在链式存储结构中，我们实现数据元素之间的次序关系依靠指针。在使用数据存储数据元素时，我们可在存储数据元素的数组中增加一个或几个数据下标域，这些数据下标域的值表示了该数组中某个数据元素的下标。由于在数据中增加的数据下标域仿真了链式存储结构中的指针域，所以这种存储结构也称为<code>仿真指针</code>。</p><p>&emsp;仿真指针也可英语存储如树和二叉树的非线性结构。当仿真指针用于存储树或二叉树时通常需要一个以上的仿真指针域。</p><h2 id="二、树的定义"><a href="#二、树的定义" class="headerlink" title="二、树的定义"></a>二、树的定义</h2><p>树是由n个有限节点构成的集合。n=0的树为空树，对于n&gt;0的树T有：  </p><ul><li>有一个特殊的节点称为根节点，根节点没有前趋节点  </li><li>当n&gt;1时，除根节点外其他节点被分成m（m&gt;0）个互不相交的集合T1,T2……,Tm。其中，每一个集合Ti本身又是一棵称为根节点的子树的树。  </li></ul><p>&emsp;&emsp;显然，树是递归定义的，即在树的定义中用到了树本身，因此，在包含树结构的算法中将会频繁地出现递归。  </p><h2 id="三、树的常用术语"><a href="#三、树的常用术语" class="headerlink" title="三、树的常用术语"></a>三、树的常用术语</h2><ul><li>结点。在树中通常把数据元素和构造数据元素之间的指针合起来称为结点。</li><li>结点的度。结点所拥有的子树的个数称为该结点的度。</li><li>叶结点。度为0的结点称为叶结点，叶结点也称为终端结点。</li><li>分支结点。度不为0的结点会称为分支结点，分支结点也称为非终端结点。显然，一棵树中除了叶结点外的所有节点都是分支结点。</li><li>孩子结点。树中一个结点的子树的根节点称为这个节点的孩子结点.</li><li>双亲结点。若树中某结点有孩子结点，则该结点就称为它的孩子结点的双亲结点。双亲结点也称为前趋结点。</li><li>兄弟结点。具有相同的双亲结点被称为兄弟结点。</li><li>祖先结点。从根结点到树中某结点经过的所有分支结点被称为该结点的祖先结点。一个树中根结点是该树中所有其他结点的祖先结点。</li><li>子孙结点。某一节点的所有孩子结点，以及这些孩子结点的孩子结点称为该结点的子孙结点。一个树中所有结点都是根结点的子孙结点。</li><li>树的度。树中所有结点的度的最大值称为该树的结点。</li><li>结点的层次。从根结点到树中某结点所经路径上的分支数称为该结点额层次。通常规定根结点的层次为0，这样其他结点的层次就是它的双亲结点的层次加1.</li><li>树的深度。树中所有结点的层次的最大值称为该树的深度。空树的深度规定为0.</li><li>无序树。树中任意一个结点的各个子树之间的次序构成无关紧要，即交换树中任意一个结点的各个子树的次序均和原树相同的树称为无序树。树均定义为无序树。</li><li>有序树。树中任意一个结点的各个子树都是有次序的树称为有序树。二叉树是一种有序树。</li><li>森林。m(m&gt;=0)棵树的集合称为森林。</li></ul><h2 id="四、树的基本操作"><a href="#四、树的基本操作" class="headerlink" title="四、树的基本操作"></a>四、树的基本操作</h2><p>&emsp;&emsp;由于树是非线性结构，节点之间的关系较线性结构复杂得多，所以树的操作也复杂得多。表示一棵树的数据成员一般来说不仅要有树的根节点指针（简称根指针），还应有树的当前操作节点指针（简称当前指针）。当前指针能保证当对树的某个节点操作后，下一次再要对其相邻节点（如该节点的双亲节点或该节点的第一个孩子节点）操作时不至于又从根节点开始查找起。<br>&emsp;&emsp;树的操作主要分为三大类：第一类，寻找满足某种特定关系的节点；第二类，插入或删除某个节点；第三类，遍历树中每个节点。  </p><ol><li>第一类操作。  </li></ol><ul><li>寻找根节点使之成为当前节点</li><li>寻找当前节点的双亲节点使之成为当前节点</li><li>寻找当前节点的第一个孩子节点使之后才能为当前节点</li><li>寻找当前节点的下一个兄弟节点使之成为当前节点<br>这一类操作时树的其他两类操作的基础操作，如插入操作就可设计成在当前节点插入一个新节点。 </li></ul><ol><li>第二类操作  </li></ol><ul><li>在树的当前节点上插入一个新节点，使新插入节点成为当前节点的第i个孩子节点</li><li>删除树的当前节点的第i个孩子节点</li><li>在树的当前节点上插入一个新子树，使新插入子树称为当前节点的第i棵子树</li><li>删除树的当前节点的第i棵子树  </li></ul><ol><li>第三类操作</li></ol><ul><li>按某种方式遍历一棵树显示树中每个节点的数据域值  </li><li>按某种方式遍历一棵树寻找数据元素域为某一值的节点  </li></ul><p>&emsp;&emsp;树的遍历操作是指按照某种方式访问树中的每一个节点且每一个节点只被访问一次。对于线性结构，通过for循环或while循环就可访问其中的每一个数据元素且每一个数据元素只被访问一次。但是对于树这种非线性数据结构，for循环和while循环就无法访问树中的每一个节点且每一个节点只被访问一次。树的遍历操作算法主要有先根遍历和后根遍历两种。下面的先根遍历和后根遍历算法都是递归的。  </p><ol><li>先根遍历。先根遍历算法为：  </li></ol><ul><li>访问根节点</li><li>按照从左到右的次序先根遍历根节点的每一棵子树</li></ul><ol><li>后根遍历。后根遍历算法为：</li></ol><ul><li>按照从左导游的次序后根遍历根节点的每一棵子树</li><li>访问根节点  </li></ul><p>&emsp;&emsp;此外，树的遍历算法还有层序遍历。树的层序遍历是要求按照从根节点至叶节点、从第一棵子树到最后一棵子树的次序访问树的节点。  </p><h2 id="五、树的存储结构"><a href="#五、树的存储结构" class="headerlink" title="五、树的存储结构"></a>五、树的存储结构</h2><p>计算机中树的存储要求既要存储节点的数据元素，又要存储节点之间的逻辑关系。构造节点之间的逻辑关系的方法可用指针或仿真指针。</p><p>1.双亲表示法</p><p>&emsp;&emsp;双亲表示法是用仿真指针结构存储树。具体方法是用一组连续的存储单元（数组）存储树中的所有节点，每个节点有两个域，一个域是数据域，一个域是指示其双亲节点在数组中下标序号的仿真指针域。<br>&emsp;&emsp;双亲表示法的仿真指针也可以改为常规的指针域。双亲表示法对于实现前述的树的基本操作中寻找双亲节点和寻找根节点使它们各自成为当前节点操作很方便，但是对于实现寻找第一个孩子节点和循环下一个兄弟节点使它们各自成为当前节点却很不方便。  </p><p>2.孩子表示法</p><p>&emsp;&emsp;由于树中每个节点的子树个数（即节点的度）不同，如果按照各个节点的度设计变长结构，则每个节点的孩子节点指针域个数增加使算法实现非常麻烦。孩子表示法可按树的度（即树中所有节点度的最大值）设计节点的孩子节点指针域的个数。同样，节点的孩子节点指针域可以是仿真指针，也可以是常规指针。  </p><p>3.双亲孩子表示法  </p><p>&emsp;&emsp;树的存储结构若把双亲表示法和孩子表示法结合起来可使之兼有这两种存储结构的优点。可有许多种结合双亲表示法和孩子表示法的存储结构方法。一种双亲孩子表示法是在仿真指针双亲表示法的基础上，给数组得到每个节点增加一个指向该节点所有孩子节点链表的常规指针。   </p><p>4.孩子兄弟表示法  </p><p>&emsp;&emsp;孩子兄弟表示法是为每个节点设计三个域，一个数据元素域，一个该节点的第一个孩子指针域，一个该节点的下一个兄弟节点指针域。此种孩子兄弟表示法的两个域通常都是常规指针。<br>&emsp;&emsp;由于树的孩子兄弟表示法有两个指针域，并且这两个指针是有序的，所以孩子兄弟表示法是将树转换为二叉树的存储结构。把二叉树转换为二叉树所对应的结构恰好就是这种孩子兄弟表示法结构，所以，孩子兄弟表示法的最大优点是可方便地实现树和二叉树的相互转换。但是，孩子兄弟表示法的缺点也和孩子表示法的缺点一样，就是从当前节点查找双亲节点比较麻烦，需要从树的根节点开始逐个查找。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、仿真指针&quot;&gt;&lt;a href=&quot;#一、仿真指针&quot; class=&quot;headerlink&quot; title=&quot;一、仿真指针&quot;&gt;&lt;/a&gt;一、仿真指针&lt;/h2&gt;&lt;p&gt;&amp;emsp;在链式存储结构中，我们实现数据元素之间的次序关系依靠指针。在使用数据存储数据元素时，我们可在存储
      
    
    </summary>
    
      <category term="数据结构" scheme="http://wanqbin.xyz/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="数据结构" scheme="http://wanqbin.xyz/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="树" scheme="http://wanqbin.xyz/tags/%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>继承</title>
    <link href="http://wanqbin.xyz/2019/07/30/%E7%BB%A7%E6%89%BF/"/>
    <id>http://wanqbin.xyz/2019/07/30/继承/</id>
    <published>2019-07-30T03:16:00.000Z</published>
    <updated>2019-07-30T10:22:44.536Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、继承"><a href="#一、继承" class="headerlink" title="一、继承"></a>一、继承</h2><p>&emsp;<code>继承</code>是面向对象编程额基本概念之一。继承使我们能在已有类的基础上构造新类。这个新的类拥有或继承已有类的数据成员和成员函数，也可添加新的数据成员和成员函数，对已有的类进行扩充。这个已有的类就称为<code>基类</code>,而这个新类则称为<code>派生类</code>。</p><p>&emsp;如果我们需要定义一个个人类和职工类，在不使用继承的情况下，代码重复会比较严重。这时，我们就需要用到继承。</p><p>&emsp;下面定义一个基类网页，重复的代码都写到这个网页上。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//基类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BasePage</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">header</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"公共头部"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">footer</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"公共底部"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">left</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"公共左侧列表"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">News</span> :</span><span class="keyword">public</span> BasePage<span class="comment">//继承BasePage</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">content</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"今日新闻"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>主函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">News news;</span><br><span class="line">news.header();</span><br><span class="line">news.left();</span><br><span class="line">news.footer();</span><br><span class="line">news.content();</span><br><span class="line">system(<span class="string">"pause"</span>);</span><br><span class="line"><span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果：</p><p><img src="/2019/07/30/继承/test1.PNG" alt="执行结果"></p><p>继承可以减少代码的重复部分，派生类可以继承基类的数据成员和成员函数。</p><p>网页中有很多公共部分，导致实现的时候由很多重复的代码。在使用继承之后，基类为公共网页，具体的子类实现把不同的内容，较好地解决了代码的复用。</p><h2 id="二、继承方式"><a href="#二、继承方式" class="headerlink" title="二、继承方式"></a>二、继承方式</h2><p>继承方式主要有：</p><ul><li><code>public</code>：公有继承</li><li><code>private</code>：私有继承</li><li><code>protected</code>：保护继承</li></ul><ol><li>不管是公有继承、保护继承还是私有继承，基类中的私有属性，都不可以继承下去</li><li>在公有继承中，父类的protected属性在子类中是protected属性。父类中的public属性在子类中是public属性</li><li>在保护继承中，父类中的protected属性，在子类中是protected属性。父类中的public属性在子类中是protected属性</li><li>在私有继承中，父类中的protected属性在子类中是private属性。父类中的public属性在子类中是private属性。</li></ol><h2 id="三、继承中的构造和析构顺序"><a href="#三、继承中的构造和析构顺序" class="headerlink" title="三、继承中的构造和析构顺序"></a>三、继承中的构造和析构顺序</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Base()</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Base默认构造函数调用"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">~Base()</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Base析构函数调用"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span>:</span><span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Son()</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Son默认构造函数调用"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">~Son()</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Son析构函数调用"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//子类会继承父类的成员属性，成员函数</span></span><br><span class="line"><span class="comment">//但是子类不会继承父类的构造函数和析构函数</span></span><br><span class="line"><span class="comment">//只有父类自己知道如何构造和析构自己的属性，而子类不知道</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Base base;</span><br><span class="line">Son son;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果：<br><img src="/2019/07/30/继承/test2.PNG" alt="执行"></p><ul><li>子类在创建对象时，先调用父类的构造函数，然后再调用自身的构造函数</li><li>析构顺序与构造顺序相反</li><li>子类不会继承父类的构造函数和析构函数</li><li>如果父类中没有合适默认构造，那么子类可以利用初始化列表方式显式地调用父类的其他构造函数。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Base()</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Base默认构造函数调用"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">~Base()</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Base析构函数调用"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">Base(<span class="keyword">int</span> a)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"有参构造函数调用,参数为："</span> &lt;&lt; a &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span>:</span><span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Son()</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Son默认构造函数调用"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">Son(<span class="keyword">int</span> a) :Base(a)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Son初始化列表调用父类带参构造"</span> &lt;&lt; a &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">~Son()</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Son析构函数调用"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//子类会继承父类的成员属性，成员函数</span></span><br><span class="line"><span class="comment">//但是子类不会继承父类的构造函数和析构函数</span></span><br><span class="line"><span class="comment">//只有父类自己知道如何构造和析构自己的属性，而子类不知道</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Base base;</span><br><span class="line">Son son;</span><br><span class="line"><span class="function">Son <span class="title">son2</span><span class="params">(<span class="number">15</span>)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果：</p><p><img src="/2019/07/30/继承/test21.PNG" alt="执行结果"></p><h2 id="四、继承中同名函数的处理"><a href="#四、继承中同名函数的处理" class="headerlink" title="四、继承中同名函数的处理"></a>四、继承中同名函数的处理</h2><ol><li>如果子类和父类拥有同名的函数、属性，子类不会覆盖父类的成员</li><li>如果子类与父类的成员函数名称相同，子类会把父类的所有同名版本都隐藏掉</li><li>如果想调用父类的方法，必须加作用域</li><li>成员属性直接调用是子类的，如果想调用父类的成员属性，需要加作用域</li><li>成员函数直接调用先调用子类的，父类的所有版本都会被隐藏，除非显式地用作用域运算符去调用。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base0</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Base0()</span><br><span class="line">&#123;</span><br><span class="line">m_A = <span class="number">100</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> m_A;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son0</span>:</span><span class="keyword">public</span> Base0</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Son0()</span><br><span class="line">&#123;</span><br><span class="line">m_A = <span class="number">20</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> m_A;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test03</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Son0 s1;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"子类中的属性："</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; s1.m_A &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"父类中的属性："</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; s1.Base0::m_A &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果：</p><p><img src="/2019/07/30/继承/test03.PNG" alt="执行结果"></p><h2 id="五、继承中的静态成员处理"><a href="#五、继承中的静态成员处理" class="headerlink" title="五、继承中的静态成员处理"></a>五、继承中的静态成员处理</h2><ul><li>如果基类定义了一个静态成员，则在整个继承体系中只存在该成员的唯一定义。不论从基类中派生出多少个派生类，对于每个静态成员来说都只存在唯一的实例。</li><li>静态成员遵循通用的访问控制规则，如果基类中的成员是private的，则派生类无权访问它。假设某静态成员是可访问的，则我们既能通过基类使用它，也可以通过派生类使用它。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Father</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> m_A;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Father func()"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">int</span> Father::m_A = <span class="number">200</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son1</span> :</span><span class="keyword">public</span> Father</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> A;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Son func()"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test04</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Father的静态成员值为："</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; Father::m_A &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Son1继承的静态成员值为："</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; Son1::m_A &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">Son1::func();</span><br><span class="line">Father::func();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果：</p><p><img src="/2019/07/30/继承/test04.PNG" alt="执行结果"></p><h2 id="六、防止继承的发生"><a href="#六、防止继承的发生" class="headerlink" title="六、防止继承的发生"></a>六、防止继承的发生</h2><p>有时候我们会定义这样一种类，我们不希望其他类继承它，或者不想考虑它是否合适作为一个基类。为了实现这个目的，C++11新标准提供了一种防止继承发生的方法，即在类后跟一个关键字<code>final</code>。</p><p><img src="/2019/07/30/继承/test05.PNG" alt="final关键字"></p><h2 id="七、菱形继承（钻石继承）的问题"><a href="#七、菱形继承（钻石继承）的问题" class="headerlink" title="七、菱形继承（钻石继承）的问题"></a>七、菱形继承（钻石继承）的问题</h2><p>&emsp;两个派生类继承同一个基类，而又有某个类同时继承了两个派生类，这种继承被称为菱形继承，或者钻石继承。</p><p>这种继承带来的问题：</p><ul><li>羊继承了动物的数据和函数，驼继承了动物的数据和函数，羊驼同时继承了羊和驼的数据和函数。当羊驼调用函数或者数据时，就会产生二义性。</li><li>羊驼继承自动物的函数和数据继承了两份，其实我们应该清楚，这份数据我们只需要一份就可以了。</li></ul><p>解决办法：</p><ul><li>采用虚继承的方式来解决。通过虚继承的方式，可以保证羊驼类中只有一份动物类的属性和函数的赋值，因此可以避免菱形继承的二义性，也就解决了“钻石继承”的问题。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//动物类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">int</span> m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//羊类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sheep</span> :</span><span class="keyword">virtual</span> <span class="keyword">public</span> Animal</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//驼类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tuo</span> :</span><span class="keyword">virtual</span> <span class="keyword">public</span> Animal</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//羊驼类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SheepTuo</span> :</span><span class="keyword">public</span> Tuo, <span class="keyword">public</span> Sheep</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test06</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">SheepTuo st;</span><br><span class="line">st.Sheep::m_Age = <span class="number">10</span>;</span><br><span class="line">st.Tuo::m_Age = <span class="number">20</span>;</span><br><span class="line">st.m_Age = <span class="number">5</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"驼的年龄为"</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; st.Tuo::m_Age &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"羊的年龄为："</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; st.Sheep::m_Age &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"羊驼的年龄为："</span>;</span><br><span class="line"><span class="comment">//可以直接访问，没有二义性的可能，只有一份数据</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; st.m_Age &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果：</p><p><img src="/2019/07/30/继承/test06.PNG" alt="执行结果"></p><h2 id="八、源码地址"><a href="#八、源码地址" class="headerlink" title="八、源码地址"></a>八、源码地址</h2><p>​        <a href="https://github.com/Aoki-Wang/CheckStation/tree/master/C%2B%2B/Inheritance" target="_blank" rel="noopener">继承源码示例</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、继承&quot;&gt;&lt;a href=&quot;#一、继承&quot; class=&quot;headerlink&quot; title=&quot;一、继承&quot;&gt;&lt;/a&gt;一、继承&lt;/h2&gt;&lt;p&gt;&amp;emsp;&lt;code&gt;继承&lt;/code&gt;是面向对象编程额基本概念之一。继承使我们能在已有类的基础上构造新类。这个新的类拥有
      
    
    </summary>
    
      <category term="C++" scheme="http://wanqbin.xyz/categories/C/"/>
    
    
      <category term="C++" scheme="http://wanqbin.xyz/tags/C/"/>
    
      <category term="继承" scheme="http://wanqbin.xyz/tags/%E7%BB%A7%E6%89%BF/"/>
    
  </entry>
  
  <entry>
    <title>stack和queue</title>
    <link href="http://wanqbin.xyz/2019/07/29/stack%E5%92%8Cqueue/"/>
    <id>http://wanqbin.xyz/2019/07/29/stack和queue/</id>
    <published>2019-07-29T00:07:00.000Z</published>
    <updated>2019-07-30T02:49:45.692Z</updated>
    
    <content type="html"><![CDATA[<h2>  <center>stack</center>  </h2><p>一、stack概述</p><p>&emsp;stack是一种先进后出（First In Last Out，FILO)的数据结构，它只有一个出口。stack允许新增元素、移除元素、取得最顶端元素。但是除了最顶端外，没有任何其他方法可以存取其他元素，换言之，stack不允许有遍历行为。</p><p>二、stack没有迭代器</p><p>&emsp;stack所有元素的进出都必须符合“先进后出”的条件，只有stack顶端的元素才有机会被外界取用。stack不提供遍历功能，也不提供迭代器。</p><p>三、stack常用API</p><ul><li>栈顶top</li><li>压栈push</li><li>栈顶弹出pop</li><li>大小 size</li><li>是否empty</li></ul><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">stest</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt;istack;</span><br><span class="line"><span class="keyword">if</span> (istack.empty())</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"stack为空!"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"stack的大小为："</span> &lt;&lt; istack.size() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">istack.push(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"stack的大小为："</span> &lt;&lt; istack.size() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"stack的栈顶元素为："</span> &lt;&lt; istack.top() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"弹出栈顶元素后:"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">istack.pop();</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"stack的大小为："</span> &lt;&lt; istack.size() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"stack的栈顶元素为："</span> &lt;&lt; istack.top() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><p><img src="/2019/07/29/stack和queue/stest.PNG" alt="stack常用API"></p><h2><center>queue</center></h2><p>一、queue概述</p><p>&emsp;queue是一种先进先出（First In First Out，FIFO）的数据结构。它有两个出口。queue允许新增元素、移除元素、从最低端加入元素、取得最顶端元素。但除了最底端可以加入、最顶端可以取出外，没有任何办法可以存取queue的其他元素。换言之，queue不允许有遍历行为。</p><p>二、queue没有迭代器</p><p>&emsp;queue所有元素的进出都必须符合“先进先出“的条件，只有queue顶端的元素，才有机会被外界取用。queue不提供遍历功能，也不提供迭代器。</p><p>三、queue常用API</p><ul><li>先进先出</li><li>队头front 队尾back</li><li>入队 push</li><li>弹出队头 pop</li><li>大小 size</li><li>为空 empty</li></ul><p>示例:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">qtest</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt;iqueue;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">iqueue.push(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"队头为："</span> &lt;&lt; iqueue.front() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"队尾为："</span> &lt;&lt; iqueue.back() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"iqueue的大小为："</span> &lt;&lt; iqueue.size() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">iqueue.pop();</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"弹出队头后："</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"队头为："</span> &lt;&lt; iqueue.front() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"队尾为："</span> &lt;&lt; iqueue.back() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"iqueue的大小为："</span> &lt;&lt; iqueue.size() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><p><img src="/2019/07/29/stack和queue/qtest.PNG" alt="queue常用API"></p><p>四、源码地址</p><p>​        <a href="https://github.com/Aoki-Wang/CheckStation/tree/master/STL/stack%20and%20queue" target="_blank" rel="noopener">stack and queue示例源码</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2&gt;
  &lt;center&gt;stack&lt;/center&gt;  
&lt;/h2&gt;

&lt;p&gt;一、stack概述&lt;/p&gt;
&lt;p&gt;&amp;emsp;stack是一种先进后出（First In Last Out，FILO)的数据结构，它只有一个出口。stack允许新增元素、移除元素、取得最顶端元素。
      
    
    </summary>
    
      <category term="STL" scheme="http://wanqbin.xyz/categories/STL/"/>
    
    
      <category term="STL" scheme="http://wanqbin.xyz/tags/STL/"/>
    
      <category term="stack" scheme="http://wanqbin.xyz/tags/stack/"/>
    
  </entry>
  
  <entry>
    <title>deque容器</title>
    <link href="http://wanqbin.xyz/2019/07/29/deque%E5%AE%B9%E5%99%A8/"/>
    <id>http://wanqbin.xyz/2019/07/29/deque容器/</id>
    <published>2019-07-28T16:25:00.000Z</published>
    <updated>2019-07-30T02:50:16.737Z</updated>
    
    <content type="html"><![CDATA[<p>一、deque概述</p><p>&emsp;<code>vector</code>是单向开口的连续线性空间，<code>deque</code>则是一种双向开口的连续线性空间。所谓双向开口，意思是可以在头尾两端分别做元素的插入和删除操作。虽然vector容器也可以在头尾两端插入元素，但是在其头部操作效率奇差，无法被接受。</p><p>&emsp;deque容器和vector容器最大的差异在于：</p><ol><li>deque允许使用常数项时间对头端进行元素的插入和删除</li><li>deque没有容量的概念，因为它是动态的以分段连续空间组成的，随时可以增加一段新的空间并链接起来，换句话说，像vector那样“旧空间不足而重新配置一块更大的空间，然后复制元素，再释放旧空间”这样的事情不会在deque发生，也因此，deque没有必要提供所谓的空间保留功能。</li><li>虽然deque容器也提供<code>Random Access Iterator</code>，但是它的迭代器并不是普通指针，其复杂度和vector不是一个量级，这当然影响各个运算的层面，除非必要，我们应该尽可能选择vector而不是deque，对deque进行的排序操作，为了最高效率，可将deque先完整复制到一个vector中，将vector排序后，再复制回deque。</li></ol><p>二、deque容器的中控器</p><p>&emsp;deque是由一段一段定量连续空间构成。一旦有必要在deque的前端或尾端增加新空间，便配置一段定量连续空间，串接在整个deque的头端或尾端，deque的最大任务，便是在这些分段的定量连续空间上，维护其整体连续的假象，并提供随机存取的接口，避开了“重新配置、复制、释放”的轮回，代价则是复杂的迭代器架构。</p><p>&emsp;deque为分段连续空间，就必须有中央控制，而为了维持整体连续的假象，数据结构的设计及迭代器前进后退等操作都颇为繁琐。deque的实现代码分量远比vector或list都多得多。</p><p>&emsp;采用一块所谓的<code>map</code>（不是STL的map）作为主控。这里所谓的<code>map</code>是一小块连续空间，其中每个元素都是指针，指向另一段（较大的）连续线性空间，称为<code>缓冲区</code>。缓冲区才是deque存储空间主体。</p><p>三、deque迭代器</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">T* cur;<span class="comment">//此迭代器指向缓冲区中当前的元素</span></span><br><span class="line">T* first;<span class="comment">//此迭代器指向缓冲区的头</span></span><br><span class="line">T* last;<span class="comment">//此迭代器指向缓冲区的尾</span></span><br><span class="line">map_pointer node;<span class="comment">//指向中控器中心</span></span><br></pre></td></tr></table></figure><p>四、deque常用API</p><p>1.deque构造函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">deque</span>&lt;T&gt; deqT;<span class="comment">//默认构造形式</span></span><br><span class="line"><span class="built_in">deque</span>(beg,end);<span class="comment">//构造函数将[beg,end)区间中的元素拷贝给本身</span></span><br><span class="line"><span class="built_in">deque</span>(n,elem);<span class="comment">//构造函数将n个elem拷贝给本身</span></span><br><span class="line"><span class="built_in">deque</span>(<span class="keyword">const</span> <span class="built_in">deque</span> &amp;deq);<span class="comment">//拷贝构造函数</span></span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt;deq1(<span class="number">5</span>,<span class="number">10</span>);<span class="comment">//构造deq1</span></span><br><span class="line"><span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt;deq2(deq1);<span class="comment">//拷贝构造deq2</span></span><br><span class="line">displayDeque(deq1);<span class="comment">//打印deq1</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">displayDeque(deq2);</span><br><span class="line"><span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt;deq3(deq2.begin(), deq2.begin() + <span class="number">3</span>);<span class="comment">//区间拷贝方式构造deq3</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">displayDeque(deq3);</span><br></pre></td></tr></table></figure><p>输出结果：</p><p><img src="/2019/07/29/deque容器/test01.PNG" alt="构造函数示例"></p><p>2.deque赋值操作</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">assign(beg,end);<span class="comment">//将[beg,end)区间中的数据拷贝给本身</span></span><br><span class="line">assign(n,elem);<span class="comment">//将n个elem拷贝赋值给本身</span></span><br><span class="line"><span class="built_in">deque</span>&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> <span class="built_in">deque</span> &amp;deq);<span class="comment">//重载等号操作符</span></span><br><span class="line">swap(deq);<span class="comment">//将deq与本身的元素互换</span></span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt;deq1(<span class="number">5</span>, <span class="number">10</span>);<span class="comment">//构造deq1</span></span><br><span class="line"><span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt;deq2(<span class="number">10</span>, <span class="number">15</span>);</span><br><span class="line">deq1.assign(deq2.begin(), deq2.begin() + <span class="number">3</span>);<span class="comment">//将deq2下标为0,1,2的数据拷贝给deq1</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"deq1:"</span>;</span><br><span class="line">displayDeque(deq1);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">deq1.assign(<span class="number">4</span>, <span class="number">4</span>);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"deq1:"</span>;</span><br><span class="line">displayDeque(deq1);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"deq2:"</span>;</span><br><span class="line">displayDeque(deq2);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">deq1.swap(deq2);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"deq1和deq2的数据交换后："</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"deq1:"</span>;</span><br><span class="line">displayDeque(deq1);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"deq2:"</span>;</span><br><span class="line">displayDeque(deq2);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><p><img src="/2019/07/29/deque容器/test02.PNG" alt="赋值操作示例"></p><p>3.deque大小操作</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">deque</span>.size();<span class="comment">//返回容器中元素的个数</span></span><br><span class="line"><span class="built_in">deque</span>.empty();<span class="comment">//判断容器是否为空</span></span><br><span class="line"><span class="built_in">deque</span>.resize(num);<span class="comment">//重新指定容器的长度为num，若容器变长，则以默认值填充新位置。如果容器变短，则末尾超出容器长度的元素被删除</span></span><br><span class="line"><span class="built_in">deque</span>.resize(num,elem);<span class="comment">//重新指定容器的长度为num，若容器变长，则以elem值填充新位置，如果容器变短，则末尾超出容器长度的元素被删除</span></span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test03</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt;deq1(<span class="number">5</span>, <span class="number">10</span>);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"deq1的长度为："</span> &lt;&lt; deq1.size() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">if</span> (deq1.empty())</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"deq1为空!"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"deq1非空!长度为："</span> &lt;&lt; deq1.size() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">displayDeque(deq1);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">deq1.resize(<span class="number">10</span>);<span class="comment">//重新指定deq的长度为10,</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"指定deq1的长度为10时，其元素为："</span>;</span><br><span class="line">displayDeque(deq1);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">deq1.resize(<span class="number">15</span>, <span class="number">100</span>);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"指定deq1的长度为15时，其元素为："</span>;</span><br><span class="line">displayDeque(deq1);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">deq1.resize(<span class="number">3</span>,<span class="number">100</span>);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"指定deq1的长度为3时，其元素为："</span>;</span><br><span class="line">displayDeque(deq1);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：<br><img src="/2019/07/29/deque容器/test03.PNG" alt="大小操作示例"></p><p>4.deque双端插入和删除操作</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">push_back(elem);<span class="comment">//在容器尾部添加一个数据</span></span><br><span class="line">push_front(elem);<span class="comment">//在容器头部插入一个数据</span></span><br><span class="line">pop_back();<span class="comment">//删除容器最后一个数据</span></span><br><span class="line">pop_front();<span class="comment">//删除容器第一个数据</span></span><br></pre></td></tr></table></figure><p>示例:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test04</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt;deq1(<span class="number">5</span>, <span class="number">5</span>);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"deq1："</span>;</span><br><span class="line">displayDeque(deq1);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">deq1.push_back(<span class="number">100</span>);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"deq1.push_back(100)后为："</span>;</span><br><span class="line">displayDeque(deq1);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">deq1.push_front(<span class="number">15</span>);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"deq1.push_front(15)后为："</span>;</span><br><span class="line">displayDeque(deq1);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">deq1.pop_back();</span><br><span class="line">deq1.pop_front();</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"deque删头去尾后为："</span>;</span><br><span class="line">displayDeque(deq1);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><p><img src="/2019/07/29/deque容器/test04.PNG" alt="双端插入删除操作示例"></p><p>5.deque数据存取</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">at(index);<span class="comment">//返回索引index所指的数据，如果index越界，抛出out_of_range</span></span><br><span class="line"><span class="keyword">operator</span>[];<span class="comment">//返回索引index所指向的数据，如果index越界，不抛出异常，直接出错</span></span><br><span class="line">front();<span class="comment">//返回第一个数据</span></span><br><span class="line">back();<span class="comment">//返回最后一个数据</span></span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test05</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; deq1(<span class="number">5</span>, <span class="number">15</span>);</span><br><span class="line"><span class="comment">//cout &lt;&lt; "索引为5的元素为：" &lt;&lt; deq1.at(5) &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">//上面的输出语句报错，抛出out_of_range</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"索引为3的元素为："</span> &lt;&lt; deq1.at(<span class="number">3</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">deq1.push_front(<span class="number">44</span>);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"索引为0的元素为："</span> &lt;&lt; deq1.at(<span class="number">0</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="comment">//cout &lt;&lt; deq1[15] &lt;&lt; endl;//越界报错</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"索引为3的元素为："</span> &lt;&lt; deq1[<span class="number">3</span>] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"索引为0的元素为："</span> &lt;&lt; deq1[<span class="number">0</span>] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"deq的首元素为："</span> &lt;&lt; deq1.front() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"deq的尾元素为："</span> &lt;&lt; deq1.back() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><p><img src="/2019/07/29/deque容器/test05.PNG" alt="数据存取操作示例"></p><p>6.deque插入操作</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">insert(pos,elem);<span class="comment">//在pos位置插入一个elem元素的拷贝，返回新数据的位置</span></span><br><span class="line">insert(pos,n,elem);<span class="comment">//在pos位置插入n个elem数据，无返回值</span></span><br><span class="line">insert(pos,beg,end);<span class="comment">//在pos位置插入[beg,end)区间的数据，无返回值</span></span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test06</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; deq1(<span class="number">5</span>, <span class="number">15</span>); </span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"deq1:"</span>;</span><br><span class="line">displayDeque(deq1);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">deq1.insert(deq1.begin() + <span class="number">3</span>, <span class="number">18</span>);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"deq1:"</span>;</span><br><span class="line">displayDeque(deq1);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">deq1.insert(deq1.begin(),<span class="number">2</span>,<span class="number">20</span>);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"deq1:"</span>;</span><br><span class="line">displayDeque(deq1);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">deq1.erase(deq1.begin());</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"deq1:"</span>;</span><br><span class="line">displayDeque(deq1);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">deq1.erase(deq1.begin(), deq1.begin() + <span class="number">5</span>);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"deq1:"</span>;</span><br><span class="line">displayDeque(deq1);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">deq1.clear();</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"deq1:"</span>;</span><br><span class="line">displayDeque(deq1);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><p><img src="/2019/07/29/deque容器/test06.PNG" alt="插入和删除操作示例"></p><p>7.deque删除操作</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">clear();<span class="comment">//移除容器的所有数据</span></span><br><span class="line">erase(beg,end);<span class="comment">//删除[beg,end)区间的数据，返回下一个数据的位置</span></span><br><span class="line">erase(pos);<span class="comment">//删除pos位置的很舒服，返回下一个数据的位置</span></span><br></pre></td></tr></table></figure><p>如上例所示。</p><p>五、源码地址</p><p>​        <a href="https://github.com/Aoki-Wang/CheckStation/tree/master/STL/deque" target="_blank" rel="noopener">deque容器示例源码</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;一、deque概述&lt;/p&gt;
&lt;p&gt;&amp;emsp;&lt;code&gt;vector&lt;/code&gt;是单向开口的连续线性空间，&lt;code&gt;deque&lt;/code&gt;则是一种双向开口的连续线性空间。所谓双向开口，意思是可以在头尾两端分别做元素的插入和删除操作。虽然vector容器也可以在头尾两
      
    
    </summary>
    
      <category term="STL" scheme="http://wanqbin.xyz/categories/STL/"/>
    
    
      <category term="STL" scheme="http://wanqbin.xyz/tags/STL/"/>
    
      <category term="deque" scheme="http://wanqbin.xyz/tags/deque/"/>
    
  </entry>
  
  <entry>
    <title>使用点对点信道的数据链路层</title>
    <link href="http://wanqbin.xyz/2019/07/01/%E7%82%B9%E5%AF%B9%E7%82%B9%E4%BF%A1%E9%81%93%E7%9A%84%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/"/>
    <id>http://wanqbin.xyz/2019/07/01/点对点信道的数据链路层/</id>
    <published>2019-07-01T12:38:00.000Z</published>
    <updated>2019-07-01T12:41:36.731Z</updated>
    
    <content type="html"><![CDATA[<p>一、数据链路层的功能</p><p>&emsp;&emsp;数据链路层在物理层提供服务的基础上向网络层提供服务，其主要作用是加强物理层传输原始比特流的功能，将物理层提供的可能出错的物理连接改造为逻辑上无差错的数据链路，使之对网络层表现为一条无差错的链路。</p><ol><li><p>为网络层提供服务</p><p>对网络层而言，数据链路层的基本任务是将源机器中来自网络层的数据传输到目标其的网络层。数据链路层通常可为网络层提供如下服务：</p><p>（1）无确认的无连接服务。员及其发送数据帧时不需先建立链路连接，目的机器收到数据帧时不需发回确认。对丢失的帧，数据链路层不负责重发而交给上层处理。适用于实时通信或误码率较低的通信信道，如以太网</p><p>（2）有确认的无连接服务。源机器发送数据帧时不需先建立链路连接，但目的机器收到数据帧时必须发回确认。源机器在所规定的时间内未收到确定信号时，就重传丢失的帧，以提高传输的可靠性。该服务适用于误码率较高的通信信道，如无线通信</p><p>（3）有确认的面向连接服务。帧传输过程分为三个阶段：建立数据链路，传输帧，释放数据链路。目的机器对收到的每一帧都要给出确认，源机器收到确认后才能发送下一帧，因而该服务的可靠性最高。该服务适用于通信要求较高的场合</p></li></ol><p>二、使用点对点信道的数据链路层</p><ol><li><p>数据链路和帧</p><ul><li>链路，就是从一个结点到相邻结点的一段物理线路，而中间没有任何其他的交换结点。</li><li>数据链路，当需要在一条线路上传送数据时，除了必须要有一条物理线路外，还必须要有一些必要的通信协议来控制这些数据的传输。若把实现这些协议的硬件和软件加到链路上，就构成了数据链路。这样的数据链路就不再是简单的物理链路而是个逻辑链路了。现在最常用的方法是使用网络适配器来实现这些协议的硬件和软件。一般的适配器都包括了数据链路层和物理层这两层功能。</li><li>帧，数据链路层把网络层交下来的数据构成<strong>帧</strong>发送到链路上，以及把接收到的<strong>帧</strong>中的数据报取出并上交给网络层。在因特网中，网络层协议数据单元就是<strong>IP数据报</strong></li><li>点对点信道的数据链路层在进行通信时的主要步骤：<ul><li>结点A的数据链路层把网络层交下来的IP数据报添加首部和尾部封装成帧</li><li>结点A把封装号的帧发送给结点B的数据链路层</li><li>若结点B的数据链路层收到的帧无差错，则从收到的帧中提取出IP数据报上交给上面的网络层，否则就丢弃这个帧</li></ul></li></ul></li><li><p>封装成帧</p><ul><li>数据链路层以帧为单位传输和处理数据。网络层的IP数据报必须向下传送到数据链路层，成为帧的数据部分，同时它的前面和后面分别添加上首部和尾部，封装成一个完整的帧。帧的长度等于帧的数据部分的长度加上帧首部和帧尾部的长度。</li><li>数据链路层的接收方为了能以帧为单位处理接收的数据，必须正确地识别每个帧的开始和结束，即进行<strong>帧定界</strong></li><li>首部和尾部的作用之一就是进行帧定界，同时也包括其他必要的控制信息。</li><li>每一种链路层协议都规定了帧的数据部分长度的上限，即<strong>最大传送单元(MTU)</strong></li><li>PPP协议采用的<strong>零比特填充法</strong><ul><li>在发送端，先扫描整个信息字段。只要发现有5个连续1，则立即填入一个0，经过这种零比特填充后的数据，就可以保证在信息字段中不会出现6个连续1.</li><li>接收端在收到一个帧时，先找到帧定界标志“Flag”以确定一个帧的边界，接着再用硬件对其中的比特流进行扫描。每当发现5个连续的1时，就把5个连续1后面的一个0删除，以还原成原来的数据比特流。</li><li>这样就保证了透明传输：在所传送的树比特流中可以包含任意组合的比特模式，而不会引起对帧定界的判断错误。</li></ul></li></ul></li><li><p>差错检测</p><ul><li>现实的通信链路都不会是理想的，比特在传输过程中可能会产生差错：1可能会变为0,0可能会变为1，则就叫做<strong>比特差错</strong></li><li>传输错误的比特占所传输比特总数的比率称为<strong>误码率</strong></li><li>为了保证接收到的数据是正确的，在计算机网络传输数据时，必须采用某种差错检测措施。虽然各种差错检测技术的具体方法差别很大，但它们最基本的原理是一样的。</li><li>在数据链路层，为了便于硬件检测差错，通常在帧的尾部设置一个差错检验字段存放整个帧的差错检测码，这个差错检验字段常称为<strong>帧检验序列（FCS）</strong>。因此，要在数据链路层进行差错检验，就必须把数据划分成帧，每一帧都加上差错检验码，一帧接一帧地传送，然后再接收方逐帧进行差错检验。</li><li>在数据链路层通常使用<strong>循环冗余检验（CRC）</strong>技术进行差错检测。</li><li>CRC编码额基本原理是，发送方和接收方首先必须协商一个r+1比特的生成式G。算法要求G的最高位和最低位的比特为1,。考虑d比特的数据D，发送方要选择一个合适的r比特<strong>冗余码R（即检错码）</strong>，并将它附加到D上，使得得到的d+r比特模式用模2算术恰好能被G整除。接收方进行差错检测时，用G去除接收到的d+r比特，如果余数非零则检测出差错，否则认为树正确。</li><li>模2运算中，加法不进位，减法不错位，等价于按位异或，乘以和除以2等价于左/右移位。</li></ul></li><li><p>可靠传输</p><ul><li>在某些情况下，我们需要数据链路层向上面的网络层提供“可靠传输”的服务。“可靠传输”就是要做到：发送端发送什么，在对应的接收端就收到什么。</li><li>为了实现可靠的单向数据传输，可靠传输协议需要进行双向通信，因此底层的不可靠信道必须是双向的。</li></ul><p>（1）停止等待协议（SW）</p><ul><li>当正确接收到一个分组时，向发送方发送一个确认分组ACK，当接收到的分组出现比特差错时，丢弃该分组并发送一个否认分组NAK。发送方收到ACK则可以发送下一个分组，而收到NAK则要重传原来的分组，直到收到ACK为止。由于发送方每发送完一个分组必须停下来等接收到确认后才能发送下一个分组，该协议被称为<strong>停止等待协议（SW）</strong></li><li>如果底层的信道会丢失分组，当数据分组或确认分组丢失时，发送方将会一直等待接收方的确认分组。为了解决给问题，可以在发送方发送完一个数据分组时，启动一个<strong>超时计数器</strong>。若到了超时计数器所设置的重传时间而发送方仍收不到接收方的任何确认分组，则重传原来的分组，这就是<strong>超时重传</strong>。</li><li>当确认分组丢失时，接收方会收到两个同样的数据分组，即<strong>重复分组</strong>。若接收方不能识别重复分组，则会导致另一种差错——<strong>数据重复</strong>。为了解决该问题，必须使每个数据分组带上不同的发送序号。每发送一个新的数据分组就把它的发送序号加1.若接收方连续收到发送序号相同的数据分组，就表明出现了重复分组。这时应丢弃重复的分组，此时，接收方还必须向发送方补发一个确认分组ACK。</li><li>停止等待协议的优点是简单，但缺点是信道利用率太低。</li><li>假设存在发送方A，发送分组需要的时间是$T_D$,接收方B，发送确认分组需要时间$T_A$.如果A处理确认分组的时间可以忽略不计，那么A在经过时间（$T_D$+RTT+$T_A$)后就可以再发送下一个分组，这里的RTT是<strong>往返时间</strong>。因为仅仅是在时间$T_D$内采用来传送有用的数据，因此，信道的利用率U为：U=$\frac{TD}{TD+RTT+TA}$.</li><li>当RTT远大于分组发送时间$T_D$时，信道的利用率就会非常低</li><li>当RTT远小于发送时间$T_D$时，信道的利用率较高。</li><li>流水线传输方式就是发送方可连续发送多个分组，不必每发完一个分组就停下来等待对方的确认。这样可使得信道上一直有数据不间断地在传送。显然，这种传输方式可以获得很高的信道利用率。</li></ul><p>（2）回退N帧协议（GBN）</p><ul><li>回退N帧协议在流水线传输的基础上利用<strong>发送窗口</strong>来限制发送方连续发送分组的个数，是一种连续<strong>ARQ</strong>协议。</li><li>为此，在发送方要维持一个发送窗口。发送窗口时允许发送方已发送但还没有收到的分组序号的范围，窗口大小就是发送方已发送但还没有收到确认的最大分组数。</li><li>在协议的工作过程中，发送窗口不断向前滑动，因此，这类协议又称为<strong>滑动窗口协议</strong>。</li><li>GBN采用累积确认的方式。优点是容易实现，即使确认丢失也可能不必重传。但缺点是不能向发送方准确反映出接收方已经正确收到的所有分组的信息。</li></ul><p>（3）选择重传协议</p><ul><li>GBN协议存在一个缺点：一个分组的差错可能引起大量分组的重传，这些分组可能已经被接收方正确接收了，但由于未按序到达而被抛弃。显然对这些分组的重传是对通信资源的极大浪费。为进一步提高性能，可设法只重传出现差错的分组，但这时<strong>接收窗口不再为1</strong>，以便先收下失序到达但仍然处在接收窗口中的那些分组，等到所缺分组收齐后再一并送交上层，这就是选择重传（SR）协议。</li><li>为了使发送方仅重传出现差错的分组，接收方不能再采用累积确认，而需要对每个正确接收到的分组进行逐一确认。</li></ul><p>（4）数据链路层的可靠传输</p><ul><li>不可靠的链路加上适当的协议就可以使链路层向上提供可靠传输服务。但付出的代价是数据的传输效率降低了，而且增加了协议的复杂性。因此，应当根据链路的具体情况来决定是否需要让链路层向上提供可靠传输服务。</li><li>现在有线网络广泛使用的数据链路层协议一般都不使用确认和重传机制，即不要求数据链路层向上提供可靠传输服务。若数据链路层传输数据偶尔出现了差错，并且需要进行改正，则改正差错的任务就由上层协议来完成。实践证明，这样做可以提高通信效率，降低设备成本。</li></ul></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;一、数据链路层的功能&lt;/p&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;数据链路层在物理层提供服务的基础上向网络层提供服务，其主要作用是加强物理层传输原始比特流的功能，将物理层提供的可能出错的物理连接改造为逻辑上无差错的数据链路，使之对网络层表现为一条无差错的链路。&lt;/p&gt;
&lt;ol&gt;

      
    
    </summary>
    
      <category term="计算机网络" scheme="http://wanqbin.xyz/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="数据链路层" scheme="http://wanqbin.xyz/tags/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/"/>
    
      <category term="差错检测" scheme="http://wanqbin.xyz/tags/%E5%B7%AE%E9%94%99%E6%A3%80%E6%B5%8B/"/>
    
      <category term="可靠传输" scheme="http://wanqbin.xyz/tags/%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93/"/>
    
  </entry>
  
  <entry>
    <title>list容器</title>
    <link href="http://wanqbin.xyz/2019/07/01/list%E5%AE%B9%E5%99%A8/"/>
    <id>http://wanqbin.xyz/2019/07/01/list容器/</id>
    <published>2019-07-01T02:06:00.000Z</published>
    <updated>2019-07-28T14:23:42.902Z</updated>
    
    <content type="html"><![CDATA[<p>一、list容器概述</p><p>&emsp;&emsp;链表是一种物理存储单元上非连续、非顺序的存储结构，数据元素的逻辑顺序是通过链表中的指针链接次序实现的。链表由一系列结点（链表中每一个元素称为结点）组成，结点可以在运行时动态生成。每个结点包括两部分：一个是存储数据元素的数据域，另一个是存储下一个节点地址的指针域。</p><p>&emsp;&emsp;相较于vector的连续线性空间，list就显得复杂许多，它的好处是每次插入或删除一个元素，就配置或释放一个元素空间。因此，list对于空间的运用有绝对的精准，一点也不浪费。而且，对于任何位置的元素插入或移除，list永远都是常数时间。</p><p>&emsp;&emsp;list容器是一个双向链表</p><ul><li>采用动态存储分配，不会造成内存浪费和溢出</li><li>链表执行插入和删除操作十分方便，修改指针即可，不需要移动大量元素</li><li>链表灵活，但是空间和时间额外耗费较大</li></ul><p>二、list容器的迭代器</p><p>&emsp;&emsp;list不再能够像vector一样以普通指针作为迭代器，因为其节点不保证在同一块连续的内存空间上，list迭代器必须有能力指向list结点，并有能力进行正确的递增、递减、取值、成员存储操作。所谓list正确的递增、递减、取值、成员取用是指，递增时指向下一个节点，递减时指向上一个节点，取值时取的是结点的数据值，成员取用时取的是结点成员。</p><p>&emsp;&emsp;由于list是一个双向链表，迭代器必须能够具备前移后移的能力，所以list容器提供的是<code>Bidirectional Iterator</code></p><p>&emsp;&emsp;list有一个重要的性质，插入操作和删除操作都不会造成原有list迭代器的失效，这在vector中是不成立的，因为vector的插入操作可能会造成记忆体重新配置，导致原有的迭代器全部失效，甚至list元素的删除，也只有被删除的那个元素的迭代器失效，其他迭代器不受任何影响。</p><p>三、list的节点</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> _<span class="title">list_node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">void</span>* void_pointer;</span><br><span class="line">void_pointer prve;<span class="comment">//型别为void*，其实可设为_list_node&lt;T&gt;*</span></span><br><span class="line">void_pointer next;</span><br><span class="line">T data;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>显然这是一个双向链表。</p><p>四、list的元素操作</p><ol><li><p>常用API</p><ul><li>list<t> lstT;//list采用采用模板类实现,对象的默认构造形式</t></li><li>list(beg,end);//构造函数将[beg, end)区间中的元素拷贝给本身</li><li>list(n,elem);//构造函数将n个elem拷贝给本身</li><li>list(const list &amp;lst);//拷贝构造函数</li><li>push_back(elem);//在容器尾部加入一个元素</li><li>pop_back();//删除容器中最后一个元素</li><li>push_front(elem);//在容器开头插入一个元素</li><li>pop_front();//从容器开头移除第一个元素</li><li>insert(pos,elem);//在pos位置插elem元素的拷贝，返回新数据的位置</li><li>insert(pos,n,elem);//在pos位置插入n个elem数据，无返回值。</li><li>insert(pos,beg,end);//在pos位置插入[beg,end)区间的数据，无返回值。</li><li>clear();//移除容器的所有数据</li><li>erase(beg,end);//删除[beg,end)区间的数据，返回下一个数据的位置。</li><li>erase(pos);//删除pos位置的数据，返回下一个数据的位置。</li><li>remove(elem);//删除容器中所有与elem值匹配的元素。</li></ul><p>示例如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;L1(<span class="number">10</span>, <span class="number">10</span>);</span><br><span class="line"><span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;L2(L1.begin(), L1.end());<span class="comment">//使用L1构造L2</span></span><br><span class="line">DislayList(L1);</span><br><span class="line">DislayList(L2);</span><br><span class="line">L2.push_back(<span class="number">15</span>);<span class="comment">//给L2后面加入一个元素</span></span><br><span class="line">DislayList(L2);</span><br><span class="line"><span class="comment">//逆序打印L2</span></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;::reverse_iterator it = L2.rbegin(); it != L2.rend(); it++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="comment">//插入数据</span></span><br><span class="line"><span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;L3;</span><br><span class="line">L3.push_back(<span class="number">15</span>);</span><br><span class="line">L3.push_back(<span class="number">20</span>);</span><br><span class="line">L3.push_front(<span class="number">10</span>);</span><br><span class="line">L3.push_front(<span class="number">5</span>);</span><br><span class="line">DislayList(L3);<span class="comment">//打印L3中的元素</span></span><br><span class="line"><span class="comment">//删除list两端的元素</span></span><br><span class="line">L3.pop_front();<span class="comment">//头删</span></span><br><span class="line">L3.pop_back();<span class="comment">//尾删</span></span><br><span class="line">DislayList(L3);<span class="comment">//打印L3中的元素</span></span><br><span class="line"><span class="comment">//插入元素</span></span><br><span class="line">L3.insert(L3.begin(), <span class="number">333</span>);</span><br><span class="line">DislayList(L3);</span><br><span class="line">L3.remove(<span class="number">15</span>);</span><br><span class="line">DislayList(L3); </span><br><span class="line"><span class="keyword">if</span> (L3.empty())</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"L3为空"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"L3中元素的个数为："</span> &lt;&lt; L3.size() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">L3.erase(L3.begin());</span><br><span class="line">DislayList(L3);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果如下图：</p><p><img src="/2019/07/01/list容器/常用API.PNG" alt="常用API示例结果"></p></li><li><p>其他操作</p><ul><li>resize(num);//重新指定容器的长度为num，若容器变长，则以默认值填充新位置。如果容器变短，则末尾超出容器长度的元素被删除</li><li>resize(num, elem);//重新指定容器的长度为num，若容器变长，则以elem值填充新位置。如果容器变短，则末尾超出容器长度的元素被删除</li><li>assign(beg, end);//将[beg, end)区间中的数据拷贝赋值给本身</li><li>assign(n, elem);//将n个elem拷贝赋值给本身</li><li>swap(lst);//将lst与本身的元素互换</li><li>reverse();//反转链表</li></ul><p>示例如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;L;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">L.push_back(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"初始L为："</span>;</span><br><span class="line">DislayList(L);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"指定容器长度为15："</span>;</span><br><span class="line">L.resize(<span class="number">15</span>);</span><br><span class="line">DislayList(L);</span><br><span class="line">L.resize(<span class="number">10</span>);</span><br><span class="line">L.resize(<span class="number">15</span>,<span class="number">121212</span>);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"执行操作resize(15,121212)后："</span>;</span><br><span class="line">DislayList(L);</span><br><span class="line">L.resize(<span class="number">5</span>);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"执行操作resize(5)后："</span>;</span><br><span class="line">DislayList(L);</span><br><span class="line"><span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;L2;</span><br><span class="line">L2.assign(L.begin(), L.end());</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"L2:"</span>;</span><br><span class="line">DislayList(L2);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"L2 front:"</span> &lt;&lt; L2.front() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"L2 back:"</span> &lt;&lt; L2.back() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="comment">//反转链表</span></span><br><span class="line">L2.reverse();</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"反转后的L2为："</span>;</span><br><span class="line">DislayList(L2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果如下图：</p><p><img src="/2019/07/01/list容器/其他操作.PNG" alt="其他操作示例结果"></p></li><li><p>==运算符重载</p><ul><li>自定义数据类型Person</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">string</span> m_name;</span><br><span class="line"><span class="keyword">int</span> m_age;</span><br><span class="line">Person(<span class="built_in">string</span> name, <span class="keyword">int</span> age)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_name = name;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_age = age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> Person&amp; p)<span class="comment">//重载==运算符</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>-&gt;m_name == p.m_name &amp;&amp; <span class="keyword">this</span>-&gt;m_age == p.m_age)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>利用重载的==运算符删除其中一个元素</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test03</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">list</span>&lt;Person&gt;L;</span><br><span class="line"><span class="function">Person <span class="title">p1</span><span class="params">(<span class="string">"Aoki"</span>, <span class="number">23</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">p2</span><span class="params">(<span class="string">"青木"</span>, <span class="number">18</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">p3</span><span class="params">(<span class="string">"张一"</span>,<span class="number">20</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">p4</span><span class="params">(<span class="string">"张二"</span>, <span class="number">10</span>)</span></span>;</span><br><span class="line">L.push_back(p1);</span><br><span class="line">L.push_back(p2);</span><br><span class="line">L.push_back(p3);</span><br><span class="line">L.push_back(p4);</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">list</span>&lt;Person&gt;::iterator it = L.begin(); it != L.end(); it++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"姓名："</span> &lt;&lt; it-&gt;m_name &lt;&lt; <span class="string">"年龄："</span> &lt;&lt; it-&gt;m_age &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"删除张二"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">L.remove(p4);</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">list</span>&lt;Person&gt;::iterator it = L.begin(); it != L.end(); it++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"姓名："</span> &lt;&lt; it-&gt;m_name &lt;&lt; <span class="string">"年龄："</span> &lt;&lt; it-&gt;m_age &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果如下：</p><p><img src="/2019/07/01/list容器/重载运算符.PNG" alt="重载==运算符"></p></li><li><p>自定义规则排序</p><p>这里我们借助sort()函数对自定义数据类型进行排序操作。</p><p>需要引用一个头文件<code>#include&lt;algorithm&gt;</code></p><p>排序规则：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">ComparePerson</span><span class="params">(Person&amp; p1, Person&amp; p2)</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">//自定义排序规则，按年龄从小到大排序</span></span><br><span class="line"><span class="keyword">return</span> p1.m_age &lt; p2.m_age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据排序规则对list中的自定义数据类型元素进行排序：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test04</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">list</span>&lt;Person&gt;L;</span><br><span class="line"><span class="function">Person <span class="title">p1</span><span class="params">(<span class="string">"Aoki"</span>, <span class="number">23</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">p2</span><span class="params">(<span class="string">"青木"</span>, <span class="number">18</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">p3</span><span class="params">(<span class="string">"张一"</span>, <span class="number">20</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">p4</span><span class="params">(<span class="string">"张二"</span>, <span class="number">10</span>)</span></span>;</span><br><span class="line">L.push_back(p1);</span><br><span class="line">L.push_back(p2);</span><br><span class="line">L.push_back(p3);</span><br><span class="line">L.push_back(p4);</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">list</span>&lt;Person&gt;::iterator it = L.begin(); it != L.end(); it++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"姓名："</span> &lt;&lt; it-&gt;m_name &lt;&lt; <span class="string">"年龄："</span> &lt;&lt; it-&gt;m_age &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">L.sort(ComparePerson);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"使用自定义规则排序："</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">list</span>&lt;Person&gt;::iterator it = L.begin(); it != L.end(); it++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"姓名："</span> &lt;&lt; it-&gt;m_name &lt;&lt; <span class="string">"年龄："</span> &lt;&lt; it-&gt;m_age &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果如下：</p><p><img src="/2019/07/01/list容器/排序操作.PNG" alt="自定义排序规则"></p></li></ol><p>五、源码地址</p><p><a href="https://github.com/Aoki-Wang/CheckStation/tree/master/STL/list" target="_blank" rel="noopener">list源码示例</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;一、list容器概述&lt;/p&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;链表是一种物理存储单元上非连续、非顺序的存储结构，数据元素的逻辑顺序是通过链表中的指针链接次序实现的。链表由一系列结点（链表中每一个元素称为结点）组成，结点可以在运行时动态生成。每个结点包括两部分：一个是存储数据元
      
    
    </summary>
    
      <category term="STL" scheme="http://wanqbin.xyz/categories/STL/"/>
    
    
      <category term="STL" scheme="http://wanqbin.xyz/tags/STL/"/>
    
      <category term="list" scheme="http://wanqbin.xyz/tags/list/"/>
    
  </entry>
  
  <entry>
    <title>交换技术和分组交换的两种方式</title>
    <link href="http://wanqbin.xyz/2019/07/01/%E4%BA%A4%E6%8D%A2%E6%8A%80%E6%9C%AF%E5%92%8C%E5%88%86%E7%BB%84%E4%BA%A4%E6%8D%A2%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%96%B9%E5%BC%8F/"/>
    <id>http://wanqbin.xyz/2019/07/01/交换技术和分组交换的两种方式/</id>
    <published>2019-06-30T16:51:00.000Z</published>
    <updated>2019-06-30T17:25:15.433Z</updated>
    
    <content type="html"><![CDATA[<p>一、电路交换</p><ul><li>在进行数据传输前，两个结点之间必须建立一条专用（双方独占）的物理通信路径，该路径可能经过许多中间结点。这一路径在整个数据传输期间一直被独占，直到通信结束才被释放。因此，电路交换技术分为三个阶段：连接建立、数据传输、连接释放</li><li>从通信资源的分配角度来看，“交换”就是按照某种方式动态地分配传输线路的资源。电路交换的关键点是，在数据传输过程中，用户始终占用端到端的固定传输带宽。</li><li>电路交换的优点：<ul><li>通信时延小。当传输的数据量较大时，这一优点非常明显</li><li>有序传输</li><li>没有冲突</li><li>适用范围广</li><li>实用性强</li><li>控制简单</li></ul></li><li>电路交换的缺点<ul><li>建立连接时间长</li><li>线路独占</li><li>灵活性差</li><li>难以规格化</li></ul></li><li>电路建立后，除源结点和目的节点外，电路上的任何结点都采取“直通方式”接收数据和发送数据，即不会存在存储转发所耗费的时间。</li></ul><p>二、报文交换</p><ul><li>数据交换的单位是报文，报文携带有目标地址、源地址等信息。报文交换在交换结点采用的是存储转发的传输方式</li><li>报文交换的优点<ul><li>无须建立连接</li><li>动态分配线路</li><li>提高线路可靠性</li><li>提高线路利用率</li><li>提供多目标服务</li></ul></li><li>报文交换的缺点<ul><li>由于数据进入交换结点后要经历存储、转发这一过程，因此会引起转发时延</li><li>报文交换对报文的大小没有限制，这就要求网络结点需要有较大的缓存空间</li></ul></li></ul><p>三、分组交换</p><ul><li>采用存储转发方式，但解决了报文交换中大报文传输的问题。</li><li>分组交换限制了每次传送的数据块大小的上限，把大的数据块划分为合理的小的数据块，再加上一些必要的控制信息，构成分组。网络结点根据控制信息把分组送到下一结点，下一结点接收到分组后，暂时保存并排队等待传输，然后根据分组控制信息选择它的下一结点，直到到达目的结点。</li><li>分组交换的优点<ul><li>无建立时延</li><li>线路利用率高</li><li>简化了存储管理</li><li>加速传输</li><li>减少了出错概率和重发数据量</li></ul></li><li>分组交换的缺点<ul><li>存在传输时延</li><li>需要传输额外的信息</li><li>当分组交换采用数据报服务时，可能会出现失序、丢失或重复分组，分组到达目的结点时，要对分组按编号进行排序等工作，因此很麻烦。若采用虚电路服务，虽无失序问题，但有呼叫建立、数据传输和虚电路释放三个过程。</li></ul></li></ul><p>四、电路交换、分组交换和分组交换</p><ul><li><p>要传送的数据量很大且其传送时间远大于呼叫时间时，采用电路交换较为合适</p></li><li><p>端到端的通路由多段链路组成时，采用分组交换传送数据较为合适</p></li><li><p>从提高整个网络的信道利用率上看，报文交换和分组交换优于电路交换，其中分组交换比报文交换的时延小，尤其适合于计算机之间的突发式数据通信。</p><p><img src="/2019/07/01/交换技术和分组交换的两种方式/交换技术.jpg" alt="三种数据交换方式的比较"></p></li></ul><p>五、数据报与虚电路</p><ul><li>分组交换根据其通信子网向端点系统提供的服务，还可以进一步分为面向连接的虚电路方式和无连接的数据报方式。这两种服务方式都由网络层提供。数据报方式和虚电路方式是分组交换的两种方式。</li></ul><ol><li><p>数据报</p><ul><li>作为通信子网用户的端系统发送一个报文时，在端系统中实现的高层协议先把报文拆成若干带有序号的数据单元，并在网络层加上地址等控制信息后形成数据办分组。中间节点存储分组很短一段时间，找到最佳路由后，尽快转发每个分组。不同的分组可以走不同的路径，也可以按不同的顺序到达目的结点。</li><li>数据报服务的特点<ul><li>发送分组前不需要建立连接，发送方可随时发送分组，网络中的结点可随时接收分组</li><li>网络尽最大努力交付，传输不保证可靠性，所以可能丢失；为每个分组独立地选择路由，转发的路径可能不同，因而分组不一定按序到达目的结点</li><li>发送的分组中要包括发送端和接收端的完整地址，以便可以独立传输</li><li>分组在交换结点存储转发时，需要排队等候处理，这会带来一定的时延。通过交换结点的通信量较大或网络发生拥塞时，这种时延会大大增加，交换结点还可根据情况丢弃部分分组</li><li>网络具有冗余路径，当某一交换结点或一段链路出现故障时，可相应地更新转发表，寻找另一条路径转发分组，对故障的适应能力强</li><li>存储转发的时延一般较小，提高了网络的吞吐量</li><li>收发双方不独占某一链路，资源利用率高</li></ul></li></ul></li><li><p>虚电路</p><ul><li>虚电路方式试图将数据报方式与电路交换方式结合起来，充分发挥两种方法的优点，以达到最佳的数据交换效果。在分组发送之前，要求在发送方和接收方建立一条逻辑上相连的虚电路，并且连接一旦建立，就固定了虚电路所对应的物理路径。与电路交换类似，整个通信过程分为三个阶段：虚电路建立、数据传输与虚电路释放</li><li>在虚电路方式中，端系统每次建立虚电路时，选择一个未用过的虚电路号分配给该虚电路以区别于本系统中的ITA虚电路。在传送数据时，每个数据分组不仅要有分组号、校验和等控制信息，还要有它通过的虚电路号，以区别于其他虚电路上的分组。在虚电路网路中的每个结点上都维持一张虚电路表，表中的每项记录了一个打开的虚电路信息，包括在接收链路和发送链路上的虚电路号、前一结点和下一结点的标识。数据传输时双向进行的，上述信息是在建立过程中确定的。</li><li>虚电路服务的特点<ul><li>虚电路通信链路的建立和拆除需要时间开销，对交互式应用和小量的短分组情况显得很浪费，但对长时间、频繁的数据交换效率较高</li><li>虚电路的路由选择体现在连接建立阶段，连接建立后，就确定了传输路径</li><li>虚电路提供了可靠的通信功能，能保证每个分组正确且有序到达。此外还可以对两个数据端点的流量进行控制，当接收方来不及接收数据时，可以通知发送方暂缓发送</li><li>虚电路有一个致命的弱点，即当网络中的某个结点或某条链路出现故障而彻底失效时，所有经过该结点或该链路的虚电路将遭到破坏</li><li>分组首部不含目的地址，而包含虚电路标识符，相对数据报方式开销小</li></ul></li><li>虚电路之所以是“虚”的，是因为这条电路不是专用的，每个节点到其他节点之间的链路可能同时有若干虚电路通过，也可能同时与多个结点之间建立虚电路。每天虚电路支持特定的两个端系统之间的数据传输，两个端系统之间也可以有多条虚电路为不同的进程服务，这些虚电路的实际路由可能相同也可能不同。</li></ul></li><li><p>数据报服务和虚电路服务的比较</p></li></ol><div class="table-container"><table><thead><tr><th></th><th>数据报服务</th><th>虚电路服务</th></tr></thead><tbody><tr><td>连接的建立</td><td>不需要</td><td>必须有</td></tr><tr><td>目的地址</td><td>每个分组都有完整的目的地址</td><td>仅在建立连接阶段使用，之后每个分组使用长度较短的虚电路号</td></tr><tr><td>路由选择</td><td>每个分组独立地进行路由选择和转发</td><td>属于同一条虚电路的分组按照同一路由转发</td></tr><tr><td>分组顺序</td><td>不保证分组的有序到达</td><td>保证分组的有序到达</td></tr><tr><td>可靠性</td><td>不保证可靠通信，可靠性由用户主机来保证</td><td>可靠性由网络保证</td></tr><tr><td>对网络故障的适应性</td><td>出故障的结点丢失分组，其他分组路径选择发生变化时可以正常传输</td><td>所有经过故障结点的虚电路均不能正常工作</td></tr><tr><td>差错处理和流量控制</td><td>由用户主机进行流量控制，不保证数据报的可靠性</td><td>可由分组交换网负责，也可由用户主机负责</td></tr></tbody></table></div>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;一、电路交换&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在进行数据传输前，两个结点之间必须建立一条专用（双方独占）的物理通信路径，该路径可能经过许多中间结点。这一路径在整个数据传输期间一直被独占，直到通信结束才被释放。因此，电路交换技术分为三个阶段：连接建立、数据传输、连接释放&lt;/li&gt;

      
    
    </summary>
    
      <category term="计算机网络" scheme="http://wanqbin.xyz/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="电路交换" scheme="http://wanqbin.xyz/tags/%E7%94%B5%E8%B7%AF%E4%BA%A4%E6%8D%A2/"/>
    
      <category term="报文交换" scheme="http://wanqbin.xyz/tags/%E6%8A%A5%E6%96%87%E4%BA%A4%E6%8D%A2/"/>
    
      <category term="分组交换" scheme="http://wanqbin.xyz/tags/%E5%88%86%E7%BB%84%E4%BA%A4%E6%8D%A2/"/>
    
      <category term="虚电路" scheme="http://wanqbin.xyz/tags/%E8%99%9A%E7%94%B5%E8%B7%AF/"/>
    
      <category term="数据报" scheme="http://wanqbin.xyz/tags/%E6%95%B0%E6%8D%AE%E6%8A%A5/"/>
    
  </entry>
  
  <entry>
    <title>vector容器</title>
    <link href="http://wanqbin.xyz/2019/06/30/vector%E5%AE%B9%E5%99%A8/"/>
    <id>http://wanqbin.xyz/2019/06/30/vector容器/</id>
    <published>2019-06-30T11:31:00.000Z</published>
    <updated>2019-06-30T16:01:56.028Z</updated>
    
    <content type="html"><![CDATA[<p>一、序列式容器</p><p>所谓序列式容器，其中的元素都是可序的，但未必有序。C++本身体用了一个序列式容器array，STL另外提供了vector,list,deque,stack.priority-queue等序列式容器。</p><p>二、vector</p><ol><li><p>vector与array的区别</p><p>vector的数据安排以及操作方式，与array非常相似，两者的唯一差别在于空间运用的灵活性。</p><ul><li>array是静态空间，一旦配置了就不能改变，要更换大一些的空间，就必须执行如下操作：<ul><li>配置一块新空间</li><li>将元素从旧地址一一搬往新地址</li><li>把原来的空间释放还给系统</li></ul></li><li>vector是动态空间，随着元素的加入，它的内部机制会自行扩充空间以容纳新元素</li></ul></li><li><p>vector空间配置</p><ul><li>为了降低空间配置时的速度成本，vector实际配置的大小比客户端需求大一些，以备将来可能的扩充。这便是容量（capacity）的概念。换句话说，一个vector的容量永远大于或等于其大小。一旦容量等于大小，便是满载，下次再有新增元素，整个vector就得另觅居所。</li><li>所谓动态增加大小，并不是在原空间之后续接新空间，而是一块更大的内存空间，然后将元数据拷贝到新空间，并释放原空间，因此，对vector的任何操作，一旦引起空间的重新配置，指向原vector额度所有迭代器就都失效了。</li><li></li></ul></li><li><p>vector的数据结构</p><p>vector所采用的数据结构非常简单：线性连续空间。它以两个迭代器<code>start</code>和<code>finish</code>分别指向配置得来的连续空间中已经使用的范围，并以迭代器<code>end_of_storage</code>指向整块连续空间（含备用空间）的尾端。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">Alloc</span> = <span class="title">alloc</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">vector</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">……</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">iterator start;    <span class="comment">//表示目前使用空间的头</span></span><br><span class="line">iterator finish;  <span class="comment">//表示目前使用空间的尾</span></span><br><span class="line">iterator end_of_storage;  <span class="comment">//表示目前可用空间的尾</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>push_back操作</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;v;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"vector当前使用的空间为："</span> &lt;&lt; v.size() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"vector的容量为："</span> &lt;&lt; v.capacity() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">v.push_back(i);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"vector当前使用的空间为："</span> &lt;&lt; v.size() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"vector的容量为："</span> &lt;&lt; v.capacity() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">DisplayVector(v);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2019/06/30/vector容器/push_back.PNG" alt="push_back操作"></p></li><li><p>构造一个vector容器</p><p>vector中提供的构造函数和拷贝构造函数如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>() :start(<span class="number">0</span>), finish(<span class="number">0</span>), end_of_storage(<span class="number">0</span>) &#123;&#125;</span><br><span class="line"><span class="built_in">vector</span>(size_type n, <span class="keyword">const</span> T&amp; value)</span><br><span class="line">&#123;</span><br><span class="line">fill_initialize(n, value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">vector</span>(<span class="keyword">int</span> n, <span class="keyword">const</span> T&amp; value)</span><br><span class="line">&#123;</span><br><span class="line">fill_initialize(n, value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">vector</span>(<span class="keyword">long</span> n, <span class="keyword">const</span> T&amp; value)</span><br><span class="line">&#123;</span><br><span class="line">fill_initialize(n, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面使用一个vector容器构造另一个vector容器，代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v1;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">v1.push_back(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v2(v1.begin(), v1.end());</span><br><span class="line">DisplayVector(v1);</span><br><span class="line">DisplayVector(v2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果如下图：</p><p><img src="/2019/06/30/vector容器/构造v2.PNG" alt="构造一个vector容器"></p></li><li><p>使用数组初始化vector</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test03</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> <span class="built_in">array</span>[] = &#123; <span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">11</span> &#125;;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;v(<span class="built_in">array</span>, <span class="built_in">array</span> + <span class="keyword">sizeof</span>(<span class="built_in">array</span>) / <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">DisplayVector(v);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果如下图：</p><p><img src="/2019/06/30/vector容器/数组构造vector容器.PNG" alt="使用数组初始化vector"></p></li><li><p>初始化vector容器的一些方式</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test04</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;v1(<span class="number">10</span>, <span class="number">1</span>);<span class="comment">//初始化vector容器v为10个1</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"v1:"</span>;</span><br><span class="line">DisplayVector(v1);</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;v2&#123; <span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">10</span> &#125;;<span class="comment">//列表初始化vector容器</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"v2:"</span>;</span><br><span class="line">DisplayVector(v2);</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;v3;</span><br><span class="line"><span class="comment">//assign(begin(),end());将[begin,end]区间中的数据拷贝给容器</span></span><br><span class="line">v3.assign(v1.begin(), v1.end());</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"v3:"</span>;</span><br><span class="line">DisplayVector(v3);</span><br><span class="line"><span class="comment">//assign(n,value);将n个value赋值给容器</span></span><br><span class="line">v3.assign(<span class="number">10</span>, <span class="number">100</span>);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"v3:"</span>;</span><br><span class="line">DisplayVector(v3);</span><br><span class="line"><span class="comment">//swap(vector);将vector中的元素与本身的元素交换</span></span><br><span class="line">v1.swap(v3);<span class="comment">//v1与v3的元素进行交换</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"v1:"</span>;</span><br><span class="line">DisplayVector(v1);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"v3:"</span>;</span><br><span class="line">DisplayVector(v3);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果如下图所示：</p><p><img src="/2019/06/30/vector容器/初始化vector的一些方式.PNG" alt="初始化vector容器的一些方式"></p></li><li><p>vector的元素操作：insert、push_back、pop_back、erase、clear</p><p>对元素操作的说明如下：</p><ul><li>insert(const_iterator pos, int count,ele);//迭代器指向位置pos 插入count 个元素ele.</li><li>push_back(ele); //尾部插入元素ele</li><li>pop_back();//删除最后一个元素</li><li>erase(const_iterator start, const_iterator end);//删除迭代器从start 到end 之间的元素</li><li>erase(const_iterator pos);//删除迭代器指向的元素</li><li><p>clear();//删除容器中所有元素</p></li><li><p>size();//返回容器中元素的个数</p></li><li>empty();//判断容器是否为空</li><li>resize(int num);//重新指定容器的长度为num，若容器变长，则以默认值填充新位置。如果容器变<br>短，则末尾超出容器长度的元素被删除。</li><li>resize(int num, elem);//重新指定容器的长度为num，若容器变长，则以elem 值填充新位置。如<br>果容器变短，则末尾超出容器长&gt;度的元素被删除。</li><li>capacity();//容器的容量</li><li>reserve(int len);//容器预留len 个元素长度，预留位置不初始化，元素不可访问。</li></ul><p>示例如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test05</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;v1&#123; <span class="number">10</span>,<span class="number">15</span>,<span class="number">16</span>,<span class="number">17</span>,<span class="number">18</span>,<span class="number">19</span>,<span class="number">20</span> &#125;;</span><br><span class="line"><span class="keyword">if</span> (v1.empty())</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"v1为空"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"v1:"</span>;</span><br><span class="line">DisplayVector(v1);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"v1不为空，元素个数为："</span> &lt;&lt; v1.size() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">v1.resize(<span class="number">10</span>);<span class="comment">//重新指定vector容器的长度</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"v1的元素个数为："</span> &lt;&lt; v1.size() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">DisplayVector(v1);</span><br><span class="line">v1.resize(<span class="number">15</span>, <span class="number">8888</span>);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"v1的元素个数为："</span> &lt;&lt; v1.size() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">DisplayVector(v1);</span><br><span class="line">v1.resize(<span class="number">4</span>);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"现在v1的元素个数为："</span> &lt;&lt; v1.size() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">DisplayVector(v1);</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;v2;</span><br><span class="line">v2.reserve(<span class="number">15</span>);<span class="comment">//为v2预留15个元素的长度</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">v2.push_back(i);</span><br><span class="line">&#125;</span><br><span class="line">DisplayVector(v2);</span><br><span class="line"><span class="keyword">int</span> ret = v1.at(<span class="number">2</span>);<span class="comment">//取索引5指向的元素</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"索引为2所指的数据为："</span> &lt;&lt; ret &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"v1中的第三个元素为："</span> &lt;&lt; v1[<span class="number">2</span>] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"v1的首元素为："</span> &lt;&lt; v1.front() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"v1的尾元素为："</span> &lt;&lt; v1.back() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">v1.insert(v1.begin() + <span class="number">1</span>, <span class="number">4</span>, <span class="number">5</span>);<span class="comment">//在迭代器v1.begin()+1指向的位置插入4个5</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"v1:"</span>;</span><br><span class="line">DisplayVector(v1);<span class="comment">//输出</span></span><br><span class="line">v1.pop_back();<span class="comment">//删除v1的尾元素</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"v1:"</span>;</span><br><span class="line">DisplayVector(v1);</span><br><span class="line">v1.erase(v1.begin());<span class="comment">//删除v1的v1.begin指向的元素</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"v1:"</span>;</span><br><span class="line">DisplayVector(v1);</span><br><span class="line">v1.erase(v1.begin()+<span class="number">1</span>, v1.end());<span class="comment">//删除v1.begin()+1,v1.end()之间的元素</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"v1:"</span>;</span><br><span class="line">DisplayVector(v1);</span><br><span class="line">v1.clear();<span class="comment">//清空v1中的元素</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"v1:"</span>;</span><br><span class="line">DisplayVector(v1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果如下：</p><p><img src="/2019/06/30/vector容器/vector的元素操作.PNG" alt="vector的元素操作"></p></li><li><p>使用swap来收缩vector容器的空间</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test06</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;v;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">v.push_back(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"v的容量为："</span> &lt;&lt; v.capacity() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"v的大小为："</span> &lt;&lt; v.size() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">v.resize(<span class="number">5</span>);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"调整大小后vector容器的容量和大小如下："</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"v的容量为："</span> &lt;&lt; v.capacity() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"v的大小为："</span> &lt;&lt; v.size() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"使用swap收缩vector空间"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(v).swap(v);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"v的容量为："</span> &lt;&lt; v.capacity() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"v的大小为："</span> &lt;&lt; v.size() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果如下：</p><p><img src="/2019/06/30/vector容器/使用swap收缩vector容器空间.PNG" alt="使用swap收缩vector容器空间"></p></li><li><p>源码地址</p><p><a href="https://github.com/Aoki-Wang/CheckStation/tree/master/STL/vector" target="_blank" rel="noopener">vector源码示例</a></p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;一、序列式容器&lt;/p&gt;
&lt;p&gt;所谓序列式容器，其中的元素都是可序的，但未必有序。C++本身体用了一个序列式容器array，STL另外提供了vector,list,deque,stack.priority-queue等序列式容器。&lt;/p&gt;
&lt;p&gt;二、vector&lt;/p&gt;
&lt;o
      
    
    </summary>
    
      <category term="STL" scheme="http://wanqbin.xyz/categories/STL/"/>
    
    
      <category term="STL" scheme="http://wanqbin.xyz/tags/STL/"/>
    
      <category term="vector" scheme="http://wanqbin.xyz/tags/vector/"/>
    
  </entry>
  
  <entry>
    <title>STL概论</title>
    <link href="http://wanqbin.xyz/2019/06/30/STL%E6%A6%82%E8%AE%BA/"/>
    <id>http://wanqbin.xyz/2019/06/30/STL概论/</id>
    <published>2019-06-30T10:30:00.000Z</published>
    <updated>2019-06-30T10:31:33.704Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>长久以来，软件界一直希望建立一种可重复运用的东西，以及一种得以制造出“可重复运用的东西”的方法，让工程师/程序员的心血不致于随时间迁移、人事异动、私心欲念而烟消云散。从子函数、程序、函数、类别、到函数库、类别库、各种组件、从结构化设计、模块化设计、面向对象设计、到模式的归纳整理，无一不是软件工程的慢慢奋斗史。</p><p>为的，就是复用性的提升。</p><p>——《STL源码剖析》</p></blockquote><p>为了建立数据结构和算法的一套标准，并且降低他们之间的耦合关系，以提升各自的独立性、弹性、交互操作性、，诞生了STL。</p><p>STL（标准模板库），是惠普实验室开发的一系列软件的统称。</p><p>STL从广义上分为：容器、算法、迭代器。容器和算法之间通过迭代器进行无缝连接。STL几乎所有的代码都采用了模板类或模板函数，相比于由函数和类组成的库来说提供了更好的代码复用机会。</p><p>一、STL六大组件</p><ol><li>容器：各种数据结构，如vector,list,deque,set,map，用来存放数据。</li><li>算法：各种常用的算法如：sort,search,copy,erase……</li><li>迭代器:扮演了容器和算法之间的胶合剂，是所谓的泛型指针。共有五种类型，以及其他的衍生变化，从实现的角度来看，迭代器是一种将operator*,operator-&gt;,operator++,operator—等指针相关操作予以重载的class template。所有STL容器都附带有自己专属的迭代器，只有容器设计者才知道如何遍历自己的元素。原生指针也是一种迭代器。</li><li>仿函数：行为类似函数，可作为算法的某种策略。从实现的角度看，仿函数是一种重载了operator()的class或class template</li><li>适配器：一种用来修饰容器或仿函数或得带器接口的东西。</li><li>空间配置器：负责空间配置与管理。从实现的角度来看，配置器是一个实现了动态空间配置，空间管理，空间释放的class template。</li></ol><p>STL六大组件的交互关系，容器通过空间配置器取得数据存储空间，算法通过迭代器存储容器空间中的内容，仿函数可以协助算法完成不同的策略的变化，适配器可以修饰仿函数</p><p>二、STL优点</p><ol><li>STL是C++的一部分，因此不用额外安装什么，它被内建在编译器之内</li><li>STL的一个重要特性是将数据和操作分离，数据由容器类别加以管理，操作则由可定制的算法定义。迭代器在两者之间充当粘合剂，以使算法可以和容器交互运行。</li><li>程序员不用思考STL具体的实现过程，只要能熟练使用STL就可以。这样他们就可以把精力放在程序开发的别的方面</li><li>STL具有高复用性、高性能、高移植性、跨平台等优点。<ul><li>高可重用性：STL中几乎所有的代码都采用了模板类和模板函数的方式实现，这相比于传统的由函数和类组成的库来说提供了更好的代码重用机会。</li><li>高性能：如map可以高效地从十万记录里面查找出指定的记录。因为map是采用红黑树的变体实现的</li><li>高移植性：如在项目A上用STL编写的模块，可以直接移植到项目B上。</li></ul></li></ol><p>三、STL三大组件介绍</p><ol><li><p>容器</p><p>容器，置物之所也。</p><p>研究数据的特定排列方式，以利于搜索或排序或其他特殊每亩地，这一门学科就是数据结构。</p><p>任何特定的数据结构都是为了实现某种特定的算法。STL容器就是将运用最广泛的一些数据结构实现出来。</p><p>常用的数据结构：数组（array），链表（list）、树（tree），栈（stack），队列（queue），集合（set），映射表（map），根据数据在容器这两个排列的特性，这些数据分为序列式容器和关联式容器两种。  </p><ul><li>序列式容器强调的是值的排序，序列式容器中的每个元素均有固定的位置，除非用删除或插入操作改变这个位置。vector容器，deque容器，list容器</li><li>关联式容器是非线性的树结构，更准确的说是二叉树结构，各元素之间没有严格的物理上的顺序关系，也就是说元素在容器中并没有保存元素置入容器时的逻辑顺序。关联式容器另一个显著特点是：在值中选择一个值作为关键字key，这个关键字对值起到了索引的作用，方便查找。set/multiset容器，map/multimap容器</li></ul></li><li><p>算法</p><p>算法，问题之解法也。</p><p>以有限的步骤，解决逻辑或数学上的问题，即为算法。</p><p>算法分为：质变算法和非质变算法</p><p>质变算法：是指在运算过程中会戈恩噶区间内元素的内容，例如拷贝、替换、删除等</p><p>非质变算法：是指运算过程中不会更改区间内的元素内容，例如查找、计数、遍历寻找极值等。</p></li><li><p>迭代器</p><p>迭代器（iterator）是一种抽象的设计概念，显示程序语言中并诶呦直接对应于这个概念的实物。设计模式中iterator模式定义如下：提供一种方法，使之能够依序寻访某个容器所含的各个元素，而又无须暴露该容器的内部表示方式。 </p><p>迭代器的设计思维-STL的关键所在，STL的中心思想在于将容器和算法分开，彼此独立设计，最后再贴胶着剂将他们撮合在一起，从技术角度来看，容器和算法的泛型化并不困难，C++的class template 和function template可分别达到目标，如果设计出这两个之间的良好的胶着剂，才是大难题。  </p></li></ol><div class="table-container"><table><thead><tr><th>分类</th><th>描述</th><th>功能</th></tr></thead><tbody><tr><td>输入迭代器</td><td>提供对数据的只读访问</td><td></td></tr><tr><td>输出迭代器</td><td>提供读写操作，并能向前推进迭代器</td><td></td></tr><tr><td>前向迭代器</td><td>提供读写操作，并能向前推进迭代器</td><td>读写，支持++，==，~=</td></tr><tr><td>双向迭代器</td><td>提供读写操作，并能向前和向后操作</td><td>读写，只会++，—</td></tr><tr><td>随机访问迭代器</td><td>提供读写操作，并能以跳跃的方式访问容器的任意数据，是功能最强大的的迭代器</td><td>读写，支持++，—，[n],-n,&lt;,&lt;=,&gt;,&gt;=</td></tr></tbody></table></div>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;长久以来，软件界一直希望建立一种可重复运用的东西，以及一种得以制造出“可重复运用的东西”的方法，让工程师/程序员的心血不致于随时间迁移、人事异动、私心欲念而烟消云散。从子函数、程序、函数、类别、到函数库、类别库、各种组件、从结构化设计、模块化设计、
      
    
    </summary>
    
      <category term="STL" scheme="http://wanqbin.xyz/categories/STL/"/>
    
    
      <category term="STL" scheme="http://wanqbin.xyz/tags/STL/"/>
    
  </entry>
  
  <entry>
    <title>软件测试知识点总结</title>
    <link href="http://wanqbin.xyz/2019/06/30/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/"/>
    <id>http://wanqbin.xyz/2019/06/30/软件测试知识点总结/</id>
    <published>2019-06-30T08:40:00.000Z</published>
    <updated>2019-06-30T08:43:43.870Z</updated>
    
    <content type="html"><![CDATA[<p>一、软件测试基本概念</p><ol><li><p>软件测试的定义</p><p>使用人工或自动手段来运行或测试某个系统的过程，其目的在于检验它是否满足规定的需求或是否弄清预期结果与实际结果之间的差别。</p></li><li><p>软件缺陷的定义</p><p>软件缺陷，常常被称为bug。所谓软件缺陷，即计算机软件或程序中存在某种破坏正常运行能力的问题、错误，或者隐藏的功能缺陷。缺陷的存在会导致软件产品在某种程度上不能满足用户的需要。</p><p>标准定义：从产品内部看，缺陷时软件产品的开发或维护过程中存在的错误、毛病等各种问题；从产品外部看，缺陷是系统所需要实现的某种功能的失效或违背。</p></li><li><p>软件缺陷的主要类型</p><p>(1)软件没有是实现产品说明书中要求的功能模块</p><p>(2)软件中出现了产品说明书中指明不应出现的错误</p><p>(3)软件实现了产品说明书中没有提到的功能模块</p><p>(4)软件没有实现产品说明书中没有明确提到但应该实现的目标</p><p>(5)软件难以理解、不易于使用，运行缓慢，或从测试员的角度看，最终用户会认为不好。</p></li><li><p>软件缺陷的级别</p><p>(1)微小的。一些小问题，对功能几乎没有影响，软件产品仍然可以使用</p><p>(2)一般的。不太严重的问题，如次要功能模块丧失、提示信息不够准确、用户界面差、操作时间长等</p><p>(3)严重的。严重错误，指没有实现功能模块或某个特性，主要功能部分丧失、次要功能全部丧失，或致命的错误声明</p><p>(4)致命的。致命的错误，将造成系统崩溃、死机，或造成数据丢失、主要功能完全丧失等</p><p>通常情况下，问题越严重，其处理优先级就越高。</p></li><li><p>软件缺陷的状态</p><p>(1)激活状态：问题没有解决，测试人员新报告的缺陷或者验证后的缺陷仍旧存在</p><p>(2)已修正状态：已经被开发人员检查、修复过的缺陷，通过单元测试，认为已经解决但还没有被测试人员验证</p><p>(3)关闭状态：测试人员经过验证后，确认验证不存在之后的状态</p></li><li><p>软件缺陷的原因</p><p>(1)软件产品说明书</p><p>(2)设计方法</p><p>(3)编写代码</p><p>(4)其他</p><p>比例依次减小</p></li><li><p>软件缺陷修复的代价</p><p>依次递增，如下：</p><p>(1)编制说明书</p><p>(2)设计阶段</p><p>(3)编写代码</p><p>(4)测试</p><p>(5)发布</p></li><li><p>软件测试的分类</p><p>(1)按照开发阶段划分</p><p>​    ①单元测试</p><p>​    ②集成测试</p><p>​    ③系统测试</p><p>​    ④验收测试</p><p>(2)按测试技术划分</p><p>​    ①白盒测试</p><p>​    ②黑盒测试</p><p>​    ③灰盒测试</p><p>(3)按被测软件是否实际运行划分</p><p>​    ①静态测试</p><p>​    ②动态测试</p><p>(4)按照测试实施组织划分</p><p>​    ①开发方测试（α测试)</p><p>​    ②用户测试（β测试）</p><p>​    ③第三方测试</p></li><li><p>软件测试的原则</p><p>（1）完全测试程序是不可能的</p><p>（2）软件测试是有风险的</p><p>（3）测试无法显示潜伏的软件缺陷</p><p>（4）软件缺陷的群集现象</p><p>（5）杀虫剂怪事：软件测试越多，其免疫力越强</p><p>（6）并非所有的软件缺陷都能被修复</p><p>（7）难以描述的软件缺陷</p></li></ol><p>二、黑盒测试用例设计方法</p><ol><li><p>测试用例在软件测试中的作用</p><p>（1）推导测试的实施</p><p>（2）规划测试数据的准备</p><p>（3）编写测试脚本的“设计规格说明书”</p><p>（4）评估测试结果的度量基准</p><p>（5）分析缺陷的标准</p></li><li><p>设计测试用例的步骤</p><p>（1）测试需求分析</p><p>（2）业务流程分析</p><p>（3）测试用例设计</p><p>（4）测试用例评审</p><p>（5）测试用例更新完善</p></li><li><p>等价类划分法</p><ul><li><p>等价类划分法是一种最为常见的黑盒测试方法。</p></li><li><p>其基本实现是把程序的输入域划分为若干个子集，然后从每个子集中选取少量具有代表性的数据作为测试用例。在该子集合中，各个输入数据对于揭示程序中的错误都是等效的</p></li><li><p>等价类可以分为两种：</p><p>（1）有效等价类。指对于程序的规格说明来说，是由合理的、与意义的输入数据构成的集合。主要为了检验程序是否实现了规格说明书中规定的功能和性能</p><p>（2）无效等价类。对规格说明书而言，是由无意义的、不合理的输入数据构成的集合。利用无效等价类中的数据，检验程序对错误输入的处理能力。</p></li><li><p>设计测试用例的步骤</p><p>（1）划分等价类</p><p>（2）建立等价类表，列出所有划分出的等价类，并为每一个等价类规定一个唯一的编号</p><p>（3）从划分出的等价类中按以下原则设计测试用例。设计一个新的测试用例，使其尽可能多地覆盖尚未被覆盖的有效等价类，重复这一步骤，直到所有的有效等价类都被覆盖为止；设计一个新的测试用例，使其仅覆盖一个尚未被覆盖的无效等价类，重复这一步，直到所有的无效等价类都被覆盖为止</p></li></ul></li><li><p>边界值分析法</p><ul><li>边界值分析法用于考察处于等价划分边界或在边界附近的状态。</li><li>通常，软件中边界分为内部边界和外部边界两种。所谓的外部边界是可以在需求规格说明书、设计规格说明书中找到相应的描述的，而内部边界是在程序实现环节存在的、至关重要的界限。</li></ul></li><li><p>因果图法</p><ul><li><p>等价类划分法和边界值分析方法都着重考虑输入条件，但没有考虑输入条件的各种组合、输入条件之间的相互制约关系。</p></li><li><p>因果图是一种利用图解法分析输入的各种组合情况，从而设计测试用例的方法，它适合于检查程序输入条件的各种组合情况。</p></li><li><p>因果图的定义：因果图是一种描述输入和输出之间关系的图，其中出现的基本符号主要有：节点和弧线。</p></li><li><p>因果图描述的原因和结果之间的关系：</p><p>（1）恒等</p><p>（2）非</p><p>（3）或</p><p>（4）与</p></li><li><p>输入条件的约束：</p><p>（1）E约束（异）</p><p>（2）I约束（或）</p><p>（3）O约束（唯一）</p><p>（4）R约束（要求）</p></li><li><p>因果图法的基本步骤</p><p>（1）分析程序规格说明书中描述的语义内容，找出“原因”和“结果”，将其表示成连接各个原因与结果的“因果图”</p><p>（2）由于语法或环境限制，有些原因与原因之间或原因与结果之间的组合情况是不可能出现的，可用记号标明约束或限制条件</p><p>（3）将因果图转换成判定表</p><p>（4）根据判定表中的每一列设计测试用例</p></li></ul></li><li><p>决策表法</p><ul><li><p>决策表，也称判定表。在所有的黑盒测试方法中，基于决策表的测试方法被认为是最严格的的，因为决策表具有逻辑严格性。</p></li><li><p>决策表是分析和表达多逻辑条件下执行不同操作的情况的工具。</p></li><li><p>决策表的结构</p><p>（1）条件桩：列出问题的所有条件</p><p>（2）条件项：针对条件桩给出的条件列出所有可能的取值</p><p>（3）动作桩：列出问题规定的可能采取的操作</p><p>（4）动作项：指出在条件项的各组取值情况下应采取的动作</p><p>（5）规则：贯穿条件项和动作项的一列就是一条规则</p></li><li><p>决策表的化简</p><ul><li>初始决策表的条件项的数目很大，若表中有两条以上规则具有相同的动作，并且在条件项之间存在极为相似的关系，便可以将它们合并。合并后的条件项用符号“—”表示，说明执行的动作与该条件的取值无关，称为无关条件。</li></ul></li></ul></li></ol><p>三、白盒测试用例设计方法</p><ol><li><p>逻辑覆盖测试</p><ul><li>白盒测试方法是把测试对象看作一个打开的盒子，测试人员依据程序内部逻辑结构相关信息，设计或选择测试用例，对程序所有逻辑路径进行测试，通过在不同点检查程序的状态，确定实际的状态是否与预期的状态一致。</li><li>逻辑覆盖测试是以程序内在逻辑结构为基础的测试，重点关注测试覆盖率。包括以下6种类型：语句覆盖、判定覆盖、条件覆盖、判定/条件覆盖、条件组合覆盖和路径覆盖。</li></ul></li><li><p>语句覆盖</p><ul><li>语句覆盖是指设计若干个测试用例，使程序中的每个可执行语句至少执行一次。在保证每条语句都运行的前提下，测试用例应尽量少。在语句覆盖的基础上可以实现程序覆盖，进而是程序块的覆盖。</li><li>语句覆盖是一种较弱的覆盖测试。</li></ul></li><li><p>判定覆盖</p><ul><li>判定覆盖的含义是：设计足够多的测试用例，使程序中的每个判定都至少获得“真值”和“假值”。程序中的判定有：分支判定和循环判定。</li><li>为了表示方便，做到理解上的统一，表示某个条件的真假用$T_i$和$F_i$,表示某个判定的真假使用$TD_i$和$FD_i$</li></ul></li><li><p>条件覆盖</p><ul><li>条件覆盖的含义是:构造一组测试用例，使得每一个判定中每个逻辑条件的可能值至少被满足一次。</li></ul></li><li><p>判定/条件覆盖</p><ul><li>设计足够的测试用例，使得判定中每个条件的所有可能（真/假）至少出现一次，并且每个判定本身的判定结果（真/假）也至少出现一次，即满足判定/条件覆盖的测试用例同时满足条件覆盖和判定覆盖。</li></ul></li><li><p>组合条件覆盖</p><ul><li><p>组合条件覆盖的含义是：设计足够的测试用例，使得每个判定中条件的各种可能组合都至少出现一次。</p></li><li><p>显然，满足组合条件覆盖的测试用例是一定满足判定覆盖、条件覆盖和判定/条件覆盖的。</p></li><li><p>具体的组合策略如下：</p><p>（1）如果某个条件组合只有一种可能性，则优先确立关系</p><p>（2）不可能存在的组合不住要设计测试用例</p><p>（3）除了不可能的情况，所有的条件组合都必须至少出现一次</p></li></ul></li><li><p>路径覆盖</p><ul><li>所谓路径覆盖就是设计足够多的测试用例使每个路径都有可能被执行。</li></ul></li><li><p>基本路径测试</p><ul><li>包括程序控制流图，环形复杂度、独立路径</li></ul></li><li><p>控制流图</p><ul><li><p>在设计程序时，为了更加突出控制流的结构，可对程序流程图进行简化，简化后的流程图称为控制流图。</p></li><li><p>控制流图的构成：</p><ul><li>控制流线</li><li>结点</li></ul></li><li><p>必须用结点表示的情况：</p><p>（1）程序流程图中矩形框表示的处理</p><p>（2）菱形框表示的两个甚至多个出口判断</p><p>（3）多条流线相交的汇合点</p></li></ul></li><li><p>环形复杂度</p><ul><li><p>环形复杂度（圈复杂度）是一种为程序逻辑复杂度提供定量尺度的软件度量。也可将该度量用于基本路径测试方法，它可以提供程序基本集的独立路径数量和确保所有语句至少被执行一次的测试数量上界。</p></li><li><p>计算环形复杂度的方法：</p><p>（1）流图中区域的数量对应于环形复杂度</p><p>（2）给定流图G的环形复杂度为V（G），定义为V(G)=E-N+2,其中，E是流图中边的数量，N是流图中节点的数量</p><p>（3）给定流图G的环形复杂度V(G)，定义为V(G)=P+1,P是流图G中判定结点的数量</p></li></ul></li><li><p>独立路径</p><ul><li>独立路径是指程序中至少引入了一个新的处理语句集合或一个新条件的程序通路，它必须至少包含一条路径在本次定义路径之前不曾用过的边。</li><li>程序的环形复杂度是程序基本路径集合中的独立路径条数，这是确定路径中每个可执行语句至少被执行一次所必需的测试用例数目的上界。</li></ul></li><li><p>代码检查</p><ul><li><p>在实际使用中，静态代码检查比动态测试更有效率，更能快速找到缺陷。</p></li><li><p>静态测试包括代码检查和静态分析两种途径，它可以由人工进行，充分发挥人的逻辑优势，也可以借助软件工具自动进行。代码检查包括<strong>桌面检查、代码审查、代码走查、技术评审</strong>等。</p></li><li><p>主要检查代码的设计是否一致、代码是否遵循标准性和可读性、代码的逻辑表达的正确性，以及代码结构的合理性等。</p></li><li><p>代码评审也称代码复查，是指通过阅读代码来检查源代码与编码标准的符合性以及代码质量的活动。</p></li><li><p>代码评审的目的：</p><p>（1）确保要发布质量可靠的代码，能非常有效地发现所有类型的错误</p><p>（2）作为教学工具帮助开发人员学会何时并且如何应用技术来提高代码的质量、一致性和维护性</p></li><li><p>代码评审是发现缺陷的有效方法。代码评审包括代码审查、代码走查、桌面检查等。</p></li></ul></li><li><p>代码审查</p><ul><li><p>代码审查作为质量保证的一部分，是静态测试的主要手段之一。</p></li><li><p>代码审查的内容：</p><p>（1）编码规范问题</p><p>（2）代码结构问题</p><p>（3）工具、框架使用不当</p><p>（4）实现问题</p><p>（5）测试问题</p></li></ul></li><li><p>代码走查</p><ul><li>代码走查是以小组为单位进行代码阅读的，同样也是一系列规程和错误检查技术的集合。且代码走查也采用了持续1小时~2小时的不间断会议的形式。</li><li>代码走查的任务：就是参与者“使用计算机”。被指定为测试为人员的那个人会带着一些书面的测试用例来参加会议。且在会议期间，每个测试用例都在人们的头脑中进行推演。即把测试数据沿程序的逻辑结构走一遍，并把程序的状态记录以纸上或白板上以供监视。</li></ul></li><li><p>桌面检查</p><ul><li>桌面检查可被视为由担任进行的代码检查或代码走查：由一个人阅读程序，对照错误列表检查程序，对程序推演测试数据。</li></ul></li></ol><p>四、单元测试</p><ol><li><p>单元测试的定义</p><ul><li>单元测试又称模块测试，是最小单位的测试，其依据是详细设计规格说明书，对模块内所有重要的控制路径设计测试用例，以便发现模块内部的错误。</li><li>单元测试多采用白盒测试技术，系统内多个模块可以并行地进行单元测试</li></ul></li><li><p>单元测试的对象</p><ul><li>一般认为，在结构化程序时代，单元测试所说的单元是指函数，在面向对象编程中，单元测试的单元一般是指类。</li><li>但从实践来看，以类作为测试单位，复杂度高、可操作性较差，所以仍然主张以类中的方法作为单元测试的测试单位但可以用一个测试类来组织某个类的所有测试函数</li><li>单元测试不应过分强调面向对象，因为局部代码依然是结构化的。单元测试的工作量较大，简单、实用、高效才是硬道理，</li></ul></li><li><p>单元测试的时间</p><ul><li>单元测试当然是越早越好，通常在编码阶段进行。在源程序代码编制完成、经过评审和验证、确定没有语法错误之后，就可以了开始进行单元测试的测试用例设计</li></ul></li><li><p>单元测试的内容</p><p>（1）模块接口测试</p><p>（2）模块局部数据结构测试</p><p>（3）模块边界条件测试</p><p>（4）模块中所有数日执行通路测试</p><p>（5）模块的各条错误处理通路测试</p><p>模块接口测试是单元测试的基础。只有在数据能正确流入、流出模块的前提下，其他测试才有意义。</p></li><li><p>单元测试的过程</p><p>（1）计划单元测试：确定测试需求，制订测试策略，确定测试所用的资源，创建测试任务的时间表</p><p>（2）设计单元测试：根据单元测试计划设计单元测试模型，制订测试方案，确认测试过程，设计具体的测试用例，创建可重用的测试脚本</p><p>（3）执行单元测试：根据单元测试的方案、用例对软件单元进行测试，验证测试结果并记录测试过程中出现的缺陷</p><p>（4）评估单元测试：对单元测试的结果进行评估，主要从需求覆盖和代码覆盖的角度进行测试完备性的评估</p></li><li><p>单元测试的模型</p><p>在进行单元测试时，如果模块不是独立的程序，需要辅助测试模块，有两种辅助模块：</p><ul><li>驱动模块：所测模块的主程序。它接收测试数据，把这些数据传递给所测试模块，最后再输出测试结果。当被测试模块能完成一定功能时，也可以不要驱动模块。</li><li>桩模块：用来代替所测模块调用的子模块。被测试模块、驱动模块共同构成了一个测试模型</li></ul></li><li><p>执行单元测试</p><p>（1）设置测试环境</p><p>（2）将测试环境初始化，以确保所有构件都处于正确的初始状态</p><p>（3）执行测试过程。需要注意的是，测试过程的执行将随着具体情况而变化：测试方式是自动还是人工，以及必需的测试构件是作为驱动程序还是桩模块。自动测试的测试脚本在执行实施测试步骤的过程中创建。而人工测试则是在“构建测试过程”活动中制定的结构化测试过程。</p></li><li><p>评估单元测试</p><ul><li>测试完备性评估</li><li>代码覆盖率评估</li><li>从覆盖的角度看，。测试应该做到以下覆盖：功能覆盖、输入域覆盖、输出域覆盖、函数交互覆盖和代码执行覆盖</li></ul></li></ol><p>五、集成测试</p><ol><li><p>集成测试的定义</p><ul><li><p>集成测试又称组装测试，是在单元测试的基础上，将所有模块按照设计要求组装成子系统或系统，而进行的测试活动</p></li><li><p>集成测试的目的是确保各单元组合在一起后能够按照既定意图协作运行，并确保增量的行为正确。</p></li><li><p>它所测试内容包括单元间的接口以及集成后的功能，通常使用黑盒测试方法测试集成的功能，并且对以前的集成进行回归测试。</p></li><li><p>集成测试阶段主要检查以下几个方面：</p><p>（1）在把各个模块连接起来的时候，穿越模块接口的数据是否会丢失</p><p>（2）一个模块的功能是否会对另一个模块的功能产生不利的影响</p><p>（3）各个子功能组合起来，能否达到预期要求的父功能</p><p>（4）全局数据结构是否有问题</p><p>（5）单个模块的误差累积起来，是否会被放大，从而达到不能接受的程度</p><p>（6）在单元测试的同时可进行集成测试，发现并排除在模块连接中可能出现的问题，最终构成要求的软件系统</p></li></ul></li><li><p>集成测试的内容</p><ul><li><p>一个产品的开发过程包括了分层的设计和逐步细化的过程，从最初的产品到最小的单元，由于集成的力度不同，一般可以把集成测试划分为三个级别：</p><p>（1）模块内集成测试</p><p>（2）子系统内集成测试（模块）：先测试子系统内的功能模块（不能单独运行的程序），然后将各个功能模块组合起来确认子系统的功能是否达到预期要求</p><p>（3）子系统间集成测试（可执行程序）：测试的单元是子系统之间的接口，这里的子系统是可单独运行的程序或进程。</p></li><li><p>模块和子系统的区别：</p><ul><li>一个完整的软件系统通常包括若干个具有不同功能的子系统。而每个子系统又由多个功能模块组成。</li></ul></li></ul></li><li><p>集成测试的原则</p><p>（1）要测试所有的公共接口，尤其是那些与系统相关联的外部接口，测试的重点是要检查数据的交换、传递和控制管理过程，还包括处理的次数</p><p>（2）必须对关键模块进行充分测试。在集成的过程中应该重点关注一个系统的关键模块。在确定测试需求时，测试人员就要确定系统的关键模块，这些关键模块包含在最希望测试的那些模块中。一般我们将系统中的模块划分成3个等级：高危模块、一般模块、低危模块。一个关键模块应该具有一个或多个下列特性：</p><ul><li>和多个软件需求有关，或与关键功能有关</li><li>处于程序控制结构的顶层</li><li>本身是复杂的或者容易出错的</li><li>含有确定性的性能需求</li><li>被频繁使用的模块</li></ul><p>（3）继承测试应当按一定的层次进行。系统的模块之间是有层次关系的，就像函数之间的相互调用关系。在对系统进行集成时，要按照一定的层次顺序进行集成，避免集成过程中发生错误无法对错误进行定位。</p><p>（4）集成测试的策略选择应当综合考虑质量、成本和进度之间的关系。风险分析贯穿整个集成测试过程中，总的原则是花费最小的成本，取得最大的测试效果</p><p>（5）集成测试应当尽早开始，并以总体设计为基础</p><p>（6）在模块与接口的划分上，测试人员应当和开发人员进行充分沟通</p><p>（7）测试执行结果应当被如实记录</p></li><li><p>集成测试的策略</p><p>（1）非增量式集成策略</p><p>非增量集成，又称大爆炸式集成，采用一步到位的方法来进行集成，又称一次组装或整体拼装。使用该方法进行集成时，首先分别测试每个模块，即对每个模块都进行独立的单元测试。测试通过后，再把所有模块按设计要求组合在一起构成整体，再对这个整体进行测试。</p><p>（2）增量式集成策略</p><p>增量式集成方法又被称为渐增式组装，它的集成时逐步实现的。首先对一个个模块进行模块测试，然后按照某种策略，将这些模块逐步组装成较大的系统，在组装的过程中边连接边测试，以发现连接过程中产生的问题。通过增值逐步组装成为满足要求的软件系统。</p><ul><li><p>自顶向下的集成测试</p><p>自顶向下增量式集成就是按照模块结构图自上而下进行集成</p></li><li><p>自底向上的集成测试</p><p>自底向上的增量式集成就是按照模块结构图自底向上进行组装，首先从模块结构的底层开始，依次往高层次集成。在集成的过程中，不需要再编写桩模块，只需要为被组装模块编写驱动模块。</p></li><li><p>混合增量式集成策略</p><p>也称“三明治”集成，对软件结构中较上层，使用的是“自顶向下”集成；对软件结构中较下层，使用的是“自底向上”继承，将两种策略的优点结合在一起。</p></li></ul></li></ol><p>六、功能测试</p><ol><li><p>系统测试</p><ul><li>系统测试是通过与系统的需求规格做比较，发现软件与系统需求规格不相符或与之矛盾的地方。它将通过确认测试的软件，作为整个基于计算机系统的一个元素，与计算机硬件、外设、某些支持软件、数据和人员等其他系统元素结合起来，在实际运行（使用）环境下，对软件进行系统测试。</li><li>系统测试的依据为需求规格说明书、概要设计说明书和各种规范。通信产品与一般的软件产品不同，其系统测试往往需求依据大量的既定规范；对于海外产品，系统测试依据还包括各个国家自定的规范。</li><li>系统测试包括功能测试、性能测试、压力测试、协议一致性测试、容量测试、安全性测试、恢复性测试、备份测试、UI测试、安装和卸载测试、本地化测试、可用性测试等。</li></ul></li><li><p>功能测试</p><ul><li>功能测试又称正确性测试，就是对产品的各项功能进行验证，根据功能测试用例，逐项测试，检查产品是否达到用户要求的功能或者说检查软件的功能是否符合规格说明。由于正确性是软件最重要的质量因素，所以功能测试也非常重要。做功能测试需要首先明确业务和需求。理解了需求和业务，才知道客户想要系统实现什么。然后按照需求来进行测试，不满足要求的都可以被认为是缺陷。</li></ul></li><li><p>功能测试的策略</p><ul><li>测试需求分析</li><li>指定测试计划</li><li>测试设计和测试用例设计</li><li>测试环境搭建</li><li>测试实施</li><li>缺陷报告</li><li>回归测试</li></ul></li><li><p>功能测试的内容</p><p>功能测试包括对用户界面的测试、对各种操作的测试，对不同的数据输入、逻辑思路、数据输出、存储等的测试。不同的应用系统，功能测试的内容差异很大，但一般都可归为界面、数据、操作、逻辑、接口等几个方面，主要包括：</p><p>（1）程序安装和启动正常，有相应的提示框、适当的错误提示等</p><p>（2）每项功能符合实际要求</p><p>（3）系统的界面清晰、美观；菜单、按钮操作正常、灵活，能处理一些异常操作</p><p>（4）能接受正确的数据输入，对异常数据的输入可以进行提示、容错处理等</p><p>（5）数据的输出结果准确、格式清晰，可以保存和读取</p><p>（6）功能逻辑清楚，符合使用者习惯</p><p>（7）系统的各种状态按照业务流程而变化，并保持稳定</p><p>（8）支持各种应用的环境，能配合多种硬件周边设备，与外部应用系统的接口有效</p><p>（9）软件升级后，能够继续支持旧版本的数据</p></li></ol><p>七、性能测试</p><ol><li><p>性能测试</p><ul><li>性能测试的目的是验证软件系统是否能够达到用户要求的性能指标，同时发现软件系统中出来的性能瓶颈，最后起到优化系统的目的。</li></ul></li><li><p>性能测试的内容</p><p>具体包括以下几个方面：</p><p>（1）评估系统的能力：测试中得到的负荷和响应时间数据可以用于验证软件系统能力是否符合设计要求</p><p>（2）识别系统中的瓶颈：当系统符合被增加到极限水平并继续增加时，可以通过性能指标的变化情况监测系统的瓶颈，从而帮助系统设计者修复系统的瓶颈</p><p>（3）系统调优：重复运行测试，验证调整系统的活动得到了预期的结果，从而改进系统性能</p><p>（4）验证稳定性与可靠性：在一定的负载压力下执行测试一定时间，是评估系统稳定性和可靠性是否满足要求的有效方法</p></li><li><p>性能测试的分类</p><ul><li><p>性能测试类型包括负载测试、压力测试、强度测试、容量测试。通常，性能测试通过自动化的测试工具模拟多种正常、峰值以及异常负载条件来对系统的各项性能指标进行测试，负载测试和压力测试都属于性能测试，两者可以结合进行</p><p>（1）负载测试，是确定在各种工作负载下系统的性能，目标是测试当负载逐渐增加时，系统各项性能指标的变化情况，例如，吞吐量、响应时间、CPU负载、内存使用等，来确定系统的性能。负载测试是一个分析软件应用程序和支撑架构、模拟真实环境的使用，从而来确定能够接受的性能的过程。</p><p>（2）压力测试是通过确定一个系统的瓶颈或者不能接受的性能点，来获得系统能提供的最大服务级别的测试</p><p>（3）疲劳测试是采用系统稳定运行情况下，能够支持的最大并发用户数，持续执行一段时间业务，通过综合分析交易执行指标和资源监控指标来确定系统处理最大工作量强度性能的过程。疲劳强度测试可以采用自动化工具进行测试，也可以手工编写程序测试，其中后者占的比例较大</p><p>（4）容量测试用于确定系统可处理同时在线的最大用户数</p><p>（5）大数据量测试可以分为两种类型：针对某些系统存储、传输、统计、查询等业务进行大数据量的独立数据量测试；与压力性能测试、负载性能测试、疲劳性能测试相结合的综合数据量测试方案。大数据量测试的关键是测试数据的准备，可以依靠工具准备测试数据。</p><p>（6）速度测试目前主要针对关键的，有速度要求的业务进行手工测速度，可以在多次测试的基础上求平均值，可以和工具测试得到的响应时间等指标做对比分析。</p></li></ul></li><li><p>性能计数器</p><ul><li><p>影响一个系统性能的因素主要有：软件因素，包括系统软件、第三方软件等；硬件因素，如内存、磁盘、CPU、网卡等；网络因素，如网络吞吐量、带宽、网络传输速率等。</p></li><li><p>性能计数器是描述服务器或操作系统性能的一些数据指标。</p><p>（1）内存，内存性能计数器主要检查应用程序是否存在内存泄漏</p><p>（2）处理器，监视“处理器”和“系统”对象计数器可以提供关于处理器使用的有价值的信息，帮助测试人员决定是否存在瓶颈</p><p>（3）物理磁盘，磁盘性能</p></li></ul></li><li><p>性能测试流程</p><p>（1）性能测试的计划</p><p>（2）性能测试的设计</p><p>（3）性能测试的执行</p><p>（4）测试结果的分析</p></li></ol><p>八、本地化测试</p><ol><li><p>本地化测试的定义</p><ul><li><p>本地化测试是对软件进行本地化过程中记性的测试</p></li><li><p>所谓本地化就是将软件版本语言进行就更该。</p></li><li><p>本地化测试的对象是软件的本地化版本</p></li><li><p>本地化测试目的是测试待定目标区域设置的软件本地化质量</p></li><li><p>本地化测试的环境是在本地化的操作系统上安装本地化的软件。</p></li><li><p>从测试方法上可以分为：基本功能测试、安装或卸载测试、当地区域的软硬件兼容测试。</p></li><li><p>测试的内容主要包括软件本地化后的界面布局和软件翻译的语言质量，包含软件、文档和在线帮助等部分</p></li><li><p>本地化测试的目的首先是保证本地化的软件与源语言软件具有相同的功能和性能。其次还要保证本地化的软件在语言、文化、传统观念等方面符合当地用户的习惯。</p></li><li><p>本地化测试过程中的测试工作集中在：</p><p>（1）易受本地化影响的方面，如用户界面</p><p>（2）区域性或区域设置特定的、语言特定的和地区特定的方面</p></li></ul></li><li><p>本地化测试与其他测试的区别</p><ul><li>软件本地化测试的测试对象是本地化的软件，需要在本地化的操作系统上进行。虽然本地化的软件是基于源程序软件创建的，但与其他测试的测试内容和重点有很大不同。</li></ul></li></ol><div class="table-container"><table><thead><tr><th>不同点</th><th>描述</th></tr></thead><tbody><tr><td>测试顺序</td><td>首先要对源程序软件进行测试，然后再创建本地化软件，测试本地化软件</td></tr><tr><td>测试内容和重点</td><td>源程序软件主要测试功能和性能，结合软件界面的测试；本地化软件的测试，更注重因本地化引起的错误；例如，翻译是否正确，本地化的界面是否美观、本地化后的功能是否与源语言软件保持一致</td></tr><tr><td>测试环境</td><td>源程序软件测试通常在源语言的操作系统上进行；本地化软件在本地化的操作系统上进行</td></tr></tbody></table></div><ol><li><p>本地化测试的类型</p><p>（1）导航测试，是为了降低软件本地化的风险而进行的一种本地化测试</p><p>（2）可接受性测试，也被称为冒烟测试，是指对编译的软件本地化版本的主要特征进行基本测试，从而确定版本是否满足详细测试的条件。</p><p>（3）语言质量测试，是软件本地化测试的重要组成部分，贯穿于本地化项目的各个阶段。语言质量测试的主要内容是软件界面和在线帮助等文档的翻译质量，包括正确性，完整性，专业性和一致性。</p><p>（4）用户界面测试，也被称为外观测试，主要是对软件的界面文字和控件布局进行测试</p><p>（5）功能测试，原始语言开发的软件的功能测试主要测试软件的各项功能是否被实现以及是否正确，而本地化软件的功能测试主要是测试软件经过本地化后，软件的功能是否与源软件一致，是否存在因软件本地化而产生的功能错误</p></li><li><p>本地化软件缺陷的分类</p><ul><li><p>核心软件缺陷</p><p>（1）源语言功能缺陷</p><p>（2）源语言国际化缺陷</p></li><li><p>本地化缺陷</p><p>（1）语言质量缺陷</p><p>（2）用户界面缺陷</p><p>（3）本地化功能缺陷</p></li></ul></li><li><p>本地化测试的流程</p><p>（1）测试规划</p><p>（2）测试设计</p><p>（3）测试实施</p><p>（4）配置管理</p><p>（5）测试管理</p></li><li><p>本地化测试工程师</p><ul><li><p>基础技能</p><p>（1）安装和配置常用操作系统的知识</p><p>（2）计算机网络基础知识</p><p>（3）通用软件的使用知识</p><p>（4）良好的语言技能</p></li><li><p>专业基础知识</p><p>（1）软件本地化或国际化的基本知识</p><p>（2）软件本地化工程的基础知识</p></li><li><p>职业素质</p><p>（1）解决问题的专业态度和创新能力</p><p>（2）主动迅速学习新知识的能力</p><p>（3）执著敬业和团队合作能力</p><p>（4）良好的书面和口头交流技能</p><p>（5）承受压力的能力</p></li></ul></li></ol><p>九、软件测试管理</p><ol><li><p>缺陷生命周期</p><p>（1）新建：当缺陷被第一次递交的时候，它的状态即为“新建”。这也就是说缺陷未被确认其是否真正是一个缺陷</p><p>（2）打开：在测试者提交一个缺陷后，测试组长确认其确实为一个缺陷的时候，会把状态置为“打开”</p><p>（3）分配：一旦缺陷被测试经理置为“打开”，再把缺陷交给相应的开发人员或开发组。这时缺陷状态变更为“分配”</p><p>（4）测试：当开发人员修复缺陷后，缺陷提交给测试组进行新一轮的测试，在开发人员公布以修复缺陷的程序之前，缺陷状态被置为“测试”。这时表明缺陷已经被修复并已经提交给了测试组</p><p>（5）已确认：当缺陷被修复后就会被置为“测试”，测试员会执行测试。如果缺陷不再出现，这就证明缺陷被修复了的同时其状态被置为“已确认”</p><p>（6）延期：延期状态被置为“延期”意味着，缺陷将会在下一个版本中被修复</p><p>（7）重新打开：如果缺陷被开发人员修复后，问题仍然存在，测试人员会把缺陷状态置为“重新打开”。缺陷即将再次穿越其生命周期</p><p>（8）重复：如果同一个缺陷被重复提交或者两个缺陷表明的意思相同，那么这个缺陷状态将会被置为“重复”提交</p><p>（9）拒绝：如果开发人员不认为其实一个缺陷，会拒绝此缺陷，缺陷状态被置为“拒绝”</p><p>（10）关闭：当缺陷被修复后，测试人员会对其进行测试。如果测试人员认为缺陷不存在了，会把缺陷状态置为“关闭”，。这个状态意味着缺陷已被修复，通过了测试并且核实确实如此</p></li><li><p>缺陷报告的编写</p><p>（1）清晰地描述缺陷</p><p>（2）使用简洁的语言</p><p>（3）重现的步骤和数据</p><p>（4）提供参考信息</p><p>（5）抓屏截图</p></li><li><p>团队管理</p><p>（1）组织结构</p><ul><li>基于技能的组织模式</li><li>基于测试流程的组织模式</li><li>基于项目的组织模式</li></ul><p>（2）素质要求</p><ul><li>踏实细心和积极主动</li><li>怀疑一切</li><li>协作和团队感</li><li>自我提高和总结的能力</li></ul><p>（3）激励方法</p><ul><li>表扬和奖励</li><li>信任的力量</li><li>提高士气<ul><li>薪水</li><li>职务</li><li>工作时间</li><li>培训机会</li></ul></li></ul></li><li><p>风险管理</p><p>（1）需求风险</p><p>（2）人员风险</p><p>（3）环境风险</p><p>（4）回归风险</p><p>（5）测试资源</p><p>（6）需求变更</p><p>（7）用例质量</p><p>（8）标准差异</p><p>（9）测试工具</p></li><li><p>过程管理</p><p>（1）测试需求分析</p><ul><li>测试需求的依据与收集</li><li>测试需求的分析</li><li>测试需求的优先级</li></ul><p>（2）测试计划</p><p>（3）测试设计</p><p>（4）测试开发</p><p>（5）测试执行</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;一、软件测试基本概念&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;软件测试的定义&lt;/p&gt;
&lt;p&gt;使用人工或自动手段来运行或测试某个系统的过程，其目的在于检验它是否满足规定的需求或是否弄清预期结果与实际结果之间的差别。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;软件缺陷的定义&lt;/p&gt;
&lt;p&gt;软件
      
    
    </summary>
    
      <category term="软件测试" scheme="http://wanqbin.xyz/categories/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/"/>
    
    
      <category term="软件测试" scheme="http://wanqbin.xyz/tags/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>计算机操作系统（第四版）习题四解答</title>
    <link href="http://wanqbin.xyz/2019/06/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC%E5%9B%9B%E7%89%88%EF%BC%89%E4%B9%A0%E9%A2%98%E5%9B%9B%E8%A7%A3%E7%AD%94/"/>
    <id>http://wanqbin.xyz/2019/06/22/计算机操作系统（第四版）习题四解答/</id>
    <published>2019-06-22T13:01:00.000Z</published>
    <updated>2019-06-22T13:07:56.872Z</updated>
    
    <content type="html"><![CDATA[<ol><li><h2 id="为什么要配置层次式存储器？"><a href="#为什么要配置层次式存储器？" class="headerlink" title="为什么要配置层次式存储器？"></a>为什么要配置层次式存储器？</h2><ul><li>设置多个存储器可以使存储器两端的硬件能并行工作；</li><li>采用多级存储系统，特别是Cache技术，是减轻存储器带宽对系统性能影响的最佳结构方案；</li><li>在微处理机内部设置各种缓冲存储器，减轻对存储器存取的压力</li><li>增加CPU中寄存器数量，大大缓解翠存储器压力</li></ul></li><li><h2 id="可采用哪几种方式将程序装入内存？它们分别适用于何种场合？"><a href="#可采用哪几种方式将程序装入内存？它们分别适用于何种场合？" class="headerlink" title="可采用哪几种方式将程序装入内存？它们分别适用于何种场合？"></a>可采用哪几种方式将程序装入内存？它们分别适用于何种场合？</h2><ul><li><p>绝对装入方式</p><p>只适用于单道程序环境</p></li><li><p>可重定位装入方式</p><p>适用于多道程序环境</p></li><li><p>动态运行时装入方式</p><ul><li>用于多道程序环境</li><li>不允许程序运行时在内存中移动位置</li></ul></li></ul></li><li><h2 id="何谓静态链接？静态链接时需要解决两个什么问题？"><a href="#何谓静态链接？静态链接时需要解决两个什么问题？" class="headerlink" title="何谓静态链接？静态链接时需要解决两个什么问题？"></a>何谓静态链接？静态链接时需要解决两个什么问题？</h2><ul><li>静态链接是指在程序运行之前，先将各目标模块及它们所需的库函数链接成一个完整的装配模块，以后不再拆开。</li><li>需要解决为问题是：<ul><li>对相对地址进行修改</li><li>变换外部调用符号</li></ul></li></ul></li><li><h2 id="何谓装入时动态链接？装入时动态链接方式有何优点？"><a href="#何谓装入时动态链接？装入时动态链接方式有何优点？" class="headerlink" title="何谓装入时动态链接？装入时动态链接方式有何优点？"></a>何谓装入时动态链接？装入时动态链接方式有何优点？</h2><ul><li>装入时动态链接是指将用户源程序编译后得到的一组目标模块，在装入内存时，采用边装入边链接的链接方式。</li><li>优点：<ul><li>便于修改和更新</li><li>便于实现对目标模块的共享</li></ul></li></ul></li><li><h2 id="何谓运行时动态链接？运行时动态链接又何优点？"><a href="#何谓运行时动态链接？运行时动态链接又何优点？" class="headerlink" title="何谓运行时动态链接？运行时动态链接又何优点？"></a>何谓运行时动态链接？运行时动态链接又何优点？</h2><ul><li>运行时动态链接是将对某些模块的链接推迟到程序执行时才运行。</li><li>优点：<ul><li>加快程序的装入过程</li><li>节省大量的内存空间</li></ul></li></ul></li><li><h2 id="在动态分区分配方式中，应如何将各空闲分区链接成空闲分区链？"><a href="#在动态分区分配方式中，应如何将各空闲分区链接成空闲分区链？" class="headerlink" title="在动态分区分配方式中，应如何将各空闲分区链接成空闲分区链？"></a>在动态分区分配方式中，应如何将各空闲分区链接成空闲分区链？</h2><p>在每个分区的起始部分设置一些用于控制分区分配的信息，以及用于链接各分区所用的前向指针，在分区尾部则设置一后向指针。通过前、后向链接指针，可将所有的空闲分区链接成一个双向链。</p></li><li><h2 id="为什么要引入动态重定位？如何实现？"><a href="#为什么要引入动态重定位？如何实现？" class="headerlink" title="为什么要引入动态重定位？如何实现？"></a>为什么要引入动态重定位？如何实现？</h2><ul><li><p>在程序执行的过程中，每当访问指令或数据时，将要访问的程序或数据的逻辑地址转换成物理地址，所以引入了动态重定位。</p></li><li><p>实现方法</p><p>在系统中增设一个重定位寄存器，用它来存放程序（数据）在内存中的起始地址。程序在执行时，真正访问的内存地址是相对地址与重定位寄存器中的地址相加而形成的。</p></li></ul></li><li><h2 id="什么是基于顺序搜索的动态分区分配算法？它可分为哪几种？"><a href="#什么是基于顺序搜索的动态分区分配算法？它可分为哪几种？" class="headerlink" title="什么是基于顺序搜索的动态分区分配算法？它可分为哪几种？"></a>什么是基于顺序搜索的动态分区分配算法？它可分为哪几种？</h2><ul><li>为了实现动态分区分配，通常是将系统中的空闲分区链接成一个链。所谓顺序搜索，是指依次搜索空闲分区链上的空闲分区，去寻找一个其大小能满足要求的分区。</li><li>基于顺序搜索的动态分区分配算法可分为：<ul><li>首次适应算法</li><li>循环首次适应算法</li><li>最佳适应算法</li><li>最坏适应书房</li></ul></li></ul></li><li><h2 id="在采用首次适应算法回收内存时，可能出现哪几种情况？应怎样处理？"><a href="#在采用首次适应算法回收内存时，可能出现哪几种情况？应怎样处理？" class="headerlink" title="在采用首次适应算法回收内存时，可能出现哪几种情况？应怎样处理？"></a>在采用首次适应算法回收内存时，可能出现哪几种情况？应怎样处理？</h2><p>可能会出现四种情况：</p><ul><li>回收区与插入点前的一个分区$F_1$相邻接。将回收区与插入点的前一分区合并，不必再为回收分区分配新表项，而只需修改其前一分区$F_1$的大小</li><li>回收分区与插入点后的一空闲分区$F_2$相邻接。将两个分区合并，形成新的分区，但用回收区的首址作为新空闲区的首址，大小为两者之和</li><li>回收区同时与插入点的前、后两个分区邻接。将三个分区合并，使用$F_1$的表项和$F_1$的首址，取消$F_2$的表项，大小为三者之和。</li></ul></li><li><h2 id="什么是基于索引搜索的动态分区分配算法？它可分为哪几种？"><a href="#什么是基于索引搜索的动态分区分配算法？它可分为哪几种？" class="headerlink" title="什么是基于索引搜索的动态分区分配算法？它可分为哪几种？"></a>什么是基于索引搜索的动态分区分配算法？它可分为哪几种？</h2><ul><li>基于顺序搜索的动态分区分配算法，比较适用于不太大的系统。当系统很大时，系统中的内存分区可能会很多，相应的空闲分区链就很长，这是采用顺序搜索方法可能会很慢。为了提高搜索空闲分区的速度，在大、中型系统中往往会采用基于索引搜索的动态分区分配算法。</li><li>基于索引搜索的动态分区分配算法可分为：<ul><li>快速适应算法</li><li>伙伴系统</li><li>哈希算法</li></ul></li></ul></li><li><h2 id="令-buddy-k-x-为大小为-2-k-、地址为x的块的伙伴系统地址，试写出-buddy-k-x-的通用表达式"><a href="#令-buddy-k-x-为大小为-2-k-、地址为x的块的伙伴系统地址，试写出-buddy-k-x-的通用表达式" class="headerlink" title="令$buddy_k$(x)为大小为$2^k$、地址为x的块的伙伴系统地址，试写出$buddy_k$(x)的通用表达式"></a>令$buddy_k$(x)为大小为$2^k$、地址为x的块的伙伴系统地址，试写出$buddy_k$(x)的通用表达式</h2><p><img src="/2019/06/22/计算机操作系统（第四版）习题四解答/11.png" alt="题解"></p></li><li><h2 id="分区存储管理中常用哪些分配策略？比较它们的优缺点？"><a href="#分区存储管理中常用哪些分配策略？比较它们的优缺点？" class="headerlink" title="分区存储管理中常用哪些分配策略？比较它们的优缺点？"></a>分区存储管理中常用哪些分配策略？比较它们的优缺点？</h2><ul><li>首次适应算法<ul><li>保留了高址部分的大空闲区，有利于后来的大型作业分配</li><li>地址部分不断被划分，留下很多难以利用的小空闲区，每次查找都从地址开始增加了系统开销</li></ul></li><li>循环首次适应算法<ul><li>内存空闲分区分布均匀，减少了查找系统开销</li><li>缺乏大空闲分区，导致不能装入大型作业</li></ul></li><li>最佳适应算法<ul><li>每次分配给文件的都是最合适该文件大小的分区，内存中留下了很多难以利用的小空闲区</li></ul></li><li>最坏适应算法<ul><li>剩下空闲分区不至于太小，产生碎片的可能性最小，对中、小型作业有利</li><li>存储器中缺乏大空闲区，对大型文件分区分配不利</li><li>查找效率很高</li></ul></li></ul></li><li><h2 id="为什么要引入对换？对换可分为哪几种类型？"><a href="#为什么要引入对换？对换可分为哪几种类型？" class="headerlink" title="为什么要引入对换？对换可分为哪几种类型？"></a>为什么要引入对换？对换可分为哪几种类型？</h2><ul><li>在多道程序环境下，一方面，在内存中的某些进程由于某花时间尚未发生而被阻塞运行，但它却占用了大量的内存空间，甚至有时有可能出现在内存中所有进程都被阻塞，而没有可以运行的进程，另一方面，却有着很多作业，因两次了空间不足，一直驻留在外存上，而不能进入内存运行。为了解决这一问题，系统引入了对换。<ul><li>对换的类型<ul><li>整体对换</li><li>页面（分段）对换</li></ul></li></ul></li></ul></li><li><h2 id="对文件区管理的目标和对对换空间管理的目标有何不同？"><a href="#对文件区管理的目标和对对换空间管理的目标有何不同？" class="headerlink" title="对文件区管理的目标和对对换空间管理的目标有何不同？"></a>对文件区管理的目标和对对换空间管理的目标有何不同？</h2><ul><li><p>对文件区管理的主要目标：</p><p>提高文件存储空间的利用率，然后才是提高对文件的访问速度。因此，对文件区空间的管理采取离散分配方式</p></li><li><p>对对换空间管理的目标：</p><p>提高进程换入和换出的速度，然后才是提高文件存储空间的利用率。为此，对对换空间的管理采取连续分配方式，较少考虑外存中的碎片问题</p></li></ul></li><li><h2 id="为实现对换，系统应具备哪几方面的功能？"><a href="#为实现对换，系统应具备哪几方面的功能？" class="headerlink" title="为实现对换，系统应具备哪几方面的功能？"></a>为实现对换，系统应具备哪几方面的功能？</h2><ul><li>对换空间管理</li><li>进程换入</li><li>进程换出</li></ul></li><li><h2 id="在以进程为单位进行对换时，每次是否都将整个进程换出？为什么？"><a href="#在以进程为单位进行对换时，每次是否都将整个进程换出？为什么？" class="headerlink" title="在以进程为单位进行对换时，每次是否都将整个进程换出？为什么？"></a>在以进程为单位进行对换时，每次是否都将整个进程换出？为什么？</h2><p>在以进程为单位进行对换时，并非每次都将整个进程换出，这是因为：</p><ul><li>从结构上讲，进程是由程序段、数据段和进程控制块组成的，其中进程控制块中总有部分或全部常驻内存，不被换出</li><li>程序段和数据段可能正在被若干进程共享，此时它们也不能换出</li></ul></li><li><h2 id="基于离散分配时所用的基本单位不同，可将离散分配分为哪几种？"><a href="#基于离散分配时所用的基本单位不同，可将离散分配分为哪几种？" class="headerlink" title="基于离散分配时所用的基本单位不同，可将离散分配分为哪几种？"></a>基于离散分配时所用的基本单位不同，可将离散分配分为哪几种？</h2><ul><li>分页存储管理方式</li><li>分段存储管理方式</li><li>段页式存储管理方式</li></ul></li><li><h2 id="什么是页面？什么是物理块？页面的大小应如何确定？"><a href="#什么是页面？什么是物理块？页面的大小应如何确定？" class="headerlink" title="什么是页面？什么是物理块？页面的大小应如何确定？"></a>什么是页面？什么是物理块？页面的大小应如何确定？</h2><ul><li>页面。分页存储管理将进程的逻辑地址空间分为若干个页，并为各页加以编号。</li><li>物理块：将内存中的物理地址空间分层若干个块</li><li>在分页系统中，若选择过小的页面大小，虽然一方面可以减轻碎片，起到减少内存碎片总空间的作用，有利于内存利用率的提高，但另一方面却会造成每个进程占用较多的页面，从而导致进程的页表过长，占用大量内存。此外，还会降低换进换出的效率。然而，页面选择过大，虽然可以减少页表的长度，提高页面换进换出的速度，但却又会使页内碎片增大。因此，页面的大小应选择适中，且页面大小应是2的幂，通常为1KB-8KB。</li></ul></li><li><h2 id="什么是页表？页表的作用是什么？"><a href="#什么是页表？页表的作用是什么？" class="headerlink" title="什么是页表？页表的作用是什么？"></a>什么是页表？页表的作用是什么？</h2><ul><li>在分页系统中，允许将进程的各个页面离散地存储在内存的任一地址块中，为了保证进程仍然能够正确地运行，即能在内存中找到每个页面所对应的物理块，系统又为每个进程建立了一张页面映像表，简称页表。</li><li>页表的作用是实现从页号到物理块号的地址映射</li></ul></li><li><h2 id="为实现分页存储管理，需要哪些硬件支持？"><a href="#为实现分页存储管理，需要哪些硬件支持？" class="headerlink" title="为实现分页存储管理，需要哪些硬件支持？"></a>为实现分页存储管理，需要哪些硬件支持？</h2><ul><li>页表寄存器</li><li>地址变换机构</li><li>联想寄存器</li></ul></li><li><h2 id="在分页系统中是如何实现地址变换的？"><a href="#在分页系统中是如何实现地址变换的？" class="headerlink" title="在分页系统中是如何实现地址变换的？"></a>在分页系统中是如何实现地址变换的？</h2><p>&emsp;&emsp;当进程要访问某个逻辑地址中的数据时，分页地址变换机构会自动地将有效地址分为页号和页内地址两部分，再以页号为索引去检索页表。查找操作由硬件执行。在执行检索之前，先将页号与页表长度进行比较，如果页号大于或等于页表长度，则表示本次所访问的地址已超越进程的地址空间。于是，这一错误将被系统发现，并产生一地址越界中断。</p><p>&emsp;&emsp;若未出现越界错误，则将页表始址与页号和页表项长度的乘积相加，便得到该表项在页表中的位置，于是可从中得到该页的物理块号，将之装入物理地址寄存器中。与此同时，再将有效地址寄存器中的页内地址送入物理地址寄存器的块内地址字段中。这样便完成了从逻辑地址到物理地址的变换。</p></li><li><h2 id="具有快表时是如何实现地址变换的？"><a href="#具有快表时是如何实现地址变换的？" class="headerlink" title="具有快表时是如何实现地址变换的？"></a>具有快表时是如何实现地址变换的？</h2><p>&emsp;&emsp;在CPU给出有效地址后，由地址变换机构自动地将页号P送入高速缓冲寄存器，并将此页号与高速缓存中的所有页号进行比较，若其中有与此相匹配的页号，便表示所要访问的页表项在快表中。于是，可直接从快表中读出该页所对应的物理块号，并送到物理地址寄存器中。</p><p>&emsp;&emsp;若在快表中未找到对应的页表项，则还须再访问内存中的页表，找到后，把从页表项中读出的物理块号送往地址寄存器；同时，再将此页表项存入快表的一个寄存器单元中。但如果联想寄存器已满，则OS必须找到一个老的且已被认为是不再需要的页表项，将它换出。</p></li><li><h2 id="较详细地说明引入分段存储管理是为了满足用户哪几方面的需要。"><a href="#较详细地说明引入分段存储管理是为了满足用户哪几方面的需要。" class="headerlink" title="较详细地说明引入分段存储管理是为了满足用户哪几方面的需要。"></a>较详细地说明引入分段存储管理是为了满足用户哪几方面的需要。</h2><ul><li>方便编程。用户通常把自己的作业按照逻辑关系划分为若干段，每段都从0 编址，并有自己名字和长度。因此，希望要访问的逻辑地址是由段名和段内偏移量决定。</li><li>信息共享。在实现对程序和数据的共享时，是以信息逻辑单位为基础。分页系统中的页是存放信息的物理单位，无完整意义，不便于共享；段是信息的逻辑单位。为了实现段的共享，希望存储管理能与用户程序分段的组织方式相适应。</li><li>信息保护。对信息的逻辑单位进行保护，分段能更有效方便地实现信息保护功能。</li><li>动态增长。在实际应用中，有些段特别是数据段，在使用过程中会不断增长，事先又无法确切知道增长多少。分段存储管理方式能较好解决这个问题。</li><li>动态链接。运行时先将主程序对应的目标程序装入内存并启动运行，运行过程中又需要调用某段时，才将该段调入内存链接。所以动态链接也要求以段作为管理单位。</li></ul></li><li><h2 id="在具有快表的段页式存储管理方式中，如何实现地址变换？"><a href="#在具有快表的段页式存储管理方式中，如何实现地址变换？" class="headerlink" title="在具有快表的段页式存储管理方式中，如何实现地址变换？"></a>在具有快表的段页式存储管理方式中，如何实现地址变换？</h2><p>&emsp;在CPU给出有效地址后，由地址变换机构自动地将页号P送入高速缓冲寄存器，并将此页号与高速缓存中的所有页号进行比较，若其中有与此相匹配的页号，便表示所要访问的页表项在快表中。于是，可直接从快表中读出该页所对应的物理块号，并送到物理地址寄存器中。</p><p>&emsp;&emsp;若在快表中未找到对应的页表项，则还须再访问内存中的页表，找到后，把从页表项中读出的物理块号送往地址寄存器；同时，再将此页表项存入快表的一个寄存器单元中。但如果联想寄存器已满，则OS必须找到一个老的且已被认为是不再需要的页表项，将它换出。</p></li><li><h2 id="为什么说分段系统比分页系统更易于实现信息的共享和保护？"><a href="#为什么说分段系统比分页系统更易于实现信息的共享和保护？" class="headerlink" title="为什么说分段系统比分页系统更易于实现信息的共享和保护？"></a>为什么说分段系统比分页系统更易于实现信息的共享和保护？</h2><ul><li>分页系统的每个页面是分散存储的，为了实现信息共享和保护，页面之间需要一一对应，为此需要建立大量的页表项；</li><li>而分段系统的每个段都从0 编址，并采用一段连续的地址空间，在实现共享和保护时，只需为要共享和保护的程序设置一个段表项，将其中的基址与内存地址一一对应就能够实现。</li></ul></li><li><h2 id="分页和分段存储管理有何区别？"><a href="#分页和分段存储管理有何区别？" class="headerlink" title="分页和分段存储管理有何区别？"></a>分页和分段存储管理有何区别？</h2><ul><li>页是信息的物理单位。采用分页存储管理方式是为了实现离散分配方式，以消减内存的外零头，提高内存的利用率。段则是信息的逻辑单位，它通常包含的是一组意义相对完整的信息。分段的目的主要在于能更好地满足用户的需要。</li><li>页的大小固定且由系统决定。在采用分页存储管理方式的系统中，在硬件结构上就把用户程序的逻辑地址划分为页号和页内地址两部分。而段的长度却是不固定的，决定于用户所编写的程序，通常由编译程序在对源程序进行编译时，根据信息的性质来划分</li><li>分页的用户程序地址空间是一维的。分页完全是系统的行为，故在分页系统中，用户程序的地址是属于单一的线性地址空间。而段式用户的行为，故在分段系统中，用户程序的地址空间是二维的。</li></ul></li><li><h2 id="试全面比较连续分配和离散分配方式"><a href="#试全面比较连续分配和离散分配方式" class="headerlink" title="试全面比较连续分配和离散分配方式"></a>试全面比较连续分配和离散分配方式</h2><ul><li>连续分配是指为一个用户程序分配一个连续的地址空间，包括单一和分区两种分配方式。单一方式将内存分为系统区和用户区，最简单且只用于单用户单任务操作系统：分区方式分为固定分区和动态分区。</li><li>离散分配方式分为分页、分段和段页式存储管理。分页式存储管理旨在提高内存利用率，分段时存储管理旨在满足用户的需要，段页式存储管理则是将两者结合起来，具有分段系统便于实现、可分享、易于保护和动态链接等优点，又能像分页系统一样，很好地解决外部碎片及为各段可离散分配内存等问题，是比较有效的存储管理方式。</li></ul></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;&lt;h2 id=&quot;为什么要配置层次式存储器？&quot;&gt;&lt;a href=&quot;#为什么要配置层次式存储器？&quot; class=&quot;headerlink&quot; title=&quot;为什么要配置层次式存储器？&quot;&gt;&lt;/a&gt;为什么要配置层次式存储器？&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;设置多个存储器可以使存
      
    
    </summary>
    
      <category term="操作系统" scheme="http://wanqbin.xyz/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="习题解答" scheme="http://wanqbin.xyz/tags/%E4%B9%A0%E9%A2%98%E8%A7%A3%E7%AD%94/"/>
    
      <category term="存储器管理" scheme="http://wanqbin.xyz/tags/%E5%AD%98%E5%82%A8%E5%99%A8%E7%AE%A1%E7%90%86/"/>
    
      <category term="对换" scheme="http://wanqbin.xyz/tags/%E5%AF%B9%E6%8D%A2/"/>
    
      <category term="分页存储管理方式" scheme="http://wanqbin.xyz/tags/%E5%88%86%E9%A1%B5%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86%E6%96%B9%E5%BC%8F/"/>
    
      <category term="分段存储管理方式" scheme="http://wanqbin.xyz/tags/%E5%88%86%E6%AE%B5%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86%E6%96%B9%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>计算机操作系统（第四版）习题二解答</title>
    <link href="http://wanqbin.xyz/2019/06/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC%E5%9B%9B%E7%89%88%EF%BC%89%E4%B9%A0%E9%A2%98%E4%BA%8C%E8%A7%A3%E7%AD%94/"/>
    <id>http://wanqbin.xyz/2019/06/20/计算机操作系统（第四版）习题二解答/</id>
    <published>2019-06-19T22:54:00.000Z</published>
    <updated>2019-06-19T22:57:04.671Z</updated>
    
    <content type="html"><![CDATA[<ol><li><h4 id="为什么程序并发执行会产生间断性特征？"><a href="#为什么程序并发执行会产生间断性特征？" class="headerlink" title="为什么程序并发执行会产生间断性特征？"></a>为什么程序并发执行会产生间断性特征？</h4><p>程序在并发执行时，由于它们共享系统管理资源，以及为万分同一项任务而相互合作，致使在这些并发执行的程序之间形成了相互制约的关系，而相互制约将导致程序具有“执行——暂停——执行”这种间断性的活动规律，所以说程序并发执行会产生间断性特征。                                                                                                                                                   </p></li><li><h4 id="程序并发执行时为什么会失去封闭性和可再现性？"><a href="#程序并发执行时为什么会失去封闭性和可再现性？" class="headerlink" title="程序并发执行时为什么会失去封闭性和可再现性？"></a>程序并发执行时为什么会失去封闭性和可再现性？</h4><p>当系统中存在着多个可以并发执行的程序时，系统中的各种资源将为它们所共享，而这些资源的状态也由这些程序来改变，致使其中任一程序在运行时，其环境都必然会受到其他程序的影响，显然，程序的运行已失去了封闭性。而失去封闭性会导致程序失去可再现性。</p></li><li><h4 id="在操作系统中为什么要引入进程的概念？它会产生什么样的影响"><a href="#在操作系统中为什么要引入进程的概念？它会产生什么样的影响" class="headerlink" title="在操作系统中为什么要引入进程的概念？它会产生什么样的影响?"></a>在操作系统中为什么要引入进程的概念？它会产生什么样的影响?</h4><p>在多道程序环境下，程序的执行属于并发执行，此时它们失去其封闭性，并且具有间断性，以及其运行结果不可再现。这些决定了通常的程序是不能参与并发执行的，否则，程序的运行也就失去了意义。<code>为了能使程序并发执行，并且可以对并发执行的程序加以描述和控制，才操作系统中引入了进程概念.</code></p></li><li><h4 id="试从动态性、并发性和独立性上比较进程和程序"><a href="#试从动态性、并发性和独立性上比较进程和程序" class="headerlink" title="试从动态性、并发性和独立性上比较进程和程序"></a>试从动态性、并发性和独立性上比较进程和程序</h4><p>进程和程序是两个截然不同的概念。</p><ul><li>动态性。进程的实质是进程实体的执行过程，因此，<code>动态性是进程的最基本的特征</code>。表现为“由创建而产生，由调度而执行，由撤销而消亡”，<code>进程具有一定的生命期</code>；而程序则只是一组有序指令的集合，并存放于某种介质上，其本身并不具有活动的含义，是静态实体。</li><li>并发性是进程的重要特征，同时也是OS的重要特征；而<code>程序是不能参与并发执行的</code>。</li><li>独立性是指进程实体是一个能独立运行、独立获得资源和独立接受调度的基本单位（传统OS中）；而对于未建立PCB的程序来说，它不能作为一个独立单位参与运行。</li></ul></li><li><h4 id="试说明PCB的作用具体表现在哪几个方面，为什么说PCB是进程存在的唯一标志？"><a href="#试说明PCB的作用具体表现在哪几个方面，为什么说PCB是进程存在的唯一标志？" class="headerlink" title="试说明PCB的作用具体表现在哪几个方面，为什么说PCB是进程存在的唯一标志？"></a>试说明PCB的作用具体表现在哪几个方面，为什么说PCB是进程存在的唯一标志？</h4><p>PCB作为进程实体的一部分，记录了操作系统所需的，用于描述进程当前情况以及管理进程运行的全部信息，是操作系统中最重要的<code>记录型数据结构</code>。</p><p>作用是使一个在多道陈存储环境下不能独立运行的程序（包括数据）成为一个能独立运行的基本单位，一个能与其他进程并发执行的进程。</p><p>当一个程序（含数据）配置了PCB后，就表示它已是一个能在多道程序环境下独立运行的、合法的基本单位，也就具有取得OS服务的权利。系统时通过PCB感知进程的存在的，所以，PCB已成为进程存在的唯一标志。</p></li><li><h4 id="PCB提供了进程管理和进程调度所需要的哪些信息？"><a href="#PCB提供了进程管理和进程调度所需要的哪些信息？" class="headerlink" title="PCB提供了进程管理和进程调度所需要的哪些信息？"></a>PCB提供了进程管理和进程调度所需要的哪些信息？</h4><ul><li>进程标识符</li><li>处理机状态</li><li>进程调度信息<ul><li>进程状态</li><li>进程优先级</li><li>进程调度所需的其他信息</li><li>事件</li></ul></li><li>进程控制信息<ul><li>程序和数据的地址</li><li>进程同步和通信机制</li><li>资源清单</li><li>链接指针</li></ul></li></ul></li><li><h4 id="进程控制块的组织方式有哪几种？"><a href="#进程控制块的组织方式有哪几种？" class="headerlink" title="进程控制块的组织方式有哪几种？"></a>进程控制块的组织方式有哪几种？</h4><ul><li>线性方式</li><li>链接方式</li><li>索引方式</li></ul></li><li><h4 id="何谓操作系统内核？内核的主要功能是是什么？"><a href="#何谓操作系统内核？内核的主要功能是是什么？" class="headerlink" title="何谓操作系统内核？内核的主要功能是是什么？"></a>何谓操作系统内核？内核的主要功能是是什么？</h4><p>现代操作系统一般将OS划分为若干层次，再将OS的不同功能分别设置在不同的层次中。</p><p>通常将一些与硬件紧密相关的模块、各种常用设备的驱动程序以及运行频率较高的模块，都安排在紧靠硬件的软件层次，让它们常驻内存，即OS内核。</p><p>OS内核的功能主要是以下两大方面：</p><ul><li>支撑功能<ul><li>中断处理</li><li>时钟管理</li><li>原语操作</li></ul></li><li>资源管理功能<ul><li>进程管理</li><li>存储器管理</li><li>设备管理</li></ul></li></ul></li><li><h4 id="试说明进程在三个基本状态之间转换的典型原因"><a href="#试说明进程在三个基本状态之间转换的典型原因" class="headerlink" title="试说明进程在三个基本状态之间转换的典型原因"></a>试说明进程在三个基本状态之间转换的典型原因</h4><ul><li>执行状态$\rightarrow$就绪状态：时间片完</li><li>就绪状态$\rightarrow$执行状态：进程调度</li><li>执行状态$\rightarrow$阻塞状态：I/O请求</li><li>阻塞状态$\rightarrow$就绪状态：I/O完成</li></ul></li><li><h4 id="为什么要引入挂起状态？该状态有哪些性质？"><a href="#为什么要引入挂起状态？该状态有哪些性质？" class="headerlink" title="为什么要引入挂起状态？该状态有哪些性质？"></a>为什么要引入挂起状态？该状态有哪些性质？</h4><p>引入挂起的原因，是基于系统和用户的如下需要：</p><ul><li>终端用户的需要</li><li>父进程请求</li><li>负荷调节的需要</li><li>操作系统的需求</li></ul><p>挂起状态的性质是：放弃CPU调度，不接受调度。引入挂起状态后，进程状态转换图增加了活动阻塞、静止阻塞、活动就绪、静止就绪四个状态，并增加了活动就绪与静止就绪，活动阻塞和静止阻塞之间的相互转换。</p></li><li><h4 id="在进行进程切换时，所要保存的处理机状态信息有哪些？"><a href="#在进行进程切换时，所要保存的处理机状态信息有哪些？" class="headerlink" title="在进行进程切换时，所要保存的处理机状态信息有哪些？"></a>在进行进程切换时，所要保存的处理机状态信息有哪些？</h4><p>进程进行切换时，需要保存的处理机状态信息有：</p><ul><li>进程当前暂存信息</li><li>下一指令地址信息</li><li>进程状态信息</li><li>过程和系统调用参数及调用地址信息</li></ul></li><li><h4 id="试说明引起进程创建的主要事件"><a href="#试说明引起进程创建的主要事件" class="headerlink" title="试说明引起进程创建的主要事件"></a>试说明引起进程创建的主要事件</h4><ul><li>用户登录</li><li>作业调度</li><li>提供服务</li><li>应用请求</li></ul></li><li><h4 id="试说明引起进程被撤销的主要事件"><a href="#试说明引起进程被撤销的主要事件" class="headerlink" title="试说明引起进程被撤销的主要事件"></a>试说明引起进程被撤销的主要事件</h4><ul><li>正常结束</li><li>异常结束<ul><li>越界错</li><li>保护错</li><li>非法指令</li><li>特权指令错</li><li>运行超时</li><li>等待超时</li><li>算术运算错</li><li>I/O故障</li></ul></li><li>外界干预</li></ul></li><li><h4 id="在创建一个进程时所要完成的主要工作是什么？"><a href="#在创建一个进程时所要完成的主要工作是什么？" class="headerlink" title="在创建一个进程时所要完成的主要工作是什么？"></a>在创建一个进程时所要完成的主要工作是什么？</h4><p>在系统中每当出现了创建新进程的请求后，OS便调用进程创建原语Create按下述步骤创建一个新进程：</p><ul><li>申请空白PCB</li><li>为新进程分配运行所需的资源</li><li>初始化进程控制块</li><li>如果进程就绪队列能够接纳新进程，便将新进程插入就绪队列</li></ul></li><li><h4 id="在撤销一个进程时所要完成的主要工作是什么？"><a href="#在撤销一个进程时所要完成的主要工作是什么？" class="headerlink" title="在撤销一个进程时所要完成的主要工作是什么？"></a>在撤销一个进程时所要完成的主要工作是什么？</h4><p>如果系统中发生了要求终止进程的某事件，OS便调用进程终止原语，按下述过程去终止指定的进程：</p><ul><li>根据被终止进程的标识符，从PCB集合中检索出该进程的PCB，从中读出该进程的状态</li><li>若被终止形成正处于执行状态，应立即终止该进程的执行，并置调度标志为真，用于指示该进程被终止后应重新进行调度</li><li>若该进程还有子孙进程，还应将其所有子孙进程也都予以终止，以防它们成为不可控进程</li><li>将被终止进程所拥有的全部资源或者归还给其父进程，或者归还给系统</li><li>将被终止进程（PCB）从所在队列（或链表）移除，等待其他程序来搜集信息</li></ul></li><li><h4 id="试说明引起进程阻塞或被唤醒的主要事件是什么？"><a href="#试说明引起进程阻塞或被唤醒的主要事件是什么？" class="headerlink" title="试说明引起进程阻塞或被唤醒的主要事件是什么？"></a>试说明引起进程阻塞或被唤醒的主要事件是什么？</h4><ul><li>向系统请求共享资源失败</li><li>等待某种操作完成</li><li>新数据尚未到达</li><li>等待新任务的到达</li></ul></li><li><h4 id="为什么要在OS中引入线程？"><a href="#为什么要在OS中引入线程？" class="headerlink" title="为什么要在OS中引入线程？"></a>为什么要在OS中引入线程？</h4><p>在OS中引入线程，是为了减少程序在并发执行时所付出的时空开销，使OS具有更好的并发性。</p></li><li><h4 id="试说明线程具有哪些属性？"><a href="#试说明线程具有哪些属性？" class="headerlink" title="试说明线程具有哪些属性？"></a>试说明线程具有哪些属性？</h4><ul><li>轻型进程</li><li>调度的基本单位</li><li>并发性</li><li>拥有资源</li><li>独立性</li><li>系统开销</li><li>支持多处理机系统</li></ul></li><li><h4 id="试从调度性、并发性、拥有资源及系统开销方面对进程和线程进行比较"><a href="#试从调度性、并发性、拥有资源及系统开销方面对进程和线程进行比较" class="headerlink" title="试从调度性、并发性、拥有资源及系统开销方面对进程和线程进行比较"></a>试从调度性、并发性、拥有资源及系统开销方面对进程和线程进行比较</h4><ul><li><p>调度性</p><ul><li>在传统的OS中，进程是作为独立调度和分派的基本单位，因而进程是能独立运行的基本单位。在每次调度时，都需要进行上下文切换，开销较大。</li><li>在引入线程的OS中，已把线程作为调度和分派的基本单位，因而线程是能独立运行的基本单位。当线程切换时，仅需要保存和设置少量寄存器内容，切换代价远低于进程。在同一进程中，线程的切换不会引起进程的切换，但从一个进程中的线程切换到另一个进程中的线程时，必然会引起进程的切换</li></ul></li><li><p>并发性</p><p>在引入线程的OS中，不仅进程之间可以并发执行，而且在一个进程的多个线程之间亦可并发执行，甚至允许在一个进程中的所有线程都能并发执行。同样，不同进程中的线程也能并发执行。</p></li><li><p>拥有资源</p><ul><li>进程可以拥有资源，并作为系统中拥有资源的一个基本单位。然而，线程本身并不拥有系统资源，而是仅有一点必不可少的、能保证独立运行的资源</li><li>线程除了拥有自己的少量资源外，还云溪多个线程共享该进程拥有的资源。</li></ul></li><li><p>系统开销</p><p>在创建或撤销进程时，系统都要为之分配和回收进程控制块、分配或回收其他资源。OS为此所付出的开销，明显大于线程创建或撤销时所付出的开销。类似地，在进程切换时，涉及到进程上下文的切换，而线程的切换代价也远低于进程的。</p></li></ul></li><li><h4 id="线程控制块TCB中包含了哪些内容？"><a href="#线程控制块TCB中包含了哪些内容？" class="headerlink" title="线程控制块TCB中包含了哪些内容？"></a>线程控制块TCB中包含了哪些内容？</h4><ul><li>线程标识符</li><li>一组寄存器</li><li>线程运行状态</li><li>优先级</li><li>线程专有存储区</li><li>信号屏蔽</li><li>堆栈指针</li></ul></li><li><h4 id="何谓用户级线程和内核支持线程？"><a href="#何谓用户级线程和内核支持线程？" class="headerlink" title="何谓用户级线程和内核支持线程？"></a>何谓用户级线程和内核支持线程？</h4><ul><li>用户级线程：用户级线程是在用户空间中实现的。对线程的创建、撤销、同步与通信等功能，都无需内核的支持，即用户级线程是与内核无关的。</li><li>内核支持线程：是在内核的支持下运行的，它们的创建、阻塞、撤销和切换等，都是在内核空间实现的</li></ul></li><li><h4 id="试说明用户级线程的实现方法"><a href="#试说明用户级线程的实现方法" class="headerlink" title="试说明用户级线程的实现方法"></a>试说明用户级线程的实现方法</h4><p>用户级线程是在用户空间中的实现的，运行在“运行时系统”与“内核控制线程”的中间系统上。运行时系统用于管理和控制线程的函数的集合。内核控制线程或轻型进程LWP可通过系统调用获得内核提供服务，利用LWP进程作为中间系统。</p></li><li><h4 id="试说明内核支持线程的实现方法"><a href="#试说明内核支持线程的实现方法" class="headerlink" title="试说明内核支持线程的实现方法"></a>试说明内核支持线程的实现方法</h4><p>系统在创建一个新进程时，便为它分配一个任务数据区PTDA，其中包括若干个线程控制块TCB空间。在每个TCB中可保存线程标识符、优先级、线程运行的CPU状态信息。每当进程要创建一个线程时，便为新线程分配一个TCB，将相关信息填入该TCB中，并为之分配必要的资源；当PTDA中的所有TCB空间已用完，而进程又要创建新的线程时，只要其所创建的线程数目未超过系统允许值，系统可再为之分配新的TCB空间；在撤销一个线程时，也应回收该线程的所有资源和TCB。</p></li><li><h4 id="多线程模型有哪几种类型？多对一模型有何优缺点？"><a href="#多线程模型有哪几种类型？多对一模型有何优缺点？" class="headerlink" title="多线程模型有哪几种类型？多对一模型有何优缺点？"></a>多线程模型有哪几种类型？多对一模型有何优缺点？</h4><p>由于用户级线程和内核级线程连接方式的不同，从而形成了三种不同的模型：</p><ul><li>多对一模型</li><li>一对一模型</li><li>多对多模型</li></ul><p>多对一模型的优点：</p><ul><li>线程管理的开销小，效率高</li></ul><p>多对一模型的缺点：</p><ul><li>如果一个线程在访问内核时发生阻塞，则整个进程都会被阻塞</li><li>在任一时刻，只有一个线程能访问内核，多个线程不能同时在多个处理机上运行</li></ul></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;&lt;h4 id=&quot;为什么程序并发执行会产生间断性特征？&quot;&gt;&lt;a href=&quot;#为什么程序并发执行会产生间断性特征？&quot; class=&quot;headerlink&quot; title=&quot;为什么程序并发执行会产生间断性特征？&quot;&gt;&lt;/a&gt;为什么程序并发执行会产生间断性特征？&lt;/h4&gt;
      
    
    </summary>
    
      <category term="操作系统" scheme="http://wanqbin.xyz/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="习题解答" scheme="http://wanqbin.xyz/tags/%E4%B9%A0%E9%A2%98%E8%A7%A3%E7%AD%94/"/>
    
      <category term="线程" scheme="http://wanqbin.xyz/tags/%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="进程" scheme="http://wanqbin.xyz/tags/%E8%BF%9B%E7%A8%8B/"/>
    
  </entry>
  
</feed>

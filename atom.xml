<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Aoki&#39;s Blog</title>
  
  <subtitle>“吾生也有涯，而知无涯”</subtitle>
  <link href="/Aoki/atom.xml" rel="self"/>
  
  <link href="http://wanqbin.coding.me/Aoki/"/>
  <updated>2019-06-13T16:15:44.801Z</updated>
  <id>http://wanqbin.coding.me/Aoki/</id>
  
  <author>
    <name>Aoki</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>软件工程的内容和方法</title>
    <link href="http://wanqbin.coding.me/Aoki/2019/06/14/%E5%B7%A5%E7%A8%8B%E7%9A%84%E5%86%85%E5%AE%B9%E5%92%8C%E6%96%B9%E6%B3%95/"/>
    <id>http://wanqbin.coding.me/Aoki/2019/06/14/工程的内容和方法/</id>
    <published>2019-06-13T16:11:00.000Z</published>
    <updated>2019-06-13T16:15:44.801Z</updated>
    
    <content type="html"><![CDATA[<h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>&emsp;经过一个礼拜的准备，终于结束了软件工程的复习。在复习软件工程的同时也在做信息系统综合设计的课程设计。在做课程设计的过程中，发现了软件工程的重要性和必要性。作为立志成为程序猿的我，软件工程在将来的工作中一定大有用处，故总结如下。</p><h2 id="一、软件、软件工程、软件工程学科体系"><a href="#一、软件、软件工程、软件工程学科体系" class="headerlink" title="一、软件、软件工程、软件工程学科体系"></a>一、软件、软件工程、软件工程学科体系</h2><p>学习软件工程，首先得知道软件是什么。其次，得知道软件工程是做什么的，它研究了什么内容，同时也应该知道软件工程学科体系是什么，与软件工程有什么关系。</p><ol><li><h4 id="软件：最新定义为，软件-知识-程序-数据-文档"><a href="#软件：最新定义为，软件-知识-程序-数据-文档" class="headerlink" title="软件：最新定义为，软件=知识+程序+数据+文档"></a>软件：最新定义为，软件=知识+程序+数据+文档</h4><p>那么这里面的知识，程序，数据，文档又是指什么呢？</p><p>知识，即各种各样的相关领域的专业知识。</p><p>程序，即使对计算机任务的处理对象和处理规则的描述。这里，我们一定要注意，软件并不等于程序，这也是一大误区。</p><p>数据，即程序赖以运行的初始化数据。</p><p>文档，即为了理解程序所需的详细描述性资料。</p></li><li><h4 id="软件工程是什么？"><a href="#软件工程是什么？" class="headerlink" title="软件工程是什么？"></a>软件工程是什么？</h4><p>软件工程是研究软件开发和管理的一门工程学科。</p><p>这个定义很短，但是知识点还是挺多的。一强调开发，毕竟开发是软件工程的主体；二强调管理或过程管理，当然，管理是为了更好的开发；三是强调工程，把软件的开发和维护当成一项工程，用工程的办法去开发，按工程的办法去管理；四是强调学科，时至今日，软件工程不只是一门学科，而是一个学科体系。这里也就引出了软件工程学科体系。</p><blockquote><p>软件工程来源于软件危机。软件工程是为了克服软件危机才产生的。</p></blockquote></li><li><h4 id="软件工程学科体系"><a href="#软件工程学科体系" class="headerlink" title="软件工程学科体系"></a>软件工程学科体系</h4><blockquote><p>软件工程作为一个学科体系，到21世纪才初步形成。2004年ACM和IEEE-CS联合制订了SWEBOK 2004版，它将软件工程学科体系的知识划分为10个知识域。</p></blockquote><p>对于这10个知识域，我的理解是它覆盖了整个软件生命周期。</p><p>1） 软件需求</p><p>2）软件设计</p><p>3）软件构造</p><p>4）软件测试</p><p>5）软件维护</p><p>6）软件配置管理</p><p>7）软件工程管理</p><p>8）软件工程过程</p><p>9）软件工程工具和方法</p><p>10）软件质量</p></li><li><h4 id="软件工程和软件工程学科体系的关系"><a href="#软件工程和软件工程学科体系的关系" class="headerlink" title="软件工程和软件工程学科体系的关系"></a>软件工程和软件工程学科体系的关系</h4><p>总体上来说，软件工程是一个局部问题，而软件工程学科体系是一个整体问题。</p></li><li><h4 id="软件工程研究的内容"><a href="#软件工程研究的内容" class="headerlink" title="软件工程研究的内容"></a>软件工程研究的内容</h4><p>软件工程研究的内容主要有五个方面。</p><p>一是软件生命周期模型</p><p>二是软件开发方法</p><p>三是软件支持过程</p><p>四是软件管理过程</p><p>五是软件工程标准与规范</p></li><li><h4 id="软件工程基本原理"><a href="#软件工程基本原理" class="headerlink" title="软件工程基本原理"></a>软件工程基本原理</h4><p>软件工程的三要素：方法、工具和过程</p><p>有7个基本原理，外加一个二八定律。具体内容见文章末尾的链接。</p></li><li><h4 id="软件工程在行业中的作用"><a href="#软件工程在行业中的作用" class="headerlink" title="软件工程在行业中的作用"></a>软件工程在行业中的作用</h4><p>软件工程作为一门工程管理学科，它对软件行业的作用毋庸置疑。那么，这里会有一个问题，既然已经有软件工程了，那么还会不会出现软件危机呢？我的答案是会的。软件工程的产生是为了克服软件危机，但是它的存在并不会完全消除软件危机。这和现实社会中法律存在的意义是相通的。法律的产生是为了消除犯罪，但是法律的存在并不会完全消除犯罪（至少在当前的社会阶段是不会的）。</p><p>软件工程可以作用到从业者，也可以作用到项目组，作用到软件公司，甚至作用到整个国家的软件产业1发展。</p></li></ol><h2 id="二、软件工程方法论和软件工程实践论"><a href="#二、软件工程方法论和软件工程实践论" class="headerlink" title="二、软件工程方法论和软件工程实践论"></a>二、软件工程方法论和软件工程实践论</h2><h4 id="1-软件工程方法论是什么？"><a href="#1-软件工程方法论是什么？" class="headerlink" title="1.  软件工程方法论是什么？"></a>1.  软件工程方法论是什么？</h4><p>软件工程方法论实质上是软件工程中软件开发方法的集合。</p><p>那么软件工程方法的集合包括哪些元素呢？</p><h4 id="2-软件工程方法集合"><a href="#2-软件工程方法集合" class="headerlink" title="2.  软件工程方法集合"></a>2.  软件工程方法集合</h4><p>软件工程方法集合包括面向过程方法、面向对象方法、面向元数据方法。</p><h4 id="3-为什么说面向对象方法可以描述无穷的信息世界呢？"><a href="#3-为什么说面向对象方法可以描述无穷的信息世界呢？" class="headerlink" title="3.  为什么说面向对象方法可以描述无穷的信息世界呢？"></a>3.  为什么说面向对象方法可以描述无穷的信息世界呢？</h4><p>要搞清楚面向对象为什么可以描述无穷的世界，首先需要知道面向对象方法是什么，其次，需要知道现实世界和软件的普遍联系。</p><p>面向对象方法是什么？是一种运用对象、类、消息传递、继承、封装、聚合、多态性等概念构造软件系统的软件开发方法。</p><p>我记得高中哲学里面听到的一句话，世界是物质的，物质是运动的，运动是有规律的。而对于软件而言，其实质是对现实人工系统的一种映射、优化和替换。通过对现实世界的分析，我们可以知道，世界是由对象组成的，对象之间时存在普遍联系的，而物质运动则说明了对象的功能。</p><p>面向方法是将这现实世界抽象映射为对象的手段。分析设计时由对象抽象出类，程序运行时由类还原到了对象。所以它能够描述无穷的信息世界。</p><h4 id="4-软件工程实践论是什么？"><a href="#4-软件工程实践论是什么？" class="headerlink" title="4.  软件工程实践论是什么？"></a>4.  软件工程实践论是什么？</h4><p>软件工程实践论是研究在开发一个大型软件系统时，到底应该怎样选取合适的开发方法。</p><h2 id="5-软件工程实践论指什么？"><a href="#5-软件工程实践论指什么？" class="headerlink" title="5.  软件工程实践论指什么？"></a>5.  软件工程实践论指什么？</h2><p>“五个面向”实践论，指面向流程分析、面向元数据设计、面向对象实现、面向功能测试、面向过程管理。</p><p>在后面，我们会发现软件工程的“五个面向”实践论在各个软件生命周期模型中都有一定的体现。</p><h2 id="三、软件支持过程、软件管理过程"><a href="#三、软件支持过程、软件管理过程" class="headerlink" title="三、软件支持过程、软件管理过程"></a>三、软件支持过程、软件管理过程</h2><ol><li><h4 id="软件过程是什么？"><a href="#软件过程是什么？" class="headerlink" title="软件过程是什么？"></a>软件过程是什么？</h4><p>软件过程，指软件生命周期中的时间序列</p></li><li><h4 id="软件支持过程是什么？"><a href="#软件支持过程是什么？" class="headerlink" title="软件支持过程是什么？"></a>软件支持过程是什么？</h4><p>软件支持过程，由支持软件生命周期模型各个阶段的生产工具组成。</p></li><li><h4 id="软件生命周期中的生产工具有哪些？"><a href="#软件生命周期中的生产工具有哪些？" class="headerlink" title="软件生命周期中的生产工具有哪些？"></a>软件生命周期中的生产工具有哪些？</h4><p>CASE工具、软件开发环境SDE、软件工程环境SEE</p></li><li><h4 id="软件管理是什么？"><a href="#软件管理是什么？" class="headerlink" title="软件管理是什么？"></a>软件管理是什么？</h4><p>管理过程和支持过程又称为“软件过程工程”。它是软件工程的一部分。</p><p>软件管理实质上是过程管理。</p></li><li><h4 id="软件管理有哪几类？"><a href="#软件管理有哪几类？" class="headerlink" title="软件管理有哪几类？"></a>软件管理有哪几类？</h4><p>ISO 9001质量管理和质量保证体系</p><p>CMMI软件能力成熟度模型</p><p>软件企业文化，包括微软企业文化，IBM企业文化，敏捷文化。</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h2&gt;&lt;p&gt;&amp;emsp;经过一个礼拜的准备，终于结束了软件工程的复习。在复习软件工程的同时也在做信息系统综合设计的课程设计。在做课程设计
      
    
    </summary>
    
    
      <category term="软件工程" scheme="http://wanqbin.coding.me/Aoki/tags/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"/>
    
      <category term="软件工程方法论" scheme="http://wanqbin.coding.me/Aoki/tags/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E6%96%B9%E6%B3%95%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络体系结构</title>
    <link href="http://wanqbin.coding.me/Aoki/2019/06/10/%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/"/>
    <id>http://wanqbin.coding.me/Aoki/2019/06/10/算机网络体系结构/</id>
    <published>2019-06-09T16:45:00.000Z</published>
    <updated>2019-06-13T16:48:06.085Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、计算机网络分层结构"><a href="#一、计算机网络分层结构" class="headerlink" title="一、计算机网络分层结构"></a>一、计算机网络分层结构</h2><p>两个系统中实体间的通信是一个很复杂的过程，为了降低协议设计和调试过程的复杂性，也为了便于对网络进行研究、实现和维护，促进标准化工作，通常对及时算计网络的体系结构以分层的形式进行建模。</p><p>我们将计算机网络的各层及其协议的集合称为网络的体系结构。</p><p>网络设计者以分层的方式组织协议以及实现这些协议的网络硬件和软件，每个协议就属于这些层次之一。某层向它的上一层提供服务，即所谓每一层的服务模型。例如，第n层提供的服务可能包括报文从网络的一边到另一边的可靠传送。这可能是通过使用第n-1层的边缘到边缘的不可靠报文传送，加上第n层的检测和重传丢失报文的功能来实现的。</p><p>计算机网络的体系结构通常都具有可分层的特性，它将复杂的大系统分为若干个较容易实现的层次。分层的基本原则如下：</p><ol><li>每次都实现一种相对独立的功能，降低大系统的复杂度</li><li>各层之间界面自然清晰，易于理解，相互交流尽可能少</li><li>各层功能的精确定义独立于具体的实现方法，可以采用合适的技术来实现</li><li>整个分层结构应该促进标准化工作</li></ol><p>在计算机网路的分层结构中，第n层中的活动元素通常被称为n层实体。具体来说，<strong>实体指任何可发送或接受信息的硬件或软件进程，通常是一个特定的软件模块</strong>。不同机器上的同一层称为对等层，同一层的实体称为对等实体。</p><p>在计算机网络体系结构的各个层次中，每个报文都分为两部分：一是数据部分，即SDU；二是控制信息部分，即PCI，它们共同组成PDU。</p><p>服务数据单元（SDU）：为完成用户所要求的功能而应传送的是数据。第n层的服务数据单元记为n-SDU。</p><p>协议控制信息（PCI）：控制协议操作的信息。第n层的协议控制信息记为n-PCI。</p><p>协议数据单元（PDU）：对等层次之间传送的数据单位称为该层的PDU。第n层的协议数据记为n-PDU。在实际的网络中，每层的协议数据单元都有一个通俗的名称，如物理层的PDU称为比特，链路层的PDU称为帧，网络层的PDU称为分组，传输层的PDU称为报文。</p><p>在各层间传输数据时，把从第n+1层收到的PDU作为第n层的SDU，加上第n层的PCI，变成了第n层的PDU，交给第n-1层后作为SDU发送，接收方接收时做相反处理。故可知三者的关系是n-SDU+n-PCI=n-PDU=(n-1)-SDU.</p><h2 id="二、协议、接口、服务"><a href="#二、协议、接口、服务" class="headerlink" title="二、协议、接口、服务"></a>二、协议、接口、服务</h2><ol><li><p>协议</p><p>协议，就是规则的集合。在网络中要做到有条不紊地交换数据，就必须遵循一些事先约定好的规则，这些规则明规定了所交换的数据的格式及有关的同步问题。这些为进行网络中的数据交换而建立的规则、标准或约定称为网络协议。它是控制两个（或多个）对等实体进行通信的规则的集合，是水平的。不对等的实体之间没有协议。</p></li><li><p>接口</p><p>接口是同一结点内相邻两层之间交换信息的连接点，是一个系统内部的规定。每层只能为紧邻的层次之间定义接口，不能跨层定义接口。在典型的接口上，同一结点相邻两层的实体通过服务访问点（SAP）进行交互。服务是通过SAP提供给上层使用的，第n层的SAP就是第n+1层可以访问第n层服务的地方。</p></li><li><p>服务</p><p>服务是指下层为紧邻的上层提供的功能调用，它是垂直的。</p><p>上层使用下层所提供的服务时必须与下层交换一些命令，这些命令在OSI中称为服务原语。OSI将原语划分为4类：<br>1）请求：由服务用户发往服务提供者，请求完成某项工作</p><p>2）指示：由服务提供者发往服务用户，提示用户做某件事</p><p>3）相应：由服务用户发往服务提供者，作为对指示的响应</p><p>4）证实：由服务提供者发往服务用户，作为对请求的证实</p></li></ol><p>   并非在一层内完成的全部功能都称为服务，只有那些能够被高一层实体“看得见”的功能才称为服务。</p><p>   计算机网络提供的服务可按以下三种方式分类：</p><p>   （1）面向连接服务于无连接服务</p><p>   在面向连接服务中，通信前双方必须先建立连接，分配相应的资源，以保证通信能正常进行，传输结束后释放连接和所占用的资源。因此这种服务可分为建立连接、数据传输和释放连接三个阶段。TCP就是一种面向连接服务的协议。</p><p>   在无连接服务中，通信前双方不需要先建立连接，需要发送数据时可直接发送，把每个带有目的地址的包传送到线路上，由系统选定路线进行传输。这是一种不可靠的服务，这种服务常被描述为“尽最大可能交付”，它不能保证通信的可靠性。例如IP、UDP就是一种无连接服务的协议。</p><p>   （2）可靠服务与不可靠服务</p><p>   可靠服务是网络具有检错、纠错、应答机制，能保证数据正确、可靠地传送到目的地。</p><p>   不可靠服务是指网络只是尽量正确、可靠地传送，而不能保证数据正确、可靠地传送到目的地，是一种尽力而为的服务。</p><p>   （3）有应答服务和无应答服务</p><p>   有应答服务是指接收方在收到数据后向发送方给出相应的应答，该应答由传输系统同内部自动实现，而不由用户实现。所发送的应答既可以是可乐定应答，也可以是否定应答，通常在接收到数据有错误时发送否定应答。文件传输服务就是一种有应答服务。</p><p>   无应答服务是指接收方收到数据后不自动给出应答。若需要应答，则由高层实现。例如，对于WWW服务，客户端收到服务器发送的页面文件不给出应答。</p><h2 id="三、ISO-OSI参考模型和TCP-IP模型"><a href="#三、ISO-OSI参考模型和TCP-IP模型" class="headerlink" title="三、ISO/OSI参考模型和TCP/IP模型"></a>三、ISO/OSI参考模型和TCP/IP模型</h2><ol><li><p>OSI参考模型</p><p>国际标准化组织（ISO）提出的网络体系结构模型，称为开放系统互联参考模型。通常简称为OSI模型。OSI有7层，自下而上依次是物理层、数据链路层、网络层、传输层、会话层、表示层、应用层。</p><p>低三层称为通信子网，它是为了联网而附加的通信设备，完成数据的传输功能；高三层统称为资源子网，它相当于计算机系统，完成数据的处理等功能。</p><p>1）物理层</p><p>物理层的传输单位是比特，任务是透明的传输比特流，功能是在物理媒体上为数据端设备透明地提供传输原始比特流。</p><p>物理层主要定义数据终端设备(DTE)和数据通信设备（DCE）的物理与逻辑连接方法，所以物理层协议也称为物理层接口标准，也称为规程。</p><p>2）数据链路层</p><p>数据链路层的传输单位是帧，任务是将网络层传来的IP数据报组装成帧。数据链路层的功能可以概括为成帧、差错控制、流量控制和传输管理。</p><p>典型的数据链路层协议有SDLC、HDLC、PPP、STP和帧中继等。</p><p>3）网络层</p><p>网络层的传输单位是数据报，它关心的是通信子网的运行控制，主要任务是把网络层的协议数据单元（分组）从源端传送到目的端，为分组交换网上的不同主机提供通信服务。关键问题是对分组进行路由选择，并实现流量控制、拥塞控制、差错控制和网际互联等功能。</p><p>网络层的协议有IP、IPX、ICMP、IGMP、ARP 、RARP、OSPF等</p><p>4）传输层</p><p>传输层也称为运输层，传输大单位是报文段（TCP）或用户数据报（UDP），传输层负责主机中两个进程之间的通信，功能是为端到端连接提供可靠的传输服务，为端到端连接提供流量控制、差错控制、服务质量、数据传输管理等服务。</p><p>数据链路层提供的是点对点的通信，传输层提供的是端到端的通信。</p><p>传输层的协议有TCP、UDP</p><p>5）会话层</p><p>会话层允许不同的主机上的各个进程之间进行通信。会话层利用传输层提供的端到端的服务向表示层提供它的增值服务。这种服务主要为表示层实体或用户进程建立连接并在连接上有序地传输数据，这就是会话，也称为建立同步(SYN)。</p><p>会话层负责管理主机间的会话进程，包括建立、管理及终止进程间的会话。会话层可以使用校验点使通信会话在通信失效时从校验点继续恢复通信，实现数据同步。</p><p>6）表示层</p><p>表示层主要用于处理在两个通信系统中交换信息的表示形式。不同机器采用的编码和表示方法不同，使用的数据结构也不同。为了使不同表示方法的数据和信息之间能互相交流，表示层采用抽象的标准方法定义数据结构，并采用标准的编码形式。数据压缩、加密和解密也是表示层可提供的数据表示交换功能。</p><p>7）应用层</p><p>应用层是OIS模型的最高层，是用户与网络的界面。应用层为特定类型的网络应用提供访问OSI环境的手段。因为用户的实际应用多种多样，这就要求应用层采用不同的应用协议来解决不同类型的应用要求，因此应用层是最复杂的一层，使用的协议也最多。</p><p>典型的应用层协议有用于文件传输的FTP、用于电子邮件的SMTP、用于万维网的HTTP等。</p></li><li><p>TCP/IP模型</p><p>TCP/IP模型从低到高依次是网络接口层（对应OSI参考模型中的物理层和数据链路层）、网际层、传输层和应用层（对应OSI模型的会话层、表示层、应用层）。</p><p>1）网络接口层</p><p>网络接口层的功能类似于OSI的物理层和数据链路层。它表示与物理网络的接口，但实际上TCP/IP本身并未真正描述这一部分，只是指出主机必须使用某种协议和网络连接，以便在其上传递IP分组。</p><p>2）网际层</p><p>网际层（主机-主机）是TCP/IP体系结构的关键部分。它和OSI网络层在功能上是非常相似的。网际层将分组发往任何网络，并为之独立地选择合适的路由，但它不保证各个分组有序地到达，各个分组的有序交付由高层负责。</p><p>3）传输层</p><p>传输层（应用-应用或进程-进程）的功能同样与OSI中的传输层类似，使得发送端和目的端主机的对等实体进行会话。传输层主要使用以下两种协议：<br>（1） 传输控制协议（Transmission Control Protocol，TCP）。它是面向连接的，数据传输的单位是报文段，能够提供可靠的交付。</p><p>（2）用户数据报协议（User Datagram Protocol，UDP）。它是无连接的，数据传输的单位是用户数据报，不能保证提供可靠的交付，只能提供“尽最大努力交付”。</p><p>4）应用层（用户-用户）包含所有的高层协议。IP协议是因特网中的核心协议；TCP/IP可以为各种各样的应用提供服务，同时TCP/IP也允许在由各种网络构成的互联网上运行。</p></li><li><p>TCP/IP模型与OSI模型的比较</p><p>1）二者都采用分层的体系结构，分层的功能也大体相似</p><p>2）二者都基于独立的协议栈概念</p><p>3）二者都可以解决异构网络的互联，实现世界上不同厂家生产的计算机之间的通信</p><p>4）OSI模型最大的贡献是精确地定义了三个主要的概念：服务，协议和接口，与现代的面向对象程序设计思想非常吻合。而TCP/IP模型在这三个概念上却没有明确区分，不符合软件工程的思想</p><p>5）OSI模型产生在协议之前，没有偏向于任何特定的协议，通用性良好。TCP/IP模型产生于协议之后，实际是对协议的描述</p><p>6）TCP/IP在设计之初就考虑了多种异构网的互联问题，并将网际协议（IP）作为一个单独的重要层次。OSI模型最初只考虑到用一种标准的公用数据网络将不同的系统互联。OSI模型认识到网际协议IP的重要性后，只好在网络层中划分出一个子层来完成类似于TCP/IP模型中的IP功能</p><p>7）<strong>OSI模型在网络层支持无连接和面向连接的通信，但在传输层仅有面向连接的通信。而TCP/IP模型认为可靠性是端到端的问题，因此它在网际层仅有一种无连接的通信模式，但传输层支持无连接和面向连接两种模式</strong>。</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、计算机网络分层结构&quot;&gt;&lt;a href=&quot;#一、计算机网络分层结构&quot; class=&quot;headerlink&quot; title=&quot;一、计算机网络分层结构&quot;&gt;&lt;/a&gt;一、计算机网络分层结构&lt;/h2&gt;&lt;p&gt;两个系统中实体间的通信是一个很复杂的过程，为了降低协议设计和调试过程
      
    
    </summary>
    
    
      <category term="网络体系结构" scheme="http://wanqbin.coding.me/Aoki/tags/%E7%BD%91%E7%BB%9C%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>通信基础</title>
    <link href="http://wanqbin.coding.me/Aoki/2019/06/10/%E9%80%9A%E4%BF%A1%E5%9F%BA%E7%A1%80/"/>
    <id>http://wanqbin.coding.me/Aoki/2019/06/10/通信基础/</id>
    <published>2019-06-09T16:42:00.000Z</published>
    <updated>2019-06-13T16:43:00.054Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>写在前面</p></blockquote><p>物理层协议的主要任务就是确定与传输媒体的接口有关的一些特性，如下所述：</p><ol><li>机械特性：指明接口所用接线器的形状和尺寸、引脚数目和排列、固定和锁定装置等。</li><li>电气特性：指明在接口电缆的各条线上出现的电压范围1.</li><li>功能特性：指明某条线上出现的某一电平代表何种意义。</li><li>过程特性：指明对于不同功能的各种可能事件的出现顺序。</li></ol><h2 id="一、数据通信的模型"><a href="#一、数据通信的模型" class="headerlink" title="一、数据通信的模型"></a>一、数据通信的模型</h2><p>一个数据通信系统可划分为三大部分，即源系统（或发送端，发送方）、传输系统（或传输网络）和目的系统（或接收方、接收端）。</p><p>源系统一般包括两部分：</p><ol><li>源点：源点设备产生要传输的数据。</li><li>发送器：通常源点生成的数字比特流要通过发送器编码之后才能在传输系统中进行传输。</li></ol><p>目的系统一般包括两部分：</p><ol><li>接收器：接收传输系统传送过来的信号，并把它转换为能够被目的设备处理的信息。</li><li>终点：终点设备从接收器获取传送来的数字比特流，然后进行信息输出。终点又称为目的站或信宿。</li></ol><p>在源系统和目的系统之间的传输系统可以是简单的传输线路，也可以是连接在源系统和目的系统之间的复杂网络系统。</p><p>通信的目的是传送<strong>消息</strong>。</p><p><strong>数据</strong>是消息的实体。</p><p><strong>信号</strong>是数据的电器或电磁表现。根据信号中代表的消息的参数的取值方式不同，信号可分为两类：</p><ol><li>模拟信号（或连续信号）——消息的参数的取值时连续的</li><li>数字信号（或离散信号）——消息的参数的取值时离散的。在使用时间域的波形表示数字信号时，代表不同离散数值的基本波形就称为<strong>码元</strong>。在使用二进制编码时，只有两种不同的码元，一种代表0状态，另一种代表1状态。</li></ol><p><strong>速率、波特与带宽</strong></p><p>速率也称为数据率，指的是数据的传输速率，表示单位之间内传输的数据量。可以用码元传输速率和信息传输速率表示。</p><ol><li>码元传输速率。又称码元速率，波形速率等，它表示单位时间内数字通信系统所传输的码元个数，单位是波特（Baud）。1波特表示数字通信系统每秒传输一个码元。这里的码元可以是多进制的，也可以是二进制的，但码元速率与进制数无关。</li><li>信息传输速率。又称信息速率，比特率等。它表示单位时间内数字通信系统传输的二进制码元数（即比特数），单位是比特/秒（b/s).</li></ol><h2 id="二、编码与调制"><a href="#二、编码与调制" class="headerlink" title="二、编码与调制"></a>二、编码与调制</h2><ol><li><p>常用编码方式</p><p>要利用信道传输数据，必须将数据转换为能在传输媒体媒体上传送的信号。信道可以分为传送模拟信号的<strong>模拟信道</strong>和传送数字信号的<strong>数字信道</strong>两大类。</p><p>将数字数据转换为数字信号的过程称为<strong>编码</strong>。</p><p>将数字信号转换为模拟信号的过程称为<strong>调制</strong>。</p><p><img src="https://i.imgur.com/nvmtArH.png" alt></p></li></ol><p>   归零制：正脉冲代表1，负脉冲代表0；</p><p>   不归零制：正电平代表1，负电平代表0；</p><p>   曼彻斯特编码：位周期中心的是上跳变代表0，位周期中心的下跳变代表1；</p><p>   差分曼彻斯特编码：在每一位的中心处始终有跳变。位开始边界有跳变代表0，而位边界没有跳变代表1；</p><ol start="2"><li><p>基本的调制方法</p><p>矩形脉冲波形的数字信号包含从直流开始的低频分量，被称为<strong>基带信号</strong></p><p>在数字信道上直接传输基带信号的方法称为<strong>基带传输</strong></p><p>基带信号往往包含较多的低频成分，甚至直流成分。而许多模拟信道仅能通过某一频率范围的信号，不能直接传输这种基带信号。因此必须对基带信号进行<strong>调制</strong>，使它能够在模拟信道中传输。</p><p>在很多情况下，需要使用<strong>载波</strong>进行调制，把基带信号的频率范围搬移到较高的频段以便在信道中传输。经过载波调制后的信号称为<strong>带通信号</strong>，而使用载波的调制称为<strong>带通调制</strong>。</p><p>最基本的带通调制的方法有：<br>1）调幅（AM），即载波的增幅随基带数字信号而变化。</p><p>2）调频（FM），即载波的频率随着基带数字信号的变化而变化。</p><p>3）调相（PM），即载波的初始相位随基带数字信号而变化。</p><p>在数字通信中，调幅、调频和调相相应地称为<strong>幅移键控</strong>、<strong>频移键控</strong>和<strong>相移键控</strong>。实现调制和解调功能的设备称为<strong>调制解调器</strong>。</p></li></ol><h2 id="三、奈奎斯特定理与香农定理"><a href="#三、奈奎斯特定理与香农定理" class="headerlink" title="三、奈奎斯特定理与香农定理"></a>三、奈奎斯特定理与香农定理</h2><ol><li><p>奈奎斯特定理</p><p>奈奎斯特定理又称<strong>奈氏准则</strong>。它指出在理想低通（没有噪声、带宽有限）的信道中，极限码元速率为2W波特，其中W是理想低通信道的带宽，单位是Hz。若用V表示每个码元离散电平的数目（码元的离散电平数目是指有多少种不同的码元，比如有16种不同的码元，则需要有4位二进制位，因此数据传输率是码元传输率的4倍），则极限速率为</p><p>​                                理想低通信道下的极限数据传输率=$2Wlog_2V$（单位为b/s)</p><p>对于奈氏准则，可以得出以下结论：</p><p>1）在任何信道中，码元传输的速率是有上限的。若传输速率超过此上限，就会出现严重的码间串扰问题，使得接收端不可能完全正确地识别码元。</p><p>2）信道的频带越宽(即通过的信号高频分量越多)，就可用更高的速率进行码元的有效传输。</p><p>3）奈氏准则给出了码元传输速率的限制，但是并未对信息传输速率给出限制，即未对一个码元可以对应多少个二进制位给出限制。</p><p>由于码元的传输速率受奈氏准则的制约，所以要提高数据的传输速率，就必须设法使每个码元携带更多个比特的信息量，此时就需要多元制的调制方法。</p></li><li><p>香农定理</p><p>香农定理给出了带宽受限且有高斯白噪声干扰的信道的极限数据传输率，当用此速率进行传输时，可以做到不产生误差。香农定理定义为：</p><p>​    信道的极限数据传输率=$Wlog_2(1+S/N)$ 单位为b/s</p><p>式中，W为信道带宽，S为信道所传输信号的平均功率，N为信道内部的高斯噪声功率，$S/N$为信噪比，即信号的平均功率与噪声的平均功率之比。</p><p>对于香农定理，可以得出以下的结论：<br>1）信道的带宽或信道中的信噪比越大，信息的极限传输速率越高。</p><p>2）对一定的传输带宽和一定的信噪比，信息传输速率的上限是确定的。</p><p>3）只要信息的传输速率低于信道的极限传输速率，就能找到某种方法来实现无差错的传输。</p><p>4）香农定理得出的是极限信息传输速率，实际信道能达到的传输速率比它低不少。</p><p>从香农定理可以看出，若信道带宽W或信噪比S/N没有上限，则信道的极限信息传输速率也没有上限。</p><p>奈氏准则只考虑了带宽与极限码元速率的关系，而香农定义不仅考虑了带宽，而且考虑到了信噪比。这从另一个侧面表明，一个码元对应的二进制位数是有限的。</p><h2 id="四、传输方式"><a href="#四、传输方式" class="headerlink" title="四、传输方式"></a>四、传输方式</h2><ol><li><p>并行传输与串行传输</p><p>并行传输，是指一次发送n个比特而不是一个比特，为此，在发送端和接收端之间需要有n条传输线路。</p><p>串行传输，是指数据是一个比特一个比特发送的，为此，发送端和接收端之间只需要一条传输线路。</p></li><li><p>异步传输与同步传输</p><p>异步传输以字节为独立的传输单位，字节之间的时间间隔不是固定的，接收端仅在每个字节的起始处对字节内的比特实现同步。为此，通常需要在每个字节前后分别加上起始位和结束位，这里的异步是指在字节级上的异步，但是字节中的每个比特仍然要同步，它们的持续时间是相同的。</p><p>采用同步传输方式时，数据块以稳定的比特流形式传输，字节之间没有间隔，也没有起始位和结束位。由于不同设备的时钟频率存在一定差异，为避免在传输大量数据的过程中累积误差所导致的错误，要采取技术使得收发双方的时钟保持同步。实现收发双方时钟同步的方法有两种，即外同步和内同步。</p><p><strong>外同步</strong>，是在发送端和接收端之间提供一条单独的时钟线，发送端在发送数据信号的同时，另外发送一条时钟同步信号。接收端根据接收到的时钟同步信号来校正时间基准，实现收发双方之间的同步。</p><p><strong>内同步</strong>，是发送端将时钟同步信号编码到发送数据中一起传输，如曼彻斯特编码与差分曼彻斯特编码都含有时钟编码，具有自同步能力。</p></li><li><p>单工、半双工、全双工</p><p>1）单向通信，又称为单工通信，即只能有一个方向的通信而没有反方向的交互。如广播等。</p><p>2）双向交替通信，又称半双工通信，即通信的双方都可以发送信息，但不能双方同时发送。这种通信方式是一方发送另一方接收，过一段时间再反回来。</p><p>3）双向同时通信，又称为全双工通信，即通信的双方可以同时发送和接收信息。</p></li></ol></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;写在前面&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;物理层协议的主要任务就是确定与传输媒体的接口有关的一些特性，如下所述：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;机械特性：指明接口所用接线器的形状和尺寸、引脚数目和排列、固定和锁定装置等。&lt;/li&gt;
&lt;li&gt;电
      
    
    </summary>
    
      <category term="计算机网络" scheme="http://wanqbin.coding.me/Aoki/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="通信" scheme="http://wanqbin.coding.me/Aoki/tags/%E9%80%9A%E4%BF%A1/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络概述</title>
    <link href="http://wanqbin.coding.me/Aoki/2019/06/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%A6%82%E8%BF%B0/"/>
    <id>http://wanqbin.coding.me/Aoki/2019/06/10/计算机网络概述/</id>
    <published>2019-06-09T16:40:00.000Z</published>
    <updated>2019-06-13T16:41:26.557Z</updated>
    
    <content type="html"><![CDATA[<h4 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h4><p>一般认为，计算机网路是一个将分散的、具有独立功能的计算机系统，通过通信设备与线路连接在一起，由功能完善的软件实现资源共享和信息传递的系统。简言之，计算机网络就是一些互联的、自治的计算机系统的集合。 </p><h2 id="一、计算机网络"><a href="#一、计算机网络" class="headerlink" title="一、计算机网络"></a>一、计算机网络</h2><p>在计算机的不同发展阶段，网络有不同的定义，这些定义反映了当时网络技术的发展水平。分为三类：</p><ol><li><p>广义观点</p><p>广义观点认为，只要是能实现远程信息处理的系统或能进一步达到资源共享的系统，，都是计算机网络。</p></li><li><p>资源共享观点</p><p>资源共享观点认为，计算机网络是“以能够相互共享资源的方式互联起来的自治计算机系统的集合”。这个定义符合目前计算机网络的基本特征。</p></li><li><p>用户透明性观点</p><p>这种观点认为，存在一个能为用户自动管理资源的网络操作系统。它能够调用用户所需要的资源，而整个网络就像是一个大的计算机系统一样对用户是透明的。用户透明性观点的定义描述了一个分布式系统，它是网络未来发展追求的目标。</p></li></ol><h2 id="二、计算机网络的组成"><a href="#二、计算机网络的组成" class="headerlink" title="二、计算机网络的组成"></a>二、计算机网络的组成</h2><p>从不同的角度，可以将计算机网路的组成分为以下几类：</p><ol><li>从组成部分上来看，一个完整的计算机网络主要由硬件、软件、协议散发部分组成。<strong>硬件</strong>主要由主机（端系统）、通信链路（如双绞线、光纤）、交换设备（如交换机、路由器）和通信处理机（如网卡）等组成。<strong>软件</strong>主要包括各种实现资源共享的软件和方便用户使用的各种工具软件。软件部分多属于应用层。<strong>协议</strong>是计算机网络的核心。</li><li>从工作方式看，计算机网络可分为边缘部分和核心部分。边缘部分由所有连接到因特网上、供用户使用的端系统组成，用来进行通信和资源共享。核心部分由大量的网络和连接这些网络的路由器组成，为边缘部分提供连通性和交换服务。</li><li>从功能组成上看，计算机网络由通信子网和资源子网构成。通信子网由各种传输介质、通信设备和相应的网络协议组成，它使网络具有数据传输、交换、控制和存储的能力，实现联网计算机之间的数据通信。资源子网是实现资源共享功能的设备及其软件的集合，向用户提供共享其他其他计算机上的硬件资源、软件资源和数据资源的服务。</li></ol><h2 id="三、计算机网络的功能"><a href="#三、计算机网络的功能" class="headerlink" title="三、计算机网络的功能"></a>三、计算机网络的功能</h2><p>计算机网路的功能很多，现如今的很多应用都与网络有关。主要有下面5个部分。</p><ol><li><p>数据通信</p><p>它是计算机网络最基本也是最重要的功能，用来实现联网计算机之间的各种信息的传输，并将分散在不同地理位置的计算机联系起来，进行统一的调配、控制和管理。</p></li><li><p>资源共享</p><p>资源共享可以是软件共享、数据共享，也可以是硬件共享。使计算机网络中的资源互通有无，分工协作，从而极大地提高了硬件资源、软件资源和数据资源的利用率</p></li><li><p>分布式处理</p><p>当计算机网络中的某个计算机负荷过重时，可以将其处理的某个复杂的任务分配给网络中的其他计算机系统，从而利用空闲资源以提高整个系统的利用率</p></li><li><p>提高可靠性</p><p>计算机网络中的各台计算机通过网络互为替代机</p></li><li><p>负载均衡</p><p>将工作任务均衡地分配给计算机网络中的各台计算机。</p></li></ol><h2 id="四、计算机网络的分类"><a href="#四、计算机网络的分类" class="headerlink" title="四、计算机网络的分类"></a>四、计算机网络的分类</h2><ol><li><p>按分布范围分：</p><p>1) 广域网（WAN）。任务是提供长距离通信，运送主机所发送的数据。</p><p>2）城域网（MAN）。城域网的覆盖范围可以跨越几个街区甚至几个城市，大多采用以太网技术。</p><p>3）局域网（LAN）。局域网一般用微机或工作站通过高速线路相连，覆盖范围较小。传统上，局域网使用广播技术，而广域网使用交换技术。</p><p>4）个人局域网（PAN）。在个人工作的地方将消费电子设备用无线技术连接起来的网络。</p></li><li><p>按传输技术分：</p><p>1）广播式网络。所有联网计算机都共享一个公共通信信道。当一台计算机利用共享通信信道发送报文分组时，所有其他的计算机都会“收听”到这个分组。接收到该分组的计算机将通过检查目的地址来决定是否接收该分组。</p><p>局域网基本上都采用广播式通信技术，广域网中的无线，卫星通信网络也采用广播式通信技术。</p><p>2）点对点网络。每条物理线路连接一对计算机。如果通信的两台计算机之间没有直接连接线路，那么它们之间的分组传输就要通过中间结点的接收、存储和转发，直至目的结点。</p><p>是否采用分组存储转发与路由选择机制是点对点网络与广播式网络的重要区别，广域网基本都属于点对点网络。</p></li><li><p>按拓扑结构分:</p><p>网络拓扑结构是指由网中结点（路由器、主机等）与通信线路（网线）之间的几何关系表示的网络结构，主要指通信子网的拓扑结构。</p><p>按网络的拓扑结构，主要分为星形、总线形、环形和网状形网络等。星形、总线形和环形网络多用于局域网，网状网络多用于广域网。</p><p>1）星形网络。每个终端或计算机都以单独的线路与中央设备相连。中央设备早期是计算机，现在一般是交换机或路由器。星形网络便于集中控制和管理，因为端用户之间的通信必须通过中间设备。缺点是成本高，中心节点对故障敏感。</p><p>2）总线形网络。用单根传输线将计算机连接起来。总线形网络的优点是建网容易，增减节点方便，节省线路。缺点是重负载时通信效率不高，总线任意一处对故障敏感。</p><p>3）环形网络。所有计算机接口设备连接成一个环。环形网络最典型的例子是令牌环局域网。环可以是单环，也可以是双环，环中信号是单向传输的。</p><p>4）网状网络。一般情况下，每个结点至少有两条路径与其他节点相连，多用于广域网中。有规则型和非规则型。其优点是可靠性高，缺点是控制复杂，线路成本高。</p></li><li><p>按使用者分:</p><p>1）公用网。指电信公司出资建造的大型网络。</p><p>2）专用网。指某个部门为了满足本单位特殊业务的需要而建造的网络，这种网络不对单位以外的人开放。</p></li><li><p>按交换技术分：</p><p>1）电路交换网络。在源结点和目的结点之间建立一条专用的通路用于传送数据，包括建立连接、传输数据和断开连接三个阶段。最典型的电路交换网络是传统电话网络。</p><p>该类网络的主要特点是整个报文的比特流连续地从源点直达终点，好像是在一条管道中传送。优点是数据直接传送，时延小。缺点是线路利用率低、不能充分利用线路容量，不便于进行差错控制。</p><p>2）报文交换网络。用户数据加上源地址、目的地址、校验码等辅助信息，然后封装成报文。整个报文传送到相邻结点全部存储后，再转发到下一个结点，重复这一过程直到到达目的结点。每个报文可以单独选择到达目的结点的路径。</p><p>报文交换网络也称存储-转发网络，主要特点是整个报文先传送到相邻结点，全部存储后查找转发表，转发到下一个结点。优点是可以较为充分的利用线路容量，可以实现不同链路之间不同数据率的转换，可以实现格式转换，可以实现一对多，多对一的访问，可以实现差错控制。缺点是增大了资源开销，增加了缓冲时延，需要额外的控制机制来保证多个报文的顺序不乱序，缓冲区难以管理。</p><p>3）分组交换网络。也称包交换网络。其原理是将数据分为较短的固定长度的数据块，在每个数据块中加上目的地址、源地址等辅助信息组成分组（包），以存储-转发方式传输。</p><p>其主要特点是单个分组传送到相邻结点，存储后查找转发表，转发到下一个结点。除具备报文交换网络的优点外，分组交换网络还具有自身的优点：缓冲易于管理；包的平均时延更小，网络占用的平均缓冲更少；易于标准化；更适合应用。现在的主流网络基本上都可视为分组交换网络。</p></li><li><p>按传输介质分：</p><p>传输介质可分为有线和无线两大类，故网络可分为有线网络和无线网络。有线网络又分为双绞线网络，同轴电缆网络等。无线网络可分为蓝牙、微波、无线电等。</p></li></ol><h2 id="五、计算机网络的的性能指标"><a href="#五、计算机网络的的性能指标" class="headerlink" title="五、计算机网络的的性能指标"></a>五、计算机网络的的性能指标</h2><p>性能指标从不同的方面来度量计算机网络的性能。</p><ol><li><p>速率</p><p>速率是数据的传送速率，它也称为数据率或比特率。</p></li><li><p>带宽</p><p>本来表示某个信号具有的频带宽度，单位是赫兹（Hz），而在计算机网络分钟，带宽用来表示网络的通信线路所能传送数据的能力，单位是比特/秒（b/s）</p></li><li><p>吞吐量</p><p>也称为吞吐率，表示单位时间内通过某个网络（或信道、接口）的数据量。</p></li><li><p>时延</p><p>时延是指一个数据（一个报文或分组，甚至比特）从网路（或链路）的一端传送到另一端所需要的时间。时延有时称为延迟或迟延。</p><p>1）发送时延，是主机或路由器将分组发送到通信线路上所需要的时间。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">发送时延=分组长度/发送速率</span><br></pre></td></tr></table></figure><p>2）传播时延，是电磁波在信道中传播需要一定的距离而花费的时间。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">传播时延=信道长度/电磁波在信道上的传播速率</span><br></pre></td></tr></table></figure><p>3）处理时延，主机或路由器收到分组时要花费一定的时间进行处理，例如，分析分组的首部、从分组中提取数据部分、进行差错检验或查找适当的路由等，这就产生了处理时延。</p><p>4）排队时延，分组在进入路由器后要先在输入队列在排队等待处理。路由器确定转发端口后，还要在输出队列中排队等待转发，这就产生了排队时延。</p><p>这样，分组从一个结点转发到另一个结点转发到另一个结点所经历的时延就是以上4种时延之和。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">总时延=发送时延+传播时延+处理时延+排队时延</span><br></pre></td></tr></table></figure></li><li><p>丢包率</p><p>即分组丢失率，是指在一定的时间范围内，分组在传输过程中丢失的分组数量和总的分组数量的比率。</p><p>分组丢失的两种情况：一是因为传输过程中出现比特级差错被结点丢弃。二是因为分组交换机队列溢出。</p></li><li><p>利用率</p><p>令D0表示网络空闲时的时延，D表示网络当前时延，那么在适当的假定条件下，利用率可表示为：D=D0/1-U。</p><p>信道或网络利用率过高会产生非常大的时延。</p></li><li><p>时延带宽积</p><p>指发送端连续发送数据且发送的第一个比特即将到达终点时，发送端已经发出的比特数，即时延带宽积=传播时延*信道带宽。</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h4&gt;&lt;p&gt;一般认为，计算机网路是一个将分散的、具有独立功能的计算机系统，通过通信设备与线路连接在一起，由功能完善的软件实现资源共享和信
      
    
    </summary>
    
    
      <category term="计算机网络" scheme="http://wanqbin.coding.me/Aoki/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>单链表的实现</title>
    <link href="http://wanqbin.coding.me/Aoki/2019/03/27/%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E5%AE%9E%E7%8E%B0/"/>
    <id>http://wanqbin.coding.me/Aoki/2019/03/27/单链表的实现/</id>
    <published>2019-03-26T16:51:00.000Z</published>
    <updated>2019-06-13T16:51:59.798Z</updated>
    
    <content type="html"><![CDATA[<h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>&emsp;链式存储结构是计算机中另一种最基本和最主要的数据存储结构。和顺序存储结构不同，初始化时链式存储结构为空链，每当有新的元素需要存储时用户向系统动态申请所需的存储空间插入链中。所有高级程序设计语言都为用户提供了向系统动态申请和动态释放存储空间的办法。C++提供了<code>new</code><br>和<code>delete</code>运算符，分别用于向系统动态申请所需存储空间和动态释放用new申请的存储空间。new能自动计算要分配的类型大小并自动返回正确的指针类型。delete能自动释放由new分配的存储空间。<br>&emsp;&emsp;在顺序存储结构中，用户向系统申请一块地址连续的有限空间用于存储数据元素，这样任意两个在逻辑上相邻的数据元素在物理上也必然相邻。但在链式存储结构中，由于它在初始化时为空链，每当有新的数据元素需要存储时用户才向系统动态申请所需的存储空间插入链中，而这些在不同时刻向系统动态申请的存储空间在内存上很可能是不连续的。因此，在链式存储结构中，任意两个在逻辑上相邻的数据元素在物理上不一定相邻，数据元素的逻辑次序是通过链中的指针连接实现的。<br> &emsp;&emsp;链式存储结构存储线性结构数据元素集合的方法是用节点（Node)构造链。线性结构数据元素的特点是：除第一个和最后一个元素外，每个元素只有一个唯一的前驱和一个唯一的后继。链式结构中每个节点除数据域外，还有一个或两个以上的指针域，数据域用来存放数据元素，指针域用来构造数据元素之间的关系。</p><blockquote><h1 id="1-单链表"><a href="#1-单链表" class="headerlink" title="1.单链表"></a>1.单链表</h1></blockquote><p>&emsp;单链表简称链表（linked list)，是表数据元素的单链结构存储。链表使用一个一个的节点链接构成的。<br>&emsp;&emsp;表要求允许在任意位置进行插入和删除。当选用带头节点的单链表时，在第一个位置插入节点和在其他位置插入节点一样不会改变头指针<code>head</code>的值，此时改变的是<code>head-&gt;next</code>的值。<br>&emsp;在第一个位置删除节点和在其他位置删除节点一样也不会改变头指针<code>head</code>的值，此时改变的也是<code>head-&gt;next</code>的值。  </p><blockquote><h1 id="2-节点类的定义和实现"><a href="#2-节点类的定义和实现" class="headerlink" title="2.节点类的定义和实现"></a>2.节点类的定义和实现</h1></blockquote><p>&emsp;在单链表中，每个节点构成包括数据域和指针域两部分。每个节点的基本操作包括构造一个节点对象、建立一个新节点、给出当前节点的下一个节点指针等。  </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">ListNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">LinList</span>&lt;T&gt;;</span><span class="comment">//声明友元类</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">T data;<span class="comment">//数据域</span></span><br><span class="line">ListNode(ListNode&lt;T&gt; *ptrNext = <span class="literal">NULL</span>);<span class="comment">//构造函数，用于构造头节点，头节点没有data参数</span></span><br><span class="line">ListNode(<span class="keyword">const</span> T &amp;item, ListNode&lt;T&gt; *ptrNext = <span class="literal">NULL</span>);<span class="comment">//构造函数，主要用于构造非头节点的节点</span></span><br><span class="line">~ListNode() &#123;&#125;;<span class="comment">//析构函数</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">ListNode&lt;T&gt; *next;<span class="comment">//指向下一节点的指针</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">ListNode</span>&lt;T&gt;:</span>:ListNode(ListNode&lt;T&gt;* ptrNext):next(ptrNext)</span><br><span class="line">&#123;&#125;<span class="comment">//构造函数，用于构造头节点，头节点没有值</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">ListNode</span>&lt;T&gt;:</span>:ListNode(<span class="keyword">const</span> T &amp; item, ListNode&lt;T&gt;* ptrNext)</span><br><span class="line">&#123;<span class="comment">//构造函数，用于构造非头节点的节点</span></span><br><span class="line">data = item;</span><br><span class="line">next = ptrNext;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;节点类的成员有<code>data</code>域和<code>next</code>域。data域中存放了该节点的数据值，由于应用问题中需要使用链表中的data值，所以定义为公有数据成员方便使用；next域定义为私有数据成员。节点类的成员函数由两个不同参数的构造函数和空的析构函数。析构函数为空是因为节点类中没有用new函数向系统申请空间，而节点对象本身分配的空间，系统可自动识别释放。  </p><br><blockquote><h1 id="3-单链表类的定义"><a href="#3-单链表类的定义" class="headerlink" title="3.单链表类的定义"></a>3.单链表类的定义</h1></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">LinList</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">LinList();<span class="comment">//构造函数</span></span><br><span class="line">~LinList();<span class="comment">//析构函数</span></span><br><span class="line"><span class="comment">//表操作成员函数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">listsize</span><span class="params">()</span> <span class="keyword">const</span></span>;<span class="comment">//返回链表中元素的个数</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">listempty</span><span class="params">()</span> <span class="keyword">const</span></span>;<span class="comment">//链表是否为空</span></span><br><span class="line">ListNode&lt;T&gt; *index(<span class="keyword">int</span> pos);<span class="comment">//返回指向第pos个节点的指针</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">const</span> T&amp; item, <span class="keyword">int</span> pos)</span></span>;<span class="comment">//在pos节点前插入一个data域为item的元素</span></span><br><span class="line"><span class="function">T <span class="title">Delete</span><span class="params">(<span class="keyword">int</span> pos)</span></span>;<span class="comment">//删除第pos个节点并返回被删除节点的data域</span></span><br><span class="line"><span class="function">T <span class="title">getdata</span><span class="params">(<span class="keyword">int</span> pos)</span></span>;<span class="comment">//返回第pos个节点的data值</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clearlist</span><span class="params">()</span></span>;<span class="comment">//清空表为初始化状态</span></span><br><span class="line"><span class="comment">//遍历链表的成员函数</span></span><br><span class="line">ListNode&lt;T&gt; *Reset(<span class="keyword">int</span> pos = <span class="number">0</span>);<span class="comment">//currPtr指向节点pos并返回currPtr</span></span><br><span class="line">ListNode&lt;T&gt; *Next();<span class="comment">//currPtr指向下一个节点并返回currPtr</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">endOfList</span><span class="params">()</span> <span class="keyword">const</span></span>;<span class="comment">//currPtr==head？</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">ListNode&lt;T&gt; *head;<span class="comment">//指向头节点的指针</span></span><br><span class="line">ListNode&lt;T&gt; *currPtr;<span class="comment">//当前指针</span></span><br><span class="line"><span class="keyword">int</span> size;<span class="comment">//单链表中元素的个数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>&emsp;单链表类的数据成员有头指针、元素个数和当前节点指针。头指针指向头结点，任何对单链表中节点的操作都要从头指针进入。初始化状态下，节点个数为0.当前节点指针是遍历链表成员函数使用的数据成员，遍历链表成员函数通过控制当前节点指针来遍历链表。<br>&emsp;&emsp;单链表类的成员函数由三组：构造函数和析构函数、表操作的成员函数和遍历链表的成员函数。由于单链表类中的节点是通过new函数向系统申请的，在释放单链表类对象的时候，系统无法自行释放这些空间，所以析构函数不能为空，析构函数必须用delete函数逐个释放这些空间。表操作成员函数时对表操作的基本成员函数，这与顺序表类中对表进行操作的成员函数意义相同，但是实现方法不同。链表的遍历操作是每次寻找当前节点的下一个节点，由于每次对链表类中节点的操作都要从头指针进入后寻找到相应的节点后才可完成，这样的单链表类遍历操作的时间复杂度返回大大增加，在单链表中增加一组遍历链表的成员函数可使单链表遍历操作的时间复杂度不增加。<br><br></p><blockquote><h1 id="4-单链表类的实现"><a href="#4-单链表类的实现" class="headerlink" title="4.单链表类的实现"></a>4.单链表类的实现</h1></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">LinList</span>&lt;T&gt;:</span>:LinList()</span><br><span class="line">&#123;</span><br><span class="line">head = <span class="keyword">new</span> ListNode&lt;T&gt;();<span class="comment">//头指针指向头结点</span></span><br><span class="line">size = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">LinList</span>&lt;T&gt;:</span>:~LinList()</span><br><span class="line">&#123;</span><br><span class="line">clearlist();</span><br><span class="line"><span class="keyword">delete</span> head;</span><br><span class="line">head = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">int</span> <span class="title">LinList</span>&lt;T&gt;:</span>:listsize() <span class="keyword">const</span><span class="comment">//返回单链表中元素的个数</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">bool</span> <span class="title">LinList</span>&lt;T&gt;:</span>:listempty() <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> size == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">ListNode</span>&lt;T&gt;* <span class="title">LinList</span>&lt;T&gt;:</span>:index(<span class="keyword">int</span> pos)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (pos == <span class="number">-1</span>)</span><br><span class="line"><span class="keyword">return</span> head;</span><br><span class="line"><span class="keyword">if</span> (pos&lt;<span class="number">0</span> || pos&gt;size)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"illegal operator"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ListNode&lt;T&gt; *p = head-&gt;next;<span class="comment">//p指向第一个节点</span></span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (p != <span class="literal">NULL</span> &amp;&amp; i &lt; pos)</span><br><span class="line">&#123;</span><br><span class="line">p = p-&gt;next;</span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> <span class="title">LinList</span>&lt;T&gt;:</span>:insert(<span class="keyword">const</span> T &amp; item, <span class="keyword">int</span> pos)</span><br><span class="line">&#123;</span><br><span class="line">ListNode&lt;T&gt; *p = index(pos - <span class="number">1</span>);</span><br><span class="line">ListNode&lt;T&gt; *newnode = <span class="keyword">new</span> ListNode&lt;T&gt;(item, p-&gt;next);</span><br><span class="line">p-&gt;next = newnode;</span><br><span class="line">size++;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">T</span> <span class="title">LinList</span>&lt;T&gt;:</span>:Delete(<span class="keyword">int</span> pos)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (size == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"list is empty"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">ListNode&lt;T&gt;*q, *p = index(pos - <span class="number">1</span>);<span class="comment">//p为指向第pos-1个节点的指针</span></span><br><span class="line">q = p-&gt;next;<span class="comment">//q指向要删除节点</span></span><br><span class="line">p-&gt;next = p-&gt;next-&gt;next;<span class="comment">//p指向要删除节点的后一节点</span></span><br><span class="line">T data = q-&gt;data;  <span class="comment">//data保存要删除节点值</span></span><br><span class="line"><span class="keyword">delete</span> q;</span><br><span class="line">size--;</span><br><span class="line"><span class="keyword">return</span> data;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">T</span> <span class="title">LinList</span>&lt;T&gt;:</span>:getdata(<span class="keyword">int</span> pos)</span><br><span class="line">&#123;</span><br><span class="line">ListNode&lt;T&gt; *p = index(pos);<span class="comment">//指针p指向第pos个节点</span></span><br><span class="line"><span class="keyword">return</span> p-&gt;data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> <span class="title">LinList</span>&lt;T&gt;:</span>:clearlist()</span><br><span class="line">&#123;</span><br><span class="line">ListNode&lt;T&gt; *p, *p1;</span><br><span class="line">p = head-&gt;next;</span><br><span class="line"><span class="keyword">while</span> (p != <span class="literal">NULL</span>)</span><br><span class="line">&#123;<span class="comment">//delete所有new出来的空间</span></span><br><span class="line">p1 = p;</span><br><span class="line">p = p-&gt;next;</span><br><span class="line"><span class="keyword">delete</span> p1;</span><br><span class="line">&#125;</span><br><span class="line">size = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">ListNode</span>&lt;T&gt;* <span class="title">LinList</span>&lt;T&gt;:</span>:Reset(<span class="keyword">int</span> pos)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (head == <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">if</span> (pos &lt; <span class="number">-1</span> || pos&gt;size)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"mistake"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (pos == <span class="number">-1</span>)</span><br><span class="line"><span class="keyword">return</span> head;</span><br><span class="line"><span class="keyword">if</span> (pos == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">currPtr = head-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">currPtr = head-&gt;next;</span><br><span class="line">ListNode&lt;T&gt; prevPtr = head;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pos; i++)</span><br><span class="line">&#123;</span><br><span class="line">prevPtr = currPtr;</span><br><span class="line">currPtr = currPtr-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> currPtr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">ListNode</span>&lt;T&gt;* <span class="title">LinList</span>&lt;T&gt;:</span>:Next()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (currPtr != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">currPtr = currPtr-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> currPtr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">bool</span> <span class="title">LinList</span>&lt;T&gt;:</span>:endOfList() <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> currPtr == <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这些成员函数基本上实现了单链表所需的基本操作。   </p><blockquote><h1 id="5-主函数测试"><a href="#5-主函数测试" class="headerlink" title="5.主函数测试"></a>5.主函数测试</h1></blockquote><p>测试主函数如下：  </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">LinList&lt;<span class="keyword">int</span>&gt; <span class="built_in">list</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"单链表中的元素个数为："</span>&lt;&lt;<span class="built_in">list</span>.listsize() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">list</span>.insert(<span class="number">15</span> * i, i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"单链表中的元素个数为："</span> &lt;&lt; <span class="built_in">list</span>.listsize() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"5号为："</span> &lt;&lt; <span class="built_in">list</span>.getdata(<span class="number">5</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="built_in">list</span>.Delete(<span class="number">5</span>)&lt;&lt;<span class="string">"已被删除"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"5号为："</span> &lt;&lt; <span class="built_in">list</span>.getdata(<span class="number">5</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">ListNode&lt;<span class="keyword">int</span>&gt; *p = <span class="built_in">list</span>.Reset();</span><br><span class="line"><span class="keyword">while</span> (!<span class="built_in">list</span>.endOfList())</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; p-&gt;data &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">p = <span class="built_in">list</span>.Next();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">test();</span><br><span class="line">system(<span class="string">"pause"</span>);</span><br><span class="line"><span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果如下：<br><img src="https://i.imgur.com/3UiALqf.png" alt>  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h2&gt;&lt;p&gt;&amp;emsp;链式存储结构是计算机中另一种最基本和最主要的数据存储结构。和顺序存储结构不同，初始化时链式存储结构为空链，每当有
      
    
    </summary>
    
      <category term="数据结构" scheme="http://wanqbin.coding.me/Aoki/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="单链表" scheme="http://wanqbin.coding.me/Aoki/tags/%E5%8D%95%E9%93%BE%E8%A1%A8/"/>
    
      <category term="数据结构" scheme="http://wanqbin.coding.me/Aoki/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>宏缺陷和内联函数</title>
    <link href="http://wanqbin.coding.me/Aoki/2019/03/18/%E5%AE%8F%E7%BC%BA%E9%99%B7%E5%92%8C%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0/"/>
    <id>http://wanqbin.coding.me/Aoki/2019/03/18/宏缺陷和内联函数/</id>
    <published>2019-03-18T15:17:00.000Z</published>
    <updated>2019-06-13T16:20:08.373Z</updated>
    
    <content type="html"><![CDATA[<blockquote><h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2></blockquote><p>C++从C中继承的一个重要特征就是效率。  </p><p>在C中我们经常把一些短并且执行频繁的计算写成宏，而不是函数，这样做的理由方式为了执行效率，宏可以避免函数调用的开销，这些都由预处理来完成。  </p><p>但是在C++出现以后，使用宏处理会出现两个问题：  </p><ul><li>第一个在C中也会出现，宏看起来像是一个函数调用，但是会隐藏一些难以发现的错误。  </li><li>第二个问题是C++特有的，预处理器不允许访问类的成员，也就是说预处理器宏不能用作类的成员的函数。  </li></ul><p>为了保持预处理宏的效率又增加安全性，而且能像一般成员函数那样在类里访问自如，C++引入了内联函数。  </p><p>内联函数为了继承宏函数的效率，没有函数调用的开销，然后又可以像普通函数那样，可以进行参数、返回值类型的安全检查，又可以作为成员函数。  </p><hr><blockquote><h1 id="1-预处理宏的缺陷"><a href="#1-预处理宏的缺陷" class="headerlink" title="1.预处理宏的缺陷"></a>1.预处理宏的缺陷</h1></blockquote><hr><p>预处理器宏存在问题的关键是我们可能认为预处理器的行为和编译器时一样的。当然也是由于宏函数调用和函数调用在外表看起来是一样的，因此也容易混淆。但是其中会有一些微妙的问题出现。  </p><h3 id="例1"><a href="#例1" class="headerlink" title="例1"></a>例1</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ADD(x,y) x+y</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ret = ADD(<span class="number">10</span>, <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ret0 = ADD(<span class="number">10</span>, <span class="number">10</span>) * <span class="number">10</span>;<span class="comment">//预期结果为200</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"ret="</span> &lt;&lt; ret &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"ret0="</span> &lt;&lt; ret0 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    test();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果如下：  </p><p><img src="https://i.imgur.com/4R0ff3I.png" alt>  </p><p>在输出结果里，我们可以看到，实际输出结果为110，并不是我们想要的结果。它实际进行运算时，运算式应该是：10+10*10。  </p><p>对于这个微小的问题，我们可以通过加括号的方式来解决它。源代码和输出结果如下：  </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ADD(x,y) ((x)+(y))</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ret = ADD(<span class="number">10</span>, <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ret0 = ADD(<span class="number">10</span>, <span class="number">10</span>) * <span class="number">10</span>;<span class="comment">//预期结果为200</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"ret="</span> &lt;&lt; ret &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"ret0="</span> &lt;&lt; ret0 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    test();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果如下：  </p><p><img src="https://i.imgur.com/pk7Yv4A.png" alt>  </p><p>我们可以看到，加括号之后，输出结果和预期相同。  </p><h3 id="例2"><a href="#例2" class="headerlink" title="例2"></a>例2</h3><p>为了防止出现例1中的问题，这次，我特意对三目运算符加了括号。代码如下：  </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> compare(a,b) ((a)&lt;(b))?(a):(b)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ret = compare(a, b);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"ret="</span> &lt;&lt; ret &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ret0 = compare(++a, b);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"ret0="</span> &lt;&lt; ret0 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    test();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果如下:  </p><p><img src="https://i.imgur.com/sTiAySo.png" alt>  </p><p>这次出现的问题让人有点摸不到头脑，因此++运算符表示在进行运算之前加1，但是输出结果中，实际输出为12，相当于加了两次。  </p><p>除此之外，我们还应当注意的是，预定义宏函数没有作用域概念，无法作为一个类的成员函数，也就是说，预定义宏没办法表示类的范围。  </p><hr><blockquote><h1 id="2-内联函数"><a href="#2-内联函数" class="headerlink" title="2.内联函数"></a>2.内联函数</h1></blockquote><hr><p>在C++中，预定义宏额概念是用内联函数来实现的，而内联函数本身也是一个真正的函数。内联函数具有普通函数的所有行为。唯一不同之处在于内联函数会在适当得到地方像预定义宏一样展开，所以不需要函数调用的开销。因此应该不使用宏，使用内联函数。   </p><p>普通函数（非成员函数）函数前面加上inline关键字使之成为内联函数。但是必须注意函数体和声明结合在一起，否则编译器会把它当成普通函数对待。  </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> a)</span></span>;</span><br></pre></td></tr></table></figure><p>上面的这种写法没有任何效果，仅仅是声明函数，应该像下面这样的方式来定义。   </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> a)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ++;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：编译器将会检查函数参数列表使用是否正确，并返回值（进行必要的转换）。这些事预处理器是无法完成的。  </p><p>内联函数的确占用空间，但是内联函数相对于普通函数的优势只是省去了函数调用是否的压栈、跳转、返回的开销。我们可以理解为内联函数是以空间换时间。  </p><p>内联说明只是向编译器发出一个请求，编译器可以选择忽略这个请求。  </p><p>一般来说，内联机制用于优化规模较小、流程直接、频繁调用的函数。很多编译器都不支持内联函数递归函数，而且一个75行的函数也不太可能在调用点内联地展开。  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;h2 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h2&gt;&lt;/blockquote&gt;
&lt;p&gt;C++从C中继承的一个重要特征就是效率。  &lt;/p&gt;
&lt;p&gt;在C中我们
      
    
    </summary>
    
    
      <category term="宏缺陷" scheme="http://wanqbin.coding.me/Aoki/tags/%E5%AE%8F%E7%BC%BA%E9%99%B7/"/>
    
      <category term="内联函数" scheme="http://wanqbin.coding.me/Aoki/tags/%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>函数默认参数及占位参数</title>
    <link href="http://wanqbin.coding.me/Aoki/2019/03/18/%E5%87%BD%E6%95%B0%E9%BB%98%E8%AE%A4%E5%8F%82%E6%95%B0%E5%8F%8A%E5%8D%A0%E4%BD%8D%E5%8F%82%E6%95%B0/"/>
    <id>http://wanqbin.coding.me/Aoki/2019/03/18/函数默认参数及占位参数/</id>
    <published>2019-03-17T16:33:00.000Z</published>
    <updated>2019-06-13T16:34:31.065Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-函数默认参数"><a href="#1-函数默认参数" class="headerlink" title="1.函数默认参数"></a>1.函数默认参数</h1><p>C++在声明函数原型时可为一个或多个参数指定默认（缺省）的参数值，当函数调用的时候如果没有指定这个值，编译器会自动用默认值代替。  </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func01</span><span class="params">(<span class="keyword">int</span> a = <span class="number">10</span>, <span class="keyword">int</span> b = <span class="number">100</span>)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"a+b="</span> &lt;&lt; a + b &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func02</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b = <span class="number">12</span>, <span class="keyword">int</span> c = <span class="number">11</span>)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"a="</span> &lt;&lt; a &lt;&lt; <span class="string">",b="</span> &lt;&lt; b &lt;&lt; <span class="string">",c="</span> &lt;&lt; c &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func03</span><span class="params">(<span class="keyword">int</span> a = <span class="number">0</span>, <span class="keyword">int</span> b = <span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func03</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"a="</span> &lt;&lt; a &lt;&lt; <span class="string">",b="</span> &lt;&lt; b &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    func01();<span class="comment">//使用默认参数</span></span><br><span class="line"></span><br><span class="line">    func01(<span class="number">100</span>, <span class="number">100</span>);<span class="comment">//使用现在传入的参数</span></span><br><span class="line"></span><br><span class="line">    func01(<span class="number">110</span>);<span class="comment">//只传入一个参数，第二个参数使用默认参数</span></span><br><span class="line"></span><br><span class="line">    func02(<span class="number">12</span>);<span class="comment">//b，c使用默认参数</span></span><br><span class="line"></span><br><span class="line">    func03();<span class="comment">//没有传参数，使用默认参数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果如下：  </p><p><img src="https://i.imgur.com/WiQCfY9.png" alt></p><p>注意点：  </p><ul><li>函数的默认常数函数从左往右，如果一个参数设置了默认参数，那么这个参数之后的参数都必须设置默认参数。  </li><li>如果函数声明和函数定义分开写，函数声明与函数定义不能同时设置默认参数。  </li></ul><blockquote><h1 id="2-函数的占位符"><a href="#2-函数的占位符" class="headerlink" title="2.函数的占位符"></a>2.函数的占位符</h1></blockquote><p>C++在声明函数时，可以使用占位参数。占位参数只有类型声明，而没有参数名声明。一般情况下，在函数体内无法使用占位参数。  </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func01</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span>)</span> </span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//函数内部无法使用占位参数</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; a + b &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func02</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> = <span class="number">10</span>)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//无法使用占位参数</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; a + b &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    func01(<span class="number">10</span>, <span class="number">15</span>, <span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">    func02(<span class="number">10</span>, <span class="number">25</span>);<span class="comment">//占位参数使用默认参数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果如下：  </p><p><img src="https://i.imgur.com/n9NYDzY.png" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-函数默认参数&quot;&gt;&lt;a href=&quot;#1-函数默认参数&quot; class=&quot;headerlink&quot; title=&quot;1.函数默认参数&quot;&gt;&lt;/a&gt;1.函数默认参数&lt;/h1&gt;&lt;p&gt;C++在声明函数原型时可为一个或多个参数指定默认（缺省）的参数值，当函数调用的时候如果没有指
      
    
    </summary>
    
    
      <category term="默认参数" scheme="http://wanqbin.coding.me/Aoki/tags/%E9%BB%98%E8%AE%A4%E5%8F%82%E6%95%B0/"/>
    
      <category term="占位参数" scheme="http://wanqbin.coding.me/Aoki/tags/%E5%8D%A0%E4%BD%8D%E5%8F%82%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>C++命名空间及using的使用</title>
    <link href="http://wanqbin.coding.me/Aoki/2019/03/16/C-%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%E5%8F%8Ausing%E7%9A%84%E4%BD%BF%E7%94%A8-1/"/>
    <id>http://wanqbin.coding.me/Aoki/2019/03/16/C-命名空间及using的使用-1/</id>
    <published>2019-03-15T16:22:00.000Z</published>
    <updated>2019-06-13T16:32:28.712Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、C-命名空间"><a href="#一、C-命名空间" class="headerlink" title="一、C++命名空间"></a>一、C++命名空间</h2><p>&emsp;在C++中，名称（name）可以是符号常量、变量、函数、结构、枚举、类和对象。工程越大，名称相互冲突性的可能性越大。另外，在使用多个厂商的类库时，也可能导致名称冲突。为了避免冲突，在大规模的设计中，以及程序员使用1各种各样的C++库时，这些标识符的命名发生冲突，标准C++引入关键字namesapce（命名空间/名字空间/名称空间），可以更好的控制标识符得到作用域。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//创建一个命名空间</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> study</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> learn</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"命名空间study的a="</span>&lt;&lt;study::a &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt;<span class="string">"命名空间learn的a="</span>&lt;&lt; learn::a &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果输出：  </p><p><img src="https://i.imgur.com/O4Nndw8.png" alt></p><p>在命名空间下，可以定义函数，变量、结构体、类；除此之外，对于命名空间的定义还应当注意，它必须定义在全局作用域下。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> study</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">namespace</span> A</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">sayhi</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"hi,Aoki"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">Student</span></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">        &#123;</span></span><br><span class="line"></span><br><span class="line">            <span class="built_in">string</span> name;</span><br><span class="line"></span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> learn</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//cout &lt;&lt; "命名空间study的a="&lt;&lt;study::a &lt;&lt; endl;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//cout &lt;&lt;"命名空间learn的a="&lt;&lt; learn::a &lt;&lt; endl;</span></span><br><span class="line"></span><br><span class="line">    study::A::sayhi();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"作用域A下的a="</span> &lt;&lt; study::A::a &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：  </p><p><img src="https://i.imgur.com/tRE7n6i.png" alt></p><p>下面是对命名空间错误定义的举例：  </p><p><img src="https://i.imgur.com/MrAHU0c.png" alt></p><p>对于命名空间，我们还可以定义无名命名空间，意味着命名空间中的标识符只能在本文件中访问，相当于给这个标识符加上了static，使得其可以作为内部连接。  </p><p>除此之外，还有就是给命名空间起别名，我们为命名空间A起别名为b，源码如下：  </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> A</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">namespace</span> b = A;<span class="comment">//给命名空间起别名为b</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt;<span class="string">"A作用域内a="</span>&lt;&lt; b::a &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="comment">//无名（匿名）命名空间</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> c = <span class="number">15</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> d = <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"c="</span> &lt;&lt; c &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"d="</span> &lt;&lt; d &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    A::test();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下图：  </p><p><img src="https://i.imgur.com/Ckyfiq4.png" alt></p><p>下面对命名空间namespace的用法总结如下：  </p><ul><li>命名空间的用途：解决名称冲突问题</li><li>命名空间下可以定义函数、变量、结构、类</li><li>命名空间必须定义在全局作用域下</li><li>命名空间可以嵌套命名空间</li><li>命名空间是开放的，可以随时给原先的命名空间添加内容</li><li>定义另个名字相同的命名空间时，两个命名空间会合并，但是不会覆盖</li><li>当我们定义了无名空间时，相当于写了<code>static intc=15，static int d=16</code>，只能在当前文件内使用</li></ul><h2 id="二、using声明"><a href="#二、using声明" class="headerlink" title="二、using声明"></a>二、using声明</h2><p>using声明可使得指定的标识符可用  </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span>  <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> One</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> test = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span>  <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> test = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">using</span> One::test;<span class="comment">//using声明</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"test="</span> &lt;&lt; test &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    test();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此处我们使用了using声明，但是编译却发生了错误。因为在test()中我们定义了一个整型数test，并赋予了初值。当我们使用using声明时，编译器有就近原则，它会选择输出test中定义的整型数，但是又发现有using声明，出现二义性问题，编译器不知道怎么处理，所有报错。报错信息如下：   </p><p><img src="https://i.imgur.com/42iUVR6.png" alt></p><p>所以，在using声明中，我们应当注意避免二义性问题。  </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span>  <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> One</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> test = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span>  <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> test = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//using One::test;//using声明</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"test="</span> &lt;&lt; test &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    test();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果如下图：  </p><p><img src="https://i.imgur.com/A4Emcx6.png" alt></p><p>using声明的一个例子：  </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span>  <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> One</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> test = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">99</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"hi,Aoki!"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">func1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"hello,Aoki!"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span>  <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"test="</span> &lt;&lt; One::a &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//using声明</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">using</span> One::a;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">using</span> One::func1;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">using</span> One::func;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"a="</span> &lt;&lt; a &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    func1();</span><br><span class="line"></span><br><span class="line">    func();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    test();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下图：  </p><p><img src="https://i.imgur.com/BS4Q4PE.png" alt></p><p>下面是using声明遇到函数重载的一个例子： </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span>  <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Two</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Nothing!"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span>  <span class="title">func</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"x="</span> &lt;&lt; x ;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">",y="</span> &lt;&lt; y &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">using</span> Two::func;</span><br><span class="line"></span><br><span class="line">    func();</span><br><span class="line"></span><br><span class="line">    func(<span class="number">15</span>);</span><br><span class="line"></span><br><span class="line">    func(<span class="number">15</span>, <span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    test1();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果如下图：  </p><p><img src="https://i.imgur.com/kcu5chb.png" alt></p><p>如果命名空间包含一组用相同名字重载的函数，using声明就声明了这个重载函数的所有集合。  </p><h2 id="三、using编译指令"><a href="#三、using编译指令" class="headerlink" title="三、using编译指令"></a>三、using编译指令</h2><p>using编译指令使整个命名空间标识符可用。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span>  <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> One</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">99</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"hi,Aoki!"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">func1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"hello,Aoki!"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span>  <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> One;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; a &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; b &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    func();</span><br><span class="line"></span><br><span class="line">    func1();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">100</span>;<span class="comment">//没有产生二义性</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; a &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Two</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//产生二义性</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> One;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> Two;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; a &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当我们像上面一样使用using编译指令时，会出现二义性问题，编译器无法通过编译。错误信息如下：  </p><p><img src="https://i.imgur.com/5w2NjKa.png" alt></p><p>当我们使用using声明或using编译指令时，会增加命名冲突的可能性。也就是说，如果有命名空间，并在代码中使用作用域解析运算符，则不会出现二义性问题。  </p><p>例子如下：  </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span>  <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> One</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">99</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"hi,Aoki!"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">func1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"hello,Aoki!"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span>  <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> One;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; a &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; b &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    func();</span><br><span class="line"></span><br><span class="line">    func1();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; a &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Two</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> One;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> Two;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//cout &lt;&lt; a &lt;&lt; endl;</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    test();</span><br><span class="line"></span><br><span class="line">    test1();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果如下：  </p><p><img src="https://i.imgur.com/SFV0e2y.png" alt></p><p>当我们引入一个全局的using编译指令时，就为该文件打开了命名空间，它不会影响其他的文件，所以可以再每一个实现文件中调整对命名空间的控制。比如，如果发现某一个实现文件中有太多using指令而产生命名冲突，就要对该文件做个简单的改变，通过明确限定或者using声明来消除名字冲突，这样不需要修改其他实现文件。  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、C-命名空间&quot;&gt;&lt;a href=&quot;#一、C-命名空间&quot; class=&quot;headerlink&quot; title=&quot;一、C++命名空间&quot;&gt;&lt;/a&gt;一、C++命名空间&lt;/h2&gt;&lt;p&gt;&amp;emsp;在C++中，名称（name）可以是符号常量、变量、函数、结构、枚举、类和对象
      
    
    </summary>
    
    
      <category term="命名空间" scheme="http://wanqbin.coding.me/Aoki/tags/%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4/"/>
    
      <category term="using的使用" scheme="http://wanqbin.coding.me/Aoki/tags/using%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    
  </entry>
  
  <entry>
    <title>关于const限定符的一些总结</title>
    <link href="http://wanqbin.coding.me/Aoki/2019/03/11/const%E9%99%90%E5%AE%9A%E7%AC%A6/"/>
    <id>http://wanqbin.coding.me/Aoki/2019/03/11/const限定符/</id>
    <published>2019-03-11T10:31:00.000Z</published>
    <updated>2019-06-11T10:36:12.688Z</updated>
    
    <content type="html"><![CDATA[<blockquote><h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1></blockquote><hr><p>有时候我们希望定义这样一种变量，它的值不能被改变。例如，用一个变量表示缓冲区的大小。使用变量的好处是我们觉得缓冲区不再合适的时候，很容易对其进行调整。另一方面，也应随时警惕，防止程序一不小心修改了这个值。为了满足这一要求，可以用关键词const对变量的类型加以限定。</p><p>在C++中，一个const不必创建内存空间，而在C中，const总是需要一块内存空间。在C++中，是否为const常量分配内存空间依赖于如何使用。一般来说，如果一个const仅仅用来把一个名字用一个值来代替，那么该存储空间就不必创建。</p><p>在存储空间没有分配内存的话，在进行完数据类型检查后，为了代码更加有效，值也许会折叠到代码中。<br>不过取一个const地址，或者把它定义为extern，则会为该const创建内存空间。  </p><p>在C++中，出现在所有函数之外的const作用于整个文件（也就是说它在该文件外部不可见，默认为内部连接，C++中其他标识符一般默认为外部连接。  </p><h2 id><a href="#" class="headerlink" title></a><br></h2><blockquote><h1 id="1-初始化和const"><a href="#1-初始化和const" class="headerlink" title="1.初始化和const"></a>1.初始化和const</h1></blockquote><hr><p><br><br><br>const类型的对象能完成非const类型所能完成的大部分操作，但是对于const类型对象的主要限制就是只能在const类型对的对象上执行不改变其内容的操作。</p><p>在不改变const对象的操作中还有一种是初始化，如果利用一个对象去初始化另外一个对象，则它们是不是const都无关紧要。  </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">12</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> ci = i;<span class="comment">//i的值拷贝给了ci</span></span><br><span class="line"><span class="keyword">int</span> j = ci;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"i="</span> &lt;&lt; i &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"ci="</span> &lt;&lt; ci &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"j="</span> &lt;&lt; j &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>输出结果如下：  ![](https://i.imgur.com/RpcPLLp.png)  <p><br><br></p><hr><blockquote><h1 id="2-const引用"><a href="#2-const引用" class="headerlink" title="2.const引用"></a>2.const引用</h1></blockquote><hr><br>可以把引用绑定到const对象上，就像绑定到其他对象上一样，我们称之为——常量引用。  <p>与普通引用不同的是，对常量的引用不能被用作修改它所绑定的对象。  </p><p>错误示范如下：<br><img src="https://i.imgur.com/ajppGmY.png" alt></p><hr><blockquote><h1 id="3-初始化和对const的引用"><a href="#3-初始化和对const的引用" class="headerlink" title="3.初始化和对const的引用"></a>3.初始化和对const的引用</h1></blockquote><hr><br>引用的类型必须与其所引用对象的类型一致，但是有两个情况例外。第一个例外情况就是在初始化常量引用时，允许用任意表达式作为初始值，只要该表达式的结果能转化成引用的类型即可。  <p>允许一个常量引用绑定非常量的对象、字面值、甚至是一般表达式。  </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">42</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;r1 = i;<span class="comment">//允许将const int &amp;绑定到一个普通int对象上</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;r2 = <span class="number">42</span>;<span class="comment">//r1是一个常量引用</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;r3 = r1 * <span class="number">2</span>;<span class="comment">//r3是一个常量引用</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"i="</span> &lt;&lt; i &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"r1="</span> &lt;&lt; r1 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"r2="</span> &lt;&lt; r2 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"r3="</span> &lt;&lt; r3 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果如下：<br><img src="https://i.imgur.com/MkT10uV.png" alt></p><p><br><br></p><hr><blockquote><h1 id="4-对cons的引用可能引用一个并非const的对象"><a href="#4-对cons的引用可能引用一个并非const的对象" class="headerlink" title="4.对cons的引用可能引用一个并非const的对象"></a>4.对cons的引用可能引用一个并非const的对象</h1></blockquote><hr><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">42</span>;</span><br><span class="line"><span class="keyword">int</span> &amp;r1 = i;<span class="comment">//引用r1绑定对象i</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;r2 = i;<span class="comment">//常量引用r2绑定i，但是r2不能修改i的值</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"i="</span> &lt;&lt; i &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"r1="</span> &lt;&lt; r1 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"r2="</span> &lt;&lt; r2 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">r1 = <span class="number">10</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"i="</span> &lt;&lt; i &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"r1="</span> &lt;&lt; r1 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"r2="</span> &lt;&lt; r2 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//r2 = 5;//此处报错，因为r2是一个常量引用</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果如下：<br><img src="https://i.imgur.com/96S3r6f.png" alt><br><br><br></p><p>对于常量引用来说，一般情况下是没有办法来对它进行修改的，但是可以使用下面的方法来尝试对常量引用进行修改。代码图如下：  </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;ref = <span class="number">10</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"ref="</span> &lt;&lt; ref &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">int</span> *p = (<span class="keyword">int</span> *)&amp;ref;</span><br><span class="line">*p = <span class="number">100</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"ref="</span> &lt;&lt; ref &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果如下：<br><img src="https://i.imgur.com/d4EB8c7.png" alt><br><br><br><br>这里我们使用了一个指针来对常量引用进行修改。首先，我们要知道的是，常量引用不是一个对象，编译器并没有给它分配内存空间。当我们使用指针指向常量引用时，编译器会给常量引用临时开辟一块内存空间。代码示意如下：  </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> tmp=ref;<span class="comment">//tmp有内存</span></span><br><span class="line"><span class="keyword">int</span> *p=(<span class="keyword">int</span> *)&amp;ref;<span class="comment">//*p指向的是那块临时空间，临时空间看不到</span></span><br></pre></td></tr></table></figure><p><br><br></p><hr><blockquote><h1 id="5-指针和const"><a href="#5-指针和const" class="headerlink" title="5.指针和const"></a>5.指针和const</h1></blockquote><hr><br>与引用一样，也可以令指针指向常量或非常量。类似于常量引用，指向常量的指针不能改变其所指对象的值。要想存放常量对象的地址，只能使用指向常量的指针。  实例代码如下：  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> i = <span class="number">10</span>;</span><br><span class="line"><span class="comment">//int *r1 = &amp;i;//报错，r1是一个普通指针，并不能指向一个常量</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> *r2 = &amp;i;<span class="comment">//常量指针指向常量</span></span><br><span class="line"><span class="comment">//常量指针可以指向常量，但是并不能修改常量的值</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"常量i的地址为："</span> &lt;&lt; &amp;i &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"r2指向的地址为："</span> &lt;&lt; r2 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"i="</span> &lt;&lt; i &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"r2="</span> &lt;&lt; *r2 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果如下：<br><img src="https://i.imgur.com/d24xVwj.png" alt><br><br><br></p><hr><blockquote><h1 id="6-const指针"><a href="#6-const指针" class="headerlink" title="6.const指针"></a>6.const指针</h1></blockquote><hr><br>指针是对象而引用不是，就像其他对象类型一样，允许把指针本身定义为常量。常量指针必须初始化，而且一旦初始化完成，则它的值（也就是存放在指针中的那个地址）就不能再修改。把*放在const关键字之前用以说明指针是一个常量。这样书写的意味着，不变的是指针本身的值，而不是指向的那个值。  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> *<span class="keyword">const</span> r1 = &amp;i;<span class="comment">//r1将一直指向i</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> i1 = <span class="number">11</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> *<span class="keyword">const</span> r2 = &amp;i1;<span class="comment">//r2是指向常量的常量指针</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"i=10时地址为："</span> &lt;&lt; &amp;i &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"常量指针r1指向的地址为："</span> &lt;&lt; r1 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">i = <span class="number">100</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"i=100时地址为："</span> &lt;&lt; &amp;i &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"常量指针r1指向的地址为："</span> &lt;&lt; r1 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果如下：<br><img src="https://i.imgur.com/SsAFLUA.png" alt></p><h2 id="-1"><a href="#-1" class="headerlink" title></a><br><br></h2><blockquote><h1 id="7-顶层const"><a href="#7-顶层const" class="headerlink" title="7.顶层const"></a>7.顶层const</h1></blockquote><hr><br>指针本身就是一个对象，它又可以指向1另外一个对象。因此指针本身是不是常量，以及指针指向的对象是不是一个常量是两个独立的问题。  <p>顶层const表示指针本身是一个常量。  </p><p>底层const表示指针所指的对象时一个常量。  </p><p>更一般地，顶层const可以表示任意的对象时常量，这一点对任何数据类型都适用，如算术类型、类、指针等。底层const则与指针和引用等符合类型的基本类型有关。比较特殊的是，指针类型既可以是顶层const，也可以是底层const。  </p><h2 id="-2"><a href="#-2" class="headerlink" title></a><br><br></h2><blockquote><h1 id="8-尽量使用const代替-define"><a href="#8-尽量使用const代替-define" class="headerlink" title="8.尽量使用const代替#define"></a>8.尽量使用const代替#define</h1></blockquote><hr><br>在旧版本的C中，如果想建立一个常量，必须使用预处理器。  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX 1024;</span></span><br></pre></td></tr></table></figure><p>这里我们定义的宏MAX从未被编译器看到过，因为在预处理阶段，所有的MAX已经全部被替换成了1024，于是MAX并没有将其加入符号表中。但是我们使用这个常量获得一个编译错误信息时，可能会带来一些困扰，因为这个信息可能会提到1024，但是并没有提到MAX。如果MAX被定义在一个不是我们自己写的头文件中，我们可能并不知道1024代表着什么，也许解决这个问题需要很长的时间。<br>解决这个问题的办法就是用一个常量来替换掉上面的宏：  </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX=<span class="number">1024</span>；</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> A <span class="comment">//卸载宏常量A</span></span></span><br></pre></td></tr></table></figure><p>###const和#define的区别  </p><ul><li>const有类型，可进行编译器类型安全检查，#define无类型，不可进行类型检查</li><li>const有作用域，而#define不重视作用域，默认定义处到文件末尾，如果定义在指定作用域下有效的常量，那么#define就不能用。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;h1 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h1&gt;&lt;/blockquote&gt;
&lt;hr&gt;
&lt;p&gt;有时候我们希望定义这样一种变量，它的值不能被改变。例如，用一
      
    
    </summary>
    
      <category term="C++" scheme="http://wanqbin.coding.me/Aoki/categories/C/"/>
    
    
      <category term="限定符" scheme="http://wanqbin.coding.me/Aoki/tags/%E9%99%90%E5%AE%9A%E7%AC%A6/"/>
    
  </entry>
  
  <entry>
    <title>C++复合类型</title>
    <link href="http://wanqbin.coding.me/Aoki/2019/03/09/C-%E5%A4%8D%E5%90%88%E7%B1%BB%E5%9E%8B/"/>
    <id>http://wanqbin.coding.me/Aoki/2019/03/09/C-复合类型/</id>
    <published>2019-03-09T00:26:00.000Z</published>
    <updated>2019-06-11T10:40:07.439Z</updated>
    
    <content type="html"><![CDATA[<p>复合类型是指基于其他类型定义的类型。C++有几种复合类型，下面主要是<code>引用</code>和<code>指针</code>。  定义复合类型的变量复杂很多，通用的描述为：一条声明语句由一个<code>基本数据类型</code>和紧随其后的一个<code>声明符</code>列表组成。每个声明符命名了一个变量并指定该变量为与基本数据类型有关的某种类型。  </p><hr><blockquote><h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1></blockquote><hr><p>C++11中新增加了一种引用，为<code>右值引用</code>，主要用于内置类。这里，我们使用<code>引用</code>时，指的是<code>左值引用</code>。  引用为对象起了另外一个名字，引用类型引用另外一种类型。通过将声明符写成<code>&amp;d</code>的形式来定义引用类型，其中d是声明的变量名。<br>引用即别名，并非对象，它只是为一个已经存在的对象所起的另外一个名字。<br>下面是引用的一个例子。  </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> vale = <span class="number">1024</span>;</span><br><span class="line"><span class="keyword">int</span> &amp;vale00 = vale; <span class="comment">//注意：引用必须进行初始化</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"vale的值为："</span> &lt;&lt; vale &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"vale00的值为："</span> &lt;&lt; vale00 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"vale00是vale的引用。"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://i.imgur.com/VPKK9Rk.png" alt><br><br><br>定义了一个引用之后，对其进行的所有操作都是在与之绑定的对象上进行的。<br>为引用赋值，实际上是把值赋给了与引用绑定的对象。获取引用的值，实际上是获取到了与之绑定的对象的值。同理，以引用作为初始值，实际上是以引用绑定的对象作为初始值。  </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">string</span> name = <span class="string">"青木"</span>;</span><br><span class="line"><span class="built_in">string</span> &amp;name_ = name;</span><br><span class="line"><span class="built_in">string</span> name0 = <span class="string">"Aoki"</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"大家好，我的名字是"</span> &lt;&lt; name_ &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"大家好，我是"</span> &lt;&lt; name0 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">name0 = name_;<span class="comment">//为引用赋值</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"大家好，我现在是"</span> &lt;&lt; name0 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果为：<br><img src="https://i.imgur.com/yxB0y8I.png" alt><br><br></p><hr><blockquote><h1 id="引用-1"><a href="#引用-1" class="headerlink" title="引用"></a>引用</h1></blockquote><hr><p><code>指针</code>是指向另外一种类型的复合类型。与引用类似，指针也实现了对其他对象的间接访问，但是指针与引用也有很多不同点，如下：  </p><ul><li>指针本身就是个对象，允许对指针赋值和拷贝，在指针的生命周期内，它可以先后指向几个不同的对象  </li><li>指针无须在定义时赋初值。和其他内置类型一样，在块作用域内定义的指针如果没有定义，也将拥有一个不确定的值。  <br>>## 获取对象的地址</li></ul><p>指针存放某个对象的地址，要向获取该地址，就要使用<code>取地址符</code>（&amp;）。<br>在声明语句中，指针的类型实际上被用于它所指向的对象的类型，所以二者必须匹配。如果指针指向了一个其他类型的对象，对该对象的操作将会发生错误。  </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">string</span> name = <span class="string">"青木"</span>;</span><br><span class="line"><span class="built_in">string</span>* name_=&amp;name;<span class="comment">//name_存放变量name的地址，或者说name_是指向变量name的指针</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"大家好，我的名字是"</span> &lt;&lt; name &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"name的地址为:"</span> &lt;&lt; name_ &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"大家好，我的名字是"</span> &lt;&lt; name_ &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果为：<br><img src="https://i.imgur.com/Rp1QNpE.png" alt><br><br><br><br></p><blockquote><h2 id="指针值"><a href="#指针值" class="headerlink" title="指针值"></a>指针值</h2></blockquote><p>指针的值（即地址）应属于下列4中状态之一：  </p><ol><li>指向一个对象 </li><li>指向紧邻对象所占空间的下一个位置</li><li>空指针，意味着指针没有指向任何值</li><li>无效指针，就是上述状态之外的其他值。</li></ol><p>对于无效指针，试图拷贝或以其他方式访问无效指针的值都将引发错误。  </p><br>>## 利用指针访问对象<p>如果一个指针指向了一个对象，则允许使用<code>解引用符</code>（*）来访问该对象。<br>对指针解引用会得到所指的对象，因此如果给解引用的结果赋值，实际上也就是给指针所指的内容赋值。  </p><blockquote><p>注意：解引用操作仅适用于那些确实指向了某个对象的有效指针。  </p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">string</span> name = <span class="string">"青木"</span>;</span><br><span class="line"><span class="built_in">string</span> name0 = <span class="string">"Aoki"</span>;</span><br><span class="line"><span class="built_in">string</span>* name_=&amp;name;<span class="comment">//name_存放变量name的地址，或者说name_是指向变量name的指针</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"大家好，我的名字是"</span> &lt;&lt; name &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"name的地址为:"</span> &lt;&lt; name_ &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"大家好，我的名字是"</span> &lt;&lt; *name_ &lt;&lt; <span class="built_in">endl</span>;<span class="comment">//指针解引用，获取对象的值</span></span><br><span class="line">*name_ = name0;<span class="comment">//经由指针为name赋值</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"大家好，我的名字是"</span> &lt;&lt; name &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"大家好，我的名字是"</span> &lt;&lt; *name_ &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>![](https://i.imgur.com/lno4Q9r.png)<br><blockquote><h2 id="空指针"><a href="#空指针" class="headerlink" title="空指针"></a>空指针</h2></blockquote><p>空指针不指向任何对象，在试图使用一个指针之前，代码可以首先检查它是否为空。<br>生成空指针的方法：  </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>* p1=<span class="literal">nullptr</span>;<span class="comment">//等价于int* ptr=0</span></span><br><span class="line"><span class="keyword">int</span>* p2=<span class="number">0</span>;<span class="comment">//直接将p2初始化为字面常量0</span></span><br></pre></td></tr></table></figure><p>得到空指针最直接的办法是使用字面值nullptr来初始化指针。nullptr是一种特殊的指针，它可以被转换成任意其他指针类型。<br><br><br><br></p><blockquote><h2 id="赋值和指针"><a href="#赋值和指针" class="headerlink" title="赋值和指针"></a>赋值和指针</h2></blockquote><p>指针额引用都能够提供对其他的对象的间接访问，但是在具体的实现细节上两者有很大不同，其中最主要的又掉了是引用本身并不是一个对象。<br>指针和它存放的地址之间没有这种限制。和其他任何变量一样，给指针赋值就是令它存放一个新地址，从而指向一个新对象。<br>对于指针的赋值，前文已经给出。  </p><blockquote><h2 id="其他指针操作"><a href="#其他指针操作" class="headerlink" title="其他指针操作"></a>其他指针操作</h2></blockquote><p>只要指针拥有一个合法值，就能将它用在条件表达式中。和采用算术值作为条件遵循的规则一样，如果指针的值是0，条件取false。<br>对于两个类型相同的合法指针，可以用相等操作符或不相等操作符来比较它们，比较的结果是布尔类型。<br>两个指针存放的地址值相同（两个指针相等），有三种可能：  </p><ul><li>它们都为空</li><li>都指向同一个对象</li><li>都指向同一个对象的下一个地址</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">string</span> name = <span class="string">"青木"</span>;</span><br><span class="line"><span class="built_in">string</span>* name_=&amp;name;<span class="comment">//name_存放变量name的地址，或者说name_是指向变量name的指针</span></span><br><span class="line"><span class="keyword">int</span>* a = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="keyword">if</span> (name_&amp;&amp;a) <span class="comment">//与运算，一真一假为假</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"大家好，我是指向"</span> &lt;&lt; name &lt;&lt; <span class="string">"的指针，我不为空"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"大家好，我是空指针a，我的地址是"</span> &lt;&lt; &amp;a &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果如下：<br><img src="https://i.imgur.com/VW47tJO.png" alt></p><p><br><br><br>最后是void*指针。</p><blockquote><h2 id="void-指针"><a href="#void-指针" class="headerlink" title="void* 指针"></a>void* 指针</h2></blockquote><p>void* 指针是一种特殊的指针类型，可用于存放任意对象的指针，一个void<em>指针存放着一个地址。<br>利用void</em>指针可以做的事有：  </p><ul><li>拿它和别的指针比较</li><li>作为函数的输入和输出</li><li>赋值给另外一个void*指针</li></ul><p>但是我们不能直接操作void* 指针，因为它的类型未知。以void*的视角来看内存空间也仅仅是内存空间，没办法访问内存空间中所存的对象。  </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span>  a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span>* name_=&amp;a;<span class="comment">//name_存放变量a的地址，或者说name_是指向变量a的指针</span></span><br><span class="line"><span class="keyword">void</span>* names;</span><br><span class="line">names = name_;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"name_指向的值为："</span> &lt;&lt; *name_ &lt;&lt;<span class="string">",地址为："</span>&lt;&lt;name_&lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"names地址为："</span> &lt;&lt; names &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：<br><img src="https://i.imgur.com/UaoQ4BV.png" alt></p><br><br><br><br>对于void* 指针，我还有许多不解的地方，在网上搜索之后发现了一个比较详细解释void* 指针的博文——[void及void指针含义的深刻解析](https://blog.csdn.net/geekcome/article/details/6249151?reload)<br><br><br><br><br>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;复合类型是指基于其他类型定义的类型。C++有几种复合类型，下面主要是&lt;code&gt;引用&lt;/code&gt;和&lt;code&gt;指针&lt;/code&gt;。  
定义复合类型的变量复杂很多，通用的描述为：一条声明语句由一个&lt;code&gt;基本数据类型&lt;/code&gt;和紧随其后的一个&lt;code&gt;声明符&lt;/
      
    
    </summary>
    
      <category term="C++" scheme="http://wanqbin.coding.me/Aoki/categories/C/"/>
    
    
      <category term="引用" scheme="http://wanqbin.coding.me/Aoki/tags/%E5%BC%95%E7%94%A8/"/>
    
      <category term="指针" scheme="http://wanqbin.coding.me/Aoki/tags/%E6%8C%87%E9%92%88/"/>
    
      <category term="复合类型" scheme="http://wanqbin.coding.me/Aoki/tags/%E5%A4%8D%E5%90%88%E7%B1%BB%E5%9E%8B/"/>
    
  </entry>
  
</feed>

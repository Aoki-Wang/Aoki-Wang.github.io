<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Aoki&#39;s Blog</title>
  
  <subtitle>“吾生也有涯，而知无涯”</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://wanqbin.xyz/"/>
  <updated>2019-08-09T14:28:33.018Z</updated>
  <id>http://wanqbin.xyz/</id>
  
  <author>
    <name>Aoki</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Linux内核同步机制分析——原子操作</title>
    <link href="http://wanqbin.xyz/2019/08/09/inux%E5%86%85%E6%A0%B8%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6%E5%88%86%E6%9E%90%E2%80%94%E2%80%94%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C/"/>
    <id>http://wanqbin.xyz/2019/08/09/inux内核同步机制分析——原子操作/</id>
    <published>2019-08-09T14:27:00.000Z</published>
    <updated>2019-08-09T14:28:33.018Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;原子操作是Linux中提供的一种实现同步的方法。所谓原子操作就是指某一操作在执行过程中是不可以被打断的，它要么全部执行完毕，要么就一点也不执行。原子原本指的是不可分割的微粒，所以原子操作也就是不可分割的指令。也就是说原子操作是绝对不会出现该操作执行了一半，内核又去执行其他操作了的情况。</p><p>&emsp;&emsp;内核提供了两组原子操作接口：一组是针对整数的原子操作，另一组是针对单独的位进行操作。在Linux支持的所有体系结构上都实现了两组原子接口。而且大多数体系结构要么原本就支持简单的原子操作，要么就为单步执行提供了锁内存总线的指令（这就确保其他操作不能同时发生）。而有些体系结构本身就不太支持原子操作，比如<code>SPARC</code>，我们则可以通过加锁的方式来实现。</p><h2 id="一、原子整数操作"><a href="#一、原子整数操作" class="headerlink" title="一、原子整数操作"></a>一、原子整数操作</h2><p>&emsp;&emsp;原子整数操作需要硬件的支持，因此它是与体系结构有关的，x86提供给用户的接口和原子类型都定义在<code>include/asm-x86/atomic.h</code>文件中，使用宏来实现。</p><p>&emsp;&emsp;原子整数操作主要用于实现资源计数，很多引用计数都是通过原子操作实现的。原子结构类型定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span><span class="keyword">int</span> counter;&#125; <span class="keyword">atomic_t</span>;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;原子整数操作，顾名思义，这是一组针对整数进行的操作，但是，该操作有几点需要特别注意的地方</p><ul><li>在Linux中的原子整数操作只能对<code>atomic_t</code>类型的数据进行操作，而不能对在C语言中用到的整数类型<code>int</code>进行操作</li><li>使用<code>atomic_t</code>的代码只能将该数据当做24位来使用。</li></ul><p>&emsp;&emsp;现在来看一下产生这两个特别的地方的原因。</p><p>&emsp;&emsp;首先是第一个，为什么Linux中给该操作定义了一个特殊的数据类型，这主要可以有如下几种原因:<br>（1）可以确保原子操作只与这种规定的特殊类型的数据一起使用，这也就保证了该类型的数据不会被传递到其他非原子操作的函数中，</p><p>（2）使用<code>atomic_t</code>类型确保了编译器不会对定义的该类型的数据进行访问，这也就是保证了原子操作最终接收到一个正确的内存地址而不是一个别名，该别名也保存了相同的值。</p><p>（3）重新定义了一个数据类型<code>atomic_t</code>，可以屏蔽到在不同体系结构上实现原子操作的差异。</p><p>&emsp;&emsp;其次，是第二个特别的地方的原因，主要是在<code>SPARC</code>体系结构上，原子操作的实现不同于其他体系结构，该体系结构上32位<code>int</code>型的低8位中设置了一个锁，这主要是由于<code>SPARC</code>体系结构对原子操作缺乏指令级的支持，所以只能利用锁来避免对原子类型数据的并发访问。</p><table><thead><tr><th>函数原型</th><th>描述</th></tr></thead><tbody><tr><td>ATOMIC_INIT(i)</td><td>用于初始化一个原子变量的值为i，并1返回这个atomic_t结构</td></tr><tr><td>atomic_read(v)</td><td>返回原子变量v的当前值</td></tr><tr><td>atomic_set(&amp;v,1)</td><td>设置原子变量v的值为i</td></tr><tr><td>atomic_add(int i,atomic_t *v)</td><td>将原子变量v的值加i</td></tr><tr><td>atomic_sub(int i,atomic_t*v)</td><td>将原子变量v的值减i</td></tr><tr><td>atomic_sub_and_test(int i.atomic_t *v)</td><td>将原子变量v的值减i，并将原子变量运算后结果为0的情况下，返回1，否则返回0</td></tr><tr><td>atomic_inc(atomic_t *v)</td><td>将原子变量v的值加1</td></tr><tr><td>atomic_dec(atomic_t *v)</td><td>将原子变量v的值减1</td></tr><tr><td>atomic_dec_and_test(atomic_t *v)</td><td>将原子变量v的值减1，并将原子运算后结果为0的情况下，返回1，否则返回0</td></tr><tr><td>atomic_inc_and_test(atomic_t *v)</td><td>将原子变量v的值加1，并将原子变量运算后结果为0的情况下返回1，否则返回0</td></tr><tr><td>atomic_add_negative(int i,atomic_t *v)</td><td>将原子变量v的值加i，并在原子变量运算结果后结果为负值的情况下返回1，否则返回0</td></tr><tr><td>atomic_add_return(int i,atomic_t *v)</td><td>将原子变量v的值加i，并返回运算后原子变量的值</td></tr><tr><td>atomic_sub_return(int i,atomic_t *v</td><td>将原子变量v的值减i，并返回运算后原子变量的值</td></tr></tbody></table><h2 id="二、原子位操作"><a href="#二、原子位操作" class="headerlink" title="二、原子位操作"></a>二、原子位操作</h2><p>&emsp;&emsp;原子位操作，就是针对数据的每一位进行操作，当然它的实现也是与体系结构相关的。其定义在<code>include/x86/bitops_32.h</code>中。</p><p>&emsp;&emsp;在这里需要注意的是原子位操作与原子整数操作不同，它不需要定义一个与该操作相对应的数据结构，因为原值位操作只是针对普通的指针进行操作的，我们可以对任何指针指向的数据进行原子位操作。Linux内核1提供了一系列原值位操作的函数。</p><table><thead><tr><th>函数原型</th><th>描述</th></tr></thead><tbody><tr><td>set_bit(int nr,volatile unsigned long *addr)</td><td>原子地设置add所指对象的第nr位</td></tr><tr><td>clear_bit(int nr,volatile unsigned long *addr)</td><td>原子地清空add所指对象的第nr位</td></tr><tr><td>change_bit(int nr,volatile unsigned long *addr)</td><td>原子地翻转add所指对象的第nr位</td></tr><tr><td>test_and_set_bit(int nr ,volatile unsigned long *addr)</td><td>原子地设置addr所指对象的第nr位，并返回原来的值</td></tr><tr><td>test_and _clear_bit(int nr ,volatile unsigned long * addr)</td><td>原子地清空addr所指对象的第nr位，并返回原来的值</td></tr><tr><td>test_and _change_bit(int nr ,volatile unsigned long * addr)</td><td>原子地翻转addr所指对象的第nr位，并返回原来的值</td></tr><tr><td>test_bit(nr,addr)</td><td>原子地返回addr所指对象的第nr位</td></tr></tbody></table><p>&emsp;&emsp;下面通过说明一个典型的操作函数<code>set_bit(int nr,volatile unsigned long *addr)</code>来分析原子位操作的具体处理过程。该函数以原子方式设置在addr所指对应的第nr位，即保证操作过程不会被打断。代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">set_bit</span><span class="params">(<span class="keyword">int</span> nr,<span class="keyword">volatile</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> *addr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    _asm__volatile_(LOCK_PREFIX</span><br><span class="line">                       <span class="string">"btsl%1,%0</span></span><br><span class="line"><span class="string">                        :"</span>+m<span class="string">"(ADDR)</span></span><br><span class="line"><span class="string">                        :"</span>Ir(nr));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第4行声明了内嵌汇编所使用的汇编指令<code>btsl</code>，用于设置占位符1%对应操作数的第%1位，然后将结果保存到占位符%0对应的变量；这里的占位符%0、%1分别对应变量<code>addr</code>和<code>nr</code>。</p><p>第5行代码声明了内嵌汇编所使用的输出变量列表。这里声明的输出变量为内存地址指针<code>addr</code>，其限定符<code>+m</code>说明该变量是一个读写类型的内存变量，即该变量既是输入变量，也是输出变量。</p><p>第6行代码声明了内嵌汇编所使用的输入变量列表。这里声明的输入变量是：代表位移的参数<code>nr</code>，其限定符<code>Ir</code>表示该变量是一个0~31的立即数，且要求编译器将该变量与处理器的某个寄存器相关联。</p><p>&emsp;&emsp;在Linux中还定义了一组与这些原子位操作相对应的非原子位操作，这些函数与原子位操作的函数所完成的功能是相同的，只是这些非原子位操作不能保证操作的原子性，其命名就是在原子位操作的函数的前面加上两个喜爱划线，如与<code>set_bit()</code>函数相对应的非原值为操作就是<code>_set_bit()</code>，其余的函数的命名方式与它完成相同。非原子位操作要比原子位操作执行速度快一些，若代码已经避免了竞争条件，那么就可以在代码中使用这些非原子位操作以提高程序的执行速度。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&amp;emsp;&amp;emsp;原子操作是Linux中提供的一种实现同步的方法。所谓原子操作就是指某一操作在执行过程中是不可以被打断的，它要么全部执行完毕，要么就一点也不执行。原子原本指的是不可分割的微粒，所以原子操作也就是不可分割的指令。也就是说原子操作是绝对不会出现该操作执行了
      
    
    </summary>
    
      <category term="Linux内核" scheme="http://wanqbin.xyz/categories/Linux%E5%86%85%E6%A0%B8/"/>
    
    
      <category term="Linux内核" scheme="http://wanqbin.xyz/tags/Linux%E5%86%85%E6%A0%B8/"/>
    
      <category term="操作系统" scheme="http://wanqbin.xyz/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="原子操作" scheme="http://wanqbin.xyz/tags/%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C/"/>
    
      <category term="原子整数操作" scheme="http://wanqbin.xyz/tags/%E5%8E%9F%E5%AD%90%E6%95%B4%E6%95%B0%E6%93%8D%E4%BD%9C/"/>
    
      <category term="原子位操作" scheme="http://wanqbin.xyz/tags/%E5%8E%9F%E5%AD%90%E4%BD%8D%E6%93%8D%E4%BD%9C/"/>
    
  </entry>
  
  <entry>
    <title>Linux内核同步机制分析——临界区与竞争条件</title>
    <link href="http://wanqbin.xyz/2019/08/09/nux%E5%86%85%E6%A0%B8%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6%E5%88%86%E6%9E%90%E2%80%94%E2%80%94%E4%B8%B4%E7%95%8C%E5%8C%BA%E4%B8%8E%E7%AB%9E%E4%BA%89%E6%9D%A1%E4%BB%B6/"/>
    <id>http://wanqbin.xyz/2019/08/09/nux内核同步机制分析——临界区与竞争条件/</id>
    <published>2019-08-09T14:26:00.000Z</published>
    <updated>2019-08-09T14:27:32.186Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;所谓临界区就是访问和操作共享数据的代码段。多个内核任务并发访问同一个资源通常是不安全的。为了避免对临界区进行并发访问，编程者必须保证临界区代码段被原子地执行，也就是说，代码段在执行期间不可被打断，就如同整个临界区是一个不可分割的指令一样。如果两个内核任务可能处于同一临界区，这可能会导致临界资源出现不一致的状态。如果确实发生了这种情况，就称它为竞争状态。</p><h2 id="一、临界区举例"><a href="#一、临界区举例" class="headerlink" title="一、临界区举例"></a>一、临界区举例</h2><p>&emsp;&emsp;为了进一步了解竞争状态，首先要明白临界区无处不在。考虑一个非常简单的、共享资源的例子：一个全局整型变量和一个简单的临界区，其中的操作仅仅是将整型变量的值增加1，即<code>i++</code>，该操作可以转化成下卖弄的机器指令序列。</p><p>（1）得到当前变量i的值并将它复制到一个寄存器中</p><p>（2）将寄存器中的值加1</p><p>（3）把i的新值写回到内存中</p><p>这三条指令形成一个临界区。现在假定有两个执行线程同时进入这个临界区，如果i的初始值是1，那么期望的结果应该如下所示：</p><table><thead><tr><th>线程1</th><th>线程2</th></tr></thead><tbody><tr><td>获得i（1）</td><td>—</td></tr><tr><td>增加i（1-&gt;2)</td><td>—</td></tr><tr><td>写回i(2)</td><td>—</td></tr><tr><td></td><td>获得i(2)</td></tr><tr><td></td><td>增加i(2-&gt;3)</td></tr><tr><td></td><td>写回i(3)</td></tr></tbody></table><p>正如期望的那样，i被两个线程分别加1变成3。但是实际的执行序列却可能如下所示：</p><table><thead><tr><th>线程1</th><th>线程2</th></tr></thead><tbody><tr><td>获得i（1）</td><td>—</td></tr><tr><td>—</td><td>获得i（1）</td></tr><tr><td>增加i(1-&gt;2)</td><td>—</td></tr><tr><td>—</td><td>增加i(1-&gt;2)</td></tr><tr><td>写回i(2)</td><td>—</td></tr><tr><td>_</td><td>写回i（2）</td></tr></tbody></table><p>&emsp;&emsp;如果两个执行线程都在变量i值增加前读取它的初值，进而又分别增加变量i的值，最后再保存该值，那么变量i的值就变成了2，而变量i的值本该是3的。这是最简单的临界区例子，幸好对这种简单竞争条件的解决办法也同样简单——我们仅仅需要将这些指令作为一个不可分割的整个来执行就可以了。多数处理器都提供了指令来原子地读变量、增加变量然后再写回变量，使用这样的指令就能解决问题。Linux内核也提供了一组实现这些原子操作的接口。</p><h2 id="二、共享队列和加锁"><a href="#二、共享队列和加锁" class="headerlink" title="二、共享队列和加锁"></a>二、共享队列和加锁</h2><p>&emsp;&emsp;下面讨论一个更为复杂的竞争状态。假定有一个需要处理的请求队列，这里假定该队列是一个链表，链表中的每个节点逻辑上代表一个“请求”。有两个函数可以用来操作此队列，一个函数将新请求添加到队列尾部，另一个函数从队列中删除请求，然后进行处理。内核各部分都会调用这两个函数，所以内核会频繁地在队列中加入请求、从队列中删除请求并对其进行处理。对请求队列的操作无疑要用到多条指令。如果一个线程试图读取队列，而这时另一个线程正在处理该队列，那么读取线程就会发现队列此刻正处于不一致状态。很明显，如果允许并发访问队列，聚会产生意想不到的错误。当共享资源是一个复杂的数据结构时，竞争状态往往会使该结构遭到破坏。</p><p>&emsp;&emsp;对于这种情况，锁机制可以避免竞争状态。这种锁就如同一把门锁，门内的房间可想象成一个临界区。在一个指定时刻，房间里只能有一个内核线程存在，当一个内核线程进入房间后，它就会锁住身后的房间；当它结束对共享数据的操作后，就会打开门锁，走出房间。如果另一个线程在房门上锁时到达，那么它必须等待房间内的线程打开门锁出来后，才能进入房间。</p><p>&emsp;&emsp;对于前面提到的请求队列，可以使用一个单独的锁进行保护。每当有一个新请求要加入队列，线程会首先占住锁，然后就可以安全地将请求加入到队列中，结束操作后再释放该锁；同样，当一个线程想从请求队列中删除一个请求时，也需要占住锁，然后才能从队列中读取和删除请求，而且在完成操作后必须释放锁。任何要访问队列的其他线程也类似，必须占住锁之后才能进行操作。因为在一个时刻只能有一个线程持有锁，所以在任何一个时刻只有一个线程可以操作队列。由此可见，锁机制可以防止并发执行，并且保护队列不受竞争状态影响。</p><p>&emsp;&emsp;任何要访问队列的代码都需要首先占住相应的锁，这样该锁就能阻止来自其他内核线程的并发访问，形式如下所示：</p><table><thead><tr><th>线程1</th><th>线程2</th></tr></thead><tbody><tr><td>试图锁定队列</td><td>试图锁定队列</td></tr><tr><td>成功，获得锁</td><td>失败：等待……</td></tr><tr><td>访问队列……</td><td>等待……</td></tr><tr><td>为队列解除锁</td><td>等待……</td></tr><tr><td>……</td><td>成功:获得锁</td></tr><tr><td>……</td><td>访问队列……</td></tr><tr><td>……</td><td>为队列解除锁</td></tr></tbody></table><p>&emsp;&emsp;注意锁的使用是自愿的、非强制性的，它完全属于一种编程者自选的编程手段。没有什么1可以强制编程者在操作虚拟队列时必须使用锁。当然，如果不这么做，无疑会造成竞争状态而破坏队列。</p><p>&emsp;&emsp;锁有多种形式，而且加锁的粒度范围也各不相同，Linux自身实现了几种不同的锁机制。各种锁机制直接的区别主要在于当锁被持有时的行为表现，一些锁持有时会不断进行循环，等待锁重新可用，而有些锁会使当前任务睡眠，直到锁可用为止。</p><h2 id="三、确定保护对象"><a href="#三、确定保护对象" class="headerlink" title="三、确定保护对象"></a>三、确定保护对象</h2><p>&emsp;&emsp;找出哪些数据需要保护是内核同步实现的关键所在。由于任何可能被并发访问的代码都需要保护，所以寻找哪些代码不需要保护反而更容易些。内核任务的局部数据仅仅被自身访问，显然不需要保护，比如，局部自动变量不需要任何形式的锁，因为它们独立存在于内核线程的栈中。类似，如果数据只会被特定的进程访问，那么也不需要加锁。</p><p>&emsp;&emsp;到底什么数据需要加锁呢？答案是大多数内核数据结构都需要加锁。有一条很好的经验可以帮助人们进行判断：如果有其他内核线程可以访问这些数据，那么就给这些数据局加上某种形式的锁；如果有任何其他东西能看到它，那么就要锁定它。</p><h2 id="四、并发执行的原因"><a href="#四、并发执行的原因" class="headerlink" title="四、并发执行的原因"></a>四、并发执行的原因</h2><p>&emsp;&emsp;内核空间之所以需要同步，是因为内核程序会被抢占和重新调度。由于处于内核态的进程可能会在任何时刻被抢占，从而使调度程序完全可能会选择另一个高优先级的进程到处理器执行，所以就有可能在一个进程进入临界区时就被非自愿地抢占了，如果新被调度的进程随后也进入同一个临界区，前后两个进程之间就会产生竞争。这种类型的并发操作并不是同时发生，它们只是相互交叉进行，所以也称为伪并发。</p><p>&emsp;&emsp;如果在对称多处理器的机器上，那么两个进程就可以真正地在临界区中同时执行。这种类型被称为真并发。虽然真并发和伪并发的原因和含义不同，但它们都同样会造成竞争状态，而且同样也需要保护。</p><p>&emsp;&emsp;那么，内核中造成并发执行的原因有哪些？简单来说有以下几种。</p><p>（1）中断：中断几乎可以在任何时刻异步发生，即可能随时打断当前正在执行的代码。</p><p>（2）内核抢占：如果内核具有抢占性，那么内核中的任务可能会被另一个任务抢占。</p><p>（3）软中断和<code>tasklet</code>：内核能在任何时刻唤醒或调度软中断和<code>tasklet</code>，打断当前正在执行的代码。</p><p>（4）睡眠：在内核执行的进程可能会睡眠，这就会唤醒调度程序，从而导致调度一个新的进程执行。</p><p>（5）对称多处理器：两个或多个处理器可以同时执行代码。</p><p>&emsp;&emsp;对于内核开发者来说，必须理解上述并发执行的原因1，并且事先为它们做好准备工作。如果在一段内核代码访问某资源的时候系统产生了一个中断，而该中断的处理程序居然还要访问这一资源，这就是一个bug；类似地，如果一段代码在访问一个共享资源期间被抢占，这也是一个bug；还有，如果内核代码在临界区里睡眠，那就是毫无原则地等待竞争状态的到来。最后还要注意，两个处理器绝对不能访问同一个共享资源。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&amp;emsp;&amp;emsp;所谓临界区就是访问和操作共享数据的代码段。多个内核任务并发访问同一个资源通常是不安全的。为了避免对临界区进行并发访问，编程者必须保证临界区代码段被原子地执行，也就是说，代码段在执行期间不可被打断，就如同整个临界区是一个不可分割的指令一样。如果两个内核
      
    
    </summary>
    
      <category term="Linux内核" scheme="http://wanqbin.xyz/categories/Linux%E5%86%85%E6%A0%B8/"/>
    
    
      <category term="Linux内核同步" scheme="http://wanqbin.xyz/tags/Linux%E5%86%85%E6%A0%B8%E5%90%8C%E6%AD%A5/"/>
    
      <category term="临界区" scheme="http://wanqbin.xyz/tags/%E4%B8%B4%E7%95%8C%E5%8C%BA/"/>
    
      <category term="竞争条件" scheme="http://wanqbin.xyz/tags/%E7%AB%9E%E4%BA%89%E6%9D%A1%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>92.反转链表II</title>
    <link href="http://wanqbin.xyz/2019/08/09/92-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8II/"/>
    <id>http://wanqbin.xyz/2019/08/09/92-反转链表II/</id>
    <published>2019-08-09T04:35:00.000Z</published>
    <updated>2019-08-09T06:29:38.978Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h2><p>反转从位置 m 到 n 的链表。请使用一趟扫描完成反转。</p><p>说明:<br>1 ≤ m ≤ n ≤ 链表长度。</p><p>示例:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL, m = 2, n = 4</span><br><span class="line">输出: 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;NULL</span><br></pre></td></tr></table></figure><h2 id="二、分析"><a href="#二、分析" class="headerlink" title="二、分析"></a>二、分析</h2><p>对于题目要求，画图如下：</p><p><img src="/2019/08/09/92-反转链表II/1.PNG" alt="题目要求"></p><p>在该题中需要实现对指定范围内的链表的反转。<code>m</code>和<code>n</code>代表范围区间。我们可以知道，<code>n-m+1</code>即为需要反转的链表的长度。在一开始，我们需要知道该从什么地方开始反转，<code>m</code>代表链表中的第<code>m</code>个结点。即从第<code>m</code>个结点开始对<code>n-m+1</code>长度的链表进行反转。</p><p><img src="/2019/08/09/92-反转链表II/2.PNG" alt="思路分析"></p><p>对反转步骤分析如下：</p><p>步骤一：找到开始逆置的结点，记录该结点以及该结点的前驱。</p><p><img src="/2019/08/09/92-反转链表II/3.PNG" alt="步骤一"></p><p>步骤二：从<code>head</code>开始，逆置<code>change_len=n-m+1</code>个结点</p><p><img src="/2019/08/09/92-反转链表II/4.PNG" alt="步骤二"></p><p>步骤三：将<code>pre_head</code>与<code>new_head</code>连接，<code>modify_list_tail</code>与<code>head</code>连接。</p><p><img src="/2019/08/09/92-反转链表II/5.PNG" alt="步骤三"></p><h2 id="三、实现"><a href="#三、实现" class="headerlink" title="三、实现"></a>三、实现</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> val;</span><br><span class="line">ListNode* next;</span><br><span class="line">ListNode(<span class="keyword">int</span> x) : val(x), next(<span class="literal">NULL</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function">ListNode* <span class="title">reverseBetween</span><span class="params">(ListNode* head, <span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> change_len = n - m + <span class="number">1</span>;<span class="comment">//需逆序的节点个数</span></span><br><span class="line">ListNode* pre_head = <span class="literal">NULL</span>;<span class="comment">//头节点的前一个节点</span></span><br><span class="line">ListNode* result = head;<span class="comment">//返回结果</span></span><br><span class="line"><span class="keyword">while</span> (head &amp;&amp; --m)</span><br><span class="line">&#123;</span><br><span class="line">pre_head = head;</span><br><span class="line">head = head-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">ListNode* modify_list_tail = head;</span><br><span class="line">ListNode* newHead = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">while</span> (head &amp;&amp; change_len)</span><br><span class="line">&#123;</span><br><span class="line">ListNode* next = head-&gt;next;</span><br><span class="line">head-&gt;next = newHead;</span><br><span class="line">newHead = head;</span><br><span class="line">head = next;</span><br><span class="line">change_len--;</span><br><span class="line">&#125;</span><br><span class="line">modify_list_tail-&gt;next = head;<span class="comment">//链接逆置的链表尾与逆置段的后一个节点</span></span><br><span class="line"><span class="keyword">if</span> (pre_head)<span class="comment">//pre_head不为空，说明不是从第一个节点开始逆置的</span></span><br><span class="line">&#123;</span><br><span class="line">pre_head-&gt;next = newHead;<span class="comment">//将逆置链表开始的前趋与逆置后的头结点链接</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">result = newHead;<span class="comment">//说明从第一个节点开始逆置，结果即为逆置后的头结点</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="测试函数："><a href="#测试函数：" class="headerlink" title="测试函数："></a>测试函数：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">ListNode <span class="title">a</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line"><span class="function">ListNode <span class="title">b</span><span class="params">(<span class="number">2</span>)</span></span>;</span><br><span class="line"><span class="function">ListNode <span class="title">c</span><span class="params">(<span class="number">3</span>)</span></span>;</span><br><span class="line"><span class="function">ListNode <span class="title">d</span><span class="params">(<span class="number">4</span>)</span></span>;</span><br><span class="line"><span class="function">ListNode <span class="title">e</span><span class="params">(<span class="number">5</span>)</span></span>;</span><br><span class="line"><span class="function">ListNode <span class="title">f</span><span class="params">(<span class="number">15</span>)</span></span>;</span><br><span class="line">a.next = &amp;b;</span><br><span class="line">b.next = &amp;c;</span><br><span class="line">c.next = &amp;d;</span><br><span class="line">d.next = &amp;e;</span><br><span class="line">e.next = &amp;f;</span><br><span class="line">Solution sol;</span><br><span class="line">ListNode* newhead = sol.reverseBetween(&amp;a, <span class="number">2</span>, <span class="number">5</span>);</span><br><span class="line"><span class="keyword">while</span> (newhead)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; newhead-&gt;val &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">newhead = newhead-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="执行结果："><a href="#执行结果：" class="headerlink" title="执行结果："></a>执行结果：</h3><p><img src="/2019/08/09/92-反转链表II/%E6%89%A7%E8%A1%8C%E7%BB%93%E6%9E%9C.PNG" alt="执行结果"></p><h2 id="三、源码地址"><a href="#三、源码地址" class="headerlink" title="三、源码地址"></a>三、源码地址</h2><p>​        <a href="https://github.com/Aoki-Wang/CheckStation/tree/master/LeetCode/92.ReverseList2" target="_blank" rel="noopener">反转链表的实现</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、题目描述&quot;&gt;&lt;a href=&quot;#一、题目描述&quot; class=&quot;headerlink&quot; title=&quot;一、题目描述&quot;&gt;&lt;/a&gt;一、题目描述&lt;/h2&gt;&lt;p&gt;反转从位置 m 到 n 的链表。请使用一趟扫描完成反转。&lt;/p&gt;
&lt;p&gt;说明:&lt;br&gt;1 ≤ m ≤ n ≤
      
    
    </summary>
    
      <category term="LeetCode" scheme="http://wanqbin.xyz/categories/LeetCode/"/>
    
      <category term="算法" scheme="http://wanqbin.xyz/categories/LeetCode/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="LeetCode" scheme="http://wanqbin.xyz/tags/LeetCode/"/>
    
      <category term="反转链表" scheme="http://wanqbin.xyz/tags/%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/"/>
    
      <category term="算法" scheme="http://wanqbin.xyz/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>206.反转链表</title>
    <link href="http://wanqbin.xyz/2019/08/09/206-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/"/>
    <id>http://wanqbin.xyz/2019/08/09/206-反转链表/</id>
    <published>2019-08-09T04:32:00.000Z</published>
    <updated>2019-08-09T06:36:42.194Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h2><p>反转一个单链表。</p><p><strong>示例:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL</span><br><span class="line">输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL</span><br></pre></td></tr></table></figure><h2 id="二、分析"><a href="#二、分析" class="headerlink" title="二、分析"></a>二、分析</h2><p>整个链表的反转比较简单，大致的实现思路是依次遍历链表节点，每遍历一个节点便逆置一个节点。</p><p><img src="/2019/08/09/206-反转链表/1.PNG" alt="思路分析"></p><h2 id="三、实现"><a href="#三、实现" class="headerlink" title="三、实现"></a>三、实现</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> val;</span><br><span class="line">ListNode* next;</span><br><span class="line">ListNode(<span class="keyword">int</span> x) : val(x), next(<span class="literal">NULL</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">ListNode* currHead = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">while</span> (head != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">ListNode* next = head-&gt;next;</span><br><span class="line">head-&gt;next = currHead;</span><br><span class="line">currHead = head;</span><br><span class="line">head = next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> currHead;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="测试函数："><a href="#测试函数：" class="headerlink" title="测试函数："></a>测试函数：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">ListNode <span class="title">a</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line"><span class="function">ListNode <span class="title">b</span><span class="params">(<span class="number">2</span>)</span></span>;</span><br><span class="line"><span class="function">ListNode <span class="title">c</span><span class="params">(<span class="number">3</span>)</span></span>;</span><br><span class="line"><span class="function">ListNode <span class="title">d</span><span class="params">(<span class="number">4</span>)</span></span>;</span><br><span class="line"><span class="function">ListNode <span class="title">e</span><span class="params">(<span class="number">5</span>)</span></span>;</span><br><span class="line">a.next = &amp;b;</span><br><span class="line">b.next = &amp;c;</span><br><span class="line">c.next = &amp;d;</span><br><span class="line">d.next = &amp;e;</span><br><span class="line">Solution solu;</span><br><span class="line">ListNode* newHead = solu.reverseList(&amp;a);</span><br><span class="line"><span class="keyword">while</span> (newHead != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; newHead-&gt;val &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">newHead = newHead-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="执行结果："><a href="#执行结果：" class="headerlink" title="执行结果："></a>执行结果：</h3><p><img src="/2019/08/09/206-反转链表/%E6%89%A7%E8%A1%8C%E7%BB%93%E6%9E%9C.PNG" alt="执行结果"></p><h2 id="四、源码地址"><a href="#四、源码地址" class="headerlink" title="四、源码地址"></a>四、源码地址</h2><p>​        <a href="https://github.com/Aoki-Wang/CheckStation/tree/master/LeetCode/206.ReverseList" target="_blank" rel="noopener">反转链表的实现</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、题目描述&quot;&gt;&lt;a href=&quot;#一、题目描述&quot; class=&quot;headerlink&quot; title=&quot;一、题目描述&quot;&gt;&lt;/a&gt;一、题目描述&lt;/h2&gt;&lt;p&gt;反转一个单链表。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例:&lt;/strong&gt;&lt;/p&gt;
&lt;figure class
      
    
    </summary>
    
      <category term="LeetCode" scheme="http://wanqbin.xyz/categories/LeetCode/"/>
    
      <category term="算法" scheme="http://wanqbin.xyz/categories/LeetCode/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="LeetCode" scheme="http://wanqbin.xyz/tags/LeetCode/"/>
    
      <category term="反转链表" scheme="http://wanqbin.xyz/tags/%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>203.移出链表元素</title>
    <link href="http://wanqbin.xyz/2019/08/09/203-%E7%A7%BB%E5%87%BA%E9%93%BE%E8%A1%A8%E5%85%83%E7%B4%A0/"/>
    <id>http://wanqbin.xyz/2019/08/09/203-移出链表元素/</id>
    <published>2019-08-09T04:28:00.000Z</published>
    <updated>2019-08-09T06:43:44.191Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h2><p>删除链表中等于给定值 <strong>val</strong> 的所有节点。</p><p><strong>示例:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: 1-&gt;2-&gt;6-&gt;3-&gt;4-&gt;5-&gt;6, val = 6</span><br><span class="line">输出: 1-&gt;2-&gt;3-&gt;4-&gt;5</span><br></pre></td></tr></table></figure><h2 id="二、分析"><a href="#二、分析" class="headerlink" title="二、分析"></a>二、分析</h2><p>在本题中，需要从链表中将某个指定的元素删除。需要实现的操作也比较简单，只是将某个匹配的结点删除。而在本题中，需要注意的是将删除结点的操作分为三类：一是删除头结点，二是删除中间的任意一个结点，三是删除尾结点。这三类删除操作的实现方法不同。</p><ul><li>对于删除头结点的操作来说，只需要将头结点指向头结点的下一个结点即可；</li><li>对于删除中间结点的操作来说，与普通的删除操作没有什么差别；</li><li>对于删除尾结点的操作来说，我们需要找到尾结点的前一个结点，此时尾节点的前一个结点的下一个结点是尾节点，我们需要做的是让尾节点的前一个结点不再指向尾节点，而是指向<code>NULL</code>；</li></ul><h2 id="三、实现"><a href="#三、实现" class="headerlink" title="三、实现"></a>三、实现</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> val;</span><br><span class="line">ListNode* next;</span><br><span class="line">ListNode(<span class="keyword">int</span> x) : val(x), next(<span class="literal">NULL</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function">ListNode* <span class="title">removeElements</span><span class="params">(ListNode* head, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">ListNode* p = head;</span><br><span class="line">ListNode* pre_p = head;</span><br><span class="line"><span class="keyword">while</span>(p)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (p == head &amp;&amp; p-&gt;val == val)<span class="comment">//头节点</span></span><br><span class="line">&#123;</span><br><span class="line">head = p-&gt;next;</span><br><span class="line">p = head;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(p-&gt;val==val)<span class="comment">//中间结点</span></span><br><span class="line">&#123;</span><br><span class="line">pre_p-&gt;next = p-&gt;next;</span><br><span class="line">p = pre_p-&gt;next;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (p-&gt;next == <span class="literal">NULL</span> &amp;&amp; p-&gt;val == val)<span class="comment">//尾结点</span></span><br><span class="line">&#123;</span><br><span class="line">pre_p = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line">pre_p = p;</span><br><span class="line">p = p-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="测试函数："><a href="#测试函数：" class="headerlink" title="测试函数："></a>测试函数：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">ListNode <span class="title">head</span><span class="params">(<span class="number">15</span>)</span></span>;</span><br><span class="line">ListNode* p = &amp;head;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">ListNode* a = <span class="keyword">new</span> ListNode(i);</span><br><span class="line">p-&gt;next = a;</span><br><span class="line">p = p-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">p-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">Solution sol;</span><br><span class="line">ListNode* newHead = sol.removeElements(&amp;head, <span class="number">4</span>);</span><br><span class="line"><span class="keyword">while</span> (newHead)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; newHead-&gt;val &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">newHead = newHead-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="执行结果："><a href="#执行结果：" class="headerlink" title="执行结果："></a>执行结果：</h3><p><img src="/2019/08/09/203-移出链表元素/%E6%89%A7%E8%A1%8C%E7%BB%93%E6%9E%9C.PNG" alt="执行结果"></p><h2 id="四、源码地址"><a href="#四、源码地址" class="headerlink" title="四、源码地址"></a>四、源码地址</h2><p>​            <a href="https://github.com/Aoki-Wang/CheckStation/tree/master/LeetCode/203.RemoveElements" target="_blank" rel="noopener">移出链表元素的实现</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、题目描述&quot;&gt;&lt;a href=&quot;#一、题目描述&quot; class=&quot;headerlink&quot; title=&quot;一、题目描述&quot;&gt;&lt;/a&gt;一、题目描述&lt;/h2&gt;&lt;p&gt;删除链表中等于给定值 &lt;strong&gt;val&lt;/strong&gt; 的所有节点。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;
      
    
    </summary>
    
      <category term="LeetCode" scheme="http://wanqbin.xyz/categories/LeetCode/"/>
    
      <category term="算法" scheme="http://wanqbin.xyz/categories/LeetCode/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="移出链表元素" scheme="http://wanqbin.xyz/tags/%E7%A7%BB%E5%87%BA%E9%93%BE%E8%A1%A8%E5%85%83%E7%B4%A0/"/>
    
      <category term="LeetCode" scheme="http://wanqbin.xyz/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>gdb调试</title>
    <link href="http://wanqbin.xyz/2019/08/08/gdb%E8%B0%83%E8%AF%95/"/>
    <id>http://wanqbin.xyz/2019/08/08/gdb调试/</id>
    <published>2019-08-08T14:24:20.000Z</published>
    <updated>2019-08-09T08:40:10.955Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>静态库和动态库的制作</title>
    <link href="http://wanqbin.xyz/2019/08/08/%E9%9D%99%E6%80%81%E5%BA%93%E5%92%8C%E5%8A%A8%E6%80%81%E5%BA%93%E7%9A%84%E5%88%B6%E4%BD%9C/"/>
    <id>http://wanqbin.xyz/2019/08/08/静态库和动态库的制作/</id>
    <published>2019-08-08T14:23:00.000Z</published>
    <updated>2019-08-09T08:39:49.908Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、静态库和动态库"><a href="#一、静态库和动态库" class="headerlink" title="一、静态库和动态库"></a>一、静态库和动态库</h2><ol><li><h3 id="静态库"><a href="#静态库" class="headerlink" title="静态库"></a>静态库</h3><p>&emsp;&emsp;静态库是指在我们的应用中，有一些公共代码是需要反复所使用的，就把这些代码编译为“库文件”；在连接步骤中，链接器将从库文件取得所需的代码，复制到生成的可执行文件中。</p><p>&emsp;&emsp;程序编译一般需要经过预处理、编译、汇编和链接几个步骤。静态库的特点是可执行文件中包含了库代码的一份完整拷贝。</p><p>&emsp;&emsp;优点：只需保证在开发者的计算机有正确的库文件，在以二进制发布时不需考虑在用户的计算机上库文件是否存在及版本问题，可避免DLL地狱等问题。</p><p>&emsp;&emsp;缺点：生成的可执行文件体积较大。</p></li><li><h3 id="动态库"><a href="#动态库" class="headerlink" title="动态库"></a>动态库</h3><p>&emsp;&emsp;动态库又称动态链接库（Dynamic Link Library,DLL),DLL是一个包含可由多个程序同时使用的代码和数据的库，DLL不是可执行文件。动态链接提供了一种方法，使进程可以调用不属于可执行代码的函数。函数的可执行代码位于一个DLL中，该DLL包含一个或多个已被编译、链接并与它们的进程分开存储的函数。DLL还有助于共享数据和资源。多个应用程序可同时访问内存中单个DLL副本的内容。DLL是一个包含可由多个程序同时使用的代码和数据的库。Windows下动态库为<code>.dll</code>后缀，在Linux下为<code>.so</code>后缀。</p></li><li><h3 id="静态库和动态库的区别"><a href="#静态库和动态库的区别" class="headerlink" title="静态库和动态库的区别"></a>静态库和动态库的区别</h3><p>&emsp;&emsp;静态库和动态库两者的不同点在于代码被载入的时刻不同。静态库的代码在编译过程中已经被载入可执行程序，因此体积比较大。动态库（共享库）的代码在可执行程序运行时才载入内存，在编译过程中仅简单地引用，因此体积比较小。</p><p>&emsp;&emsp;不同的应用程序如果调用相同的库，那么在内存中只需要有一份该动态库的实例。静态库1和动态库的最大区别，静态情况下，把库直接加载到程序中，而动态链接的时候，它只是保留接口，将动态库与程序代码独立，这样就可以提高代码的可复用度，降低程序的耦合度。</p><p>&emsp;&emsp;动态库在程序编译时并不会被链接到目标代码中，而是在程序运行时才被载入，因此在程序运行时还需要动态库的存在。</p></li></ol><h2 id="二、静态库的制作"><a href="#二、静态库的制作" class="headerlink" title="二、静态库的制作"></a>二、静态库的制作</h2><ul><li>静态库的文件命名：<code>libxxx.a</code></li><li>制作步骤：<ul><li>编译为<code>.o</code>文件</li><li>将<code>.o</code>文件打包，<code>ar rcs libxxxx.a file1.o file2.o……</code>。其中，<code>libxxxx.a</code>为静态库名，<code>file1.o</code>等文件都是需要打包的文件</li></ul></li><li>使用：编译时需要加静态库名 ，<code>-L</code>用来指明包含的库路径,<code>-l</code>指定库名(通常为libxx.so或者libxxx.a)</li></ul><p>首先我们将需要打包的文件编译为<code>.o</code>文件</p><p><img src="/2019/08/08/静态库和动态库的制作/6.PNG" alt="静态库制作"></p><p>接下来，将所有需要打包的<code>.o</code>文件打包</p><p><img src="/2019/08/08/静态库和动态库的制作/7.PNG" alt="静态库的制作"></p><p>接下来，使用刚制作的静态库对<code>main.cpp</code>进行编译。在这之前，将制作的静态库移到<code>/lib</code>目录下。</p><p><img src="/2019/08/08/静态库和动态库的制作/8.PNG" alt="静态库的制作"></p><p>执行结果如下：</p><p><img src="/2019/08/08/静态库和动态库的制作/9.PNG" alt="执行结果"></p><h2 id="三、动态库的制作"><a href="#三、动态库的制作" class="headerlink" title="三、动态库的制作"></a>三、动态库的制作</h2><ul><li>制作步骤：<ul><li>编译与位置无关的代码，生成<code>.o</code>文件，关键参数<code>-fPIC</code></li><li>将<code>.o</code>文件打包：关键参数<code>-shared</code></li><li>将库与头文件一起发布</li></ul></li></ul><p>我们利用之前的<code>.cpp</code>文件来制作动态库，首先，将之前制作静态库时用到的文件全部删除。删除结果如下：</p><p><img src="/2019/08/08/静态库和动态库的制作/10.PNG" alt="动态库的制作"></p><p>下面我们编译与位置无关的代码，生成<code>.o</code>文件，结果如下。</p><p><img src="/2019/08/08/静态库和动态库的制作/11.PNG" alt="动态库的制作"></p><p>下面，我们使用动态库的参数<code>-shared</code>打包<code>.o</code>文件。</p><p><img src="/2019/08/08/静态库和动态库的制作/12.PNG" alt="动态库的制作"></p><p>接下来，要做的就是使用动态库。这里，我们先将生成的动态库移动到<code>/lib</code>下面。</p><p><img src="/2019/08/08/静态库和动态库的制作/13.PNG" alt="动态库的制作"></p><p>执行结果如下：</p><p><img src="/2019/08/08/静态库和动态库的制作/14.PNG" alt="动态库的制作"></p><p>我们可以看到，这里并没有执行成功。它没有像静态库一样直接打开可执行文件就可以运行。</p><h2 id="四、解决不能加载动态库的问题"><a href="#四、解决不能加载动态库的问题" class="headerlink" title="四、解决不能加载动态库的问题"></a>四、解决不能加载动态库的问题</h2><p>对于动态库无法加载的问题，这里有三种解决办法</p><ul><li>将动态库拷贝到<code>/lib</code>下，当然这种方式不太好，可能会出现一些问题</li><li>将库路径增加到环境变量<code>LD_LIBRARY_PATH</code>中，这种方式也不是特别推荐</li><li>配置<code>/etc/ld.so.conf</code>，增加动态库的绝对路径，然后执行<code>sudo ldconfig -v</code></li></ul><p>首先，我们使用 <code>pwd</code>命令查看动态库的路径。</p><p><img src="/2019/08/08/静态库和动态库的制作/15.PNG" alt="动态库的制作"></p><p>我们在<code>/etc/ld.so.conf</code>文件中添加该动态库的路径</p><p><img src="/2019/08/08/静态库和动态库的制作/16.PNG" alt="动态库的制作"></p><p>接下来执行<code>sudo ldconfig -v</code>命令，得到下面的结果</p><p><img src="/2019/08/08/静态库和动态库的制作/17.PNG" alt="动态库的制作"></p><p>在<code>sudo ldconfig -v</code>命令中，<code>-v</code>选项表示显示加载过程。</p><p>通过<code>ldd</code>命令，我们可以看到该程序所需要的动态链接库。最后是运行结果。</p><p><img src="/2019/08/08/静态库和动态库的制作/18.PNG" alt="执行结果"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、静态库和动态库&quot;&gt;&lt;a href=&quot;#一、静态库和动态库&quot; class=&quot;headerlink&quot; title=&quot;一、静态库和动态库&quot;&gt;&lt;/a&gt;一、静态库和动态库&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;h3 id=&quot;静态库&quot;&gt;&lt;a href=&quot;#静态库&quot; class=&quot;h
      
    
    </summary>
    
      <category term="Linux命令" scheme="http://wanqbin.xyz/categories/Linux%E5%91%BD%E4%BB%A4/"/>
    
    
      <category term="静态库制作" scheme="http://wanqbin.xyz/tags/%E9%9D%99%E6%80%81%E5%BA%93%E5%88%B6%E4%BD%9C/"/>
    
      <category term="动态库制作" scheme="http://wanqbin.xyz/tags/%E5%8A%A8%E6%80%81%E5%BA%93%E5%88%B6%E4%BD%9C/"/>
    
      <category term="动态库加载" scheme="http://wanqbin.xyz/tags/%E5%8A%A8%E6%80%81%E5%BA%93%E5%8A%A0%E8%BD%BD/"/>
    
  </entry>
  
  <entry>
    <title>gcc编译流程</title>
    <link href="http://wanqbin.xyz/2019/08/08/gcc%E7%BC%96%E8%AF%91%E6%B5%81%E7%A8%8B/"/>
    <id>http://wanqbin.xyz/2019/08/08/gcc编译流程/</id>
    <published>2019-08-08T14:08:00.000Z</published>
    <updated>2019-08-09T07:07:04.707Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、gcc工作流程"><a href="#一、gcc工作流程" class="headerlink" title="一、gcc工作流程"></a>一、gcc工作流程</h2><p>gcc编译流程如下：</p><ul><li><code>gcc -E</code>预处理、头文件展开、宏替换，生成<code>hello.i</code></li><li><code>gcc -S</code>生成汇编代码，生成<code>hello.s</code></li><li><code>gcc -c</code>将汇编文件编译成二进制文件，生成<code>hello.o</code></li><li><code>ld</code>链接，生成可执行文件<code>a.out</code></li></ul><p><img src="/2019/08/08/gcc编译流程/1.PNG" alt="gcc编译流程"></p><h2 id="二、gcc相关参数"><a href="#二、gcc相关参数" class="headerlink" title="二、gcc相关参数"></a>二、gcc相关参数</h2><ul><li><code>-L</code>用来指明包含的库路径</li><li><code>-l</code>指定库名(通常为libxx.so或者libxxx.a)</li><li><code>-g</code>用于gdb调试，不加此选项不能进行gdb调试</li><li><code>-Wall</code>显示更多的警告</li><li><code>-lstdc++</code>编译C++代码</li><li><code>-O</code>优化选项，1—3，数字越大，优先级越高</li><li><code>-D</code>用来指定要执行的宏</li><li><code>-o</code>用来指定编译后文件名</li></ul><p>在当前目录下，有如下图所示的<code>.cpp</code>文件。</p><p><img src="/2019/08/08/gcc编译流程/2.PNG" alt="gcc编译流程"></p><p>我们可以使用gcc的相关参数对这些文件进行编译。下图所示为各个<code>.cpp</code>文件的内容。</p><p><img src="/2019/08/08/gcc编译流程/3.PNG" alt="gcc相关参数"></p><p>我们可以看到在每一个<code>.cpp</code>文件中，都有一个头文件，在对这些<code>.cpp</code>文件进行编译时，我们需要知道该头文件的路径。</p><p><img src="/2019/08/08/gcc编译流程/4.PNG" alt="头文件"></p><p>下面，我们对这些<code>.cpp</code>文件进行编译执行，结果如下图。</p><p><img src="/2019/08/08/gcc编译流程/5.PNG" alt="编译执行结果"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、gcc工作流程&quot;&gt;&lt;a href=&quot;#一、gcc工作流程&quot; class=&quot;headerlink&quot; title=&quot;一、gcc工作流程&quot;&gt;&lt;/a&gt;一、gcc工作流程&lt;/h2&gt;&lt;p&gt;gcc编译流程如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;gcc -E&lt;/code
      
    
    </summary>
    
      <category term="Linux命令" scheme="http://wanqbin.xyz/categories/Linux%E5%91%BD%E4%BB%A4/"/>
    
    
      <category term="Ubuntu" scheme="http://wanqbin.xyz/tags/Ubuntu/"/>
    
      <category term="gcc" scheme="http://wanqbin.xyz/tags/gcc/"/>
    
      <category term="gcc编译" scheme="http://wanqbin.xyz/tags/gcc%E7%BC%96%E8%AF%91/"/>
    
  </entry>
  
  <entry>
    <title>Linux添加系统调用</title>
    <link href="http://wanqbin.xyz/2019/08/08/Linux%E6%B7%BB%E5%8A%A0%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/"/>
    <id>http://wanqbin.xyz/2019/08/08/Linux添加系统调用/</id>
    <published>2019-08-08T11:59:00.000Z</published>
    <updated>2019-08-08T12:00:54.923Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;在Linux中为系统添加一个系统调用并不是很难的事情，首先需要编写自己的系统调用，然后再把编写好的系统调用注册进内核使它成为一个正式的系统调用即可。系统调用函数可以静态添加，也可以动态添加，静态方式就是把系统掉用那个直接加入到内核中，这需要重新编译内核；动态方式是以模块的方式添加系统调用，这种方式下，不需要重新编译内核。</p><ol><li><h3 id="编写系统调用函数"><a href="#编写系统调用函数" class="headerlink" title="编写系统调用函数"></a>编写系统调用函数</h3><p>&emsp;&emsp;编写自己的系统调用前，必须首先清楚该系统调用所要实现的功能是什么，在Linux中，尽量不要用一个系统调用来实现多个功能。系统调用接口应该尽量简洁，参数尽量少，当然还要考虑到系统调用的通用性，即系统调用是否可移植等因素。</p><p>&emsp;&emsp;内核执行系统调用的时候处于进程上下文中，因此可以睡眠，也可以被抢占，这样系统调用可以使用内核提供的绝大多数函数。系统调用函数的一般形式如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">asmlinkage <span class="keyword">long</span> sys_ <span class="title">xxx</span><span class="params">(type1 arg1,type2 arg2……）</span></span></span><br></pre></td></tr></table></figure></li><li><h3 id="把系统调用添加到系统调用表中"><a href="#把系统调用添加到系统调用表中" class="headerlink" title="把系统调用添加到系统调用表中"></a>把系统调用添加到系统调用表中</h3><p>&emsp;&emsp;把编写好的系统调用添加到系统表的最后，对于支持该系统调用的所有硬件体系结构都必须做这样的工作。从0开始算起，系统调用在该表中的位置就是它的系统调用号。每种体系结构下对应的系统调用号不一定相同。</p></li><li><h3 id="添加系统调用号"><a href="#添加系统调用号" class="headerlink" title="添加系统调用号"></a>添加系统调用号</h3><p>&emsp;&emsp;对于系统调用所支持的各种体系结构，把由上一步得到的系统调用号添加到文件<code>unistd.h</code>中，并修改总的系统调用个数<code>NR_syscalls</code>的值。</p></li><li><h3 id="添加系统调用函数"><a href="#添加系统调用函数" class="headerlink" title="添加系统调用函数"></a>添加系统调用函数</h3><p>&emsp;&emsp;最后把编写好的系统调用函数添加到内核中时，要保证系统必须被编译进内核映像（而不是被编译成模块）。</p></li><li><h3 id="重新编译内核"><a href="#重新编译内核" class="headerlink" title="重新编译内核"></a>重新编译内核</h3><p>&emsp;&emsp;编译修改过的Linux内核，再次系统选择启动新内核，这样就可以使用刚才写好的系统调用了。</p></li><li><h3 id="从用户空间使用系统调用"><a href="#从用户空间使用系统调用" class="headerlink" title="从用户空间使用系统调用"></a>从用户空间使用系统调用</h3><p>&emsp;&emsp;通常，系统调用靠C库的支持，用户程序通过包含标准头文件并和C库链接，就可以使用系统调用了。但是如果仅仅写出系统调用，glibc库恐怕并提供支持。在2.6.20之后，出于安全的考虑，Linux删除了<code>_syscalln</code>的一组宏，这样就只有使用内核为用户程序提供的另外一个函数<code>syscall</code>。该函数的形式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">syscall(_NR_mysyscall,arg1,arg2……）;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&amp;emsp;&amp;emsp;在Linux中为系统添加一个系统调用并不是很难的事情，首先需要编写自己的系统调用，然后再把编写好的系统调用注册进内核使它成为一个正式的系统调用即可。系统调用函数可以静态添加，也可以动态添加，静态方式就是把系统掉用那个直接加入到内核中，这需要重新编译内
      
    
    </summary>
    
      <category term="Linux内核" scheme="http://wanqbin.xyz/categories/Linux%E5%86%85%E6%A0%B8/"/>
    
    
      <category term="Linux内核" scheme="http://wanqbin.xyz/tags/Linux%E5%86%85%E6%A0%B8/"/>
    
      <category term="Linux系统调用" scheme="http://wanqbin.xyz/tags/Linux%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/"/>
    
      <category term="Linux添加系统调用" scheme="http://wanqbin.xyz/tags/Linux%E6%B7%BB%E5%8A%A0%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/"/>
    
      <category term="操作系统" scheme="http://wanqbin.xyz/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>Linux系统调用实现分析</title>
    <link href="http://wanqbin.xyz/2019/08/08/Linux%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E5%AE%9E%E7%8E%B0%E5%88%86%E6%9E%90/"/>
    <id>http://wanqbin.xyz/2019/08/08/Linux系统调用实现分析/</id>
    <published>2019-08-08T11:33:00.000Z</published>
    <updated>2019-08-08T11:33:37.412Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、C程序库和系统调用"><a href="#一、C程序库和系统调用" class="headerlink" title="一、C程序库和系统调用"></a>一、C程序库和系统调用</h2><p>&emsp;&emsp;系统调用视为了编程人员提供内核服务的一组函数，而C程序库通过软中断陷入内核，实现内核服务。</p><p>&emsp;&emsp;系统调用时系统内核向用户程序提供支持的接口，通过这些接口应用程序向系统内核服务，控制转向系统内核，而系统内核在完成服务之后，将控制和结果返回给用户程序。系统调用是用户程序与系统内核的边界，通过系统调用，进程可由用户模式转入内核模式，在内核模式下完成一定的服务请求后再返回用户模式。系统调用只是提供一个基本功能集，而通过对这些操作的引用和封装，可以形成丰富而且强大的系统调用库。这里体现了Linux的机制与策略相分离的编程思想——系统调用只是提供访问核心的基本机制，而策略是通过系统调用库来实现的。</p><p>&emsp;&emsp;在Linux中，系统调用库实体通过C程序来实现的，又称为C程序库。C程序库主要是为编程人员提供应用程序编程接口（API），即为编程人员提供与内核进行交互的一组法术。一般情况下，应用程序使用的这种编程接口实际上并不需要和内核提供的系统调用对应。一个API的功能可以通过一个系统调用来实现，也可以通过多个系统调用来实现，也可以完全不使用系统调用。实际上，API可以在各种操作系统上实现，给应用程序提供完全相同的接口，而它们自身在这些系统同上的实现可能不同。</p><p>&emsp;&emsp;从程序员的角度来看，系统调用无关紧要；他们只需要跟C库的API打交道就可以。相反的，内核只跟系统调用打交道；库函数及应用程序怎么使用系统调用并不是内核所关心的。只是内核必须时刻牢记系统调用所有潜在的用途并保证它们有良好的通用性和灵活性。</p><h2 id="二、系统调用实现分析"><a href="#二、系统调用实现分析" class="headerlink" title="二、系统调用实现分析"></a>二、系统调用实现分析</h2><p>&emsp;&emsp;在Linux系统中系统调用时用户空间访问内核的一种方式，系统调用执行大致过程如下：</p><p>（1）在应用程序中调用用户空间的库函数</p><p>（2）库函数在执行一系列预处理后，取得系统调用号，传递相应的参数并执行软中断指令<code>INT</code>产生中断</p><p>（3）Linux系统进行地址空间的转换和堆栈的切换，执行<code>SAVE_ALL</code>宏定义，从而保存现场</p><p>（4）根据系统调用号从系统调用表找到对应系统调用处理程序的入口地址</p><p>（5）执行系统调用对应的处理程序</p><p>（6）执行<code>RESTORE_ALL</code>宏定义，恢复系统调用前的任务现场并返回用户模式</p><p>不同的平台，系统调用的实现也不同。下面是在x86体系结构中系统调用的实现。</p><ol><li><h4 id="系统调用的初始化"><a href="#系统调用的初始化" class="headerlink" title="系统调用的初始化"></a>系统调用的初始化</h4><p>&emsp;&emsp;在应用程序调用系统调用时，应该以某种方式从用户态陷入到内核态，在Linux中可以通过软中断（这里的软中断是相对于外部的硬件中断来说的）来实现陷入，在x86平台上，这条指令是<code>init 0x80</code>。也就是说在Linux中，向系统调用的接口是一个中断处理函数的特例。这样，就需要在系统启动时，对系统调用中断进行初始化。</p><p>&emsp;&emsp;Linux内核在初始化期间会调用<code>arch/i386/kernel/traps.c</code>文件中的<code>trap_init()</code>函数来设置中断描述符表。在这个函数中，通过调用函数<code>set_system_gate(SYSCALL_VECTOR,&amp;SYSTEM_call)</code>来完成该项的设置。其中的<code>SYSTEMCALL_VECTOR</code>就是<code>0x80</code>，而<code>system_call</code>则是一个汇编子函数，它是中断<code>0x80</code>的处理函数，也是系统调用的入口函数。</p></li><li><h4 id="与系统调用相关的数据结构"><a href="#与系统调用相关的数据结构" class="headerlink" title="与系统调用相关的数据结构"></a>与系统调用相关的数据结构</h4><h4 id="（1）系统调用号"><a href="#（1）系统调用号" class="headerlink" title="（1）系统调用号"></a>（1）系统调用号</h4><p>&emsp;&emsp;在Linux中每个系统调用被赋予一个唯一的编号，这个编号被称为系统调用号。这样通过这个独一无二的号就可以关联到相应的系统调用处理处理程序。系统调用号定义在<code>include/asm/unistd.h</code>中，编号的定义方式如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _NR_result_syscall0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _NR_exit   1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _NR_fork  2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _NR_read                         3</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _NR_write  4</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _NR_open5</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _NR_close  6</span></span><br><span class="line"></span><br><span class="line">……</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NR_syscalls  325</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;其中，<code>NR_syscalls</code>表示系统调用的总数，在检查一个系统调用号是否合法时要用到。</p><p>&emsp;&emsp;系统调用号非常关键，当用户空间的进程执行一个系统调用的时候，系统使用系统调用号而不是系统调用的函数名称，来指明到底是要执行那个系统调用。系统调用号一旦分配就不能再有任何变更，否则编译好的应用程序就会崩溃。此外，如果一个系统调用被删除，它所占用的系统调用号也不允许被回收利用，否则，以前编译过的代码在调用这个系统调用时，就会出错。为此，Linux设置了专门的“未实现”系统调用<code>sys_ni_syscall()</code>，它除了返回<code>-ENOSYS</code>外，不做任何其他的事。当系统调用一个被删除的系统调用时，或者无效的系统调用时，这个函数就会被执行。</p><h4 id="（2）系统调用表"><a href="#（2）系统调用表" class="headerlink" title="（2）系统调用表"></a>（2）系统调用表</h4><p>&emsp;&emsp;内核使用系统调用表记录了各个系统调用处理函数的入口地址，以系统同调用号为偏移量能够很容易地在该表中找到对应的处理函数地址。系统调用表存储在<code>sys_call_table</code>中，它与体系结构有关，x86体系结构的系统调用表定义在<code>arch/x86/kernel/syscall_table.S</code>中，其定义方式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ENTER(sys_call_table)</span><br><span class="line">.long sys_restart_syscall</span><br><span class="line">.long sys_exit</span><br><span class="line">.long sys_fork</span><br><span class="line">.long sys_read</span><br><span class="line">……</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;当用户空间程序调用一个系统调用时，系统调用号作为参数传递给中断<code>0x80</code>，而该标号实际上就相当于系统调用表的下标，通过该值可以找到相应的系统调用的处理函数。</p></li><li><h4 id="系统调用入口函数"><a href="#系统调用入口函数" class="headerlink" title="系统调用入口函数"></a>系统调用入口函数</h4><p>&emsp;&emsp;当用户执行了软中断指令后，系统从用户空间进入内核空间，并在内核空间执行系统调用入口函数。系统调用入口函数由<code>arch/x386/kernel/entry_32.S</code>文件中的<code>system_call</code>汇编代码段定义，其主要功能是对系统调用进行预处理，并调用相应的系统调用服务例程。函数的执行过程如下：</p><p>（1）首先将系统调用号（eax的值，因为在save_all中保存的eax寄存器会被调用的返回值覆盖）放入栈中</p><p>（2）调用<code>save_all</code>保存寄存器上下文</p><p>（3）得到进程的<code>thread_info</code>结构指针放到<code>ebp</code>中。检查<code>struct thread_info</code>中的<code>flags</code>标志，看是否有系统管理调用跟踪等，有则跳到<code>syscall_trace_entry</code></p><p>（4）检查系统调用号的有效性，若不小于<code>nr_syscalls</code>则报错并返回<code>-ENOOSYS</code>，否则跳转到该系统调用的处理函数入口。这里以eax作为偏移，在系统调用表<code>sys_call_table</code>中查找处理函数入口地址，并跳转到该入口地址</p><p>（5）将返回值存放在eax中，调用<code>restore_all</code>恢复寄存器上下文。</p></li><li><h4 id="系统调用的参数传递"><a href="#系统调用的参数传递" class="headerlink" title="系统调用的参数传递"></a>系统调用的参数传递</h4><p>&emsp;&emsp;与普通的函数类似，系统调用通常也需要输入/输出参数，这些参数可能是实际的值，也可能是函数的地址及用户态进程地址空间的变量。在系统调用需要传递少量参数的情况下，通常采用处理器中的寄存器完成参数的传递工作。系统调用过程中所需要的参数由寄存器<code>%eax</code>,<code>%ebx</code>,<code>%ecx</code>,<code>%edx</code>,<code>%esi</code>,<code>%edi</code>来传递。</p><p>&emsp;&emsp;事实上，系统调用过程中系统调用号就是通过处理器中的寄存器<code>%eax</code>进行传递的，系统调用入口函数<code>system_call()</code>根据保存在该寄存器中的不同系统调用号，调用相应的系统调用处理函数来完成具体的系统调用。</p><p>&emsp;&emsp;具体的系统调用处理函数所需参数依次由除了<code>%eax</code>外剩余的5个寄存器<code>%ebx</code>,<code>%ecx</code>,<code>%edx</code>,<code>%esi</code>,<code>%edi</code>来传递。在系统调用处理过程中，这些保存在处理器寄存器中的参数被系统调用入口函数<code>system_call()</code>通过调用<code>save_all()</code>函数压入到内核态栈中。具体的系统调用处理函数从内核态栈中取得相应的参数值，完成具体的处理工作。</p><p>&emsp;&emsp;当系统调用需要在用户态和内核态传递大量数据时，处理器中内置的寄存器显然不够使用。通常的做法是，把所传递的参数封装到特定的结构中，此时采用一个指向该结构的指针和该结构的长度值来描述这一参数，再和传递少量数据的情况一样将这两个通过处理器中的参数进行传递。</p><p>&emsp;&emsp;由于在内核中，不可以访问用户态地址空间，Linux提供了<code>copy_from_user()</code>和<code>copy_to_user()</code>两个函数，用于用户态空间和内核态空间的数据交换。</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、C程序库和系统调用&quot;&gt;&lt;a href=&quot;#一、C程序库和系统调用&quot; class=&quot;headerlink&quot; title=&quot;一、C程序库和系统调用&quot;&gt;&lt;/a&gt;一、C程序库和系统调用&lt;/h2&gt;&lt;p&gt;&amp;emsp;&amp;emsp;系统调用视为了编程人员提供内核服务的一组函数
      
    
    </summary>
    
      <category term="Linux内核" scheme="http://wanqbin.xyz/categories/Linux%E5%86%85%E6%A0%B8/"/>
    
    
      <category term="Linux系统调用" scheme="http://wanqbin.xyz/tags/Linux%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/"/>
    
      <category term="操作系统" scheme="http://wanqbin.xyz/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="系统调用" scheme="http://wanqbin.xyz/tags/%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/"/>
    
      <category term="C程序库" scheme="http://wanqbin.xyz/tags/C%E7%A8%8B%E5%BA%8F%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>Linux调度相关系统调用</title>
    <link href="http://wanqbin.xyz/2019/08/08/Linux%E8%B0%83%E5%BA%A6%E7%9B%B8%E5%85%B3%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/"/>
    <id>http://wanqbin.xyz/2019/08/08/Linux调度相关系统调用/</id>
    <published>2019-08-08T09:00:00.000Z</published>
    <updated>2019-08-08T09:00:48.927Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;Linux内核提供的一些系统调用主要用于管理和维护与进程调度相关的参数值，这些系统调用可以用来获取和设置进程的优先级、进程调度策略，以及进程与处理器的亲和力等。</p><div class="table-container"><table><thead><tr><th>系统调用</th><th>功能简介</th></tr></thead><tbody><tr><td>nice()</td><td>用于设置普通进程的静态优先级，即设置进程的nice值</td></tr><tr><td>getprioprity()</td><td>返回20减去给定进程组中所有进程之中最低nice字段的值，即获得一组普通进程的最大优先级</td></tr><tr><td>setpriority()</td><td>把给定组中所有进程的静态优先级都设置为一个给定的值</td></tr><tr><td>sched_getaffinity()</td><td>获取进程与处理器的亲和力掩码</td></tr><tr><td>sched_setaffinity()</td><td>设置进程与处理器的亲和力掩码</td></tr><tr><td>sched_getscheduler()</td><td>获取进程的调度策略</td></tr><tr><td>sched_setschedule()</td><td>设置一个进程的调度策略和实时优先级</td></tr><tr><td>sched_getparam()</td><td>获取一个进程的实时优先级</td></tr><tr><td>sched_setparam()</td><td>设置一个进程的实时优先级</td></tr><tr><td>sched_yield()</td><td>进程自愿暂时让出CPU</td></tr><tr><td>sched_get_priority_min()</td><td>获取最小的实时静态优先级</td></tr><tr><td>sched_get_priority_max()</td><td>获取最大的实时静态优先级</td></tr><tr><td>sched_rr_get_interval()</td><td>获得时间片轮转策略的时间片值</td></tr></tbody></table></div><ol><li><p><code>nice()</code>系统调用</p><p>&emsp;&emsp;该函数用于设置普通进程的静态优先级，它可以将给定进程的静态优先级增加一个给定的量，这时我们应该注意，这个给定的量有两种情况，第一种是将给定的进程的静态优先级加上一个正值，其实这相当于降低进程的优先级，第二种是将给定的进程的静态优先级加上一个负值，其实这相当于提高进程的优先级。</p><p>&emsp;&emsp;在Linux中规定，作为一般原则，总是允许用户降低他们进程的优先级，即给定的那个量是一个正值。然而，如果他们想修改属于某一用户进程的优先级，或者如果他们想增加自己进程的优先级，即给定的量是一个负值，那么，他们必须拥有超级用户的特权。</p><p>&emsp;&emsp;<code>nice()</code>函数会调用内核的<code>set_uer_nice()</code>函数，这个函数会设置进程的<code>task_struct</code>中的<code>static_prio</code>和<code>prio</code>的值。</p></li><li><p><code>getprioriity()</code>和<code>setpriority()</code>系统调用</p><p>&emsp;&emsp;<code>nice()</code>系统调用只影响调用它的进程，而另外两个系统调用<code>getpriority()</code>和<code>setpriority()</code>则作用于给定组中所有进程的基本优先级。<code>getpriority()</code>返回20减去给定组中所有进程之中最低<code>nice</code>字段的值，<code>setpriority()</code>把给定组中所有进程的基本优先级都设置为一个给定的值。</p></li><li><p><code>getaffinity()</code>和<code>setaffinity()</code>系统调用</p><p>&emsp;&emsp;Linux调度程序提供强制的处理器绑定机制，即它允许用户强制指定某个进程必须在相应的CPU上运行，所谓亲和力掩码就是用于指定该进程可以在哪个CPU上运行的一个标志位，它保存在进程结构体（<code>task_struct</code>)的<code>cpu_allowed</code>这个位掩码标志中。该掩码1的每一位对应于系统中的一个CPU，在默认情况下一个进程的该掩码所有的位都被设置，即默认情况下一个进程可以在系统中所有可用的CPU上运行。</p></li><li><p><code>sched_getscheduler()</code>和<code>sched_setscheduler()</code>系统调用</p><p>&emsp;&emsp;<code>sched_getscheduler()</code>和<code>sched_setscheduler()</code>分别用于设置和获取进程的调度策略和实时优先级。其主要工作就是读取和设置进程结构体<code>task_struct</code>中的<code>policy</code>和<code>rt_priority</code>域的值。</p><p>&emsp;&emsp;<code>sched_getscheduler()</code>函数查询与给定的pid相对应的进程当前所用的调度策略。如果pid为0，将检索调用该函数的进程的调度策略；如果成功，这个系统调用为进程返回策略。</p><p>&emsp;&emsp;<code>sched_setscheduler()</code>系统调用既可以设置调度策略，也可以设置与给定的pid相对应的进程的相关参数。如果pid为0，调用该函数的进程的调度程序参数将被设置。</p></li><li><p><code>sched_getparam()</code>和<code>sched_setparam()</code>系统调用</p><p>&emsp;&emsp;<code>sched_getparam()</code>和<code>sched_setparam()</code>分别用于设置和获取进程的实时优先级。<code>sched_getparam()</code>系统调用可以获取与给定的pid相对应的进程的实时优先级。如果pid为0，<code>current</code>进程的实时优先级将被检索。它首先找到与pid相关的进程描述符指针，把它的<code>rt_priority</code>字段存放在类型为<code>sched_param</code>的局部变量中，并调用<code>copy_to_user()</code>把它复制到进程地址空间中由<code>param</code>参数指定的地址。<code>sched_setparam()</code>系统调用类似于<code>sched_setscheduler()</code>，它与后者的不同在于不让调用者设置<code>policy</code>字段的值。</p></li><li><p><code>sched_yield()</code>系统调用</p><p>&emsp;&emsp;<code>sched_yield()</code>系统调用提供了一种让进程资源地让出CPU给其他等待执行的进程的方法，这个调用主要由<code>SCHED_FIFO</code>实时进程调用。</p><p>&emsp;&emsp;在Linux中对于实时进程和普通进程在调用该函数后的处理有些不同。当调用该函数的进程是一个普通进程时，内核会把该进程移到进程队列中的过期队列中，这样可以保证该进程在一段时间内不会再次被调度。当调用该函数的进程是一个实时进程时，由于实时进程不会过期，所以内核会将调用该函数的进程放到优先级队列的后面，而不是移到过期队列中。</p></li><li><p><code>sched_get_priority_min()</code>和<code>sched_get_priority_max()</code>系统调用</p><p>&emsp;&emsp;该系统调用主要用于返回给定调度策略的最大和最小优先级。实时调度策略的最大优先级时<code>MAX_USER_RT_PRIO</code>减1，最小优先级是1.当调用该函数时若<code>current</code>是实时进程,<code>sys_sched_get_priority_min()</code>服务例程返回1，否则返回0；<code>sys_sched_get_priority_max()</code>服务例程返回99（最高优先级），否则返回0.</p></li><li><p><code>sched_rr_get_interval()</code>系统调用</p><p><code>sched_rr_get_interval()</code>系统调用把参数pid表示的实时进程的轮转时间片写入用户态地址空间的一个结构中。如果pid等于0，系统调用就写当前进程的时间片。相应的<code>sys_sched_rr_get_interval()</code>服务例程同样带哦用<code>find_process_by_pid()</code>检索与pid相关的进程描述符。然后，把存放在所选中进程的基本时间片转换为秒数和纳秒数，并把它们复制到用户态的结构中，通常，FIFO实时进程的时间片等于0。</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&amp;emsp;&amp;emsp;Linux内核提供的一些系统调用主要用于管理和维护与进程调度相关的参数值，这些系统调用可以用来获取和设置进程的优先级、进程调度策略，以及进程与处理器的亲和力等。&lt;/p&gt;
&lt;div class=&quot;table-container&quot;&gt;
&lt;table&gt;
&lt;t
      
    
    </summary>
    
      <category term="Linux内核" scheme="http://wanqbin.xyz/categories/Linux%E5%86%85%E6%A0%B8/"/>
    
    
      <category term="Linux内核" scheme="http://wanqbin.xyz/tags/Linux%E5%86%85%E6%A0%B8/"/>
    
      <category term="操作系统" scheme="http://wanqbin.xyz/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="系统调用" scheme="http://wanqbin.xyz/tags/%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/"/>
    
  </entry>
  
  <entry>
    <title>Linux内核调度</title>
    <link href="http://wanqbin.xyz/2019/08/08/nux%E5%86%85%E6%A0%B8%E8%B0%83%E5%BA%A6/"/>
    <id>http://wanqbin.xyz/2019/08/08/nux内核调度/</id>
    <published>2019-08-08T08:06:00.000Z</published>
    <updated>2019-08-08T08:07:31.330Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、schedule"><a href="#一、schedule" class="headerlink" title="一、schedule()"></a>一、<code>schedule()</code></h2><p>&emsp;&emsp;选定下一个需要调度的进程并切换到该进程上面去执行是通过<code>schedule()</code>函数来实现的。当内核代码想要休眠时，将会直接调用该函数；另外，在系统返回到用户态以及从中断返回时，内核都会调用<code>need_resched()</code>函数检查时候设置了<code>need_resched</code>标志，来决定是否调用<code>schedule()</code>函数。<code>need_resched</code>存放在<code>thread_info</code>结构体中，用一个标志变量中的一位来表示，用于表示当前是否需要重新调度。</p><p>&emsp;&emsp;<code>schedule()</code>函数独立于每个处理器运行，每个CPU都有自己的标号id和运行队列，因此每个CPU可以独立地对下一次该运行那个进程做出判断。通过<code>smp_processor_id()</code>可以获取当前的CPU标号，其类型为<code>unsigned int</code>。通过<code>cpu_rq(cpu)</code>可以获取CPU的运行队列。</p><p><code>schedule()</code>函数中的部分代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">need_resched:</span><br><span class="line">preempt_disable();</span><br><span class="line">cpu=smp_processor_id();</span><br><span class="line">rq=cpu_rq(cpu);</span><br><span class="line">rcu_qsctr_inc(cpu);</span><br><span class="line">prev=rq-&gt;curr;</span><br><span class="line">switch_count=&amp;prev-&gt;nivcsw;</span><br><span class="line">release_kernel_lock(prev);</span><br></pre></td></tr></table></figure><p>调用<code>preempt_disable()</code>函数禁止内核抢占，然后获取当前CPU的运行队列。调用<code>release_kernel_lock()</code>函数，如果内核被锁定，该函数释放大内核锁。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">local_irq_disable();</span><br><span class="line">_update_rq_clock(rq);</span><br><span class="line">sppin_lock(&amp;rq-&gt;lock);</span><br><span class="line">clear_tsk_need_resched(prev);</span><br></pre></td></tr></table></figure><p>代码中<code>local_irq_disable()</code>函数用于禁止当前处理器中断，<code>_update_rq_clock()</code>函数用于更新当前运行队列<code>rq</code>的时钟，<code>clear_tsk_need_resched()</code>函数用于清除当前进程的<code>need_resched()</code>标志。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(prev-&gt;state&amp;&amp;!(preempt_count()&amp;&amp;PREEMPT_ACCTIVE))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(unlikely((prev-&gt;state&amp;TASK_INTERRUPTIBLE)&amp;&amp;unlikely(signal_pending(prev))))</span><br><span class="line">        &#123;</span><br><span class="line">          prev-&gt;state=TASK_RUNNING;  </span><br><span class="line">        &#125;</span><br><span class="line">       <span class="keyword">else</span></span><br><span class="line">       &#123;</span><br><span class="line">           deactivate_task(rq,prev,<span class="number">1</span>);</span><br><span class="line">       &#125;</span><br><span class="line">      switch_count=&amp;prev-&gt;nvcsw;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>if(prev-&gt;state&amp;&amp;!(preempt_count()&amp;&amp;PREEMPT_ACCTIVE))</code>,表示判断当前进程的状态是否为<code>TASK_RUNNING</code>状态，并且当前的内核是否为非抢占式。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(unlikely((prev-&gt;state&amp;TASK_INTERRUPTIBLE)&amp;&amp;unlikely(signal_pending(prev))))</span><br><span class="line">       &#123;</span><br><span class="line">         prev-&gt;state=TASK_RUNNING;  </span><br><span class="line">       &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">          deactivate_task(rq,prev,<span class="number">1</span>);</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure><p>其中，以上代码查看当前进程的状态是否为可中断睡眠状态<code>TASK_INTERRUPTIBLE</code>，并且等待的信号已经发生。如果是，则将当前进程的状态重新设置为可执行状态<code>TASK_RUNNING</code>，否则将当前进程从运行队列中删除。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(unlikely(!rq-&gt;nr_running))</span><br><span class="line">&#123;</span><br><span class="line">    idle_balance(cpu,rq);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码检查当前CPU的运行队列是否有可执行的进程，如果没有可执行的进程且定义了SMP，调用<code>idle_balance()</code>函数进行负载平衡。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">prev-&gt;sched_class-&gt;put_prev_task(rq,prev);</span><br></pre></td></tr></table></figure><p>以上代码调用当前进程调度类的<code>put_prev_task()</code>函数，根据进程的状态将其放入到相应的队列中。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">next=pick_next_task(rq,prev);</span><br></pre></td></tr></table></figure><p>以上代码调用<code>pick_next_task()</code>函数从当前CPU的运行队列中选取下一个需要执行的任务。<code>pick_next_task()</code>函数在选择下一个需要调度的进程时，充分体现了模块化调度的好处。它首先检查是否有实时进程，如果没有，就调用CFS调度类的<code>pick_next_task()</code>函数选择下一个需要调度的进程；如果存在实时进程，则调用实时进程调度类的<code>pick_next_task()</code>函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(likely(prev!=next))</span><br><span class="line">&#123;</span><br><span class="line">    rq-&gt;nr_switchs++;</span><br><span class="line">    rq-&gt;curr=next;</span><br><span class="line">    ++*switch_count;</span><br><span class="line">    context_switch(rq,prev,next);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    spin_unlock_irq(&amp;rq-&gt;lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码检查下一个需要调度的进程和当前进程是否为同一个进程。如果不是，则调用<code>context_switch()</code>函数进行上下文切换。<code>context_switch()</code>函数负责上下文的切换，即从一个进程切换到另一个可执行的进程。它主要完成以下两个工作：</p><ul><li>虚拟内存映射的切换：负责把虚拟内存从被切换下来的进程映射到新进程中，该功能是由函数<code>switch_mm()</code>来实现的。</li><li>进程的寄存器状态的切换：负责从一个进程的处理器状态切换到新进程的处理器状态，该功能是由函数<code>switch_to()</code>来实现的。</li></ul><h2 id="二、内核抢占"><a href="#二、内核抢占" class="headerlink" title="二、内核抢占"></a>二、内核抢占</h2><p>&emsp;&emsp;为了提高系统的响应能力、实时能力以及用户的满意度，在Linux2.6内核中引入了抢占机制；即只要重新调度是安全的，那么内核就可以在任何时间抢占正在执行的任务。内核抢占与用户抢占一样，包含显式内核抢占和隐式内核抢占。</p><p>（1）显式内核抢占：这种抢占很简单，它发生在内核代码调用<code>schedule()</code>函数时的内核空间中，内核代码可以用两种方式调用<code>schedule()</code>函数，即主动调用<code>schedule()</code>函数让出CPU控制权或内核代码被阻塞时调用<code>schedule()</code>函数。显式内核抢占从来都是受支持的，因为它无需额外的逻辑来保证内核可以安全地被抢占，如果内核代码调用<code>schedule()</code>，那么它应该很清楚自己是可以被安全地抢占的。</p><p>（2）隐式内核抢占：这是Linux2.6新增的功能，当一个内核任务拥有对CPU控制权时，只要当前进程没有持有任何锁（即重新调度是安全的），这个内核任务就可以被另一个更高优先级的内核任务抢占。为了支持隐式内核抢占，在每个进程的<code>thread_info</code>结构中引入了<code>preempt_count</code>计数器，该计数器的初始值为0，每当使用锁的时候数值增加1，释放锁的时候数值减1。当数值为0时，内核就可以执行抢占。从中断返回内核空间的时候，内核会检查<code>need_resched</code>和<code>preempt_count</code>的值，如果<code>need_resched</code>被设置，并且<code>preempt_count</code>为0的话，这说明有一个更为重要的任务需要执行且可以安全地被抢占，此时，调度程序就会被调用。如果<code>preempt_count</code>不为0，说明当前的任务持有锁，不能被抢占，这时就会直接从中断返回到当前执行的任务中。如果当前的任务持有的锁被释放，<code>preempt_count</code>等于0，释放锁的代码就会检查<code>need_resched</code>时候被设置，如果是，就会调用调度程序。与内核相关的几个函数如下：</p><ul><li><p><code>preempt_enable_no_resched()</code>函数激活内核抢占，该函数会调用<code>dec_preempt_count()</code>函数，使<code>preempt_count</code>的值减1。</p></li><li><p><code>preempt_disable()</code>函数禁止内核抢占，该函数会调用<code>inc_preempt_count()</code>,使<code>preempt_count</code>的值加1。</p></li><li><p><code>preempt_enable()</code>函数激活内核抢占且检查是否需要内核抢占，该函数会调用<code>preempt_enable_no_resched()</code>函数，同时会调用<code>preempt_check_resched()</code>判断当前进程是否被标记为重新调度，如果是，它调用<code>preempt_schedule()</code>函数进行内核抢占。</p></li></ul><p>根据以上描述，可知内核抢占的时机是：</p><ul><li>从中断处理程序返回内核空间时</li><li>内核代码再一次具有可抢占性的时候</li><li>内核中显式地调用<code>schedule()</code></li><li>内核的任务阻塞</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、schedule&quot;&gt;&lt;a href=&quot;#一、schedule&quot; class=&quot;headerlink&quot; title=&quot;一、schedule()&quot;&gt;&lt;/a&gt;一、&lt;code&gt;schedule()&lt;/code&gt;&lt;/h2&gt;&lt;p&gt;&amp;emsp;&amp;emsp;选定下一个需要调度
      
    
    </summary>
    
      <category term="Linux内核" scheme="http://wanqbin.xyz/categories/Linux%E5%86%85%E6%A0%B8/"/>
    
    
      <category term="操作系统" scheme="http://wanqbin.xyz/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="Linux内核调度" scheme="http://wanqbin.xyz/tags/Linux%E5%86%85%E6%A0%B8%E8%B0%83%E5%BA%A6/"/>
    
      <category term="内核抢占" scheme="http://wanqbin.xyz/tags/%E5%86%85%E6%A0%B8%E6%8A%A2%E5%8D%A0/"/>
    
  </entry>
  
  <entry>
    <title>Linux进程调度——实时调度算法</title>
    <link href="http://wanqbin.xyz/2019/08/08/Linux%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6%E2%80%94%E2%80%94%E5%AE%9E%E6%97%B6%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95/"/>
    <id>http://wanqbin.xyz/2019/08/08/Linux进程调度——实时调度算法/</id>
    <published>2019-08-08T06:38:00.000Z</published>
    <updated>2019-08-08T08:09:26.002Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、实时调度策略"><a href="#一、实时调度策略" class="headerlink" title="一、实时调度策略"></a>一、实时调度策略</h2><p>&emsp;&emsp;在Linux中，实时优先级范围从0到<code>MAX_RT_PRIO-1</code>，默认情况下，<code>MAX_RT_PRIO</code>为100，所以默认情况的实时优先级从0到99。任何实时进程都比普通进程先得到调度，Linux提供了两种调度策略：<code>SCHED_FIFO</code>和<code>SCHED_RR</code>。</p><p>&emsp;&emsp;<code>SCHED_FIFO</code>实现了一种非常简单的、先进先出的调度算法。适用于对相应时间要求比较高，运行所需时间比较短的实时进程。采用该策略时，各实时进程按其进入可运行队列的顺序依次获得CPU。除了因等待某一时间主动放弃CPU，或者出现优先级更高的进程而剥夺CPU之外，该进程将一直占用CPU，直到进程运行结束。</p><p>&emsp;&emsp;<code>SCHED_RR</code>与<code>SCHED_FIFO</code>大致相同，是带有时间片的<code>SCHED_FIFO</code>。适用于对响应时间要求比较高，运行所需时间比较长的实时进程。采用该策略时，各实时进程按时间片轮流使用CPU。当一个运行进程的时间片用完之后，重置其时间片，进程调度程序停止其运行并将其置于可运行队列的末尾。</p><p>&emsp;&emsp;Linux实时调度策略提供的实时调度是软实时调度。软实时的含义是：内核调度进程尽力使进程在它优先的限定时间到来前运行，但内核并不保证总能满足这些进程的要求。相反，硬实时系统保证在一定条件下，可以满足任何调度的要求。Linux对于实时任务的调度不做任何保证，虽然不能保证硬实时工作方式，但是Linux的实时调度算法经过简单的修改可以满足硬实时的要求。</p><p>&emsp;&emsp;实时任务存放在实时运行队列中。由结构<code>rt-rq</code>表示。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rt</span>-<span class="title">rq</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rt_prio_array</span> <span class="title">active</span>;</span><span class="comment">/*实时任务的优先级数组*/</span></span><br><span class="line"><span class="keyword">int</span> rt_load_balance_idx;<span class="comment">/*需要进行负载平衡的实时队列的下标*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> *<span class="title">rt_load_balance_head</span> *<span class="title">rt_load_balance_curr</span>;</span><span class="comment">/*需要进行负载平衡队列的链表头节点，需要负载平衡的下一个任务*/</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在实时运行队列<code>rt_rq</code>中有一个实时优先队列数组，定义在<code>kernel/sched.c</code>中，由结构<code>rt_prio_array</code>表示。实时优先级数组使处理器中实时进程的每个优先级包含一个相应的队列，而这些队列包含了对应优先级上的可运行实时任务链表。优先级数组还有一个优先级位图，当需要查找当前系统内拥有最高优先级的可执行进程时，它可以帮助提高效率，<code>rt_prio_array</code>定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">re_prio_array</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    DECLARE_BITMAP(bitmap,MAX_RT_PRIO+<span class="number">1</span>);<span class="comment">/*优先级位图*/</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">queue</span>[<span class="title">MAX_RT_PRIO</span>];</span><span class="comment">/*优先级队列*/</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;优先级位图的实际类型为<code>unsigned long</code>长整型数组，数组的大小通过<code>BITS_TO_LONGS(bits)</code>来确定，默认的<code>MAX_RT_PRIO</code>值为100，因此需要使用5个长整型的数来表示。长整型数组中的每一位代表一个优先级。一开始，所有的位都被设置为0，当某个任务的状态变为可执行状态时，位图中相应的优先级位被设置为1.</p><p>&emsp;&emsp;比如一个优先级为2的实时任务变为可执行状态时，第2位就被置为1.这样，查找系统中最高的优先级就成了查找位图中第一个被设置的位。因为优先级格式是一个定值，所以查找时间恒定。此外，Linux对它支持的每个体系结构上都提供了对应的快速查找函数<code>sched_find_first_bit()</code>，以保证对位图的快速查找。</p><p>&emsp;&emsp;每个优先级数组还包含了一个叫做<code>struct list_head</code>的队列，每个队列上都包含对应处理器上相应优先级的全部可运行任务。</p><h2 id="二、实时调度的具体实现"><a href="#二、实时调度的具体实现" class="headerlink" title="二、实时调度的具体实现"></a>二、实时调度的具体实现</h2><p>&emsp;&emsp;实时调度类定义在<code>sched_rt.c</code>中，下面对实时调度类对应的每个函数进行简要的说明。</p><ol><li><p><code>enqueue_task_rt()</code></p><p>把实时进程插入到相应的运行队列尾部，并设置对应的优先级位图。</p></li><li><p><code>dequeue_task_rt()</code></p><p>记录实时任务的运行时间，把进程从相应的优先级队列中删除，检查相对应的优先级队列是否为空，如果为空，清除相应的优先级位图。</p></li><li><p><code>yidld_task_rt()</code></p><p>把实时进程从相应的优先级队列的头部插入到尾部。</p></li><li><p><code>check_preempt_curr_rt()</code></p><p>函数原型如下：</p><p><code>static void check_preempt_curr_rt(struct rq*rq,struct task_struct *p)</code></p><p>检查任务p的优先级是否大于当前运行队列中的优先级，如果是，调用<code>resched_task()</code>函数，设置当前进程需要被调度的标志。</p></li><li><p><code>pick_next_task_rt()</code></p><p>从优先级数组中选取一个优先级最高的进程。</p></li><li><p><code>put_prev_task_rt()</code></p><p>更新当前任务的运行时间信息。</p></li><li><p><code>set_curr_task_rt()</code></p><p>重新计算实时进程运行的开始时间。</p></li><li><p><code>task_tick_rt()</code></p><p>当时间节拍函数被调用时，函数执行流程如下：</p><p>首先更新当前进程的运行时间信息，然后再查看该进程是否是时间片轮转的实时进程，如果是，对实时进程的时间片<code>time_slice</code>减1，如果<code>time_slice</code>等于0，则设置进程的<code>time_slice</code>为默认时间片（100*Hz/1000),并把当前进程加入到所对应的优先级队列的尾部。</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、实时调度策略&quot;&gt;&lt;a href=&quot;#一、实时调度策略&quot; class=&quot;headerlink&quot; title=&quot;一、实时调度策略&quot;&gt;&lt;/a&gt;一、实时调度策略&lt;/h2&gt;&lt;p&gt;&amp;emsp;&amp;emsp;在Linux中，实时优先级范围从0到&lt;code&gt;MAX_RT_PRI
      
    
    </summary>
    
      <category term="Linux内核" scheme="http://wanqbin.xyz/categories/Linux%E5%86%85%E6%A0%B8/"/>
    
    
      <category term="操作系统" scheme="http://wanqbin.xyz/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="Linux进程调度" scheme="http://wanqbin.xyz/tags/Linux%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6/"/>
    
      <category term="实时调度策略" scheme="http://wanqbin.xyz/tags/%E5%AE%9E%E6%97%B6%E8%B0%83%E5%BA%A6%E7%AD%96%E7%95%A5/"/>
    
      <category term="实时调度算法" scheme="http://wanqbin.xyz/tags/%E5%AE%9E%E6%97%B6%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Linux进程调度——CFS调度算法</title>
    <link href="http://wanqbin.xyz/2019/08/08/Linux%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6%E2%80%94%E2%80%94CFS%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95/"/>
    <id>http://wanqbin.xyz/2019/08/08/Linux进程调度——CFS调度算法/</id>
    <published>2019-08-08T04:10:00.000Z</published>
    <updated>2019-08-08T08:09:30.732Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、进程优先级和虚拟运行时间"><a href="#一、进程优先级和虚拟运行时间" class="headerlink" title="一、进程优先级和虚拟运行时间"></a>一、进程优先级和虚拟运行时间</h2><p>&emsp;&emsp;对于普通的进程，CFS保留了系统的静态优先级<code>nice</code>值。其范围从-20到19，默认值为0，<code>nice</code>值越大，优先级越低。但是CFS不再使用动态优先级的概念，而是对每个进程进行加权，权值越大的进程获得CPU时间相对较多。<code>nice</code>值与权值之间存在着对应关系，<code>nice</code>每增加1，其对应权值就会降低25%；<code>nice</code>值每减小1，其对应的权值就会增大25%；<code>nice</code>值为0，对应的权值为1024.<code>nice</code>值和权值可以通过<code>prio_to_weight</code>数组进行转换。</p><p>&emsp;&emsp;CFS中每个任务的权值由<code>load_weight</code>结构来存储。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">load_weight</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> weight,inv_weight;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;其中，<code>weight</code>是任务的权值，<code>inv_weight</code>表示权值的倒置，在根据权值计算进程的虚拟运行时间时，需要使用该值。</p><p>&emsp;&emsp;<code>vruntime</code>(单位：纳秒)记录每个任务已经获得的CPU时间。理想的状态下，在任何时刻，系统中所有任务都应该得到相同额<code>vruntime</code>。但是由于同一时刻，系统中只能有一个任务（在单CPU的机器上）可以执行，因此每个任务的<code>vruntime</code>并不相同。<code>vruntime</code>是CFS选择下一个需要运行的任务的依据，是红黑树中每个实体的键值，系统从红黑树中选择<code>vruntime</code>最小值的节点（最左边的节点）作为下一个可运行的实体。</p><p>&emsp;&emsp;一个任务的<code>vruntime</code>的值与其权值<code>weight</code>有关，当一个新的任务产生时，<code>vruntime</code>可简单地通过下面的公司计算获得：</p><p><code>vruntime=sysctl_sched_latecy *NICE_TO_LOAD/weight</code></p><p>&emsp;&emsp;其中<code>sysctl_sched_latecy</code>是任务的一次可执行时间，默认为20ms；<code>NICE_TO_LOAD</code>是<code>nice</code>值为0的权值，即1024；<code>weight</code>为任务的权值。</p><p>&emsp;&emsp;任务在运行时，权值不同的任务执行相同的时间，其对应的<code>vruntime</code>的增量是不同的，<code>vruntime</code>的增量<code>delta_vruntime</code>可以使用下面的公式来计算。</p><p><code>delta_vruntime=exec_time*NICE_TO_LOAD/weight</code></p><p>通过给每个任务赋予一定的权值，我们就可以区别每个任务的重要性，权值越高的任务越重要，其<code>vruntime</code>增长得越慢，得到的执行时间就会越多。</p><h2 id="二、CFS调度算法的实现"><a href="#二、CFS调度算法的实现" class="headerlink" title="二、CFS调度算法的实现"></a>二、CFS调度算法的实现</h2><p>我们根据CFS调度类<code>fair_sched_class</code>所对应的每个函数进行简要的说明。</p><ol><li><p><code>enqueue_task_fair()</code>：</p><p>该函数首先获取任务的调度实体，检查该调度实体是否已经在运行队列上，如果是，函数退出；否则计算调度实体的<code>vruntime</code>，并把调度实体加入到相应的运行队列中，运行队列的<code>nr_running</code>加1。如果定义了组调度，则要查看对应的父调度实体是否在相应的运行队列上，如果不是，则更新调度实体的<code>vruntime</code>，并加入到相应的运行队列，运行队列的<code>nr_running</code>加1。重复以上过程，直到到达最上层的调度实体。</p></li><li><p><code>dequeue_task_fair()</code></p><p>当任务执行完毕，或者阻塞的时候，调用该函数，把相应的调度实体从CFS的运行队列中删除。该函数首先获取任务的调度实体，把它从相应的运行队列中删除，运行队列的<code>nr_running</code>减1；如果定义了组调度，则检查调度实体对应的运行队列是否为空，如果是，把父调度实体从相应的运行队列中删除，重复以上过程。</p></li><li><p><code>yield_task_fair()</code></p><p>这个函数的实现很简单，只是把当前正在运行的任务调度实体的<code>vruntime</code>设置为运行队列最左边调度实体（<code>vruntime</code>最小的调度实体）的<code>vruntime</code>加1.当我们希望当前任务让出CPU时，首先调用该函数，更新当前运行的调度实体的<code>vruntime</code>，然后调用<code>put_prev_task()</code>把当前的调度实体加入到队列中。</p></li><li><p><code>put_prev_task_fair()</code></p><p>把当前任务的调度实体放入相应的运行队列中。如果定义了组调度，把父调度实体也放入相应的运行队列，重复此过程，直到到达最上层的调度实体。</p></li><li><p><code>check_preempt_wakeup()</code></p><p>函数原型为：<code>static void check_preempt_wakeup(struct rq* rq,struct task_struct *p)</code>。该函数检查刚创建的任务或者从阻塞状态转为可执行的任务p，是否应该抢占当前正在运行的任务。即查看当前调度实体的<code>vruntime</code>加上环形粒度（<code>wakeup_granularity</code>)是否大于任务p的调度实体的<code>vruntime</code>。如果是，调用<code>resched_task()</code>函数，设置当前进程需要被调度的标志。</p></li><li><p><code>pick_next_task_fair()</code></p><p>从运行队列中找出下一个需要调度的调度实体（红黑树最左边的节点），并返回该调度实体对应的任务。如果定义了组调度，查看该调度实体是否有自己的运行队列，如果有，从其运行队列中找出下一个调度实体，重复此过程，直到最底层的调度实体，当调度实体不存在自己的运行队列时，该调度实体只包含一个任务。</p></li><li><p><code>set_curr_task_fair()</code></p><p>函数原型为：<code>static void set_curr_task_fair(struct rq*rq)</code>。该函数把CPU的运行队列<code>rq</code>的当前任务p，设置成任务p的调度实体所对应的CFS运行队列的当前任务。如果定义了组调度，重复此过程，直到到达最上层的调度实体。</p></li><li><p><code>task_tick_fair()</code></p><p>时间节拍函数，检查当前的调度实体的运行时间是否大于其一次应该具有的运行时间，如果是，调用<code>resched_task()</code>函数，设置当前进程需要被调度的标志。如果定义了组调度，重复此过程，直到到达最上层的调度实体。</p></li><li><p><code>task_new_fair()</code></p><p>计算新任务调度实体的<code>vruntime</code>，并把任务实体放入到对应的运行队列中，调用<code>resched_task()</code>函数，设置当前进程需要被调度的标志。如果我们指定子进程先运行，则检查新任务调度实体的<code>vruntime</code>是否小于当前正在运行的调度实体的<code>vruntime</code>，如果不是，交换这两个调度实体<code>vruntime</code>，使新任务调度实体的<code>vruntime</code>最小。</p></li></ol><p>&emsp;&emsp;在CFS调度算法的实现中，引入了重要的<code>sysctl()</code>函数来在运行时对调度程序进行调优，时间都是以纳秒为单位。</p><p>(1)<code>sysctl_sched_latecy</code></p><p>抢占潜伏时间，一个任务一次可运行的最长时间。这个值与时间片长度不一样，它表示一个时间长度的变量，默认为20ms。针对CPU密集型任务进行目标抢占延迟。</p><p>(2)<code>sysctl_sched_min_granularity</code></p><p>最小抢占粒度，默认为4ms。针对CPU密集型任务执行最低级别抢占粒度。</p><p>(3)<code>sysctl_nr_latecy</code></p><p>在一个抢占潜伏期内可调度的次数。其值等于<code>sysctl_sched_latecy/sysctl_sched_min_granlarity</code></p><p>(4)<code>sysctl_sched_child_runs_first</code></p><p>在创建新进程时，子进程是否先运行，设置为1，表示子进程向运行，设置为0，表示父进程先运行。</p><p>(5)<code>sysctl_sched_batch_wakeup_granularity</code></p><p>针对<code>SCHED_BATCH</code>的唤醒粒度，默认为10ms</p><p>(6)<code>sysctl_sched_wakeup_granularity</code></p><p>针对<code>SCHED_OTHER</code>的唤醒粒度，默认为10ms。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、进程优先级和虚拟运行时间&quot;&gt;&lt;a href=&quot;#一、进程优先级和虚拟运行时间&quot; class=&quot;headerlink&quot; title=&quot;一、进程优先级和虚拟运行时间&quot;&gt;&lt;/a&gt;一、进程优先级和虚拟运行时间&lt;/h2&gt;&lt;p&gt;&amp;emsp;&amp;emsp;对于普通的进程，CF
      
    
    </summary>
    
      <category term="Linux内核" scheme="http://wanqbin.xyz/categories/Linux%E5%86%85%E6%A0%B8/"/>
    
    
      <category term="操作系统" scheme="http://wanqbin.xyz/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="Linux进程调度" scheme="http://wanqbin.xyz/tags/Linux%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6/"/>
    
      <category term="CFS调度算法" scheme="http://wanqbin.xyz/tags/CFS%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Linux进程调度——模块化调度和组调度</title>
    <link href="http://wanqbin.xyz/2019/08/08/inux%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6%E2%80%94%E2%80%94%E6%A8%A1%E5%9D%97%E5%8C%96%E8%B0%83%E5%BA%A6%E5%92%8C%E7%BB%84%E8%B0%83%E5%BA%A6/"/>
    <id>http://wanqbin.xyz/2019/08/08/inux进程调度——模块化调度和组调度/</id>
    <published>2019-08-08T03:09:00.000Z</published>
    <updated>2019-08-08T08:11:35.050Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、模块化调度"><a href="#一、模块化调度" class="headerlink" title="一、模块化调度"></a>一、模块化调度</h2><p>&emsp;&emsp;CFS提供了模块化调度，使得各种不同的调度算法都可以作为一个模块注册到该管理器中。不同的进程可以选择不同的调度模块。为了实现模块化调度，引入了称为“调度类”的概念。</p><p>&emsp;&emsp;调度类类似于一个模块链，封装了关于调度算法的信息，协助内核调度程序工作，每个调度算法模块需要实现由调度类建议的一组函数。CFS实现了两个调度算法模块，CFS算法模块(<code>sched_fair.c</code>)和实时调度模块(<code>sched_re.c</code>)。对应实时进程，将使用实时调度模块，对应普通进程则使用CFS算法。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sched_class</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">sched_class</span> *<span class="title">next</span>;</span><span class="comment">/*指向下一个调度类*/</span></span><br><span class="line">    <span class="keyword">void</span>(*enqueue_task)(struct rq *rq,struct task_struct *p,<span class="keyword">int</span> wakeup);</span><br><span class="line">    <span class="keyword">void</span>(*dequeue_task)(struct rq *rq,struct task_struct *p,<span class="keyword">int</span> sleep);</span><br><span class="line">    <span class="keyword">void</span>(*yield_task)(struct rq *rq);</span><br><span class="line">    <span class="keyword">void</span>(*check_preempt_curr)(struct rq *rq,struct task_struct *p);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *(*<span class="title">pick_next_task</span>)(<span class="title">struct</span> <span class="title">rq</span> *<span class="title">rq</span>);</span></span><br><span class="line">    <span class="keyword">void</span>(*put_prev_task)(struct rq *rq,struct task_struct *p);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_SMP</span></span><br><span class="line">    <span class="function"><span class="keyword">unsigned</span> <span class="title">long</span><span class="params">(*load_balance)</span><span class="params">(struct rq *this_rq,<span class="keyword">int</span> this_cpu,</span></span></span><br><span class="line"><span class="function"><span class="params">                                struct rq *busiest,<span class="keyword">unsigned</span> <span class="keyword">long</span> max_load_move,</span></span></span><br><span class="line"><span class="function"><span class="params">                                struct sched_domain *sd,<span class="keyword">enum</span> cpu_idle_type idle,</span></span></span><br><span class="line"><span class="function"><span class="params">                                <span class="keyword">int</span> *all_pinned,<span class="keyword">int</span> *this_best_prio)</span></span>;</span><br><span class="line">    <span class="keyword">int</span>(*move_one_task)(struct rq * this_rq,<span class="keyword">int</span> this_cpu,</span><br><span class="line">                       struct rq *busiest,struct sched_domain *sd,</span><br><span class="line">                       <span class="keyword">enum</span> cpu_idle_type idle);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">void</span>(*set_curr_task)(struct rq *rq);</span><br><span class="line">    <span class="keyword">void</span>(*task_tick)(struct rq *rq,struct task_struct *p);</span><br><span class="line">    <span class="keyword">void</span>(*task_new)(struct rq *rq,struct  task_struct *p);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ol><li><code>enqueue_task</code>:当某个任务进入可运行状态时，该函数将得到调用。它将调度实体（进程）放入相应的运行队列中，并对运行队列成员变量<code>nr_running</code>加1</li><li><code>dequeue_task</code>：当某个任务退出运行状态时调用该函数，它将从相应的运行队列中去掉对应的调度实体，并从<code>nr_running</code>变量中减1</li><li><code>yield_task</code>：在<code>compat_yield_syscttl</code>选项关闭的情况下，该函数实际上执行先出队后入队，这样就将相应的调度实体放在运行队列的最后。（如果是CFS运行队列，则将调度实体放在红黑树的最右端）</li><li><code>check_preempt_curr</code>：该函数将检查当前运行的任务是否被抢占。在实际抢占正在运行的任务之前，CFS调度程序模块将执行公平性测试。这将驱动唤醒（wakeup）抢占。</li><li><code>pick_next_task</code>：该函数选择接下来要运行的最合适的进程。</li><li><code>put_prev_task</code>：当一个进程不再运行时，调用该函数通知相应的调度模块。</li><li><code>load_balance</code>：每个调度程序模块实现两个函数，<code>load_balance_start()</code>和<code>load_balance_next()</code>，使用者两个函数实现一个迭代器，在调度模块的<code>load_balance</code>例程中调用。内核调度程序使用这种方法实现由调度模块管理的进程的负载平衡。</li><li><code>set_curr_task</code>：当任务修改其调度类或修改其任务组时，将调用这个函数。</li><li><code>task_tick</code>：该函数通常为时间节拍函数；它可能引起进程切换。这将驱动运行时（running）抢占。</li><li><code>task_new</code>：内核调度程序为调度模块提供了管理新任务启动的机会。CFS调度模块使用它进行组调度，而用于实时任务的调度模块不会使用这个函数。</li></ol><h2 id="二、组调度"><a href="#二、组调度" class="headerlink" title="二、组调度"></a>二、组调度</h2><p>&emsp;&emsp;通常情况下，调度器都是针对单个任务进行调度，为每个任务提供公平的CPU时间。但是在有些时候，我们需要为任务组提供公平的CPU时间考虑一个两用户的例子：用户A和用户B在一台机器上运行任务。用户A只有两个任务正在运行，而用户B正在运行48个任务。组调度使CFS能够对用户A和用户B进行公平调度，而不是对系统运行50个任务进行公平调度。每个用户拥有50%的CPU使用。用户B使用自己50%的CPU分配他的48个任务，而不会占用属于用户A的另外50%的CPU分配。</p><p>&emsp;&emsp;为了实现组调度，引入了一个称为“调度实体”的概念，用以指代被调度的对象，这个对象不一定是一个进程。调度实体保持了每个实体的调度信息，并将它们封装在<code>sched_entity</code>结构中，但它并没有改变CFS调度的工作方式。</p><p>&emsp;&emsp;调度实体是一个层次结构，每个调度实体代表一组进程，每个调度实体内部有一个自己的运行队列<code>my_q</code>。当我们定义了组调度时，调度实体内还存在一个指向上一层的实体<code>parent</code>指针和一个该实体所在的运行队列<code>cfs_rq</code>。缺省地，调度实体中只存在一个进程，且都在顶级层次结构中。</p><p>&emsp;&emsp;但当调度器选择下一个要运行的任务的时候，它首先检查所有顶级调度实体，取出最应获取CPU的实体，如果这个实体是一个高层调度实体，那么调度器就会检查调度实体中运行队列，并重复这一过程，直到达到层次结构的最底层，找到一个可执行的进程。在进程运行过程中，同样会收集一些运行时信息，这些信息同时会向上层调度实体传播，从而在每个级别上都正确度量其占用CPU的时间。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sched_entity</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">load_weight</span> <span class="title">load</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> <span class="title">run_node</span>;</span><span class="comment">/*调度实体上的运行节点*/</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> on_rq;<span class="comment">/*该调度实体上是否在运行队列上*/</span></span><br><span class="line">    u64 exec_strart;<span class="comment">/*任务开始运行的时间*/</span></span><br><span class="line">    u64 sum_exec_runtime;<span class="comment">/*任务总的运行时间*/</span></span><br><span class="line">    u64 vruntime;<span class="comment">/*应当占用CPU的时间*/</span></span><br><span class="line">    u64 prev_sum_exec_runtime;<span class="comment">/*任务最近一次执行前的sum_exec_runtime*/</span></span><br><span class="line">    </span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_FAIR_GROUP_SCHED</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sched_entity</span> *<span class="title">parent</span>;</span><span class="comment">/*指向该调度实体的父节点*/</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">cfs_rq</span> *<span class="title">cfs_rq</span>;</span><span class="comment">/*调度实体所在的CFS运行队列*/</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">cfs_rq</span> *<span class="title">my_q</span>;</span><span class="comment">/*调度实体所拥有的CFS运行队列*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;从调度实体可以看出，当我们定义了<code>CONFIG_FAIR_GROUP_SCHED</code>时，就开启了组调度。到目前为止，有两种策略对任务进行分组。</p><p>（1）基于用户id的分组策略（<code>CONFIG_FAIR_GROUP_SCHED</code>)</p><p>在这种分组策略中，根据任务所属的用户，对任务进行分组。</p><p>（2）基于cgroup的伪文件系统（<code>CONFIG_FAIR_CGROUP_SCHED</code>)</p><p>在这种分组策略中，管理员可以使用<code>cgroup</code>伪文件系统任意地创建任务组。调度器只能采用这两种策略中的一个，不能全部采用。Linux内核使用<code>task group</code>结构描述与任务组相关的信息。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_group</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_FAIR_CGROUP_SCHED</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">cgroup_subsys_state</span> <span class="title">css</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sched_entity</span> **<span class="title">se</span>;</span><span class="comment">/*任务组在每个CPU上所包含的调度实体*/</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">cfs_rq</span> **<span class="title">cfs_rq</span>;</span><span class="comment">/*任务组在每个CPU上所用的运行队列*/</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> shares;</span><br><span class="line">    <span class="keyword">spinlock_t</span> lock;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rcu</span>)<span class="title">head</span> <span class="title">rcu</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、模块化调度&quot;&gt;&lt;a href=&quot;#一、模块化调度&quot; class=&quot;headerlink&quot; title=&quot;一、模块化调度&quot;&gt;&lt;/a&gt;一、模块化调度&lt;/h2&gt;&lt;p&gt;&amp;emsp;&amp;emsp;CFS提供了模块化调度，使得各种不同的调度算法都可以作为一个模块注册到该管理
      
    
    </summary>
    
      <category term="Linux内核" scheme="http://wanqbin.xyz/categories/Linux%E5%86%85%E6%A0%B8/"/>
    
    
      <category term="Linux内核" scheme="http://wanqbin.xyz/tags/Linux%E5%86%85%E6%A0%B8/"/>
    
      <category term="操作系统" scheme="http://wanqbin.xyz/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="进程调度" scheme="http://wanqbin.xyz/tags/%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6/"/>
    
      <category term="模块化调度" scheme="http://wanqbin.xyz/tags/%E6%A8%A1%E5%9D%97%E5%8C%96%E8%B0%83%E5%BA%A6/"/>
    
      <category term="组调度" scheme="http://wanqbin.xyz/tags/%E7%BB%84%E8%B0%83%E5%BA%A6/"/>
    
  </entry>
  
  <entry>
    <title>Linux进程调度——内核调度概述</title>
    <link href="http://wanqbin.xyz/2019/08/07/Linux%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6%E2%80%94%E2%80%94%E5%86%85%E6%A0%B8%E8%B0%83%E5%BA%A6%E6%A6%82%E8%BF%B0/"/>
    <id>http://wanqbin.xyz/2019/08/07/Linux进程调度——内核调度概述/</id>
    <published>2019-08-07T15:31:00.000Z</published>
    <updated>2019-08-07T15:32:17.962Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、调度原理"><a href="#一、调度原理" class="headerlink" title="一、调度原理"></a>一、调度原理</h2><p>&emsp;&emsp;调度程序是内核的组成部分，它负责选择下一个要运行的进程。进程调度器可以看做是为处于就绪态的所有进程分配有限的处理器时间资源的内核子系统。在多任务的操作系统中，进程调度是一个全局性的关键的问题，它对系统的总体设计、系统的实现、功能设置以及各方面的性能都有着决定性的影响，是多任务操作系统的基础，只有通过调度程序的合理调度，系统资源才能最大限度地发挥作用，多任务才会有并发执行的效果。</p><p>&emsp;&emsp;调度程序的主要目标是：最大限度地利用处理器时间，同时要保证进程之间的公平性，使系统中的所有进程都有机会执行。为了满足这些目标，在设计进程调度程序时，应该考虑以下三个方面：</p><ul><li>调度时机：什么时候，什么情况下进行程序调度</li><li>调度策略：使用什么样的策略来选择下一个进入运行的进程</li><li>调度的方式：是抢占式还是非抢占式。当由调度程序来决定什么时候停止一个进程的执行，以便让其他程序能够得到执行机会时，这种强制挂起进程的动作称为抢占式。</li></ul><p>&emsp;进程调度器的设计，对系统的复杂性有着极大的影响，常常会由于调度器实现过于复杂而需要在功能与性能方面做出必要的权衡和让步。一个好的操作系统调度算法要兼顾三种不同应用的需要。</p><ol><li>交互式进程:在这种应用中，着重于系统的响应速度，使共用一个系统的各个用户都能感觉到自己是在独占地使用一个系统。特别是，当系统中有大量进程共存时，需要能保证每个交互式进程都有可接受的响应速度而使每个用户感觉不到明显的延时。</li><li>批处理进程：批处理进程往往是作为“后台作业”运行的，所以对响应速度并无要求，但是完成一个作业所要的时间仍是一个重要的因素，主要考虑“平均速度”。</li><li>实时进程：这是时间性最强的一类进程，不但要考虑进程执行的平均速度，还要考虑“即时速度”；不但要考虑响应速度，还要考虑有关程序能否在规定时间内执行完毕。</li></ol><h2 id="二、Linux调度器的发展"><a href="#二、Linux调度器的发展" class="headerlink" title="二、Linux调度器的发展"></a>二、Linux调度器的发展</h2><ol><li><h3 id="Linux2-4内核的调度器"><a href="#Linux2-4内核的调度器" class="headerlink" title="Linux2.4内核的调度器"></a>Linux2.4内核的调度器</h3><p>&emsp;&emsp;Linux2.4中使用的调度器采用基于优先级的设计。该调度器的<code>pick_next</code>算法非常简单：对运行队列<code>runqueue</code>中所有进程优先级依次进行比较，选择最高优先级的进程作为下一个被调度的进程。</p><p>&emsp;&emsp;每个进程被创建时都被赋予一个时间片。时钟中断则递减当前运行进程的时间片，当进程的时间片被用完时，它必须等待重新赋予时间片才能有机会运行。Linux2.4调度器保证只有当所有处于<code>RUNNING</code>状态的进程的时间片都被用完之后，才对所有进程重新分配时间片。这种设计保证了每个进程都有机会得到执行。</p><p>&emsp;&emsp;对于实时进程，调度器将实时进程的优先级静态设定，而且始终大于普通进程的优先级。因此只有当<code>runqueue</code>队列中没有实时进程存在的情况下，普通进程才能够得到调度，获得处理器时间。在Linux内核，实时进程采用两种调度策略：<code>SCHED_FIFO</code>和<code>SCHED_RR</code>。FIFO调度采用先进先出的策略，对于所有相同优先级的进程，最先进入<code>runqueue</code>队列的进程总能优先获得调度；<code>SCHED_RR</code>调度采用更加公平的轮转策略，使得相同优先级的实时进程能够轮流得到执行。</p><p>&emsp;&emsp;对于普通进程，调度器倾向于提高交互式进程的优先级，因为它们需要快速地用户响应。普通进程的优先级主要由进程描述符中的<code>counter</code>字段决定。进程被创建时子进程的<code>counter</code>值为父进程<code>counter</code>值的一半，这样保证了任何进程不能依靠不断的调用<code>fork()</code>函数创建子进程从而获得更多的执行机会。Linux2.4调度器在提高交互式进程的优先级时，做了如下工作：当所有<code>RUNNING</code>状态进程的时间片被用完之后，将重新计算所有进程的<code>counter</code>值，所有进程不仅包括<code>RUNNING</code>进程，也包括处于睡眠状态的进程。处于睡眠状态的进程的<code>counter</code>本来就没有用完，在重新计算时，它们的<code>counter</code>值会加上这些原来未用完的部分，从而提高了它们的优先级。交互式进程经常因为等待用户输入而处于睡眠状态，当它们重新被唤醒并进入<code>runqueue</code>队列时，就会优于其他进程而获得CPU。从用户的角度来看，交互式进程的响应速度就提高了。</p><p>&emsp;&emsp;这种调度的主要不足在于：</p><p>（1）可扩展性不好：调度器选择进程时需要遍历整个<code>runqueue</code>队列，从中选出最佳调度进程，因此该算法的执行时间与进程数成正比。另外每次重新计算<code>counter</code>所花费的时间也会随着系统中进程数的增加而线性增长，当进程数很大时，更新<code>counter</code>操作的代价会非常高，导致系统整体的性能下降。</p><p>（2）高负载系统上的调度性能比较低：Linux2.4的调度器预分配给每个进程的时间片比较大，因此在高负载的服务器上，该调度器的效率比较低，因为平均每个进程的等待时间与该时间片的大小成正比。</p><p>（3）交互式进程的优化并不完善：Linux2.4识别交互式进程的原理基于如下假设：即交互式进程比批处理进程更频繁地处于阻塞状态。然而现实情况往往并非如此，有些批处理进程虽然没有用户交互，但是也会频繁地进行I/O操作，比如一个数据库引擎在处理查询时会经常地进行磁盘I/O，虽然它们并不需要快速的用户响应，还是被提高了优先级。当系统中这类进程的负载较重时，会影响真正的交互式进程的响应时间。</p><p>（4）对实时进程的支持不够：Linux2.4内核是非抢占的，当进程处于内核态时不会发生抢占，这对于真正的实时应用是不能接受的。</p></li><li><h3 id="Linux2-6内核的O-1-调度器"><a href="#Linux2-6内核的O-1-调度器" class="headerlink" title="Linux2.6内核的O(1)调度器"></a>Linux2.6内核的O(1)调度器</h3><p>&emsp;&emsp;O(1)调度算法所花费的时间为常数，与当前系统中的进程个数无关。此外Linux2.6内核支持内核抢占，因此更好地支持了实时进程。相比于前任，O(1)调度器还更好地区分了交互式进程和批处理式进程。</p><p>&emsp;&emsp;Linux2.6内核也支持三种调度策略：<code>SCHED_NORMAL</code>、<code>SCHED_FIFO</code>、<code>SHCED_RR</code>。其中，<code>SCHED_FIFO</code>和<code>SCHED_RR</code>用于实时进程，而<code>SCHED_NORMAL</code>用于普通进程。O(1)调度器在两个方面修改了Linux2.4调度器，一是进程优先级的计算方法，二是<code>pick_next</code>算法。</p><p>&emsp;&emsp;（1）优先级计算方法</p><p>&emsp;&emsp;普通进程优先级是动态计算的，计算公式中包含了静态优先级。一般来讲，静态优先级越高，进程所能分配到的时间片越长，用户可通过<code>nice</code>系统调用修改进程的静态优先级。动态优先级由下面的公式计算得出。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dynamic_priority=max(<span class="number">100</span>,min(<span class="keyword">static</span> prority-bonus+<span class="number">5139</span>))</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;其中，<code>bouns</code>取决于进程的平均睡眠时间。平均睡眠时间越长，其<code>bouns</code>越大，从而得到更高的优先级。</p><p>&emsp;&emsp;实时进程的优先级由系统调用<code>sys_sched_setschedule()</code>设置。该值不会动态修改，而且总是比普通进程的优先级高。在进程描述符中用<code>rt_prioriity</code>域表示。</p><p>&emsp;&emsp;(2)<code>pick_next</code>算法</p><p>&emsp;&emsp;普通进程的调度选择算法基于进程优先级，拥有最高优先级的进程被调度器选中。在Linux2.4内核中，时间片<code>counter</code>同时也表示了一个进程的优先级。Linux2.6中的时间片用任务描述符中的<code>time_slice</code>域表示，而优先级用<code>prio(普通进程)</code>或者<code>rt_priority（实时进程）</code>表示。</p><p>&emsp;&emsp;调度器为每个CPU维护了两个进程队列数组：<code>active</code>数组（时间片未耗尽的进程队列）和<code>expire</code>数组（时间片以耗尽的进程队列）。数组中的元素保存某一优先级的进程队列指针。系统一共有140个不同的优先级，因此这两个数组大小都是140。当需要选择最高优先级进程时，Linux2.6内核的调度器不用遍历整个<code>runqueue</code>，而是直接从<code>active</code>数组中选择当前最高优先级队列中的第一个进程。</p><p>&emsp;&emsp;为了实现上述算法，<code>active</code>数组维护了一个<code>bitmap</code>位图，当某个优先级别上有进程被插入列表时，相应的比特位就被置位。<code>sched_find_first_bit()</code>函数查询位图bitmap，返回当前被置位的最高优先级的数组下标。</p><p>&emsp;&emsp;为了二提高交互式进程的响应时间，O(1)调度器不仅动态地提高该类进程的优先级，还采用以下方法。</p><p>&emsp;&emsp;在每次时钟<code>tick</code>中断时，进程的时间片(time_slice)被减1。当time_slice为0时，调度器判断当前进程的类型，如果是交互式进程或者实时进程，则重置时间片并重新插入<code>active</code>数组。如果不是交互式进程则从<code>active</code>数组中移到<code>expired</code>数组。这样实时进程和交互式进程就总能获得CPU。然而这些进程不能始终留在<code>active</code>数组，否则进入<code>expire</code>数组的进程就会产生饥饿现象。当进程已经占用CPU的时间超过一个固定值后，即使它是交互式进程或实时进程也会被移到<code>expire</code>数组中。</p><p>&emsp;&emsp;当<code>active</code>数组中的所有进程都被移到<code>expire</code>数组中后，调度器就会交换<code>active</code>数组和<code>expire</code>数组。当进程被调度器移入<code>active</code>数组中时，调度器会重置其时间片，因此新的<code>active</code>数组又恢复了初始情况，而<code>expire</code>数组为空，从而开始新的一轮调度。</p><p>&emsp;&emsp;这种调度器的主要不足是：</p><p>&emsp;&emsp;O(1)调度器群交互式进程和批处理进程的算法与以前虽大有改进，但是仍然在很多情况下会失效。有一些著名的程序总能让该调度器性能下降，导致交互式进程反应缓慢。</p></li></ol><h2 id="三、CFS调度器"><a href="#三、CFS调度器" class="headerlink" title="三、CFS调度器"></a>三、CFS调度器</h2><p>&emsp;&emsp;CFS(Completely Fair Scheduler)即“完全公平调度”，是一个新的进程调度器。</p><p>&emsp;&emsp;CFS的设计思想可以用一句话概括：CFS建立了一个调度模型，在实际的硬件上模拟出一个理想的、精确的多任务CPU。理想的多任务CPU即是要发挥实际CPU100%的能量，在CPU上并行地执行每个任务，且任务的执行速度相同，即1/nr_running。例如，假如系统中有两个任务在执行，则每个任务并行化地占有50%的资源，但是在实际的硬件条件下，每时每刻都只能有一个任务运行，为此引入了虚拟运行时间（vruntime)。一个任务的虚拟运行时间用来表示任务已经获得的CPU时间。CFS根据vruntime的值来选择下一个需要运行的任务。</p><p>&emsp;&emsp;与O(1)调度器相比，具有以下特点：</p><p>（1）CFS的核心数据结构不再基于队列数组，而是红黑树。树里面包含了所有的处理RUNNING状态的进程，而在最左边的进程就是下一个被调度的进程。</p><p>（2）CFS彻底以时间和系统负载为参照，完全抛弃原有调度方案中的双优先级数组的概念，使用红黑树来代替运行队列数组，vruntime作为红黑树中节点的键值。</p><p>（3）对于普通的进程，不再进一步区分是I/O消耗型进程还是处理器消耗型进程。</p><p>（4）不再使用时间片的概念，也不使用<code>jiffies</code>或者其他的Hz，而使用单位为纳秒的时间长度变量。</p><p>（5）引入了模块化调度：调度实体和调度类。</p><p>（6）对SMP负载平衡进行了重构，使用调度模块的迭代器。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、调度原理&quot;&gt;&lt;a href=&quot;#一、调度原理&quot; class=&quot;headerlink&quot; title=&quot;一、调度原理&quot;&gt;&lt;/a&gt;一、调度原理&lt;/h2&gt;&lt;p&gt;&amp;emsp;&amp;emsp;调度程序是内核的组成部分，它负责选择下一个要运行的进程。进程调度器可以看做是为处于就
      
    
    </summary>
    
      <category term="Linux内核" scheme="http://wanqbin.xyz/categories/Linux%E5%86%85%E6%A0%B8/"/>
    
    
      <category term="操作系统" scheme="http://wanqbin.xyz/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="Linux进程调度" scheme="http://wanqbin.xyz/tags/Linux%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6/"/>
    
      <category term="内核调度器" scheme="http://wanqbin.xyz/tags/%E5%86%85%E6%A0%B8%E8%B0%83%E5%BA%A6%E5%99%A8/"/>
    
      <category term="内核调度算法" scheme="http://wanqbin.xyz/tags/%E5%86%85%E6%A0%B8%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>vim的使用</title>
    <link href="http://wanqbin.xyz/2019/08/07/vim%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>http://wanqbin.xyz/2019/08/07/vim的使用/</id>
    <published>2019-08-07T12:24:00.000Z</published>
    <updated>2019-08-07T13:51:06.335Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、vim"><a href="#一、vim" class="headerlink" title="一、vim"></a>一、vim</h2><p><img src="/2019/08/07/vim的使用/1.PNG" alt="vim"></p><p>&emsp;&emsp;vim是从vi发展出来的一个文本编辑器。代码补全、编译及错误跳转等方便编程的功能特别丰富，在程序员中被广泛使用，和Emacs并列称为类Unix系统用户最喜欢的文本编辑器。</p><p>&emsp;vim的设计理念是命令的组合。用户学习了各种各样的文本间移动/跳转的命令和其他的普通模式的编辑命令，并且能够灵活使用的话，能够比那些没有模式的编辑器是更加高效地进行文本编辑。同时vim与很多快捷键设置和正则表达式类似，可以辅助记忆，并且vim针对程序员做了优化。</p><h2 id="二、vim的使用"><a href="#二、vim的使用" class="headerlink" title="二、vim的使用"></a>二、vim的使用</h2><ol><li><h4 id="光标移动"><a href="#光标移动" class="headerlink" title="光标移动"></a>光标移动</h4></li></ol><div class="table-container"><table><thead><tr><th>按键</th><th>动作</th></tr></thead><tbody><tr><td>k</td><td>上</td></tr><tr><td>j</td><td>下</td></tr><tr><td>h</td><td>左</td></tr><tr><td>l</td><td>右</td></tr><tr><td>0</td><td>到行首</td></tr><tr><td>shift+4（即$)</td><td>到行尾</td></tr><tr><td>gg</td><td>移动到文件头</td></tr><tr><td>G</td><td>移动到文件尾部</td></tr><tr><td>nG（n为行数）</td><td>移动到某一行</td></tr></tbody></table></div><ol><li><h4 id="删除内容"><a href="#删除内容" class="headerlink" title="删除内容"></a>删除内容</h4></li></ol><div class="table-container"><table><thead><tr><th>按键</th><th>动作</th></tr></thead><tbody><tr><td>x</td><td>删除光标所在字母</td></tr><tr><td>u</td><td>撤销</td></tr><tr><td>X</td><td>删除光标前面的内容</td></tr><tr><td>dw</td><td>从光标删除一个单词</td></tr><tr><td>d0</td><td>删除光标到行首</td></tr><tr><td>D</td><td>删除光标到行尾</td></tr><tr><td>dd</td><td>删除光标所在行</td></tr><tr><td>ndd</td><td>删除光标所在行开始n行</td></tr></tbody></table></div><ol><li><h4 id="复制粘贴与可视模式"><a href="#复制粘贴与可视模式" class="headerlink" title="复制粘贴与可视模式"></a>复制粘贴与可视模式</h4></li></ol><div class="table-container"><table><thead><tr><th>按键</th><th>动作</th></tr></thead><tbody><tr><td>yy</td><td>复制一行内容</td></tr><tr><td>dd</td><td>剪切一方内容</td></tr><tr><td>nyy</td><td>复制n行内容</td></tr><tr><td>p</td><td>粘贴到当前行</td></tr><tr><td>P</td><td>粘贴到上一行</td></tr><tr><td>r</td><td>替换一个字母（输入r之后，再输入一个字母）</td></tr></tbody></table></div><p>   可视模式：</p><ul><li><p>按v进入可视模式</p></li><li><p>移动光标选中内容</p></li><li><p>按y复制内容</p></li><li><p>移动光标到目的地</p></li><li><p>按p/P将内容粘贴</p></li></ul><ol><li><h4 id="查找-amp-格式调整-amp-查看"><a href="#查找-amp-格式调整-amp-查看" class="headerlink" title="查找&amp;格式调整&amp;查看"></a>查找&amp;格式调整&amp;查看</h4><p>内容查找：</p><ul><li>/要查找的字符或字符串</li><li>n/N进行遍历，向前或向后</li><li>?要查找的字符或字符串</li><li>光标移动到字符串上，按#也可以查找该字符串</li></ul><p>格式调整：</p><ul><li>gg=G 文件整体调整格式</li><li><code>&gt;&gt;</code>当前光标所在行右移一个Tab</li><li><code>&lt;&lt;</code>光标所在行左移一个Tab</li><li>n<code>&gt;&gt;</code>光标开始n行左移一个Tab</li></ul></li><li><h4 id="从命令模式到编辑模式"><a href="#从命令模式到编辑模式" class="headerlink" title="从命令模式到编辑模式"></a>从命令模式到编辑模式</h4><p>命令模式变为编辑模式：</p><ul><li><code>i</code>在光标前插入</li><li><code>a</code>在光标后插入</li><li><code>I</code>在行首插入</li><li><code>A</code>在行尾插入</li><li><code>o/O</code>在下一行或上一行插入</li><li><code>s</code>删除当前字母，进入插入模式</li><li><code>S</code>删除当前行，进入插入模式</li></ul></li><li><h4 id="末行查找替换与保存退出"><a href="#末行查找替换与保存退出" class="headerlink" title="末行查找替换与保存退出"></a>末行查找替换与保存退出</h4><p>末行模式：</p><ul><li><code>:s/被替换内容/替换内容</code>只替换当前行第一个匹配的“被替换内容”为“替换内容”</li><li><code>:s/被替换内容/替换内容/g</code>替换当前行所有的“被替换类同”为“替换内容”</li><li><code>:%s/被替换内容/替换内容</code>替换所有行的第一个匹配“被替换内容”为“替换内容”</li><li><code>:%s/被替换内容/替换内容/g</code>替换文件内所有的“被替换内容”为“替换内容”</li></ul><p>保存退出：</p><ul><li><code>wq</code>保存退出</li><li><code>:w</code>只保存</li><li><code>:q</code>只退出，文件不能修改</li><li><code>:q!</code>强退，不保存</li><li><code>:x</code>保存退出</li><li><code>ZZ</code>保存退出（命令模式下）</li></ul></li><li><h4 id="分屏"><a href="#分屏" class="headerlink" title="分屏"></a>分屏</h4><p><code>:sp filename</code>横分</p><p><code>:vsp filename</code>竖分</p><p><img src="/2019/08/07/vim的使用/2.PNG" alt="分屏——横分"></p><p><img src="/2019/08/07/vim的使用/3.PNG" alt="分屏——竖分"></p><p>退出：<br><code>:q</code>退出一个文件</p><p><code>:qall</code>全部文件退出</p><p><code>:wqall</code>全部保存退出</p><p>切换屏幕：</p><p>​    Ctrl+w+w</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、vim&quot;&gt;&lt;a href=&quot;#一、vim&quot; class=&quot;headerlink&quot; title=&quot;一、vim&quot;&gt;&lt;/a&gt;一、vim&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;/2019/08/07/vim的使用/1.PNG&quot; alt=&quot;vim&quot;&gt;&lt;/p&gt;
&lt;p&gt;&amp;ems
      
    
    </summary>
    
      <category term="Linux命令" scheme="http://wanqbin.xyz/categories/Linux%E5%91%BD%E4%BB%A4/"/>
    
    
      <category term="Ubuntu" scheme="http://wanqbin.xyz/tags/Ubuntu/"/>
    
      <category term="Linux" scheme="http://wanqbin.xyz/tags/Linux/"/>
    
      <category term="Vim" scheme="http://wanqbin.xyz/tags/Vim/"/>
    
  </entry>
  
  <entry>
    <title>Linux压缩解压命令及其他命令</title>
    <link href="http://wanqbin.xyz/2019/08/07/Linux%E5%8E%8B%E7%BC%A9%E8%A7%A3%E5%8E%8B%E5%91%BD%E4%BB%A4%E5%8F%8A%E5%85%B6%E4%BB%96%E5%91%BD%E4%BB%A4/"/>
    <id>http://wanqbin.xyz/2019/08/07/Linux压缩解压命令及其他命令/</id>
    <published>2019-08-07T11:43:00.000Z</published>
    <updated>2019-08-07T12:11:04.076Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、压缩解压命令"><a href="#一、压缩解压命令" class="headerlink" title="一、压缩解压命令"></a>一、压缩解压命令</h2><ol><li><h3 id="压缩解压命令：gzip"><a href="#压缩解压命令：gzip" class="headerlink" title="压缩解压命令：gzip"></a>压缩解压命令：<code>gzip</code></h3><ul><li><p>命令名称：gzip</p></li><li><p>命令英文原意：GUN zip</p></li><li><p>命令所在路径：/bin/gzip</p></li><li><p>执行权限：所有用户</p></li><li><p>语法：gzip [文件]</p></li><li><p>功能描述：压缩文件</p></li><li><p>压缩后文件格式：.gz</p></li><li><p>注意：</p><ul><li><p>gizp只能压缩文件，不能压缩目录</p></li><li><p>压缩之后不保留原文件</p></li></ul></li></ul><p><img src="/2019/08/07/Linux压缩解压命令及其他命令/1.PNG" alt="压缩解压命令"></p></li><li><h3 id="压缩解压命令：gunzip"><a href="#压缩解压命令：gunzip" class="headerlink" title="压缩解压命令：gunzip"></a>压缩解压命令：<code>gunzip</code></h3><ul><li><p>命令名称：gunzip</p></li><li><p>命令英文原意：GUN unzip</p></li><li><p>命令所在路径：/bin/gunzip</p></li><li><p>执行权限：所有用户</p></li><li><p>语法： gunzip [压缩文件]</p></li><li><p>功能描述： 解压缩.gz的压缩文件</p></li></ul><p><img src="/2019/08/07/Linux压缩解压命令及其他命令/2.PNG" alt="压缩解压命令"></p></li><li><h3 id="压缩解压命令：tar"><a href="#压缩解压命令：tar" class="headerlink" title="压缩解压命令：tar"></a>压缩解压命令：<code>tar</code></h3><ul><li><p>命令名称：tar</p></li><li><p>命令所在路径：/bin/tar</p></li><li><p>执行权限：所有用户</p></li><li><p>语法：tar 选项[-zcf] [压缩后文件名] [目录]</p><p>-c 打包</p><p>-v 显示详细信息</p><p>-f 指定文件名</p><p>-z 打包同时压缩</p></li><li><p>功能描述：打包目录</p></li><li><p>压缩后文件格式：<code>.tar.gz</code></p></li></ul><p><img src="/2019/08/07/Linux压缩解压命令及其他命令/3.PNG" alt="压缩解压缩命令"></p></li><li><h3 id="压缩解压缩命令：tar"><a href="#压缩解压缩命令：tar" class="headerlink" title="压缩解压缩命令：tar"></a>压缩解压缩命令：<code>tar</code></h3><ul><li><p>tar命令解压缩语法：</p><p>​    -x 解包</p><p>​    -v 显示详细信息</p><p>​    -f 指定解压文件</p><p>​    -z 解压缩</p></li></ul><p><img src="/2019/08/07/Linux压缩解压命令及其他命令/4.PNG" alt="压缩解压命令"></p></li><li><h3 id="压缩解压缩命令：zip"><a href="#压缩解压缩命令：zip" class="headerlink" title="压缩解压缩命令：zip"></a>压缩解压缩命令：<code>zip</code></h3><ul><li><p>命令名称：zip</p></li><li><p>命令所在路径：/usr/bin/zip</p></li><li><p>执行权限：所有用户</p></li><li><p>语法： zip 选项 [-r] [压缩后文件名] [文件或目录] </p><p>​     -r 压缩目录</p></li><li><p>功能描述：压缩文件或目录</p></li><li><p>压缩后文件格式：zip</p></li><li><p>压缩之后可以保留原文件</p></li></ul><p><img src="/2019/08/07/Linux压缩解压命令及其他命令/5.PNG" alt="压缩解压命令"></p></li><li><h3 id="压缩解压缩命令：unzip"><a href="#压缩解压缩命令：unzip" class="headerlink" title="压缩解压缩命令：unzip"></a>压缩解压缩命令：<code>unzip</code></h3><ul><li><p>命令名称：unzip</p></li><li><p>命令所在路径：/usr/bin/unzip</p></li><li><p>执行权限：所有用户</p></li><li><p>语法：unzip [压缩文件]</p></li><li><p>功能描述：解压.zip的压缩文件</p></li></ul><p><img src="/2019/08/07/Linux压缩解压命令及其他命令/6.PNG" alt="压缩解压命令"></p></li><li><h3 id="压缩解压缩命令：bzip2"><a href="#压缩解压缩命令：bzip2" class="headerlink" title="压缩解压缩命令：bzip2"></a>压缩解压缩命令：<code>bzip2</code></h3><ul><li><p>命令名称：bzip2</p></li><li><p>命令所在路径：/usr/bin/bzip2</p></li><li><p>执行权限：所有用户</p></li><li><p>语法：bzip2 选项[-k] [文件]</p><p>​    -k 产生压缩文件后保留原文件</p></li><li><p>功能描述：压缩文件</p></li><li><p>压缩后文件格式：.bz2</p></li><li>不能压缩目录</li></ul><p><img src="/2019/08/07/Linux压缩解压命令及其他命令/7.PNG" alt="压缩解压命令"></p></li><li><h3 id="压缩解压缩命令：bunzip2"><a href="#压缩解压缩命令：bunzip2" class="headerlink" title="压缩解压缩命令：bunzip2"></a>压缩解压缩命令：<code>bunzip2</code></h3><ul><li><p>命令名称：bunzip2</p></li><li><p>命令所在权限：所有用户</p></li><li><p>语法：bunzip2 选项[-k] [压缩文件]</p><p>​        -k 解压缩后保留原文件</p></li><li><p>功能描述：解压缩</p></li></ul><p><img src="/2019/08/07/Linux压缩解压命令及其他命令/8.PNG" alt="压缩解压命令"></p></li></ol><h2 id="二、用户管理命令"><a href="#二、用户管理命令" class="headerlink" title="二、用户管理命令"></a>二、用户管理命令</h2><ol><li><h3 id="用户管理命令：useradd"><a href="#用户管理命令：useradd" class="headerlink" title="用户管理命令：useradd"></a>用户管理命令：<code>useradd</code></h3><ul><li><p>命令名称：useradd</p></li><li><p>命令所在路径：/usr/sbin/useradd</p></li><li><p>执行权限：root</p></li><li><p>语法：useradd 用户名</p></li><li><p>功能描述：添加新用户</p></li></ul></li><li><h3 id="用户管理命令：passwd"><a href="#用户管理命令：passwd" class="headerlink" title="用户管理命令：passwd"></a>用户管理命令：<code>passwd</code></h3><ul><li><p>命令名称：passwd</p></li><li><p>命令所在路径：/usr/bin/passwd</p></li><li><p>执行权限：所有用户</p></li><li><p>语法：passwd 用户名</p></li><li><p>功能描述：设置用户密码</p></li></ul><p><img src="/2019/08/07/Linux压缩解压命令及其他命令/9.PNG" alt="用户管理命令"></p></li><li><h3 id="用户管理命令：who"><a href="#用户管理命令：who" class="headerlink" title="用户管理命令：who"></a>用户管理命令：<code>who</code></h3><ul><li><p>命令名称：who</p></li><li><p>命令所在路径：/usr/bin/who</p></li><li><p>执行权限：所有用户</p></li><li><p>语法：who</p></li><li><p>功能描述：查看登录用户信息</p></li></ul><p><img src="/2019/08/07/Linux压缩解压命令及其他命令/10.PNG" alt="用户管理命令"></p></li></ol><h2 id="三、帮助命令"><a href="#三、帮助命令" class="headerlink" title="三、帮助命令"></a>三、帮助命令</h2><ol><li><h3 id="帮助命令：man"><a href="#帮助命令：man" class="headerlink" title="帮助命令：man"></a>帮助命令：<code>man</code></h3><ul><li><p>命令名称：man</p></li><li><p>命令英文原意：mannual</p></li><li><p>命令所在路径：/usr/bin/man</p></li><li><p>执行权限：所有用户</p></li><li><p>语法： man [命令或配置文件]  //配置文件不写绝对路径</p></li><li><p>功能描述：获得帮助信息</p></li></ul><p><img src="/2019/08/07/Linux压缩解压命令及其他命令/11.PNG" alt="帮助命令"></p></li><li><h3 id="帮助命令：help"><a href="#帮助命令：help" class="headerlink" title="帮助命令：help"></a>帮助命令：<code>help</code></h3><ul><li><p>命令名称：help</p></li><li><p>命令所在路径：Shell内置命令</p></li><li><p>执行权限：所有用户</p></li><li><p>语法 ：help 命令</p></li><li><p>功能描述：获得shell 内置命令的帮助信息</p></li><li><p>范例：$help umask</p><p>​            查看umask命令的帮助信息</p></li></ul><p><img src="/2019/08/07/Linux压缩解压命令及其他命令/12.PNG" alt="帮助命令"></p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、压缩解压命令&quot;&gt;&lt;a href=&quot;#一、压缩解压命令&quot; class=&quot;headerlink&quot; title=&quot;一、压缩解压命令&quot;&gt;&lt;/a&gt;一、压缩解压命令&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;h3 id=&quot;压缩解压命令：gzip&quot;&gt;&lt;a href=&quot;#压缩解压命令：gz
      
    
    </summary>
    
      <category term="Linux命令" scheme="http://wanqbin.xyz/categories/Linux%E5%91%BD%E4%BB%A4/"/>
    
    
      <category term="Linux命令" scheme="http://wanqbin.xyz/tags/Linux%E5%91%BD%E4%BB%A4/"/>
    
      <category term="Ubuntu" scheme="http://wanqbin.xyz/tags/Ubuntu/"/>
    
      <category term="Linux压缩解压" scheme="http://wanqbin.xyz/tags/Linux%E5%8E%8B%E7%BC%A9%E8%A7%A3%E5%8E%8B/"/>
    
      <category term="Linux用户管理" scheme="http://wanqbin.xyz/tags/Linux%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86/"/>
    
      <category term="Linux帮助命令" scheme="http://wanqbin.xyz/tags/Linux%E5%B8%AE%E5%8A%A9%E5%91%BD%E4%BB%A4/"/>
    
  </entry>
  
  <entry>
    <title>Linux文件搜索命令</title>
    <link href="http://wanqbin.xyz/2019/08/07/Linux%E6%96%87%E4%BB%B6%E6%90%9C%E7%B4%A2%E5%91%BD%E4%BB%A4/"/>
    <id>http://wanqbin.xyz/2019/08/07/Linux文件搜索命令/</id>
    <published>2019-08-07T09:02:00.000Z</published>
    <updated>2019-08-07T11:19:13.674Z</updated>
    
    <content type="html"><![CDATA[<ol><li><p>文件搜索命令：<code>find</code></p><p>注意：搜索会占用大量服务器资源。</p><ul><li><p>命令名称：find</p></li><li><p>命令所在路径：/bin/find</p></li><li><p>执行权限：所有用户</p></li><li><p>语法：find [搜索范围] [匹配条件]</p></li><li><p>执行权限： 所有用户</p></li><li><p>语法：find [文件搜索] [匹配条件]</p></li><li><p>功能描述：文件搜索</p></li></ul><p><code>$find aokis -name cpp</code></p><p>在目录<code>aokis</code>中查找文件<code>cpp</code></p><p><img src="/2019/08/07/Linux文件搜索命令/1.PNG" alt="文件搜索命令"></p><p><code>$find aokis -size +1024</code></p><p>+n代表大于， -n代表小于， n 表示等于</p><p><img src="/2019/08/07/Linux文件搜索命令/2.PNG" alt="文件搜索命令"></p><p><code>$find aokis -user aoki</code></p><p>在目录<code>aokis</code>中查找所有者为<code>aoki</code>的文件</p><p><code>-group</code>为根据所属组查找</p><p><code>$find aokis -cmin -120</code></p><p>在目录aokis下查找120分钟内修改过的文件和目录。</p><p><img src="/2019/08/07/Linux文件搜索命令/4.PNG" alt="文件搜索命令"></p><p><code>-amin</code> 访问时间access</p><p><code>-cmin</code> 文件属性change，改变文件属性的时间</p><p><code>-mmin</code> 文件内modify,文件内容被改变</p><p><code>find aokis -size +0 -a -size -1024</code></p><p>在aokis目录下查找大于0，小于1024的文件</p><p><img src="/2019/08/07/Linux文件搜索命令/5.PNG" alt="文件搜索命令"></p><p><code>-a</code>两个条件同时满足</p><p><code>-o</code>两个条件满足任意一个即可。</p><p><code>$find aokis -name aoki -exec cat {} \;</code></p><p>在aokis下查找aoki文件，并对其进行查看操作</p><p><code>-exec/-ok 命令{}\</code>对搜索结果执行操作</p><p><code>-type</code>根据文件类型查找</p><ul><li><code>-f</code>文件 <code>-d</code>目录  <code>-l</code>软链接文件</li></ul><p><code>-inum</code>根据i结点查找</p><p><img src="/2019/08/07/Linux文件搜索命令/6.PNG" alt="文件搜索命令"></p></li><li><p>文件搜索命令：<code>locate</code></p><ul><li><p>命令名称：locate</p></li><li><p>命令所在路径：/usr/bin/locate</p></li><li><p>执行权限:所有用户</p></li><li><p>语法：locate 文件名</p></li><li><p>功能描述：在文件资料库中查找文件</p></li><li>updatedb 更新locate文件资料库</li><li>注意：<ul><li>/tmp临时文件并不在locate的文件资料库中</li><li>locate 严格区分大小写</li><li>locate -i 不严格区分大小写</li></ul></li></ul><p><img src="/2019/08/07/Linux文件搜索命令/7.PNG" alt="文件搜索命令"></p></li><li><p>文件搜索命令：<code>which</code></p><ul><li><p>命令名称：which</p></li><li><p>命令所在路径：/usr/bin/which</p></li><li><p>执行权限：所有用户</p></li><li><p>语法：which 命令</p></li><li><p>功能描述：搜索命令所在目录及别名信息</p></li></ul><p><img src="/2019/08/07/Linux文件搜索命令/8.PNG" alt="文件搜索命令"></p></li><li><p>文件搜索命令：<code>grep</code></p><ul><li><p>命令名称：grep</p></li><li><p>命令所在路径：/bin/grep</p></li><li><p>执行权限：所有用户</p></li><li><p>语法：grep -iv [指定字符串] [文件]</p></li><li><p>功能描述：在文件中搜寻字符串匹配的行并输出</p><p>​                    -i  不区分大小写</p><p>​                    -v  排除指定字串</p><p><img src="/2019/08/07/Linux文件搜索命令/9.PNG" alt="文件搜索命令"></p><p><img src="/2019/08/07/Linux文件搜索命令/10.PNG" alt="文件搜索命令"></p></li></ul></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;&lt;p&gt;文件搜索命令：&lt;code&gt;find&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;注意：搜索会占用大量服务器资源。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;命令名称：find&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;命令所在路径：/bin/find&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;执行
      
    
    </summary>
    
      <category term="Linux命令" scheme="http://wanqbin.xyz/categories/Linux%E5%91%BD%E4%BB%A4/"/>
    
    
      <category term="Linux命令" scheme="http://wanqbin.xyz/tags/Linux%E5%91%BD%E4%BB%A4/"/>
    
      <category term="Ubuntu" scheme="http://wanqbin.xyz/tags/Ubuntu/"/>
    
      <category term="Linux文件搜索" scheme="http://wanqbin.xyz/tags/Linux%E6%96%87%E4%BB%B6%E6%90%9C%E7%B4%A2/"/>
    
  </entry>
  
  <entry>
    <title>Linux链接命令及权限管理命令</title>
    <link href="http://wanqbin.xyz/2019/08/07/Linux%E9%93%BE%E6%8E%A5%E5%91%BD%E4%BB%A4%E5%8F%8A%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86%E5%91%BD%E4%BB%A4/"/>
    <id>http://wanqbin.xyz/2019/08/07/Linux链接命令及权限管理命令/</id>
    <published>2019-08-07T07:45:00.000Z</published>
    <updated>2019-08-07T08:26:16.332Z</updated>
    
    <content type="html"><![CDATA[<ol><li><h3 id="文件处理命令：ln"><a href="#文件处理命令：ln" class="headerlink" title="文件处理命令：ln"></a>文件处理命令：<code>ln</code></h3><ul><li><p>命令名称：ln</p></li><li><p>命令英文原意：link</p></li><li><p>命令所在路径：/bin/ln</p></li><li><p>执行权限：所有用户</p></li><li><p>语法：ln -s [原文件] [目标文件]</p><p>​            -s 创建软链接</p></li><li><p>功能描述：生成链接文件</p></li></ul><p><img src="/2019/08/07/Linux链接命令及权限管理命令/1.PNG" alt="链接命令"></p><p>软链接特征：类似于Windos快捷方式</p><ul><li><code>lrwxrwxrwx</code> l代表软链接</li><li>文件大小只是符号链接的大小</li><li>cpp.soft-&gt;aokis/cpp 指向源文件</li></ul><p>硬链接特征：</p><ul><li>相当于执行了‘cp -p’命令，复制了相同属性的文件，且硬链接可以同步更新</li><li>通过i结点识别</li><li>不能跨分区</li><li>不能针对目录使用</li></ul><p><img src="/2019/08/07/Linux链接命令及权限管理命令/2.PNG" alt="硬链接"></p></li><li><h3 id="权限管理命令：chmod"><a href="#权限管理命令：chmod" class="headerlink" title="权限管理命令：chmod"></a>权限管理命令：<code>chmod</code></h3><ul><li>命令名称：chmod</li><li>命令英文原意：<strong>ch</strong>ange the  permissions <strong>mod</strong>e of a file</li><li>命令所在路径：/bin/chmod</li><li>执行权限：所有用户</li><li>语法：chmod  [{ugoa} {+-=} {rwx}] [文件或目录]   a表示所有人   u 表示所有者 g表示所属组  o表示other，其他人</li></ul><p>​            [mode=421] [文件或目录]          </p><p>​            -R 递归修改</p><ul><li><p>功能描述：改变文件或目录权限</p></li><li><p>权限的数字表示：</p><p>r ——4</p><p>w ——2</p><p>x ——-l</p><p>rwxrw-r—</p><p>7  6  4</p></li></ul></li></ol><div class="table-container"><table><thead><tr><th>代表字符</th><th>权限</th><th>对文件的含义</th><th>对目录的含义</th></tr></thead><tbody><tr><td>r</td><td>读权限</td><td>可以查看文件内容</td><td>可以列出目录中的内容</td></tr><tr><td>w</td><td>写权限</td><td>可以修改文件内容</td><td>可以在目录中创建、删除文件</td></tr><tr><td>x</td><td>执行权限</td><td>可以执行文件内容</td><td>可以进入目录</td></tr></tbody></table></div><p>   <img src="/2019/08/07/Linux链接命令及权限管理命令/3.PNG" alt="权限管理命令"></p><ol><li><h3 id="权限管理命令：useradd-amp-groupadd"><a href="#权限管理命令：useradd-amp-groupadd" class="headerlink" title="权限管理命令：useradd &amp; groupadd"></a>权限管理命令：<code>useradd &amp; groupadd</code></h3><p>添加用户：<code>useradd</code></p><p><img src="/2019/08/07/Linux链接命令及权限管理命令/4.PNG" alt="添加用户"></p><p>添加结果：</p><p><img src="/2019/08/07/Linux链接命令及权限管理命令/5.PNG" alt="添加结果"></p><p>添加组：</p><p><img src="/2019/08/07/Linux链接命令及权限管理命令/6.PNG" alt="添加组"></p></li><li><h3 id="权限管理命令：chown"><a href="#权限管理命令：chown" class="headerlink" title="权限管理命令：chown"></a>权限管理命令：<code>chown</code></h3><ul><li><p>权限管理命令：chown</p></li><li><p>命令名称：chown</p></li><li><p>命令英文原意：change  owership file</p></li><li><p>命令所在路径：/bin/chown</p></li><li><p>执行权限：所有用户</p></li><li><p>语法：chown [用户] [文件或目录]</p></li><li><p>功能描述：改变文件或目录的所有者</p></li></ul><p><img src="/2019/08/07/Linux链接命令及权限管理命令/7.PNG" alt="权限管理命令"></p></li><li><h3 id="权限管理命令：chgrp"><a href="#权限管理命令：chgrp" class="headerlink" title="权限管理命令：chgrp"></a>权限管理命令：<code>chgrp</code></h3><ul><li><p>权限管理命令：chgrp</p></li><li><p>命令名称：chgrp</p></li><li><p>命令英文原意：change file group ownership</p></li><li><p>命令所在路径：/bin/chgrp</p></li><li><p>执行权限：所有用户</p></li><li><p>语法：chgrp [用户组] [文件或目录]</p></li><li><p>功能描述：改变文件或目录的所属组</p></li></ul><p><img src="/2019/08/07/Linux链接命令及权限管理命令/8.PNG" alt="权限管理命令"></p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;&lt;h3 id=&quot;文件处理命令：ln&quot;&gt;&lt;a href=&quot;#文件处理命令：ln&quot; class=&quot;headerlink&quot; title=&quot;文件处理命令：ln&quot;&gt;&lt;/a&gt;文件处理命令：&lt;code&gt;ln&lt;/code&gt;&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;命令名称：ln&lt;/p&gt;
      
    
    </summary>
    
      <category term="Linux命令" scheme="http://wanqbin.xyz/categories/Linux%E5%91%BD%E4%BB%A4/"/>
    
    
      <category term="Ubuntu" scheme="http://wanqbin.xyz/tags/Ubuntu/"/>
    
      <category term="Linux" scheme="http://wanqbin.xyz/tags/Linux/"/>
    
      <category term="文件处理命令" scheme="http://wanqbin.xyz/tags/%E6%96%87%E4%BB%B6%E5%A4%84%E7%90%86%E5%91%BD%E4%BB%A4/"/>
    
  </entry>
  
</feed>

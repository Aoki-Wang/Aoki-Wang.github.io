<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Aoki&#39;s Blog</title>
  
  <subtitle>“惟将终夜长开眼，报答平生未展眉”</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://wanqbin.xyz/"/>
  <updated>2019-11-29T06:46:52.053Z</updated>
  <id>https://wanqbin.xyz/</id>
  
  <author>
    <name>Aoki</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Shell变量的数值运算</title>
    <link href="https://wanqbin.xyz/2019/hell%E5%8F%98%E9%87%8F%E7%9A%84%E6%95%B0%E5%80%BC%E8%BF%90%E7%AE%97/"/>
    <id>https://wanqbin.xyz/2019/hell变量的数值运算/</id>
    <published>2019-11-29T05:58:00.000Z</published>
    <updated>2019-11-29T06:46:52.053Z</updated>
    
    <content type="html"><![CDATA[<pre><code>## 一、算数运算符</code></pre><h3 id="1-Shell中常见的算数运算符号"><a href="#1-Shell中常见的算数运算符号" class="headerlink" title="1.Shell中常见的算数运算符号"></a>1.Shell中常见的算数运算符号</h3><table><thead><tr><th>算数运算符</th><th>意义</th></tr></thead><tbody><tr><td>+、-</td><td>加、减</td></tr><tr><td>*、/、%</td><td>乘法、除法、取余</td></tr><tr><td>**</td><td>幂</td></tr><tr><td>++、–</td><td>增加，及减少</td></tr><tr><td>!、&amp;&amp;、||</td><td>逻辑反、逻辑与、逻辑或</td></tr><tr><td>&lt;、&lt;=、&gt;、&gt;=</td><td>比较符号</td></tr><tr><td>==、!=、=</td><td>比较符号</td></tr><tr><td>&lt;&lt;、&gt;&gt;</td><td>向左移位、向右移位</td></tr><tr><td>~、|、&amp;、^</td><td>按位取反、按位异或、按位与按位或</td></tr><tr><td>=、+=、-=、*=、/=、%=</td><td>赋值运算符</td></tr></tbody></table><h3 id="2-Shell中常见的算数运算命令"><a href="#2-Shell中常见的算数运算命令" class="headerlink" title="2.Shell中常见的算数运算命令"></a>2.Shell中常见的算数运算命令</h3><table><thead><tr><th>运算操作符与运算命令</th><th>意义</th></tr></thead><tbody><tr><td>(())</td><td>用于整数运算的常用运算符，效率很高</td></tr><tr><td>let</td><td>用于整数运算，类似于(())</td></tr><tr><td>expr</td><td>可用于整数运算，但还有很多其他额外的功能</td></tr><tr><td>bc</td><td>Linux下的一个计算器程序（适合整数及小数运算）</td></tr><tr><td>$[]</td><td>用于整数运算</td></tr><tr><td>awk</td><td>awk既可以用于整数运算，也可以用于小数运算</td></tr><tr><td>declare</td><td>定义变量值和属性，-i参数可以用于定义整形变量，做运算</td></tr></tbody></table><h2 id="二、”-”数值运算命令"><a href="#二、”-”数值运算命令" class="headerlink" title="二、”(())”数值运算命令"></a>二、”(())”数值运算命令</h2><p>“(())”的作用是进行数值运算与数值比较。</p><table><thead><tr><th>运算操作符与运算命令</th><th>意义</th></tr></thead><tbody><tr><td>((i=i+1))</td><td>为运算后赋值，即将i+1的结果赋值给i</td></tr><tr><td>i=$((i+1))</td><td>表示将表达式运算后的结果赋值给i</td></tr><tr><td>((8&gt;7&amp;&amp;5==5))</td><td>进行比较操作，还可以加入逻辑与逻辑或，用于条件判断</td></tr><tr><td>echo $(2+1)</td><td>需要直接输出运算表达式的运算结果时，可以在”(())”的前面加$</td></tr></tbody></table><p>test1.sh</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span>! /bin/bash</span><br><span class="line"><span class="meta">#</span>Author: Created by Aoki</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">echo "$1+$2=$(($1+$2))"</span><br><span class="line"></span><br><span class="line">echo "$1-$2=$(($1-$2))"</span><br><span class="line"></span><br><span class="line">echo "$1*$2=$(($1*$2))"</span><br><span class="line"></span><br><span class="line">echo "$1/$2=$(($1/$2))"</span><br><span class="line"></span><br><span class="line">echo "$1**$2=$(($1**$2))"</span><br></pre></td></tr></table></figure><p><img src="/2019/hell变量的数值运算/%E5%8F%8C%E5%B0%8F%E6%8B%AC%E5%8F%B7test.PNG" alt="执行结果"></p><h2 id="三、let运算命令"><a href="#三、let运算命令" class="headerlink" title="三、let运算命令"></a>三、let运算命令</h2><p>let运算命令的语法格式：</p><p><code>let 赋值表达式</code></p><p>let赋值表达式的功能等同于”((赋值表达式))”</p><p>示例：监控web服务状态，如果访问量两次均失败，则报警。</p><p>mail配置：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/mail.rc</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>在末尾添加如下内容：</span><br><span class="line">set from=xxxxxx@qq.com</span><br><span class="line">set smtp=smtp.qq.com</span><br><span class="line">set smtp-auth-user="xxxxxx@qq.com"</span><br><span class="line">set smtp-auth-password=xxxxxxxxxxxxxxx</span><br><span class="line">set smtp-auth=login</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span>! /bin/bash</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>Author: Created by Aoki</span><br><span class="line"></span><br><span class="line">function checkUrl()&#123;</span><br><span class="line">timeout=5</span><br><span class="line">fails=0</span><br><span class="line">success=0</span><br><span class="line">while true </span><br><span class="line">do</span><br><span class="line">        wget --timeout=$timeout --tries=1 https://wanqbin.xyz -q -O /dev/null</span><br><span class="line">        if [ $? -ne 0 ];then</span><br><span class="line">                let fails=fails+1</span><br><span class="line">        else</span><br><span class="line">                let success+=1</span><br><span class="line">        fi</span><br><span class="line"></span><br><span class="line">        if [ $success -ge 1 ];then</span><br><span class="line">                echo "success"</span><br><span class="line">                exit 0</span><br><span class="line">        fi</span><br><span class="line"></span><br><span class="line">        if [ $fails -ge 2 ];then</span><br><span class="line">                Critical="sys is down."</span><br><span class="line">                echo $Critical|tee|mail -s "$Critical" aoki3352@163.com</span><br><span class="line">                exit 2</span><br><span class="line">        fi</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">done</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">checkUrl</span><br></pre></td></tr></table></figure><p><img src="/2019/hell变量的数值运算/%E9%82%AE%E4%BB%B6%E6%8A%A5%E8%AD%A6.PNG" alt="执行结果"></p><h2 id="四、expr命令的用法"><a href="#四、expr命令的用法" class="headerlink" title="四、expr命令的用法"></a>四、expr命令的用法</h2><p>expr(evaluate(求值) expression(表达式))命令既可以用于整数运算，也可以用于相关字符串长度、匹配等的运算处理。</p><p>在使用expr时，要注意：</p><ul><li>运算符及用于计算的数字左右都至少有一个空格，否则会报错</li><li>使用称号时，必须使用反斜线屏蔽其特定含义，因为Shell可能会误解星号的含义。</li></ul><p><img src="/2019/hell变量的数值运算/expr%E8%BF%90%E7%AE%97.PNG" alt="示例"></p><p>expr配合变量计算：</p><p>expr在Shell中可配合变量进行计算，但需要用反引号将计算表达式括起来。</p><p><img src="/2019/hell变量的数值运算/expr%E4%BD%BF%E7%94%A8%E5%8F%8D%E6%8B%AC%E5%8F%B7%E8%AE%A1%E7%AE%97.PNG" alt="expr使用反括号计算"></p><p>示例：判断一个变量值或字符串是否为整数</p><p>实现原理：</p><p>利用expr做计算时变量或字符串必须是整数的规则，把一个变量或字符串和一个已知的整数（非0）相加，看命令返回的值是否为0.如果是0，就认为做加法的变量或字符串为整数，否则就不是整数。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span>! /bin/bash</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>Author: Created by Aoki</span><br><span class="line"></span><br><span class="line">expr $1 + 1 &gt;/dev/null 2&gt;&amp;1</span><br><span class="line"></span><br><span class="line">[ $? -eq 0 ] &amp;&amp;echo int || echo chars #返回值为0，输出int，返回值不为0，否则输出chars</span><br></pre></td></tr></table></figure><p><img src="/2019/hell变量的数值运算/%E5%88%A4%E6%96%AD%E6%98%AF%E5%90%A6%E4%B8%BA%E6%95%B4%E6%95%B0.PNG" alt="执行结果"></p><p>标记：</p><p>/dev/null ：代表空设备文件</p><p>1 &gt; /dev/null 2&gt;&amp;1 语句含义：</p><ul><li>1 &gt; /dev/null ： 首先表示标准输出重定向到空设备文件，也就是不输出任何信息到终端，说白了就是不显示任何信息。</li><li>2&gt;&amp;1 ：接着，标准错误输出重定向（等同于）标准输出，因为之前标准输出已经重定向到了空设备文件，所以标准错误输出也重定向到空设备文件。</li></ul><p>示例：通过read读入持续等待输入</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span>! /bin/bash</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>Author:Created by Aoki</span><br><span class="line"></span><br><span class="line">while true</span><br><span class="line">do</span><br><span class="line">        read -p "Please input :" a</span><br><span class="line">        expr $a + 1 &gt;/dev/null 2&gt;&amp;1</span><br><span class="line">        [ $? -eq 0 ] &amp;&amp; echo int || echo chars</span><br><span class="line">done</span><br><span class="line">~</span><br></pre></td></tr></table></figure><p><img src="/2019/hell变量的数值运算/read%E8%AF%BB%E5%85%A5%E5%B9%B6%E5%88%A4%E6%96%AD%E6%98%AF%E5%90%A6%E4%B8%BA%E6%95%B4%E6%95%B0.PNG" alt="执行结果"></p><p>示例：打印一句话中字符数不大于4的单词</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span>! /bin.bash</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>Author: Created by Aoki</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">for n in I am Aoki who comes from China</span><br><span class="line">do</span><br><span class="line">        if [ `expr length $n` -le 4 ];then</span><br><span class="line">                echo $n</span><br><span class="line">        fi</span><br><span class="line">done</span><br></pre></td></tr></table></figure><p><img src="/2019/hell变量的数值运算/%E6%89%93%E5%8D%B0%E4%B8%80%E5%8F%A5%E8%AF%9D%E4%B8%AD%E5%AD%97%E7%AC%A6%E6%95%B0%E4%B8%8D%E5%A4%A7%E4%BA%8E4.PNG" alt="执行结果"></p><h2 id="五、bc命令"><a href="#五、bc命令" class="headerlink" title="五、bc命令"></a>五、bc命令</h2><p><img src="/2019/hell变量的数值运算/bc.PNG" alt="bc命令"></p><p>注：scale=3表示保留三位小数</p><p>示例：通过一条命令计算输出1+2+3+4+……+10的表达式，并计算结果。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@aoki obShell]# seq -s "+" 10  #seq是生成数字序列，-s是指定数字序列之间的分隔符</span><br><span class="line">1+2+3+4+5+6+7+8+9+10</span><br><span class="line">[root@aoki obShell]# echo &#123;1..10&#125; |tr " " "+"    #&#123;1..10&#125;是生成以空格为间隔的数字序列，并交给tr将空格替换为+</span><br><span class="line">1+2+3+4+5+6+7+8+9+10</span><br><span class="line">[root@aoki obShell]#</span><br></pre></td></tr></table></figure><p><img src="/2019/hell变量的数值运算/1%E5%88%B010%E7%9B%B8%E5%8A%A0.PNG" alt="执行结果"></p><h2 id="六、awk命令"><a href="#六、awk命令" class="headerlink" title="六、awk命令"></a>六、awk命令</h2><p>利用awk进行运算的效果也很好，适合小数和整数，特别是命令行计算，尤其是小数，运算很精确。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@aoki obShell]# echo &apos;7.777 3.444&apos; |awk &apos;&#123;print ($1-$2)&#125;&apos;      </span><br><span class="line">4.333</span><br><span class="line">[root@aoki obShell]# echo &apos;123.32 234 2&apos; |awk &apos;&#123;print (($1-$2)/$3)&#125;&apos;</span><br><span class="line">-55.34</span><br><span class="line">[root@aoki obShell]#</span><br></pre></td></tr></table></figure><p><img src="/2019/hell变量的数值运算/awk%E5%91%BD%E4%BB%A4.PNG" alt="执行结果"></p><h2 id="七、-符号的运算"><a href="#七、-符号的运算" class="headerlink" title="七、$[]符号的运算"></a>七、$[]符号的运算</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@aoki obShell]# i=5</span><br><span class="line">[root@aoki obShell]# i=$[i+10]</span><br><span class="line">[root@aoki obShell]# echo $i</span><br><span class="line">15</span><br><span class="line">[root@aoki obShell]# echo $[15*2]</span><br><span class="line">30</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;pre&gt;&lt;code&gt;## 一、算数运算符&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;1-Shell中常见的算数运算符号&quot;&gt;&lt;a href=&quot;#1-Shell中常见的算数运算符号&quot; class=&quot;headerlink&quot; title=&quot;1.Shell中常见的算数运算符号&quot;&gt;&lt;/a&gt;1
      
    
    </summary>
    
      <category term="Shell脚本" scheme="https://wanqbin.xyz/categories/Shell%E8%84%9A%E6%9C%AC/"/>
    
    
      <category term="Shell运算符" scheme="https://wanqbin.xyz/tags/Shell%E8%BF%90%E7%AE%97%E7%AC%A6/"/>
    
  </entry>
  
  <entry>
    <title>Shell中的for循环和while循环</title>
    <link href="https://wanqbin.xyz/2019/Shell%E4%B8%AD%E7%9A%84for%E5%BE%AA%E7%8E%AF%E5%92%8Cwhile%E5%BE%AA%E7%8E%AF/"/>
    <id>https://wanqbin.xyz/2019/Shell中的for循环和while循环/</id>
    <published>2019-11-27T13:50:00.000Z</published>
    <updated>2019-11-27T13:56:36.349Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、for循环"><a href="#一、for循环" class="headerlink" title="一、for循环"></a>一、for循环</h2><h3 id="1-基本语法："><a href="#1-基本语法：" class="headerlink" title="1.基本语法："></a>1.基本语法：</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">For 变量 in 字符串</span><br><span class="line">do</span><br><span class="line">语句1</span><br><span class="line">done</span><br></pre></td></tr></table></figure><h3 id="2-示例1：for1-sh"><a href="#2-示例1：for1-sh" class="headerlink" title="2.示例1：for1.sh"></a>2.示例1：<strong>for1.sh</strong></h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span>! /bin/bash</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>author by Aoki</span><br><span class="line"></span><br><span class="line">for i in `seq 1 15`  #反引号，识别为命令</span><br><span class="line"></span><br><span class="line">do</span><br><span class="line">        echo -e "\033[32mThe number is $i\033[0m"</span><br><span class="line">done</span><br></pre></td></tr></table></figure><p><img src="/2019/Shell中的for循环和while循环/for1%E6%89%A7%E8%A1%8C%E7%BB%93%E6%9E%9C.PNG" alt="for1执行结果"></p><h3 id="3-示例2：for-sum-sh"><a href="#3-示例2：for-sum-sh" class="headerlink" title="3.示例2：for-sum.sh"></a>3.示例2：<strong>for-sum.sh</strong></h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span>! /bin/bash</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>author by Aoki</span><br><span class="line"></span><br><span class="line">j=0</span><br><span class="line">for((i=1;i&lt;=100;i++))</span><br><span class="line"></span><br><span class="line">do</span><br><span class="line"></span><br><span class="line">        j=`expr $i + $j`</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line">echo $j</span><br><span class="line">~</span><br></pre></td></tr></table></figure><p><img src="/2019/Shell中的for循环和while循环/expr%E7%BB%93%E6%9E%9C.PNG" alt="expr命令"></p><p><img src="/2019/Shell中的for循环和while循环/for-sum%E6%89%A7%E8%A1%8C%E7%BB%93%E6%9E%9C.PNG" alt="for-sum执行结果"></p><p>查看脚本执行过程： <code>sh -x for-sum.sh</code></p><p><img src="/2019/Shell中的for循环和while循环/shell%E8%84%9A%E6%9C%AC%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B.PNG" alt="shell脚本执行过程"></p><h3 id="4-示例3：create-manylogs-sh"><a href="#4-示例3：create-manylogs-sh" class="headerlink" title="4.示例3：create-manylogs.sh"></a>4.示例3：<strong>create-manylogs.sh</strong></h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span>! /bin/bash</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>author by Aoki</span><br><span class="line"></span><br><span class="line">for((i=100;i&lt;=102;i++))</span><br><span class="line">do</span><br><span class="line">        FILE=$i.log</span><br><span class="line">        if [ ! -f $FILE ];then</span><br><span class="line">                touch /root/shell/test1/$FILE</span><br><span class="line">        else</span><br><span class="line">                continue;</span><br><span class="line">        fi</span><br><span class="line">done</span><br></pre></td></tr></table></figure><p><img src="/2019/Shell中的for循环和while循环/crate-log%E6%89%A7%E8%A1%8C%E7%BB%93%E6%9E%9C.PNG" alt="create-manylogs执行结果"></p><h3 id="5-示例4：-tar-logs-sh——找到相关log，然后批量打包"><a href="#5-示例4：-tar-logs-sh——找到相关log，然后批量打包" class="headerlink" title="5.示例4： tar-logs.sh——找到相关log，然后批量打包"></a>5.示例4： <strong>tar-logs.sh</strong>——找到相关log，然后批量打包</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span>! /bin/bash</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>author by Aoki</span><br><span class="line"></span><br><span class="line">for i in `find /root/shell/test1 -name "*.log"`</span><br><span class="line">do</span><br><span class="line">        tar -cvzf $i.tar.gz $i</span><br><span class="line">done</span><br></pre></td></tr></table></figure><p> <img src="/2019/Shell中的for循环和while循环/%E6%89%93%E5%8C%85logs.PNG" alt="打包结果"></p><h3 id="6-示例5：transfer-files-sh——批量传输文件"><a href="#6-示例5：transfer-files-sh——批量传输文件" class="headerlink" title="6.示例5：transfer-files.sh——批量传输文件"></a>6.示例5：<strong>transfer-files.sh</strong>——批量传输文件</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span>! /bin/bash</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>author by Aoki</span><br><span class="line"></span><br><span class="line">for i in `seq $1 $2`</span><br><span class="line">do</span><br><span class="line">        scp -r /root/shell/transferFiles root@192.168.43.$i:/tmp/</span><br><span class="line">done</span><br></pre></td></tr></table></figure><p><img src="/2019/Shell中的for循环和while循环/%E6%89%B9%E9%87%8F%E4%BC%A0%E8%BE%93%E6%96%87%E4%BB%B6.PNG" alt="传输过程"></p><p><img src="/2019/Shell中的for循环和while循环/61%E4%BC%A0%E8%BE%93%E7%BB%93%E6%9E%9C.PNG" alt="传输结果"></p><p><img src="/2019/Shell中的for循环和while循环/62%E4%BC%A0%E8%BE%93%E7%BB%93%E6%9E%9C.PNG" alt="传输结果2"></p><h2 id="二、while循环"><a href="#二、while循环" class="headerlink" title="二、while循环"></a>二、while循环</h2><h3 id="1-示例1：while1-sh"><a href="#1-示例1：while1-sh" class="headerlink" title="1.示例1：while1.sh"></a>1.示例1：<strong>while1.sh</strong></h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span>! /bin/bash</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>author by Aoki</span><br><span class="line"></span><br><span class="line">i=0</span><br><span class="line">while [[ $i -lt 10 ]]</span><br><span class="line">do</span><br><span class="line">        echo "The number is $i"</span><br><span class="line">        ((i++))</span><br><span class="line">done</span><br></pre></td></tr></table></figure><p><img src="/2019/Shell中的for循环和while循环/while%E5%BE%AA%E7%8E%AF%E6%89%A7%E8%A1%8C%E7%BB%93%E6%9E%9C.PNG" alt="执行结果"></p><h3 id="2-read命令："><a href="#2-read命令：" class="headerlink" title="2.read命令："></a>2.read命令：</h3><p><img src="/2019/Shell中的for循环和while循环/read%E5%91%BD%E4%BB%A4.PNG" alt="read命令图示"></p><h3 id="3-示例2：while2-sh"><a href="#3-示例2：while2-sh" class="headerlink" title="3.示例2：while2.sh"></a>3.示例2：<strong>while2.sh</strong></h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span>! /bin/bash</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>author by Aoki</span><br><span class="line"></span><br><span class="line">while read line</span><br><span class="line"></span><br><span class="line">do</span><br><span class="line">        echo $line</span><br><span class="line">done &lt;/etc/hosts</span><br></pre></td></tr></table></figure><p><img src="/2019/Shell中的for循环和while循环/while2%E6%89%A7%E8%A1%8C%E7%BB%93%E6%9E%9C.PNG" alt="while2执行结果"></p><h3 id="4-示例3：while3-sh"><a href="#4-示例3：while3-sh" class="headerlink" title="4.示例3：while3.sh"></a>4.示例3：<strong>while3.sh</strong></h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span>! /bin/bash</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>author by Aoki</span><br><span class="line"></span><br><span class="line">while read line</span><br><span class="line"></span><br><span class="line">do</span><br><span class="line">        IP=`echo $line |awk '&#123;print $2&#125;'`   #取第二列</span><br><span class="line">        echo -e "\033[32mscp -r /tmp/test.txt root@$IP:/tmp \033[0m"</span><br><span class="line">done &lt; IPList.txt</span><br></pre></td></tr></table></figure><p><strong>IPList.txt</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1 192.168.43.51 /tmp/ /root/shell/</span><br><span class="line">2 192.168.43.61 /tmp/ /root/shell/</span><br><span class="line">3 192.168.43.62 /tmp/ /root/shell/</span><br></pre></td></tr></table></figure><p><img src="/2019/Shell中的for循环和while循环/while3%E6%89%A7%E8%A1%8C%E7%BB%93%E6%9E%9C.PNG" alt="执行结果"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、for循环&quot;&gt;&lt;a href=&quot;#一、for循环&quot; class=&quot;headerlink&quot; title=&quot;一、for循环&quot;&gt;&lt;/a&gt;一、for循环&lt;/h2&gt;&lt;h3 id=&quot;1-基本语法：&quot;&gt;&lt;a href=&quot;#1-基本语法：&quot; class=&quot;headerlink
      
    
    </summary>
    
      <category term="Shell" scheme="https://wanqbin.xyz/categories/Shell/"/>
    
    
      <category term="shell" scheme="https://wanqbin.xyz/tags/shell/"/>
    
      <category term="for循环" scheme="https://wanqbin.xyz/tags/for%E5%BE%AA%E7%8E%AF/"/>
    
      <category term="while循环" scheme="https://wanqbin.xyz/tags/while%E5%BE%AA%E7%8E%AF/"/>
    
  </entry>
  
  <entry>
    <title>Shell及其基本语法【一】</title>
    <link href="https://wanqbin.xyz/2019/shell%E5%8F%8A%E5%85%B6%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95%E3%80%90%E4%B8%80%E3%80%91/"/>
    <id>https://wanqbin.xyz/2019/shell及其基本语法【一】/</id>
    <published>2019-11-27T07:50:00.000Z</published>
    <updated>2019-11-27T13:52:21.312Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、Shell是什么？"><a href="#一、Shell是什么？" class="headerlink" title="一、Shell是什么？"></a>一、Shell是什么？</h2><p>Shell是操作系统的最外层，Shell可以合并变成语言以控制进程和文件，以及启动和控制其他程序，shell通过更难过提示您输入，向操作系统解释该输入，然后处理来自操作系统的任何结果输出来管理您与操作系统之间的交互。简单来说，Shell就是一个用户跟操作系统之间的一个命令解释器。</p><p>Shell是用户与Linux操作系统之间沟通的桥梁。用户可以输入命令执行，又可以利用Shell脚本变成去运行。</p><h2 id="二、Shell编程之变量"><a href="#二、Shell编程之变量" class="headerlink" title="二、Shell编程之变量"></a>二、Shell编程之变量</h2><p>Shell是非类型的解释性语言。Shell给一个变量赋值，实际上即使定义了变量，在Linux支持的所有shell中，都可以用复制符号（=）为变量赋值。</p><p>Shell变量可分为两类：局部变量和环境变量。</p><ul><li>局部变量只在创建它们的shell脚本中使用。</li><li>环境变量则可以在创建它们的shell及其派生出来的任意子进程中使用。</li><li>有些变量是用户创建的，其他的则是专用shell变量。</li></ul><p>first_shell.sh</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> !/bin/bash</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>Filename :first_shell.sh</span><br><span class="line"><span class="meta">#</span>auto echo hello world</span><br><span class="line"><span class="meta">#</span>by author Aoki</span><br><span class="line"></span><br><span class="line">echo "Hello world"</span><br></pre></td></tr></table></figure><ul><li>$0 当前程序的名称</li><li>$n 当前程序的第n个参数，n=1,2,3……</li><li>$* 当前程序的所有参数（不包括程序本身）</li><li>$# 当前程序的参数个数（不包括程序本身）</li><li>$? 命令或程序执行完后的状态，一般返回0表示执行成功</li><li>UID 当前用户的UID</li><li>$PWD 当前所在的目录</li></ul><p>var.sh</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span>!/bin/bash</span><br><span class="line"><span class="meta">#</span>define path varibles</span><br><span class="line"><span class="meta">#</span>by author Aoki</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>A=123</span><br><span class="line">name=Aoki</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>echo " This is my First shell var $A"</span><br><span class="line">echo "My name is $name"</span><br><span class="line"></span><br><span class="line">echo $UID</span><br><span class="line">echo $PWD</span><br><span class="line">echo "#################################"</span><br><span class="line"></span><br><span class="line">echo $0</span><br><span class="line">echo $1</span><br><span class="line">echo "######################################"</span><br><span class="line"></span><br><span class="line">echo "The \$1 is $1"</span><br><span class="line">echo "The \$2 is $2"</span><br><span class="line">echo "The \$? is $?"   #判断上一条命令是否正确 0代表正确</span><br><span class="line">echo "The \$* is $*"    #输出所有参数</span><br><span class="line">echo "The \$# is $#"    #输出参数的数量</span><br></pre></td></tr></table></figure><h2 id="三、if语句"><a href="#三、if语句" class="headerlink" title="三、if语句"></a>三、if语句</h2><p>if 、for、 while、 case等条件流程控制语句。</p><p>逻辑运算符解析：</p><ul><li>-f 判断文件是否存在 eg: if [ -f filename ]</li><li>-d 判断目录是否存在 eg: if [ -d dir ]</li><li>-eq 等于 应用于：整型比较</li><li>-ne 不等于 应用于：整型比较</li><li>-lt 小于 应用于：整型比较</li><li>-gt 大于 应用于：整型比较</li><li>-le 小于或等于 应用于：整型比较</li><li>-ge 大于或等于 应用于：整型比较</li><li>-a 双方都成立（and） 逻辑表达式 –a 逻辑表达式</li><li>-o 单方成立（or） 逻辑表达式 –o 逻辑表达式</li><li>-z 空字符串</li></ul><p>If条件判断语句</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> If (表达式)   #if (Variable in Array)</span><br><span class="line"></span><br><span class="line">语句1</span><br><span class="line"></span><br><span class="line">else</span><br><span class="line"></span><br><span class="line">语句2</span><br><span class="line"></span><br><span class="line">fi</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/bin/bash -n 文件名  #测试该脚本有没有报错</span><br></pre></td></tr></table></figure><p>if.sh</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span>!/bin/bash</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>auto if test</span><br><span class="line"><span class="meta">#</span>by author Aoki</span><br><span class="line"></span><br><span class="line">NUM1=100</span><br><span class="line">NUM2=200</span><br><span class="line"></span><br><span class="line"><span class="meta">if(($</span>NUM1 &gt; $NUM2));then</span><br><span class="line"></span><br><span class="line">        echo "This $NUM1 greate $NUM2 "</span><br><span class="line"></span><br><span class="line">else</span><br><span class="line">        echo "This $NUM1 little $NUM2"</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><p>iftest1.sh</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span>!/bin/bash</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>auto if  test1</span><br><span class="line"><span class="meta">#</span>by author Aoki</span><br><span class="line"></span><br><span class="line">DIR=/root/20000</span><br><span class="line"></span><br><span class="line">if [ ! -d $DIR ];then  #判断当前目录是否存在</span><br><span class="line"></span><br><span class="line">        mkdir -p $DIR</span><br><span class="line">        echo "$DIR create successfully"</span><br><span class="line">else</span><br><span class="line">        echo "$DIR is exist"</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><p>iftest2.sh</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span>!/bin/bash</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>auto test file whether exist</span><br><span class="line"><span class="meta">#</span>by author Aoki</span><br><span class="line"></span><br><span class="line">FILES=/root/test.txt</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if [ ! -f $FILES ];then  #判断当前文件是否存在</span><br><span class="line"></span><br><span class="line">        echo "ok"&gt;&gt;$FILES</span><br><span class="line">else</span><br><span class="line">        cat $FILES</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><p>iftest3.sh</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span>!/bin/bash</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>by author Aoki</span><br><span class="line"></span><br><span class="line">scores=$1</span><br><span class="line"></span><br><span class="line">if [ -z $scores ];then</span><br><span class="line">        echo "Usage:&#123;$0 60 | 80.&#125;"</span><br><span class="line">        exit</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">if [[ $scores -gt 80 ]]; then</span><br><span class="line">        echo "really Good"</span><br><span class="line">elif [[ $scores -gt 70 ]]; then</span><br><span class="line">        echo "good"</span><br><span class="line">elif [[ $scores -gt 60 ]]; then</span><br><span class="line">        echo "pass"</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><h2 id="四、使用if条件语句编写MySQL备份脚本"><a href="#四、使用if条件语句编写MySQL备份脚本" class="headerlink" title="四、使用if条件语句编写MySQL备份脚本"></a>四、使用if条件语句编写MySQL备份脚本</h2><p>auto_backup_mysql.sh</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span>!/bin/bash</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>auto backup mysql db</span><br><span class="line"><span class="meta">#</span>by author Aoki</span><br><span class="line"><span class="meta">#</span>define backup path</span><br><span class="line"></span><br><span class="line">BACK_DIR=/data/backup/`data+%Y%m%d` #反引号解析为命令</span><br><span class="line">MYSQLDB=discuz</span><br><span class="line">MYSQLUSR=backup</span><br><span class="line">MYSQLPW=123456</span><br><span class="line">MYSQLCMD=/usr/bin/mysqldump</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>判断是否root用户登录</span><br><span class="line"></span><br><span class="line">if [ $UID -ne 0 ];then</span><br><span class="line">        echo "Must to use root for exec shell"</span><br><span class="line">        exit</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if [ ! -d $BACK_DIR ];then</span><br><span class="line">        mkdir -p $BACK_DIR</span><br><span class="line">        echo "$BACK_DIR created successfully"</span><br><span class="line">else</span><br><span class="line">        echo "This $BACK_DIR is exist"</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>mysql 备份命令</span><br><span class="line"><span class="meta">$</span>MYSQLCMD -u$MYSQLUSR -p$MYSQLPW -d MYSQLDB &gt; $BACK_DIR/$MYSQLDB.sql</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if [ $? -eq 0];then</span><br><span class="line">        echo "The mysql backup $MYSQLDB successfully"</span><br><span class="line">else</span><br><span class="line">        echo "The mysql backup $MYSQLDB failed"</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、Shell是什么？&quot;&gt;&lt;a href=&quot;#一、Shell是什么？&quot; class=&quot;headerlink&quot; title=&quot;一、Shell是什么？&quot;&gt;&lt;/a&gt;一、Shell是什么？&lt;/h2&gt;&lt;p&gt;Shell是操作系统的最外层，Shell可以合并变成语言以控制进程和
      
    
    </summary>
    
      <category term="Shell脚本" scheme="https://wanqbin.xyz/categories/Shell%E8%84%9A%E6%9C%AC/"/>
    
    
      <category term="shell" scheme="https://wanqbin.xyz/tags/shell/"/>
    
      <category term="MySQL备份脚本" scheme="https://wanqbin.xyz/tags/MySQL%E5%A4%87%E4%BB%BD%E8%84%9A%E6%9C%AC/"/>
    
      <category term="shell变量" scheme="https://wanqbin.xyz/tags/shell%E5%8F%98%E9%87%8F/"/>
    
      <category term="if语句" scheme="https://wanqbin.xyz/tags/if%E8%AF%AD%E5%8F%A5/"/>
    
  </entry>
  
  <entry>
    <title>AbstractFactory模式</title>
    <link href="https://wanqbin.xyz/2019/AbstractFactory%E6%A8%A1%E5%BC%8F/"/>
    <id>https://wanqbin.xyz/2019/AbstractFactory模式/</id>
    <published>2019-11-26T16:09:00.000Z</published>
    <updated>2019-11-26T16:26:07.829Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、Abstract-Factory模式"><a href="#一、Abstract-Factory模式" class="headerlink" title="一、Abstract Factory模式"></a>一、Abstract Factory模式</h2><blockquote><p>为创建一组相关或相互依赖的对象提供一个接口，而且无需指定它们的具体类。</p><p>​                                                                                                                                                                                    </p><p>​                                                                                                                                                                                    ——《设计模式》</p></blockquote><p>有时候，几个对象需要以一种协调的方式实例化。例如，在处理用户界面时，系统可能需要在一个操作系统上用一组对象，在另一个操作系统上用另一组对象。Abstract Factory模式能够确保系统总是根据情况获得正确的对象。</p><h2 id="二、Abstract-Factory模式：示例研究"><a href="#二、Abstract-Factory模式：示例研究" class="headerlink" title="二、Abstract Factory模式：示例研究"></a>二、Abstract Factory模式：示例研究</h2><p>假设有这样一项任务：设计一个计算机系统，显示并打印取自数据库的几何形状。用来显示和打印形状的分辨率取决于当前运行系统的计算机：CPU的速度和可用内存。系统必须留意自己对计算机的要求。</p><p>这里的难点在于，系统必须控制使用哪些驱动程序：低配置机器使用低分辨率驱动程序，高配置机器使用高分辨率驱动程序，如下所示：</p><table><thead><tr><th>驱动程序</th><th>在低配置机器上</th><th>在高配置机器上</th></tr></thead><tbody><tr><td>显示</td><td>LRDD低分辨率显示驱动程序</td><td>HRDD高分辨率显示驱动程序</td></tr><tr><td>打印</td><td>LRPD低分辨率打印驱动程序</td><td>HRPD高分辨率打印驱动程序</td></tr></tbody></table><p>这个例子中，两组驱动程序是互斥的，但通常实际情况并不是这样的。有时候不同组的驱动程序会包含来自同一个类的对象。比如，一台中级配置的机器可能使用低分辨率的显示驱动程序（LRDD）和高分辨率打印驱动程序(HRPD)</p><p>使用哪一组取决于问题域：对于给定的情形，需要使用哪组对象？在这个例子中，共同的概念主要是对象对系统提出的要求。</p><ul><li>低分辨率组——LRDD和LRPD，这些驱动程序对系统提出的要求较低。</li><li>高分辨率组——HRDD和HRPD，这些驱动程序对系统提出的要求较高。</li></ul><p>方案一：使用switch语句选择驱动程序</p><p><strong>ApControl.h</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ApControl</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ApControl(<span class="keyword">void</span>);</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">doDraw</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">doPrint</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ~ApControl(<span class="keyword">void</span>);</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Resolution myResolution;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>ApControl.cpp</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"ApControl.h"</span></span></span><br><span class="line"></span><br><span class="line">ApControl::ApControl(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Set myResolution based on configuration</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ApControl::~ApControl(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> ApControl::<span class="function"><span class="keyword">void</span> <span class="title">doDraw</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (myResolution) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> LOW:</span><br><span class="line">            <span class="comment">// use lrdd</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> HIGH:</span><br><span class="line">            <span class="comment">// use hrdd</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> ApControl::doPrint()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">switch</span> (myResolution) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> LOW:</span><br><span class="line">            <span class="comment">// use lrpd</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> HIGH:</span><br><span class="line">            <span class="comment">// use hrpd</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然这样能够达到目的，但是有问题。确定使用哪个驱动程序的规则与驱动程序实际使用混杂在一起，因此耦合度和内聚性上都存在问题。</p><ul><li>紧耦合——如果要修改分辨率的规则，就必须在两处修改代码，而这两处的其他方面毫无关系。</li><li>低内聚——doDraw方法和doPrint方法的任务毫不相关；它们都必须创建形状，并且操心应该使用哪个驱动程序。</li></ul><p>紧耦合和低内聚也许眼下并不是问题，但是，它们通常会增加维护成本。</p><h3 id="switch语句可能说明需要抽象"><a href="#switch语句可能说明需要抽象" class="headerlink" title="switch语句可能说明需要抽象"></a>switch语句可能说明需要抽象</h3><blockquote><p>switch语句本身常常说明问题：</p><ul><li>需要多态行为</li><li>存在职责错放。</li></ul><p>应该考虑用一种更通用的解决方案，比如抽象代替switch语句，或者将职责赋予其他对象。</p></blockquote><p>另一种方案是使用继承。可以用两个不同的ApControl类：一个使用低分辨率驱动程序，另一个使用高分辨率驱动程序。它们都将从同一个抽象类派生，因此可以在抽象类中维护公共代码。</p><p><img src="/2019/AbstractFactory模式/01.PNG" alt="方案二——用继承处理变化"></p><p>虽然这个简单的例子里使用继承也可以完成任务，但继承的缺点非常多。</p><ul><li>组合爆炸——对于每个组和未来可能使用的每个新组，都必须创建一个新的具体类（即ApControl的一个新版本）。例如，如果需要中级配置的应用程序（使用LRPD和HRDD），就需要增加一个新类处理这一情况。如果需要一个应用程序处理HRPD和LRDD，又需要一个类。</li><li>含义不清——所生成的类对于说明意图毫无帮助。我已经将每个类根据特定情况进行了特化。如果希望自己的带啊吗维护起来比较容易，就需要尽可能清晰地说明其意图。这样就不必再耗费大量时间重新了解某段代码地用途。</li><li>需要使用聚集——这个方案违反了“优先使用对象聚集而不是类继承”地原则。没有遵循这一规则说明在发生其他变化时，这些类会在类层次中进一步降级。</li></ul><p>在这个例子中，LRDD和HRDD都是显示驱动程序，LRPD和HRPD都是打印驱动程序。所以抽象概念应该是<strong>显示驱动程序</strong>和<strong>打印驱动程序</strong>。下图可以概念性地表示这一点，之所以说是概念性的，是因为LRDD和HRDD并不是从同一个抽象类派生出来的。现在，我不用操心LRDD和HRDD派生自不同的抽象类，因为i我知道可以使用Adapter模式对这些驱动程序进行适配，使它们看起来属于一个抽象类。</p><p><img src="/2019/AbstractFactory模式/02.PNG" alt="驱动程序及其抽象"></p><p>这样定义对象，ApControl对象不用switch语句就可以使用DisplayDriver对象和PrintDriver对象了。ApControl类的可理解性大大提高了，因为它自己用不着再考虑驱动程序的具体类型，也就是说，ApControl对象可以不考虑驱动程序的分辨率，使用DisplayDriver对象和PrintDriver对象。ApControl使用驱动程序很可能又可以实现Bridge模式。</p><p><img src="/2019/AbstractFactory模式/03.PNG" alt="理想情况下ApControl使用驱动程序的情形"></p><p>还有一个问题：如何创建合适的对象呢？</p><p>可以让ApControl类负责，但这样未来会有维护问题。如果要处理一组新的对象，就必须修改ApControl类。相反，如果用一个“工厂”对象负责实例化所需要的对象，即使出现新的对象组也没有问题了。</p><p>下面，我将用一个工厂对象（ResFactory类型，也称分辨率工厂）来控制驱动程序组的创建。ApControl对象将使用另外一个对象——工厂对象获得适合当前计算机的显示驱动程序和打印驱动程序。</p><p>工厂是有一定职责的，而且是内聚的，</p><p>从ApControl的角度来看，事情现在简单多了。ApControl让ResFactory来负责跟踪应该使用哪些驱动程序。虽然我们仍然需要为ResFactory来编写选择代码，但是问题已经根据职责分解了。ApControl的职责是是了解如何使用合适的对象。ResFactory的职责是决定哪些对象合适。可以使用不同的工厂对象，也可以只使用一个。无论如何，现在的情况都优于前面的方案。</p><p>这同时还加强了内聚性：ResFactory所做的就是创建合适的驱动程序；ApControl只负责使用这些驱动程序。</p><p>避免在ResFactory类使用switch语句的办法有几种。不适用switch语句可以在未来进行修改时，不影响原有的工厂对象。可以通过定义一个表示“工厂”概念的抽象类，将变化封装在一个类中。对于ResFactory而言，有两种不同的行为：</p><ul><li>给我应该使用的显示驱动程序</li><li>给我应该使用的打印驱动程序</li></ul><p>ResFactory对象可以从两个具体类中的一个实例化，而具体类都从一个定义了公共方法的抽象类派生。</p><p><img src="/2019/AbstractFactory模式/04.PNG" alt="ResFactory模式封装了变化"></p><p>下面是Abstract Factory模式的3个关键的概念步骤：</p><table><thead><tr><th>策略</th><th>设计中的体现</th></tr></thead><tbody><tr><td>找到变化并封装之</td><td>使用哪个驱动程序对象的选择是变化的，所以，将它封装在ResFactory类中</td></tr><tr><td>优先使用对象聚集，而不是类继承</td><td>将变化放在一个独立的对象——ResFactory对象中，ApControl对象使用ResFactory对象，而不是拥有两种不同的ApControl对象。</td></tr><tr><td>针对接口编程而不是实现设计</td><td>ApControl知道怎样请求ResFactory实例化驱动程序对象，但它不知道ResFactory对象如何实际实例化。</td></tr></tbody></table><p>下面来完成这个解决方案，让ApControl对象与合适的工厂对象（LowResFact对象或HighResFact对象）通信，如下图所示。请注意，ResFactory是抽象的，这种对ResFactory实现细节的隐藏，正是这个模式的运作原理。因此，这个模式被称为Abstract Factory（抽象工厂）。</p><p><img src="/2019/AbstractFactory模式/05.PNG" alt="使用Abstract Factory模式的过度解决方案"></p><p>ApControl对象将得到一个LowResFacrt对象或一个HIghResFact对象。需要时ApControl对象向这个工厂请求对象合适的驱动程序。工厂对象实例化自己了解的某个驱动对象程序。ApControl对象不需要操心返回的驱动程序时低分辨率还是高分辨率，因为ApControl对象使用它们的方式是相同的。</p><p><strong>ApControl.h</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"DisplayDriver.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"PrintDriver.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"ResFactory.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ApControl</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ApControl(<span class="keyword">void</span>);</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">doPrint</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">doDraw</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ~ApControl(<span class="keyword">void</span>);</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    ResFactory *myResFactory;</span><br><span class="line">    DisplayDriver *myDisplayDriver;</span><br><span class="line">    PrintDriver *myPrintDriver;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>ApControl.cpp</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"ApControl.h"</span></span></span><br><span class="line"></span><br><span class="line">ApControl::ApControl(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    ResFactory *myResFactory= ResFactory::getFactory();</span><br><span class="line">    myDisplayDriver= myResFactory-&gt;getDispDrvr();</span><br><span class="line">    myPrintDriver= myResFactory-&gt;getPrtDrvr();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ApControl::~ApControl(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> ApControl::doDraw(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//    . . .</span></span><br><span class="line">    myDisplayDriver-&gt;draw();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> ApControl::doPrint(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//    . . .</span></span><br><span class="line">    myPrintDriver-&gt;print();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>ResFactory.h</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"DisplayDriver.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"PrintDriver.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ResFactory</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ResFactory(<span class="keyword">void</span>);</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> DisplayDriver* <span class="title">getDispDrvr</span><span class="params">(<span class="keyword">void</span>)</span></span>=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> PrintDriver* <span class="title">getPrtDrvr</span><span class="params">(<span class="keyword">void</span>)</span></span>=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> ResFactory* <span class="title">getFactory</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ~ResFactory(<span class="keyword">void</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>ResFactory.cpp</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"ResFactory.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"HighResFactory.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"LowResFactory.h"</span></span></span><br><span class="line"></span><br><span class="line">ResFactory::ResFactory(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ResFactory::~ResFactory(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ResFactory* ResFactory::getFactory (<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Logic to decide which resolution to use</span></span><br><span class="line">    <span class="comment">// If are to use High Resolution</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> HighResFactory;</span><br><span class="line">    <span class="comment">// if are to use Low Resolution</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> LowResFactory;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>HighResFact.h</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"resfactory.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"HRDD.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"HRPD.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HighResFact</span> :</span> <span class="keyword">public</span> ResFactory</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    HighResFact(<span class="keyword">void</span>);</span><br><span class="line">    <span class="function">DisplayDriver* <span class="title">getDispDrvr</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line">    <span class="function">PrintDriver* <span class="title">getPrtDrvr</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ~HighResFact(<span class="keyword">void</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>HighResFact.cpp</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"HighResFact.h"</span></span></span><br><span class="line"></span><br><span class="line">HighResFact::HighResFact(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">HighResFact::~HighResFact(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line">DisplayDriver* HighResFact::getDispDrvr(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> HRDD;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PrintDriver* HighResFact::getPrtDrvr(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> HRPD;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>LowResFact.h</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"resfactory.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"LRDD.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"LRPD.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LowResFact</span> :</span>     <span class="keyword">public</span> ResFactory</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    LowResFact(<span class="keyword">void</span>);</span><br><span class="line">    <span class="function">DisplayDriver* <span class="title">getDispDrvr</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line">    <span class="function">PrintDriver* <span class="title">getPrtDrvr</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ~LowResFact(<span class="keyword">void</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>LowResFact.cpp</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"LowResFact.h"</span></span></span><br><span class="line"></span><br><span class="line">LowResFact::LowResFact(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">LowResFact::~LowResFact(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">DisplayDriver* LowResFact::getDispDrvr(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> LRDD;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PrintDriver* LowResFact::getPrtDrvr(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> LRPD;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>DisplayDriver.h</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DisplayDriver</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    DisplayDriver(<span class="keyword">void</span>);</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">(<span class="keyword">void</span>)</span></span>=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ~DisplayDriver(<span class="keyword">void</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>DisplayDriver.cpp</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"DisplayDriver.h"</span></span></span><br><span class="line"></span><br><span class="line">DisplayDriver::DisplayDriver(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">DisplayDriver::~DisplayDriver(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>HRDD.h</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"displaydriver.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HRDD</span> :</span> <span class="keyword">public</span> DisplayDriver</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    HRDD(<span class="keyword">void</span>);</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">draw</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ~HRDD(<span class="keyword">void</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>HRDD.cpp</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"HRDD.h"</span></span></span><br><span class="line"></span><br><span class="line">HRDD::HRDD(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">HRDD::~HRDD(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> HRDD::draw(<span class="keyword">void</span>) </span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// do high resolution draw</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>LRDD.h</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"displaydriver.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LRDD</span> :</span></span><br><span class="line">    <span class="keyword">public</span> DisplayDriver</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    LRDD(<span class="keyword">void</span>);</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">draw</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ~LRDD(<span class="keyword">void</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>LRDD.cpp</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"LRDD.h"</span></span></span><br><span class="line"></span><br><span class="line">LRDD::LRDD(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">LRDD::~LRDD(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> LRDD::draw(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// do low resolution draw</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>PrintDriver.h</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PrintDriver</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    PrintDriver(<span class="keyword">void</span>);</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">void</span>)</span></span>=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ~PrintDriver(<span class="keyword">void</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>PrintDriver.cpp</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"PrintDriver.h"</span></span></span><br><span class="line"></span><br><span class="line">PrintDriver::PrintDriver(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PrintDriver::~PrintDriver(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>HRPD.h</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"printdriver.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HRPD</span> :</span> <span class="keyword">public</span> PrintDriver</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    HRPD(<span class="keyword">void</span>);</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ~HRPD(<span class="keyword">void</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>HRPD.cpp</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"HRPD.h"</span></span></span><br><span class="line"></span><br><span class="line">HRPD::HRPD(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">HRPD::~HRPD(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> HRPD::print()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Do high resolution print</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>LRPD.h</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"printdriver.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LRPD</span> :</span></span><br><span class="line">    <span class="keyword">public</span> PrintDriver</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    LRPD(<span class="keyword">void</span>);</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ~LRPD(<span class="keyword">void</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>LRPD.cpp</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"LRPD.h"</span></span></span><br><span class="line"></span><br><span class="line">LRPD::LRPD(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">LRPD::~LRPD(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> LRPD::print()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// do low resolution print</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里还忽略了一个问题：LRDD和HRDD可能不是派生自同一个抽象类。我们可以使用上图中的结构，但是需要使用Adapter模式对驱动程序进行适配。</p><p><img src="/2019/AbstractFactory模式/06.PNG" alt="用Abstract Factory模式和Adapter模式解决这个问题"></p><p>这个设计的实现基于上与前面那个相同。唯一区别在于，现在工厂对象实例化的对象来自另外两个适配原驱动程序的类。这是一个重要的建模方法。用这种方法将概念上相似的对象当作同种对象处理，即使它们不是。这使Abstract Factory模式可以用于更多情况。</p><p>在这个模式中：</p><ul><li>客户对象只知道向谁请求所需的对象和如何使用这些对象</li><li>Abstract Factory类通过为每个不同类型的对象定义一个方法，来指定实例化哪个对象，一般而言，对于每一种必须实例化的对象，Abstract Factory模式都有一个相应的方法</li><li>具体的工厂对象指定哪些对象要实例化</li></ul><p>在刚才的例子中，通过为每一种可能情况设一个具体类，实现了Abstract Factory模式。这里有两种情况：低分辨率和高分辨率。实践中，情况的数量可能非常大，而且每增加一个新的变量都会组合级数地增长。</p><h2 id="三、Abstract-Factory模式：关键特征"><a href="#三、Abstract-Factory模式：关键特征" class="headerlink" title="三、Abstract Factory模式：关键特征"></a>三、Abstract Factory模式：关键特征</h2><p>决定需要哪个工厂对象实际上与确定使用哪一组对象是相同的。</p><p>我可以使用Abstract Factory模式，不同应用程序都使用同一子系统。在这种情况下，工厂对象将传给子系统，告诉子系统将要使用哪些对象。此时，通常主系统知道子系统需要哪一组对象。在调用子系统之前，将实例化正确的工厂对象。</p><p>下图中，Client对象使用派生自两个不同服务类的对象（AbstractProductA和AbstractProductB）。这个设计非常简化，隐藏了实现细节，系统可隐藏性也更好。</p><ul><li>Client对象不知道自己拥有的是服务对象的哪个特定具体实现，因为创建服务对象是工厂对象的职责</li><li>Client对象甚至不知道自己使用的是哪个特定工厂，因为它只知道自己有一个AbstractFactory对象。它可能有一个ConcreteFactory1对象或一个ConcreteFactory2对象，但它不知道到底是哪一个。</li></ul><p><img src="/2019/AbstractFactory模式/07.PNG" alt="Abstract Factory模式通用结构图"></p><p>对Client对象隐藏（即封装）了”应该使用哪些服务对象”的选择，这样将来修改选择算法将更加容易，因为不会影响到Client对象。</p><p>Abstract Factory模式为我们提供了一种新的分解方式——根据职责分解。使用这种方法可以将问题分解成：</p><ul><li>谁在使用我们的特定对象（ApControl）</li><li>谁来决定使用哪些特定对象（AbstractFactory）</li></ul><h3 id="Abstract-Factory模式关键特征："><a href="#Abstract-Factory模式关键特征：" class="headerlink" title="Abstract Factory模式关键特征："></a>Abstract Factory模式关键特征：</h3><ul><li>意图：需要为特定的客户（或情况）提供对象组。</li><li>问题：需要实例化一组相关的对象</li><li>解决方案：协调对象组的创建。提供一种方式，将如何执行对象实例化的规则从使用这些对象的客户对象中提出出来。</li><li>参与者和协作者：AbstractFactory为如何创建对象组的每个对象组定义接口。一般每个组都由独立的ConcreteFactory进行创建。</li><li>效果：这个模式将“使用哪些对象”的规则与“如何使用这些对象”的逻辑分离开来。</li><li>实现：定义一个抽象类来指定创建哪些对象。然后为每个组实现一个具体类。可以用表或文件完成同样的任务。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、Abstract-Factory模式&quot;&gt;&lt;a href=&quot;#一、Abstract-Factory模式&quot; class=&quot;headerlink&quot; title=&quot;一、Abstract Factory模式&quot;&gt;&lt;/a&gt;一、Abstract Factory模式&lt;/h2&gt;&lt;
      
    
    </summary>
    
      <category term="设计模式" scheme="https://wanqbin.xyz/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="Abstract Factory模式" scheme="https://wanqbin.xyz/tags/Abstract-Factory%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="抽象工厂模式" scheme="https://wanqbin.xyz/tags/%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Bridge模式【二】</title>
    <link href="https://wanqbin.xyz/2019/Bridge%E6%A8%A1%E5%BC%8F%E3%80%90%E4%BA%8C%E3%80%91/"/>
    <id>https://wanqbin.xyz/2019/Bridge模式【二】/</id>
    <published>2019-11-25T13:05:00.000Z</published>
    <updated>2019-11-25T13:12:03.274Z</updated>
    
    <content type="html"><![CDATA[<p>上篇：<a href="https://wanqbin.xyz/2019/Bridge%E6%A8%A1%E5%BC%8F%E3%80%90%E4%B8%80%E3%80%91/#more">Bridge模式（一）</a></p><p>刚开始考虑这些问题的时候，我觉得目前的困难可能只是由于使用了错误的继承层次造成的。因此，我尝试选择下图所示的另一种层次。</p><p><img src="/2019/Bridge模式【二】/bridge%E5%8F%A6%E4%B8%80%E7%A7%8D%E5%AE%9E%E7%8E%B0.PNG" alt="另一种实现"></p><p>我仍然用相同的四个类表示所有可能的组合，但是，因为先从不同的绘图程序派生不同的版本，所以DP1和DP2之间的冗余去掉了。</p><p>但是，糟糕的一点是，两种Rectangle和两种Circle之间的冗余却没办法去除，因为它们每一对都有相同的draw方法。</p><p>无论怎样解决，前面的类爆炸后性增长问题依然存在。</p><p>这里，我们开始思考Birdge模式要解决的问题是什么呢？</p><p>当存在一个抽象有不同实现时Bridge模式最为有用，它可以使抽象和实现相互独立地进行变化。</p><p>使抽象和实现相互独立地变化，将意味着我可以在不改变实现的情况下增加新的抽象。，反之亦然。</p><p>当前的解决方案并不允许这种独立地进行变化。我已经看到，创建一个支持独立变化的实现更好。</p><p>在进行设计以应对变化的过程中，应遵循两条基本策略：</p><ul><li>找出变化并封装之</li><li>优先使用对象聚集，而不是类继承</li></ul><p>我们按照这个过程对矩形绘图问题进行设计：</p><ul><li><p>首先，找到什么在发生变化。在这里，变化的是形状的种类和绘图程序的种类。而共同的概念是“形状”和“绘图程序”。</p><p><img src="/2019/Bridge模式【二】/Bridge%E6%A8%A1%E5%BC%8F%EF%BC%9A%E4%BB%80%E4%B9%88%E5%9C%A8%E5%8F%91%E7%94%9F%E5%8F%98%E5%8C%96.PNG" alt="什么在发生变化"></p><p>现在，我希望Shape类封装形状种类的概念。形状需要知道如何绘制自己，而Drawing对象负责画线和圆。我通过在类中定义方法来表示这些责任。</p></li><li><p>下一步是表示具体的变化。Shape类有矩形和圆形，绘图程序分别有一个基于DP1的对象（V1Drawing）和基于DP2的对象（V2Drawing）。</p><p><img src="/2019/Bridge模式【二】/Bridge%E6%A8%A1%E5%BC%8F%EF%BC%9A%E8%A1%A8%E7%A4%BA%E5%8F%98%E5%8C%96.PNG" alt="表示变化"></p><p>有了这两组类之后，还需要知道它们之间如何联系。我不想再在继承树中增加一组新的类，因为我知道这样做会导致什么情况。相反，我想看看是否能通过一组使用另外一组，将这些类联系起来（也就是说，遵循“优先使用对象聚集，而不是类继承”的要求）。问题是，该让哪组类使用另一组类呢？</p><p>考虑如下的可能性：Shape类使用Drawing程序，或者Drawing程序使用Shape类。</p><ul><li><p>首先考虑后一种情形。如果绘图程序能够直接绘制形状，它们必须对形状的一些情况有大致的了解：是什么，看起来如何。但这违反呢对象的一个基本原则：对象应该只对自己负责。</p><p>这样做还违反了封装。Drawing对象要绘制形状，必须知道Shape的具体信息（即Shape的种类）。因此，对象并不是真正对自己的行为负责。</p></li><li><p>现在考虑这样一种情形。如果让Shape类使用Drawing对象来绘制自己如何？Shape对象无需知道所用Drawing对象的类型，因为可以让Shape引用Drawing类，Shape对象仍然要负责绘图的过程。</p><p>这个方案如下图所示：<br><img src="/2019/Bridge模式【二】/Bridge%E6%A8%A1%E5%BC%8F%EF%BC%9A%E5%B0%86%E7%B1%BB%E8%81%94%E7%B3%BB%E8%B5%B7%E6%9D%A5.PNG" alt="将类联系起来"></p><p>在这个设计中，Shape类通过Drawing类具体实现自己的行为。其中略去了V1Drawing使用DP1程序、V2Drawing使用DP2程序的细节。下图增加了这些细节，以及保护方法drawLine和drawCircle，这两个方法分别调用Drawing()的drawLine方法和drawCircle()方法。</p><p><img src="/2019/Bridge模式【二】/Bridge%E6%A8%A1%E5%BC%8F%EF%BC%9AShape%E6%8A%BD%E8%B1%A1%E4%B8%8EDrawing%E5%AE%9E%E7%8E%B0%E7%9A%84%E5%88%86%E7%A6%BB.PNG" alt="Shape抽象和Drawing实现的分离"></p></li></ul></li></ul><blockquote><p>规则只在一个地方实现。</p></blockquote><p>换言之，如果做什么事情有一条规则，只实现一次。这通常会使代码中出现比较小的方法，所增加的代价很小，却消除了重复，而且经常可以预防将来可能出现的很多问题。重复的害处，不仅仅在于输入工作成倍增加，还因为将来将来有东西可能发生变化时，可能会忘记在所有需要的地方进行修改。</p><p><img src="/2019/Bridge模式【二】/Bridge%E6%A8%A1%E5%BC%8F%EF%BC%9A%E6%8A%BD%E8%B1%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E5%88%86%E7%A6%BB.PNG" alt="说明“抽象与实现分离”的类图"></p><p>从方法的角度来看，这与基于继承的实现非常相似。最大的区别在于，方法现在被放在不同的类中。</p><p>Bridge模式使我明白，将实现看成对象之外的东西，看出由对象所使用的东西，这样就使变化隐藏在实现中，与调用程序隔离了，从而提供了极大的只有自由。用这种方式设计对象，还能够看到将变化包含在不同的类层次中了。上图中左边的类层次包含了抽象中的变化，右边的类层次包含了实现这些抽象时包含的变化。</p><p><strong>Client.h</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Client</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Client(<span class="keyword">void</span>);</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ~Client(<span class="keyword">void</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>Client.cpp</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Client.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Shape.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Factory.h"</span></span></span><br><span class="line"></span><br><span class="line">Client::Client(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Client::~Client(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="keyword">static</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Shape **myShapes;</span><br><span class="line">    Factory myFactory;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// get Rectangles from some other source</span></span><br><span class="line">    myShapes= myFactory.getShapes();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i= <span class="number">0</span>; i &lt; <span class="keyword">sizeof</span>(myShapes)/ <span class="keyword">sizeof</span>(myShapes[<span class="number">0</span>]); i++)</span><br><span class="line">        myShapes[i]-&gt;draw();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Factory.h</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Shape.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Circle.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Rectangle.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Drawing.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"V1Drawing.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"V2Drawing.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Factory</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Factory(<span class="keyword">void</span>);</span><br><span class="line">    ~Factory(<span class="keyword">void</span>);</span><br><span class="line">    <span class="function">Shape** <span class="title">getShapes</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>Factory.cpp</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Factory.h"</span></span></span><br><span class="line"></span><br><span class="line">Factory::Factory(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Factory::~Factory(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Shape** Factory::getShapes ()</span><br><span class="line">&#123;</span><br><span class="line">    Shape **myShapes;</span><br><span class="line">    <span class="comment">// Figure out the shapes needed.</span></span><br><span class="line">    <span class="comment">// create them and put them in the array myShapes</span></span><br><span class="line">    <span class="keyword">return</span> myShapes;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Shape.h</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Drawing.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Shape</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Shape(Drawing *aDrawing);</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span></span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    Drawing *myDrawing;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">drawLine</span><span class="params">( <span class="keyword">double</span>, <span class="keyword">double</span>, <span class="keyword">double</span>, <span class="keyword">double</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">drawCircle</span><span class="params">( <span class="keyword">double</span>, <span class="keyword">double</span>, <span class="keyword">double</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ~Shape(<span class="keyword">void</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>Shape.cpp</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Shape.h"</span></span></span><br><span class="line"></span><br><span class="line">Shape::Shape(Drawing *aDrawing)</span><br><span class="line">&#123;</span><br><span class="line">    myDrawing= aDrawing;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Shape::~Shape(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> Shape::drawLine( <span class="keyword">double</span> x1,<span class="keyword">double</span> y1, <span class="keyword">double</span> x2,<span class="keyword">double</span> y2) </span><br><span class="line">&#123;</span><br><span class="line">   myDrawing-&gt;drawLine(x1,y1,x2,y2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> Shape::drawCircle( <span class="keyword">double</span> x,<span class="keyword">double</span> y,<span class="keyword">double</span> r) </span><br><span class="line">&#123;</span><br><span class="line">   myDrawing-&gt;drawCircle(x,y,r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Circle.h</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Shape.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span> :</span> <span class="keyword">public</span> Shape</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Circle(Drawing*, <span class="keyword">double</span>, <span class="keyword">double</span>, <span class="keyword">double</span>);</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">drawCircle</span><span class="params">(<span class="keyword">double</span>, <span class="keyword">double</span>, <span class="keyword">double</span>)</span></span>=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ~Circle(<span class="keyword">void</span>);</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">double</span> _x, _y, _r;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>Circle.cpp</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Circle.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Factory.h"</span></span></span><br><span class="line"></span><br><span class="line">Circle::Circle(Drawing *aDrawing, <span class="keyword">double</span> x, <span class="keyword">double</span> y, <span class="keyword">double</span> r) : Shape (aDrawing)</span><br><span class="line">&#123;</span><br><span class="line">    _x= x;</span><br><span class="line">    _y= y;</span><br><span class="line">    _r= r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Circle::~Circle(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> Circle::draw ()</span><br><span class="line">&#123;</span><br><span class="line">    drawCircle( _x, _y, _r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Rectangle.h</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#pragma once</span><br><span class="line">#include &quot;Shape.h&quot;</span><br><span class="line"></span><br><span class="line">class Rectangle : public  Shape</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    Rectangle(Drawing*, double, double, double, double);</span><br><span class="line">    virtual void drawLine(double, double, double, double)=0;</span><br><span class="line">    void draw();</span><br><span class="line">public:</span><br><span class="line">    ~Rectangle(void);</span><br><span class="line">private:</span><br><span class="line">    double _x1, _x2, _y1, _y2;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>Rectangle.cpp</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Rectangle.h"</span></span></span><br><span class="line"></span><br><span class="line">Rectangle::Rectangle(Drawing *aDrawing, <span class="keyword">double</span> x1, <span class="keyword">double</span> y1, <span class="keyword">double</span> x2, <span class="keyword">double</span> y2) : </span><br><span class="line">    Shape (aDrawing)</span><br><span class="line">&#123;</span><br><span class="line">    _x1= x1; _y1= y1; _x2= x2; _y2= y2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Rectangle::~Rectangle(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> Rectangle::draw()</span><br><span class="line">&#123;</span><br><span class="line">    drawLine( _x1, _y1, _x2, _y1);</span><br><span class="line">    drawLine( _x2, _y1, _x2, _y2);</span><br><span class="line">    drawLine( _x2, _y2, _x1, _y2);</span><br><span class="line">    drawLine( _x1, _y2, _x1, _y1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Drawing.h</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Drawing</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Drawing(<span class="keyword">void</span>);</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ~Drawing(<span class="keyword">void</span>);</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">drawLine</span><span class="params">( <span class="keyword">double</span>, <span class="keyword">double</span>, <span class="keyword">double</span>, <span class="keyword">double</span>)</span></span>=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">drawCircle</span><span class="params">( <span class="keyword">double</span>, <span class="keyword">double</span>, <span class="keyword">double</span>)</span></span>=<span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>Drawing.cpp</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Drawing.h"</span></span></span><br><span class="line"></span><br><span class="line">Drawing::Drawing(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Drawing::~Drawing(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>V1Drawing.h</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"drawing.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"DP1.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">V1Drawing</span> :</span> <span class="keyword">public</span> Drawing</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    V1Drawing(<span class="keyword">void</span>);</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ~V1Drawing(<span class="keyword">void</span>);</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">drawLine</span><span class="params">( <span class="keyword">double</span>, <span class="keyword">double</span>, <span class="keyword">double</span>, <span class="keyword">double</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">drawCircle</span><span class="params">( <span class="keyword">double</span>, <span class="keyword">double</span>, <span class="keyword">double</span>)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    DP1 myDP1;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>V1Drawing.cpp</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"V1Drawing.h"</span></span></span><br><span class="line"></span><br><span class="line">V1Drawing::V1Drawing(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">V1Drawing::~V1Drawing(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> V1Drawing::drawLine ( <span class="keyword">double</span> x1,<span class="keyword">double</span> y1, <span class="keyword">double</span> x2,<span class="keyword">double</span> y2) </span><br><span class="line">&#123;</span><br><span class="line">   DP1::draw_a_line(x1,y1,x2,y2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> V1Drawing::drawCircle (<span class="keyword">double</span> x,<span class="keyword">double</span> y,<span class="keyword">double</span> r) </span><br><span class="line">&#123;</span><br><span class="line">   DP1::draw_a_circle(x,y,r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>V2Drawing.h</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"drawing.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"DP2.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">V2Drawing</span> :</span> <span class="keyword">public</span> Drawing</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    V2Drawing(<span class="keyword">void</span>);</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ~V2Drawing(<span class="keyword">void</span>);</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">drawLine</span><span class="params">( <span class="keyword">double</span>, <span class="keyword">double</span>, <span class="keyword">double</span>, <span class="keyword">double</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">drawCircle</span><span class="params">( <span class="keyword">double</span>, <span class="keyword">double</span>, <span class="keyword">double</span>)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    DP2 myDP2;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>V2Drawing.cpp</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"V2Drawing.h"</span></span></span><br><span class="line"></span><br><span class="line">V2Drawing::V2Drawing(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">V2Drawing::~V2Drawing(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> V2Drawing::drawLine (<span class="keyword">double</span> x1,<span class="keyword">double</span> y1, <span class="keyword">double</span> x2,<span class="keyword">double</span> y2) </span><br><span class="line">&#123;</span><br><span class="line">   <span class="comment">// arguments are different in DP2</span></span><br><span class="line">   <span class="comment">// and must be rearranged</span></span><br><span class="line">   DP2::drawline(x1,x2,y1,y2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> V2Drawing::drawCircle ( <span class="keyword">double</span> x, <span class="keyword">double</span> y,<span class="keyword">double</span> r) </span><br><span class="line">&#123;</span><br><span class="line">   DP2::drawcircle(x,y,r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>DP1.h</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DP1</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    DP1(<span class="keyword">void</span>);</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">draw_a_line</span><span class="params">( <span class="keyword">double</span>, <span class="keyword">double</span>, <span class="keyword">double</span>, <span class="keyword">double</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">draw_a_circle</span><span class="params">( <span class="keyword">double</span>, <span class="keyword">double</span>, <span class="keyword">double</span>)</span></span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ~DP1(<span class="keyword">void</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>DP1.cpp</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"DP1.h"</span></span></span><br><span class="line"></span><br><span class="line">DP1::DP1(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">DP1::~DP1(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> DP1::draw_a_line( <span class="keyword">double</span> x1, <span class="keyword">double</span> y1, <span class="keyword">double</span> x2, <span class="keyword">double</span> y2)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// draw the line</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> DP1::draw_a_circle( <span class="keyword">double</span> x, <span class="keyword">double</span> y, <span class="keyword">double</span> r)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// draw the circle</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>DP2.h</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"DP2.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DP2</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    DP2(<span class="keyword">void</span>);</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">drawline</span><span class="params">( <span class="keyword">double</span>, <span class="keyword">double</span>, <span class="keyword">double</span>, <span class="keyword">double</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">drawcircle</span><span class="params">( <span class="keyword">double</span>, <span class="keyword">double</span>, <span class="keyword">double</span>)</span></span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ~DP2(<span class="keyword">void</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>DP2.cpp</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"DP2.h"</span></span></span><br><span class="line"></span><br><span class="line">DP2::DP2(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">DP2::~DP2(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> DP2::drawline( <span class="keyword">double</span> x1, <span class="keyword">double</span> x2, <span class="keyword">double</span> y1, <span class="keyword">double</span> y2)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// draw the line</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> DP2::drawcircle( <span class="keyword">double</span> x, <span class="keyword">double</span> y, <span class="keyword">double</span> r)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// draw the circle</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="三、Birdge模式：关键特征"><a href="#三、Birdge模式：关键特征" class="headerlink" title="三、Birdge模式：关键特征"></a>三、Birdge模式：关键特征</h2><ul><li>意图：将一组实现与另一组使用它们的对象分离</li><li>问题：一个抽象类的派生类必须使用多个实现，但不能出现类数量爆炸性增长。</li><li>解决方案：为所有实现定义一个接口，供抽象类的所有派生类使用。</li><li>参与者与协作者：Abstraction为要实现的对象定义接口，Implementor为具体实现类定义接口。Abstarction的派生类使用Implementor的派生类，却无需知道自己具体使用哪一个ConcreteImplementor。</li><li>效果：实现与使用的对象解耦，提供了可扩展性，客户对象无需操心实现问题。</li><li>实现：<ul><li>将实现封装在一个抽象类中</li><li>在要实现的抽象的基类中包含一个实现的句柄</li></ul></li></ul><p>在使用Bridge模式时，几个抽象对象有时候可能共享实现对象。</p><ul><li>在C#和Java中，这不会有什么问题；当所有的抽象对象销毁之后，垃圾回收器会发现不再需要实现对象，并清理它们。</li><li>在C++中，我必须自己管理实现对象。办法有很多：可能是维护一个引用计数器，或者使用Singleton模式。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;上篇：&lt;a href=&quot;https://wanqbin.xyz/2019/Bridge%E6%A8%A1%E5%BC%8F%E3%80%90%E4%B8%80%E3%80%91/#more&quot;&gt;Bridge模式（一）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;刚开始考虑这些问题的时候，我觉得目前
      
    
    </summary>
    
      <category term="设计模式" scheme="https://wanqbin.xyz/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="Bridge模式" scheme="https://wanqbin.xyz/tags/Bridge%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="桥接模式" scheme="https://wanqbin.xyz/tags/%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="对象结构型模式" scheme="https://wanqbin.xyz/tags/%E5%AF%B9%E8%B1%A1%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Bridge模式【一】</title>
    <link href="https://wanqbin.xyz/2019/Bridge%E6%A8%A1%E5%BC%8F%E3%80%90%E4%B8%80%E3%80%91/"/>
    <id>https://wanqbin.xyz/2019/Bridge模式【一】/</id>
    <published>2019-11-25T11:11:00.000Z</published>
    <updated>2019-11-25T11:15:19.519Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、Bridge模式"><a href="#一、Bridge模式" class="headerlink" title="一、Bridge模式"></a>一、Bridge模式</h2><blockquote><p>将抽象部分与它的实现部分分离，使它们都可以独立地变化。</p><p>​                                                                                                                                                                ——《设计模式》</p></blockquote><p>解耦（decouple）：是指让各种事物互相独立地行事，或者至少明确地声明之间地关系。</p><p>抽象（abstraction)：是指不同事物之间概念上地联系方式。</p><p>一直以为<strong>实现</strong>就是实际构建抽象的方式。令我不解的是，怎样才能将抽象与其实现的具体方式分离开呢？</p><p>其实我的迷惑主要是因为误解了实现的含义。这里<strong>实现</strong>指的是抽象类及其派生类用来实现自己的对象（而不是抽象类的派生类，这些派生类被称为具体类）。</p><h2 id="二、案例研究"><a href="#二、案例研究" class="headerlink" title="二、案例研究"></a>二、案例研究</h2><p>假设我接受了一个任务：编写一个程序，使用两个绘图程序之一绘制矩形。我被告知，实例化矩形的时候，它会知道应该使用绘图程序1（DP1)还是绘图程序2（DP2）。</p><p>其中矩形是用两对点来定义的。</p><p>绘图程序的区别：</p><table><thead><tr><th></th><th>DP1</th><th>DP2</th></tr></thead><tbody><tr><td>用于画线</td><td>draw_a_line(x1,x2,y1,y2)</td><td>drawline(x1,x2,y1,y2)</td></tr><tr><td>用于画圆</td><td>draw_a_circle(x,y,r)</td><td>drawcircle(x,y,r)</td></tr></tbody></table><p>分析师做出规定，绘制矩形的代码并不需要操心自己应该使用那种绘制程序。我想到，因为矩形在实例化的时候会知道使用哪个绘图程序，所以可以有两种不同的矩形对象：一种使用DP1，一种使用DP2。每种矩形对象都有一个绘制方法。</p><p><img src="/2019/Bridge模式【一】/%E7%9F%A9%E5%BD%A2%E5%92%8C%E7%BB%98%E5%9B%BE%E7%A8%8B%E5%BA%8F%E7%9A%84%E8%AE%BE%E8%AE%A1.PNG" alt="矩形和绘图程序的设计"></p><p>通过引入一个抽象类Rectangle，我可以利用这样一个事实，不同Rectangle之间唯一的差异在于如何实现drawLine方法，V1Rectangle类是通过一个DP1对象的引用，使用该DP1对象的draw_a_line方法实现的。V2Rectangle类是通过一个DP2对象的引用，使用该DP2对象的drawline方法实现的。无论这样，通过实例化正确的Rectangle，我不必再操心这种差异。</p><p><strong>Rectangle.h</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Rectangle(<span class="keyword">double</span>, <span class="keyword">double</span>, <span class="keyword">double</span>, <span class="keyword">double</span>);</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">drawLine</span><span class="params">(<span class="keyword">double</span>, <span class="keyword">double</span>, <span class="keyword">double</span>, <span class="keyword">double</span>)</span></span>=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ~Rectangle(<span class="keyword">void</span>);</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">double</span> _x1, _x2, _y1, _y2;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>Rectangle.cpp</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Rectangle.h"</span></span></span><br><span class="line"></span><br><span class="line">Rectangle::Rectangle(<span class="keyword">double</span> x1, <span class="keyword">double</span> y1, <span class="keyword">double</span> x2, <span class="keyword">double</span> y2) </span><br><span class="line">&#123;</span><br><span class="line">    _x1= x1; _y1= y1; _x2= x2; _y2= y2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Rectangle::~Rectangle(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> Rectangle::draw()</span><br><span class="line">&#123;</span><br><span class="line">    drawLine( _x1, _y1, _x2, _y1);</span><br><span class="line">    drawLine( _x2, _y1, _x2, _y2);</span><br><span class="line">    drawLine( _x2, _y2, _x1, _y2);</span><br><span class="line">    drawLine( _x1, _y2, _x1, _y1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>V1Rectangle.h</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Rectangle.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">V1Rectangle</span> :</span> <span class="keyword">public</span> Rectangle</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    V1Rectangle(<span class="keyword">double</span>, <span class="keyword">double</span>, <span class="keyword">double</span>, <span class="keyword">double</span>);</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">drawLine</span><span class="params">( <span class="keyword">double</span>, <span class="keyword">double</span>, <span class="keyword">double</span>, <span class="keyword">double</span>)</span></span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ~V1Rectangle(<span class="keyword">void</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>V1Rectangle.cpp</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"V1Rectangle.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"DP1.h"</span></span></span><br><span class="line"></span><br><span class="line">V1Rectangle::V1Rectangle(<span class="keyword">double</span> x1, <span class="keyword">double</span> y1, <span class="keyword">double</span> x2, <span class="keyword">double</span> y2) : </span><br><span class="line">    Rectangle(x1, y1, x2, y2)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">V1Rectangle::~V1Rectangle(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> V1Rectangle::drawLine( <span class="keyword">double</span> x1, <span class="keyword">double</span> y1, <span class="keyword">double</span> x2, <span class="keyword">double</span> y2)</span><br><span class="line">&#123;</span><br><span class="line">    DP1::draw_a_line( x1, y1, x2, y2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>V2Rectangle.h</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Rectangle.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">V2Rectangle</span> :</span> <span class="keyword">public</span> Rectangle</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    V2Rectangle(<span class="keyword">double</span>, <span class="keyword">double</span>, <span class="keyword">double</span>, <span class="keyword">double</span>);</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">drawLine</span><span class="params">( <span class="keyword">double</span>, <span class="keyword">double</span>, <span class="keyword">double</span>, <span class="keyword">double</span>)</span></span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ~V2Rectangle(<span class="keyword">void</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>V2Rectangle.cpp</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"V2Rectangle.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"DP2.h"</span></span></span><br><span class="line"></span><br><span class="line">V2Rectangle::V2Rectangle(<span class="keyword">double</span> x1, <span class="keyword">double</span> y1, <span class="keyword">double</span> x2, <span class="keyword">double</span> y2) : </span><br><span class="line">    Rectangle(x1, y1, x2, y2)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">V2Rectangle::~V2Rectangle(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> V2Rectangle::drawLine( <span class="keyword">double</span> x1, <span class="keyword">double</span> y1, <span class="keyword">double</span> x2, <span class="keyword">double</span> y2)</span><br><span class="line">&#123;</span><br><span class="line">    DP2::drawline( x1, y1, x2, y2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>DP1.h</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DP1</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    DP1(<span class="keyword">void</span>);</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">draw_a_line</span><span class="params">( <span class="keyword">double</span>, <span class="keyword">double</span>, <span class="keyword">double</span>, <span class="keyword">double</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">draw_a_circle</span><span class="params">( <span class="keyword">double</span>, <span class="keyword">double</span>, <span class="keyword">double</span>)</span></span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ~DP1(<span class="keyword">void</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>DP1.cpp</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"DP1.h"</span></span></span><br><span class="line"></span><br><span class="line">DP1::DP1(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">DP1::~DP1(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> DP1::draw_a_line( <span class="keyword">double</span> x1, <span class="keyword">double</span> y1, <span class="keyword">double</span> x2, <span class="keyword">double</span> y2)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// draw the line</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> DP1::draw_a_circle( <span class="keyword">double</span> x, <span class="keyword">double</span> y, <span class="keyword">double</span> r)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// draw the circle</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>DP2.h</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DP2</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    DP2(<span class="keyword">void</span>);</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">drawline</span><span class="params">( <span class="keyword">double</span>, <span class="keyword">double</span>, <span class="keyword">double</span>, <span class="keyword">double</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">drawcircle</span><span class="params">( <span class="keyword">double</span>, <span class="keyword">double</span>, <span class="keyword">double</span>)</span></span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ~DP2(<span class="keyword">void</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>DP2.cpp</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"DP2.h"</span></span></span><br><span class="line"></span><br><span class="line">DP2::DP2(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">DP2::~DP2(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> DP2::drawline( <span class="keyword">double</span> x1, <span class="keyword">double</span> x2, <span class="keyword">double</span> y1, <span class="keyword">double</span> y2)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// draw the line</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> DP2::drawcircle( <span class="keyword">double</span> x, <span class="keyword">double</span> y, <span class="keyword">double</span> r)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// draw the circle</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在，假设在代码完成之后。需求发生了变化。我现在需要支持另一种形状——这次是圆形，但是需求还是要求集合对象无需知道Rectangle和Circle的差异。</p><p>我想到可以在类层次中增加一层，就可以在已经使用的方法之上进行扩展了。我需要增加一个名为Shape的新类，并从中派生Rectangle类和Circle类。这样，Client对象可以只引用Shape对象，而不必考虑说给的是哪种形状。</p><p>例如，我可以从上面的设计开始，然后对每一种Shape类，都用各自的绘图程序实现，为Rectangle类派生一个DP1版本和一个DP2版本，为Circle类也派生一个DP1版本和一个DP2版本。最终的设计如下：</p><p><img src="/2019/Bridge模式【一】/%E7%9B%B4%E6%88%AA%E4%BA%86%E5%BD%93%E7%9A%84%E6%96%B9%E5%BC%8F%E5%AE%9E%E7%8E%B0%E4%B8%A4%E7%A7%8D%E5%BD%A2%E5%BC%8F%E5%BD%A2%E7%8A%B6%E5%92%8C%E4%B8%A4%E4%B8%AA%E7%BB%98%E5%9B%BE%E7%A8%8B%E5%BA%8F.PNG" alt="一种直接了当的方法：实现两种形状和两个绘图程序"></p><p>实现Rectangle类的方法与实现Circle类的方式相同，但是，这一次实现draw方法使用的是drawCircle方法，而不是drawLine方法。</p><p><strong>Shape.h</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Shape</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Shape(<span class="keyword">void</span>);</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span></span>= <span class="number">0</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ~Shape(<span class="keyword">void</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>Shape.cpp</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Shape.h"</span></span></span><br><span class="line"></span><br><span class="line">Shape::Shape(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Shape::~Shape(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Circle.h</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Shape.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span> :</span></span><br><span class="line">    <span class="keyword">public</span> Shape</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Circle(<span class="keyword">double</span>, <span class="keyword">double</span>, <span class="keyword">double</span>);</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">drawCircle</span><span class="params">(<span class="keyword">double</span>, <span class="keyword">double</span>, <span class="keyword">double</span>)</span></span>=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ~Circle(<span class="keyword">void</span>);</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">double</span> _x, _y, _r;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>Circle.cpp</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Circle.h"</span></span></span><br><span class="line"></span><br><span class="line">Circle::Circle(<span class="keyword">double</span> x, <span class="keyword">double</span> y, <span class="keyword">double</span> r)</span><br><span class="line">&#123;</span><br><span class="line">    _x= x;</span><br><span class="line">    _y= y;</span><br><span class="line">    _r= r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Circle::~Circle(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> Circle::draw ()</span><br><span class="line">&#123;</span><br><span class="line">    drawCircle( _x, _y, _r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Rectangle.h</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Shape.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> :</span> <span class="keyword">public</span>  Shape</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Rectangle(<span class="keyword">double</span>, <span class="keyword">double</span>, <span class="keyword">double</span>, <span class="keyword">double</span>);</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">drawLine</span><span class="params">(<span class="keyword">double</span>, <span class="keyword">double</span>, <span class="keyword">double</span>, <span class="keyword">double</span>)</span></span>=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ~Rectangle(<span class="keyword">void</span>);</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">double</span> _x1, _x2, _y1, _y2;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>Rectangle.cpp</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Rectangle.h"</span></span></span><br><span class="line"></span><br><span class="line">Rectangle::Rectangle(<span class="keyword">double</span> x1, <span class="keyword">double</span> y1, <span class="keyword">double</span> x2, <span class="keyword">double</span> y2) </span><br><span class="line">&#123;</span><br><span class="line">    _x1= x1; _y1= y1; _x2= x2; _y2= y2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Rectangle::~Rectangle(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> Rectangle::draw()</span><br><span class="line">&#123;</span><br><span class="line">    drawLine( _x1, _y1, _x2, _y1);</span><br><span class="line">    drawLine( _x2, _y1, _x2, _y2);</span><br><span class="line">    drawLine( _x2, _y2, _x1, _y2);</span><br><span class="line">    drawLine( _x1, _y2, _x1, _y1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>V1Circle.h</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Circle.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">V1Circle</span> :</span> <span class="keyword">public</span> Circle</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    V1Circle(<span class="keyword">double</span>, <span class="keyword">double</span>, <span class="keyword">double</span>);</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">drawCircle</span><span class="params">( <span class="keyword">double</span>, <span class="keyword">double</span>, <span class="keyword">double</span>)</span></span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ~V1Circle(<span class="keyword">void</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>V1Circle.cpp</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"V1Circle.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"DP1.h"</span></span></span><br><span class="line"></span><br><span class="line">V1Circle::V1Circle(<span class="keyword">double</span> x, <span class="keyword">double</span> y, <span class="keyword">double</span> r) : Circle( x, y, r)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">V1Circle::~V1Circle(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> V1Circle::drawCircle ( <span class="keyword">double</span> x, <span class="keyword">double</span> y, <span class="keyword">double</span> r)</span><br><span class="line">&#123;</span><br><span class="line">    DP1::draw_a_circle( x, y, r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>V1Rectangle.h</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Rectangle.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">V1Rectangle</span> :</span> <span class="keyword">public</span> Rectangle</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    V1Rectangle(<span class="keyword">double</span>, <span class="keyword">double</span>, <span class="keyword">double</span>, <span class="keyword">double</span>);</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">drawLine</span><span class="params">( <span class="keyword">double</span>, <span class="keyword">double</span>, <span class="keyword">double</span>, <span class="keyword">double</span>)</span></span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ~V1Rectangle(<span class="keyword">void</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>V1Rectangle.cpp</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"V1Rectangle.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"DP1.h"</span></span></span><br><span class="line"></span><br><span class="line">V1Rectangle::V1Rectangle(<span class="keyword">double</span> x1, <span class="keyword">double</span> y1, <span class="keyword">double</span> x2, <span class="keyword">double</span> y2) : </span><br><span class="line">    Rectangle(x1, y1, x2, y2)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">V1Rectangle::~V1Rectangle(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> V1Rectangle::drawLine( <span class="keyword">double</span> x1, <span class="keyword">double</span> y1, <span class="keyword">double</span> x2, <span class="keyword">double</span> y2)</span><br><span class="line">&#123;</span><br><span class="line">    DP1::draw_a_line( x1, y1, x2, y2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>V2Circle.h</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Circle.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">V2Circle</span> :</span> <span class="keyword">public</span> Circle</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    V2Circle(<span class="keyword">double</span>, <span class="keyword">double</span>, <span class="keyword">double</span>);</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">drawCircle</span><span class="params">( <span class="keyword">double</span>, <span class="keyword">double</span>, <span class="keyword">double</span>)</span></span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ~V2Circle(<span class="keyword">void</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>V2Circle.cpp</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"V2Circle.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"DP2.h"</span></span></span><br><span class="line"></span><br><span class="line">V2Circle::V2Circle(<span class="keyword">double</span> x, <span class="keyword">double</span> y, <span class="keyword">double</span> r) : Circle( x, y, r)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">V2Circle::~V2Circle(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> V2Circle::drawCircle ( <span class="keyword">double</span> x, <span class="keyword">double</span> y, <span class="keyword">double</span> r)</span><br><span class="line">&#123;</span><br><span class="line">    DP2::drawcircle( x, y, r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>V2Rectangle.h</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Rectangle.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">V2Rectangle</span> :</span> <span class="keyword">public</span> Rectangle</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    V2Rectangle(<span class="keyword">double</span>, <span class="keyword">double</span>, <span class="keyword">double</span>, <span class="keyword">double</span>);</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">drawLine</span><span class="params">( <span class="keyword">double</span>, <span class="keyword">double</span>, <span class="keyword">double</span>, <span class="keyword">double</span>)</span></span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ~V2Rectangle(<span class="keyword">void</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>V2Rectangle.cpp</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"V2Rectangle.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"DP2.h"</span></span></span><br><span class="line"></span><br><span class="line">V2Rectangle::V2Rectangle(<span class="keyword">double</span> x1, <span class="keyword">double</span> y1, <span class="keyword">double</span> x2, <span class="keyword">double</span> y2) : </span><br><span class="line">    Rectangle(x1, y1, x2, y2)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">V2Rectangle::~V2Rectangle(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> V2Rectangle::drawLine( <span class="keyword">double</span> x1, <span class="keyword">double</span> y1, <span class="keyword">double</span> x2, <span class="keyword">double</span> y2)</span><br><span class="line">&#123;</span><br><span class="line">    DP2::drawline( x1, y1, x2, y2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>DP1.h</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DP1</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    DP1(<span class="keyword">void</span>);</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">draw_a_line</span><span class="params">( <span class="keyword">double</span>, <span class="keyword">double</span>, <span class="keyword">double</span>, <span class="keyword">double</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">draw_a_circle</span><span class="params">( <span class="keyword">double</span>, <span class="keyword">double</span>, <span class="keyword">double</span>)</span></span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ~DP1(<span class="keyword">void</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>DP1.cpp</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"DP1.h"</span></span></span><br><span class="line"></span><br><span class="line">DP1::DP1(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">DP1::~DP1(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> DP1::draw_a_line( <span class="keyword">double</span> x1, <span class="keyword">double</span> y1, <span class="keyword">double</span> x2, <span class="keyword">double</span> y2)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// draw the line</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> DP1::draw_a_circle( <span class="keyword">double</span> x, <span class="keyword">double</span> y, <span class="keyword">double</span> r)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// draw the circle</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>DP2.h</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DP2</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    DP2(<span class="keyword">void</span>);</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">drawline</span><span class="params">( <span class="keyword">double</span>, <span class="keyword">double</span>, <span class="keyword">double</span>, <span class="keyword">double</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">drawcircle</span><span class="params">( <span class="keyword">double</span>, <span class="keyword">double</span>, <span class="keyword">double</span>)</span></span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ~DP2(<span class="keyword">void</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>DP2.cpp</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"DP2.h"</span></span></span><br><span class="line"></span><br><span class="line">DP2::DP2(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">DP2::~DP2(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> DP2::drawline( <span class="keyword">double</span> x1, <span class="keyword">double</span> x2, <span class="keyword">double</span> y1, <span class="keyword">double</span> y2)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// draw the line</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> DP2::drawcircle( <span class="keyword">double</span> x, <span class="keyword">double</span> y, <span class="keyword">double</span> r)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// draw the circle</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然类图中似乎有很多对象，但实际上，只需要处理三个对象：</p><ul><li>使用矩形的Client对象</li><li>V1Rectangle对象</li><li>绘图程序DP1对象</li></ul><p>但是，这个办法带来了新的问题。准确地说，这个办法存在“组合爆炸”问题。</p><ul><li>对于类图中V1Rectangle这一行的类，表示的是Shape的4个具体类型。</li><li>如果我另外还有一个绘图程序，也就是说实现上又有一种新的变化，会怎么样呢？将会有6种不同类型的Shape（具体类型）</li><li>如果我还有另一类型的Shape，也就是说另一种概念上的变化，会怎么样呢？将会有9中不同类型的Shape（3个概念上的Shape，3个绘图程序）</li></ul><p>于是，类爆炸性增长的问题出现了，因为这个解决方案中抽象（Shape）与其实现（绘图程序）是紧耦合的。每种形状都必须知道自己用的是哪种绘图程序。需要有一种方式将抽象上的变化和实际上的变化分开，从而使类的数量仅仅是线性的增加。</p><p>这正是Bridge模式的意图：将抽象与实现解耦，使它们都可以独立地变化。</p><p>问问自己这个设计还有什么毛病？</p><ul><li>看上去是否存在冗余？</li><li>是高内聚还是低内聚？</li><li>是紧耦合还是松耦合？</li></ul><p>“为每种变化使用不同的特化”（继承）到“将变化转移到使用或拥有这种变化的对象中”（组合）</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、Bridge模式&quot;&gt;&lt;a href=&quot;#一、Bridge模式&quot; class=&quot;headerlink&quot; title=&quot;一、Bridge模式&quot;&gt;&lt;/a&gt;一、Bridge模式&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;将抽象部分与它的实现部分分离，使它们都可以独立地变
      
    
    </summary>
    
      <category term="设计模式" scheme="https://wanqbin.xyz/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="Bridge模式" scheme="https://wanqbin.xyz/tags/Bridge%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="桥接模式" scheme="https://wanqbin.xyz/tags/%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="对象结构型模式" scheme="https://wanqbin.xyz/tags/%E5%AF%B9%E8%B1%A1%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Strategy模式</title>
    <link href="https://wanqbin.xyz/2019/Strategy%E6%A8%A1%E5%BC%8F/"/>
    <id>https://wanqbin.xyz/2019/Strategy模式/</id>
    <published>2019-11-25T11:04:00.000Z</published>
    <updated>2019-11-25T11:09:59.672Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、Strategy模式"><a href="#一、Strategy模式" class="headerlink" title="一、Strategy模式"></a>一、Strategy模式</h2><blockquote><p>定义一系列的算法，把它们一个个封装起来，并且使他们可相互替换。Strategy模式使算法可独立于使用它的客户而变化。</p><p>​                                                                                                                                                                                                ——《设计模式》</p></blockquote><p>Strategy模式以下列几条原则为基础：</p><ul><li>对象都具有职责</li><li>这些职责不同的具体实现使通过多态的使用完成的</li><li>概念上相同的算法具有多个不同的实现，需要进行管理</li></ul><p>将问题域中的各个行为互相分离开来——也就是说，将它们解耦，使一个好的设计。这使我们可以修改负责某一行为的类，不会对其他类产生不良影响。</p><h2 id="二、电子商务系统案例研究"><a href="#二、电子商务系统案例研究" class="headerlink" title="二、电子商务系统案例研究"></a>二、电子商务系统案例研究</h2><p>我们考虑这样一个国际电子商务订单处理系统。这个系统必须能够处理许多不同国家的订单。</p><h3 id="最初的需求"><a href="#最初的需求" class="headerlink" title="最初的需求"></a>最初的需求</h3><p>在这个系统的总架构中有一个控制器对象，用于处理销售请求。它能够确认何时有人在请求销售订单，并将请求转发给SalesOrder对象进行订单处理。</p><p><img src="/2019/Strategy模式/%E7%94%B5%E5%AD%90%E5%95%86%E5%8A%A1%E8%AE%A2%E5%8D%95%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84.PNG" alt="电子商务系统的订单体系结构"></p><p>SalesOrder对象的功能包括：</p><ul><li>允许客户通过GUI填写订单</li><li>处理税额的计算</li><li>处理订单，打印销售收据</li></ul><h3 id="处理新的需求"><a href="#处理新的需求" class="headerlink" title="处理新的需求"></a>处理新的需求</h3><p>如果此时我收到了一个新需求，需要修改处理税额的办法。如果我必须处理国外的订单税额。我至少需要添加新的税额计算规则。</p><p>候选方案：</p><ul><li>复制和粘贴</li><li>使用switch或if语句，用一个变量指定各种情况</li><li>使用函数指针或委托（让另一个代表每一种情况）</li><li>继承（让派生类用新的方式处理）</li><li>将整个功能委托给新的对象。</li></ul><p>这里如果使用switch或if等条件语句，分支的流向将会变得模糊。</p><p>C++中的函数指针和C#中的委托都可以用来将代码隐藏在精巧、紧凑、内聚的函数之中，但是，函数指针和委托无法维持每个对象的状态，因此其使用也是受限的。</p><p>继承经常被人误用，这使它的名声不佳。其实继承本身并没有什么问题。</p><p>当面向对象设计成为主流时，“重用”曾经被吹捧为它的主要优点之一。为了实现“重用”，我们总是强调应该找到已有的东西，用派生类的形式对其进行小幅修改。</p><p>在我们的这个例子中，可以试图重用现有的SalesOrder对象。我可以将新缴税规则看成新种类的销售订单，只是缴税规则不同。例如，对于加拿大的订单，可以从SalesOrder派生名为CanadianSalesOrder的新类，改写缴税规则。如下所示：</p><p><img src="/2019/Strategy模式/Strategy%E6%A8%A1%E5%BC%8F%E7%BB%A7%E6%89%BF.PNG" alt="销售订单框架"></p><p>采用这种方法的苦难指出在于，它这次能奏效，但是无法次次奏效。比如，如果要处理德国的订单，或者应对其他方面发生的变化（比如日期格式，语言和运费规则），我们构建的继承层次将无法轻松地应对。诸如此类地反复特化，要么会使代码变得无法理解，要么产生冗余。人们对面向对象设计进程有一种抱怨：特化技术最终总是会产生太深地继承层次。糟糕的是，继承层次太深，会导致程序难以理解（低内聚）、存在冗余、难以测试而且多个概念耦合在一起。无怪乎许多人认为面向对象有些言过其实——尤其是这一切都是因为遵循了通用的面向对象“重用”要求。</p><p>根据这种方法，应该这样做：</p><ul><li>寻找变化，并将它封装在一个单独的类中</li><li>将这个类包含在另一个类中</li></ul><p>在本例中，已经确定缴税规则是变化的。“将它封装”就意味着创建一个抽象类定义入股哦在概念上完成税额计算，然后为每种变化派生具体类。也就是说，可以创建一个CalcTax对象，为完成税额计算这一任务定义接口。然后可以由它派生所需的特定版本。</p><p><img src="/2019/Strategy模式/%E5%B0%81%E8%A3%85%E7%BC%B4%E7%A8%8E%E8%A7%84%E5%88%99.PNG" alt="封装缴税规则"></p><p>接下来，应该使用组合取代继承，。这意味着用不着再创建不同版本的销售订单（使用继承），可以用组合来包含变化。也就是说，只有一个SalesOrder类，让它包含处理变化的CalcTax类。如下所示：</p><p><img src="/2019/Strategy模式/%E7%94%A8%E7%BB%84%E5%90%88%E4%BB%A3%E6%9B%BF%E7%BB%A7%E6%89%BF.PNG" alt="用组合代替继承"></p><p>实现Strategy模式：</p><p> <strong>TaxController.h</strong> </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"CalcTax.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TaskController</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    TaskController(<span class="keyword">void</span>);</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">process</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">CalcTax *<span class="title">getTaxRulesForCountry</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ~TaskController(<span class="keyword">void</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>TaxController.cpp</strong> </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">include <span class="string">"TaskController.h"</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"SalesOrder.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"CalcTax.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"USTax.h"</span></span></span><br><span class="line"></span><br><span class="line">TaskController::TaskController(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">TaskController::~TaskController(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> TaskController::process ()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// this code is an emulation of a </span></span><br><span class="line">    <span class="comment">// processing task controller</span></span><br><span class="line">    <span class="comment">// . . .</span></span><br><span class="line">    <span class="comment">// figure out which country you are in</span></span><br><span class="line">    CalcTax *myTax;</span><br><span class="line">    myTax= getTaxRulesForCountry();</span><br><span class="line">    SalesOrder *mySO= <span class="keyword">new</span> SalesOrder();</span><br><span class="line">    mySO-&gt;process( myTax);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">CalcTax *TaskController::getTaxRulesForCountry() </span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// In real life, get the tax rules based on</span></span><br><span class="line">    <span class="comment">// country you are in.  You may have the</span></span><br><span class="line">    <span class="comment">// logic here or you may have it in a</span></span><br><span class="line">    <span class="comment">// configuration file</span></span><br><span class="line">    <span class="comment">// Here, just return a USTax so this </span></span><br><span class="line">    <span class="comment">// will compile.</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> USTax;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> <strong>SalesOrder.h</strong> </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"CalcTax.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SalesOrder</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    SalesOrder(<span class="keyword">void</span>);</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">process</span> <span class="params">(CalcTax *TaxToUse)</span></span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ~SalesOrder(<span class="keyword">void</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p> <strong>SalesOrder.cpp</strong> </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"SalesOrder.h"</span></span></span><br><span class="line"></span><br><span class="line">SalesOrder::SalesOrder(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SalesOrder::~SalesOrder(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> SalesOrder::process (CalcTax *taxToUse)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">long</span> itemNumber= <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">double</span> price= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// given the tax object to use</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// . . .</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// calculate tax</span></span><br><span class="line">    <span class="keyword">double</span> tax= taxToUse-&gt;taxAmount( itemNumber, price);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> <strong>CalcTax.h</strong> </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CalcTax</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    CalcTax(<span class="keyword">void</span>);</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="keyword">virtual</span> <span class="title">taxAmount</span><span class="params">( <span class="keyword">long</span>, <span class="keyword">double</span>)</span></span>= <span class="number">0</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ~CalcTax(<span class="keyword">void</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p> <strong>CalcTax.cpp</strong> </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"CalcTax.h"</span></span></span><br><span class="line"></span><br><span class="line">CalcTax::CalcTax(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">CalcTax::~CalcTax(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> <strong>CanTax.h</strong> </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"calctax.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CanTax</span> :</span></span><br><span class="line">    <span class="keyword">public</span> CalcTax</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    CanTax(<span class="keyword">void</span>);</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">taxAmount</span><span class="params">( <span class="keyword">long</span>, <span class="keyword">double</span>)</span></span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ~CanTax(<span class="keyword">void</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p> <strong>CanTax.cpp</strong> </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"CanTax.h"</span></span></span><br><span class="line"></span><br><span class="line">CanTax::CanTax(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">CanTax::~CanTax(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">double</span> CanTax::taxAmount (<span class="keyword">long</span> itemSold, <span class="keyword">double</span> price) </span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// in real life, figure out tax according to</span></span><br><span class="line">    <span class="comment">// the rules in Canada and return it</span></span><br><span class="line">    <span class="comment">// here, return 0 so this will compile</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0.0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> <strong>USTax.h</strong> </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"calctax.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">USTax</span> :</span></span><br><span class="line">    <span class="keyword">public</span> CalcTax</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    USTax(<span class="keyword">void</span>);</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">taxAmount</span><span class="params">( <span class="keyword">long</span>, <span class="keyword">double</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ~USTax(<span class="keyword">void</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p> <strong>USTax.cpp</strong> </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"USTax.h"</span></span></span><br><span class="line"></span><br><span class="line">USTax::USTax(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">USTax::~USTax(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">double</span> USTax::taxAmount (<span class="keyword">long</span> itemSold, <span class="keyword">double</span> price) </span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// in real life, figure out tax according to</span></span><br><span class="line">    <span class="comment">// the rules in the US and return it</span></span><br><span class="line">    <span class="comment">// here, return 0 so this will compile</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0.0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种方法的一个优点在于提高了内聚度。销售税有专门的类进行处理。还有一个优点是：在有新的缴税需求是，只需从CalcTax类派生一个新类予以实现即可。</p><p>最后，这种方法使职责的转移更加容易了。例如，在基于继承的方法中，必须由TaskController决定该使用哪个类型的SalesOrder对象。而在新结构中，SalesOrder对象的类型既可以由TaskController对象来决定，也可以由SalesOrder对象决定。为了由SalesOrder对象决定，需要有一个Configuration（配置）对象，使SalesOrder对象知道应该使用哪个税额计算对象，如下图所示：</p><p><img src="/2019/Strategy模式/Strategy%E6%A8%A1%E5%BC%8F%E4%B8%ADConfiguration.PNG" alt="使用Configuration告诉SalesOrder对象应该使用哪一个CalcTax"></p><p>这种方法也使用了继承，但是，它使用继承的方式与仅仅从SalesOrder派生CandianSalesOrder是不同的。在严格的继承方法中，是通过在SalesOrder继承来处理变化的，而在设计模式所指导的方法中，使用对象聚集（也就是说，SalesOrder中包含一个引用，指向处理变化的功能也就是税额计算的对象。）从SalesOrder（需要扩展的类）的就角度来看，是用组合代替了继承。至于被包含的类如何处理变化，SalesOrder并不关心。</p><p>“这种方法不就是将问题向下推了吗？”</p><ul><li>首先，这种说法没错，但是这样能够简化更大，更复杂的程序。</li><li>其次，原设计在一个类层次（SalesOrder）中装入了许多独立的变量，而在新的方法中将这些变量都放在自己的类层次中，这样就能够独立地分别扩展它们。</li><li>最后，在新的方法中，系统的其他部分可以独立于SalesOrder使用或测试这些更小的操作。</li><li>总而言之，模式所提倡的方法伸缩性更强，这是原来直接使用继承的方法所不具备的。</li></ul><p>这种方法使业务规则能够独立于自己的SalesOrder对象而发生改变。请注意对于目前和未来可能出现的任何情况，这种方法都行之有效。这种”将算法封装在一个抽象类（CalcTax）中，而且在某一时刻能够互换地使用其中之一“的方法，本质上就是Strategy模式。</p><h2 id="三、Strategy模式：关键特征"><a href="#三、Strategy模式：关键特征" class="headerlink" title="三、Strategy模式：关键特征"></a>三、Strategy模式：关键特征</h2><ul><li><p>意图：可以根据所处上下文，使用不同的业务规则或算法。</p></li><li><p>问题：对所需算法的选择取决于发出请求的客户或者要处理的数据。如果只有一些不会变化的算法，就不需要Strategy模式。</p></li><li><p>解决方案：将对算法的选择和实现分离。允许根据上下文进行选择。</p></li><li><p>参与者与协作者：</p><ul><li>Strategy指定了如何使用不同的算法。</li><li>各ConcreteStrategy实现了这些不同的算法。</li><li>Context通过类型为Strategy的引用使用具体的ConcreteStrategy。Strategy与Context相互作用以实现所选的算法。Conetext将来自Client的请求转发给Strategy。</li></ul></li><li><p>效果：</p><ul><li>Strategy模式定义了一系列的算法。</li><li>可以不使用switch语句或者条件语句。</li><li>必须以相同的方式调用所有的算法（它们必须拥有相同的接口）。各ConcreteStrategy与Conetxt之间的相互作用可能需要在Context中加入获取状态的方法。</li></ul></li><li><p>实现：让使用算法的类（Context）包含一个抽象类（Strategy），该抽象类有一个抽象方法指定如何调用算法。每个派生类按需要实现算法。</p><p>注意：在原型Strategy模式中，选择所用具体实现的职责由Client对象承担，并转给Strategy模式的Context对象。</p><p>​                </p><p><img src="/2019/Strategy模式/Strategy%E6%A8%A1%E5%BC%8F%E9%80%9A%E7%94%A8%E7%BB%93%E6%9E%84%E5%9B%BE.PNG" alt="Startegy模式通用结构图"></p></li></ul><h2 id="四、使用Strategy模式"><a href="#四、使用Strategy模式" class="headerlink" title="四、使用Strategy模式"></a>四、使用Strategy模式</h2><p>&emsp;&emsp;从技术角度而言，Strategy模式就是用来封装算法的。但是在实践中，它可以用来封装几乎任何类型的规则。</p><p>&emsp;&emsp;Strategy模式要求所封装的算法（业务规则）应处在使用它们的类（Context）之外。这意味着Strategy模式所需信息必须要么传递给它们，要么以某种形式获得。</p><p>&emsp;&emsp;Strategy模式还简化了单元测试，因为每个算法都有自己的类，可以通过自己的接口单独测试。如果算法不像Strategy模式中那样移出来，Context和Strategy之间的耦合将使测试非常苦难。例如，在实例化Context对象之前可能还有一些前提条件。或者，Context可能通过保护数据成员提供Strategy所需信息。如果同时存在几个不同系列的算法，测试能够进一步简化。这是因为使用Strategy模式，开发人员不需要操心与Context耦合所带来的各种相互作用。也就是说，我们应该能够独立地测试每个算法，而无需担心可能地所有组合情况。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、Strategy模式&quot;&gt;&lt;a href=&quot;#一、Strategy模式&quot; class=&quot;headerlink&quot; title=&quot;一、Strategy模式&quot;&gt;&lt;/a&gt;一、Strategy模式&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;定义一系列的算法，把它们一个个封装
      
    
    </summary>
    
      <category term="设计模式" scheme="https://wanqbin.xyz/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="Strategy模式" scheme="https://wanqbin.xyz/tags/Strategy%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="策略模式" scheme="https://wanqbin.xyz/tags/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="对象行为型模式" scheme="https://wanqbin.xyz/tags/%E5%AF%B9%E8%B1%A1%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Adapter模式</title>
    <link href="https://wanqbin.xyz/2019/Adapter%E6%A8%A1%E5%BC%8F/"/>
    <id>https://wanqbin.xyz/2019/Adapter模式/</id>
    <published>2019-11-24T14:58:00.000Z</published>
    <updated>2019-11-25T11:15:46.033Z</updated>
    
    <content type="html"><![CDATA[<p>一、Adapter模式</p><blockquote><p>将一个类的接口转换成客户希望的另外一个接口。Adapter模式使原本由于接口不兼容而不能一起工作的类可以一起工作。</p><p>​                                                                                                                                                                                            ——《设计模式》</p></blockquote><p>即：我们需要一种方式，为一个功能正确但接口不合的对象创建一个新的接口。</p><p>二、学习Adapter模式</p><p>假设客户提出的需求为：</p><ul><li>为都有“显示”(display)行为的点、线、正方形分别创建类；</li><li>客户对象不必知道自己到底拥有点、线还是正方形。他们只需要知道拥有这些形状中的一个。</li></ul><p>也就是说，我想要用一个更高层次的概念将这些具体形状都涵盖进入，这个高层概念可以称为“可显示的形状”。</p><p>也就是说，尽管系统中有点、线以及正方形，但是我希望客户对象认为只有形状。</p><ul><li>这样客户对象可以以相同的方式处理所有对象——无需关注它们的区别。</li><li>这样我未来还可以在客户对象不修改的情况下添加新的形状类型。</li></ul><p>这里将使用多态，也就是说，我的系统中将有许多不同的对象，但我希望对象的客户与它们交互的方式是通用的。</p><p>这里，客户对象只是简单地让点、线或正方形对象进行一些操作，比如“自我显示”或“自我擦除”。然后由每个点、线、正方形负责了解如何按自己的类型完成相应的行为。</p><p>为了实现这一点，我创建了一个Shape类，然后从它派生出表示点、线、正方形的类。如下图所示：</p><p><img src="/2019/Adapter模式/Adapter1.PNG" alt="Point,Line,Square继承自Shape"></p><p>首先，我必须指定Shape对象应提供的具体行为。为此，我在Shape类中为这些行为定义了接口，然后在每个派生类中都相应地实现了这些功能。</p><p>Shape类需要具备以下行为：</p><ul><li>设定一个Shape对象的位置</li><li>获取一个Shape对象的位置</li><li>显示一个Shape对象</li><li>填充一个Shape对象</li><li>设置一个Shape对象的颜色</li><li>擦除一个Shape对象</li></ul><p><img src="/2019/Adapter模式/Adapter%E6%98%BE%E7%A4%BA%E6%96%B9%E6%B3%95.PNG" alt="显示了方法的Point，Line，Square"></p><p>假设现在客户要求实现一个圆——一种新的Shape。为此，我创建了一个新的类——Circle类来实现，并从Shape类派生出Circle类，这样我仍然可以获得多态行为。</p><p>那么，我必须为Circle类编写display,fill和undisplay方法。但是，我现在找到了一个现有的处理圆形的xxCircle类，但是这个类中的方法命名如下：</p><ul><li>displayIt</li><li>fillIt</li><li>undisplayIt</li></ul><p>这里，我不能直接使用xxCircle类，因为我想保持Shape类的多态行为。这有两个原因：</p><ul><li>名称和参数列表不同</li><li>我无法派生它</li></ul><p>而xxCircle无法修改。</p><p>既然无法改变，那就想办法适配！</p><p>我可以创建一个新类，它就是派生自Shape类，因此实现了Shape的接口，但是又用不着重写xxCircle类中的圆形的实现代码。</p><ul><li>Circle类派生自Shape</li><li>Circle包含xxCircle</li><li>Circle将发给自己的请求传送给xxCircle对象。</li></ul><p>![Adapter模式：Circle类包装了xxCircle类](Adapter Circle包装了xxCircle类.PNG)</p><p>当Circle对象实例化的时候，它必须实例化一个xxCircle对象。发给Circle对象的任何请求都将转给该xxCircle对象。如果能够总是如此，而且xxCircle对象具有Circle对象所需要的全部功能，Circle对象就可以通过让xxCircle做实际工作来实现自己的行为。</p><p>实现Adapter模式：</p><p>Shape.h</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Shape</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Shape(<span class="keyword">void</span>);</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="keyword">virtual</span> <span class="title">display</span><span class="params">()</span></span>= <span class="number">0</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ~Shape(<span class="keyword">void</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>Shape.cpp</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Shape::Shape(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Shape::~Shape(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> <strong>Circle.h</strong> </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Shape.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"XX_Circle.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span> :</span> <span class="keyword">public</span> Shape</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Circle(XX_Circle *xxCircle);</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ~Circle(<span class="keyword">void</span>);</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    XX_Circle *myXX_Circle;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>Circle.cpp</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Circle.h"</span></span></span><br><span class="line"></span><br><span class="line">Circle::Circle(XX_Circle *xxCircle)</span><br><span class="line">&#123;</span><br><span class="line">    myXX_Circle = xxCircle;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Circle::~Circle(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">delete</span> myXX_Circle;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> Circle::display()</span><br><span class="line">&#123;</span><br><span class="line">    myXX_Circle-&gt;displayIt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>XX_Circle.h</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">XX_Circle</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    XX_Circle(<span class="keyword">void</span>);</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">displayIt</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ~XX_Circle(<span class="keyword">void</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p> <strong>XX_Circle.cpp</strong> </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"XX_Circle.h"</span></span></span><br><span class="line"></span><br><span class="line">XX_Circle::XX_Circle(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">XX_Circle::~XX_Circle(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>三、Adapter模式：关键特征</p><ul><li>意图：使控制范围之外的一个原有对象与某个接口匹配。</li><li>问题：系统的数据和行为都正确，但接口不符。通常用于必须从抽象类派生时。</li><li>解决方案：Adapter模式提供了具有所需接口的包装类。</li><li>参与者与协作者：Adapter改变了Adaptee的接口，使Adaptee与Adapter的基类Target匹配。这样Client就可以使用Adaptee了，好像它是Target类型的。</li><li>效果：Adapter模式使原有对象能够适应新的类结构，不受其接口的限制。</li><li>实现：将原有类包含在另一个类中。让包含类与需要的接口匹配，调用被包容类的方法。</li></ul><p>四、Adapter模式与Facade模式</p><table><thead><tr><th></th><th>Facade模式</th><th>Adapter模式</th></tr></thead><tbody><tr><td>是否存在既有的类？</td><td>是</td><td>是</td></tr><tr><td>是否必须按某个接口设计？</td><td>否</td><td>是</td></tr><tr><td>对象需要多态行为吗？</td><td>否</td><td>可能</td></tr><tr><td>需要更简单的接口吗？</td><td>是</td><td>否</td></tr></tbody></table><p>从上表中，我们可以看到以下内容：</p><ul><li>在两个模式中，都存在既有的类</li><li>但是在Facade模式中，我无须按某个接口进行设计；而在Adapter模式中，则必须按某个特定的接口设计</li><li>在Facade模式中，我不需要多态行为，而Adapter模式中，多态行为可能是需要的</li><li>Facade模式中的动机是简化接口。而在Adapter模式中，尽管也是越简单越好，但是设计必须遵循一个已有的接口，不能简化任何东西，即使可能存在更简单的接口。</li></ul><p>结论：Facade模式简化了接口，而Adapter模式则将一个已有的接口转换成另一个接口。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;一、Adapter模式&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;将一个类的接口转换成客户希望的另外一个接口。Adapter模式使原本由于接口不兼容而不能一起工作的类可以一起工作。&lt;/p&gt;
&lt;p&gt;​                                       
      
    
    </summary>
    
      <category term="设计模式" scheme="https://wanqbin.xyz/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="Adapter模式" scheme="https://wanqbin.xyz/tags/Adapter%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="适配器模式" scheme="https://wanqbin.xyz/tags/%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="类对象结构型模式" scheme="https://wanqbin.xyz/tags/%E7%B1%BB%E5%AF%B9%E8%B1%A1%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Facade模式</title>
    <link href="https://wanqbin.xyz/2019/Facade%E6%A8%A1%E5%BC%8F/"/>
    <id>https://wanqbin.xyz/2019/Facade模式/</id>
    <published>2019-11-24T14:55:00.000Z</published>
    <updated>2019-11-25T11:16:07.293Z</updated>
    
    <content type="html"><![CDATA[<p>一、Facade 模式</p><blockquote><p>为子系统中的一组接口提供一个统一接口。Facade模式定义了一个更高层的接口，使子系统更加容易使用。</p><p>​                                            </p><p>​                                                                                                                                                                                            ——《设计模式》</p></blockquote><p>即：我们需要用一种比原有方式更简单的办法与系统交互，或者说，我们需要以一种特殊的方式使用系统（例如以二维的方式使用一个三维绘图程序）。</p><p>二、Facade 模式：关键特征</p><ul><li><p>意图：希望简化原有系统的使用方式。需要定义自己的接口。</p></li><li><p>问题：只需要使用某个复杂系统的子集，或者，需要以一种特殊的方式与系统交互。</p></li><li><p>解决方案：Facade为原有系统的客户提供了一个新的接口。</p></li><li><p>参与者与协作者：为客户提供一个简单的接口，使系统更容易使用。（接口本身和各个子系统）</p></li><li><p>效果：Facade模式简化了对所需子系统的使用过程。但是，由于Facade并不完整，因此客户可能无法使用某些功能。</p></li><li><p>实现：</p><ul><li><p>注意点：</p><ul><li>降低客户-子系统之间的耦合度。用抽象类实现Facade而它的具体子类对应于不同的子系统实现，这可以进一步降低客户与子系统的耦合度。</li><li>公共子系统与私有子系统。一个子系统与一个类的相似之处是，它们都有接口，并且都封装了一些东西——类封装了状态和操作，而子系统封装了一些类。考虑一个类的公共和私有接口是有益的，我们也可以考虑子系统的公共和私有接口。<ul><li>子系统的公共接口包含所有的客户程序可以访问的类</li><li>私有接口仅用于对子系统进行扩充。</li><li>Facade类是公共接口的一部分，但它不是唯一的部分，子系统的其他部分通常也是公共的。</li></ul></li></ul></li><li><p>定义一个（或多个）具备所需接口的新类。</p></li><li><p>让新的类使用原有的系统。</p></li></ul></li></ul><p>三、Facade模式：实践</p><p><img src="/2019/Facade模式/Facade%E6%A8%A1%E5%BC%8F%E4%BD%BF%E7%94%A8%E5%89%8D.PNG" alt="Facade模式使用前"></p><p>假设Client对象必须处理Database，Model，Element对象。Client必须首先通过Database对象打开数据库，获取Model对象，然后再查询Model对象，获取Element对象，最后请求Element对象的信息。如果能够创建一个可供Client查询的Database Facade，那么，以上过程将容易得多。</p><p><img src="/2019/Facade模式/Facade%E6%A8%A1%E5%BC%8F.PNG" alt="Facade模式可以减少客户需要处理的对象数量"></p><p>Facade模式提出了一种通用方法：它为我提供了起点。这个模式的Facade部分实际上就是创建了一种新的接口供客户使用，来替代原有的接口。之所以能够这样做，是因为Client对象并不需要原系统提供的所有功能。</p><p>Facade模式还可以用来隐藏或者封装系统。Facade类能够将系统作为自己的私有成员包含进来。在此情况下，原系统将与Facade类联系起来，但Facade类的客户无需看到。</p><p>封装系统的原因如下：</p><ul><li>跟踪系统的使用情况——通过强制所有系统的访问都必须经过Facade，可以很容易地监视系统地使用情况。</li><li>改换系统——未来可能需要切换系统。通过将原系统作为Facade类地一个私有成员，可以最省力地切换到新的系统。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;一、Facade 模式&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;为子系统中的一组接口提供一个统一接口。Facade模式定义了一个更高层的接口，使子系统更加容易使用。&lt;/p&gt;
&lt;p&gt;​                                            &lt;/
      
    
    </summary>
    
      <category term="设计模式" scheme="https://wanqbin.xyz/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="对象结构型模式" scheme="https://wanqbin.xyz/tags/%E5%AF%B9%E8%B1%A1%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="Facade模式" scheme="https://wanqbin.xyz/tags/Facade%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="外观模式" scheme="https://wanqbin.xyz/tags/%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>UML和类图</title>
    <link href="https://wanqbin.xyz/2019/UML%E5%92%8C%E7%B1%BB%E5%9B%BE/"/>
    <id>https://wanqbin.xyz/2019/UML和类图/</id>
    <published>2019-11-24T09:03:00.000Z</published>
    <updated>2019-11-24T09:09:07.771Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、什么是UML？"><a href="#一、什么是UML？" class="headerlink" title="一、什么是UML？"></a>一、什么是UML？</h2><p>UML是一种用来创建程序模型的图形语言（即带有语义的一种图形记号）。</p><h3 id="1-UML图及其用途"><a href="#1-UML图及其用途" class="headerlink" title="1. UML图及其用途"></a>1. UML图及其用途</h3><table><thead><tr><th>当你在……</th><th>所使用的UML图</th></tr></thead><tbody><tr><td>分析阶段</td><td>用例图，所涉及的是与系统之间交互的实体，以及需要实现的功能点</td></tr><tr><td></td><td>活动图，关注的是【问题领域和其他主体工作的实际空间，程序的主题领域】的工作流，而不是程序的逻辑流</td></tr><tr><td>观察对象的交互</td><td>交互图，说明了特定对象如何相互交互。因为它们处理的都是具体情况而不是一般情况，所以在检查需求和设计时都很有用。最常见的一种交互图是顺序图。</td></tr><tr><td>设计阶段</td><td>类图，详细说明了类之间的关系</td></tr><tr><td>观察对象所处状态不同时行为的差异</td><td>状态图，详细描述了对象可能所处的不同状态以及在这些状态之间的转换。</td></tr><tr><td>配置阶段</td><td>部署图，说明如何部署不同模块。</td></tr></tbody></table><h3 id="2-为什么使用UML？"><a href="#2-为什么使用UML？" class="headerlink" title="2. 为什么使用UML？"></a>2. 为什么使用UML？</h3><ul><li><p>UML主要是用来交流的。</p></li><li><p>UML提供了一种方法，可以用来确定我对系统的理解是否与其他人相同。因为系统非常复杂，有许多不同种类的信息需要传递，所以UML提供了许多不同的图专门表示不同种类的信息。</p></li></ul><h2 id="二、类图"><a href="#二、类图" class="headerlink" title="二、类图"></a>二、类图</h2><p>类图不仅描述了类，而且说明了类之间的关系。这些关系可能有以下这些类型：</p><ul><li>当一个类是“一种”另一个类时：<code>is-a</code>（是一种/一个）关系</li><li>当两个类之间存在关联时：<ul><li>一个类“包含”另一个类：<code>has-a</code>（拥有一个）关系；</li><li>一个类“使用”另一个类：<code>use-a</code>（使用一个）关系；</li><li>一个类“创建”另一类</li></ul></li></ul><p>这些类型还有一些变体。比如，说“什么东西包含另一个东西”时，我们可能是指：</p><ul><li>被包含者是包含者的一部分（比如汽车中的发动机）</li><li>有一个集合，集合中东西可以独立存在（比如机场上的飞机）</li></ul><p>第一种情况被称为<strong>组合</strong>(composition)，第二种情况被称为<strong>聚集</strong>(aggregation)。</p><p>首先，矩形表示一个类。在UML中，可以表示最多三个方面的类的信息：</p><ul><li>类名</li><li>类的数据成员</li><li>类的方法（函数）</li></ul><p><img src="/2019/UML和类图/%5C%E7%B1%BB%E5%9B%BE%E2%80%94%E2%80%94%E4%B8%89%E7%A7%8D%E5%8F%98%E4%BD%93.PNG" alt="类图——三种变体"></p><p>表示类的信息有三种不同方式：</p><ul><li>最左边的矩形只显示了类名。在不需要更详细信息时，可以使用类的这种表示形式。</li><li>中间的举行显示了类名和类的方法。Square类有一个display方法。display前的加号（+）表示此方法是公开的。</li><li>最右边的矩形除显示了前面的信息之外，还显示了类的数据成员。</li></ul><p>表示访问权限的UML记号：</p><ul><li>公开——用一个加号（+）标记。</li><li>保护——用一个井号（#）标记。</li><li>私有——用一个减号（-）标记。</li></ul><p>表示关系的UML记号有如下四种：</p><p><img src="/2019/UML和类图/%E8%A1%A8%E7%A4%BA%E5%85%B3%E7%B3%BB%E7%9A%84UML%E8%AE%B0%E5%8F%B7.PNG" alt="表示关系的UML记号"></p><p>类图还可以表示不同类之间的关系。下图显示了Shape类和它的几个派生类之间的关系。</p><p><img src="/2019/UML和类图/is-a%E5%85%B3%E7%B3%BB.PNG" alt="is-a关系的类图"></p><p>上图说明了几件事：</p><ul><li>首先，Shape类下面的箭头的意思是：指向Shape的那些类派生自Shape类。</li><li>而且，Shape类的名字使用<em>斜体</em>表示的，说明它是一个抽象类。抽象类是用来为其派生类定义接口而且存放这些派生类共哦那个数据和方法的类。</li><li>接口可以看作是没有公共数据和方法的抽象类——它只用来作为一种“为要实现它的那些类的方法进行定义”的方式而已。</li></ul><p>如前所述，有两种<code>has-a</code>关系。</p><ul><li><p>一个对象可以拥有另一个对象，其中被包含的对象是包含对象的一部分——或者不是。</p><ul><li><p>在下图中，Airport“拥有”Aircraft。Aircraft并不是Airport的一部分，但仍然可以说Airport拥有Aircraft，这种关系称为<strong>聚集</strong>或<strong>聚合</strong>。</p><p><img src="/2019/UML和类图/%E8%81%9A%E5%90%88%E5%85%B3%E7%B3%BB.PNG" alt="has-a关系"></p><ul><li>jet表示喷气式飞机，Helicopter表示直升飞机。</li></ul></li></ul></li><li><p>另一种<code>has-a</code>关系是包含，被包含的对象是包含对象的一部分，这种关系称为组合。</p><ul><li><p>在下图中，Car（轿车）拥有Tire（轮胎），后者是Car的一部分。</p></li><li><p>下图还显示Car使用了GasStation（加油站）类，这种使用关系用带箭头的虚线表示，也称为<strong>依赖</strong>。</p><p><img src="/2019/UML和类图/%E7%BB%84%E5%90%88%E5%85%B3%E7%B3%BB.PNG" alt="组合&amp;&amp;依赖"></p></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、什么是UML？&quot;&gt;&lt;a href=&quot;#一、什么是UML？&quot; class=&quot;headerlink&quot; title=&quot;一、什么是UML？&quot;&gt;&lt;/a&gt;一、什么是UML？&lt;/h2&gt;&lt;p&gt;UML是一种用来创建程序模型的图形语言（即带有语义的一种图形记号）。&lt;/p&gt;
&lt;h3
      
    
    </summary>
    
      <category term="设计模式" scheme="https://wanqbin.xyz/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="https://wanqbin.xyz/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="UML" scheme="https://wanqbin.xyz/tags/UML/"/>
    
      <category term="类图" scheme="https://wanqbin.xyz/tags/%E7%B1%BB%E5%9B%BE/"/>
    
  </entry>
  
  <entry>
    <title>面向对象泛型</title>
    <link href="https://wanqbin.xyz/2019/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%B3%9B%E5%9E%8B/"/>
    <id>https://wanqbin.xyz/2019/面向对象泛型/</id>
    <published>2019-11-23T09:44:00.000Z</published>
    <updated>2019-11-23T09:45:27.753Z</updated>
    
    <content type="html"><![CDATA[<p>面向对象泛型以对象概念为中心，一切都集中在对象之上，编写代码时是围绕对象而非函数进行组织的。</p><p>使用对象的优点在于，可以定义自己负责自己的事物。对象天生就知道自己的类型。对象中的数据能够告诉它自己的转台如何，而对象中的代码能够使它正确工作。</p><table><thead><tr><th>对象</th><th>责任</th></tr></thead><tbody><tr><td>Student</td><td>知道自己所在的教室;知道自己下堂课的教室；从一个教室到下一个教室</td></tr><tr><td>Instructor</td><td>告诉学生到下堂课的教室去</td></tr><tr><td>Classroom</td><td>有明确的地址</td></tr><tr><td>Direction giver</td><td>对于给定的两个教室，指出从一个教室到另一个教室的路线</td></tr></tbody></table><p>在这种情况下，对象是通过寻找在问题领域中的实体而被发现的。然后再通过查看这些实体需要做些什么，为每个对象确定责任。这与通过在需求中寻找名词发现对象和通过寻找动词发现方法的技术是一致的。</p><p>理解对象的最佳方式，是将其看成“具有责任的东西”。</p><p>有一条好的设计规则：对象应该自己负责自己，而且应该清楚地定义责任。</p><p>从<strong>软件开发过程中的视角</strong>观察对象：</p><ul><li>在概念层次上，对象是一组责任</li><li>在规约层次上，对象是一组可以被其他对象或对象自己调用的方法</li><li>在实现层次上，对象是代码和数据，以及它们之间的计算交互。</li></ul><p>因为对象具有责任并且自己负责自己，所以必须有方法告诉对象要做什么。对象含有说明自己状态的数据，还有实现必要功能的方法。对象的很多方法都将标识为可被其他对象调用。这些方法的集合就称为对象的公共接口。</p><p>面向对象的相关术语：</p><table><thead><tr><th>术语</th><th>描述</th></tr></thead><tbody><tr><td>抽象类（abstract class）</td><td>定义了一组相关类的行为。</td></tr><tr><td>类(class)</td><td>根据对象所具有的责任定义对象的类型。责任可以访问行为和/或状态。这些分别是由方法和/或数据实现的。</td></tr><tr><td>具体类(concrete class)</td><td>实现抽象类某一特定类型行为的类。具体类是一个概念特定、不变的实现。</td></tr><tr><td>封装(encapsulation)</td><td>通常定义为数据隐藏，但最好将它看作任何形式的隐藏（类型、实现和设计等等）</td></tr><tr><td>继承(inheritance)</td><td>一个类继承另一个类，是指它接受了该类的一些或者所有性质。其实类被称为基类、超类、父类或泛化类，而继承类称为派生类、子类或特化类</td></tr><tr><td>实例(instance)</td><td>类的特例（总是一个对象）。类的特殊实例或实体。每个对象都有自己的状态。因此，同一个类型（类）可以有多个对象。</td></tr><tr><td>实例化(instantiation)</td><td>创建类的一个实例的过程。</td></tr><tr><td>接口(interface)</td><td>接口与类类似，但是只为其成员提供规约而不提供实现。它与只含有抽象成员的抽象类很相似。编程的时候，如果需要几个类共享公共基类中没有的一些特性，而且希望确保每个类自己实现这些特定（因为所有成员都是抽象的），就应该使用接口。</td></tr><tr><td>视角(perspective)</td><td>观察对象有三种视角：概念视角、规约视角和实现视角。这三个不同层次的区别在理解抽象类与其派生类之间的关系上用处很大。抽象类定义了如何在概念层次上解决问题，还提供了与任何派生对象通信的规约。每个派生类都按需要提供特定的实现。</td></tr><tr><td>多态(polymorphism)</td><td>能够用一种方式引用一个类的不同派生类，但获得的行为对应于所引用的派生类。</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;面向对象泛型以对象概念为中心，一切都集中在对象之上，编写代码时是围绕对象而非函数进行组织的。&lt;/p&gt;
&lt;p&gt;使用对象的优点在于，可以定义自己负责自己的事物。对象天生就知道自己的类型。对象中的数据能够告诉它自己的转台如何，而对象中的代码能够使它正确工作。&lt;/p&gt;
&lt;table
      
    
    </summary>
    
      <category term="设计模式" scheme="https://wanqbin.xyz/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="面向对象泛型" scheme="https://wanqbin.xyz/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%B3%9B%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>面向对象泛型之前：功能分解</title>
    <link href="https://wanqbin.xyz/2019/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%B3%9B%E5%9E%8B%E4%B9%8B%E5%89%8D%EF%BC%9A%E5%8A%9F%E8%83%BD%E5%88%86%E8%A7%A3/"/>
    <id>https://wanqbin.xyz/2019/面向对象泛型之前：功能分解/</id>
    <published>2019-11-23T09:43:00.000Z</published>
    <updated>2019-11-23T09:44:21.098Z</updated>
    
    <content type="html"><![CDATA[<p>功能分解方法的一个问题在于，它通常会导致让一个“主“程序负责控制子程序，这是将功能分解为多个子功能的自然结果。但是主程序所承受的责任太多了：要确保一切正常工作，还要协调各函数并控制它们的先后顺序，因此经常会产生非常复杂的代码。如果让一些子函数负责自己的行为，并且能够告诉主函数执行某些任务，并信任它知道如何执行，这种方式比功能分解的方式要容易得多。这就是所谓的<strong>委托</strong>。</p><p>功能分解的另一个问题是，它在为未来可能出现的变化未雨绸缪方面，在对代码合适地改进方面，都于事无补。变化是无可避免的，经常是因为自己要为已有的主题增加新的变体。例如，我可能不得不处理新的形状，或者需要显示形状的新办法。如果将实现各步骤的所有逻辑代码都放在一个大函数或者大模块中的话，那么这些步骤的任何实质性变化，都必须都这个函数或模块进行修改。</p><p>内聚性指的是”例程中操作之间的紧密程度“。</p><p>耦合性指的是”两个例程之间联系的紧密程度。耦合性与内聚性是相辅相成的关系。内聚性描述的是一个例程内部组成部分之间相互联系的紧密程度，而耦合性描述的是一个例程与其他例程之间联系的紧密程度。软件开发的目标应该是创建这样的例程：内部完成（高内聚），而与其他例程之间的联系则是小巧、直接、可见、灵活的“。</p><blockquote><p>假设你是一个会议的讲师，听课的人课后还要去听其他课，但它们不知道下一堂课的听课地点。你的责任之一，就是确保大家都知道下一堂课去哪里上。</p></blockquote><p>如果按照结构化程序设计的方法，可以这样做:</p><ol><li>获得听课人的名字</li><li>对于名单上的每个人，做以下工作：<ul><li>找到他要听的下一节课</li><li>找到该课的听课地点</li><li>找到从你的教师到下一堂课地点怎么走</li><li>告诉这个人怎样去上下一堂课</li></ul></li></ol><p>为了完成上面的工作，你可能需要编写：</p><ol><li>获得听课人名单的方法</li><li>获得每个人课程表方法</li><li>告诉某个人如何从你的教室到其他教室的程序</li><li>为听课的每个人服务的一个控制程序，它可以为每个人完成所需的步骤</li></ol><blockquote><p>你可能会把从这个教室到其他教室的路线贴出来，然后告诉课堂上的所有人：”我已经将下一堂课的地点和其他教室的位置都贴在教室后面了。请根据它找到你们下一堂课的教室。“</p><p>可以预期每个人都知道自己的下一堂课是什么，而且他们都能从你提供的列表中查到正确的教室，然后按照指示找到它。</p></blockquote><p>这两种方法的区别何在？</p><ul><li>第一种，直接给没每个人都提供提示，你必须密切关注大量细节，除你之外没有其他人负责。</li><li>第二种，你只给出通用的提示，然后期待每个人会自己弄清怎样完成任务。</li></ul><p><strong>其中最大的区别就是这样责任的转移</strong></p><p>第二种方法有以下三种不同：</p><ul><li>人们对自己的行为负责，而不再由一个中央控制程序负责决定他们的行为。</li><li>控制程序可以与不同类型的人交流，好像他们都一样。</li><li>控制程序不需要知道学生从此教室到彼教室可能采取的任何特殊步骤。</li></ul><p>软件开发过程中的视角</p><table><thead><tr><th>视角</th><th>描述</th></tr></thead><tbody><tr><td>概念</td><td>这种视角要回答的问题是：”软件要负责什么？“</td></tr><tr><td>规约</td><td>考虑软件的接口，而不是实现。这个视角要回答的问题是：”怎么使用软件？“</td></tr><tr><td>实现</td><td>这个视角要回答的问题是：”软件怎样履行自己的责任？“</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;功能分解方法的一个问题在于，它通常会导致让一个“主“程序负责控制子程序，这是将功能分解为多个子功能的自然结果。但是主程序所承受的责任太多了：要确保一切正常工作，还要协调各函数并控制它们的先后顺序，因此经常会产生非常复杂的代码。如果让一些子函数负责自己的行为，并且能够告诉主函
      
    
    </summary>
    
      <category term="设计模式" scheme="https://wanqbin.xyz/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="面向对象" scheme="https://wanqbin.xyz/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
  </entry>
  
  <entry>
    <title>私有docker仓库搭建</title>
    <link href="https://wanqbin.xyz/2019/%E7%A7%81%E6%9C%89docker%E4%BB%93%E5%BA%93%E6%90%AD%E5%BB%BA/"/>
    <id>https://wanqbin.xyz/2019/私有docker仓库搭建/</id>
    <published>2019-11-20T03:06:00.000Z</published>
    <updated>2019-11-20T03:07:49.944Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h2><p>&emsp;&emsp;使用公有仓库，我们可以很方便地分享自己的镜像，也可以使用其他人分享的镜像。但是有时候，公有仓库并不是很适合，比如某些镜像可能只是希望在内部用户间共享，这时可以搭建一个私有的仓库服务器。</p><p>&emsp;&emsp;搭建私有的仓库服务器有两种方式：一是使用容器运行docker-registry，二是本地安装运行docker-registry。</p><p>&emsp;&emsp;docker-registry是一个基于Python的开源项目，为我们提供了私有镜像服务器的功能。</p><h2 id="二、使用容器运行docker-registry"><a href="#二、使用容器运行docker-registry" class="headerlink" title="二、使用容器运行docker-registry"></a>二、使用容器运行docker-registry</h2><ol><li><h3 id="获取官方镜像"><a href="#获取官方镜像" class="headerlink" title="获取官方镜像"></a>获取官方镜像</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull registry</span><br></pre></td></tr></table></figure></li><li><h3 id="运行registry"><a href="#运行registry" class="headerlink" title="运行registry"></a>运行registry</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -p 5000:5000 registry   #-d表示表示后台运行，-p表示端口映射</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;通过上面的命令，我们的私有服务器就以默认参数运行了。我们也可以配合使用<code>-e</code>和<code>-v</code>参数来该该改变服务器的运行参数。一是配置文件的路径，二是仓库的路径。</p><ul><li><h4 id="配置文件的路径：通过类似下面的命令改变："><a href="#配置文件的路径：通过类似下面的命令改变：" class="headerlink" title="配置文件的路径：通过类似下面的命令改变："></a>配置文件的路径：通过类似下面的命令改变：</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -p 5000:5000 -v /home/share/registry-conf:/root/registry-conf -e DOCKER_REGISTRY_CONFIG=/root/registry-conf/config.yaml registry</span><br></pre></td></tr></table></figure><p>在本地目录<code>/home/share/registry-conf</code>下存放着要使用的配置文件，通过<code>-v</code>参数将它映射到容器的<code>/root/registry-conf</code>目录，使用<code>-e</code>用环境变量的方式指定<code>/root/registry-conf/config.yaml</code>为程序的配置文件。</p></li><li><h4 id="配置仓库路径：通过类似下面的命令改变："><a href="#配置仓库路径：通过类似下面的命令改变：" class="headerlink" title="配置仓库路径：通过类似下面的命令改变："></a>配置仓库路径：通过类似下面的命令改变：</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -p 5000:5000 -v /opt/data/registry:/tmp/registry registry</span><br></pre></td></tr></table></figure><p>官方镜像使用的仓库路径是<code>/tmp/registry</code>，我们通过把本地路径映射到<code>/tmp/registry</code>。可以让服务器把镜像保存到我们自定义的路径下。</p></li></ul><p>这里我使用的命令是：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -i -t -p 5000:5000 -v /data/registry:/var/lib/registry  --restart=always --name registry registry:latest</span><br></pre></td></tr></table></figure><ul><li>–restart=always：这是重启策略，加入这个容器异常退出会自动重启容器</li><li>–name registry：创建容器命名为registry</li><li>registry:latest：这是刚刚pull下来的镜像</li></ul></li><li><h3 id="配置-etc-docker-daemon-json"><a href="#配置-etc-docker-daemon-json" class="headerlink" title="配置/etc/docker/daemon.json"></a>配置<code>/etc/docker/daemon.json</code></h3><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"insecure-registries"</span>:[<span class="string">"192.168.43.114:5000"</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里<code>192.168.43.114</code>是私有仓库的IP地址。</p><p>其他机器pull私有仓库镜像的时候，也需要在该文件中添加如上内容。</p></li><li><h3 id="查看镜像仓库中的镜像"><a href="#查看镜像仓库中的镜像" class="headerlink" title="查看镜像仓库中的镜像"></a>查看镜像仓库中的镜像</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl http://127.0.0.1:5000/v2/_catalog</span><br></pre></td></tr></table></figure></li><li><h3 id="为镜像打标签"><a href="#为镜像打标签" class="headerlink" title="为镜像打标签"></a>为镜像打标签</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker tag 镜像名 127.0.0.1:5000/镜像名</span><br></pre></td></tr></table></figure></li><li><h3 id="上传镜像"><a href="#上传镜像" class="headerlink" title="上传镜像"></a>上传镜像</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker push 127.0.0.1:5000/镜像名</span><br></pre></td></tr></table></figure></li><li><h3 id="拉取私有仓库镜像"><a href="#拉取私有仓库镜像" class="headerlink" title="拉取私有仓库镜像"></a>拉取私有仓库镜像</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull 192.168.43.114:5000/镜像名</span><br></pre></td></tr></table></figure></li></ol><h2 id="三、在本地安装运行docker-registry"><a href="#三、在本地安装运行docker-registry" class="headerlink" title="三、在本地安装运行docker-registry"></a>三、在本地安装运行docker-registry</h2><p>&emsp;&emsp;这里使用的CentOS7。</p><ul><li><h3 id="安装相关依赖库"><a href="#安装相关依赖库" class="headerlink" title="安装相关依赖库"></a>安装相关依赖库</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install -y python-devel libevent-devel python-pip gcc xz-devel</span><br></pre></td></tr></table></figure></li><li><h3 id="安装相关python模块"><a href="#安装相关python模块" class="headerlink" title="安装相关python模块"></a>安装相关python模块</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install gunicorn pyyaml flask flask-cors rsa gevent</span><br></pre></td></tr></table></figure></li><li><h3 id="安装docker-registry"><a href="#安装docker-registry" class="headerlink" title="安装docker-registry"></a>安装docker-registry</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python-pip install docker-registry</span><br></pre></td></tr></table></figure></li><li><h3 id="启动服务器"><a href="#启动服务器" class="headerlink" title="启动服务器"></a>启动服务器</h3><p>通过下面的命令，可以启动服务器：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gunicorn --access-logfile /var/log/docker-registry/access.log --error-logfile /var/log/docker-registry/server.log -k gevent --max-requests 100 --graceful-timeout 3600 -t 3600 -b 127.0.0.1:5000 -w 1 docker_registry.wsgi:application</span><br></pre></td></tr></table></figure><p>使用HTTP方式访问本地的5000端口，如果看到类似下面的输出，说明服务器正常运行了。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">curl 127.0.0.1:5000</span><br><span class="line">"\"docker-registry server\""</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、概述&quot;&gt;&lt;a href=&quot;#一、概述&quot; class=&quot;headerlink&quot; title=&quot;一、概述&quot;&gt;&lt;/a&gt;一、概述&lt;/h2&gt;&lt;p&gt;&amp;emsp;&amp;emsp;使用公有仓库，我们可以很方便地分享自己的镜像，也可以使用其他人分享的镜像。但是有时候，公有仓库并不是
      
    
    </summary>
    
      <category term="分布式与云计算" scheme="https://wanqbin.xyz/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%8E%E4%BA%91%E8%AE%A1%E7%AE%97/"/>
    
    
      <category term="docker" scheme="https://wanqbin.xyz/tags/docker/"/>
    
      <category term="私有仓库" scheme="https://wanqbin.xyz/tags/%E7%A7%81%E6%9C%89%E4%BB%93%E5%BA%93/"/>
    
      <category term="registry" scheme="https://wanqbin.xyz/tags/registry/"/>
    
  </entry>
  
  <entry>
    <title>镜像和Dockerfile</title>
    <link href="https://wanqbin.xyz/2019/%E9%95%9C%E5%83%8F%E5%92%8CDockerfile/"/>
    <id>https://wanqbin.xyz/2019/镜像和Dockerfile/</id>
    <published>2019-11-19T17:48:00.000Z</published>
    <updated>2019-11-19T17:49:29.645Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、镜像与容器"><a href="#一、镜像与容器" class="headerlink" title="一、镜像与容器"></a>一、镜像与容器</h2><ul><li>镜像是一个包含程序运行必要依赖环境和代码的只读文件，它采用分层的文件系统，将每一次改变以读写层的形式增加到原来的只读文件上。</li><li>镜像是容器运行的基石。如果将容器理解为一套程序运行的虚拟环境，那么镜像就是用来构建这个环境的模板。</li><li>镜像的最底层必须是一个称为启动文件系统（bootfs）的镜像，用户不会与这一层直接打交道。bootfs的上层镜像叫做根镜像（rootfs），它在通常情况下是一个操作系统。用户的镜像必须构建于根镜像之上。</li><li>镜像的本质是磁盘上的一系列文件的集合。创建新的镜像其实就是对已有经i想文件进行增、删、改、查操作，镜像之间并不是独立的，而是存在单向的文件依赖关系。</li><li>镜像的写时复制机制<ul><li>通过<code>docker run</code>命令指定镜像创建一个容器时，实际上是在该镜像之上创建一个空的可读写文件系统层级。可以将这个文件系统当成一个新的临时镜像，而命令里所指定的镜像称为父镜像。父镜像的内容都是以只读方式挂在进来的，容器会读取父镜像的内容。不过一旦需要修改父镜像文件，便会触发Docker从父镜像中复制这个文件到临时镜像中来，所有的修改均发生在你的文件系统中，而不会对父镜像造成任何影响，这就是Docker镜像的写时复制机制。</li></ul></li></ul><h2 id="二、本地镜像的管理"><a href="#二、本地镜像的管理" class="headerlink" title="二、本地镜像的管理"></a>二、本地镜像的管理</h2><ol><li><h3 id="查看"><a href="#查看" class="headerlink" title="查看"></a>查看</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker images</span><br></pre></td></tr></table></figure><ul><li>REPOSITORY：仓库名称</li><li>TAG：用于区分同一仓库中的不同镜像。如果未指定，默认为latest</li><li>IMAGE ID：每个镜像都有一个字符串类型、长为64位的HashID，用来全网标识一个镜像。</li><li>CREATED：镜像的创建时间。</li><li>VIRTUAL SIZE：镜像所占的虚拟大小，该大小包含所有共享文件的大小。</li></ul></li><li><h3 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker search 镜像名   #在Docker Hub上搜索符合要求的镜像</span><br><span class="line">docker pull 镜像名 #拉取镜像</span><br></pre></td></tr></table></figure></li><li><h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rmi 镜像名/镜像ID</span><br></pre></td></tr></table></figure><p>删除本地所有镜像：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rm $(docker ps -a -q)</span><br></pre></td></tr></table></figure><p>其中，<code>docker ps -a -q</code>命令用来列出所有容器的ID。</p></li></ol><h2 id="三、创建本地镜像"><a href="#三、创建本地镜像" class="headerlink" title="三、创建本地镜像"></a>三、创建本地镜像</h2><ol><li><h3 id="使用commit命令创建本地镜像"><a href="#使用commit命令创建本地镜像" class="headerlink" title="使用commit命令创建本地镜像"></a>使用<code>commit</code>命令创建本地镜像</h3><p>使用镜像创建并运行一个镜像，实际上是在父镜像的基础上构建一个可读写的文件层级。我们在容器中所做的修改，都发生在这个层级上。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker run -i -t centos    #在centos镜像上创建运行一个容器</span><br><span class="line"><span class="meta">#</span>在该容器中安装软件</span><br><span class="line">exit #退出该容器</span><br></pre></td></tr></table></figure><p>在这里，需要注意的是，要保存当前创建的容器的ID。在退出容器后，执行下面的命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker commit -m="Message" --author="Aoki" 容器ID aoki/centos:v1</span><br></pre></td></tr></table></figure><p><code>-m</code>参数是描述本次创建的镜像的信息，<code>--author</code>参数用来指定作者信息，<code>aoki</code>表示仓库名，这里需要注意的是，在命名的过程中，有一定的标准，比如不能使用大写字母，<code>centos</code>表示镜像名，<code>v1</code>标识镜像TAG名。</p></li><li><h3 id="使用Dockerfile创建镜像"><a href="#使用Dockerfile创建镜像" class="headerlink" title="使用Dockerfile创建镜像"></a>使用Dockerfile创建镜像</h3><p>使用Dockerfile创建镜像是是将所有的配置信息都写入到了一个文件中，然后使用<code>docker build</code>命令来创建一个镜像。这种方法可以使镜像的创建变得透明和独立化，并且创建过程可以被重复执行。Dockerfile文件以行为单位，行首为Dockerfile命令，命令都是大写形式，其后紧跟的是命令的参数。</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#version: 1.0.1</span></span><br><span class="line"><span class="comment">#指定父镜像</span></span><br><span class="line"><span class="keyword">FROM</span> ubuntu:latest</span><br><span class="line"></span><br><span class="line"><span class="keyword">MAINTAINER</span> Aoki <span class="string">"aoki3352@163.com"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#设置root用户为后续命令的执行者</span></span><br><span class="line"><span class="keyword">USER</span> root</span><br><span class="line"></span><br><span class="line"><span class="comment">#执行操作</span></span><br><span class="line"><span class="keyword">RUN</span> apt-get update</span><br><span class="line"><span class="keyword">RUN</span> apt-get install -t nginx</span><br><span class="line"></span><br><span class="line"><span class="comment">#使用&amp;&amp;拼接命令</span></span><br><span class="line"><span class="keyword">RUN</span> touch test.txt &amp;&amp; echo "abc" &gt; abc.txt</span><br><span class="line"></span><br><span class="line"><span class="comment">#对外暴露接口</span></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">80</span> <span class="number">8080</span> <span class="number">1038</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#添加文件</span></span><br><span class="line"><span class="keyword">ADD</span> /webapp /opt/webapp  #添加当前文件夹中的/webapp文件到 /opt/webapp目录下</span><br><span class="line"></span><br><span class="line"><span class="comment">#添加网络文件</span></span><br><span class="line"><span class="keyword">ADD</span> https://www.baidu.com/img/xxxx.png /opt #添加网络文件到/opt目录下</span><br><span class="line"></span><br><span class="line"><span class="comment">#设置环境变量</span></span><br><span class="line"><span class="keyword">ENV</span> WEBAPP_PORT=<span class="number">9090</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#设置工作目录</span></span><br><span class="line"><span class="keyword">WORKDIR</span> /opt</span><br><span class="line"></span><br><span class="line"><span class="comment">#设置启动命令</span></span><br><span class="line"><span class="keyword">ENTRYPOINT</span> ["ls"]</span><br><span class="line"></span><br><span class="line"><span class="comment">#设置启动参数</span></span><br><span class="line"><span class="keyword">CMD</span> ["-a","-l"]</span><br><span class="line"></span><br><span class="line"><span class="comment">#设置卷</span></span><br><span class="line"><span class="keyword">VOLUME</span> ["/data","/var/www"]</span><br><span class="line"></span><br><span class="line"><span class="comment">#设置子镜像的触发操作</span></span><br><span class="line"><span class="keyword">ONBUILD</span> <span class="keyword">ADD</span> . /app/src</span><br><span class="line"><span class="keyword">ONBUILD</span> <span class="keyword">RUN</span> echo "on build excuted" &gt;&gt; onbuild.txt</span><br></pre></td></tr></table></figure><p>下面的各个命令的含义：</p><ul><li><code>FROM</code>：指定待扩展的父镜像。除了注释之外，在文件开头必须是一个<code>FROM</code>指令，接下来的指令便在这个父级镜像的环境中运行，直到遇到下一个<code>FROM</code>指令。</li><li><code>MAINTAINER</code>：用来声明创建的镜像的作者信息。分别是 用户名、用户邮箱。这个命令不是必须的。</li><li><code>USER</code>：为容器的运行及接下来指令的运行指定用户或UID。</li><li><code>RUN</code>：用来修改镜像的命令，接下来的指令会在新的镜像上继续执行。</li><li><code>EXPOSE</code>：用来指明容器内进程对外开发的端口，多个端口之间使用空格隔开。运行容器时，通过参数<code>-P</code>即可将<code>EXPOSE</code>里所指定的端口映射到主机上另外的随机端口，其他容器或主机就可以通过映射后的端口与此容器进行通信。同时，也可以使用<code>-p</code>参数将<code>EXPOSE</code>没有列出的端口设置成公开。</li><li><code>ADD</code>：向新镜像中添加文件<ul><li><code>ADD</code>命令的第一个参数用来指定源文件（夹），可以是文件路径、文件夹路径或网络文件的URL地址，但是需要注意的是，如果是文件（夹）路径的话，必须是Dockerfile文件所在目录的相对路径。</li><li>第二个参数是文件需要放置在目标镜像的位置。如果源文件是主机上<code>zip</code>或者<code>tar</code>形式的压缩文件，Docker会先解压缩，然后添加到镜像的指定路径。如果是一个通过URL指定的网络压缩文件，则不会解压。</li></ul></li><li><code>VOLUME</code>：该命令会在镜像里创建一个指定路径的挂载点，这个路径可以来自主机或者其他容器。多个容器可以通过同一个挂载点共享数据，即便其中一个容器已经停止，挂载点也依然可以访问，只有当挂载点的容器引用全部消失时，挂载点才会自动删除。</li><li><code>WORKDIR</code>：为接下来执行的指令指定一个新的工作目录，这个目录可以是绝对路径，也可以是相对路径。</li><li><code>ENV</code>：设置容器运行的环境变量，在运行容器的时候，通过<code>-e</code>参数可以修改这个环境变量值，也可以添加新的环境变量。</li><li><code>CMD</code>：用来设置启动容器时默认运行的命令。</li><li><code>ENTRYPOINT</code>：与<code>CMD</code>类似，用来指定容器启动时默认运行的命令</li><li><code>ONBUILD</code>：触发器指令。构建镜像的时候，Docker的镜像构建器会将所有的<code>ONBUILD</code>指令指定的命令保存到镜像的元数据中，这些命令在当前镜像的构建过程中并不会执行。只有新的镜像使用<code>FROM</code>指令指定该镜像为父镜像时，便会触发执行。</li></ul><h3 id="docker-build命令创建构建镜像："><a href="#docker-build命令创建构建镜像：" class="headerlink" title="docker build命令创建构建镜像："></a><code>docker build</code>命令创建构建镜像：</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -t aoki/xxx:v1 .</span><br></pre></td></tr></table></figure><p><code>-t</code>参数用来指定镜像的命名空间，仓库名和TAG。</p><p>命令最后的<code>.</code>表示Dockerfile文件所在的相对路径，这里是指当前路径。</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、镜像与容器&quot;&gt;&lt;a href=&quot;#一、镜像与容器&quot; class=&quot;headerlink&quot; title=&quot;一、镜像与容器&quot;&gt;&lt;/a&gt;一、镜像与容器&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;镜像是一个包含程序运行必要依赖环境和代码的只读文件，它采用分层的文件系统，将每一次改变以
      
    
    </summary>
    
      <category term="分布式与云计算" scheme="https://wanqbin.xyz/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%8E%E4%BA%91%E8%AE%A1%E7%AE%97/"/>
    
    
      <category term="docker" scheme="https://wanqbin.xyz/tags/docker/"/>
    
      <category term="Dockerfile" scheme="https://wanqbin.xyz/tags/Dockerfile/"/>
    
      <category term="镜像" scheme="https://wanqbin.xyz/tags/%E9%95%9C%E5%83%8F/"/>
    
  </entry>
  
  <entry>
    <title>Docker和容器</title>
    <link href="https://wanqbin.xyz/2019/Docker%E5%92%8C%E5%AE%B9%E5%99%A8/"/>
    <id>https://wanqbin.xyz/2019/Docker和容器/</id>
    <published>2019-11-19T16:25:00.000Z</published>
    <updated>2019-11-19T16:26:14.105Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、Docker是什么？"><a href="#一、Docker是什么？" class="headerlink" title="一、Docker是什么？"></a>一、Docker是什么？</h2><p>Docker是容器的一种，容器是一种轻量级的虚拟技术，和容器对应的更为重量级的虚拟技术是虚拟机。虚拟机是一种基于硬件的虚拟技术，它采用指令级的模拟，完全模拟一整套物理主机。容器是一种基于操作系统的虚拟技术，它运行在操作系统之上的用户空间，所有的容器都共用一个系统内核，甚至是公共库，容器引擎提供进程级别的隔离，让每个容器都像运行在单独的系统之上，但又能共享很多底层资源。</p><h2 id="二、Docker的组件"><a href="#二、Docker的组件" class="headerlink" title="二、Docker的组件"></a>二、Docker的组件</h2><p>Docker采用C/S架构。Docker客户端，即Docker可执行程序，可以通过命令行和API的形式与Docker守候程序进行通信，Docker守候程序提供Docker服务。</p><p>Docker包含三大核心组件——镜像，容器和库。</p><ul><li>镜像：是一个只读的静态模板。它保存着容器需要的环境和应用的执行代码，可以把镜像看成是容器的代码，当代码运行起来后就成了容器。镜像采用分层机制，每个镜像都是只读的，但是可以将写数据的层通过联合文件系统附加在原有的镜像之上。这种增量式修改使得镜像非常容器存储、传输和更新。</li><li>容器：是一个运行时环境，它是一个镜像的运行状态，想到对于静态的镜像而言，容器是镜像执行的动态表现。</li><li>库：Docker采用注册服务器来存储和共享用户的镜像，库是某个特定用户存储镜像的目录。通常，一个用户可以建立多个库来保存自己的镜像。如Docker官方的Docker Hub。</li></ul><h2 id="三、容器的管理操作"><a href="#三、容器的管理操作" class="headerlink" title="三、容器的管理操作"></a>三、容器的管理操作</h2><ol><li><h3 id="创建容器"><a href="#创建容器" class="headerlink" title="创建容器"></a>创建容器</h3><ul><li><p>docker create</p><p> 创建的容器处于停止状态</p></li><li><p>docker run</p><p>不仅创建的容器，而且启动了容器</p></li></ul><p>容器创建后，会返回容器的ID。</p><p>要想让创建的容器立马进入运行态，可以使用<code>docker run</code>命令，该命令相当于下面的两条命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker create</span><br><span class="line">docker start</span><br></pre></td></tr></table></figure><p>使用<code>docker run</code>命令可以创建两种类型的容器——后台型容器和交互型容器。</p><ul><li>交互型容器：运行在前台，通常会指定有交互的控制台，可以给容器输入，也可以得到容器的输出。创建该容器的终端被关闭，在容器内部使用<code>exit</code>命令或者调用了<code>docker stop</code>、<code>docker kill</code>命令后，容器会变成停止状态。</li><li>后台型容器：运行在后台，创建启动之后就与终端无关。即便终端关闭了，该后台容器也依然存在，只有调用<code>docker stop</code>或<code>docker kill</code>命令时才能够使容器变成停止状态。</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -i -t --name=inspect_shell ubuntu /bin/bash</span><br></pre></td></tr></table></figure><p>其中，<code>-i</code>用于打开容器的标准输入(STDIN),<code>-t</code>告诉Docker为容器建立一个命令行终端。</p><p><code>--name</code>为容器指定一个名字，是一个可选项。如果没有这个选项，Docker会为容器创建一个随机名字</p><p><code>ubuntu</code>是镜像名，<code>/bin/bash</code>代表告诉Docker要在容器里面执行命令<code>/bin/bash</code>。</p><p>执行该命令之后，如果本地没有该镜像，Docker会从远程仓库中获取。然后，Docker使用这个镜像创建一个新的容器并将其启动；容器的文件系统是在只读的镜像文件上增加一层可读写的文件层，这样可以保证镜像不变而只记录改变的数据，这对容器的共享和传输都非常有利。接着会配置容器的网络，Docker会为容器分配一个虚拟网络接口，并通过网桥的方式将该网络接口桥接到宿主主机上，然后该虚拟网络接口分配一个IP地址。最后，Docker在新容器中运行指定的命令。</p></li><li><h3 id="查看容器"><a href="#查看容器" class="headerlink" title="查看容器"></a>查看容器</h3><p>查看正在运行的容器：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker ps</span><br></pre></td></tr></table></figure><p>CONTAINER ID：唯一标识容器的ID</p><p>IMAGE：创建容器时使用的镜像</p><p>COMMAND：容器最后运行的命令</p><p>CREATED：创建容器的时间</p><p>STATUS：容器的状态</p><p>PORT：对外开放的接口</p><p>NAMES：容器名。和容器ID一样都可以唯一标识一个容器。</p><p>查看所有的容器：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker ps -a</span><br></pre></td></tr></table></figure><p>列出所有容器，包括运行的和停止的容器。</p></li><li><h3 id="启动容器"><a href="#启动容器" class="headerlink" title="启动容器"></a>启动容器</h3><p>通过<code>docker create</code>命令创建的容器会进入到停止状态，想要运行该容器，可以执行以下命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker start 容器名/容器ID</span><br></pre></td></tr></table></figure></li><li><h3 id="终止容器"><a href="#终止容器" class="headerlink" title="终止容器"></a>终止容器</h3><p>执行命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker stop 容器名/容器ID</span><br></pre></td></tr></table></figure></li><li><h3 id="删除容器"><a href="#删除容器" class="headerlink" title="删除容器"></a>删除容器</h3><p>执行命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rm 容器名</span><br></pre></td></tr></table></figure><p>注意：不可以删除一个运行中的容器，必须先用<code>docker stop</code>或<code>docker kill</code>命令停止它才能删除。当然，也可以使用<code>-f</code>选项强制删除。</p><p>删除所有容器：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rm 'docker ps -a -q'</span><br></pre></td></tr></table></figure><p><code>-a</code>标志列出所有容器，<code>-q</code>标志只列出容器的ID，不包括容器的其他信息。然后将这个列表传给<code>docker rm</code>命令，依次删除容器。</p></li></ol><h2 id="四、容器内信息获取与命令执行"><a href="#四、容器内信息获取与命令执行" class="headerlink" title="四、容器内信息获取与命令执行"></a>四、容器内信息获取与命令执行</h2><ol><li><h3 id="依附容器"><a href="#依附容器" class="headerlink" title="依附容器"></a>依附容器</h3><p>依附操作<code>attach</code>通常用于由<code>docker start</code>或者<code>docker restart</code>启动的交互型容器中。由于<code>docker start</code>启动的交互型容器并没有具体终端可以依附，而容器本身是可以接收用户交互的，这时就需要通过<code>attach</code>命令来将终端依附到容器上。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker attach 容器ID</span><br></pre></td></tr></table></figure></li></ol><ol start="2"><li><h3 id="查看容器日志"><a href="#查看容器日志" class="headerlink" title="查看容器日志"></a>查看容器日志</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker logs -f 容器名 </span><br><span class="line">docker logs -f --tails=5 容器名   #控制logs输出的日志行数，只输出最后五行</span><br></pre></td></tr></table></figure></li></ol><ol start="3"><li><h3 id="查看容器进程"><a href="#查看容器进程" class="headerlink" title="查看容器进程"></a>查看容器进程</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker top 容器名</span><br></pre></td></tr></table></figure></li><li><h3 id="查看容器信息"><a href="#查看容器信息" class="headerlink" title="查看容器信息"></a>查看容器信息</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker inspect 容器名</span><br></pre></td></tr></table></figure><p>用来查看容器的配置环境，包括容器名，环境变量，运行命令，主机配置，网络配置和数据卷配置等。使用<code>-f</code>或者<code>--format</code>命令格式化标志，可以查看指定部分的信息。</p></li><li><h3 id="容器的导入与导出"><a href="#容器的导入与导出" class="headerlink" title="容器的导入与导出"></a>容器的导入与导出</h3><p>Docker的导入和导出分别由<code>import</code>命令和<code>export</code>命令完成。</p><p>使用<code>docker export</code>命令导出容器：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker export 容器名 &gt; my_container.tar</span><br></pre></td></tr></table></figure><p><code>docker export</code>命令会把容器的文件系统以tar包的格式导出到标准输出。我们将其定位到目标文件<code>name.tar</code>。将容器保存到本地文件也算是持久化方式的一种。将容器保存到本次之后，我们就可以通过网络等方法将tar包分享给他人。</p><p>使用<code>docker import</code>命令导入一个本地的tar包作为镜像：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat my_container.tar | docker import - imported:container</span><br></pre></td></tr></table></figure><p><code>docker import</code>会把打包的容器导入为一个镜像。</p><p><code>import</code>表示从标准输入读取容器内容，我们把<code>name.tar</code>的内容传给标准输入，res和tag代表生成的镜像和标记。</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、Docker是什么？&quot;&gt;&lt;a href=&quot;#一、Docker是什么？&quot; class=&quot;headerlink&quot; title=&quot;一、Docker是什么？&quot;&gt;&lt;/a&gt;一、Docker是什么？&lt;/h2&gt;&lt;p&gt;Docker是容器的一种，容器是一种轻量级的虚拟技术，和容器
      
    
    </summary>
    
      <category term="分布式与云计算" scheme="https://wanqbin.xyz/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%8E%E4%BA%91%E8%AE%A1%E7%AE%97/"/>
    
    
      <category term="Docker" scheme="https://wanqbin.xyz/tags/Docker/"/>
    
      <category term="容器" scheme="https://wanqbin.xyz/tags/%E5%AE%B9%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>Kubernetes集群部署</title>
    <link href="https://wanqbin.xyz/2019/Kubernetes%E9%9B%86%E7%BE%A4%E9%83%A8%E7%BD%B2/"/>
    <id>https://wanqbin.xyz/2019/Kubernetes集群部署/</id>
    <published>2019-11-19T14:05:00.000Z</published>
    <updated>2019-11-19T14:08:22.267Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、环境概述"><a href="#一、环境概述" class="headerlink" title="一、环境概述"></a>一、环境概述</h2><ul><li><h3 id="节点信息"><a href="#节点信息" class="headerlink" title="节点信息"></a>节点信息</h3></li></ul><table><thead><tr><th>IP</th><th>角色</th><th>服务器名</th></tr></thead><tbody><tr><td>192.168.43.60</td><td>Master</td><td>Matser</td></tr><tr><td>192.168.43.61</td><td>Node</td><td>Node1</td></tr><tr><td>192.168.43.62</td><td>Node</td><td>Node2</td></tr><tr><td>192.168.43.63</td><td>Node</td><td>Node3</td></tr></tbody></table><ul><li><h3 id="服务器配置信息"><a href="#服务器配置信息" class="headerlink" title="服务器配置信息"></a>服务器配置信息</h3><p>Master：虚拟机CentOS7</p><p>Node：虚拟机CentOS7</p></li></ul><ul><li><h3 id="节点分布："><a href="#节点分布：" class="headerlink" title="节点分布："></a>节点分布：</h3><p>利用局域网中的四台电脑中的虚拟机实现K8S集群的部署。</p></li></ul><h2 id="二、部署步骤"><a href="#二、部署步骤" class="headerlink" title="二、部署步骤"></a>二、部署步骤</h2><p>需要说明的是，kubernetes集群部署可以采用二进制文件进行安装，也可以采用kubeadm工具快速安装kubernetes，这里我使用了kubeadm工具。</p><ol><li><h3 id="设置服务器名"><a href="#设置服务器名" class="headerlink" title="设置服务器名"></a>设置服务器名</h3><p>分别设置各个服务器名：</p><p>执行命令：<code>vi /etc/hostname</code></p><p>Master：修改<code>localhost</code>为<code>Master</code></p><p>Node1：修改<code>localhost</code>为<code>Node1</code></p><p>Node2：修改<code>localhost</code>为<code>Node2</code></p><p>Node3：修改<code>localhost</code>为<code>Node3</code></p></li><li><h3 id="设置HOST"><a href="#设置HOST" class="headerlink" title="设置HOST"></a>设置HOST</h3><p>在每个节点中执行命令：<code>vi /etc/hosts</code></p><p>插入如下内容：</p></li></ol>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">192.168.43.60 Master</span><br><span class="line">192.168.43.61 Node1</span><br><span class="line">192.168.43.61 Node2</span><br><span class="line">192.168.43.61 Node3</span><br></pre></td></tr></table></figure><ol start="3"><li><h3 id="时间同步"><a href="#时间同步" class="headerlink" title="时间同步"></a>时间同步</h3><p>执行下列命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ntpdate cn.pool.ntp.org</span><br></pre></td></tr></table></figure><p>若提示ntpdate未安装，执行命令：<code>yum install ntpdate</code></p></li><li><h3 id="关闭防火墙-开启特定端口策略"><a href="#关闭防火墙-开启特定端口策略" class="headerlink" title="关闭防火墙/开启特定端口策略"></a>关闭防火墙/开启特定端口策略</h3><p>在各个节点上执行如下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">systemctl disable firewalld</span><br><span class="line">systemctl stop firewalld</span><br></pre></td></tr></table></figure></li></ol><ol start="5"><li><h3 id="禁用SELinux，让容器可以读取主机文件系统"><a href="#禁用SELinux，让容器可以读取主机文件系统" class="headerlink" title="禁用SELinux，让容器可以读取主机文件系统"></a>禁用SELinux，让容器可以读取主机文件系统</h3><p>在各个节点上执行如下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setenforce 0</span><br></pre></td></tr></table></figure></li></ol><ol start="6"><li><h3 id="配置yum源"><a href="#配置yum源" class="headerlink" title="配置yum源"></a>配置yum源</h3><p>在各个服务器上执行命令： <code>*vi /etc/yum.repos.d/kubernetes.repo*</code></p><p>插入如下内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[kubernetes]</span><br><span class="line">name=Kubernetes Repository</span><br><span class="line">baseurl=https://mirrors.aliyun.com/kubernetes/yum/repos/kubernetes-el7-x86_64/</span><br><span class="line">enabled=1</span><br><span class="line">gpgcheck=0</span><br></pre></td></tr></table></figure></li><li><h3 id="安装kubeadm和相关工具"><a href="#安装kubeadm和相关工具" class="headerlink" title="安装kubeadm和相关工具"></a>安装kubeadm和相关工具</h3><p>执行如下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install -y kubelet kubeadm kubectl --disableexcludes=kubernetes</span><br></pre></td></tr></table></figure></li><li><h3 id="安装docker-ce"><a href="#安装docker-ce" class="headerlink" title="安装docker-ce"></a>安装docker-ce</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install docker-ce</span><br></pre></td></tr></table></figure><p>若报类似于nothing的错误，执行命令：<code>yum update</code></p><p>然后执行<code>yum search docker-ce</code></p><p>之后根据查找结果安装docker-ce</p></li><li><h3 id="启动Docker服务和kubectl服务"><a href="#启动Docker服务和kubectl服务" class="headerlink" title="启动Docker服务和kubectl服务"></a>启动Docker服务和kubectl服务</h3><p>执行下列命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">systemctl enable docker &amp;&amp; systemctl start docker</span><br><span class="line">systemctl enable kubelet &amp;&amp; systemctl start kubelet</span><br></pre></td></tr></table></figure></li><li><h3 id="检测docker服务和kubelet服务"><a href="#检测docker服务和kubelet服务" class="headerlink" title="检测docker服务和kubelet服务"></a>检测docker服务和kubelet服务</h3><p>执行下列命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">systemctl status docker</span><br><span class="line">systemctl status kubelet</span><br></pre></td></tr></table></figure><p>执行结果显示绿色字样的<code>running</code>即为正常状态。</p></li><li><h3 id="通过kubeadm获取初始化配置文件"><a href="#通过kubeadm获取初始化配置文件" class="headerlink" title="通过kubeadm获取初始化配置文件"></a>通过kubeadm获取初始化配置文件</h3><p>执行命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">kubeadm config print init-defaults &gt; init.default.yaml</span><br><span class="line">cp init.default.yaml init-config.yaml</span><br><span class="line">vi init-config.yaml</span><br></pre></td></tr></table></figure><p>修改内容如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">kubeadm.k8s.io/v1beta2</span></span><br><span class="line"><span class="attr">bootstrapTokens:</span></span><br><span class="line"><span class="attr">- groups:</span></span><br><span class="line"><span class="attr">  - system:</span><span class="attr">bootstrappers:kubeadm:default-node-token</span></span><br><span class="line"><span class="attr">  token:</span> <span class="string">lo7fj7.j16rob4ic6mbgs5q</span></span><br><span class="line"><span class="attr">  ttl:</span> <span class="number">24</span><span class="string">h0m0s</span></span><br><span class="line"><span class="attr">  usages:</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">signing</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">authentication</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">InitConfiguration</span></span><br><span class="line"><span class="attr">localAPIEndpoint:</span></span><br><span class="line"><span class="attr">  advertiseAddress:</span> <span class="number">192.168</span><span class="number">.43</span><span class="number">.60</span>   <span class="comment">#master IP</span></span><br><span class="line"><span class="attr">  bindPort:</span> <span class="number">6443</span></span><br><span class="line"><span class="attr">nodeRegistration:</span></span><br><span class="line"><span class="attr">  criSocket:</span> <span class="string">/var/run/dockershim.sock</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">master</span></span><br><span class="line"><span class="attr">  taints:</span></span><br><span class="line"><span class="attr">  - effect:</span> <span class="string">NoSchedule</span></span><br><span class="line"><span class="attr">    key:</span> <span class="string">node-role.kubernetes.io/master</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiServer:</span></span><br><span class="line"><span class="attr">  timeoutForControlPlane:</span> <span class="number">4</span><span class="string">m0s</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">kubeadm.k8s.io/v1beta2</span></span><br><span class="line"><span class="attr">certificatesDir:</span> <span class="string">/etc/kubernetes/pki</span></span><br><span class="line"><span class="attr">clusterName:</span> <span class="string">kubernetes</span></span><br><span class="line"><span class="attr">controllerManager:</span> <span class="string">&#123;&#125;</span></span><br><span class="line"><span class="attr">dns:</span></span><br><span class="line"><span class="attr">  type:</span> <span class="string">CoreDNS</span></span><br><span class="line"><span class="attr">etcd:</span></span><br><span class="line"><span class="attr">  local:</span></span><br><span class="line"><span class="attr">    dataDir:</span> <span class="string">/var/lib/etcd</span></span><br><span class="line"><span class="attr">imageRepository:</span> <span class="string">registry.aliyuncs.com/google_containers</span>  <span class="comment">#镜像源，国内</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ClusterConfiguration</span></span><br><span class="line"><span class="attr">kubernetesVersion:</span> <span class="string">v1.16.0</span></span><br><span class="line"><span class="attr">networking:</span></span><br><span class="line"><span class="attr">  dnsDomain:</span> <span class="string">cluster.local</span></span><br><span class="line"><span class="attr">  podSubnet:</span> <span class="string">"192.168.0.0/16"</span></span><br><span class="line"><span class="attr">  serviceSubnet:</span> <span class="number">10.96</span><span class="number">.0</span><span class="number">.0</span><span class="string">/12</span></span><br><span class="line"><span class="attr">scheduler:</span> <span class="string">&#123;&#125;</span></span><br></pre></td></tr></table></figure></li><li><h3 id="修改docker镜像源"><a href="#修改docker镜像源" class="headerlink" title="修改docker镜像源"></a>修改docker镜像源</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"> &quot;registry-mirrors&quot;:[&quot;https://e384u25y.mirror.aliyuncs.com&quot;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的镜像源是阿里云加速链接，可以注册阿里云账号，然后在镜像服务中找到专属的加速链接</p></li><li><h3 id="下载镜像文件"><a href="#下载镜像文件" class="headerlink" title="下载镜像文件"></a>下载镜像文件</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubeadm config images pull --config=init-config.yaml</span><br></pre></td></tr></table></figure></li></ol><ol start="14"><li><h3 id="使用kubeadm-init命令安装Master"><a href="#使用kubeadm-init命令安装Master" class="headerlink" title="使用kubeadm init命令安装Master"></a>使用<code>kubeadm init</code>命令安装Master</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubeadm init --config=init-config.yaml</span><br></pre></td></tr></table></figure><p>在安装的过程中可能会出现比较多的问题。</p><ul><li>如果是镜像源的问题，可以重新启动docker服务，加载修改的镜像源，命令如下：</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">systemctl daemon-reload</span><br><span class="line">systemctl restart docker</span><br></pre></td></tr></table></figure><ul><li><p>如果是提示<code>hostname &quot;master&quot; could not be reached</code>之类的问题，可以修改<code>/etc/hosts</code>文件，见第2步。</p><p>若提示如下问题：</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">running with swap on is not supported. Please disable swap</span><br></pre></td></tr></table></figure><p>执行命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*swapoff -a*</span><br></pre></td></tr></table></figure><ul><li><p>若提示如下问题：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[ERROR FileContent--proc-sys-net-bridge-bridge-nf-call-iptables]: /proc/sys/net/bridge/bridge-nf-call-iptables contents are not set to 1</span><br></pre></td></tr></table></figure><p>执行命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo 1 &gt; /proc/sys/net/ipv4/ip_forward</span><br></pre></td></tr></table></figure></li></ul><p>安装成功后会出现如下提示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Your Kubernetes control-plane has initialized successfully!</span><br></pre></td></tr></table></figure><p>在最下面的提示信息中也会出现token，这用于节点加入集群，不过这个token只有24小时的有效期。我们也可以使用其他命令生成永久的token。</p></li><li><h3 id="准备配置文件，以便系统重启时，自动启动集群"><a href="#准备配置文件，以便系统重启时，自动启动集群" class="headerlink" title="准备配置文件，以便系统重启时，自动启动集群"></a>准备配置文件，以便系统重启时，自动启动集群</h3><p>执行命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p $HOME/.kube</span><br><span class="line">cp -i /etc/kubernetes/admin.conf $HOME/.kube/config</span><br><span class="line">chown $(id -u):$(id -g) $HOME/.kube/config</span><br></pre></td></tr></table></figure></li></ol><ol start="16"><li><h3 id="验证安装是否成功"><a href="#验证安装是否成功" class="headerlink" title="验证安装是否成功"></a>验证安装是否成功</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@Master ~]# kubectl get -n kube-system configmap</span><br><span class="line">NAME                                 DATA   AGE</span><br><span class="line">coredns                              1      10d</span><br><span class="line">extension-apiserver-authentication   6      10d</span><br><span class="line">kube-proxy                           2      10d</span><br><span class="line">kubeadm-config                       2      10d</span><br><span class="line">kubelet-config-1.16                  1      10d</span><br></pre></td></tr></table></figure><p>至此，master节点安装完毕。下面安装node节点。</p></li><li><h3 id="安装节点"><a href="#安装节点" class="headerlink" title="安装节点"></a>安装节点</h3><p>在各个节点上重复步骤1~10。</p></li><li><h3 id="通过kubeadm获取join配置文件"><a href="#通过kubeadm获取join配置文件" class="headerlink" title="通过kubeadm获取join配置文件"></a>通过kubeadm获取join配置文件</h3><p>执行命令如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kubeadm config print join-defaults &gt; join-config.yaml</span><br><span class="line">vim join-config.yaml</span><br></pre></td></tr></table></figure><p>然后修改内容如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">kubeadm.k8s.io/v1beta2</span></span><br><span class="line"><span class="attr">caCertPath:</span> <span class="string">/etc/kubernetes/pki/ca.crt</span></span><br><span class="line"><span class="attr">discovery:</span></span><br><span class="line"><span class="attr">  bootstrapToken:</span></span><br><span class="line"><span class="attr">    apiServerEndpoint:</span> <span class="number">192.168</span><span class="number">.43</span><span class="number">.60</span><span class="string">:6443</span>  <span class="comment">#这地方是master节点的IP</span></span><br><span class="line"><span class="attr">    token:</span> <span class="string">lo7fj7.j16rob4ic6mbgs5q</span>   <span class="comment">#这地方是token，一般是初始化的toke，和master节点中的init文件中的token相同</span></span><br><span class="line"><span class="attr">    unsafeSkipCAVerification:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">  timeout:</span> <span class="number">5</span><span class="string">m0s</span></span><br><span class="line"><span class="attr">  tlsBootstrapToken:</span> <span class="string">lo7fj7.j16rob4ic6mbgs5q</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">JoinConfiguration</span></span><br><span class="line"><span class="attr">nodeRegistration:</span></span><br><span class="line"><span class="attr">  criSocket:</span> <span class="string">/var/run/dockershim.sock</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">node1</span>   <span class="comment">#节点名，每个节点的名字必须不同</span></span><br><span class="line"><span class="attr">  taints:</span> <span class="literal">null</span></span><br></pre></td></tr></table></figure></li><li><h3 id="运行kubeadm-join命令加入集群"><a href="#运行kubeadm-join命令加入集群" class="headerlink" title="运行kubeadm join命令加入集群"></a>运行<code>kubeadm join</code>命令加入集群</h3><p>执行命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubeadm join --config=join-config.yaml</span><br></pre></td></tr></table></figure></li></ol><ol start="20"><li><h3 id="查看已加入节点"><a href="#查看已加入节点" class="headerlink" title="查看已加入节点"></a>查看已加入节点</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@Master ~]# kubectl get node</span><br><span class="line">NAME     STATUS     ROLES    AGE     VERSION</span><br><span class="line">master   NotReady   master   10d     v1.16.2   </span><br><span class="line">node1    NotReady   &lt;none&gt;   7d12h   v1.16.2</span><br><span class="line">node2    NotReady   &lt;none&gt;   7d12h   v1.16.2</span><br><span class="line">node3    NotReady   &lt;none&gt;   7d12h   v1.16.2</span><br></pre></td></tr></table></figure><p>在节点加入成功后，执行命令的结果如上。这里notready是因为没有安装网络插件。网络插件比较多，比如weave，Flannel等。这里安装weave。</p></li><li><h3 id="安装网络插件"><a href="#安装网络插件" class="headerlink" title="安装网络插件"></a>安装网络插件</h3><p>执行命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl apply -f "https://cloud.weave.works/k8s/net?k8s-version=$(kubectl version | base64 | tr -d '\n')"</span><br></pre></td></tr></table></figure><p>这里可能会因为科学上网的问题而出现ErrImage或者ImagePullback等问题。我的也出现了这个问题，后来不知道什么原因，突然就安装上了。</p></li><li><h3 id="验证Kubernetes集群是否安装完成"><a href="#验证Kubernetes集群是否安装完成" class="headerlink" title="验证Kubernetes集群是否安装完成"></a>验证Kubernetes集群是否安装完成</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">kube-system            coredns-58cc8c89f4-8rxzx                     1/1     Running            13         7d12h</span><br><span class="line">kube-system            coredns-58cc8c89f4-cdwm7                     1/1     Running            15         7d12h</span><br><span class="line">kube-system            etcd-master                                  1/1     Running            26         10d</span><br><span class="line">kube-system            kube-apiserver-master                        1/1     Running            265        10d</span><br><span class="line">kube-system            kube-controller-manager-master               1/1     Running            108        10d</span><br><span class="line">kube-system            kube-proxy-bhdzd                             1/1     Running            9          7d1h</span><br><span class="line">kube-system            kube-proxy-dj4qt                             1/1     Running            14         7d1h</span><br><span class="line">kube-system            kube-scheduler-master                        1/1     Running            96         10d</span><br><span class="line">kube-system            weave-net-6nd4h                              2/2     Running            44         7d12h</span><br><span class="line">kube-system            weave-net-9tzjk                              2/2     Running            41         7d19h</span><br></pre></td></tr></table></figure><p>这里，Kubernetes集群就可以搭建完毕了。</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、环境概述&quot;&gt;&lt;a href=&quot;#一、环境概述&quot; class=&quot;headerlink&quot; title=&quot;一、环境概述&quot;&gt;&lt;/a&gt;一、环境概述&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;h3 id=&quot;节点信息&quot;&gt;&lt;a href=&quot;#节点信息&quot; class=&quot;headerlink&quot;
      
    
    </summary>
    
      <category term="分布式与云计算" scheme="https://wanqbin.xyz/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%8E%E4%BA%91%E8%AE%A1%E7%AE%97/"/>
    
    
      <category term="k8s" scheme="https://wanqbin.xyz/tags/k8s/"/>
    
      <category term="分布式集群" scheme="https://wanqbin.xyz/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E9%9B%86%E7%BE%A4/"/>
    
  </entry>
  
  <entry>
    <title>面向对象设计原则</title>
    <link href="https://wanqbin.xyz/2019/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/"/>
    <id>https://wanqbin.xyz/2019/面向对象设计原则/</id>
    <published>2019-11-18T17:06:00.000Z</published>
    <updated>2019-11-18T17:07:20.490Z</updated>
    
    <content type="html"><![CDATA[<p>面向对象设计，为什么？</p><p>变化是复用的天敌，面向对象设计最大的优势在于：抵御变化。</p><p>重新认识面向对象</p><ul><li>理解隔离变化<ul><li>从宏观层面来看，面向对象的构建方式更能适应软件的变化，能将变化所带来的影响减为最小</li></ul></li><li>各司其职<ul><li>从微观层面来看，面向对象的方式更强调各个类的“责任”</li><li>由于需求变化导致的新增类型不应该影响原来类型的实现——是所谓各司其职。</li></ul></li><li>对象是什么<ul><li>从语言实现层面来看，对象封装了代码和数据</li><li>从规格层面讲，对象是一系列可被使用的公共接口</li><li>从概念层面讲，对象时某种拥有责任的抽象。</li></ul></li></ul><p>面向对象设计原则</p><ul><li><p>依赖倒置原则（DIP)</p><ul><li>高层模块（稳定）不应该依赖于底层模块（变化），二者都应该依赖于抽象（稳定）</li><li>抽象（稳定）不应该依赖于实现细节（变化），实现细节应该依赖于抽象（稳定）。</li></ul></li><li><p>开放封闭原则（OCP)</p><ul><li>对扩展开放，对更改封闭</li><li>类模块应该是可扩展的，但是不可修改</li></ul></li><li><p>单一职责原则</p><ul><li>一个类应该仅有一个引起它变化的原因</li><li>变化的方向隐含着类的责任。</li></ul></li><li><p>Liskov替换原则（LSP）</p><ul><li>子类必须能够替换它们的基类</li><li>继承表达类型抽象</li></ul></li><li><p>接口隔离原则（ISP）</p><ul><li>不应该强迫客户程序依赖它们不用的方法</li><li>接口应该小而完备</li></ul></li><li><p>优先使用对象组合，而不是类继承</p><ul><li>类继承通常为“白箱复用”，对象组合通常为“黑箱复用”</li><li>继承在某种程度上破坏了封装性，子类父类耦合度高</li><li>而对象组合则只要求被组合的对象具有良好定义的接口，耦合度低</li></ul></li><li><p>封装变化点</p><ul><li>使用封装来创建对象之间的分界层，让设计者可以在分界层一侧进行修改，而不会对另一侧产生不良的影响，从而实现层次间的松耦合</li></ul></li><li><p>针对接口编程，而不是针对实现编程</p><ul><li>不将变量类型声明为某个特定的具体类，而是声明为某个接口。</li><li>客户程序无需获知对象的具体类型，只需要知道对象所具有的接口</li><li>减少系统中各部分的依赖关系，从而实现“高内聚，松耦合”的类型设计方案。</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;面向对象设计，为什么？&lt;/p&gt;
&lt;p&gt;变化是复用的天敌，面向对象设计最大的优势在于：抵御变化。&lt;/p&gt;
&lt;p&gt;重新认识面向对象&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;理解隔离变化&lt;ul&gt;
&lt;li&gt;从宏观层面来看，面向对象的构建方式更能适应软件的变化，能将变化所带来的影响减为最小&lt;/li
      
    
    </summary>
    
      <category term="设计模式" scheme="https://wanqbin.xyz/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="https://wanqbin.xyz/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="面向对象设计原则、" scheme="https://wanqbin.xyz/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99%E3%80%81/"/>
    
  </entry>
  
  <entry>
    <title>什么是设计模式？</title>
    <link href="https://wanqbin.xyz/2019/%E4%BB%80%E4%B9%88%E6%98%AF%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%9F/"/>
    <id>https://wanqbin.xyz/2019/什么是设计模式？/</id>
    <published>2019-11-18T17:05:00.000Z</published>
    <updated>2019-11-18T17:06:06.114Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>每一个模式描述了一个在我们周围不断重复发生的问题，以及该问题的解决方案的核心。这样，你就能一次又一次地使用该方案而不必做重复劳动。</p><p>​                                                                           ——Christopher Alexander</p></blockquote><p>一般而言，一个模式有四个基本要素：</p><ol><li><p>模式名称。</p><p>一个助记名，它用一两个词来描述模式的问题，解决方案和效果。命名一个新的设计模式增加了我们的设计词汇。设计模式允许我们在较高的抽象层次进行设计。</p></li><li><p>问题。</p><p>描述了应该在何时使用模式。它解释了设计问题和问题存在的前提，它可能描述了特定的设计问题，如怎样用对象表示算法。也可能描述了导致不灵活设计的类或对象结构。</p></li><li><p>解决方案</p><p>描述了设计的组成成分，它们之间的相互关系以及各自的职责和协作方式。因为模式就像是一个模板，可应用于多种不同场合，所以解决方案并不描述一个特定而具体的设计或实现，而是提供设计问题的抽象和怎样用一个具有一般意义的元素组合来解决这个问题。</p></li><li><p>效果。</p><p>描述了模式应用的效果以及使用模式应权衡的问题。尽管我们描述设计决策时，并不总提到设计模式，但它们对于评价设计选择和理解使用模式的代价以及好处具有重要意义。软件效果大多关注对时间和空间的衡量，它们也表述了语言和实现问题。因为复用是面向对象设计的要素之一，所以模式效果包括它对系统灵活性、扩充性或可移动性的影响，显式地列出这些效果对理解和评价这些模式很有帮助。</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;每一个模式描述了一个在我们周围不断重复发生的问题，以及该问题的解决方案的核心。这样，你就能一次又一次地使用该方案而不必做重复劳动。&lt;/p&gt;
&lt;p&gt;​                                                  
      
    
    </summary>
    
      <category term="设计模式" scheme="https://wanqbin.xyz/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="https://wanqbin.xyz/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>传输控制协议TCP</title>
    <link href="https://wanqbin.xyz/2019/%E4%BC%A0%E8%BE%93%E6%8E%A7%E5%88%B6%E5%8D%8F%E8%AE%AETCP/"/>
    <id>https://wanqbin.xyz/2019/传输控制协议TCP/</id>
    <published>2019-11-18T17:04:00.000Z</published>
    <updated>2019-11-18T17:04:33.756Z</updated>
    
    <content type="html"><![CDATA[<p>TCP是TCP/IP体系中面向连接的运输层协议，它提供了全双工的和可靠交付的服务。TCP与UDP最大的区别就是：TCP是面向连接的，而UDP是无连接的。TCP比UDP复杂的多，除了具有面向连接和可靠传输的特性外，TCP还在运输层使用流量控制和拥塞控制机制。</p><h2 id="一、TCP的主要特点"><a href="#一、TCP的主要特点" class="headerlink" title="一、TCP的主要特点"></a>一、TCP的主要特点</h2><ul><li>TCP是面向连接的运输层协议。这就是说，应用程序在使用TCP提供的服务传送数据之前，必须先建立TCP连接。建立TCP连接的目的是通信双方为接下来的数据传送做好准备，初始化各种状态变量，分配缓存等资源，在传送数据完毕后，必须释放已建立的TCP连接，即释放相应的资源和变量。</li><li>每一条TCP连接只能有两端点，即每一条TCP连接只能是点对点的（一对一）。TCP连接唯一地被通信两端的端点所确定，而两个端点分别由二元组（IP地址，端口号）唯一标识，即一条TCP连接由两个套接字地址标识。</li><li>TCP是提供可靠服务的。也就是说，通过TCP连接传送的数据无差错，不丢失，不重复，并且按序到达。</li><li>TCP提供全双工通信。TCP允许通信双方的应用进程在任何时候都能发送数据。TCP连接的两端都没有发送缓存和接受缓存，用来临时存放双向通信的数据。在发送时，应用程序在把数据传送给TCP的缓存后，就可以做自己的事，而TCP在合适的时候把数据发送出去。在接收时，TCP把收到的数据放入缓存，上层的应用进程在合适的时候读取缓存中的数据。</li><li>面向字节流。TCP中的流指的是流入到进程或从进程流出的字节序列。面向字节流的含义是：虽然应用程序和TCP的交互时一次一个数据块，但TCP把应用程序交下来的数据看成是一连串的无结构的字节流。TCP不保证接收方应用程序收到的数据块和发送方应用程序所发出的数据块具有对应大小的关系，从TCP接收方缓存中将数据读取完毕。但接受方应用程序收到的字节流必须和发送方应用程序发出的字节流完全一样。</li></ul><p>发送方的应用进程按照自己产生数据的规律，不断地把数据块陆续写入到TCP的发送缓存中。TCP再从发送缓存中取出一定数量的数据，将其组成TCP报文段逐个传递给IP层，然后发送出去。</p><p>接收方从IP层收到TCP报文段后，先把它暂存在接收缓存中，然后等待接收方对应的应用进程从接收缓存中按顺序读取。需要注意的是，接收方应用进程每次从接收缓存中读取数据时，是按应用进程指定的数量读取数据，而不是一次读取接收缓存中的一个完整的报文段或所有数据。只有当接收缓存中的数据量小于应用进程指定的读取量时，才返回给应用进程接收缓冲中所有的数据。当接收缓存中完全没有数据时，根据读取方式的不同，应用进程可能会一直等待，也可能直接返回。由此可见，TCP的接收方应用进程读取的数据块与发送方应用进程发送的数据块边界毫无关系，也就是说，TCP接收方在向上层交付数据时不保证能保持发送方应用进程发送数据块的边界。</p><p>TCP连接时一条虚连接，而不是一条物理连接。也就是说，TCP连接时一种抽象的逻辑连接。</p><p>TCP报文段首先要传送到IP层，加上IP首部后，再传送到数据链路层，再加上数据链路层的首部和尾部后，才离开主机发送到物理链路。另外，TCP连接仅存在于两个端系统同中，而网络核心的中间设备完全不知道该连接的存在。TCP连接的组成主要包括：通信两端主机上的缓存、状态变量，在这两台主机间的路由器和交换机没有为该连接分配任何缓存和变量。</p><p>与UDP的端口队列不同的是，TCP的发送缓存和接受缓存都是分配给一个连接的，而不是一个端口。TCP的一个连接由四元组（源IP地址，源端口号，目的IP地址，目的端口号）标识，即由源/目的套接字地址对标识。也就是说，来自不同源的TCP报文段，即使它们的目的IP地址和面对端口号相同，它们也不可能被交付到同一个TCP接收缓存中，因为它们在不同的TCP管道中传输，到达不同管道出口的缓存。通常一个TCP服务器进程用一个端口号与不同的客户机进程建立多个连接，然后创建多个子进程分别用这些连接与各自的客户机进程进行通信。</p><h2 id="二、TCP报文段的格式"><a href="#二、TCP报文段的格式" class="headerlink" title="二、TCP报文段的格式"></a>二、TCP报文段的格式</h2><p>TCP虽然是面向字节流的，但TCP传送的数据单元却是报文段。TCP报文段分为首部和数据两部分，而TCP的全部功能都体现在它首部各字段的作用。</p><p>TCP报文段首部的前20个字节是固定的，后面有4N个字节是根据需要而增加的选项。因此，TCP首部的最小长度是20字节。</p><p>首部固定部分各字段的意义如下所述：</p><ul><li>源端口和目的端口。各占两个字节。与UDP一样，该字段定义了主机中发送和接受该报文段的应用程序的端口号，用于运输层的复用和分用。</li><li>序号。占4个字节。序号从0开始，到$2^{32}-1$为止。TCP是面向数据流的.TCP传送的报文段可看成连续的数据流。在一个TCP连接中传送的数据流中的每一个字节都是按顺序编号。整个数据的起始序号在连接建立时设置。首部中的序号字段的值则指的是本报文段所含的数据的第一个字节的序号。</li><li>确认号。占4个字节，是期望收到对方的下一个报文段的第一个数据字节的序号。TCP提供的是双向通信，当一端发送数据时同时对接收到的对端数据进行确认。TCP采用的是累积确认。</li><li>数据偏移。占4位，它指出TCP报文段的数据起始处距离TCP报文段的起始处有多远。这实际上就是TCP报文段首部的长度。由于首部长度不固定，因此数据偏移字段是必要的。但应注意的是，“数据偏移”的单位不是字节而是32位字（即以4字节长的字为计算单位）。由于4位二进制数能够表示的最大十进制数字是15，因此数据偏移的最大值是60字节，这也是TCP首部的最大长度。</li><li>保留。占6位，保留为今后使用，但目前应置0.</li><li>紧急URG。当URG=1时，表明紧急指针字段有效。它告诉接收方TCP此报文段中有紧急数据，应尽快交付给应用程序，而不要按序从接收缓存中读取。</li><li>确认ACK。只有当ACK=1时确认号字段才有效。当ACK=0时，确认号无效。</li><li>推送PSH。处于效率的考虑，TCP可能会延迟发送数据或向应用程序延迟交付数据，这样可以一次处理更多的数据。但是当两个应用进程进行交互式通信时，有时在一段的应用进程希望在键入一个命令后立即就能得到对方的响应。在这种情况下，应用程序可以通知TCP使用推送操作。这时发送方TCP把PSH置1，并立即创建一个报文段发送出去，而不需要累积到足够多的数据再发送。。接收TCP收到PSH置1的报文段，就尽快地交付给接收应用进程，而不要等到收到足够多的的数据才向上交付。</li><li>复位RST。当RST=1时，表明TCP连接中出现严重差错，必须释放连接，然后再从新建立运输连接。RST置1还用来拒绝一个非法的报文段或拒绝打开一个连接。RST也可称为重建位或重置位。</li><li>同步SYN。用来建立一个连接。当SYN=1而ACK=0时，表明这是一个连接请求报文段。对方若同意建立连接，则应在响应的报文段中使SYN=1和ACK=1。因此，SYN置1就表示这是一个连接请求或连接接收报文。</li><li>终止FIN。用来释放一个连接。当FIN=1时，表明此报文段的发送方的数据已发送完毕，并要求释放运输连接。</li><li>窗口。占两字节。窗口值指示发送该报文段的接受窗口大小，在0到$2^{16}-1$之间。窗口字段用来控制对方发送的数据量，单位为字节。窗口字段反映了接收方接收缓存的可用空间大小。</li><li>检验和。占两个字节。检验和字段检验的范围包括首部和数据两部分。</li><li>选项。长度可变。这里介绍一个，即最大报文段长度（MSS）。</li></ul><h2 id="三、TCP的可靠传输"><a href="#三、TCP的可靠传输" class="headerlink" title="三、TCP的可靠传输"></a>三、TCP的可靠传输</h2><ul><li><p>数据编号与确认</p><p>TCP是面向字节的。TCP把应用层交下来的长报文看成是一个个字节组成的数据流，并使每一个字节对应于一个序号。注意，GBN协议中是对每个分组进行编号在。在建立连接时，双方TCP要各自确定初始序号。TCP每次发送的报文段的首部中的序号字段数值表示该报文段中紧接着首部后面的第一个数据字节的序号。</p><p>TCP使用累积确认，即确认是对所有按序收到的数据的确认。但请注意，接收方返回的确认号时已按序收到的数据的最高序号加1.也就是说，确认号表示接收方期望下一次收到的数据中的第一个数据直接序号。</p><p>当TCP发送一报文段时，它同时也咋自己的重传队列中存放这个报文段的一个副本。若收到确认，则删除此副本。若在规定时间内没有收到确认，则重传此报文段的副本。TCP的确认并不保证数据已交付给了应用进程，而只是表明在接收方的TCP已按序正确收到了对方所发送的报文段。</p><p>由于TCP连接能提供全双工通信，因此通信中的每一方都不必专门发送确认报文段，而可以在传送数据时顺便把确认信息捎带传送。为此，TCP采用了一种延迟确的机制，即接收方在正确接收到数据时可能要等待一段时间再发送确认。若这段时间内有数据要发送给对方，则可以捎带确认。也有可能在这段时间内又有数据到达，则可以同时对这两次到达的数据进行累计确认。这样做可以减少发送完全不带数据的确认报文段，以提高TCP的传输效率。</p><p>接收方若收到有差错的报文段就丢弃。若收到重复的报文段，也要丢弃，但要立即发回确认信息。</p><p>若收到的报文段无差错，只是未按序号顺序到达，那么应如何处理？在GBN协议中会丢弃所有未按序到达的分组，但是TCP对此未做明确规定，而是让TCP的实现者自行确定。可以像GBN协议一样将不按序到达的报文段丢弃，但多数TCP实现是先将其暂存与接收缓存内，待所缺序号的报文段收齐后再一起上交应用层。在互联网环境中，封装TCP报文段和IP数据报不一定是按序到达的，将失序的报文段先缓存起来可以避免不必要的重传。注意，不论采用哪种方法，接收方都要立即对已按序接收到的数据进行确认。</p><p>TCP发送方每发送一个报文段，就会为这个报文段设置一个计时器。只要计时器设置的重传时间已经到了但还没有收到确认，就要重传这一报文段。我们知道，在GBN协议中，一旦发送方某个分组超时，则会重传窗口内所有已发送的分组。而在TCP中发送方只会重传超时的那一个报文段，如果后序报文段的确认能够在超时之前及时到达，则不会重传那些还没有超时的后续报文段。</p></li><li><p>以字节为单位的滑动窗口</p><p>为了提高报文段的传输效率，TCP采用滑动窗口协议。但与GBN协议不同的是，TCP发送窗口大小的单位是字节，而不是分组数。TCP发送方已发送的未被确认的字节数不能超过发送窗口的大小。</p><p>落入发送窗口内的是允许发送的字节，落在发送窗口外左侧的是已发送并被确认的字节，而落在发送窗口外右侧是是还不能发送的字节。收到确认后，发送窗口向右滑动，直到发送窗口的左沿正好包含确认序号的字节。</p><p>发送缓存用来暂时存放：</p><ul><li>发送应用程序传送给发送方TCP准备发送的数据</li><li>TCP已发送出去但尚未收到确认的数据</li></ul><p>发送窗口通常只是发送缓存的一半部分。已被确认的数据应当才能够发送缓存中删除，因此发送缓存和发送窗口的后沿是重合的。发送应用程序最后写入发送缓存的字节序号减去最后被确认的字节序号，就是还保留在发送缓存的被写入的字节数。如果发送应用程序传送给TCP发送方的速度太快，可能会最终导致发送缓存被填满，这时发送应用程序必须等待，直到有数据从发送缓存中删除。</p><p>接收缓存用来暂时存放：</p><ul><li>按序到达的，但尚未被接受应用程序读取的数据</li><li>未按序到达的，但还不能被接收应用程序读取的数据</li></ul><p>如果收到的分组被检测出有差错，则要丢弃。如果接受应用程序来不及读取收到的数据，接收缓存最终就会被填满，使接收窗口减小到0.反之，如果接受应用程序能够及时从接收缓存中读取收到的数据，接收窗口就会增大，但最大不能超过接收缓存的大小。</p></li><li><p>超时重传时间的选择</p><p>由于TCP的下层是互联网环境，发送的报文段可能只经过一个高速率的局域网，但也可能经过多个低速率的广域网，并且每个IP数据报所选择的路由还可能不同，不同时间网络拥塞情况也有不同。因此往返时间是不断变化的。</p><p>对于运输层来说，其往返时间的方差很大。如果把超时时间设置得太短，则很多报文段就会过早超时，引起很多报文段的不必要的重传，使网络负荷增大。但如果把超时时间设置得过长，则大量丢失的报文段不能被及时重传，降低了传输效率。因此，选择超时重传时间再数据链路层并不困难，但在运输层却不那么简单。</p><p>那么。运输层的超时计时器的超时重传时间究竟应设置为多大呢？<br>显然，超时重传时间应比当前报文段的往返时间要长一些。针对互联网环境中端到端的时延是动态变化的特点，TCP才用了一种自适应算法。该算法记录每个报文段发出的时间，以及收到相应的确认报文段的时间。这两个时间之差就是报文段得到往返时间RTT。在互联网中，实际的RTT测量值变化非常大，因此需要用多个RTT测量值的平均值来估计当前报文段的RTT。由于越近的测量值越能反映网络当前的情况,TCP采用指数加权移动平均的算法对RTT测量值进行加权平均，得出报文段的平均往返时间RTT。</p></li><li><p>快速重传</p><p>超时触发重传存在的一个问题就是超时时间可能相对较长。由于无法精确估计实际的往返时间，超时重传时间RTO往往比实际的往返时间大很多。当一个报文段丢失时，发送方需要等待很长时间才能重传丢失的报文段，因而增加了端到端时延。幸运的是，有时一个报文段的丢失会引起发送方连续收到多个重复的确认，通过收到多个重复的确认可以快速地判断报文段可能已经丢失而不必等待重传计时器超时。快速重传就是基于该方法对超时重传的补充和改进。</p></li><li><p>选择确认</p><p>TCP报文段的确认字段是一种累积确认，就是说，它只通告收到的最后一个按序到达的字节，而没有通告所有收到的失序到达的那些字节，虽然这些字节已经被接收方接收并暂存在接收缓存中。这些没有被确认的字节很可能因为超时而被发送方重传。为了避免这些无意义的重传，一个可选功能选择确认可以解决这个问题。选择确认允许接收方通知发送方所有正确接收了的但是失序的字节块，发送方可以根据这些信息只重传那些接收方还没有收到的字节块。</p></li></ul><h2 id="四、TCP的流量控制"><a href="#四、TCP的流量控制" class="headerlink" title="四、TCP的流量控制"></a>四、TCP的流量控制</h2><p>一条TCP连接的双方主机都为该连接设置了接收缓存。当该TCP连接接收得到按序的字节后，它就将数据放入接收缓存。相关联的应用程序会从该缓存中读取数据，但应用程序不一定能马上将数据取走。事实上，接收方应用也许正忙于其他任务，需要过很长的时间后才能去读取数据。如果应用程序读取数据比较慢，而发送方发送数据很快、很多，则很容易使该连接的接收缓存溢出。</p><p>TCP为应用程序提供了流量控制服务，以解决因发送方发送数据太快而导致接收方来不及接收，使接收方缓存溢出的问题。</p><p>流量控制的基本方法就是接收方根据自己的接收能力控制发送方的发送速率。因此，可以说流量控制是一个速度匹配服务，即发送方的发送速率与接收方应用程序的读速率相匹配。利用滑动窗口机制可以很方便地控制发送方的平均发送速率。TCP采用接收方控制发送方发送窗口大小的方法来实现在TCP连接上的流量控制。在TCP报文段首部的窗口字段写入的数值就是当前给对方设置的发送窗口数值的上限。这种由接收方控制发送方的做法，在计算机网络中经常使用。</p><p>发送窗口在连接建立时由双方商定。但在通信的过程中，接收方根据接收缓存中可用缓存的大小，随时动态地调整对方的发送窗口的上限值。为此，TCP接收方要维持一个接受窗口的变量，其值不能大于可用缓存大小。</p><p>在TCP报文段首部的窗口字段写入的数值就是当前接收方的接收窗口的大小。TCP发送方的发送窗口的大小必须小于该值。</p><p>当接收方的可用接收缓存大小不再为0时，向发送方发送的窗口更新报文段丢失了会出现什么问题？如果接收方一直没有数据要发送给发送方，则发送方将会永远等下去。为防止因为因接收方发送给发送方的窗口变更变文段的丢失所导致的死锁状态，实际上，当窗口变为0时，如果发送方有数据要发送，则会周期性地发送只包含一个字节数据的窗口探测报文段，以便强制接收方发回确认并公告接收窗口大小。如果这时接收窗口大小非零，则会接收这个字节，并对这个字节进行确认，否则会丢弃该字节并对以前数据进行重复确认。</p><h2 id="五、TCP的连接管理"><a href="#五、TCP的连接管理" class="headerlink" title="五、TCP的连接管理"></a>五、TCP的连接管理</h2><p>TCP是面向连接的协议。连接的建立和释放是每一次面向连接的通信中必不可少的过程。因此TCP连接就有三个阶段，即连接建立、数据传送、连接释放。建立连接的目的就是为接下来要进行的通信做好充分的准备，其中最重要的就是分配相应的资源。在通信结束之后显然要释放所占用的资源，即释放连接。注意，TCP的连接时运输层连接，只存在于通信的两个端系统中，而网络核心的路由器完全不知道它的存在。</p><ul><li><p>TCP的连接建立</p><p>在连接建立时要解决以下三个问题：</p><ul><li>要使每一方能够确知对方的存在；</li><li>要允许双方协商一些参数</li><li>能够对运输实体资源进行分配和初始化</li></ul><p>TCP的连接建立采用客户——服务器方式。主动发起连接建立的应用进程叫做客户，而被动等待连接建立的应用进程叫做服务器。</p><p>设主机B运行TCP的服务器进程，它先发出一个被动打开命令，准备接受客户进程的连接请求。然后服务器进程就处于“听”状态，不断检测是否有客户进程要发起连接请求。如有，即做出响应。</p><p>设客户进程运行在主机A中。它先向其TCP发出主动打开命令，表明要向某个IP地址的某个端口建立运输层连接。</p><p>主机A的TCP向主机B的TCP发出连接请求报文段，其首部的同步位SYN应置1，同时选择一个序号<code>seq=x</code>，这表明下一个报文段的第一个数据字节的序号是<code>x+1</code>。</p><p>主机B的TCP收到连接请求报文段后，如同意，则发回连接请求确认。在确认报文段中应把SYN位和ACK位都置1，确认号<code>ack=x+1</code>，同时也为自己选择一个序号<code>seq=y</code>。</p><p>主机A的TCP收到B接受连接请求的确认后，还要向B给出确认，其ACK置1，确认号<code>ack=y+1</code>。而自己的序号<code>seq=x+1</code>。TCP标准规定，SYN=1的报文段不能携带数据，但要消耗一个序号。因此A发送的第二个报文段的序号应当是第一个报文段的序号加1.注意，A发送的第二个报文段中SYN是0而不是1，ACK位必须为1.该报文段是对B的同步报文段的确认，但是一个普通报文段，可携带数据。若该报文段不携带数据，则按照TCP的规定，确认报文段不消耗序号。</p><p>运行客户进程的主机A的TCP通知上层应用进程，连接已经建立。</p><p>当运行服务器进程的主机B的TCP收到主机A的确认后，会通知其上层应用进程，连接已经建立。</p><p>连接建立采用的这种过程叫做三次握手。</p><p>为什么要发送这三个报文段呢？这主要是为了防止已失效的连接请求报文段突然又传送到了主机B，因而导致错误产生。</p></li><li><p>TCP的连接释放</p><p>在数据传输结束后，通信的双方都可以发出释放连接的请求。在连接释放过程中要释放为该连接分配的所有资源。</p><p>设主机A的应用进程先向其TCP发出连接释放请求，并且不再发送数据。TCP通知对方要释放A到B这个方向的链接，把发往主机B的报文段首部的FIN置1，其序号<code>seq=u</code>。由于FIN报文段要消耗一个序号，因此序号u等于A前面已传送过的数据的之后一个字节的序号加1.</p><p>主机B的TCP收到释放连接的通知后即发出确认，确认号<code>ack=u+1</code>，而这个报文段自己的序号假定为v。主机B的TCP这时应通知高层应用进程。这样，从A到B的连接就释放了，连接处于半关闭状态。</p><p>此后，主机B不再接受主机A发来的数据。但若主机B还有一些数据要发往主机A，则可以继续发送。主机A只要正确收到数据，仍应向主机B发送确认。</p><p>若主机B不再向主机A发送数据，其应用进程就通知TCP释放连接。主机B发出的连接释放报文段必须使FIN=1，其序号为w。主机A必须对此发出确认，把ACK置1，确认号<code>ack=w+1</code>，而自己的序号为<code>seq=u+1</code>。这样才把从B到A的反方向连接释放掉。但此时，主机A的TCP并不能马上释放整个连接，还要再等待一个超时时间才能将整个连接释放。因为主机A的确认有可能丢失，这时B会重传FIN报文段。在这段超时时间内，若A又收到B重传的FIN报文段，A需要再次进行确认。收到A的最后确认，B才能将整个连接释放。若等待的这段超时时间内没有收到B的FIN报文段，主机A的TCP则应向其应用进程报告，整个连接已经全部释放。</p><p>上述的连接释放过程是四次握手。</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;TCP是TCP/IP体系中面向连接的运输层协议，它提供了全双工的和可靠交付的服务。TCP与UDP最大的区别就是：TCP是面向连接的，而UDP是无连接的。TCP比UDP复杂的多，除了具有面向连接和可靠传输的特性外，TCP还在运输层使用流量控制和拥塞控制机制。&lt;/p&gt;
&lt;h2 
      
    
    </summary>
    
      <category term="计算机网络" scheme="https://wanqbin.xyz/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="传输控制协议" scheme="https://wanqbin.xyz/tags/%E4%BC%A0%E8%BE%93%E6%8E%A7%E5%88%B6%E5%8D%8F%E8%AE%AE/"/>
    
      <category term="TCP" scheme="https://wanqbin.xyz/tags/TCP/"/>
    
  </entry>
  
  <entry>
    <title>拥塞控制</title>
    <link href="https://wanqbin.xyz/2019/%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6/"/>
    <id>https://wanqbin.xyz/2019/拥塞控制/</id>
    <published>2019-11-18T17:04:00.000Z</published>
    <updated>2019-11-18T17:05:04.673Z</updated>
    
    <content type="html"><![CDATA[<p>当网络中出现太多的分组时，网络的性能开始下降。这种情况称为拥塞。拥塞是分组交换网中一个非常重要的问题。如果网络中的负载，即发送到网络中的数据量超过了网络的容量，即网络中能处理的数据量，那么在网络中就可能发生拥塞。所谓拥塞控制就是放置过多的数据注入到网络中，这样可以使网络中的路由器或链路不至过载。</p><h2 id="一、拥塞的原因及危害"><a href="#一、拥塞的原因及危害" class="headerlink" title="一、拥塞的原因及危害"></a>一、拥塞的原因及危害</h2><p>理想情况下，在吞吐量饱和之前，网络吞吐量应等于输入负载。但当输入负载超过网络容量时，在理想情况下，吞吐量不再增长而保持为水平线，即吞吐量达到饱和。这就表明输入负载中有一部分损失掉了。</p><p>但是，在实际的网络中，若不采取有效的拥塞控制手段，随着输入负载的增大，网络吞吐量的增长速率逐渐减小。特别是当输入负载达到某一数值时，网络的吞吐量反而随负载的增大而下降，这时网络就进入了拥塞状态。当输入负载继续增大时，网络的吞吐量甚至有可能下降到零，即网络已无法工作。这就是所谓的死锁。</p><p>当网络拥塞而丢弃分组时，该分组在其经过路径中所占用的全部资源都被白白浪费掉了。</p><p>既然网络拥塞是因为发送到网络中的数据量超过了网络的容量，要彻底解决分组交换网中的拥塞问题，就要想办法限制输入到网络中的负载，即控制源点的发送速率。</p><h2 id="二、拥塞控制的基本方法"><a href="#二、拥塞控制的基本方法" class="headerlink" title="二、拥塞控制的基本方法"></a>二、拥塞控制的基本方法</h2><p>拥塞控制和流量控制之间的区别是需要注意的，因为它们都需要控制源点的发送速率，因此容易混淆。拥塞控制的任务是防止过多的数据注入到网络中，使网络能够承受现有的网络负载。这是一个全局性的问题，涉及各方面的行为，包括所有的主机，所有的路由器，路由器内部的存储转发处理过程，以及与降低网络传输性能有关的所有因素。</p><p>与此相反，流量控制只与特定点对点通信的发送方和接收方之间的流量有关。它的任务是，确保一个快速的发送方不会持续地以超过接收方接收能力的速率发送数据，以防止接收方来不及处理数据。流量控制通常涉及的做法是，接收方向发送方提供某种直接的反馈，以抑制发送方的发送速率。</p><p>从控制论的角度出发，拥塞控制可以分为开环控制和闭环控制两大类。开环控制方法试图用良好的设计来解决问题，它的本质是从一开始就保证问题不会发生。一旦系统启动并运行起来了，就不需要中途做修正。</p><p>相反，闭环控制是一种基于反馈环路的方法，它包括三个部分：</p><ul><li>监测网络系统以便监测到拥塞在何时、何地发生</li><li>把拥塞发生的信息传送到可以采取行动的地方</li><li>调整网络系统的运行以解决出现的问题</li></ul><p>当网络系统的流量可以准确规定、性能要求可以事先获得时，适于使用开环控制；而当流量特征不能1准确描述或者当系统不提供资源预留时，适于使用闭环控制。由于因特网中不提供资源预留的机制，而且流量的特性不能准确地描述，所以在因特网中拥塞控制主要采用闭环控制方法。</p><p>根据拥塞反馈信息的形式，又可以将闭环拥塞控制算法分为显式反馈算法和隐式反馈算法。在显式反馈算法中，从拥塞点（即路由器）向源点提供关于网络中拥塞状态的显式反馈信息。当因特网中一个路由器被大量的IP是数据报淹没时，它可能会丢弃一些数据报，同时可使用ICMP源站抑制报文通告源主机。源站收到后应降低发送速率。不过当网络拥塞发生时，向网络中注入这些额外的分组可能会”火上浇油“，因此在实际中很少使用。现在，因特网中的拥塞控制任务主要是在运输层上完成的。更好的显式反馈信息的方法是，在路由器转发的分组中保留一个比特或字段，用该比特或字段的值表示网络的拥塞状态，而不是专门发送一个分组。</p><p>在隐式反馈算法中，源端通过对网络行为的观察来推断是否发生了拥塞，无需拥塞点提供显式反馈信息。TCP采用的就是隐式反馈算法。</p><p>需要说明的是，拥塞控制并不仅仅是运输层要考虑的问题。显式反馈算法就必须涉及网络层。虽然一些网络体系结构主要在网路层实现拥塞控制，但因特网主要利用隐式反馈在运输层实现拥塞控制。</p><p>不论采用哪种方法进行拥塞控制都是需要付出代价的。例如，在实施拥塞控制时，可能需要在结点之间交换信息和各种命令，以便选择控制的策略和实施控制。这样会产生额外的开销。有些拥塞控制机制会预留一些资源用于特殊用户或特殊情况，降低了网络资源的共享程度。因此，当网络输入负载1不大时，有拥塞控制的系统吞吐量要低于无拥塞控制的系统吞吐量。但付出一定的代价是值得的，它会保证网络性能的稳定，不会因为输入负载的增长而导致网络性能的恶化甚至出现崩溃。</p><h2 id="三、TCP的拥塞控制"><a href="#三、TCP的拥塞控制" class="headerlink" title="三、TCP的拥塞控制"></a>三、TCP的拥塞控制</h2><p>TCP采用的方法是让每一个发送方根据所感知到的网络拥塞的程度，来限制其向连接发送流量的速率。如果TCP发送方感知从它到目的地之间的路径上没有拥塞，则增加其发送速率；如果发送方感知在该路径上有拥塞，则降低其发送速率。该方法具体要解决以下三个问题：首先，TCP发送方如何限制它的发送速率；其次，TCP发送方如何感知从它到目的地之间的路径上存在拥塞；最后，当发送方感知到端到端的拥塞时，采用什么算法来改变其发送速率。</p><p>TCP的流量控制利用接收方通告给发送方的接收窗口<code>rwnd</code>大小来限制发送窗口的大小。这个窗口大小就是接收方给发送方的TCP报文段首部中的窗口字段的值。实际上TCP的发送方还维持着一个叫做拥塞窗口<code>cwnd</code>的状态变量。拥塞窗口的大小取决于网络的拥塞程度，并且是动态变化的。TCP发送方在确定发送报文段的速率时，既要根据接收方的接收能力，又要从全局考虑不要使网络发生拥塞。因此TCP发送方的发送窗口大小取接收方接收窗口和拥塞窗口的最小值，即应按如下公式确定：</p><p><code>发送窗口的上限值=Min(rwnd,cwnd)</code></p><p>当<code>rwnd&lt;cwnd</code>时，是接收方的接收能力限制发送窗口的最大值。但当<code>cwnd&lt;rwnd</code>时，则是网络的传输能力限制发送窗口的最大值。</p><p>TCP发送方又是如何知道网络发生了拥塞呢？我们知道，当网络发生拥塞时，路由器就要丢弃分组。现在通信线路的传输质量一般都很好，因传输出差错而丢弃分组的概率是很小的。因此检测到分组丢失就可以认为网络出现了故障。在快速重传中，发送方不一定要通过重传计时器超时才能发现分组的丢失，可以通过接收到三个重复确认就能判断有分组的丢失。因此，当重传计时器超时或接收到三个重复确认时，TCP的发送方就认为网络出现了拥塞。</p><p>当发送方感知到端到端的拥塞时，采用什么算法来改变其发送速率呢？慢启动、拥塞避免和快速恢复。</p><ul><li><p>慢启动和拥塞避免</p><p>当主机刚开始发送数据时完全不知道网络的拥塞情况，如果立即把较大的发送窗口中的全部数据字节都注入到网络，那么就有可能引发网络拥塞。经验证明，较好的方法是通过试探发现网络中的可用带宽，即由小到大逐渐增大发送方的拥塞窗口数值，直到发生拥塞。通常在刚刚开始发送报文段时可先将拥塞窗口<code>cwnd</code>设置为一个最大报文段MSS的数值。而在每收到一个对新的报文段的确认后，将拥塞窗口增加至多一个MSS的数值。用这样的方法逐步增大发送方的拥塞窗口<code>cwnd</code>，可以使分组注入到网络的速率更加合理。这就是慢启动算法。</p><p>在慢启动阶段发送速率以指数方式迅速增长，若持续以该速度增长发送速率必然导致网络很快进入到拥塞状态。因此当网络要接近拥塞时应降低发送速率的增长率，以避免网络拥塞。这可以使TCP连接在一段相对长的时间内保持较高的发送速率但又不使网络拥塞。为此，TCP定义了一个状态变量，即慢启动门限<code>ssthresh</code>（即从慢启动阶段进入拥塞避免阶段的门限）。慢启动门限<code>ssthresh</code>的用法如下：</p><ul><li>当<code>cwnd&lt;ssthresh</code>时，使用上述的慢启动算法</li><li>当<code>cwnd&gt;ssthresh</code>时，停止使用慢启动算法而改用拥塞避免算法</li><li>当<code>cwnd=ssthresh</code>时，即可以使用慢启动算法，又可以使用拥塞避免算法</li></ul><p>具体的做法如下所述：</p><p>拥塞避免算法使发送方的拥塞窗口<code>cwnd</code>每经过大约一个往返时间RTT就增加一个MSS的大小。实际的做法是，每收到一个新的确认，将<code>cwnd</code>增加<code>MSS*(MSS/cwnd)</code>。这样，拥塞窗口<code>cwnd</code>按线性规律缓慢增长，比慢启动算法的拥塞窗口增长速率缓慢得多。</p><p>无论在慢启动阶段还是在拥塞避免阶段，只要发送方发现网络拥塞，就立即将拥塞窗口<code>cwnd</code>重新设置为1，并执行慢启动算法。这样做的目的就是要迅速减少主机发送到网络中的分组数，使得发生拥塞的路由器有足够的时间把队列中积压的分组处理完毕。在重新执行慢启动算法的同时，将慢启动门限<code>ssthresh</code>设置为出现拥塞时的发送窗口值的一半。这样设置的考虑是：这一次在该窗口值发生拥塞，则下次很有可能在该窗口值再出现拥塞，因此当下次拥塞窗口又接近该值时，就要降低窗口的增长速率，进入拥塞避免阶段。</p><p>拥塞避免的具体过程：</p><ul><li>当TCP连接进行初始化时，将拥塞窗口置为1.</li><li>执行慢启动算法时，拥塞窗口<code>cwnd</code>的初始值为1。以后发送方每收到一个对新报文段的确认ACK，就将发送方的拥塞窗口加1，然后开始下一次的传输。一个轮次就是把拥塞窗口<code>cwnd</code>所允许发送的报文段都发送出去，并且都收到了对方的确认。“轮次”之间的间隔时间可以近似为一个RTT。因此，拥塞窗口<code>cwnd</code>随着传输轮次按指数规律增长。当拥塞窗口<code>cwnd</code>增长到慢启动门限值<code>ssthresh</code>时，就改为执行拥塞避免算法，拥塞窗口按线性规律增长。</li><li>假定拥塞窗口的数值增长到24时，网络出现拥塞。更新后的<code>ssthresh</code>值变为12，拥塞窗口再重新设置为1，并执行慢启动算法。当<code>cwnd=12</code>时改为执行拥塞避免算法，拥塞窗口按线性规律增长，每经过一个往返时间就增加一个MSS的大小。</li></ul><p>可见，执行拥塞避免算法后，拥塞窗口呈线性增长，发送速率增长比较缓慢，以防止网络过早出现拥塞，并使发送方可以长时间保持一个合理的发送速率。这里要再强调一下，“拥塞避免”并不能避免拥塞，而是说把拥塞窗口控制为按线性规律增长，使网络不容易立即出现拥塞。</p></li><li><p>快速恢复</p><p>实际上TCP检测到分组丢失有两种情况：重传计时器超时和收到连续三个重复的ACK。上面的拥塞控制算法对这两种情况采取了同样的反应，即将拥塞窗口降低为1，然后执行慢启动算法。但实际上这两种情况下网络拥塞情况是不一样的。当发送方收到连续三个重复的ACK时，虽然有可能丢失了一些分组，但这连续的三个重复ACK同样又表明丢失分组以外的另外三个分组已经被接收方接收了。因此，与发生超时事件的情况不同，网络还有一定的分组交付能力，拥塞情况并不严重。既然网络拥塞情况并不严重，将拥塞窗口直接降低为1则反应太过剧烈了，这会导致发送方要经过很长时间才能恢复到正常的传输速率。</p><p>为此，定义了与快速重传配套使用的快速恢复算法，其具体步骤如下：</p><ul><li>当发送方收到连续三个重复的ACK时，就重新设置慢启动门限<code>ssthresh</code>，将其设置为当前发送窗口的一半。这一点和慢启动算法是一样的。</li><li>与慢启动不同之处是拥塞窗口<code>cwnd</code>不是设置为1，而是设置为新设置的慢启动门限<code>ssthresh</code>，然后开始执行拥塞避免算法，使拥塞窗口缓慢地线性增长。</li></ul><p>对于超时事件，由于后续的分组都被丢弃了，一直没有收到它们的确认而导致重传计时器超时，显然网络存在严重的阻塞。对于这种情况重新执行慢启动有助于迅速减少主机发送到网络中的分组数，使发生拥塞的路由器有足够的时间把队列中积压的分组处理完毕。</p><p>采用快速恢复算法的情况下，长时间的TCP连接在稳定的时候通常处于下面描述的不断重复状态。经过慢启动发送方迅速进入拥塞避免阶段，在该阶段，使拥塞窗口呈线性增长，即加性增，发送速率缓慢增长，以防止网络网络过早拥塞。当流量逐渐超过网络可用带宽时会出现拥塞，但由于发送速率增长缓慢，通常仅导致少量分组丢失。这种情况下发送方会超过三个重复ACK并将拥塞窗口减半，即“乘性减”，然后再继续执行“加性增”缓慢增长发送速率，如此重复下去。因此，对于长时间的TCP连接，在稳定时的拥塞窗口大小呈锯齿状变化。在这种“加性增，乘性减“的拥塞控制下，发送方的平均发送速率始终保持在较接近网络可用带宽的位置。</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;当网络中出现太多的分组时，网络的性能开始下降。这种情况称为拥塞。拥塞是分组交换网中一个非常重要的问题。如果网络中的负载，即发送到网络中的数据量超过了网络的容量，即网络中能处理的数据量，那么在网络中就可能发生拥塞。所谓拥塞控制就是放置过多的数据注入到网络中，这样可以使网络中的
      
    
    </summary>
    
      <category term="计算机网络" scheme="https://wanqbin.xyz/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="TCP" scheme="https://wanqbin.xyz/tags/TCP/"/>
    
      <category term="拥塞控制" scheme="https://wanqbin.xyz/tags/%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6/"/>
    
      <category term="计算机网络" scheme="https://wanqbin.xyz/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
</feed>

<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Aoki&#39;s Blog</title>
  
  <subtitle>“吾生也有涯，而知无涯”</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://wanqbin.xyz/"/>
  <updated>2019-07-30T10:22:44.536Z</updated>
  <id>http://wanqbin.xyz/</id>
  
  <author>
    <name>Aoki</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>继承</title>
    <link href="http://wanqbin.xyz/2019/07/30/%E7%BB%A7%E6%89%BF/"/>
    <id>http://wanqbin.xyz/2019/07/30/继承/</id>
    <published>2019-07-30T03:16:00.000Z</published>
    <updated>2019-07-30T10:22:44.536Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、继承"><a href="#一、继承" class="headerlink" title="一、继承"></a>一、继承</h2><p>&emsp;<code>继承</code>是面向对象编程额基本概念之一。继承使我们能在已有类的基础上构造新类。这个新的类拥有或继承已有类的数据成员和成员函数，也可添加新的数据成员和成员函数，对已有的类进行扩充。这个已有的类就称为<code>基类</code>,而这个新类则称为<code>派生类</code>。</p><p>&emsp;如果我们需要定义一个个人类和职工类，在不使用继承的情况下，代码重复会比较严重。这时，我们就需要用到继承。</p><p>&emsp;下面定义一个基类网页，重复的代码都写到这个网页上。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//基类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BasePage</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">header</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"公共头部"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">footer</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"公共底部"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">left</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"公共左侧列表"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">News</span> :</span><span class="keyword">public</span> BasePage<span class="comment">//继承BasePage</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">content</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"今日新闻"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>主函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">News news;</span><br><span class="line">news.header();</span><br><span class="line">news.left();</span><br><span class="line">news.footer();</span><br><span class="line">news.content();</span><br><span class="line">system(<span class="string">"pause"</span>);</span><br><span class="line"><span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果：</p><p><img src="/2019/07/30/继承/test1.PNG" alt="执行结果"></p><p>继承可以减少代码的重复部分，派生类可以继承基类的数据成员和成员函数。</p><p>网页中有很多公共部分，导致实现的时候由很多重复的代码。在使用继承之后，基类为公共网页，具体的子类实现把不同的内容，较好地解决了代码的复用。</p><h2 id="二、继承方式"><a href="#二、继承方式" class="headerlink" title="二、继承方式"></a>二、继承方式</h2><p>继承方式主要有：</p><ul><li><code>public</code>：公有继承</li><li><code>private</code>：私有继承</li><li><code>protected</code>：保护继承</li></ul><ol><li>不管是公有继承、保护继承还是私有继承，基类中的私有属性，都不可以继承下去</li><li>在公有继承中，父类的protected属性在子类中是protected属性。父类中的public属性在子类中是public属性</li><li>在保护继承中，父类中的protected属性，在子类中是protected属性。父类中的public属性在子类中是protected属性</li><li>在私有继承中，父类中的protected属性在子类中是private属性。父类中的public属性在子类中是private属性。</li></ol><h2 id="三、继承中的构造和析构顺序"><a href="#三、继承中的构造和析构顺序" class="headerlink" title="三、继承中的构造和析构顺序"></a>三、继承中的构造和析构顺序</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Base()</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Base默认构造函数调用"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">~Base()</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Base析构函数调用"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span>:</span><span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Son()</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Son默认构造函数调用"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">~Son()</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Son析构函数调用"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//子类会继承父类的成员属性，成员函数</span></span><br><span class="line"><span class="comment">//但是子类不会继承父类的构造函数和析构函数</span></span><br><span class="line"><span class="comment">//只有父类自己知道如何构造和析构自己的属性，而子类不知道</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Base base;</span><br><span class="line">Son son;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果：<br><img src="/2019/07/30/继承/test2.PNG" alt="执行"></p><ul><li>子类在创建对象时，先调用父类的构造函数，然后再调用自身的构造函数</li><li>析构顺序与构造顺序相反</li><li>子类不会继承父类的构造函数和析构函数</li><li>如果父类中没有合适默认构造，那么子类可以利用初始化列表方式显式地调用父类的其他构造函数。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Base()</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Base默认构造函数调用"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">~Base()</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Base析构函数调用"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">Base(<span class="keyword">int</span> a)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"有参构造函数调用,参数为："</span> &lt;&lt; a &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span>:</span><span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Son()</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Son默认构造函数调用"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">Son(<span class="keyword">int</span> a) :Base(a)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Son初始化列表调用父类带参构造"</span> &lt;&lt; a &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">~Son()</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Son析构函数调用"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//子类会继承父类的成员属性，成员函数</span></span><br><span class="line"><span class="comment">//但是子类不会继承父类的构造函数和析构函数</span></span><br><span class="line"><span class="comment">//只有父类自己知道如何构造和析构自己的属性，而子类不知道</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Base base;</span><br><span class="line">Son son;</span><br><span class="line"><span class="function">Son <span class="title">son2</span><span class="params">(<span class="number">15</span>)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果：</p><p><img src="/2019/07/30/继承/test21.PNG" alt="执行结果"></p><h2 id="四、继承中同名函数的处理"><a href="#四、继承中同名函数的处理" class="headerlink" title="四、继承中同名函数的处理"></a>四、继承中同名函数的处理</h2><ol><li>如果子类和父类拥有同名的函数、属性，子类不会覆盖父类的成员</li><li>如果子类与父类的成员函数名称相同，子类会把父类的所有同名版本都隐藏掉</li><li>如果想调用父类的方法，必须加作用域</li><li>成员属性直接调用是子类的，如果想调用父类的成员属性，需要加作用域</li><li>成员函数直接调用先调用子类的，父类的所有版本都会被隐藏，除非显式地用作用域运算符去调用。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base0</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Base0()</span><br><span class="line">&#123;</span><br><span class="line">m_A = <span class="number">100</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> m_A;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son0</span>:</span><span class="keyword">public</span> Base0</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Son0()</span><br><span class="line">&#123;</span><br><span class="line">m_A = <span class="number">20</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> m_A;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test03</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Son0 s1;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"子类中的属性："</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; s1.m_A &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"父类中的属性："</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; s1.Base0::m_A &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果：</p><p><img src="/2019/07/30/继承/test03.PNG" alt="执行结果"></p><h2 id="五、继承中的静态成员处理"><a href="#五、继承中的静态成员处理" class="headerlink" title="五、继承中的静态成员处理"></a>五、继承中的静态成员处理</h2><ul><li>如果基类定义了一个静态成员，则在整个继承体系中只存在该成员的唯一定义。不论从基类中派生出多少个派生类，对于每个静态成员来说都只存在唯一的实例。</li><li>静态成员遵循通用的访问控制规则，如果基类中的成员是private的，则派生类无权访问它。假设某静态成员是可访问的，则我们既能通过基类使用它，也可以通过派生类使用它。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Father</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> m_A;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Father func()"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">int</span> Father::m_A = <span class="number">200</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son1</span> :</span><span class="keyword">public</span> Father</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> A;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Son func()"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test04</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Father的静态成员值为："</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; Father::m_A &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Son1继承的静态成员值为："</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; Son1::m_A &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">Son1::func();</span><br><span class="line">Father::func();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果：</p><p><img src="/2019/07/30/继承/test04.PNG" alt="执行结果"></p><h2 id="六、防止继承的发生"><a href="#六、防止继承的发生" class="headerlink" title="六、防止继承的发生"></a>六、防止继承的发生</h2><p>有时候我们会定义这样一种类，我们不希望其他类继承它，或者不想考虑它是否合适作为一个基类。为了实现这个目的，C++11新标准提供了一种防止继承发生的方法，即在类后跟一个关键字<code>final</code>。</p><p><img src="/2019/07/30/继承/test05.PNG" alt="final关键字"></p><h2 id="七、菱形继承（钻石继承）的问题"><a href="#七、菱形继承（钻石继承）的问题" class="headerlink" title="七、菱形继承（钻石继承）的问题"></a>七、菱形继承（钻石继承）的问题</h2><p>&emsp;两个派生类继承同一个基类，而又有某个类同时继承了两个派生类，这种继承被称为菱形继承，或者钻石继承。</p><p>这种继承带来的问题：</p><ul><li>羊继承了动物的数据和函数，驼继承了动物的数据和函数，羊驼同时继承了羊和驼的数据和函数。当羊驼调用函数或者数据时，就会产生二义性。</li><li>羊驼继承自动物的函数和数据继承了两份，其实我们应该清楚，这份数据我们只需要一份就可以了。</li></ul><p>解决办法：</p><ul><li>采用虚继承的方式来解决。通过虚继承的方式，可以保证羊驼类中只有一份动物类的属性和函数的赋值，因此可以避免菱形继承的二义性，也就解决了“钻石继承”的问题。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//动物类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">int</span> m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//羊类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sheep</span> :</span><span class="keyword">virtual</span> <span class="keyword">public</span> Animal</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//驼类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tuo</span> :</span><span class="keyword">virtual</span> <span class="keyword">public</span> Animal</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//羊驼类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SheepTuo</span> :</span><span class="keyword">public</span> Tuo, <span class="keyword">public</span> Sheep</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test06</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">SheepTuo st;</span><br><span class="line">st.Sheep::m_Age = <span class="number">10</span>;</span><br><span class="line">st.Tuo::m_Age = <span class="number">20</span>;</span><br><span class="line">st.m_Age = <span class="number">5</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"驼的年龄为"</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; st.Tuo::m_Age &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"羊的年龄为："</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; st.Sheep::m_Age &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"羊驼的年龄为："</span>;</span><br><span class="line"><span class="comment">//可以直接访问，没有二义性的可能，只有一份数据</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; st.m_Age &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果：</p><p><img src="/2019/07/30/继承/test06.PNG" alt="执行结果"></p><h2 id="八、源码地址"><a href="#八、源码地址" class="headerlink" title="八、源码地址"></a>八、源码地址</h2><p>​        <a href="https://github.com/Aoki-Wang/CheckStation/tree/master/C%2B%2B/Inheritance" target="_blank" rel="noopener">继承源码示例</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、继承&quot;&gt;&lt;a href=&quot;#一、继承&quot; class=&quot;headerlink&quot; title=&quot;一、继承&quot;&gt;&lt;/a&gt;一、继承&lt;/h2&gt;&lt;p&gt;&amp;emsp;&lt;code&gt;继承&lt;/code&gt;是面向对象编程额基本概念之一。继承使我们能在已有类的基础上构造新类。这个新的类拥有
      
    
    </summary>
    
      <category term="C++" scheme="http://wanqbin.xyz/categories/C/"/>
    
    
      <category term="C++" scheme="http://wanqbin.xyz/tags/C/"/>
    
      <category term="继承" scheme="http://wanqbin.xyz/tags/%E7%BB%A7%E6%89%BF/"/>
    
  </entry>
  
  <entry>
    <title>stack和queue</title>
    <link href="http://wanqbin.xyz/2019/07/29/stack%E5%92%8Cqueue/"/>
    <id>http://wanqbin.xyz/2019/07/29/stack和queue/</id>
    <published>2019-07-29T00:07:00.000Z</published>
    <updated>2019-07-30T02:49:45.692Z</updated>
    
    <content type="html"><![CDATA[<h2>  <center>stack</center>  </h2><p>一、stack概述</p><p>&emsp;stack是一种先进后出（First In Last Out，FILO)的数据结构，它只有一个出口。stack允许新增元素、移除元素、取得最顶端元素。但是除了最顶端外，没有任何其他方法可以存取其他元素，换言之，stack不允许有遍历行为。</p><p>二、stack没有迭代器</p><p>&emsp;stack所有元素的进出都必须符合“先进后出”的条件，只有stack顶端的元素才有机会被外界取用。stack不提供遍历功能，也不提供迭代器。</p><p>三、stack常用API</p><ul><li>栈顶top</li><li>压栈push</li><li>栈顶弹出pop</li><li>大小 size</li><li>是否empty</li></ul><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">stest</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt;istack;</span><br><span class="line"><span class="keyword">if</span> (istack.empty())</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"stack为空!"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"stack的大小为："</span> &lt;&lt; istack.size() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">istack.push(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"stack的大小为："</span> &lt;&lt; istack.size() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"stack的栈顶元素为："</span> &lt;&lt; istack.top() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"弹出栈顶元素后:"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">istack.pop();</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"stack的大小为："</span> &lt;&lt; istack.size() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"stack的栈顶元素为："</span> &lt;&lt; istack.top() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><p><img src="/2019/07/29/stack和queue/stest.PNG" alt="stack常用API"></p><h2><center>queue</center></h2><p>一、queue概述</p><p>&emsp;queue是一种先进先出（First In First Out，FIFO）的数据结构。它有两个出口。queue允许新增元素、移除元素、从最低端加入元素、取得最顶端元素。但除了最底端可以加入、最顶端可以取出外，没有任何办法可以存取queue的其他元素。换言之，queue不允许有遍历行为。</p><p>二、queue没有迭代器</p><p>&emsp;queue所有元素的进出都必须符合“先进先出“的条件，只有queue顶端的元素，才有机会被外界取用。queue不提供遍历功能，也不提供迭代器。</p><p>三、queue常用API</p><ul><li>先进先出</li><li>队头front 队尾back</li><li>入队 push</li><li>弹出队头 pop</li><li>大小 size</li><li>为空 empty</li></ul><p>示例:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">qtest</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt;iqueue;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">iqueue.push(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"队头为："</span> &lt;&lt; iqueue.front() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"队尾为："</span> &lt;&lt; iqueue.back() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"iqueue的大小为："</span> &lt;&lt; iqueue.size() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">iqueue.pop();</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"弹出队头后："</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"队头为："</span> &lt;&lt; iqueue.front() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"队尾为："</span> &lt;&lt; iqueue.back() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"iqueue的大小为："</span> &lt;&lt; iqueue.size() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><p><img src="/2019/07/29/stack和queue/qtest.PNG" alt="queue常用API"></p><p>四、源码地址</p><p>​        <a href="https://github.com/Aoki-Wang/CheckStation/tree/master/STL/stack%20and%20queue" target="_blank" rel="noopener">stack and queue示例源码</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2&gt;
  &lt;center&gt;stack&lt;/center&gt;  
&lt;/h2&gt;

&lt;p&gt;一、stack概述&lt;/p&gt;
&lt;p&gt;&amp;emsp;stack是一种先进后出（First In Last Out，FILO)的数据结构，它只有一个出口。stack允许新增元素、移除元素、取得最顶端元素。
      
    
    </summary>
    
      <category term="STL" scheme="http://wanqbin.xyz/categories/STL/"/>
    
    
      <category term="STL" scheme="http://wanqbin.xyz/tags/STL/"/>
    
      <category term="stack" scheme="http://wanqbin.xyz/tags/stack/"/>
    
  </entry>
  
  <entry>
    <title>deque容器</title>
    <link href="http://wanqbin.xyz/2019/07/29/deque%E5%AE%B9%E5%99%A8/"/>
    <id>http://wanqbin.xyz/2019/07/29/deque容器/</id>
    <published>2019-07-28T16:25:00.000Z</published>
    <updated>2019-07-30T02:50:16.737Z</updated>
    
    <content type="html"><![CDATA[<p>一、deque概述</p><p>&emsp;<code>vector</code>是单向开口的连续线性空间，<code>deque</code>则是一种双向开口的连续线性空间。所谓双向开口，意思是可以在头尾两端分别做元素的插入和删除操作。虽然vector容器也可以在头尾两端插入元素，但是在其头部操作效率奇差，无法被接受。</p><p>&emsp;deque容器和vector容器最大的差异在于：</p><ol><li>deque允许使用常数项时间对头端进行元素的插入和删除</li><li>deque没有容量的概念，因为它是动态的以分段连续空间组成的，随时可以增加一段新的空间并链接起来，换句话说，像vector那样“旧空间不足而重新配置一块更大的空间，然后复制元素，再释放旧空间”这样的事情不会在deque发生，也因此，deque没有必要提供所谓的空间保留功能。</li><li>虽然deque容器也提供<code>Random Access Iterator</code>，但是它的迭代器并不是普通指针，其复杂度和vector不是一个量级，这当然影响各个运算的层面，除非必要，我们应该尽可能选择vector而不是deque，对deque进行的排序操作，为了最高效率，可将deque先完整复制到一个vector中，将vector排序后，再复制回deque。</li></ol><p>二、deque容器的中控器</p><p>&emsp;deque是由一段一段定量连续空间构成。一旦有必要在deque的前端或尾端增加新空间，便配置一段定量连续空间，串接在整个deque的头端或尾端，deque的最大任务，便是在这些分段的定量连续空间上，维护其整体连续的假象，并提供随机存取的接口，避开了“重新配置、复制、释放”的轮回，代价则是复杂的迭代器架构。</p><p>&emsp;deque为分段连续空间，就必须有中央控制，而为了维持整体连续的假象，数据结构的设计及迭代器前进后退等操作都颇为繁琐。deque的实现代码分量远比vector或list都多得多。</p><p>&emsp;采用一块所谓的<code>map</code>（不是STL的map）作为主控。这里所谓的<code>map</code>是一小块连续空间，其中每个元素都是指针，指向另一段（较大的）连续线性空间，称为<code>缓冲区</code>。缓冲区才是deque存储空间主体。</p><p>三、deque迭代器</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">T* cur;<span class="comment">//此迭代器指向缓冲区中当前的元素</span></span><br><span class="line">T* first;<span class="comment">//此迭代器指向缓冲区的头</span></span><br><span class="line">T* last;<span class="comment">//此迭代器指向缓冲区的尾</span></span><br><span class="line">map_pointer node;<span class="comment">//指向中控器中心</span></span><br></pre></td></tr></table></figure><p>四、deque常用API</p><p>1.deque构造函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">deque</span>&lt;T&gt; deqT;<span class="comment">//默认构造形式</span></span><br><span class="line"><span class="built_in">deque</span>(beg,end);<span class="comment">//构造函数将[beg,end)区间中的元素拷贝给本身</span></span><br><span class="line"><span class="built_in">deque</span>(n,elem);<span class="comment">//构造函数将n个elem拷贝给本身</span></span><br><span class="line"><span class="built_in">deque</span>(<span class="keyword">const</span> <span class="built_in">deque</span> &amp;deq);<span class="comment">//拷贝构造函数</span></span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt;deq1(<span class="number">5</span>,<span class="number">10</span>);<span class="comment">//构造deq1</span></span><br><span class="line"><span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt;deq2(deq1);<span class="comment">//拷贝构造deq2</span></span><br><span class="line">displayDeque(deq1);<span class="comment">//打印deq1</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">displayDeque(deq2);</span><br><span class="line"><span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt;deq3(deq2.begin(), deq2.begin() + <span class="number">3</span>);<span class="comment">//区间拷贝方式构造deq3</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">displayDeque(deq3);</span><br></pre></td></tr></table></figure><p>输出结果：</p><p><img src="/2019/07/29/deque容器/test01.PNG" alt="构造函数示例"></p><p>2.deque赋值操作</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">assign(beg,end);<span class="comment">//将[beg,end)区间中的数据拷贝给本身</span></span><br><span class="line">assign(n,elem);<span class="comment">//将n个elem拷贝赋值给本身</span></span><br><span class="line"><span class="built_in">deque</span>&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> <span class="built_in">deque</span> &amp;deq);<span class="comment">//重载等号操作符</span></span><br><span class="line">swap(deq);<span class="comment">//将deq与本身的元素互换</span></span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt;deq1(<span class="number">5</span>, <span class="number">10</span>);<span class="comment">//构造deq1</span></span><br><span class="line"><span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt;deq2(<span class="number">10</span>, <span class="number">15</span>);</span><br><span class="line">deq1.assign(deq2.begin(), deq2.begin() + <span class="number">3</span>);<span class="comment">//将deq2下标为0,1,2的数据拷贝给deq1</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"deq1:"</span>;</span><br><span class="line">displayDeque(deq1);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">deq1.assign(<span class="number">4</span>, <span class="number">4</span>);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"deq1:"</span>;</span><br><span class="line">displayDeque(deq1);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"deq2:"</span>;</span><br><span class="line">displayDeque(deq2);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">deq1.swap(deq2);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"deq1和deq2的数据交换后："</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"deq1:"</span>;</span><br><span class="line">displayDeque(deq1);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"deq2:"</span>;</span><br><span class="line">displayDeque(deq2);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><p><img src="/2019/07/29/deque容器/test02.PNG" alt="赋值操作示例"></p><p>3.deque大小操作</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">deque</span>.size();<span class="comment">//返回容器中元素的个数</span></span><br><span class="line"><span class="built_in">deque</span>.empty();<span class="comment">//判断容器是否为空</span></span><br><span class="line"><span class="built_in">deque</span>.resize(num);<span class="comment">//重新指定容器的长度为num，若容器变长，则以默认值填充新位置。如果容器变短，则末尾超出容器长度的元素被删除</span></span><br><span class="line"><span class="built_in">deque</span>.resize(num,elem);<span class="comment">//重新指定容器的长度为num，若容器变长，则以elem值填充新位置，如果容器变短，则末尾超出容器长度的元素被删除</span></span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test03</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt;deq1(<span class="number">5</span>, <span class="number">10</span>);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"deq1的长度为："</span> &lt;&lt; deq1.size() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">if</span> (deq1.empty())</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"deq1为空!"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"deq1非空!长度为："</span> &lt;&lt; deq1.size() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">displayDeque(deq1);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">deq1.resize(<span class="number">10</span>);<span class="comment">//重新指定deq的长度为10,</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"指定deq1的长度为10时，其元素为："</span>;</span><br><span class="line">displayDeque(deq1);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">deq1.resize(<span class="number">15</span>, <span class="number">100</span>);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"指定deq1的长度为15时，其元素为："</span>;</span><br><span class="line">displayDeque(deq1);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">deq1.resize(<span class="number">3</span>,<span class="number">100</span>);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"指定deq1的长度为3时，其元素为："</span>;</span><br><span class="line">displayDeque(deq1);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：<br><img src="/2019/07/29/deque容器/test03.PNG" alt="大小操作示例"></p><p>4.deque双端插入和删除操作</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">push_back(elem);<span class="comment">//在容器尾部添加一个数据</span></span><br><span class="line">push_front(elem);<span class="comment">//在容器头部插入一个数据</span></span><br><span class="line">pop_back();<span class="comment">//删除容器最后一个数据</span></span><br><span class="line">pop_front();<span class="comment">//删除容器第一个数据</span></span><br></pre></td></tr></table></figure><p>示例:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test04</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt;deq1(<span class="number">5</span>, <span class="number">5</span>);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"deq1："</span>;</span><br><span class="line">displayDeque(deq1);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">deq1.push_back(<span class="number">100</span>);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"deq1.push_back(100)后为："</span>;</span><br><span class="line">displayDeque(deq1);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">deq1.push_front(<span class="number">15</span>);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"deq1.push_front(15)后为："</span>;</span><br><span class="line">displayDeque(deq1);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">deq1.pop_back();</span><br><span class="line">deq1.pop_front();</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"deque删头去尾后为："</span>;</span><br><span class="line">displayDeque(deq1);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><p><img src="/2019/07/29/deque容器/test04.PNG" alt="双端插入删除操作示例"></p><p>5.deque数据存取</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">at(index);<span class="comment">//返回索引index所指的数据，如果index越界，抛出out_of_range</span></span><br><span class="line"><span class="keyword">operator</span>[];<span class="comment">//返回索引index所指向的数据，如果index越界，不抛出异常，直接出错</span></span><br><span class="line">front();<span class="comment">//返回第一个数据</span></span><br><span class="line">back();<span class="comment">//返回最后一个数据</span></span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test05</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; deq1(<span class="number">5</span>, <span class="number">15</span>);</span><br><span class="line"><span class="comment">//cout &lt;&lt; "索引为5的元素为：" &lt;&lt; deq1.at(5) &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">//上面的输出语句报错，抛出out_of_range</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"索引为3的元素为："</span> &lt;&lt; deq1.at(<span class="number">3</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">deq1.push_front(<span class="number">44</span>);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"索引为0的元素为："</span> &lt;&lt; deq1.at(<span class="number">0</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="comment">//cout &lt;&lt; deq1[15] &lt;&lt; endl;//越界报错</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"索引为3的元素为："</span> &lt;&lt; deq1[<span class="number">3</span>] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"索引为0的元素为："</span> &lt;&lt; deq1[<span class="number">0</span>] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"deq的首元素为："</span> &lt;&lt; deq1.front() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"deq的尾元素为："</span> &lt;&lt; deq1.back() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><p><img src="/2019/07/29/deque容器/test05.PNG" alt="数据存取操作示例"></p><p>6.deque插入操作</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">insert(pos,elem);<span class="comment">//在pos位置插入一个elem元素的拷贝，返回新数据的位置</span></span><br><span class="line">insert(pos,n,elem);<span class="comment">//在pos位置插入n个elem数据，无返回值</span></span><br><span class="line">insert(pos,beg,end);<span class="comment">//在pos位置插入[beg,end)区间的数据，无返回值</span></span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test06</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; deq1(<span class="number">5</span>, <span class="number">15</span>); </span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"deq1:"</span>;</span><br><span class="line">displayDeque(deq1);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">deq1.insert(deq1.begin() + <span class="number">3</span>, <span class="number">18</span>);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"deq1:"</span>;</span><br><span class="line">displayDeque(deq1);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">deq1.insert(deq1.begin(),<span class="number">2</span>,<span class="number">20</span>);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"deq1:"</span>;</span><br><span class="line">displayDeque(deq1);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">deq1.erase(deq1.begin());</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"deq1:"</span>;</span><br><span class="line">displayDeque(deq1);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">deq1.erase(deq1.begin(), deq1.begin() + <span class="number">5</span>);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"deq1:"</span>;</span><br><span class="line">displayDeque(deq1);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">deq1.clear();</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"deq1:"</span>;</span><br><span class="line">displayDeque(deq1);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><p><img src="/2019/07/29/deque容器/test06.PNG" alt="插入和删除操作示例"></p><p>7.deque删除操作</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">clear();<span class="comment">//移除容器的所有数据</span></span><br><span class="line">erase(beg,end);<span class="comment">//删除[beg,end)区间的数据，返回下一个数据的位置</span></span><br><span class="line">erase(pos);<span class="comment">//删除pos位置的很舒服，返回下一个数据的位置</span></span><br></pre></td></tr></table></figure><p>如上例所示。</p><p>五、源码地址</p><p>​        <a href="https://github.com/Aoki-Wang/CheckStation/tree/master/STL/deque" target="_blank" rel="noopener">deque容器示例源码</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;一、deque概述&lt;/p&gt;
&lt;p&gt;&amp;emsp;&lt;code&gt;vector&lt;/code&gt;是单向开口的连续线性空间，&lt;code&gt;deque&lt;/code&gt;则是一种双向开口的连续线性空间。所谓双向开口，意思是可以在头尾两端分别做元素的插入和删除操作。虽然vector容器也可以在头尾两
      
    
    </summary>
    
      <category term="STL" scheme="http://wanqbin.xyz/categories/STL/"/>
    
    
      <category term="STL" scheme="http://wanqbin.xyz/tags/STL/"/>
    
      <category term="deque" scheme="http://wanqbin.xyz/tags/deque/"/>
    
  </entry>
  
  <entry>
    <title>使用点对点信道的数据链路层</title>
    <link href="http://wanqbin.xyz/2019/07/01/%E7%82%B9%E5%AF%B9%E7%82%B9%E4%BF%A1%E9%81%93%E7%9A%84%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/"/>
    <id>http://wanqbin.xyz/2019/07/01/点对点信道的数据链路层/</id>
    <published>2019-07-01T12:38:00.000Z</published>
    <updated>2019-07-01T12:41:36.731Z</updated>
    
    <content type="html"><![CDATA[<p>一、数据链路层的功能</p><p>&emsp;&emsp;数据链路层在物理层提供服务的基础上向网络层提供服务，其主要作用是加强物理层传输原始比特流的功能，将物理层提供的可能出错的物理连接改造为逻辑上无差错的数据链路，使之对网络层表现为一条无差错的链路。</p><ol><li><p>为网络层提供服务</p><p>对网络层而言，数据链路层的基本任务是将源机器中来自网络层的数据传输到目标其的网络层。数据链路层通常可为网络层提供如下服务：</p><p>（1）无确认的无连接服务。员及其发送数据帧时不需先建立链路连接，目的机器收到数据帧时不需发回确认。对丢失的帧，数据链路层不负责重发而交给上层处理。适用于实时通信或误码率较低的通信信道，如以太网</p><p>（2）有确认的无连接服务。源机器发送数据帧时不需先建立链路连接，但目的机器收到数据帧时必须发回确认。源机器在所规定的时间内未收到确定信号时，就重传丢失的帧，以提高传输的可靠性。该服务适用于误码率较高的通信信道，如无线通信</p><p>（3）有确认的面向连接服务。帧传输过程分为三个阶段：建立数据链路，传输帧，释放数据链路。目的机器对收到的每一帧都要给出确认，源机器收到确认后才能发送下一帧，因而该服务的可靠性最高。该服务适用于通信要求较高的场合</p></li></ol><p>二、使用点对点信道的数据链路层</p><ol><li><p>数据链路和帧</p><ul><li>链路，就是从一个结点到相邻结点的一段物理线路，而中间没有任何其他的交换结点。</li><li>数据链路，当需要在一条线路上传送数据时，除了必须要有一条物理线路外，还必须要有一些必要的通信协议来控制这些数据的传输。若把实现这些协议的硬件和软件加到链路上，就构成了数据链路。这样的数据链路就不再是简单的物理链路而是个逻辑链路了。现在最常用的方法是使用网络适配器来实现这些协议的硬件和软件。一般的适配器都包括了数据链路层和物理层这两层功能。</li><li>帧，数据链路层把网络层交下来的数据构成<strong>帧</strong>发送到链路上，以及把接收到的<strong>帧</strong>中的数据报取出并上交给网络层。在因特网中，网络层协议数据单元就是<strong>IP数据报</strong></li><li>点对点信道的数据链路层在进行通信时的主要步骤：<ul><li>结点A的数据链路层把网络层交下来的IP数据报添加首部和尾部封装成帧</li><li>结点A把封装号的帧发送给结点B的数据链路层</li><li>若结点B的数据链路层收到的帧无差错，则从收到的帧中提取出IP数据报上交给上面的网络层，否则就丢弃这个帧</li></ul></li></ul></li><li><p>封装成帧</p><ul><li>数据链路层以帧为单位传输和处理数据。网络层的IP数据报必须向下传送到数据链路层，成为帧的数据部分，同时它的前面和后面分别添加上首部和尾部，封装成一个完整的帧。帧的长度等于帧的数据部分的长度加上帧首部和帧尾部的长度。</li><li>数据链路层的接收方为了能以帧为单位处理接收的数据，必须正确地识别每个帧的开始和结束，即进行<strong>帧定界</strong></li><li>首部和尾部的作用之一就是进行帧定界，同时也包括其他必要的控制信息。</li><li>每一种链路层协议都规定了帧的数据部分长度的上限，即<strong>最大传送单元(MTU)</strong></li><li>PPP协议采用的<strong>零比特填充法</strong><ul><li>在发送端，先扫描整个信息字段。只要发现有5个连续1，则立即填入一个0，经过这种零比特填充后的数据，就可以保证在信息字段中不会出现6个连续1.</li><li>接收端在收到一个帧时，先找到帧定界标志“Flag”以确定一个帧的边界，接着再用硬件对其中的比特流进行扫描。每当发现5个连续的1时，就把5个连续1后面的一个0删除，以还原成原来的数据比特流。</li><li>这样就保证了透明传输：在所传送的树比特流中可以包含任意组合的比特模式，而不会引起对帧定界的判断错误。</li></ul></li></ul></li><li><p>差错检测</p><ul><li>现实的通信链路都不会是理想的，比特在传输过程中可能会产生差错：1可能会变为0,0可能会变为1，则就叫做<strong>比特差错</strong></li><li>传输错误的比特占所传输比特总数的比率称为<strong>误码率</strong></li><li>为了保证接收到的数据是正确的，在计算机网络传输数据时，必须采用某种差错检测措施。虽然各种差错检测技术的具体方法差别很大，但它们最基本的原理是一样的。</li><li>在数据链路层，为了便于硬件检测差错，通常在帧的尾部设置一个差错检验字段存放整个帧的差错检测码，这个差错检验字段常称为<strong>帧检验序列（FCS）</strong>。因此，要在数据链路层进行差错检验，就必须把数据划分成帧，每一帧都加上差错检验码，一帧接一帧地传送，然后再接收方逐帧进行差错检验。</li><li>在数据链路层通常使用<strong>循环冗余检验（CRC）</strong>技术进行差错检测。</li><li>CRC编码额基本原理是，发送方和接收方首先必须协商一个r+1比特的生成式G。算法要求G的最高位和最低位的比特为1,。考虑d比特的数据D，发送方要选择一个合适的r比特<strong>冗余码R（即检错码）</strong>，并将它附加到D上，使得得到的d+r比特模式用模2算术恰好能被G整除。接收方进行差错检测时，用G去除接收到的d+r比特，如果余数非零则检测出差错，否则认为树正确。</li><li>模2运算中，加法不进位，减法不错位，等价于按位异或，乘以和除以2等价于左/右移位。</li></ul></li><li><p>可靠传输</p><ul><li>在某些情况下，我们需要数据链路层向上面的网络层提供“可靠传输”的服务。“可靠传输”就是要做到：发送端发送什么，在对应的接收端就收到什么。</li><li>为了实现可靠的单向数据传输，可靠传输协议需要进行双向通信，因此底层的不可靠信道必须是双向的。</li></ul><p>（1）停止等待协议（SW）</p><ul><li>当正确接收到一个分组时，向发送方发送一个确认分组ACK，当接收到的分组出现比特差错时，丢弃该分组并发送一个否认分组NAK。发送方收到ACK则可以发送下一个分组，而收到NAK则要重传原来的分组，直到收到ACK为止。由于发送方每发送完一个分组必须停下来等接收到确认后才能发送下一个分组，该协议被称为<strong>停止等待协议（SW）</strong></li><li>如果底层的信道会丢失分组，当数据分组或确认分组丢失时，发送方将会一直等待接收方的确认分组。为了解决给问题，可以在发送方发送完一个数据分组时，启动一个<strong>超时计数器</strong>。若到了超时计数器所设置的重传时间而发送方仍收不到接收方的任何确认分组，则重传原来的分组，这就是<strong>超时重传</strong>。</li><li>当确认分组丢失时，接收方会收到两个同样的数据分组，即<strong>重复分组</strong>。若接收方不能识别重复分组，则会导致另一种差错——<strong>数据重复</strong>。为了解决该问题，必须使每个数据分组带上不同的发送序号。每发送一个新的数据分组就把它的发送序号加1.若接收方连续收到发送序号相同的数据分组，就表明出现了重复分组。这时应丢弃重复的分组，此时，接收方还必须向发送方补发一个确认分组ACK。</li><li>停止等待协议的优点是简单，但缺点是信道利用率太低。</li><li>假设存在发送方A，发送分组需要的时间是$T_D$,接收方B，发送确认分组需要时间$T_A$.如果A处理确认分组的时间可以忽略不计，那么A在经过时间（$T_D$+RTT+$T_A$)后就可以再发送下一个分组，这里的RTT是<strong>往返时间</strong>。因为仅仅是在时间$T_D$内采用来传送有用的数据，因此，信道的利用率U为：U=$\frac{TD}{TD+RTT+TA}$.</li><li>当RTT远大于分组发送时间$T_D$时，信道的利用率就会非常低</li><li>当RTT远小于发送时间$T_D$时，信道的利用率较高。</li><li>流水线传输方式就是发送方可连续发送多个分组，不必每发完一个分组就停下来等待对方的确认。这样可使得信道上一直有数据不间断地在传送。显然，这种传输方式可以获得很高的信道利用率。</li></ul><p>（2）回退N帧协议（GBN）</p><ul><li>回退N帧协议在流水线传输的基础上利用<strong>发送窗口</strong>来限制发送方连续发送分组的个数，是一种连续<strong>ARQ</strong>协议。</li><li>为此，在发送方要维持一个发送窗口。发送窗口时允许发送方已发送但还没有收到的分组序号的范围，窗口大小就是发送方已发送但还没有收到确认的最大分组数。</li><li>在协议的工作过程中，发送窗口不断向前滑动，因此，这类协议又称为<strong>滑动窗口协议</strong>。</li><li>GBN采用累积确认的方式。优点是容易实现，即使确认丢失也可能不必重传。但缺点是不能向发送方准确反映出接收方已经正确收到的所有分组的信息。</li></ul><p>（3）选择重传协议</p><ul><li>GBN协议存在一个缺点：一个分组的差错可能引起大量分组的重传，这些分组可能已经被接收方正确接收了，但由于未按序到达而被抛弃。显然对这些分组的重传是对通信资源的极大浪费。为进一步提高性能，可设法只重传出现差错的分组，但这时<strong>接收窗口不再为1</strong>，以便先收下失序到达但仍然处在接收窗口中的那些分组，等到所缺分组收齐后再一并送交上层，这就是选择重传（SR）协议。</li><li>为了使发送方仅重传出现差错的分组，接收方不能再采用累积确认，而需要对每个正确接收到的分组进行逐一确认。</li></ul><p>（4）数据链路层的可靠传输</p><ul><li>不可靠的链路加上适当的协议就可以使链路层向上提供可靠传输服务。但付出的代价是数据的传输效率降低了，而且增加了协议的复杂性。因此，应当根据链路的具体情况来决定是否需要让链路层向上提供可靠传输服务。</li><li>现在有线网络广泛使用的数据链路层协议一般都不使用确认和重传机制，即不要求数据链路层向上提供可靠传输服务。若数据链路层传输数据偶尔出现了差错，并且需要进行改正，则改正差错的任务就由上层协议来完成。实践证明，这样做可以提高通信效率，降低设备成本。</li></ul></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;一、数据链路层的功能&lt;/p&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;数据链路层在物理层提供服务的基础上向网络层提供服务，其主要作用是加强物理层传输原始比特流的功能，将物理层提供的可能出错的物理连接改造为逻辑上无差错的数据链路，使之对网络层表现为一条无差错的链路。&lt;/p&gt;
&lt;ol&gt;

      
    
    </summary>
    
      <category term="计算机网络" scheme="http://wanqbin.xyz/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="数据链路层" scheme="http://wanqbin.xyz/tags/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/"/>
    
      <category term="差错检测" scheme="http://wanqbin.xyz/tags/%E5%B7%AE%E9%94%99%E6%A3%80%E6%B5%8B/"/>
    
      <category term="可靠传输" scheme="http://wanqbin.xyz/tags/%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93/"/>
    
  </entry>
  
  <entry>
    <title>list容器</title>
    <link href="http://wanqbin.xyz/2019/07/01/list%E5%AE%B9%E5%99%A8/"/>
    <id>http://wanqbin.xyz/2019/07/01/list容器/</id>
    <published>2019-07-01T02:06:00.000Z</published>
    <updated>2019-07-28T14:23:42.902Z</updated>
    
    <content type="html"><![CDATA[<p>一、list容器概述</p><p>&emsp;&emsp;链表是一种物理存储单元上非连续、非顺序的存储结构，数据元素的逻辑顺序是通过链表中的指针链接次序实现的。链表由一系列结点（链表中每一个元素称为结点）组成，结点可以在运行时动态生成。每个结点包括两部分：一个是存储数据元素的数据域，另一个是存储下一个节点地址的指针域。</p><p>&emsp;&emsp;相较于vector的连续线性空间，list就显得复杂许多，它的好处是每次插入或删除一个元素，就配置或释放一个元素空间。因此，list对于空间的运用有绝对的精准，一点也不浪费。而且，对于任何位置的元素插入或移除，list永远都是常数时间。</p><p>&emsp;&emsp;list容器是一个双向链表</p><ul><li>采用动态存储分配，不会造成内存浪费和溢出</li><li>链表执行插入和删除操作十分方便，修改指针即可，不需要移动大量元素</li><li>链表灵活，但是空间和时间额外耗费较大</li></ul><p>二、list容器的迭代器</p><p>&emsp;&emsp;list不再能够像vector一样以普通指针作为迭代器，因为其节点不保证在同一块连续的内存空间上，list迭代器必须有能力指向list结点，并有能力进行正确的递增、递减、取值、成员存储操作。所谓list正确的递增、递减、取值、成员取用是指，递增时指向下一个节点，递减时指向上一个节点，取值时取的是结点的数据值，成员取用时取的是结点成员。</p><p>&emsp;&emsp;由于list是一个双向链表，迭代器必须能够具备前移后移的能力，所以list容器提供的是<code>Bidirectional Iterator</code></p><p>&emsp;&emsp;list有一个重要的性质，插入操作和删除操作都不会造成原有list迭代器的失效，这在vector中是不成立的，因为vector的插入操作可能会造成记忆体重新配置，导致原有的迭代器全部失效，甚至list元素的删除，也只有被删除的那个元素的迭代器失效，其他迭代器不受任何影响。</p><p>三、list的节点</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> _<span class="title">list_node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">void</span>* void_pointer;</span><br><span class="line">void_pointer prve;<span class="comment">//型别为void*，其实可设为_list_node&lt;T&gt;*</span></span><br><span class="line">void_pointer next;</span><br><span class="line">T data;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>显然这是一个双向链表。</p><p>四、list的元素操作</p><ol><li><p>常用API</p><ul><li>list<t> lstT;//list采用采用模板类实现,对象的默认构造形式</t></li><li>list(beg,end);//构造函数将[beg, end)区间中的元素拷贝给本身</li><li>list(n,elem);//构造函数将n个elem拷贝给本身</li><li>list(const list &amp;lst);//拷贝构造函数</li><li>push_back(elem);//在容器尾部加入一个元素</li><li>pop_back();//删除容器中最后一个元素</li><li>push_front(elem);//在容器开头插入一个元素</li><li>pop_front();//从容器开头移除第一个元素</li><li>insert(pos,elem);//在pos位置插elem元素的拷贝，返回新数据的位置</li><li>insert(pos,n,elem);//在pos位置插入n个elem数据，无返回值。</li><li>insert(pos,beg,end);//在pos位置插入[beg,end)区间的数据，无返回值。</li><li>clear();//移除容器的所有数据</li><li>erase(beg,end);//删除[beg,end)区间的数据，返回下一个数据的位置。</li><li>erase(pos);//删除pos位置的数据，返回下一个数据的位置。</li><li>remove(elem);//删除容器中所有与elem值匹配的元素。</li></ul><p>示例如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;L1(<span class="number">10</span>, <span class="number">10</span>);</span><br><span class="line"><span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;L2(L1.begin(), L1.end());<span class="comment">//使用L1构造L2</span></span><br><span class="line">DislayList(L1);</span><br><span class="line">DislayList(L2);</span><br><span class="line">L2.push_back(<span class="number">15</span>);<span class="comment">//给L2后面加入一个元素</span></span><br><span class="line">DislayList(L2);</span><br><span class="line"><span class="comment">//逆序打印L2</span></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;::reverse_iterator it = L2.rbegin(); it != L2.rend(); it++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="comment">//插入数据</span></span><br><span class="line"><span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;L3;</span><br><span class="line">L3.push_back(<span class="number">15</span>);</span><br><span class="line">L3.push_back(<span class="number">20</span>);</span><br><span class="line">L3.push_front(<span class="number">10</span>);</span><br><span class="line">L3.push_front(<span class="number">5</span>);</span><br><span class="line">DislayList(L3);<span class="comment">//打印L3中的元素</span></span><br><span class="line"><span class="comment">//删除list两端的元素</span></span><br><span class="line">L3.pop_front();<span class="comment">//头删</span></span><br><span class="line">L3.pop_back();<span class="comment">//尾删</span></span><br><span class="line">DislayList(L3);<span class="comment">//打印L3中的元素</span></span><br><span class="line"><span class="comment">//插入元素</span></span><br><span class="line">L3.insert(L3.begin(), <span class="number">333</span>);</span><br><span class="line">DislayList(L3);</span><br><span class="line">L3.remove(<span class="number">15</span>);</span><br><span class="line">DislayList(L3); </span><br><span class="line"><span class="keyword">if</span> (L3.empty())</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"L3为空"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"L3中元素的个数为："</span> &lt;&lt; L3.size() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">L3.erase(L3.begin());</span><br><span class="line">DislayList(L3);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果如下图：</p><p><img src="/2019/07/01/list容器/常用API.PNG" alt="常用API示例结果"></p></li><li><p>其他操作</p><ul><li>resize(num);//重新指定容器的长度为num，若容器变长，则以默认值填充新位置。如果容器变短，则末尾超出容器长度的元素被删除</li><li>resize(num, elem);//重新指定容器的长度为num，若容器变长，则以elem值填充新位置。如果容器变短，则末尾超出容器长度的元素被删除</li><li>assign(beg, end);//将[beg, end)区间中的数据拷贝赋值给本身</li><li>assign(n, elem);//将n个elem拷贝赋值给本身</li><li>swap(lst);//将lst与本身的元素互换</li><li>reverse();//反转链表</li></ul><p>示例如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;L;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">L.push_back(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"初始L为："</span>;</span><br><span class="line">DislayList(L);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"指定容器长度为15："</span>;</span><br><span class="line">L.resize(<span class="number">15</span>);</span><br><span class="line">DislayList(L);</span><br><span class="line">L.resize(<span class="number">10</span>);</span><br><span class="line">L.resize(<span class="number">15</span>,<span class="number">121212</span>);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"执行操作resize(15,121212)后："</span>;</span><br><span class="line">DislayList(L);</span><br><span class="line">L.resize(<span class="number">5</span>);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"执行操作resize(5)后："</span>;</span><br><span class="line">DislayList(L);</span><br><span class="line"><span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;L2;</span><br><span class="line">L2.assign(L.begin(), L.end());</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"L2:"</span>;</span><br><span class="line">DislayList(L2);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"L2 front:"</span> &lt;&lt; L2.front() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"L2 back:"</span> &lt;&lt; L2.back() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="comment">//反转链表</span></span><br><span class="line">L2.reverse();</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"反转后的L2为："</span>;</span><br><span class="line">DislayList(L2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果如下图：</p><p><img src="/2019/07/01/list容器/其他操作.PNG" alt="其他操作示例结果"></p></li><li><p>==运算符重载</p><ul><li>自定义数据类型Person</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">string</span> m_name;</span><br><span class="line"><span class="keyword">int</span> m_age;</span><br><span class="line">Person(<span class="built_in">string</span> name, <span class="keyword">int</span> age)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_name = name;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_age = age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> Person&amp; p)<span class="comment">//重载==运算符</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>-&gt;m_name == p.m_name &amp;&amp; <span class="keyword">this</span>-&gt;m_age == p.m_age)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>利用重载的==运算符删除其中一个元素</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test03</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">list</span>&lt;Person&gt;L;</span><br><span class="line"><span class="function">Person <span class="title">p1</span><span class="params">(<span class="string">"Aoki"</span>, <span class="number">23</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">p2</span><span class="params">(<span class="string">"青木"</span>, <span class="number">18</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">p3</span><span class="params">(<span class="string">"张一"</span>,<span class="number">20</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">p4</span><span class="params">(<span class="string">"张二"</span>, <span class="number">10</span>)</span></span>;</span><br><span class="line">L.push_back(p1);</span><br><span class="line">L.push_back(p2);</span><br><span class="line">L.push_back(p3);</span><br><span class="line">L.push_back(p4);</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">list</span>&lt;Person&gt;::iterator it = L.begin(); it != L.end(); it++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"姓名："</span> &lt;&lt; it-&gt;m_name &lt;&lt; <span class="string">"年龄："</span> &lt;&lt; it-&gt;m_age &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"删除张二"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">L.remove(p4);</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">list</span>&lt;Person&gt;::iterator it = L.begin(); it != L.end(); it++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"姓名："</span> &lt;&lt; it-&gt;m_name &lt;&lt; <span class="string">"年龄："</span> &lt;&lt; it-&gt;m_age &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果如下：</p><p><img src="/2019/07/01/list容器/重载运算符.PNG" alt="重载==运算符"></p></li><li><p>自定义规则排序</p><p>这里我们借助sort()函数对自定义数据类型进行排序操作。</p><p>需要引用一个头文件<code>#include&lt;algorithm&gt;</code></p><p>排序规则：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">ComparePerson</span><span class="params">(Person&amp; p1, Person&amp; p2)</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">//自定义排序规则，按年龄从小到大排序</span></span><br><span class="line"><span class="keyword">return</span> p1.m_age &lt; p2.m_age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据排序规则对list中的自定义数据类型元素进行排序：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test04</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">list</span>&lt;Person&gt;L;</span><br><span class="line"><span class="function">Person <span class="title">p1</span><span class="params">(<span class="string">"Aoki"</span>, <span class="number">23</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">p2</span><span class="params">(<span class="string">"青木"</span>, <span class="number">18</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">p3</span><span class="params">(<span class="string">"张一"</span>, <span class="number">20</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">p4</span><span class="params">(<span class="string">"张二"</span>, <span class="number">10</span>)</span></span>;</span><br><span class="line">L.push_back(p1);</span><br><span class="line">L.push_back(p2);</span><br><span class="line">L.push_back(p3);</span><br><span class="line">L.push_back(p4);</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">list</span>&lt;Person&gt;::iterator it = L.begin(); it != L.end(); it++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"姓名："</span> &lt;&lt; it-&gt;m_name &lt;&lt; <span class="string">"年龄："</span> &lt;&lt; it-&gt;m_age &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">L.sort(ComparePerson);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"使用自定义规则排序："</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">list</span>&lt;Person&gt;::iterator it = L.begin(); it != L.end(); it++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"姓名："</span> &lt;&lt; it-&gt;m_name &lt;&lt; <span class="string">"年龄："</span> &lt;&lt; it-&gt;m_age &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果如下：</p><p><img src="/2019/07/01/list容器/排序操作.PNG" alt="自定义排序规则"></p></li></ol><p>五、源码地址</p><p><a href="https://github.com/Aoki-Wang/CheckStation/tree/master/STL/list" target="_blank" rel="noopener">list源码示例</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;一、list容器概述&lt;/p&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;链表是一种物理存储单元上非连续、非顺序的存储结构，数据元素的逻辑顺序是通过链表中的指针链接次序实现的。链表由一系列结点（链表中每一个元素称为结点）组成，结点可以在运行时动态生成。每个结点包括两部分：一个是存储数据元
      
    
    </summary>
    
      <category term="STL" scheme="http://wanqbin.xyz/categories/STL/"/>
    
    
      <category term="STL" scheme="http://wanqbin.xyz/tags/STL/"/>
    
      <category term="list" scheme="http://wanqbin.xyz/tags/list/"/>
    
  </entry>
  
  <entry>
    <title>交换技术和分组交换的两种方式</title>
    <link href="http://wanqbin.xyz/2019/07/01/%E4%BA%A4%E6%8D%A2%E6%8A%80%E6%9C%AF%E5%92%8C%E5%88%86%E7%BB%84%E4%BA%A4%E6%8D%A2%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%96%B9%E5%BC%8F/"/>
    <id>http://wanqbin.xyz/2019/07/01/交换技术和分组交换的两种方式/</id>
    <published>2019-06-30T16:51:00.000Z</published>
    <updated>2019-06-30T17:25:15.433Z</updated>
    
    <content type="html"><![CDATA[<p>一、电路交换</p><ul><li>在进行数据传输前，两个结点之间必须建立一条专用（双方独占）的物理通信路径，该路径可能经过许多中间结点。这一路径在整个数据传输期间一直被独占，直到通信结束才被释放。因此，电路交换技术分为三个阶段：连接建立、数据传输、连接释放</li><li>从通信资源的分配角度来看，“交换”就是按照某种方式动态地分配传输线路的资源。电路交换的关键点是，在数据传输过程中，用户始终占用端到端的固定传输带宽。</li><li>电路交换的优点：<ul><li>通信时延小。当传输的数据量较大时，这一优点非常明显</li><li>有序传输</li><li>没有冲突</li><li>适用范围广</li><li>实用性强</li><li>控制简单</li></ul></li><li>电路交换的缺点<ul><li>建立连接时间长</li><li>线路独占</li><li>灵活性差</li><li>难以规格化</li></ul></li><li>电路建立后，除源结点和目的节点外，电路上的任何结点都采取“直通方式”接收数据和发送数据，即不会存在存储转发所耗费的时间。</li></ul><p>二、报文交换</p><ul><li>数据交换的单位是报文，报文携带有目标地址、源地址等信息。报文交换在交换结点采用的是存储转发的传输方式</li><li>报文交换的优点<ul><li>无须建立连接</li><li>动态分配线路</li><li>提高线路可靠性</li><li>提高线路利用率</li><li>提供多目标服务</li></ul></li><li>报文交换的缺点<ul><li>由于数据进入交换结点后要经历存储、转发这一过程，因此会引起转发时延</li><li>报文交换对报文的大小没有限制，这就要求网络结点需要有较大的缓存空间</li></ul></li></ul><p>三、分组交换</p><ul><li>采用存储转发方式，但解决了报文交换中大报文传输的问题。</li><li>分组交换限制了每次传送的数据块大小的上限，把大的数据块划分为合理的小的数据块，再加上一些必要的控制信息，构成分组。网络结点根据控制信息把分组送到下一结点，下一结点接收到分组后，暂时保存并排队等待传输，然后根据分组控制信息选择它的下一结点，直到到达目的结点。</li><li>分组交换的优点<ul><li>无建立时延</li><li>线路利用率高</li><li>简化了存储管理</li><li>加速传输</li><li>减少了出错概率和重发数据量</li></ul></li><li>分组交换的缺点<ul><li>存在传输时延</li><li>需要传输额外的信息</li><li>当分组交换采用数据报服务时，可能会出现失序、丢失或重复分组，分组到达目的结点时，要对分组按编号进行排序等工作，因此很麻烦。若采用虚电路服务，虽无失序问题，但有呼叫建立、数据传输和虚电路释放三个过程。</li></ul></li></ul><p>四、电路交换、分组交换和分组交换</p><ul><li><p>要传送的数据量很大且其传送时间远大于呼叫时间时，采用电路交换较为合适</p></li><li><p>端到端的通路由多段链路组成时，采用分组交换传送数据较为合适</p></li><li><p>从提高整个网络的信道利用率上看，报文交换和分组交换优于电路交换，其中分组交换比报文交换的时延小，尤其适合于计算机之间的突发式数据通信。</p><p><img src="/2019/07/01/交换技术和分组交换的两种方式/交换技术.jpg" alt="三种数据交换方式的比较"></p></li></ul><p>五、数据报与虚电路</p><ul><li>分组交换根据其通信子网向端点系统提供的服务，还可以进一步分为面向连接的虚电路方式和无连接的数据报方式。这两种服务方式都由网络层提供。数据报方式和虚电路方式是分组交换的两种方式。</li></ul><ol><li><p>数据报</p><ul><li>作为通信子网用户的端系统发送一个报文时，在端系统中实现的高层协议先把报文拆成若干带有序号的数据单元，并在网络层加上地址等控制信息后形成数据办分组。中间节点存储分组很短一段时间，找到最佳路由后，尽快转发每个分组。不同的分组可以走不同的路径，也可以按不同的顺序到达目的结点。</li><li>数据报服务的特点<ul><li>发送分组前不需要建立连接，发送方可随时发送分组，网络中的结点可随时接收分组</li><li>网络尽最大努力交付，传输不保证可靠性，所以可能丢失；为每个分组独立地选择路由，转发的路径可能不同，因而分组不一定按序到达目的结点</li><li>发送的分组中要包括发送端和接收端的完整地址，以便可以独立传输</li><li>分组在交换结点存储转发时，需要排队等候处理，这会带来一定的时延。通过交换结点的通信量较大或网络发生拥塞时，这种时延会大大增加，交换结点还可根据情况丢弃部分分组</li><li>网络具有冗余路径，当某一交换结点或一段链路出现故障时，可相应地更新转发表，寻找另一条路径转发分组，对故障的适应能力强</li><li>存储转发的时延一般较小，提高了网络的吞吐量</li><li>收发双方不独占某一链路，资源利用率高</li></ul></li></ul></li><li><p>虚电路</p><ul><li>虚电路方式试图将数据报方式与电路交换方式结合起来，充分发挥两种方法的优点，以达到最佳的数据交换效果。在分组发送之前，要求在发送方和接收方建立一条逻辑上相连的虚电路，并且连接一旦建立，就固定了虚电路所对应的物理路径。与电路交换类似，整个通信过程分为三个阶段：虚电路建立、数据传输与虚电路释放</li><li>在虚电路方式中，端系统每次建立虚电路时，选择一个未用过的虚电路号分配给该虚电路以区别于本系统中的ITA虚电路。在传送数据时，每个数据分组不仅要有分组号、校验和等控制信息，还要有它通过的虚电路号，以区别于其他虚电路上的分组。在虚电路网路中的每个结点上都维持一张虚电路表，表中的每项记录了一个打开的虚电路信息，包括在接收链路和发送链路上的虚电路号、前一结点和下一结点的标识。数据传输时双向进行的，上述信息是在建立过程中确定的。</li><li>虚电路服务的特点<ul><li>虚电路通信链路的建立和拆除需要时间开销，对交互式应用和小量的短分组情况显得很浪费，但对长时间、频繁的数据交换效率较高</li><li>虚电路的路由选择体现在连接建立阶段，连接建立后，就确定了传输路径</li><li>虚电路提供了可靠的通信功能，能保证每个分组正确且有序到达。此外还可以对两个数据端点的流量进行控制，当接收方来不及接收数据时，可以通知发送方暂缓发送</li><li>虚电路有一个致命的弱点，即当网络中的某个结点或某条链路出现故障而彻底失效时，所有经过该结点或该链路的虚电路将遭到破坏</li><li>分组首部不含目的地址，而包含虚电路标识符，相对数据报方式开销小</li></ul></li><li>虚电路之所以是“虚”的，是因为这条电路不是专用的，每个节点到其他节点之间的链路可能同时有若干虚电路通过，也可能同时与多个结点之间建立虚电路。每天虚电路支持特定的两个端系统之间的数据传输，两个端系统之间也可以有多条虚电路为不同的进程服务，这些虚电路的实际路由可能相同也可能不同。</li></ul></li><li><p>数据报服务和虚电路服务的比较</p></li></ol><div class="table-container"><table><thead><tr><th></th><th>数据报服务</th><th>虚电路服务</th></tr></thead><tbody><tr><td>连接的建立</td><td>不需要</td><td>必须有</td></tr><tr><td>目的地址</td><td>每个分组都有完整的目的地址</td><td>仅在建立连接阶段使用，之后每个分组使用长度较短的虚电路号</td></tr><tr><td>路由选择</td><td>每个分组独立地进行路由选择和转发</td><td>属于同一条虚电路的分组按照同一路由转发</td></tr><tr><td>分组顺序</td><td>不保证分组的有序到达</td><td>保证分组的有序到达</td></tr><tr><td>可靠性</td><td>不保证可靠通信，可靠性由用户主机来保证</td><td>可靠性由网络保证</td></tr><tr><td>对网络故障的适应性</td><td>出故障的结点丢失分组，其他分组路径选择发生变化时可以正常传输</td><td>所有经过故障结点的虚电路均不能正常工作</td></tr><tr><td>差错处理和流量控制</td><td>由用户主机进行流量控制，不保证数据报的可靠性</td><td>可由分组交换网负责，也可由用户主机负责</td></tr></tbody></table></div>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;一、电路交换&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在进行数据传输前，两个结点之间必须建立一条专用（双方独占）的物理通信路径，该路径可能经过许多中间结点。这一路径在整个数据传输期间一直被独占，直到通信结束才被释放。因此，电路交换技术分为三个阶段：连接建立、数据传输、连接释放&lt;/li&gt;

      
    
    </summary>
    
      <category term="计算机网络" scheme="http://wanqbin.xyz/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="电路交换" scheme="http://wanqbin.xyz/tags/%E7%94%B5%E8%B7%AF%E4%BA%A4%E6%8D%A2/"/>
    
      <category term="报文交换" scheme="http://wanqbin.xyz/tags/%E6%8A%A5%E6%96%87%E4%BA%A4%E6%8D%A2/"/>
    
      <category term="分组交换" scheme="http://wanqbin.xyz/tags/%E5%88%86%E7%BB%84%E4%BA%A4%E6%8D%A2/"/>
    
      <category term="虚电路" scheme="http://wanqbin.xyz/tags/%E8%99%9A%E7%94%B5%E8%B7%AF/"/>
    
      <category term="数据报" scheme="http://wanqbin.xyz/tags/%E6%95%B0%E6%8D%AE%E6%8A%A5/"/>
    
  </entry>
  
  <entry>
    <title>vector容器</title>
    <link href="http://wanqbin.xyz/2019/06/30/vector%E5%AE%B9%E5%99%A8/"/>
    <id>http://wanqbin.xyz/2019/06/30/vector容器/</id>
    <published>2019-06-30T11:31:00.000Z</published>
    <updated>2019-06-30T16:01:56.028Z</updated>
    
    <content type="html"><![CDATA[<p>一、序列式容器</p><p>所谓序列式容器，其中的元素都是可序的，但未必有序。C++本身体用了一个序列式容器array，STL另外提供了vector,list,deque,stack.priority-queue等序列式容器。</p><p>二、vector</p><ol><li><p>vector与array的区别</p><p>vector的数据安排以及操作方式，与array非常相似，两者的唯一差别在于空间运用的灵活性。</p><ul><li>array是静态空间，一旦配置了就不能改变，要更换大一些的空间，就必须执行如下操作：<ul><li>配置一块新空间</li><li>将元素从旧地址一一搬往新地址</li><li>把原来的空间释放还给系统</li></ul></li><li>vector是动态空间，随着元素的加入，它的内部机制会自行扩充空间以容纳新元素</li></ul></li><li><p>vector空间配置</p><ul><li>为了降低空间配置时的速度成本，vector实际配置的大小比客户端需求大一些，以备将来可能的扩充。这便是容量（capacity）的概念。换句话说，一个vector的容量永远大于或等于其大小。一旦容量等于大小，便是满载，下次再有新增元素，整个vector就得另觅居所。</li><li>所谓动态增加大小，并不是在原空间之后续接新空间，而是一块更大的内存空间，然后将元数据拷贝到新空间，并释放原空间，因此，对vector的任何操作，一旦引起空间的重新配置，指向原vector额度所有迭代器就都失效了。</li><li></li></ul></li><li><p>vector的数据结构</p><p>vector所采用的数据结构非常简单：线性连续空间。它以两个迭代器<code>start</code>和<code>finish</code>分别指向配置得来的连续空间中已经使用的范围，并以迭代器<code>end_of_storage</code>指向整块连续空间（含备用空间）的尾端。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">Alloc</span> = <span class="title">alloc</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">vector</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">……</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">iterator start;    <span class="comment">//表示目前使用空间的头</span></span><br><span class="line">iterator finish;  <span class="comment">//表示目前使用空间的尾</span></span><br><span class="line">iterator end_of_storage;  <span class="comment">//表示目前可用空间的尾</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>push_back操作</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;v;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"vector当前使用的空间为："</span> &lt;&lt; v.size() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"vector的容量为："</span> &lt;&lt; v.capacity() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">v.push_back(i);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"vector当前使用的空间为："</span> &lt;&lt; v.size() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"vector的容量为："</span> &lt;&lt; v.capacity() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">DisplayVector(v);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2019/06/30/vector容器/push_back.PNG" alt="push_back操作"></p></li><li><p>构造一个vector容器</p><p>vector中提供的构造函数和拷贝构造函数如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>() :start(<span class="number">0</span>), finish(<span class="number">0</span>), end_of_storage(<span class="number">0</span>) &#123;&#125;</span><br><span class="line"><span class="built_in">vector</span>(size_type n, <span class="keyword">const</span> T&amp; value)</span><br><span class="line">&#123;</span><br><span class="line">fill_initialize(n, value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">vector</span>(<span class="keyword">int</span> n, <span class="keyword">const</span> T&amp; value)</span><br><span class="line">&#123;</span><br><span class="line">fill_initialize(n, value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">vector</span>(<span class="keyword">long</span> n, <span class="keyword">const</span> T&amp; value)</span><br><span class="line">&#123;</span><br><span class="line">fill_initialize(n, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面使用一个vector容器构造另一个vector容器，代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v1;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">v1.push_back(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v2(v1.begin(), v1.end());</span><br><span class="line">DisplayVector(v1);</span><br><span class="line">DisplayVector(v2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果如下图：</p><p><img src="/2019/06/30/vector容器/构造v2.PNG" alt="构造一个vector容器"></p></li><li><p>使用数组初始化vector</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test03</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> <span class="built_in">array</span>[] = &#123; <span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">11</span> &#125;;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;v(<span class="built_in">array</span>, <span class="built_in">array</span> + <span class="keyword">sizeof</span>(<span class="built_in">array</span>) / <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">DisplayVector(v);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果如下图：</p><p><img src="/2019/06/30/vector容器/数组构造vector容器.PNG" alt="使用数组初始化vector"></p></li><li><p>初始化vector容器的一些方式</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test04</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;v1(<span class="number">10</span>, <span class="number">1</span>);<span class="comment">//初始化vector容器v为10个1</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"v1:"</span>;</span><br><span class="line">DisplayVector(v1);</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;v2&#123; <span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">10</span> &#125;;<span class="comment">//列表初始化vector容器</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"v2:"</span>;</span><br><span class="line">DisplayVector(v2);</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;v3;</span><br><span class="line"><span class="comment">//assign(begin(),end());将[begin,end]区间中的数据拷贝给容器</span></span><br><span class="line">v3.assign(v1.begin(), v1.end());</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"v3:"</span>;</span><br><span class="line">DisplayVector(v3);</span><br><span class="line"><span class="comment">//assign(n,value);将n个value赋值给容器</span></span><br><span class="line">v3.assign(<span class="number">10</span>, <span class="number">100</span>);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"v3:"</span>;</span><br><span class="line">DisplayVector(v3);</span><br><span class="line"><span class="comment">//swap(vector);将vector中的元素与本身的元素交换</span></span><br><span class="line">v1.swap(v3);<span class="comment">//v1与v3的元素进行交换</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"v1:"</span>;</span><br><span class="line">DisplayVector(v1);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"v3:"</span>;</span><br><span class="line">DisplayVector(v3);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果如下图所示：</p><p><img src="/2019/06/30/vector容器/初始化vector的一些方式.PNG" alt="初始化vector容器的一些方式"></p></li><li><p>vector的元素操作：insert、push_back、pop_back、erase、clear</p><p>对元素操作的说明如下：</p><ul><li>insert(const_iterator pos, int count,ele);//迭代器指向位置pos 插入count 个元素ele.</li><li>push_back(ele); //尾部插入元素ele</li><li>pop_back();//删除最后一个元素</li><li>erase(const_iterator start, const_iterator end);//删除迭代器从start 到end 之间的元素</li><li>erase(const_iterator pos);//删除迭代器指向的元素</li><li><p>clear();//删除容器中所有元素</p></li><li><p>size();//返回容器中元素的个数</p></li><li>empty();//判断容器是否为空</li><li>resize(int num);//重新指定容器的长度为num，若容器变长，则以默认值填充新位置。如果容器变<br>短，则末尾超出容器长度的元素被删除。</li><li>resize(int num, elem);//重新指定容器的长度为num，若容器变长，则以elem 值填充新位置。如<br>果容器变短，则末尾超出容器长&gt;度的元素被删除。</li><li>capacity();//容器的容量</li><li>reserve(int len);//容器预留len 个元素长度，预留位置不初始化，元素不可访问。</li></ul><p>示例如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test05</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;v1&#123; <span class="number">10</span>,<span class="number">15</span>,<span class="number">16</span>,<span class="number">17</span>,<span class="number">18</span>,<span class="number">19</span>,<span class="number">20</span> &#125;;</span><br><span class="line"><span class="keyword">if</span> (v1.empty())</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"v1为空"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"v1:"</span>;</span><br><span class="line">DisplayVector(v1);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"v1不为空，元素个数为："</span> &lt;&lt; v1.size() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">v1.resize(<span class="number">10</span>);<span class="comment">//重新指定vector容器的长度</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"v1的元素个数为："</span> &lt;&lt; v1.size() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">DisplayVector(v1);</span><br><span class="line">v1.resize(<span class="number">15</span>, <span class="number">8888</span>);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"v1的元素个数为："</span> &lt;&lt; v1.size() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">DisplayVector(v1);</span><br><span class="line">v1.resize(<span class="number">4</span>);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"现在v1的元素个数为："</span> &lt;&lt; v1.size() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">DisplayVector(v1);</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;v2;</span><br><span class="line">v2.reserve(<span class="number">15</span>);<span class="comment">//为v2预留15个元素的长度</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">v2.push_back(i);</span><br><span class="line">&#125;</span><br><span class="line">DisplayVector(v2);</span><br><span class="line"><span class="keyword">int</span> ret = v1.at(<span class="number">2</span>);<span class="comment">//取索引5指向的元素</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"索引为2所指的数据为："</span> &lt;&lt; ret &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"v1中的第三个元素为："</span> &lt;&lt; v1[<span class="number">2</span>] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"v1的首元素为："</span> &lt;&lt; v1.front() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"v1的尾元素为："</span> &lt;&lt; v1.back() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">v1.insert(v1.begin() + <span class="number">1</span>, <span class="number">4</span>, <span class="number">5</span>);<span class="comment">//在迭代器v1.begin()+1指向的位置插入4个5</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"v1:"</span>;</span><br><span class="line">DisplayVector(v1);<span class="comment">//输出</span></span><br><span class="line">v1.pop_back();<span class="comment">//删除v1的尾元素</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"v1:"</span>;</span><br><span class="line">DisplayVector(v1);</span><br><span class="line">v1.erase(v1.begin());<span class="comment">//删除v1的v1.begin指向的元素</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"v1:"</span>;</span><br><span class="line">DisplayVector(v1);</span><br><span class="line">v1.erase(v1.begin()+<span class="number">1</span>, v1.end());<span class="comment">//删除v1.begin()+1,v1.end()之间的元素</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"v1:"</span>;</span><br><span class="line">DisplayVector(v1);</span><br><span class="line">v1.clear();<span class="comment">//清空v1中的元素</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"v1:"</span>;</span><br><span class="line">DisplayVector(v1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果如下：</p><p><img src="/2019/06/30/vector容器/vector的元素操作.PNG" alt="vector的元素操作"></p></li><li><p>使用swap来收缩vector容器的空间</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test06</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;v;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">v.push_back(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"v的容量为："</span> &lt;&lt; v.capacity() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"v的大小为："</span> &lt;&lt; v.size() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">v.resize(<span class="number">5</span>);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"调整大小后vector容器的容量和大小如下："</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"v的容量为："</span> &lt;&lt; v.capacity() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"v的大小为："</span> &lt;&lt; v.size() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"使用swap收缩vector空间"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(v).swap(v);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"v的容量为："</span> &lt;&lt; v.capacity() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"v的大小为："</span> &lt;&lt; v.size() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果如下：</p><p><img src="/2019/06/30/vector容器/使用swap收缩vector容器空间.PNG" alt="使用swap收缩vector容器空间"></p></li><li><p>源码地址</p><p><a href="https://github.com/Aoki-Wang/CheckStation/tree/master/STL/vector" target="_blank" rel="noopener">vector源码示例</a></p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;一、序列式容器&lt;/p&gt;
&lt;p&gt;所谓序列式容器，其中的元素都是可序的，但未必有序。C++本身体用了一个序列式容器array，STL另外提供了vector,list,deque,stack.priority-queue等序列式容器。&lt;/p&gt;
&lt;p&gt;二、vector&lt;/p&gt;
&lt;o
      
    
    </summary>
    
      <category term="STL" scheme="http://wanqbin.xyz/categories/STL/"/>
    
    
      <category term="STL" scheme="http://wanqbin.xyz/tags/STL/"/>
    
      <category term="vector" scheme="http://wanqbin.xyz/tags/vector/"/>
    
  </entry>
  
  <entry>
    <title>STL概论</title>
    <link href="http://wanqbin.xyz/2019/06/30/STL%E6%A6%82%E8%AE%BA/"/>
    <id>http://wanqbin.xyz/2019/06/30/STL概论/</id>
    <published>2019-06-30T10:30:00.000Z</published>
    <updated>2019-06-30T10:31:33.704Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>长久以来，软件界一直希望建立一种可重复运用的东西，以及一种得以制造出“可重复运用的东西”的方法，让工程师/程序员的心血不致于随时间迁移、人事异动、私心欲念而烟消云散。从子函数、程序、函数、类别、到函数库、类别库、各种组件、从结构化设计、模块化设计、面向对象设计、到模式的归纳整理，无一不是软件工程的慢慢奋斗史。</p><p>为的，就是复用性的提升。</p><p>——《STL源码剖析》</p></blockquote><p>为了建立数据结构和算法的一套标准，并且降低他们之间的耦合关系，以提升各自的独立性、弹性、交互操作性、，诞生了STL。</p><p>STL（标准模板库），是惠普实验室开发的一系列软件的统称。</p><p>STL从广义上分为：容器、算法、迭代器。容器和算法之间通过迭代器进行无缝连接。STL几乎所有的代码都采用了模板类或模板函数，相比于由函数和类组成的库来说提供了更好的代码复用机会。</p><p>一、STL六大组件</p><ol><li>容器：各种数据结构，如vector,list,deque,set,map，用来存放数据。</li><li>算法：各种常用的算法如：sort,search,copy,erase……</li><li>迭代器:扮演了容器和算法之间的胶合剂，是所谓的泛型指针。共有五种类型，以及其他的衍生变化，从实现的角度来看，迭代器是一种将operator*,operator-&gt;,operator++,operator—等指针相关操作予以重载的class template。所有STL容器都附带有自己专属的迭代器，只有容器设计者才知道如何遍历自己的元素。原生指针也是一种迭代器。</li><li>仿函数：行为类似函数，可作为算法的某种策略。从实现的角度看，仿函数是一种重载了operator()的class或class template</li><li>适配器：一种用来修饰容器或仿函数或得带器接口的东西。</li><li>空间配置器：负责空间配置与管理。从实现的角度来看，配置器是一个实现了动态空间配置，空间管理，空间释放的class template。</li></ol><p>STL六大组件的交互关系，容器通过空间配置器取得数据存储空间，算法通过迭代器存储容器空间中的内容，仿函数可以协助算法完成不同的策略的变化，适配器可以修饰仿函数</p><p>二、STL优点</p><ol><li>STL是C++的一部分，因此不用额外安装什么，它被内建在编译器之内</li><li>STL的一个重要特性是将数据和操作分离，数据由容器类别加以管理，操作则由可定制的算法定义。迭代器在两者之间充当粘合剂，以使算法可以和容器交互运行。</li><li>程序员不用思考STL具体的实现过程，只要能熟练使用STL就可以。这样他们就可以把精力放在程序开发的别的方面</li><li>STL具有高复用性、高性能、高移植性、跨平台等优点。<ul><li>高可重用性：STL中几乎所有的代码都采用了模板类和模板函数的方式实现，这相比于传统的由函数和类组成的库来说提供了更好的代码重用机会。</li><li>高性能：如map可以高效地从十万记录里面查找出指定的记录。因为map是采用红黑树的变体实现的</li><li>高移植性：如在项目A上用STL编写的模块，可以直接移植到项目B上。</li></ul></li></ol><p>三、STL三大组件介绍</p><ol><li><p>容器</p><p>容器，置物之所也。</p><p>研究数据的特定排列方式，以利于搜索或排序或其他特殊每亩地，这一门学科就是数据结构。</p><p>任何特定的数据结构都是为了实现某种特定的算法。STL容器就是将运用最广泛的一些数据结构实现出来。</p><p>常用的数据结构：数组（array），链表（list）、树（tree），栈（stack），队列（queue），集合（set），映射表（map），根据数据在容器这两个排列的特性，这些数据分为序列式容器和关联式容器两种。  </p><ul><li>序列式容器强调的是值的排序，序列式容器中的每个元素均有固定的位置，除非用删除或插入操作改变这个位置。vector容器，deque容器，list容器</li><li>关联式容器是非线性的树结构，更准确的说是二叉树结构，各元素之间没有严格的物理上的顺序关系，也就是说元素在容器中并没有保存元素置入容器时的逻辑顺序。关联式容器另一个显著特点是：在值中选择一个值作为关键字key，这个关键字对值起到了索引的作用，方便查找。set/multiset容器，map/multimap容器</li></ul></li><li><p>算法</p><p>算法，问题之解法也。</p><p>以有限的步骤，解决逻辑或数学上的问题，即为算法。</p><p>算法分为：质变算法和非质变算法</p><p>质变算法：是指在运算过程中会戈恩噶区间内元素的内容，例如拷贝、替换、删除等</p><p>非质变算法：是指运算过程中不会更改区间内的元素内容，例如查找、计数、遍历寻找极值等。</p></li><li><p>迭代器</p><p>迭代器（iterator）是一种抽象的设计概念，显示程序语言中并诶呦直接对应于这个概念的实物。设计模式中iterator模式定义如下：提供一种方法，使之能够依序寻访某个容器所含的各个元素，而又无须暴露该容器的内部表示方式。 </p><p>迭代器的设计思维-STL的关键所在，STL的中心思想在于将容器和算法分开，彼此独立设计，最后再贴胶着剂将他们撮合在一起，从技术角度来看，容器和算法的泛型化并不困难，C++的class template 和function template可分别达到目标，如果设计出这两个之间的良好的胶着剂，才是大难题。  </p></li></ol><div class="table-container"><table><thead><tr><th>分类</th><th>描述</th><th>功能</th></tr></thead><tbody><tr><td>输入迭代器</td><td>提供对数据的只读访问</td><td></td></tr><tr><td>输出迭代器</td><td>提供读写操作，并能向前推进迭代器</td><td></td></tr><tr><td>前向迭代器</td><td>提供读写操作，并能向前推进迭代器</td><td>读写，支持++，==，~=</td></tr><tr><td>双向迭代器</td><td>提供读写操作，并能向前和向后操作</td><td>读写，只会++，—</td></tr><tr><td>随机访问迭代器</td><td>提供读写操作，并能以跳跃的方式访问容器的任意数据，是功能最强大的的迭代器</td><td>读写，支持++，—，[n],-n,&lt;,&lt;=,&gt;,&gt;=</td></tr></tbody></table></div>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;长久以来，软件界一直希望建立一种可重复运用的东西，以及一种得以制造出“可重复运用的东西”的方法，让工程师/程序员的心血不致于随时间迁移、人事异动、私心欲念而烟消云散。从子函数、程序、函数、类别、到函数库、类别库、各种组件、从结构化设计、模块化设计、
      
    
    </summary>
    
      <category term="STL" scheme="http://wanqbin.xyz/categories/STL/"/>
    
    
      <category term="STL" scheme="http://wanqbin.xyz/tags/STL/"/>
    
  </entry>
  
  <entry>
    <title>软件测试知识点总结</title>
    <link href="http://wanqbin.xyz/2019/06/30/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/"/>
    <id>http://wanqbin.xyz/2019/06/30/软件测试知识点总结/</id>
    <published>2019-06-30T08:40:00.000Z</published>
    <updated>2019-06-30T08:43:43.870Z</updated>
    
    <content type="html"><![CDATA[<p>一、软件测试基本概念</p><ol><li><p>软件测试的定义</p><p>使用人工或自动手段来运行或测试某个系统的过程，其目的在于检验它是否满足规定的需求或是否弄清预期结果与实际结果之间的差别。</p></li><li><p>软件缺陷的定义</p><p>软件缺陷，常常被称为bug。所谓软件缺陷，即计算机软件或程序中存在某种破坏正常运行能力的问题、错误，或者隐藏的功能缺陷。缺陷的存在会导致软件产品在某种程度上不能满足用户的需要。</p><p>标准定义：从产品内部看，缺陷时软件产品的开发或维护过程中存在的错误、毛病等各种问题；从产品外部看，缺陷是系统所需要实现的某种功能的失效或违背。</p></li><li><p>软件缺陷的主要类型</p><p>(1)软件没有是实现产品说明书中要求的功能模块</p><p>(2)软件中出现了产品说明书中指明不应出现的错误</p><p>(3)软件实现了产品说明书中没有提到的功能模块</p><p>(4)软件没有实现产品说明书中没有明确提到但应该实现的目标</p><p>(5)软件难以理解、不易于使用，运行缓慢，或从测试员的角度看，最终用户会认为不好。</p></li><li><p>软件缺陷的级别</p><p>(1)微小的。一些小问题，对功能几乎没有影响，软件产品仍然可以使用</p><p>(2)一般的。不太严重的问题，如次要功能模块丧失、提示信息不够准确、用户界面差、操作时间长等</p><p>(3)严重的。严重错误，指没有实现功能模块或某个特性，主要功能部分丧失、次要功能全部丧失，或致命的错误声明</p><p>(4)致命的。致命的错误，将造成系统崩溃、死机，或造成数据丢失、主要功能完全丧失等</p><p>通常情况下，问题越严重，其处理优先级就越高。</p></li><li><p>软件缺陷的状态</p><p>(1)激活状态：问题没有解决，测试人员新报告的缺陷或者验证后的缺陷仍旧存在</p><p>(2)已修正状态：已经被开发人员检查、修复过的缺陷，通过单元测试，认为已经解决但还没有被测试人员验证</p><p>(3)关闭状态：测试人员经过验证后，确认验证不存在之后的状态</p></li><li><p>软件缺陷的原因</p><p>(1)软件产品说明书</p><p>(2)设计方法</p><p>(3)编写代码</p><p>(4)其他</p><p>比例依次减小</p></li><li><p>软件缺陷修复的代价</p><p>依次递增，如下：</p><p>(1)编制说明书</p><p>(2)设计阶段</p><p>(3)编写代码</p><p>(4)测试</p><p>(5)发布</p></li><li><p>软件测试的分类</p><p>(1)按照开发阶段划分</p><p>​    ①单元测试</p><p>​    ②集成测试</p><p>​    ③系统测试</p><p>​    ④验收测试</p><p>(2)按测试技术划分</p><p>​    ①白盒测试</p><p>​    ②黑盒测试</p><p>​    ③灰盒测试</p><p>(3)按被测软件是否实际运行划分</p><p>​    ①静态测试</p><p>​    ②动态测试</p><p>(4)按照测试实施组织划分</p><p>​    ①开发方测试（α测试)</p><p>​    ②用户测试（β测试）</p><p>​    ③第三方测试</p></li><li><p>软件测试的原则</p><p>（1）完全测试程序是不可能的</p><p>（2）软件测试是有风险的</p><p>（3）测试无法显示潜伏的软件缺陷</p><p>（4）软件缺陷的群集现象</p><p>（5）杀虫剂怪事：软件测试越多，其免疫力越强</p><p>（6）并非所有的软件缺陷都能被修复</p><p>（7）难以描述的软件缺陷</p></li></ol><p>二、黑盒测试用例设计方法</p><ol><li><p>测试用例在软件测试中的作用</p><p>（1）推导测试的实施</p><p>（2）规划测试数据的准备</p><p>（3）编写测试脚本的“设计规格说明书”</p><p>（4）评估测试结果的度量基准</p><p>（5）分析缺陷的标准</p></li><li><p>设计测试用例的步骤</p><p>（1）测试需求分析</p><p>（2）业务流程分析</p><p>（3）测试用例设计</p><p>（4）测试用例评审</p><p>（5）测试用例更新完善</p></li><li><p>等价类划分法</p><ul><li><p>等价类划分法是一种最为常见的黑盒测试方法。</p></li><li><p>其基本实现是把程序的输入域划分为若干个子集，然后从每个子集中选取少量具有代表性的数据作为测试用例。在该子集合中，各个输入数据对于揭示程序中的错误都是等效的</p></li><li><p>等价类可以分为两种：</p><p>（1）有效等价类。指对于程序的规格说明来说，是由合理的、与意义的输入数据构成的集合。主要为了检验程序是否实现了规格说明书中规定的功能和性能</p><p>（2）无效等价类。对规格说明书而言，是由无意义的、不合理的输入数据构成的集合。利用无效等价类中的数据，检验程序对错误输入的处理能力。</p></li><li><p>设计测试用例的步骤</p><p>（1）划分等价类</p><p>（2）建立等价类表，列出所有划分出的等价类，并为每一个等价类规定一个唯一的编号</p><p>（3）从划分出的等价类中按以下原则设计测试用例。设计一个新的测试用例，使其尽可能多地覆盖尚未被覆盖的有效等价类，重复这一步骤，直到所有的有效等价类都被覆盖为止；设计一个新的测试用例，使其仅覆盖一个尚未被覆盖的无效等价类，重复这一步，直到所有的无效等价类都被覆盖为止</p></li></ul></li><li><p>边界值分析法</p><ul><li>边界值分析法用于考察处于等价划分边界或在边界附近的状态。</li><li>通常，软件中边界分为内部边界和外部边界两种。所谓的外部边界是可以在需求规格说明书、设计规格说明书中找到相应的描述的，而内部边界是在程序实现环节存在的、至关重要的界限。</li></ul></li><li><p>因果图法</p><ul><li><p>等价类划分法和边界值分析方法都着重考虑输入条件，但没有考虑输入条件的各种组合、输入条件之间的相互制约关系。</p></li><li><p>因果图是一种利用图解法分析输入的各种组合情况，从而设计测试用例的方法，它适合于检查程序输入条件的各种组合情况。</p></li><li><p>因果图的定义：因果图是一种描述输入和输出之间关系的图，其中出现的基本符号主要有：节点和弧线。</p></li><li><p>因果图描述的原因和结果之间的关系：</p><p>（1）恒等</p><p>（2）非</p><p>（3）或</p><p>（4）与</p></li><li><p>输入条件的约束：</p><p>（1）E约束（异）</p><p>（2）I约束（或）</p><p>（3）O约束（唯一）</p><p>（4）R约束（要求）</p></li><li><p>因果图法的基本步骤</p><p>（1）分析程序规格说明书中描述的语义内容，找出“原因”和“结果”，将其表示成连接各个原因与结果的“因果图”</p><p>（2）由于语法或环境限制，有些原因与原因之间或原因与结果之间的组合情况是不可能出现的，可用记号标明约束或限制条件</p><p>（3）将因果图转换成判定表</p><p>（4）根据判定表中的每一列设计测试用例</p></li></ul></li><li><p>决策表法</p><ul><li><p>决策表，也称判定表。在所有的黑盒测试方法中，基于决策表的测试方法被认为是最严格的的，因为决策表具有逻辑严格性。</p></li><li><p>决策表是分析和表达多逻辑条件下执行不同操作的情况的工具。</p></li><li><p>决策表的结构</p><p>（1）条件桩：列出问题的所有条件</p><p>（2）条件项：针对条件桩给出的条件列出所有可能的取值</p><p>（3）动作桩：列出问题规定的可能采取的操作</p><p>（4）动作项：指出在条件项的各组取值情况下应采取的动作</p><p>（5）规则：贯穿条件项和动作项的一列就是一条规则</p></li><li><p>决策表的化简</p><ul><li>初始决策表的条件项的数目很大，若表中有两条以上规则具有相同的动作，并且在条件项之间存在极为相似的关系，便可以将它们合并。合并后的条件项用符号“—”表示，说明执行的动作与该条件的取值无关，称为无关条件。</li></ul></li></ul></li></ol><p>三、白盒测试用例设计方法</p><ol><li><p>逻辑覆盖测试</p><ul><li>白盒测试方法是把测试对象看作一个打开的盒子，测试人员依据程序内部逻辑结构相关信息，设计或选择测试用例，对程序所有逻辑路径进行测试，通过在不同点检查程序的状态，确定实际的状态是否与预期的状态一致。</li><li>逻辑覆盖测试是以程序内在逻辑结构为基础的测试，重点关注测试覆盖率。包括以下6种类型：语句覆盖、判定覆盖、条件覆盖、判定/条件覆盖、条件组合覆盖和路径覆盖。</li></ul></li><li><p>语句覆盖</p><ul><li>语句覆盖是指设计若干个测试用例，使程序中的每个可执行语句至少执行一次。在保证每条语句都运行的前提下，测试用例应尽量少。在语句覆盖的基础上可以实现程序覆盖，进而是程序块的覆盖。</li><li>语句覆盖是一种较弱的覆盖测试。</li></ul></li><li><p>判定覆盖</p><ul><li>判定覆盖的含义是：设计足够多的测试用例，使程序中的每个判定都至少获得“真值”和“假值”。程序中的判定有：分支判定和循环判定。</li><li>为了表示方便，做到理解上的统一，表示某个条件的真假用$T_i$和$F_i$,表示某个判定的真假使用$TD_i$和$FD_i$</li></ul></li><li><p>条件覆盖</p><ul><li>条件覆盖的含义是:构造一组测试用例，使得每一个判定中每个逻辑条件的可能值至少被满足一次。</li></ul></li><li><p>判定/条件覆盖</p><ul><li>设计足够的测试用例，使得判定中每个条件的所有可能（真/假）至少出现一次，并且每个判定本身的判定结果（真/假）也至少出现一次，即满足判定/条件覆盖的测试用例同时满足条件覆盖和判定覆盖。</li></ul></li><li><p>组合条件覆盖</p><ul><li><p>组合条件覆盖的含义是：设计足够的测试用例，使得每个判定中条件的各种可能组合都至少出现一次。</p></li><li><p>显然，满足组合条件覆盖的测试用例是一定满足判定覆盖、条件覆盖和判定/条件覆盖的。</p></li><li><p>具体的组合策略如下：</p><p>（1）如果某个条件组合只有一种可能性，则优先确立关系</p><p>（2）不可能存在的组合不住要设计测试用例</p><p>（3）除了不可能的情况，所有的条件组合都必须至少出现一次</p></li></ul></li><li><p>路径覆盖</p><ul><li>所谓路径覆盖就是设计足够多的测试用例使每个路径都有可能被执行。</li></ul></li><li><p>基本路径测试</p><ul><li>包括程序控制流图，环形复杂度、独立路径</li></ul></li><li><p>控制流图</p><ul><li><p>在设计程序时，为了更加突出控制流的结构，可对程序流程图进行简化，简化后的流程图称为控制流图。</p></li><li><p>控制流图的构成：</p><ul><li>控制流线</li><li>结点</li></ul></li><li><p>必须用结点表示的情况：</p><p>（1）程序流程图中矩形框表示的处理</p><p>（2）菱形框表示的两个甚至多个出口判断</p><p>（3）多条流线相交的汇合点</p></li></ul></li><li><p>环形复杂度</p><ul><li><p>环形复杂度（圈复杂度）是一种为程序逻辑复杂度提供定量尺度的软件度量。也可将该度量用于基本路径测试方法，它可以提供程序基本集的独立路径数量和确保所有语句至少被执行一次的测试数量上界。</p></li><li><p>计算环形复杂度的方法：</p><p>（1）流图中区域的数量对应于环形复杂度</p><p>（2）给定流图G的环形复杂度为V（G），定义为V(G)=E-N+2,其中，E是流图中边的数量，N是流图中节点的数量</p><p>（3）给定流图G的环形复杂度V(G)，定义为V(G)=P+1,P是流图G中判定结点的数量</p></li></ul></li><li><p>独立路径</p><ul><li>独立路径是指程序中至少引入了一个新的处理语句集合或一个新条件的程序通路，它必须至少包含一条路径在本次定义路径之前不曾用过的边。</li><li>程序的环形复杂度是程序基本路径集合中的独立路径条数，这是确定路径中每个可执行语句至少被执行一次所必需的测试用例数目的上界。</li></ul></li><li><p>代码检查</p><ul><li><p>在实际使用中，静态代码检查比动态测试更有效率，更能快速找到缺陷。</p></li><li><p>静态测试包括代码检查和静态分析两种途径，它可以由人工进行，充分发挥人的逻辑优势，也可以借助软件工具自动进行。代码检查包括<strong>桌面检查、代码审查、代码走查、技术评审</strong>等。</p></li><li><p>主要检查代码的设计是否一致、代码是否遵循标准性和可读性、代码的逻辑表达的正确性，以及代码结构的合理性等。</p></li><li><p>代码评审也称代码复查，是指通过阅读代码来检查源代码与编码标准的符合性以及代码质量的活动。</p></li><li><p>代码评审的目的：</p><p>（1）确保要发布质量可靠的代码，能非常有效地发现所有类型的错误</p><p>（2）作为教学工具帮助开发人员学会何时并且如何应用技术来提高代码的质量、一致性和维护性</p></li><li><p>代码评审是发现缺陷的有效方法。代码评审包括代码审查、代码走查、桌面检查等。</p></li></ul></li><li><p>代码审查</p><ul><li><p>代码审查作为质量保证的一部分，是静态测试的主要手段之一。</p></li><li><p>代码审查的内容：</p><p>（1）编码规范问题</p><p>（2）代码结构问题</p><p>（3）工具、框架使用不当</p><p>（4）实现问题</p><p>（5）测试问题</p></li></ul></li><li><p>代码走查</p><ul><li>代码走查是以小组为单位进行代码阅读的，同样也是一系列规程和错误检查技术的集合。且代码走查也采用了持续1小时~2小时的不间断会议的形式。</li><li>代码走查的任务：就是参与者“使用计算机”。被指定为测试为人员的那个人会带着一些书面的测试用例来参加会议。且在会议期间，每个测试用例都在人们的头脑中进行推演。即把测试数据沿程序的逻辑结构走一遍，并把程序的状态记录以纸上或白板上以供监视。</li></ul></li><li><p>桌面检查</p><ul><li>桌面检查可被视为由担任进行的代码检查或代码走查：由一个人阅读程序，对照错误列表检查程序，对程序推演测试数据。</li></ul></li></ol><p>四、单元测试</p><ol><li><p>单元测试的定义</p><ul><li>单元测试又称模块测试，是最小单位的测试，其依据是详细设计规格说明书，对模块内所有重要的控制路径设计测试用例，以便发现模块内部的错误。</li><li>单元测试多采用白盒测试技术，系统内多个模块可以并行地进行单元测试</li></ul></li><li><p>单元测试的对象</p><ul><li>一般认为，在结构化程序时代，单元测试所说的单元是指函数，在面向对象编程中，单元测试的单元一般是指类。</li><li>但从实践来看，以类作为测试单位，复杂度高、可操作性较差，所以仍然主张以类中的方法作为单元测试的测试单位但可以用一个测试类来组织某个类的所有测试函数</li><li>单元测试不应过分强调面向对象，因为局部代码依然是结构化的。单元测试的工作量较大，简单、实用、高效才是硬道理，</li></ul></li><li><p>单元测试的时间</p><ul><li>单元测试当然是越早越好，通常在编码阶段进行。在源程序代码编制完成、经过评审和验证、确定没有语法错误之后，就可以了开始进行单元测试的测试用例设计</li></ul></li><li><p>单元测试的内容</p><p>（1）模块接口测试</p><p>（2）模块局部数据结构测试</p><p>（3）模块边界条件测试</p><p>（4）模块中所有数日执行通路测试</p><p>（5）模块的各条错误处理通路测试</p><p>模块接口测试是单元测试的基础。只有在数据能正确流入、流出模块的前提下，其他测试才有意义。</p></li><li><p>单元测试的过程</p><p>（1）计划单元测试：确定测试需求，制订测试策略，确定测试所用的资源，创建测试任务的时间表</p><p>（2）设计单元测试：根据单元测试计划设计单元测试模型，制订测试方案，确认测试过程，设计具体的测试用例，创建可重用的测试脚本</p><p>（3）执行单元测试：根据单元测试的方案、用例对软件单元进行测试，验证测试结果并记录测试过程中出现的缺陷</p><p>（4）评估单元测试：对单元测试的结果进行评估，主要从需求覆盖和代码覆盖的角度进行测试完备性的评估</p></li><li><p>单元测试的模型</p><p>在进行单元测试时，如果模块不是独立的程序，需要辅助测试模块，有两种辅助模块：</p><ul><li>驱动模块：所测模块的主程序。它接收测试数据，把这些数据传递给所测试模块，最后再输出测试结果。当被测试模块能完成一定功能时，也可以不要驱动模块。</li><li>桩模块：用来代替所测模块调用的子模块。被测试模块、驱动模块共同构成了一个测试模型</li></ul></li><li><p>执行单元测试</p><p>（1）设置测试环境</p><p>（2）将测试环境初始化，以确保所有构件都处于正确的初始状态</p><p>（3）执行测试过程。需要注意的是，测试过程的执行将随着具体情况而变化：测试方式是自动还是人工，以及必需的测试构件是作为驱动程序还是桩模块。自动测试的测试脚本在执行实施测试步骤的过程中创建。而人工测试则是在“构建测试过程”活动中制定的结构化测试过程。</p></li><li><p>评估单元测试</p><ul><li>测试完备性评估</li><li>代码覆盖率评估</li><li>从覆盖的角度看，。测试应该做到以下覆盖：功能覆盖、输入域覆盖、输出域覆盖、函数交互覆盖和代码执行覆盖</li></ul></li></ol><p>五、集成测试</p><ol><li><p>集成测试的定义</p><ul><li><p>集成测试又称组装测试，是在单元测试的基础上，将所有模块按照设计要求组装成子系统或系统，而进行的测试活动</p></li><li><p>集成测试的目的是确保各单元组合在一起后能够按照既定意图协作运行，并确保增量的行为正确。</p></li><li><p>它所测试内容包括单元间的接口以及集成后的功能，通常使用黑盒测试方法测试集成的功能，并且对以前的集成进行回归测试。</p></li><li><p>集成测试阶段主要检查以下几个方面：</p><p>（1）在把各个模块连接起来的时候，穿越模块接口的数据是否会丢失</p><p>（2）一个模块的功能是否会对另一个模块的功能产生不利的影响</p><p>（3）各个子功能组合起来，能否达到预期要求的父功能</p><p>（4）全局数据结构是否有问题</p><p>（5）单个模块的误差累积起来，是否会被放大，从而达到不能接受的程度</p><p>（6）在单元测试的同时可进行集成测试，发现并排除在模块连接中可能出现的问题，最终构成要求的软件系统</p></li></ul></li><li><p>集成测试的内容</p><ul><li><p>一个产品的开发过程包括了分层的设计和逐步细化的过程，从最初的产品到最小的单元，由于集成的力度不同，一般可以把集成测试划分为三个级别：</p><p>（1）模块内集成测试</p><p>（2）子系统内集成测试（模块）：先测试子系统内的功能模块（不能单独运行的程序），然后将各个功能模块组合起来确认子系统的功能是否达到预期要求</p><p>（3）子系统间集成测试（可执行程序）：测试的单元是子系统之间的接口，这里的子系统是可单独运行的程序或进程。</p></li><li><p>模块和子系统的区别：</p><ul><li>一个完整的软件系统通常包括若干个具有不同功能的子系统。而每个子系统又由多个功能模块组成。</li></ul></li></ul></li><li><p>集成测试的原则</p><p>（1）要测试所有的公共接口，尤其是那些与系统相关联的外部接口，测试的重点是要检查数据的交换、传递和控制管理过程，还包括处理的次数</p><p>（2）必须对关键模块进行充分测试。在集成的过程中应该重点关注一个系统的关键模块。在确定测试需求时，测试人员就要确定系统的关键模块，这些关键模块包含在最希望测试的那些模块中。一般我们将系统中的模块划分成3个等级：高危模块、一般模块、低危模块。一个关键模块应该具有一个或多个下列特性：</p><ul><li>和多个软件需求有关，或与关键功能有关</li><li>处于程序控制结构的顶层</li><li>本身是复杂的或者容易出错的</li><li>含有确定性的性能需求</li><li>被频繁使用的模块</li></ul><p>（3）继承测试应当按一定的层次进行。系统的模块之间是有层次关系的，就像函数之间的相互调用关系。在对系统进行集成时，要按照一定的层次顺序进行集成，避免集成过程中发生错误无法对错误进行定位。</p><p>（4）集成测试的策略选择应当综合考虑质量、成本和进度之间的关系。风险分析贯穿整个集成测试过程中，总的原则是花费最小的成本，取得最大的测试效果</p><p>（5）集成测试应当尽早开始，并以总体设计为基础</p><p>（6）在模块与接口的划分上，测试人员应当和开发人员进行充分沟通</p><p>（7）测试执行结果应当被如实记录</p></li><li><p>集成测试的策略</p><p>（1）非增量式集成策略</p><p>非增量集成，又称大爆炸式集成，采用一步到位的方法来进行集成，又称一次组装或整体拼装。使用该方法进行集成时，首先分别测试每个模块，即对每个模块都进行独立的单元测试。测试通过后，再把所有模块按设计要求组合在一起构成整体，再对这个整体进行测试。</p><p>（2）增量式集成策略</p><p>增量式集成方法又被称为渐增式组装，它的集成时逐步实现的。首先对一个个模块进行模块测试，然后按照某种策略，将这些模块逐步组装成较大的系统，在组装的过程中边连接边测试，以发现连接过程中产生的问题。通过增值逐步组装成为满足要求的软件系统。</p><ul><li><p>自顶向下的集成测试</p><p>自顶向下增量式集成就是按照模块结构图自上而下进行集成</p></li><li><p>自底向上的集成测试</p><p>自底向上的增量式集成就是按照模块结构图自底向上进行组装，首先从模块结构的底层开始，依次往高层次集成。在集成的过程中，不需要再编写桩模块，只需要为被组装模块编写驱动模块。</p></li><li><p>混合增量式集成策略</p><p>也称“三明治”集成，对软件结构中较上层，使用的是“自顶向下”集成；对软件结构中较下层，使用的是“自底向上”继承，将两种策略的优点结合在一起。</p></li></ul></li></ol><p>六、功能测试</p><ol><li><p>系统测试</p><ul><li>系统测试是通过与系统的需求规格做比较，发现软件与系统需求规格不相符或与之矛盾的地方。它将通过确认测试的软件，作为整个基于计算机系统的一个元素，与计算机硬件、外设、某些支持软件、数据和人员等其他系统元素结合起来，在实际运行（使用）环境下，对软件进行系统测试。</li><li>系统测试的依据为需求规格说明书、概要设计说明书和各种规范。通信产品与一般的软件产品不同，其系统测试往往需求依据大量的既定规范；对于海外产品，系统测试依据还包括各个国家自定的规范。</li><li>系统测试包括功能测试、性能测试、压力测试、协议一致性测试、容量测试、安全性测试、恢复性测试、备份测试、UI测试、安装和卸载测试、本地化测试、可用性测试等。</li></ul></li><li><p>功能测试</p><ul><li>功能测试又称正确性测试，就是对产品的各项功能进行验证，根据功能测试用例，逐项测试，检查产品是否达到用户要求的功能或者说检查软件的功能是否符合规格说明。由于正确性是软件最重要的质量因素，所以功能测试也非常重要。做功能测试需要首先明确业务和需求。理解了需求和业务，才知道客户想要系统实现什么。然后按照需求来进行测试，不满足要求的都可以被认为是缺陷。</li></ul></li><li><p>功能测试的策略</p><ul><li>测试需求分析</li><li>指定测试计划</li><li>测试设计和测试用例设计</li><li>测试环境搭建</li><li>测试实施</li><li>缺陷报告</li><li>回归测试</li></ul></li><li><p>功能测试的内容</p><p>功能测试包括对用户界面的测试、对各种操作的测试，对不同的数据输入、逻辑思路、数据输出、存储等的测试。不同的应用系统，功能测试的内容差异很大，但一般都可归为界面、数据、操作、逻辑、接口等几个方面，主要包括：</p><p>（1）程序安装和启动正常，有相应的提示框、适当的错误提示等</p><p>（2）每项功能符合实际要求</p><p>（3）系统的界面清晰、美观；菜单、按钮操作正常、灵活，能处理一些异常操作</p><p>（4）能接受正确的数据输入，对异常数据的输入可以进行提示、容错处理等</p><p>（5）数据的输出结果准确、格式清晰，可以保存和读取</p><p>（6）功能逻辑清楚，符合使用者习惯</p><p>（7）系统的各种状态按照业务流程而变化，并保持稳定</p><p>（8）支持各种应用的环境，能配合多种硬件周边设备，与外部应用系统的接口有效</p><p>（9）软件升级后，能够继续支持旧版本的数据</p></li></ol><p>七、性能测试</p><ol><li><p>性能测试</p><ul><li>性能测试的目的是验证软件系统是否能够达到用户要求的性能指标，同时发现软件系统中出来的性能瓶颈，最后起到优化系统的目的。</li></ul></li><li><p>性能测试的内容</p><p>具体包括以下几个方面：</p><p>（1）评估系统的能力：测试中得到的负荷和响应时间数据可以用于验证软件系统能力是否符合设计要求</p><p>（2）识别系统中的瓶颈：当系统符合被增加到极限水平并继续增加时，可以通过性能指标的变化情况监测系统的瓶颈，从而帮助系统设计者修复系统的瓶颈</p><p>（3）系统调优：重复运行测试，验证调整系统的活动得到了预期的结果，从而改进系统性能</p><p>（4）验证稳定性与可靠性：在一定的负载压力下执行测试一定时间，是评估系统稳定性和可靠性是否满足要求的有效方法</p></li><li><p>性能测试的分类</p><ul><li><p>性能测试类型包括负载测试、压力测试、强度测试、容量测试。通常，性能测试通过自动化的测试工具模拟多种正常、峰值以及异常负载条件来对系统的各项性能指标进行测试，负载测试和压力测试都属于性能测试，两者可以结合进行</p><p>（1）负载测试，是确定在各种工作负载下系统的性能，目标是测试当负载逐渐增加时，系统各项性能指标的变化情况，例如，吞吐量、响应时间、CPU负载、内存使用等，来确定系统的性能。负载测试是一个分析软件应用程序和支撑架构、模拟真实环境的使用，从而来确定能够接受的性能的过程。</p><p>（2）压力测试是通过确定一个系统的瓶颈或者不能接受的性能点，来获得系统能提供的最大服务级别的测试</p><p>（3）疲劳测试是采用系统稳定运行情况下，能够支持的最大并发用户数，持续执行一段时间业务，通过综合分析交易执行指标和资源监控指标来确定系统处理最大工作量强度性能的过程。疲劳强度测试可以采用自动化工具进行测试，也可以手工编写程序测试，其中后者占的比例较大</p><p>（4）容量测试用于确定系统可处理同时在线的最大用户数</p><p>（5）大数据量测试可以分为两种类型：针对某些系统存储、传输、统计、查询等业务进行大数据量的独立数据量测试；与压力性能测试、负载性能测试、疲劳性能测试相结合的综合数据量测试方案。大数据量测试的关键是测试数据的准备，可以依靠工具准备测试数据。</p><p>（6）速度测试目前主要针对关键的，有速度要求的业务进行手工测速度，可以在多次测试的基础上求平均值，可以和工具测试得到的响应时间等指标做对比分析。</p></li></ul></li><li><p>性能计数器</p><ul><li><p>影响一个系统性能的因素主要有：软件因素，包括系统软件、第三方软件等；硬件因素，如内存、磁盘、CPU、网卡等；网络因素，如网络吞吐量、带宽、网络传输速率等。</p></li><li><p>性能计数器是描述服务器或操作系统性能的一些数据指标。</p><p>（1）内存，内存性能计数器主要检查应用程序是否存在内存泄漏</p><p>（2）处理器，监视“处理器”和“系统”对象计数器可以提供关于处理器使用的有价值的信息，帮助测试人员决定是否存在瓶颈</p><p>（3）物理磁盘，磁盘性能</p></li></ul></li><li><p>性能测试流程</p><p>（1）性能测试的计划</p><p>（2）性能测试的设计</p><p>（3）性能测试的执行</p><p>（4）测试结果的分析</p></li></ol><p>八、本地化测试</p><ol><li><p>本地化测试的定义</p><ul><li><p>本地化测试是对软件进行本地化过程中记性的测试</p></li><li><p>所谓本地化就是将软件版本语言进行就更该。</p></li><li><p>本地化测试的对象是软件的本地化版本</p></li><li><p>本地化测试目的是测试待定目标区域设置的软件本地化质量</p></li><li><p>本地化测试的环境是在本地化的操作系统上安装本地化的软件。</p></li><li><p>从测试方法上可以分为：基本功能测试、安装或卸载测试、当地区域的软硬件兼容测试。</p></li><li><p>测试的内容主要包括软件本地化后的界面布局和软件翻译的语言质量，包含软件、文档和在线帮助等部分</p></li><li><p>本地化测试的目的首先是保证本地化的软件与源语言软件具有相同的功能和性能。其次还要保证本地化的软件在语言、文化、传统观念等方面符合当地用户的习惯。</p></li><li><p>本地化测试过程中的测试工作集中在：</p><p>（1）易受本地化影响的方面，如用户界面</p><p>（2）区域性或区域设置特定的、语言特定的和地区特定的方面</p></li></ul></li><li><p>本地化测试与其他测试的区别</p><ul><li>软件本地化测试的测试对象是本地化的软件，需要在本地化的操作系统上进行。虽然本地化的软件是基于源程序软件创建的，但与其他测试的测试内容和重点有很大不同。</li></ul></li></ol><div class="table-container"><table><thead><tr><th>不同点</th><th>描述</th></tr></thead><tbody><tr><td>测试顺序</td><td>首先要对源程序软件进行测试，然后再创建本地化软件，测试本地化软件</td></tr><tr><td>测试内容和重点</td><td>源程序软件主要测试功能和性能，结合软件界面的测试；本地化软件的测试，更注重因本地化引起的错误；例如，翻译是否正确，本地化的界面是否美观、本地化后的功能是否与源语言软件保持一致</td></tr><tr><td>测试环境</td><td>源程序软件测试通常在源语言的操作系统上进行；本地化软件在本地化的操作系统上进行</td></tr></tbody></table></div><ol><li><p>本地化测试的类型</p><p>（1）导航测试，是为了降低软件本地化的风险而进行的一种本地化测试</p><p>（2）可接受性测试，也被称为冒烟测试，是指对编译的软件本地化版本的主要特征进行基本测试，从而确定版本是否满足详细测试的条件。</p><p>（3）语言质量测试，是软件本地化测试的重要组成部分，贯穿于本地化项目的各个阶段。语言质量测试的主要内容是软件界面和在线帮助等文档的翻译质量，包括正确性，完整性，专业性和一致性。</p><p>（4）用户界面测试，也被称为外观测试，主要是对软件的界面文字和控件布局进行测试</p><p>（5）功能测试，原始语言开发的软件的功能测试主要测试软件的各项功能是否被实现以及是否正确，而本地化软件的功能测试主要是测试软件经过本地化后，软件的功能是否与源软件一致，是否存在因软件本地化而产生的功能错误</p></li><li><p>本地化软件缺陷的分类</p><ul><li><p>核心软件缺陷</p><p>（1）源语言功能缺陷</p><p>（2）源语言国际化缺陷</p></li><li><p>本地化缺陷</p><p>（1）语言质量缺陷</p><p>（2）用户界面缺陷</p><p>（3）本地化功能缺陷</p></li></ul></li><li><p>本地化测试的流程</p><p>（1）测试规划</p><p>（2）测试设计</p><p>（3）测试实施</p><p>（4）配置管理</p><p>（5）测试管理</p></li><li><p>本地化测试工程师</p><ul><li><p>基础技能</p><p>（1）安装和配置常用操作系统的知识</p><p>（2）计算机网络基础知识</p><p>（3）通用软件的使用知识</p><p>（4）良好的语言技能</p></li><li><p>专业基础知识</p><p>（1）软件本地化或国际化的基本知识</p><p>（2）软件本地化工程的基础知识</p></li><li><p>职业素质</p><p>（1）解决问题的专业态度和创新能力</p><p>（2）主动迅速学习新知识的能力</p><p>（3）执著敬业和团队合作能力</p><p>（4）良好的书面和口头交流技能</p><p>（5）承受压力的能力</p></li></ul></li></ol><p>九、软件测试管理</p><ol><li><p>缺陷生命周期</p><p>（1）新建：当缺陷被第一次递交的时候，它的状态即为“新建”。这也就是说缺陷未被确认其是否真正是一个缺陷</p><p>（2）打开：在测试者提交一个缺陷后，测试组长确认其确实为一个缺陷的时候，会把状态置为“打开”</p><p>（3）分配：一旦缺陷被测试经理置为“打开”，再把缺陷交给相应的开发人员或开发组。这时缺陷状态变更为“分配”</p><p>（4）测试：当开发人员修复缺陷后，缺陷提交给测试组进行新一轮的测试，在开发人员公布以修复缺陷的程序之前，缺陷状态被置为“测试”。这时表明缺陷已经被修复并已经提交给了测试组</p><p>（5）已确认：当缺陷被修复后就会被置为“测试”，测试员会执行测试。如果缺陷不再出现，这就证明缺陷被修复了的同时其状态被置为“已确认”</p><p>（6）延期：延期状态被置为“延期”意味着，缺陷将会在下一个版本中被修复</p><p>（7）重新打开：如果缺陷被开发人员修复后，问题仍然存在，测试人员会把缺陷状态置为“重新打开”。缺陷即将再次穿越其生命周期</p><p>（8）重复：如果同一个缺陷被重复提交或者两个缺陷表明的意思相同，那么这个缺陷状态将会被置为“重复”提交</p><p>（9）拒绝：如果开发人员不认为其实一个缺陷，会拒绝此缺陷，缺陷状态被置为“拒绝”</p><p>（10）关闭：当缺陷被修复后，测试人员会对其进行测试。如果测试人员认为缺陷不存在了，会把缺陷状态置为“关闭”，。这个状态意味着缺陷已被修复，通过了测试并且核实确实如此</p></li><li><p>缺陷报告的编写</p><p>（1）清晰地描述缺陷</p><p>（2）使用简洁的语言</p><p>（3）重现的步骤和数据</p><p>（4）提供参考信息</p><p>（5）抓屏截图</p></li><li><p>团队管理</p><p>（1）组织结构</p><ul><li>基于技能的组织模式</li><li>基于测试流程的组织模式</li><li>基于项目的组织模式</li></ul><p>（2）素质要求</p><ul><li>踏实细心和积极主动</li><li>怀疑一切</li><li>协作和团队感</li><li>自我提高和总结的能力</li></ul><p>（3）激励方法</p><ul><li>表扬和奖励</li><li>信任的力量</li><li>提高士气<ul><li>薪水</li><li>职务</li><li>工作时间</li><li>培训机会</li></ul></li></ul></li><li><p>风险管理</p><p>（1）需求风险</p><p>（2）人员风险</p><p>（3）环境风险</p><p>（4）回归风险</p><p>（5）测试资源</p><p>（6）需求变更</p><p>（7）用例质量</p><p>（8）标准差异</p><p>（9）测试工具</p></li><li><p>过程管理</p><p>（1）测试需求分析</p><ul><li>测试需求的依据与收集</li><li>测试需求的分析</li><li>测试需求的优先级</li></ul><p>（2）测试计划</p><p>（3）测试设计</p><p>（4）测试开发</p><p>（5）测试执行</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;一、软件测试基本概念&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;软件测试的定义&lt;/p&gt;
&lt;p&gt;使用人工或自动手段来运行或测试某个系统的过程，其目的在于检验它是否满足规定的需求或是否弄清预期结果与实际结果之间的差别。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;软件缺陷的定义&lt;/p&gt;
&lt;p&gt;软件
      
    
    </summary>
    
      <category term="软件测试" scheme="http://wanqbin.xyz/categories/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/"/>
    
    
      <category term="软件测试" scheme="http://wanqbin.xyz/tags/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>计算机操作系统（第四版）习题四解答</title>
    <link href="http://wanqbin.xyz/2019/06/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC%E5%9B%9B%E7%89%88%EF%BC%89%E4%B9%A0%E9%A2%98%E5%9B%9B%E8%A7%A3%E7%AD%94/"/>
    <id>http://wanqbin.xyz/2019/06/22/计算机操作系统（第四版）习题四解答/</id>
    <published>2019-06-22T13:01:00.000Z</published>
    <updated>2019-06-22T13:07:56.872Z</updated>
    
    <content type="html"><![CDATA[<ol><li><h2 id="为什么要配置层次式存储器？"><a href="#为什么要配置层次式存储器？" class="headerlink" title="为什么要配置层次式存储器？"></a>为什么要配置层次式存储器？</h2><ul><li>设置多个存储器可以使存储器两端的硬件能并行工作；</li><li>采用多级存储系统，特别是Cache技术，是减轻存储器带宽对系统性能影响的最佳结构方案；</li><li>在微处理机内部设置各种缓冲存储器，减轻对存储器存取的压力</li><li>增加CPU中寄存器数量，大大缓解翠存储器压力</li></ul></li><li><h2 id="可采用哪几种方式将程序装入内存？它们分别适用于何种场合？"><a href="#可采用哪几种方式将程序装入内存？它们分别适用于何种场合？" class="headerlink" title="可采用哪几种方式将程序装入内存？它们分别适用于何种场合？"></a>可采用哪几种方式将程序装入内存？它们分别适用于何种场合？</h2><ul><li><p>绝对装入方式</p><p>只适用于单道程序环境</p></li><li><p>可重定位装入方式</p><p>适用于多道程序环境</p></li><li><p>动态运行时装入方式</p><ul><li>用于多道程序环境</li><li>不允许程序运行时在内存中移动位置</li></ul></li></ul></li><li><h2 id="何谓静态链接？静态链接时需要解决两个什么问题？"><a href="#何谓静态链接？静态链接时需要解决两个什么问题？" class="headerlink" title="何谓静态链接？静态链接时需要解决两个什么问题？"></a>何谓静态链接？静态链接时需要解决两个什么问题？</h2><ul><li>静态链接是指在程序运行之前，先将各目标模块及它们所需的库函数链接成一个完整的装配模块，以后不再拆开。</li><li>需要解决为问题是：<ul><li>对相对地址进行修改</li><li>变换外部调用符号</li></ul></li></ul></li><li><h2 id="何谓装入时动态链接？装入时动态链接方式有何优点？"><a href="#何谓装入时动态链接？装入时动态链接方式有何优点？" class="headerlink" title="何谓装入时动态链接？装入时动态链接方式有何优点？"></a>何谓装入时动态链接？装入时动态链接方式有何优点？</h2><ul><li>装入时动态链接是指将用户源程序编译后得到的一组目标模块，在装入内存时，采用边装入边链接的链接方式。</li><li>优点：<ul><li>便于修改和更新</li><li>便于实现对目标模块的共享</li></ul></li></ul></li><li><h2 id="何谓运行时动态链接？运行时动态链接又何优点？"><a href="#何谓运行时动态链接？运行时动态链接又何优点？" class="headerlink" title="何谓运行时动态链接？运行时动态链接又何优点？"></a>何谓运行时动态链接？运行时动态链接又何优点？</h2><ul><li>运行时动态链接是将对某些模块的链接推迟到程序执行时才运行。</li><li>优点：<ul><li>加快程序的装入过程</li><li>节省大量的内存空间</li></ul></li></ul></li><li><h2 id="在动态分区分配方式中，应如何将各空闲分区链接成空闲分区链？"><a href="#在动态分区分配方式中，应如何将各空闲分区链接成空闲分区链？" class="headerlink" title="在动态分区分配方式中，应如何将各空闲分区链接成空闲分区链？"></a>在动态分区分配方式中，应如何将各空闲分区链接成空闲分区链？</h2><p>在每个分区的起始部分设置一些用于控制分区分配的信息，以及用于链接各分区所用的前向指针，在分区尾部则设置一后向指针。通过前、后向链接指针，可将所有的空闲分区链接成一个双向链。</p></li><li><h2 id="为什么要引入动态重定位？如何实现？"><a href="#为什么要引入动态重定位？如何实现？" class="headerlink" title="为什么要引入动态重定位？如何实现？"></a>为什么要引入动态重定位？如何实现？</h2><ul><li><p>在程序执行的过程中，每当访问指令或数据时，将要访问的程序或数据的逻辑地址转换成物理地址，所以引入了动态重定位。</p></li><li><p>实现方法</p><p>在系统中增设一个重定位寄存器，用它来存放程序（数据）在内存中的起始地址。程序在执行时，真正访问的内存地址是相对地址与重定位寄存器中的地址相加而形成的。</p></li></ul></li><li><h2 id="什么是基于顺序搜索的动态分区分配算法？它可分为哪几种？"><a href="#什么是基于顺序搜索的动态分区分配算法？它可分为哪几种？" class="headerlink" title="什么是基于顺序搜索的动态分区分配算法？它可分为哪几种？"></a>什么是基于顺序搜索的动态分区分配算法？它可分为哪几种？</h2><ul><li>为了实现动态分区分配，通常是将系统中的空闲分区链接成一个链。所谓顺序搜索，是指依次搜索空闲分区链上的空闲分区，去寻找一个其大小能满足要求的分区。</li><li>基于顺序搜索的动态分区分配算法可分为：<ul><li>首次适应算法</li><li>循环首次适应算法</li><li>最佳适应算法</li><li>最坏适应书房</li></ul></li></ul></li><li><h2 id="在采用首次适应算法回收内存时，可能出现哪几种情况？应怎样处理？"><a href="#在采用首次适应算法回收内存时，可能出现哪几种情况？应怎样处理？" class="headerlink" title="在采用首次适应算法回收内存时，可能出现哪几种情况？应怎样处理？"></a>在采用首次适应算法回收内存时，可能出现哪几种情况？应怎样处理？</h2><p>可能会出现四种情况：</p><ul><li>回收区与插入点前的一个分区$F_1$相邻接。将回收区与插入点的前一分区合并，不必再为回收分区分配新表项，而只需修改其前一分区$F_1$的大小</li><li>回收分区与插入点后的一空闲分区$F_2$相邻接。将两个分区合并，形成新的分区，但用回收区的首址作为新空闲区的首址，大小为两者之和</li><li>回收区同时与插入点的前、后两个分区邻接。将三个分区合并，使用$F_1$的表项和$F_1$的首址，取消$F_2$的表项，大小为三者之和。</li></ul></li><li><h2 id="什么是基于索引搜索的动态分区分配算法？它可分为哪几种？"><a href="#什么是基于索引搜索的动态分区分配算法？它可分为哪几种？" class="headerlink" title="什么是基于索引搜索的动态分区分配算法？它可分为哪几种？"></a>什么是基于索引搜索的动态分区分配算法？它可分为哪几种？</h2><ul><li>基于顺序搜索的动态分区分配算法，比较适用于不太大的系统。当系统很大时，系统中的内存分区可能会很多，相应的空闲分区链就很长，这是采用顺序搜索方法可能会很慢。为了提高搜索空闲分区的速度，在大、中型系统中往往会采用基于索引搜索的动态分区分配算法。</li><li>基于索引搜索的动态分区分配算法可分为：<ul><li>快速适应算法</li><li>伙伴系统</li><li>哈希算法</li></ul></li></ul></li><li><h2 id="令-buddy-k-x-为大小为-2-k-、地址为x的块的伙伴系统地址，试写出-buddy-k-x-的通用表达式"><a href="#令-buddy-k-x-为大小为-2-k-、地址为x的块的伙伴系统地址，试写出-buddy-k-x-的通用表达式" class="headerlink" title="令$buddy_k$(x)为大小为$2^k$、地址为x的块的伙伴系统地址，试写出$buddy_k$(x)的通用表达式"></a>令$buddy_k$(x)为大小为$2^k$、地址为x的块的伙伴系统地址，试写出$buddy_k$(x)的通用表达式</h2><p><img src="/2019/06/22/计算机操作系统（第四版）习题四解答/11.png" alt="题解"></p></li><li><h2 id="分区存储管理中常用哪些分配策略？比较它们的优缺点？"><a href="#分区存储管理中常用哪些分配策略？比较它们的优缺点？" class="headerlink" title="分区存储管理中常用哪些分配策略？比较它们的优缺点？"></a>分区存储管理中常用哪些分配策略？比较它们的优缺点？</h2><ul><li>首次适应算法<ul><li>保留了高址部分的大空闲区，有利于后来的大型作业分配</li><li>地址部分不断被划分，留下很多难以利用的小空闲区，每次查找都从地址开始增加了系统开销</li></ul></li><li>循环首次适应算法<ul><li>内存空闲分区分布均匀，减少了查找系统开销</li><li>缺乏大空闲分区，导致不能装入大型作业</li></ul></li><li>最佳适应算法<ul><li>每次分配给文件的都是最合适该文件大小的分区，内存中留下了很多难以利用的小空闲区</li></ul></li><li>最坏适应算法<ul><li>剩下空闲分区不至于太小，产生碎片的可能性最小，对中、小型作业有利</li><li>存储器中缺乏大空闲区，对大型文件分区分配不利</li><li>查找效率很高</li></ul></li></ul></li><li><h2 id="为什么要引入对换？对换可分为哪几种类型？"><a href="#为什么要引入对换？对换可分为哪几种类型？" class="headerlink" title="为什么要引入对换？对换可分为哪几种类型？"></a>为什么要引入对换？对换可分为哪几种类型？</h2><ul><li>在多道程序环境下，一方面，在内存中的某些进程由于某花时间尚未发生而被阻塞运行，但它却占用了大量的内存空间，甚至有时有可能出现在内存中所有进程都被阻塞，而没有可以运行的进程，另一方面，却有着很多作业，因两次了空间不足，一直驻留在外存上，而不能进入内存运行。为了解决这一问题，系统引入了对换。<ul><li>对换的类型<ul><li>整体对换</li><li>页面（分段）对换</li></ul></li></ul></li></ul></li><li><h2 id="对文件区管理的目标和对对换空间管理的目标有何不同？"><a href="#对文件区管理的目标和对对换空间管理的目标有何不同？" class="headerlink" title="对文件区管理的目标和对对换空间管理的目标有何不同？"></a>对文件区管理的目标和对对换空间管理的目标有何不同？</h2><ul><li><p>对文件区管理的主要目标：</p><p>提高文件存储空间的利用率，然后才是提高对文件的访问速度。因此，对文件区空间的管理采取离散分配方式</p></li><li><p>对对换空间管理的目标：</p><p>提高进程换入和换出的速度，然后才是提高文件存储空间的利用率。为此，对对换空间的管理采取连续分配方式，较少考虑外存中的碎片问题</p></li></ul></li><li><h2 id="为实现对换，系统应具备哪几方面的功能？"><a href="#为实现对换，系统应具备哪几方面的功能？" class="headerlink" title="为实现对换，系统应具备哪几方面的功能？"></a>为实现对换，系统应具备哪几方面的功能？</h2><ul><li>对换空间管理</li><li>进程换入</li><li>进程换出</li></ul></li><li><h2 id="在以进程为单位进行对换时，每次是否都将整个进程换出？为什么？"><a href="#在以进程为单位进行对换时，每次是否都将整个进程换出？为什么？" class="headerlink" title="在以进程为单位进行对换时，每次是否都将整个进程换出？为什么？"></a>在以进程为单位进行对换时，每次是否都将整个进程换出？为什么？</h2><p>在以进程为单位进行对换时，并非每次都将整个进程换出，这是因为：</p><ul><li>从结构上讲，进程是由程序段、数据段和进程控制块组成的，其中进程控制块中总有部分或全部常驻内存，不被换出</li><li>程序段和数据段可能正在被若干进程共享，此时它们也不能换出</li></ul></li><li><h2 id="基于离散分配时所用的基本单位不同，可将离散分配分为哪几种？"><a href="#基于离散分配时所用的基本单位不同，可将离散分配分为哪几种？" class="headerlink" title="基于离散分配时所用的基本单位不同，可将离散分配分为哪几种？"></a>基于离散分配时所用的基本单位不同，可将离散分配分为哪几种？</h2><ul><li>分页存储管理方式</li><li>分段存储管理方式</li><li>段页式存储管理方式</li></ul></li><li><h2 id="什么是页面？什么是物理块？页面的大小应如何确定？"><a href="#什么是页面？什么是物理块？页面的大小应如何确定？" class="headerlink" title="什么是页面？什么是物理块？页面的大小应如何确定？"></a>什么是页面？什么是物理块？页面的大小应如何确定？</h2><ul><li>页面。分页存储管理将进程的逻辑地址空间分为若干个页，并为各页加以编号。</li><li>物理块：将内存中的物理地址空间分层若干个块</li><li>在分页系统中，若选择过小的页面大小，虽然一方面可以减轻碎片，起到减少内存碎片总空间的作用，有利于内存利用率的提高，但另一方面却会造成每个进程占用较多的页面，从而导致进程的页表过长，占用大量内存。此外，还会降低换进换出的效率。然而，页面选择过大，虽然可以减少页表的长度，提高页面换进换出的速度，但却又会使页内碎片增大。因此，页面的大小应选择适中，且页面大小应是2的幂，通常为1KB-8KB。</li></ul></li><li><h2 id="什么是页表？页表的作用是什么？"><a href="#什么是页表？页表的作用是什么？" class="headerlink" title="什么是页表？页表的作用是什么？"></a>什么是页表？页表的作用是什么？</h2><ul><li>在分页系统中，允许将进程的各个页面离散地存储在内存的任一地址块中，为了保证进程仍然能够正确地运行，即能在内存中找到每个页面所对应的物理块，系统又为每个进程建立了一张页面映像表，简称页表。</li><li>页表的作用是实现从页号到物理块号的地址映射</li></ul></li><li><h2 id="为实现分页存储管理，需要哪些硬件支持？"><a href="#为实现分页存储管理，需要哪些硬件支持？" class="headerlink" title="为实现分页存储管理，需要哪些硬件支持？"></a>为实现分页存储管理，需要哪些硬件支持？</h2><ul><li>页表寄存器</li><li>地址变换机构</li><li>联想寄存器</li></ul></li><li><h2 id="在分页系统中是如何实现地址变换的？"><a href="#在分页系统中是如何实现地址变换的？" class="headerlink" title="在分页系统中是如何实现地址变换的？"></a>在分页系统中是如何实现地址变换的？</h2><p>&emsp;&emsp;当进程要访问某个逻辑地址中的数据时，分页地址变换机构会自动地将有效地址分为页号和页内地址两部分，再以页号为索引去检索页表。查找操作由硬件执行。在执行检索之前，先将页号与页表长度进行比较，如果页号大于或等于页表长度，则表示本次所访问的地址已超越进程的地址空间。于是，这一错误将被系统发现，并产生一地址越界中断。</p><p>&emsp;&emsp;若未出现越界错误，则将页表始址与页号和页表项长度的乘积相加，便得到该表项在页表中的位置，于是可从中得到该页的物理块号，将之装入物理地址寄存器中。与此同时，再将有效地址寄存器中的页内地址送入物理地址寄存器的块内地址字段中。这样便完成了从逻辑地址到物理地址的变换。</p></li><li><h2 id="具有快表时是如何实现地址变换的？"><a href="#具有快表时是如何实现地址变换的？" class="headerlink" title="具有快表时是如何实现地址变换的？"></a>具有快表时是如何实现地址变换的？</h2><p>&emsp;&emsp;在CPU给出有效地址后，由地址变换机构自动地将页号P送入高速缓冲寄存器，并将此页号与高速缓存中的所有页号进行比较，若其中有与此相匹配的页号，便表示所要访问的页表项在快表中。于是，可直接从快表中读出该页所对应的物理块号，并送到物理地址寄存器中。</p><p>&emsp;&emsp;若在快表中未找到对应的页表项，则还须再访问内存中的页表，找到后，把从页表项中读出的物理块号送往地址寄存器；同时，再将此页表项存入快表的一个寄存器单元中。但如果联想寄存器已满，则OS必须找到一个老的且已被认为是不再需要的页表项，将它换出。</p></li><li><h2 id="较详细地说明引入分段存储管理是为了满足用户哪几方面的需要。"><a href="#较详细地说明引入分段存储管理是为了满足用户哪几方面的需要。" class="headerlink" title="较详细地说明引入分段存储管理是为了满足用户哪几方面的需要。"></a>较详细地说明引入分段存储管理是为了满足用户哪几方面的需要。</h2><ul><li>方便编程。用户通常把自己的作业按照逻辑关系划分为若干段，每段都从0 编址，并有自己名字和长度。因此，希望要访问的逻辑地址是由段名和段内偏移量决定。</li><li>信息共享。在实现对程序和数据的共享时，是以信息逻辑单位为基础。分页系统中的页是存放信息的物理单位，无完整意义，不便于共享；段是信息的逻辑单位。为了实现段的共享，希望存储管理能与用户程序分段的组织方式相适应。</li><li>信息保护。对信息的逻辑单位进行保护，分段能更有效方便地实现信息保护功能。</li><li>动态增长。在实际应用中，有些段特别是数据段，在使用过程中会不断增长，事先又无法确切知道增长多少。分段存储管理方式能较好解决这个问题。</li><li>动态链接。运行时先将主程序对应的目标程序装入内存并启动运行，运行过程中又需要调用某段时，才将该段调入内存链接。所以动态链接也要求以段作为管理单位。</li></ul></li><li><h2 id="在具有快表的段页式存储管理方式中，如何实现地址变换？"><a href="#在具有快表的段页式存储管理方式中，如何实现地址变换？" class="headerlink" title="在具有快表的段页式存储管理方式中，如何实现地址变换？"></a>在具有快表的段页式存储管理方式中，如何实现地址变换？</h2><p>&emsp;在CPU给出有效地址后，由地址变换机构自动地将页号P送入高速缓冲寄存器，并将此页号与高速缓存中的所有页号进行比较，若其中有与此相匹配的页号，便表示所要访问的页表项在快表中。于是，可直接从快表中读出该页所对应的物理块号，并送到物理地址寄存器中。</p><p>&emsp;&emsp;若在快表中未找到对应的页表项，则还须再访问内存中的页表，找到后，把从页表项中读出的物理块号送往地址寄存器；同时，再将此页表项存入快表的一个寄存器单元中。但如果联想寄存器已满，则OS必须找到一个老的且已被认为是不再需要的页表项，将它换出。</p></li><li><h2 id="为什么说分段系统比分页系统更易于实现信息的共享和保护？"><a href="#为什么说分段系统比分页系统更易于实现信息的共享和保护？" class="headerlink" title="为什么说分段系统比分页系统更易于实现信息的共享和保护？"></a>为什么说分段系统比分页系统更易于实现信息的共享和保护？</h2><ul><li>分页系统的每个页面是分散存储的，为了实现信息共享和保护，页面之间需要一一对应，为此需要建立大量的页表项；</li><li>而分段系统的每个段都从0 编址，并采用一段连续的地址空间，在实现共享和保护时，只需为要共享和保护的程序设置一个段表项，将其中的基址与内存地址一一对应就能够实现。</li></ul></li><li><h2 id="分页和分段存储管理有何区别？"><a href="#分页和分段存储管理有何区别？" class="headerlink" title="分页和分段存储管理有何区别？"></a>分页和分段存储管理有何区别？</h2><ul><li>页是信息的物理单位。采用分页存储管理方式是为了实现离散分配方式，以消减内存的外零头，提高内存的利用率。段则是信息的逻辑单位，它通常包含的是一组意义相对完整的信息。分段的目的主要在于能更好地满足用户的需要。</li><li>页的大小固定且由系统决定。在采用分页存储管理方式的系统中，在硬件结构上就把用户程序的逻辑地址划分为页号和页内地址两部分。而段的长度却是不固定的，决定于用户所编写的程序，通常由编译程序在对源程序进行编译时，根据信息的性质来划分</li><li>分页的用户程序地址空间是一维的。分页完全是系统的行为，故在分页系统中，用户程序的地址是属于单一的线性地址空间。而段式用户的行为，故在分段系统中，用户程序的地址空间是二维的。</li></ul></li><li><h2 id="试全面比较连续分配和离散分配方式"><a href="#试全面比较连续分配和离散分配方式" class="headerlink" title="试全面比较连续分配和离散分配方式"></a>试全面比较连续分配和离散分配方式</h2><ul><li>连续分配是指为一个用户程序分配一个连续的地址空间，包括单一和分区两种分配方式。单一方式将内存分为系统区和用户区，最简单且只用于单用户单任务操作系统：分区方式分为固定分区和动态分区。</li><li>离散分配方式分为分页、分段和段页式存储管理。分页式存储管理旨在提高内存利用率，分段时存储管理旨在满足用户的需要，段页式存储管理则是将两者结合起来，具有分段系统便于实现、可分享、易于保护和动态链接等优点，又能像分页系统一样，很好地解决外部碎片及为各段可离散分配内存等问题，是比较有效的存储管理方式。</li></ul></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;&lt;h2 id=&quot;为什么要配置层次式存储器？&quot;&gt;&lt;a href=&quot;#为什么要配置层次式存储器？&quot; class=&quot;headerlink&quot; title=&quot;为什么要配置层次式存储器？&quot;&gt;&lt;/a&gt;为什么要配置层次式存储器？&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;设置多个存储器可以使存
      
    
    </summary>
    
      <category term="操作系统" scheme="http://wanqbin.xyz/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="习题解答" scheme="http://wanqbin.xyz/tags/%E4%B9%A0%E9%A2%98%E8%A7%A3%E7%AD%94/"/>
    
      <category term="存储器管理" scheme="http://wanqbin.xyz/tags/%E5%AD%98%E5%82%A8%E5%99%A8%E7%AE%A1%E7%90%86/"/>
    
      <category term="对换" scheme="http://wanqbin.xyz/tags/%E5%AF%B9%E6%8D%A2/"/>
    
      <category term="分页存储管理方式" scheme="http://wanqbin.xyz/tags/%E5%88%86%E9%A1%B5%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86%E6%96%B9%E5%BC%8F/"/>
    
      <category term="分段存储管理方式" scheme="http://wanqbin.xyz/tags/%E5%88%86%E6%AE%B5%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86%E6%96%B9%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>计算机操作系统（第四版）习题二解答</title>
    <link href="http://wanqbin.xyz/2019/06/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC%E5%9B%9B%E7%89%88%EF%BC%89%E4%B9%A0%E9%A2%98%E4%BA%8C%E8%A7%A3%E7%AD%94/"/>
    <id>http://wanqbin.xyz/2019/06/20/计算机操作系统（第四版）习题二解答/</id>
    <published>2019-06-19T22:54:00.000Z</published>
    <updated>2019-06-19T22:57:04.671Z</updated>
    
    <content type="html"><![CDATA[<ol><li><h4 id="为什么程序并发执行会产生间断性特征？"><a href="#为什么程序并发执行会产生间断性特征？" class="headerlink" title="为什么程序并发执行会产生间断性特征？"></a>为什么程序并发执行会产生间断性特征？</h4><p>程序在并发执行时，由于它们共享系统管理资源，以及为万分同一项任务而相互合作，致使在这些并发执行的程序之间形成了相互制约的关系，而相互制约将导致程序具有“执行——暂停——执行”这种间断性的活动规律，所以说程序并发执行会产生间断性特征。                                                                                                                                                   </p></li><li><h4 id="程序并发执行时为什么会失去封闭性和可再现性？"><a href="#程序并发执行时为什么会失去封闭性和可再现性？" class="headerlink" title="程序并发执行时为什么会失去封闭性和可再现性？"></a>程序并发执行时为什么会失去封闭性和可再现性？</h4><p>当系统中存在着多个可以并发执行的程序时，系统中的各种资源将为它们所共享，而这些资源的状态也由这些程序来改变，致使其中任一程序在运行时，其环境都必然会受到其他程序的影响，显然，程序的运行已失去了封闭性。而失去封闭性会导致程序失去可再现性。</p></li><li><h4 id="在操作系统中为什么要引入进程的概念？它会产生什么样的影响"><a href="#在操作系统中为什么要引入进程的概念？它会产生什么样的影响" class="headerlink" title="在操作系统中为什么要引入进程的概念？它会产生什么样的影响?"></a>在操作系统中为什么要引入进程的概念？它会产生什么样的影响?</h4><p>在多道程序环境下，程序的执行属于并发执行，此时它们失去其封闭性，并且具有间断性，以及其运行结果不可再现。这些决定了通常的程序是不能参与并发执行的，否则，程序的运行也就失去了意义。<code>为了能使程序并发执行，并且可以对并发执行的程序加以描述和控制，才操作系统中引入了进程概念.</code></p></li><li><h4 id="试从动态性、并发性和独立性上比较进程和程序"><a href="#试从动态性、并发性和独立性上比较进程和程序" class="headerlink" title="试从动态性、并发性和独立性上比较进程和程序"></a>试从动态性、并发性和独立性上比较进程和程序</h4><p>进程和程序是两个截然不同的概念。</p><ul><li>动态性。进程的实质是进程实体的执行过程，因此，<code>动态性是进程的最基本的特征</code>。表现为“由创建而产生，由调度而执行，由撤销而消亡”，<code>进程具有一定的生命期</code>；而程序则只是一组有序指令的集合，并存放于某种介质上，其本身并不具有活动的含义，是静态实体。</li><li>并发性是进程的重要特征，同时也是OS的重要特征；而<code>程序是不能参与并发执行的</code>。</li><li>独立性是指进程实体是一个能独立运行、独立获得资源和独立接受调度的基本单位（传统OS中）；而对于未建立PCB的程序来说，它不能作为一个独立单位参与运行。</li></ul></li><li><h4 id="试说明PCB的作用具体表现在哪几个方面，为什么说PCB是进程存在的唯一标志？"><a href="#试说明PCB的作用具体表现在哪几个方面，为什么说PCB是进程存在的唯一标志？" class="headerlink" title="试说明PCB的作用具体表现在哪几个方面，为什么说PCB是进程存在的唯一标志？"></a>试说明PCB的作用具体表现在哪几个方面，为什么说PCB是进程存在的唯一标志？</h4><p>PCB作为进程实体的一部分，记录了操作系统所需的，用于描述进程当前情况以及管理进程运行的全部信息，是操作系统中最重要的<code>记录型数据结构</code>。</p><p>作用是使一个在多道陈存储环境下不能独立运行的程序（包括数据）成为一个能独立运行的基本单位，一个能与其他进程并发执行的进程。</p><p>当一个程序（含数据）配置了PCB后，就表示它已是一个能在多道程序环境下独立运行的、合法的基本单位，也就具有取得OS服务的权利。系统时通过PCB感知进程的存在的，所以，PCB已成为进程存在的唯一标志。</p></li><li><h4 id="PCB提供了进程管理和进程调度所需要的哪些信息？"><a href="#PCB提供了进程管理和进程调度所需要的哪些信息？" class="headerlink" title="PCB提供了进程管理和进程调度所需要的哪些信息？"></a>PCB提供了进程管理和进程调度所需要的哪些信息？</h4><ul><li>进程标识符</li><li>处理机状态</li><li>进程调度信息<ul><li>进程状态</li><li>进程优先级</li><li>进程调度所需的其他信息</li><li>事件</li></ul></li><li>进程控制信息<ul><li>程序和数据的地址</li><li>进程同步和通信机制</li><li>资源清单</li><li>链接指针</li></ul></li></ul></li><li><h4 id="进程控制块的组织方式有哪几种？"><a href="#进程控制块的组织方式有哪几种？" class="headerlink" title="进程控制块的组织方式有哪几种？"></a>进程控制块的组织方式有哪几种？</h4><ul><li>线性方式</li><li>链接方式</li><li>索引方式</li></ul></li><li><h4 id="何谓操作系统内核？内核的主要功能是是什么？"><a href="#何谓操作系统内核？内核的主要功能是是什么？" class="headerlink" title="何谓操作系统内核？内核的主要功能是是什么？"></a>何谓操作系统内核？内核的主要功能是是什么？</h4><p>现代操作系统一般将OS划分为若干层次，再将OS的不同功能分别设置在不同的层次中。</p><p>通常将一些与硬件紧密相关的模块、各种常用设备的驱动程序以及运行频率较高的模块，都安排在紧靠硬件的软件层次，让它们常驻内存，即OS内核。</p><p>OS内核的功能主要是以下两大方面：</p><ul><li>支撑功能<ul><li>中断处理</li><li>时钟管理</li><li>原语操作</li></ul></li><li>资源管理功能<ul><li>进程管理</li><li>存储器管理</li><li>设备管理</li></ul></li></ul></li><li><h4 id="试说明进程在三个基本状态之间转换的典型原因"><a href="#试说明进程在三个基本状态之间转换的典型原因" class="headerlink" title="试说明进程在三个基本状态之间转换的典型原因"></a>试说明进程在三个基本状态之间转换的典型原因</h4><ul><li>执行状态$\rightarrow$就绪状态：时间片完</li><li>就绪状态$\rightarrow$执行状态：进程调度</li><li>执行状态$\rightarrow$阻塞状态：I/O请求</li><li>阻塞状态$\rightarrow$就绪状态：I/O完成</li></ul></li><li><h4 id="为什么要引入挂起状态？该状态有哪些性质？"><a href="#为什么要引入挂起状态？该状态有哪些性质？" class="headerlink" title="为什么要引入挂起状态？该状态有哪些性质？"></a>为什么要引入挂起状态？该状态有哪些性质？</h4><p>引入挂起的原因，是基于系统和用户的如下需要：</p><ul><li>终端用户的需要</li><li>父进程请求</li><li>负荷调节的需要</li><li>操作系统的需求</li></ul><p>挂起状态的性质是：放弃CPU调度，不接受调度。引入挂起状态后，进程状态转换图增加了活动阻塞、静止阻塞、活动就绪、静止就绪四个状态，并增加了活动就绪与静止就绪，活动阻塞和静止阻塞之间的相互转换。</p></li><li><h4 id="在进行进程切换时，所要保存的处理机状态信息有哪些？"><a href="#在进行进程切换时，所要保存的处理机状态信息有哪些？" class="headerlink" title="在进行进程切换时，所要保存的处理机状态信息有哪些？"></a>在进行进程切换时，所要保存的处理机状态信息有哪些？</h4><p>进程进行切换时，需要保存的处理机状态信息有：</p><ul><li>进程当前暂存信息</li><li>下一指令地址信息</li><li>进程状态信息</li><li>过程和系统调用参数及调用地址信息</li></ul></li><li><h4 id="试说明引起进程创建的主要事件"><a href="#试说明引起进程创建的主要事件" class="headerlink" title="试说明引起进程创建的主要事件"></a>试说明引起进程创建的主要事件</h4><ul><li>用户登录</li><li>作业调度</li><li>提供服务</li><li>应用请求</li></ul></li><li><h4 id="试说明引起进程被撤销的主要事件"><a href="#试说明引起进程被撤销的主要事件" class="headerlink" title="试说明引起进程被撤销的主要事件"></a>试说明引起进程被撤销的主要事件</h4><ul><li>正常结束</li><li>异常结束<ul><li>越界错</li><li>保护错</li><li>非法指令</li><li>特权指令错</li><li>运行超时</li><li>等待超时</li><li>算术运算错</li><li>I/O故障</li></ul></li><li>外界干预</li></ul></li><li><h4 id="在创建一个进程时所要完成的主要工作是什么？"><a href="#在创建一个进程时所要完成的主要工作是什么？" class="headerlink" title="在创建一个进程时所要完成的主要工作是什么？"></a>在创建一个进程时所要完成的主要工作是什么？</h4><p>在系统中每当出现了创建新进程的请求后，OS便调用进程创建原语Create按下述步骤创建一个新进程：</p><ul><li>申请空白PCB</li><li>为新进程分配运行所需的资源</li><li>初始化进程控制块</li><li>如果进程就绪队列能够接纳新进程，便将新进程插入就绪队列</li></ul></li><li><h4 id="在撤销一个进程时所要完成的主要工作是什么？"><a href="#在撤销一个进程时所要完成的主要工作是什么？" class="headerlink" title="在撤销一个进程时所要完成的主要工作是什么？"></a>在撤销一个进程时所要完成的主要工作是什么？</h4><p>如果系统中发生了要求终止进程的某事件，OS便调用进程终止原语，按下述过程去终止指定的进程：</p><ul><li>根据被终止进程的标识符，从PCB集合中检索出该进程的PCB，从中读出该进程的状态</li><li>若被终止形成正处于执行状态，应立即终止该进程的执行，并置调度标志为真，用于指示该进程被终止后应重新进行调度</li><li>若该进程还有子孙进程，还应将其所有子孙进程也都予以终止，以防它们成为不可控进程</li><li>将被终止进程所拥有的全部资源或者归还给其父进程，或者归还给系统</li><li>将被终止进程（PCB）从所在队列（或链表）移除，等待其他程序来搜集信息</li></ul></li><li><h4 id="试说明引起进程阻塞或被唤醒的主要事件是什么？"><a href="#试说明引起进程阻塞或被唤醒的主要事件是什么？" class="headerlink" title="试说明引起进程阻塞或被唤醒的主要事件是什么？"></a>试说明引起进程阻塞或被唤醒的主要事件是什么？</h4><ul><li>向系统请求共享资源失败</li><li>等待某种操作完成</li><li>新数据尚未到达</li><li>等待新任务的到达</li></ul></li><li><h4 id="为什么要在OS中引入线程？"><a href="#为什么要在OS中引入线程？" class="headerlink" title="为什么要在OS中引入线程？"></a>为什么要在OS中引入线程？</h4><p>在OS中引入线程，是为了减少程序在并发执行时所付出的时空开销，使OS具有更好的并发性。</p></li><li><h4 id="试说明线程具有哪些属性？"><a href="#试说明线程具有哪些属性？" class="headerlink" title="试说明线程具有哪些属性？"></a>试说明线程具有哪些属性？</h4><ul><li>轻型进程</li><li>调度的基本单位</li><li>并发性</li><li>拥有资源</li><li>独立性</li><li>系统开销</li><li>支持多处理机系统</li></ul></li><li><h4 id="试从调度性、并发性、拥有资源及系统开销方面对进程和线程进行比较"><a href="#试从调度性、并发性、拥有资源及系统开销方面对进程和线程进行比较" class="headerlink" title="试从调度性、并发性、拥有资源及系统开销方面对进程和线程进行比较"></a>试从调度性、并发性、拥有资源及系统开销方面对进程和线程进行比较</h4><ul><li><p>调度性</p><ul><li>在传统的OS中，进程是作为独立调度和分派的基本单位，因而进程是能独立运行的基本单位。在每次调度时，都需要进行上下文切换，开销较大。</li><li>在引入线程的OS中，已把线程作为调度和分派的基本单位，因而线程是能独立运行的基本单位。当线程切换时，仅需要保存和设置少量寄存器内容，切换代价远低于进程。在同一进程中，线程的切换不会引起进程的切换，但从一个进程中的线程切换到另一个进程中的线程时，必然会引起进程的切换</li></ul></li><li><p>并发性</p><p>在引入线程的OS中，不仅进程之间可以并发执行，而且在一个进程的多个线程之间亦可并发执行，甚至允许在一个进程中的所有线程都能并发执行。同样，不同进程中的线程也能并发执行。</p></li><li><p>拥有资源</p><ul><li>进程可以拥有资源，并作为系统中拥有资源的一个基本单位。然而，线程本身并不拥有系统资源，而是仅有一点必不可少的、能保证独立运行的资源</li><li>线程除了拥有自己的少量资源外，还云溪多个线程共享该进程拥有的资源。</li></ul></li><li><p>系统开销</p><p>在创建或撤销进程时，系统都要为之分配和回收进程控制块、分配或回收其他资源。OS为此所付出的开销，明显大于线程创建或撤销时所付出的开销。类似地，在进程切换时，涉及到进程上下文的切换，而线程的切换代价也远低于进程的。</p></li></ul></li><li><h4 id="线程控制块TCB中包含了哪些内容？"><a href="#线程控制块TCB中包含了哪些内容？" class="headerlink" title="线程控制块TCB中包含了哪些内容？"></a>线程控制块TCB中包含了哪些内容？</h4><ul><li>线程标识符</li><li>一组寄存器</li><li>线程运行状态</li><li>优先级</li><li>线程专有存储区</li><li>信号屏蔽</li><li>堆栈指针</li></ul></li><li><h4 id="何谓用户级线程和内核支持线程？"><a href="#何谓用户级线程和内核支持线程？" class="headerlink" title="何谓用户级线程和内核支持线程？"></a>何谓用户级线程和内核支持线程？</h4><ul><li>用户级线程：用户级线程是在用户空间中实现的。对线程的创建、撤销、同步与通信等功能，都无需内核的支持，即用户级线程是与内核无关的。</li><li>内核支持线程：是在内核的支持下运行的，它们的创建、阻塞、撤销和切换等，都是在内核空间实现的</li></ul></li><li><h4 id="试说明用户级线程的实现方法"><a href="#试说明用户级线程的实现方法" class="headerlink" title="试说明用户级线程的实现方法"></a>试说明用户级线程的实现方法</h4><p>用户级线程是在用户空间中的实现的，运行在“运行时系统”与“内核控制线程”的中间系统上。运行时系统用于管理和控制线程的函数的集合。内核控制线程或轻型进程LWP可通过系统调用获得内核提供服务，利用LWP进程作为中间系统。</p></li><li><h4 id="试说明内核支持线程的实现方法"><a href="#试说明内核支持线程的实现方法" class="headerlink" title="试说明内核支持线程的实现方法"></a>试说明内核支持线程的实现方法</h4><p>系统在创建一个新进程时，便为它分配一个任务数据区PTDA，其中包括若干个线程控制块TCB空间。在每个TCB中可保存线程标识符、优先级、线程运行的CPU状态信息。每当进程要创建一个线程时，便为新线程分配一个TCB，将相关信息填入该TCB中，并为之分配必要的资源；当PTDA中的所有TCB空间已用完，而进程又要创建新的线程时，只要其所创建的线程数目未超过系统允许值，系统可再为之分配新的TCB空间；在撤销一个线程时，也应回收该线程的所有资源和TCB。</p></li><li><h4 id="多线程模型有哪几种类型？多对一模型有何优缺点？"><a href="#多线程模型有哪几种类型？多对一模型有何优缺点？" class="headerlink" title="多线程模型有哪几种类型？多对一模型有何优缺点？"></a>多线程模型有哪几种类型？多对一模型有何优缺点？</h4><p>由于用户级线程和内核级线程连接方式的不同，从而形成了三种不同的模型：</p><ul><li>多对一模型</li><li>一对一模型</li><li>多对多模型</li></ul><p>多对一模型的优点：</p><ul><li>线程管理的开销小，效率高</li></ul><p>多对一模型的缺点：</p><ul><li>如果一个线程在访问内核时发生阻塞，则整个进程都会被阻塞</li><li>在任一时刻，只有一个线程能访问内核，多个线程不能同时在多个处理机上运行</li></ul></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;&lt;h4 id=&quot;为什么程序并发执行会产生间断性特征？&quot;&gt;&lt;a href=&quot;#为什么程序并发执行会产生间断性特征？&quot; class=&quot;headerlink&quot; title=&quot;为什么程序并发执行会产生间断性特征？&quot;&gt;&lt;/a&gt;为什么程序并发执行会产生间断性特征？&lt;/h4&gt;
      
    
    </summary>
    
      <category term="操作系统" scheme="http://wanqbin.xyz/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="习题解答" scheme="http://wanqbin.xyz/tags/%E4%B9%A0%E9%A2%98%E8%A7%A3%E7%AD%94/"/>
    
      <category term="线程" scheme="http://wanqbin.xyz/tags/%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="进程" scheme="http://wanqbin.xyz/tags/%E8%BF%9B%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>ASP.NET Core MVC 视图与控制器传值</title>
    <link href="http://wanqbin.xyz/2019/06/17/%E8%A7%86%E5%9B%BE%E4%B8%8E%E6%8E%A7%E5%88%B6%E5%99%A8%E4%BC%A0%E5%80%BC/"/>
    <id>http://wanqbin.xyz/2019/06/17/视图与控制器传值/</id>
    <published>2019-06-16T23:49:00.000Z</published>
    <updated>2019-06-17T10:39:25.196Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、form表单传值"><a href="#一、form表单传值" class="headerlink" title="一、form表单传值"></a>一、form表单传值</h2><ol><li><h4 id="View页面：GetFormValue-cshtml"><a href="#View页面：GetFormValue-cshtml" class="headerlink" title="View页面：GetFormValue.cshtml"></a>View页面：GetFormValue.cshtml</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>GetFormValue<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">asp-action</span>=<span class="string">"Home/GetFormValue"</span> <span class="attr">method</span>=<span class="string">"post"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">placeholder</span>=<span class="string">"名字"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">"submit"</span> <span class="attr">type</span>=<span class="string">"submit"</span>&gt;</span>提交<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在这个form表单中，用<code>asp-action=&quot;Home/GetFormValue&quot;</code>指定了表单中的值需要传到什么地方，其中<code>Home</code>代表控制器，<code>GetFromValue</code>代表Action。</p></li><li><h4 id="Action-GetFormValue"><a href="#Action-GetFormValue" class="headerlink" title="Action: GetFormValue"></a>Action: GetFormValue</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public IActionResult GetFormValue()</span><br><span class="line">        &#123;</span><br><span class="line">            return View();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        [HttpPost]</span><br><span class="line">        public IActionResult GetFormValue(string name)</span><br><span class="line">        &#123;</span><br><span class="line">            return View();</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p><code>GetFormValue</code>用来接受从视图传过来的值，这次传的是名字。</p></li><li><h4 id="页面输入"><a href="#页面输入" class="headerlink" title="页面输入"></a>页面输入</h4><p><img src="/2019/06/17/视图与控制器传值/2019061701.PNG" alt="Form表单传值"></p></li><li><h4 id="传值结果"><a href="#传值结果" class="headerlink" title="传值结果"></a>传值结果</h4><p><img src="/2019/06/17/视图与控制器传值/201906170102.PNG" alt="Form表单传值结果"></p></li></ol><h2 id="二、JS传值"><a href="#二、JS传值" class="headerlink" title="二、JS传值"></a>二、JS传值</h2><ol><li><h4 id="视图页面：GetJsValue-cshtml"><a href="#视图页面：GetJsValue-cshtml" class="headerlink" title="视图页面：GetJsValue.cshtml"></a>视图页面：GetJsValue.cshtml</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>GetFormValue<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">"testdata"</span> <span class="attr">type</span>=<span class="string">"text"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">"submitButton"</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">"提交"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> &gt;</span></span><br><span class="line">    var button = document.getElementById('submitButton');</span><br><span class="line">    button.onclick = function () &#123;</span><br><span class="line">        var data = $('#testdata').val();</span><br><span class="line">        $.post("Home/GetJsValue", &#123; name: data &#125;, function () &#123;</span><br><span class="line">            alert("submit data success!");</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><h4 id="Action：GetJsValue"><a href="#Action：GetJsValue" class="headerlink" title="Action：GetJsValue"></a>Action：GetJsValue</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public IActionResult GetJsValue()</span><br><span class="line">       &#123;</span><br><span class="line">           return View();</span><br><span class="line">       &#125;</span><br><span class="line">       [HttpPost]</span><br><span class="line">       public IActionResult GetJsValue(string name)</span><br><span class="line">       &#123;</span><br><span class="line">           return View();</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure></li><li><h4 id="页面输入-1"><a href="#页面输入-1" class="headerlink" title="页面输入"></a>页面输入</h4><p><img src="/2019/06/17/视图与控制器传值/201906170103.PNG" alt="JS传值页面输入"></p></li><li><h4 id="传值结果-1"><a href="#传值结果-1" class="headerlink" title="传值结果"></a>传值结果</h4><p><img src="/2019/06/17/视图与控制器传值/201906170104.PNG" alt="JS传值结果"></p></li></ol><h2 id="三、Jquery-AJAX方法传值"><a href="#三、Jquery-AJAX方法传值" class="headerlink" title="三、Jquery AJAX方法传值"></a>三、Jquery AJAX方法传值</h2><ol><li><h4 id="视图页面：GetJqueryValue-cshtml"><a href="#视图页面：GetJqueryValue-cshtml" class="headerlink" title="视图页面：GetJqueryValue.cshtml"></a>视图页面：GetJqueryValue.cshtml</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>GetJqueryValue<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">"testdata"</span> <span class="attr">type</span>=<span class="string">"text"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">"submitButton"</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">"提交"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">"~/js/jQuery.form.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">"~/js/jquery-1.12.4.min.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line">    $("#submitButton").click(function () &#123;</span><br><span class="line">        var name = $("#testdata").val();</span><br><span class="line">        $.ajax(&#123;</span><br><span class="line">            type: 'post',</span><br><span class="line">            url:'/Home/GetJqueryValue',</span><br><span class="line">            data: &#123; "name": name &#125;,</span><br><span class="line">            success: function (data) &#123;</span><br><span class="line">                alert("submit success");</span><br><span class="line">            &#125;,</span><br><span class="line">            error: function (data) &#123;</span><br><span class="line">                alert("failed");</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;);</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在使用jquery的ajax方法传递数据的时候，会出现<code>not defined</code>错误，网上查了一圈也没有解决，最后用上面的方式解决了。</p></li><li><h4 id="Action-GetJqueryValue"><a href="#Action-GetJqueryValue" class="headerlink" title="Action:GetJqueryValue"></a>Action:GetJqueryValue</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public IActionResult GetJqueryValue()</span><br><span class="line">       &#123;</span><br><span class="line">           return View();</span><br><span class="line">       &#125;</span><br><span class="line">       [HttpPost]</span><br><span class="line">       public IActionResult GetJqueryValue(string name)</span><br><span class="line">       &#123;</span><br><span class="line">           return View();</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure></li><li><h4 id="页面结果"><a href="#页面结果" class="headerlink" title="页面结果"></a>页面结果</h4><p><img src="/2019/06/17/视图与控制器传值/201906170106.PNG" alt="页面结果"></p></li><li><h4 id="传值结果-2"><a href="#传值结果-2" class="headerlink" title="传值结果"></a>传值结果</h4><p><img src="/2019/06/17/视图与控制器传值/2011906170105.PNG" alt="传值结果"></p></li></ol><h2 id="四、模型绑定"><a href="#四、模型绑定" class="headerlink" title="四、模型绑定"></a>四、模型绑定</h2><p>模型绑定就是将表单中的传递来的数据，创建对应的model并把数据赋给model的属性。我们能看到的就是表单传过来的数据是一个对象。</p><p>需要注意的是，传递每一项数据的名称和接受的类的属性名称必须相同。</p><ol><li><h4 id="Aoki类："><a href="#Aoki类：" class="headerlink" title="Aoki类："></a>Aoki类：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class Aoki</span><br><span class="line">   &#123;</span><br><span class="line">       [Required(ErrorMessage = &quot;尚有未填写项，请先完善&quot;)]</span><br><span class="line">       public string name &#123; get; set; &#125;</span><br><span class="line">       [Required(ErrorMessage = &quot;尚有未填写项，请先完善&quot;)]</span><br><span class="line">       public string description &#123; get; set; &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>对于Aoki类，我添加了模型验证，Required就是说这个属性不能为空，当表单中这个数据没有填写的时候，是无法提交的。当然，我觉得前端的验证有浏览器完成比较好一些。</p></li><li><h4 id="视图页面：GetModelValue-cshtml"><a href="#视图页面：GetModelValue-cshtml" class="headerlink" title="视图页面：GetModelValue.cshtml"></a>视图页面：GetModelValue.cshtml</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>GetModelValue<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">asp-action</span>=<span class="string">"Home/GetModelValue"</span> <span class="attr">method</span>=<span class="string">"post"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">placeholder</span>=<span class="string">"名字"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"description"</span> <span class="attr">placeholder</span>=<span class="string">"描述"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">"submit"</span> <span class="attr">type</span>=<span class="string">"submit"</span>&gt;</span>提交<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这里要注意的是，<code>name</code>必须和原有对象的属性名相同。</p></li><li><h4 id="Action-GetModelValue"><a href="#Action-GetModelValue" class="headerlink" title="Action:GetModelValue"></a>Action:GetModelValue</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public IActionResult GetModelValue()</span><br><span class="line">        &#123;</span><br><span class="line">            return View();</span><br><span class="line">        &#125;</span><br><span class="line">        [HttpPost]</span><br><span class="line">        public IActionResult GetModelValue(Aoki aoki)</span><br><span class="line">        &#123;</span><br><span class="line">            return View();</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>在第二个Action中会收到前端传过来的一个对象，这个对象的属性是和前端页面中表单中填写的数据绑定的。</p></li><li><h4 id="页面输入："><a href="#页面输入：" class="headerlink" title="页面输入："></a>页面输入：</h4><p><img src="/2019/06/17/视图与控制器传值/201906170108.PNG" alt="页面输入"></p></li><li><h4 id="传值结果："><a href="#传值结果：" class="headerlink" title="传值结果："></a>传值结果：</h4><p><img src="/2019/06/17/视图与控制器传值/201906170109.PNG" alt="传值结果"></p></li></ol><h2 id="五、定位标记帮助程序"><a href="#五、定位标记帮助程序" class="headerlink" title="五、定位标记帮助程序"></a>五、定位标记帮助程序</h2><p>标记帮助程序使服务器端代码可以在Razor文件中参与创建和呈现HTML元素。在下面的代码中，<code>AnchorTagHelper</code>从控制器操作方法和路由ID动态生成HTML<code>href</code>特性值。</p><ol><li><h4 id="视图页面：GetNum-cshtml"><a href="#视图页面：GetNum-cshtml" class="headerlink" title="视图页面：GetNum.cshtml"></a>视图页面：GetNum.cshtml</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>GetNum<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">table</span> <span class="attr">border</span>=<span class="string">"1"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">th</span>&gt;</span>名字<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">th</span>&gt;</span>描述<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">th</span>&gt;</span>操作<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">th</span>&gt;</span></span><br><span class="line">            Aoki</span><br><span class="line">        <span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">th</span>&gt;</span></span><br><span class="line">            试举头，一笑问青天、天无语</span><br><span class="line">        <span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">th</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">a</span> <span class="attr">asp-action</span>=<span class="string">"GetNum"</span> <span class="attr">asp-controller</span>=<span class="string">"Home"</span> <span class="attr">asp-route-ID</span>=<span class="string">"1"</span>&gt;</span>查看<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这里需要注意的是<code>asp-action</code>、<code>asp-controller</code>、<code>asp-route-ID</code>是生成URL。在<code>asp-route-ID</code>中值得注意的是，这里面的<code>ID</code>就是传递的参数，控制器里面的参数名字是什么，这里的<code>ID</code>就换成什么。否则会出错</p></li><li><h4 id="Action-GetNum"><a href="#Action-GetNum" class="headerlink" title="Action:GetNum"></a>Action:GetNum</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public IActionResult GetNum(int ID)</span><br><span class="line">        &#123;</span><br><span class="line">            return View();</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></li><li><h4 id="页面结果-1"><a href="#页面结果-1" class="headerlink" title="页面结果"></a>页面结果</h4><p><img src="/2019/06/17/视图与控制器传值/201906170112.PNG" alt="页面"></p><p>鼠标悬停在查看按钮上，下方会出现URL。如图所示。</p><p><img src="/2019/06/17/视图与控制器传值/201906170114.png" alt="URL"></p><p>在浏览器中“查看源”，生成的HTML的部分如下如图所示。</p><p><img src="/2019/06/17/视图与控制器传值/201906170113.PNG" alt="HTML"></p></li><li><h4 id="传值结果-3"><a href="#传值结果-3" class="headerlink" title="传值结果"></a>传值结果</h4><p><img src="/2019/06/17/视图与控制器传值/201906170111.PNG" alt="传值结果"></p></li></ol><p>&emsp;&emsp;<a href="https://github.com/Aoki-Wang/CheckStation/tree/master/%E6%8E%A7%E5%88%B6%E5%99%A8%E4%B8%8E%E8%A7%86%E5%9B%BE%E4%B9%8B%E9%97%B4%E4%BC%A0%E5%80%BC/WebApplication1" target="_blank" rel="noopener">获得源码</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、form表单传值&quot;&gt;&lt;a href=&quot;#一、form表单传值&quot; class=&quot;headerlink&quot; title=&quot;一、form表单传值&quot;&gt;&lt;/a&gt;一、form表单传值&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;h4 id=&quot;View页面：GetFormValue-csht
      
    
    </summary>
    
      <category term="ASP.NET Core MVC" scheme="http://wanqbin.xyz/categories/ASP-NET-Core-MVC/"/>
    
    
      <category term="ASP.NET Core" scheme="http://wanqbin.xyz/tags/ASP-NET-Core/"/>
    
      <category term="视图与控制器" scheme="http://wanqbin.xyz/tags/%E8%A7%86%E5%9B%BE%E4%B8%8E%E6%8E%A7%E5%88%B6%E5%99%A8/"/>
    
      <category term="传值" scheme="http://wanqbin.xyz/tags/%E4%BC%A0%E5%80%BC/"/>
    
  </entry>
  
  <entry>
    <title>ASP.NET Core MVC控制器与视图传值</title>
    <link href="http://wanqbin.xyz/2019/06/16/ASP-NET-Core-MVC%E6%8E%A7%E5%88%B6%E5%99%A8%E4%B8%8E%E8%A7%86%E5%9B%BE%E4%BC%A0%E5%80%BC/"/>
    <id>http://wanqbin.xyz/2019/06/16/ASP-NET-Core-MVC控制器与视图传值/</id>
    <published>2019-06-16T08:31:00.000Z</published>
    <updated>2019-06-16T17:05:55.415Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、传值方式"><a href="#一、传值方式" class="headerlink" title="一、传值方式"></a>一、传值方式</h2><ul><li>弱类型参数传递数据</li><li>强类型参数传递数据</li></ul><h2 id="二、弱类型参数传递数据"><a href="#二、弱类型参数传递数据" class="headerlink" title="二、弱类型参数传递数据"></a>二、弱类型参数传递数据</h2><ol><li><h2 id="ViewData"><a href="#ViewData" class="headerlink" title="ViewData"></a>ViewData</h2><p>1）派生自ViewDataDictionary，因此它有可用的字典属性，如，ContainsKey、Add、Remove、Clear</p></li></ol><p>&emsp;    2）字典中键是字符串，所以允许有空格</p><p>&emsp;    3）任何非string类型均须在试图中进行强制转换才能使用ViewData</p><ol><li><h2 id="ViewBag"><a href="#ViewBag" class="headerlink" title="ViewBag"></a>ViewBag</h2><p>1）派生自DynamicViewData，因此它可使用点表示法（<code>ViewBag.name=name</code>)创建动态属性，且无需强制转换</p><p>2) ViewBag的语法使控制器到视图的速度更快</p><p>3) ViewBag更易于检查NULL值</p></li></ol><h3 id="3-ViewData的使用"><a href="#3-ViewData的使用" class="headerlink" title="3. ViewData的使用"></a>3. ViewData的使用</h3><p>1）创建Action：Index</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public IActionResult Index()</span><br><span class="line">        &#123;</span><br><span class="line">            ViewData[&quot;name&quot;] = &quot;Aoki&quot;;</span><br><span class="line">            ViewData[&quot;description&quot;] = &quot;试举头，一笑问青天、天无语&quot;;</span><br><span class="line">            return View();</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>2）创建视图：Index.cshtml</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"text-center"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>@ViewData["name"]<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>@ViewData["description"]<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>3）实现结果：</p><p><img src="/2019/06/16/ASP-NET-Core-MVC控制器与视图传值/viewdata.PNG" alt="结果"></p><h3 id="4-ViewBag的使用"><a href="#4-ViewBag的使用" class="headerlink" title="4. ViewBag的使用"></a>4. ViewBag的使用</h3><p>1）创建Action：Index</p><p>\ASP-NET-Core-MVC控制器与视图传值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public IActionResult Index()</span><br><span class="line">        &#123;</span><br><span class="line">            ViewBag.type = &quot;ViewBag&quot;;</span><br><span class="line">            ViewBag.name = &quot;Aoki&quot;;</span><br><span class="line">            ViewBag.description = &quot;试举头，一笑问青天、天无语&quot;;</span><br><span class="line">            return View();</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>2）创建视图：Index.cshtml</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"text-center"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>@ViewBag.name<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>@ViewBag.description<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h4</span>&gt;</span>Pass the value through @ViewBag.type<span class="tag">&lt;/<span class="name">h4</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>3）实现结果</p><p><img src="/2019/06/16/ASP-NET-Core-MVC控制器与视图传值/viewbag.PNG" alt="结果"></p><h2 id="三、强类型参数传递数据"><a href="#三、强类型参数传递数据" class="headerlink" title="三、强类型参数传递数据"></a>三、强类型参数传递数据</h2><ol><li><h3 id="强类型参数说明"><a href="#强类型参数说明" class="headerlink" title="强类型参数说明"></a>强类型参数说明</h3><p>&emsp;&emsp;视图强类型通常称为ViewModel，可以在<code>return View();</code>时指定参数/对象。并在视图文件（.cshtml）中通过<code>@model</code>语法来指定对应的类型。</p></li><li><h3 id="强类型参数示例"><a href="#强类型参数示例" class="headerlink" title="强类型参数示例"></a>强类型参数示例</h3><p>1）创建Aoki类</p></li></ol>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public class Aoki</span><br><span class="line">    &#123;</span><br><span class="line">        public string name &#123; get; set; &#125;</span><br><span class="line">        public string description &#123; get; set; &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>   2）创建Action：Index</p>   <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public IActionResult Index()</span><br><span class="line">        &#123;</span><br><span class="line">            var aoki = new Aoki</span><br><span class="line">            &#123;</span><br><span class="line">                name = "Aoki",</span><br><span class="line">                description = "试举头，一笑问青天、天无语"</span><br><span class="line">            &#125;;</span><br><span class="line">            return View(aoki);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>   3）创建视图：Index.cshtml</p>   <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"text-center"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>@Model.name<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>@Model.description<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>   4）实现结果</p><p>   <img src="/2019/06/16/ASP-NET-Core-MVC控制器与视图传值/Model.PNG" alt="结果"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、传值方式&quot;&gt;&lt;a href=&quot;#一、传值方式&quot; class=&quot;headerlink&quot; title=&quot;一、传值方式&quot;&gt;&lt;/a&gt;一、传值方式&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;弱类型参数传递数据&lt;/li&gt;
&lt;li&gt;强类型参数传递数据&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;
      
    
    </summary>
    
      <category term="ASP.NET Core MVC" scheme="http://wanqbin.xyz/categories/ASP-NET-Core-MVC/"/>
    
    
      <category term="ASP.NET Core" scheme="http://wanqbin.xyz/tags/ASP-NET-Core/"/>
    
      <category term="MVC" scheme="http://wanqbin.xyz/tags/MVC/"/>
    
  </entry>
  
  <entry>
    <title>软件管理</title>
    <link href="http://wanqbin.xyz/2019/06/16/%E7%AE%A1%E7%90%86/"/>
    <id>http://wanqbin.xyz/2019/06/16/管理/</id>
    <published>2019-06-15T16:58:00.000Z</published>
    <updated>2019-06-15T17:20:37.863Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、软件过程改进模型CMMI"><a href="#一、软件过程改进模型CMMI" class="headerlink" title="一、软件过程改进模型CMMI"></a>一、软件过程改进模型CMMI</h2><p>软件组织的产品质量和服务质量，来自组织内部的过程改进状态。而过程改进是要有模型的，模型是实践、理论、方法、经验和技术的结晶，是软件组织的一种企业文化、工作环境和管理理念；模型能够引导企业从杂乱无章的管理状态到有条不紊的管理状态。</p><p>目前为止，IT企业界的过程管理和过程改进模型共有三个类型：</p><ul><li>ISO 9001 模型</li><li>CMMI模型</li><li>软件企业文化模型<ul><li>微软企业文化</li><li>IBM企业文化</li><li>敏捷文化现象</li></ul></li></ul><ol><li><h4 id="CMMI是什么"><a href="#CMMI是什么" class="headerlink" title="CMMI是什么"></a>CMMI是什么</h4><p>软件能力成熟度模型CMMI是由美国卡内基-梅隆大学软件工程研究所推出的评估软件能力与成熟度等级的一套标准。</p></li><li><h4 id="CMMI的作用是什么"><a href="#CMMI的作用是什么" class="headerlink" title="CMMI的作用是什么"></a>CMMI的作用是什么</h4><ul><li>软件组织，用它来不断改进自身的软件过程管理能力</li><li>评估机构，用它来评估某软件组织当前软件能力成熟度级别</li><li>客户，用它来评估某承包商的软件能力</li></ul></li><li><h4 id="CMMI的实质"><a href="#CMMI的实质" class="headerlink" title="CMMI的实质"></a>CMMI的实质</h4><ul><li>以“过程”为核心，抓软件组织的管理，即软件“组织”的过程改进</li><li>以“项目”为手段，抓团队开发过程的“活动”，即落实过程改进的措施</li><li>以“活动”记录为基础，抓软件过程的“度量”，即“度量”软件组织改进的情况</li></ul></li><li><h4 id="CMMI阶段模型的成熟度等级"><a href="#CMMI阶段模型的成熟度等级" class="headerlink" title="CMMI阶段模型的成熟度等级"></a>CMMI阶段模型的成熟度等级</h4></li></ol><div class="table-container"><table><thead><tr><th>CMMI等级</th><th>PA数目</th><th>管理特点</th></tr></thead><tbody><tr><td>ML1:初始级</td><td>0</td><td>过程不可预测且缺乏控制</td></tr><tr><td>ML2：已管理级</td><td>7</td><td>过程为项目服务，即项目级管理</td></tr><tr><td>ML3：已定义级</td><td>11</td><td>过程为组织服务，即组织级管理</td></tr><tr><td>ML4：定量管理级</td><td>2</td><td>过程已度量和控制，即定量级管理</td></tr><tr><td>ML5：优化级</td><td>2</td><td>集中于过程改进，即优化管理级</td></tr></tbody></table></div><ol><li><h4 id="ISO-9001与CMMI的联系和区别"><a href="#ISO-9001与CMMI的联系和区别" class="headerlink" title="ISO 9001与CMMI的联系和区别"></a>ISO 9001与CMMI的联系和区别</h4><p>&emsp;&emsp;与ISO 9001标准相比，CMMI更为软件产业所看好。原因是CMMI专门针对软件工程控制而设置。它不仅进行软件企业工程能力的评估，更致力于软件开发过程的管理，强调对软件开发过程进行持续改进，引导软件开发过程走向成熟。</p><p>&emsp;&emsp;两者的相同点是：CMMI和ISO 9001标准都致力于质量和过程管理，都是为了解决同样的问题。</p><p>&emsp;&emsp;两者的不同点是：CMMI是动态的、开放的和持续改进的，它强调“没有最好，只有更好”，强调不断改进，强调人在软件开发方面的主动性，非常适用于软件过程改进；ISO 9001是静态的质量控制，只要达到20个关键指标或过程，就能完成质量控制，它更适用于硬件制造行业和第三产业的质量控制。CMMI与IO 9001的设计思路有差异：CMMI是“专用的”，ISO 9001是“通用”的。ISO 9001不覆盖CMMI，CMMI也不覆盖ISO 9001.</p></li></ol><h2 id="二、软件配置管理"><a href="#二、软件配置管理" class="headerlink" title="二、软件配置管理"></a>二、软件配置管理</h2><p>软件配置管理SCM是对软件开发过程中配置项的一组追踪和控制活动，它开始于软件开发之初，结束于软件淘汰之时。</p><h2 id="三、软件质量保证"><a href="#三、软件质量保证" class="headerlink" title="三、软件质量保证"></a>三、软件质量保证</h2><p>软件质量保证SQA是一个过程，是CMMI和ISO 9001的重要议题，同样也是项目管理的重要议题。</p><p>软件质量，是供方提供的软件产品满足用户明确或隐含需求的能力特性的总和。</p><ol><li><h4 id="质量管理的三大支柱"><a href="#质量管理的三大支柱" class="headerlink" title="质量管理的三大支柱"></a>质量管理的三大支柱</h4><ul><li>质量标准</li><li>配置管理</li><li>测试测量</li></ul></li><li><h4 id="质量管理的三大要素"><a href="#质量管理的三大要素" class="headerlink" title="质量管理的三大要素"></a>质量管理的三大要素</h4><ul><li>SQA计划</li><li>SQA进度</li><li>SQA评审和审计</li></ul></li></ol><h2 id="四、软件项目管理"><a href="#四、软件项目管理" class="headerlink" title="四、软件项目管理"></a>四、软件项目管理</h2><ol><li><h4 id="什么是项目"><a href="#什么是项目" class="headerlink" title="什么是项目"></a>什么是项目</h4><p>项目，是一次性的多任务工作，它具有确定的开始日期，结束日期，工作范围，经费预算，质量标准，以及特定的功能、性能和接口要求。</p></li><li><h4 id="什么是项目管理"><a href="#什么是项目管理" class="headerlink" title="什么是项目管理"></a>什么是项目管理</h4><p>项目管理，是为了实现项目目标，运用相关知识、技能、方法与工具，对项目的计划、进度、质量、成本、资源进行管理和控制的活动。</p></li><li><h4 id="项目经理的七项职责"><a href="#项目经理的七项职责" class="headerlink" title="项目经理的七项职责"></a>项目经理的七项职责</h4><ul><li>抓需求获取与确认</li><li>抓计划制订与执行</li><li>抓团队分工与协作</li><li>抓后勤供应与保障</li><li>抓产品测试和交付</li><li>抓开发标准与规范</li><li>抓员工考核与奖励</li></ul></li><li><h4 id="项目经理对程序员的八项要求"><a href="#项目经理对程序员的八项要求" class="headerlink" title="项目经理对程序员的八项要求"></a>项目经理对程序员的八项要求</h4><ul><li>团队协作精神的训练和要求</li><li>数据库和数据结构分析与设计能力的训练和要求</li><li>书写文档习惯的训练和要求</li><li>规范化代码编写能力的训练和要求</li><li>复用性能力与构件技术的训练和要求</li><li>测试习惯的训练和要求</li><li>学习和总结能力的训练和要求</li><li>引导程序员由“丑小鸭”变成“白天鹅”</li></ul></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、软件过程改进模型CMMI&quot;&gt;&lt;a href=&quot;#一、软件过程改进模型CMMI&quot; class=&quot;headerlink&quot; title=&quot;一、软件过程改进模型CMMI&quot;&gt;&lt;/a&gt;一、软件过程改进模型CMMI&lt;/h2&gt;&lt;p&gt;软件组织的产品质量和服务质量，来自组织内部的
      
    
    </summary>
    
      <category term="软件工程" scheme="http://wanqbin.xyz/categories/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"/>
    
    
      <category term="CMMI" scheme="http://wanqbin.xyz/tags/CMMI/"/>
    
      <category term="软件管理" scheme="http://wanqbin.xyz/tags/%E8%BD%AF%E4%BB%B6%E7%AE%A1%E7%90%86/"/>
    
      <category term="项目管理" scheme="http://wanqbin.xyz/tags/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/"/>
    
      <category term="软件质量保证" scheme="http://wanqbin.xyz/tags/%E8%BD%AF%E4%BB%B6%E8%B4%A8%E9%87%8F%E4%BF%9D%E8%AF%81/"/>
    
      <category term="项目经理" scheme="http://wanqbin.xyz/tags/%E9%A1%B9%E7%9B%AE%E7%BB%8F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>软件实施与维护</title>
    <link href="http://wanqbin.xyz/2019/06/16/%E5%AE%9E%E6%96%BD%E4%B8%8E%E7%BB%B4%E6%8A%A4-1/"/>
    <id>http://wanqbin.xyz/2019/06/16/实施与维护-1/</id>
    <published>2019-06-15T16:18:00.000Z</published>
    <updated>2019-06-15T16:22:17.255Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、软件产品"><a href="#一、软件产品" class="headerlink" title="一、软件产品"></a>一、软件产品</h2><ol><li><p>软件企业开发的软件可以分为软件项目和软件产品。</p></li><li><p>软件产品分为三类分别是：</p></li></ol><div class="table-container"><table><thead><tr><th>类别</th><th>产品特点</th><th>举例</th></tr></thead><tbody><tr><td>1</td><td>不需要客户化的产品</td><td>系统软件</td></tr><tr><td>2</td><td>只需要少量客户化工作的产品</td><td>专业性特强的应用软件产品</td></tr><tr><td>3</td><td>需要重新做业务流程规范和需求规格定义的软件产品</td><td>分行业ERP</td></tr></tbody></table></div><ol><li><p>项目与产品的区别与联系</p><p>除了上述三类软件产品外，其他软件一般称为软件项目，不能叫软件产品。</p><p>软件项目就是为用户定制的软件系统，它的专业性强，通用性差，从需求分析、设计、编码、测试，到安装、试运行、正式运行，直至验收交付，整个开发流程一步都不能省。</p><p>软件项目的特点是，业务领域知识所占比重大，工程性强，因此用CMMI模型实现规范化管理和量化控制比较适合。IT企业做软件项目的目的，一般都是为了将软件项目逐步产品化，如同做财务项目是为了做财务产品一样。一方面，只有产品化了才能赚取最大的利润，另一方面，只有拥有自己的软件产品，才能在投标活动中获得更大更好的项目。</p><p>项目和产品既有显著的不同，又有紧密的关系。这种关系是：做软件项目是手段，做软件产品是目的，软件项目做多了，软件项目就慢慢变成了软件产品。</p></li></ol><h2 id="二、软件产品的发布"><a href="#二、软件产品的发布" class="headerlink" title="二、软件产品的发布"></a>二、软件产品的发布</h2><p>&emsp;&emsp;产品的发布时机，是由市场利润、开发进度、产品的功能与质量、客户可接受程度等多方面因素决定的。</p><h2 id="三、软件产品的实施"><a href="#三、软件产品的实施" class="headerlink" title="三、软件产品的实施"></a>三、软件产品的实施</h2><p>软件产品发布以后，销售中心就会获取各种客户信息，并准备用各种方式为客户服务。在服务中，需要各种销售技术人员的支持，这些技术人员包括售前、售中、售后三部分人员。售前技术人员称为售前工程师，售中技术人员称为实施工程师，售后技术人员称为维护工程师。</p><h2 id="四、软件维护的传统方法"><a href="#四、软件维护的传统方法" class="headerlink" title="四、软件维护的传统方法"></a>四、软件维护的传统方法</h2><p>软件维护，是指软件项目或产品爱安装、运行并交付给用户使用后，在新产品升级之前这段时间里，软件厂商向客户提供的服务工作。</p><ol><li><h4 id="软件维护的分类"><a href="#软件维护的分类" class="headerlink" title="软件维护的分类"></a>软件维护的分类</h4></li></ol><div class="table-container"><table><thead><tr><th>序号</th><th>维护的种类</th><th>维护的内容</th></tr></thead><tbody><tr><td>1</td><td>纠错性维护</td><td>产品或项目中存在缺陷或错误，在测试和验收时未发现，到了使用过程中逐渐暴露出来，需要改正。</td></tr><tr><td>2</td><td>适应性维护</td><td>这类维护是为了产品或项目适应变化了的硬件、系统软件的运行环境，如系统升级</td></tr><tr><td>3</td><td>完善性维护</td><td>这类维护是为了给软件系统增加一些新的功能，使产品或项目更加完善与合理，又不至于对系统进行伤筋动骨的改造，这类维护占维护的大部分</td></tr><tr><td>4</td><td>预防性维护</td><td>这类维护是为了提高产品或项目的可靠性和可维护性，有利于系统的进一步改造或升级换代</td></tr></tbody></table></div><ol><li><h4 id="软件维护的副作用"><a href="#软件维护的副作用" class="headerlink" title="软件维护的副作用"></a>软件维护的副作用</h4></li></ol><div class="table-container"><table><thead><tr><th>序号</th><th>维护的方式</th><th>副作用的表现</th></tr></thead><tbody><tr><td>1</td><td>修改编码</td><td>使编码更加混乱，程序结构更不清晰，可读性更差，而且会有连锁反应</td></tr><tr><td>2</td><td>修改数据结构</td><td>数据结构是系统的骨架，修改数据结构是对系统伤筋动骨的大手术，在数据冗余与数据不一致方面，可能顾此失彼</td></tr><tr><td>3</td><td>修改用户数据</td><td>需要与用户协商，一旦有疏忽，可使系统发生意外</td></tr><tr><td>4</td><td>修改文档</td><td>对非结构化维护不适应，对结构化维护要严防程序与文档的不匹配</td></tr></tbody></table></div><h2 id="五、软件维护的最新方法"><a href="#五、软件维护的最新方法" class="headerlink" title="五、软件维护的最新方法"></a>五、软件维护的最新方法</h2><ol><li><h4 id="软件维护的最新分类方法"><a href="#软件维护的最新分类方法" class="headerlink" title="软件维护的最新分类方法"></a>软件维护的最新分类方法</h4><ul><li>面向缺陷维护——程序级维护</li><li>面向功能维护——设计级维护</li></ul></li><li><h4 id="软件维护的最新方法"><a href="#软件维护的最新方法" class="headerlink" title="软件维护的最新方法"></a>软件维护的最新方法</h4><ul><li>基于两层结构（客户机/服务器）划分软件维护的方法</li><li>基于三层结构划分软件维护的方法</li><li>基于“三种开发方法”，来划分软件维护的方法</li></ul></li><li><h4 id="软件维护工作流程"><a href="#软件维护工作流程" class="headerlink" title="软件维护工作流程"></a>软件维护工作流程</h4></li></ol><div class="table-container"><table><thead><tr><th>流程步骤</th><th>流程内容</th></tr></thead><tbody><tr><td>1</td><td>分类整理用户意见</td></tr><tr><td>2</td><td>提出维护申请</td></tr><tr><td>3</td><td>评审、审计、批准维护申请</td></tr><tr><td>4</td><td>修改需求文档</td></tr><tr><td>5</td><td>维护需求文档评审</td></tr><tr><td>6</td><td>维护设计文档</td></tr><tr><td>7</td><td>维护设计文档评审</td></tr><tr><td>8</td><td>修改源程序</td></tr><tr><td>9</td><td>回归测试</td></tr><tr><td>10</td><td>修改软件版本号</td></tr><tr><td>11</td><td>交付用户运行</td></tr><tr><td>12</td><td>收集用户反馈意见，准备进行新一轮维护活动，转向流程第1个步骤</td></tr></tbody></table></div>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、软件产品&quot;&gt;&lt;a href=&quot;#一、软件产品&quot; class=&quot;headerlink&quot; title=&quot;一、软件产品&quot;&gt;&lt;/a&gt;一、软件产品&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;软件企业开发的软件可以分为软件项目和软件产品。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;软件产品
      
    
    </summary>
    
      <category term="软件工程" scheme="http://wanqbin.xyz/categories/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"/>
    
    
      <category term="软件维护" scheme="http://wanqbin.xyz/tags/%E8%BD%AF%E4%BB%B6%E7%BB%B4%E6%8A%A4/"/>
    
      <category term="软件产品" scheme="http://wanqbin.xyz/tags/%E8%BD%AF%E4%BB%B6%E4%BA%A7%E5%93%81/"/>
    
      <category term="软件项目" scheme="http://wanqbin.xyz/tags/%E8%BD%AF%E4%BB%B6%E9%A1%B9%E7%9B%AE/"/>
    
  </entry>
  
  <entry>
    <title>软件设计、实现与测试</title>
    <link href="http://wanqbin.xyz/2019/06/15/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E3%80%81%E5%AE%9E%E7%8E%B0%E3%80%81%E6%B5%8B%E8%AF%95/"/>
    <id>http://wanqbin.xyz/2019/06/15/软件设计、实现、测试/</id>
    <published>2019-06-15T15:47:00.000Z</published>
    <updated>2019-06-15T15:48:08.791Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、软件设计"><a href="#一、软件设计" class="headerlink" title="一、软件设计"></a>一、软件设计</h2><ol><li><h4 id="三层结构设计"><a href="#三层结构设计" class="headerlink" title="三层结构设计"></a>三层结构设计</h4><p>1）表示层：也称浏览层，通常采用图形化界面，在客户端PC或工作站上运行。站在“三个模型”的思想上看，系统内部支持表示层的模型是“功能模型”。</p><p>&emsp;表示层的主要功能：</p><p>&emsp;1)接受用户请求，将这些请求反馈给业务逻辑层，等待业务逻辑层的应答信息。</p><p>&emsp;2）对业务逻辑层的应答信息进行显示</p><p>&emsp;3）有时会兼做一些业务逻辑层的小功能</p><p>2）中间层（业务层）：它由许多构件和组件组成，它们完全体现了用户的业务逻辑或业务规则，站在“三个模型”建模思想上看，系统内部支持业务层的模型是“业务模型”。</p><p>&emsp;业务层的主要功能：</p><p>&emsp;1）接受从表示层传来的用户请求信息</p><p>&emsp;2）根据用户的请求信息生成SQL语句</p><p>&emsp;3)利用生成的SQL语句从数据层取数据、修改数据、删除数据</p><p>&emsp;4）将结果返回表示层</p><p>中间层也可以分为两个子层，分别是业务逻辑层和数据访问层。</p><p>在这段时间的信息系统设计中我深有体会，将虽然三层结构从一定程度上可以降低系统的耦合度，但是如果数据层出现问题，需要进行调整，那么中间层也要进行大规模的调整，这对系统的实现进度是有害的。如果将中间层划分为两个子层，那么，如果数据层出现问题，进行了大规模调整，那么我们的业务逻辑层是不会受到影响的，只需要对数据访问层进行适当的修改。</p><p>3）数据层：是数据库服务器上的数据库层，它包括数据库管理系统DBMS和数据库DB两部分。站在“三个模型”建模思想上看，系统内部支持数据层的模型是“数据模型”。</p><p>&emsp;数据层的功能：</p><p>&emsp;1）接受业务层数据处理请求的SQL语句或存储过程</p><p>&emsp;2）利用SQL语句或存储过程，对数据库服务器上数据库的相关表进行存储或检索</p><p>&emsp;3）将存储或检索的结果传递给业务层。</p></li><li><h4 id="软件设计原理"><a href="#软件设计原理" class="headerlink" title="软件设计原理"></a>软件设计原理</h4><p>软件设计原理，就是各种软件设计方法中都应该遵守的共同基本原理。这些原理包括：抽象、模块化、信息隐藏、模块独立性、封装、接口和实现分离。</p><p>1）抽象。</p><p>在每个阶段中，抽象的层次逐步降低，在软件结构设计中的模块分层也是由抽象到具体分析和构造出来的。抽象就是将几个有区别的物体的共同性质或特性，形象地抽取出来，独立地进行考虑的过程。</p><p>常用的抽象技术有：控制抽象、过程抽象、数据抽象</p><p>2）模块化。</p><p>模块指程序中的数据说明、可执行语句等程序对象的集合，或单独命名和编程的元素。</p><p>模块化，就是解决一个复杂问题时，自顶向下、逐步求精地把软件系统划分为若干模块的过程。为了解决复杂的问题，在软件设计中，必须把整个问题分解来降低复杂性，以减小开发工作量，降低开发成本，提高软件生产率。但是模块并不是越多越好，因为这会增加模块之间的接口量。所以划分模块的层次和数量应该避免过多或过少。</p><p>3）信息隐藏。</p><p>信息隐藏，指在设计和确定模块时，使一个模块内包含的信息，对于不需要这些信息的其他模块来说是不能访问的。</p><p>4）模块独立性。</p><p>模块独立性指每个模块只完成系统要求的独立的子功能，并且与其他模块的联系最少，且接口简单。模块独立性是抽象、模块化、信息隐藏的直接产物，在概要设计的过程中，就是要设计出具有良好模块独立性的软件结构。用来衡量软件模块独立性的定性度量标准有：高内聚、低耦合</p><p>5）封装。</p><p>封装是将信息隐藏在一个实体中，使其内部细节对外不可见。封装是实现“低耦合、高内聚”的技术手段之一。要进行正确的封装，必须遵守的原则是：</p><ul><li>实体间相互隐藏内部实现</li><li>尽量减少全局的共享数据</li></ul><p>6）接口和实现分离</p><p>将接口与实现分离，对外只提供接口，隐藏具体的实现。接口与实现的分离，保证了实现的独立变化，降低了模块间的耦合。</p></li></ol><h2 id="二、三种设计方法"><a href="#二、三种设计方法" class="headerlink" title="二、三种设计方法"></a>二、三种设计方法</h2><ol><li><h4 id="面向过程设计"><a href="#面向过程设计" class="headerlink" title="面向过程设计"></a>面向过程设计</h4><p>1）面向过程概要设计的主要方法有：</p><ul><li>功能模块分解方法</li><li>功能模块调用方法</li><li>功能模块转化方法</li><li>数据流图转换为层次结构图方法</li></ul><p>2）面向过程设计技术，采用“自顶向下、逐步求精”的设计方法和“单入口、单出口”的控制结构，并且只包含顺序、选择和循环三种结构，设计目标之一是使程序的控制流程线性化，即程序的动态执行顺序符合静态书写结构。</p><p>3）详细设计的工具有：程序流程图、N-S图、程序设计语言PDL、PAD图等</p></li><li><h4 id="面向对象设计"><a href="#面向对象设计" class="headerlink" title="面向对象设计"></a>面向对象设计</h4><p>面向对象设计描述工具：</p><p>1）系统静态建模图（结构图）</p><ul><li><p>类图</p></li><li><p>部件图</p><p>部件图比类图在更高层次上体现了系统中部件、部件接口以及部件之间的关系。</p></li><li><p>部署图</p><p>表示运行时处理元素（节点）的物理配置情况。</p></li><li><p>界面图</p></li></ul><p>2）系统动态建模（行为图）</p><ul><li><p>用例图</p></li><li><p>顺序图</p><p>&emsp;&emsp;顺序图是系统的动态视图，表示系统基于时间序列的操作。在顺序图中可以包括与系统交互的角色。顺序图以一个二维视图展现交互过程，垂直方向上是时间轴，水平方向上是参与交互的对象或角色。</p><p>&emsp;&emsp;顺序图是类图的补充，类图是系统的静态视图，顺序图反映了系统的动态视图。通常先绘制用例图，接着根据用例图中涉及的实体绘制类图，再绘制顺序图来展现用例的交互过程。</p></li><li><p>状态图</p><p>&emsp;&emsp;状态图是状态机图形化的表现，用于描述用例、部件或类的行为。状态图对实体的有限状态、事件和状态间的转换进行建模。</p></li><li><p>活动图</p><p>&emsp;&emsp;活动图描述的是执行某个功能的活动。</p></li></ul></li><li><h4 id="面向元数据设计"><a href="#面向元数据设计" class="headerlink" title="面向元数据设计"></a>面向元数据设计</h4><p>&emsp;&emsp;面向元数据设计，以实体-关系模型为基础，按照一定的规则将概念模型CDM转换成为能被某种数据库管理系统接受的物理数据模型PDM，创建物理上的数据库表、索引和视图，并且用存储过程和触发器来实现各种业务规则。</p></li></ol><h2 id="三、软件实现"><a href="#三、软件实现" class="headerlink" title="三、软件实现"></a>三、软件实现</h2><ol><li><p>构件：就是被标识的且可被复用的软件制品。</p></li><li><p>中间件：是一个非常大的组件（构件），一般在网络上运行，完成批量数据的传递和通信工作，调用方式是通过一组事先约定的格式与参数进行的。</p></li><li><p>软件实现原则</p><ul><li>尽可能简单。在软件实现过程中，应创建简单、容易阅读的代码；相同功能的代码只写一次；简单的代码易于维护；通过采用一些编码规范和标准，可以有效地降低代码的复杂度。</li><li>易于验证。无论是在编码、测试和实际操作中，软件工程师应该很容易发现其中的错误；自动化的单元测试可产生易于验证的代码；写代码时，要限制使用复杂的难以理解的语言结构</li><li>适应变化。外部环境、软件需求和软件设计，在整个开发过程中可能会随时发生变化，因此要求软件实现时考虑适应这些变化</li><li>遵守某一编程规范。尽量使用了标准库函数和公共函数。不要随意定义全局变量，尽量使用局部变量。使用括号避免二义性。</li><li>选择项目组成员最熟悉的工具或语言。</li></ul><p>除此之外，除了特殊要求之外，任何程序必须遵守”可读性第一、效率第二“的实现原则。</p></li></ol><h2 id="四、软件测试"><a href="#四、软件测试" class="headerlink" title="四、软件测试"></a>四、软件测试</h2><p>在另外的一些文章或资料中有所涉及和详细解释。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、软件设计&quot;&gt;&lt;a href=&quot;#一、软件设计&quot; class=&quot;headerlink&quot; title=&quot;一、软件设计&quot;&gt;&lt;/a&gt;一、软件设计&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;h4 id=&quot;三层结构设计&quot;&gt;&lt;a href=&quot;#三层结构设计&quot; class=&quot;headerl
      
    
    </summary>
    
      <category term="软件工程" scheme="http://wanqbin.xyz/categories/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"/>
    
    
      <category term="软件设计" scheme="http://wanqbin.xyz/tags/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1/"/>
    
      <category term="软件实现" scheme="http://wanqbin.xyz/tags/%E8%BD%AF%E4%BB%B6%E5%AE%9E%E7%8E%B0/"/>
    
      <category term="三层结构" scheme="http://wanqbin.xyz/tags/%E4%B8%89%E5%B1%82%E7%BB%93%E6%9E%84/"/>
    
      <category term="软件设计原理" scheme="http://wanqbin.xyz/tags/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>软件建模</title>
    <link href="http://wanqbin.xyz/2019/06/15/%E8%BD%AF%E4%BB%B6%E5%BB%BA%E6%A8%A1/"/>
    <id>http://wanqbin.xyz/2019/06/15/软件建模/</id>
    <published>2019-06-15T15:46:00.000Z</published>
    <updated>2019-06-15T15:46:54.288Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、三个模型的建模思想"><a href="#一、三个模型的建模思想" class="headerlink" title="一、三个模型的建模思想"></a>一、三个模型的建模思想</h2><ol><li><h4 id="功能模型"><a href="#功能模型" class="headerlink" title="功能模型"></a>功能模型</h4><p>功能模型，实质上是用户需求模型，用来描述系统能做什么，即对系统的功能、性能、接口和界面进行定义。</p><p>从用户角度来看，功能模型就是系统功能需求列表</p><p>从设计者的角度看，功能模型就是系统内部功能模块的有机排列和组合</p><p>从Rose的角度上看，功能模型就是系统的用例的集合</p><p>从产品的角度看，功能模型就是系统的用户操作手册</p><p>从操作界面的角度上看，功能模型就是系统的功能菜单</p><p>从B/A/S的角度上看，功能模型就对应在浏览层上建模</p></li><li><h4 id="业务模型"><a href="#业务模型" class="headerlink" title="业务模型"></a>业务模型</h4><p>业务模型，实质上是业务逻辑模型，用于描述系统在何时、何地、由何角色、按什么业务规则去做、以及做什么的流程或步骤，即对系统的操作流程进行定义。</p><p>业务模型反映了系统的业务行为，是算法设计的主要依据。站在B/A/S的角度上看，业务模型就对应在中间层（业务逻辑层或业务应用层）上建模。</p></li><li><h4 id="数据模型"><a href="#数据模型" class="headerlink" title="数据模型"></a>数据模型</h4><p>数据模型实质上是实体或类的状态关系模型，用于描述系统工作前的数据来自何处、工作中的数据暂存在什么地方、工作后的数据放到哪儿、以及这些数据的状态及相互之间的关联，即对系统的数据结构进行定义。</p></li></ol><h2 id="二、数据模型设计"><a href="#二、数据模型设计" class="headerlink" title="二、数据模型设计"></a>二、数据模型设计</h2><ol><li><h4 id="什么是好的数据模型？"><a href="#什么是好的数据模型？" class="headerlink" title="什么是好的数据模型？"></a>什么是好的数据模型？</h4><p>条件有三：</p><p>1）满足功能需求</p><p>2）满足性能需求</p><p>3）该模型能够长期使用，也就是“以不变应万变</p></li><li><h4 id="数据库的基本表、代码表、中间表和临时表"><a href="#数据库的基本表、代码表、中间表和临时表" class="headerlink" title="数据库的基本表、代码表、中间表和临时表"></a>数据库的基本表、代码表、中间表和临时表</h4><p>存放元素数据的表，称为基本表</p><p>存放信息代码的表，称为代码表</p><p>存放统计信息的表，称为中间表（又称查询表）</p><p>存放临时数据的表，称为临时表</p></li><li><h4 id="基本表的4个特性："><a href="#基本表的4个特性：" class="headerlink" title="基本表的4个特性："></a>基本表的4个特性：</h4><p>1）原子性：基本表中的字段是不可再分解的。</p><p>2）原始性：基本表中的记录是原始数据记录。</p><p>3）演绎性：由基本表与代码表中的数据可以派生出所有的输出数据。</p><p>4）稳定性：基本表的结构是相对稳定的，表中的记录需要长期保存。</p></li><li><h4 id="数据库设计的步骤："><a href="#数据库设计的步骤：" class="headerlink" title="数据库设计的步骤："></a>数据库设计的步骤：</h4><p>1）将原始单据分类整理，理清原始单据与输出数据之间的数据转换关系和算法，澄清一切不确定的问题。</p><p>2）从原始单据出发，划分出各个实体，给实体命名，初步分配属性，标识出主键或外键，理清实体之间的关系。</p><p>3）进行数据库概念数据模型设计，画出实体关系图ERD，定义完整性约束</p><p>4）进行数据库物理数据模型PDM设计，将概念模型CDM转换为物理数据模型PDM</p><p>5）在待定对的数据库管理系统上定义表空间，实现物理建表与建索引</p><p>6）定义触发器与存储过程</p><p>7）定义视图，说明数据库与应用程序之间的关系</p><p>8）数据库加载测试：向基表中追加记录，对数据库的功能、性能进行全面测试</p><p>9）数据库性能优化：从数据库系统的参数配置、数据库设计的反规范化两个方面，对数据库的性能进行优化</p><p>10）数据库设计评审：从数据库的整体功能和性能两个方面，请同行专家评审评价</p></li></ol><h2 id="三、数据库设计理论与方法"><a href="#三、数据库设计理论与方法" class="headerlink" title="三、数据库设计理论与方法"></a>三、数据库设计理论与方法</h2><ol><li><h4 id="数据库范式理论"><a href="#数据库范式理论" class="headerlink" title="数据库范式理论"></a>数据库范式理论</h4><p>1NF，关系模式中的关系的每个分量都是不可再分的数据项</p><p>2NF，满足1NF，且每一非主属性完全函数依赖于候选键</p><p>3NF，消除非主属性对候选键的传递依赖</p></li><li><h4 id="数据库设计中的“第三者插足”设计模式"><a href="#数据库设计中的“第三者插足”设计模式" class="headerlink" title="数据库设计中的“第三者插足”设计模式"></a>数据库设计中的“第三者插足”设计模式</h4><p>当两个实体之间存在多对关系时，必须在它们之间插入第三个实体，以化解这种多对多关系。</p></li><li><h4 id="数据库设计中的“列变行”模式"><a href="#数据库设计中的“列变行”模式" class="headerlink" title="数据库设计中的“列变行”模式"></a>数据库设计中的“列变行”模式</h4><p>就是将第一个表中的某些列，变为第二个表中的某些行。</p></li><li><h4 id="数据库设计中的四个原子化理论"><a href="#数据库设计中的四个原子化理论" class="headerlink" title="数据库设计中的四个原子化理论"></a>数据库设计中的四个原子化理论</h4><p>站在数据库设计者的角度看，只要实现属性原子化、实体原子化、主键原子化、联系原子化，数据的所谓更新异常、插入异常、删除异常、数据冗余现象就从根本上消除了。</p><p>属性原子化：实体的属性本身不能再分解</p><p>实体原子化：实体本身不能再分解</p><p>主键原子化：是指实体的主键本身是一个ID（identifier）</p><p>联系原子化：是指实体之间的联系都是一对多联系。</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、三个模型的建模思想&quot;&gt;&lt;a href=&quot;#一、三个模型的建模思想&quot; class=&quot;headerlink&quot; title=&quot;一、三个模型的建模思想&quot;&gt;&lt;/a&gt;一、三个模型的建模思想&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;h4 id=&quot;功能模型&quot;&gt;&lt;a href=&quot;#功能模型
      
    
    </summary>
    
      <category term="软件工程" scheme="http://wanqbin.xyz/categories/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"/>
    
    
      <category term="软件建模" scheme="http://wanqbin.xyz/tags/%E8%BD%AF%E4%BB%B6%E5%BB%BA%E6%A8%A1/"/>
    
      <category term="功能模型" scheme="http://wanqbin.xyz/tags/%E5%8A%9F%E8%83%BD%E6%A8%A1%E5%9E%8B/"/>
    
      <category term="数据库设计" scheme="http://wanqbin.xyz/tags/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1/"/>
    
      <category term="范式理论" scheme="http://wanqbin.xyz/tags/%E8%8C%83%E5%BC%8F%E7%90%86%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>软件需求分析</title>
    <link href="http://wanqbin.xyz/2019/06/15/%E8%BD%AF%E4%BB%B6%E9%9C%80%E6%B1%82%E5%88%86%E6%9E%90/"/>
    <id>http://wanqbin.xyz/2019/06/15/软件需求分析/</id>
    <published>2019-06-15T05:15:00.000Z</published>
    <updated>2019-06-15T05:15:34.389Z</updated>
    
    <content type="html"><![CDATA[<h4 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h4><p>&emsp;需求分析的输入是软件的《合同》或《立项建议书》，以及对用户现场的调研、分析和确认，输出是《用户需求报告》。</p><h2 id="一、需求分析是什么？"><a href="#一、需求分析是什么？" class="headerlink" title="一、需求分析是什么？"></a>一、需求分析是什么？</h2><p>&emsp;在对需求分析进行了解之前，得知道需求分析是什么。</p><p>&emsp;需求分析的定义如下：</p><ol><li>用户解决问题或达到目标所需的条件或能力</li><li>系统或系统部件要满足合同、标准、规范或其他正式文档规定所需具有的条件或能力</li><li>一种反映1或2所描述的条件或能力的文档说明</li></ol><p>&emsp;我对需求分析的定义时理解是，需求分析中的文档说明起到了至关重要的作用。</p><p>&emsp;当然对于一个软件系统来说，前期的需求分析是十分重要的，这几乎可以决定软件系统开发的成败。</p><h2 id="二、需求获取的三原则"><a href="#二、需求获取的三原则" class="headerlink" title="二、需求获取的三原则"></a>二、需求获取的三原则</h2><p>&emsp;所谓需求获取，就是开发者与用户共同提取并共同确认需求。“划分、抽象、投影”是需求获取的三要素。</p><ol><li>划分，就是捕获问题空间的“整体/部分”关系。</li><li>抽象，就是捕获问题空间的“一般/特殊”或“一般/特例”关系。</li><li>投影，就是捕获问题空间的多维”视图“。</li></ol><p>&emsp;我对这三原则的理解可能欠妥，但这是我在学习过程中的一些想法。首先，划分，就是将整个系统进行划分，将复杂的系统划分为小系统，这样不仅可以简化系统分析的难度，同时，由于对其进行了划分，所以在需求分析的时候，能够对系统的需求细节进行完善。</p><p>&emsp;其次是抽象，对于一个软件系统，能够实现功能的复用性是再好不过了，那么就需要对需求中的“特殊”扩展泛华为“一般”，依次来实现复用。</p><p>&emsp;最后是投影，程序的实质是对现实世界的投影，是对现实世界中不同角色工作流程或工作业务的抽象处理，而对于一个系统来说，操作它的可能有三种角色，比如，高层领导，中层管理和基层操作人员。而这三种角色的业务流程和工作业务是不同，需要从三维视图进行分析。</p><h2 id="三、需求分析的任务是什么？"><a href="#三、需求分析的任务是什么？" class="headerlink" title="三、需求分析的任务是什么？"></a>三、需求分析的任务是什么？</h2><ol><li>画出目标系统的组织结构图，列出各部门的岗位角色表，即组织机构模型。</li><li>画出目标系统的业务操作流程图，即业务模型。</li><li>画出目标系统的数据流图，即单据和报表的流图，掌握业务规则，获得初步的数据模型</li><li>列出目标系统的功能点列表，即功能模型。</li><li>列出系统的性能点列表，即性能模型。</li><li>确定目标系统的接口列表，即接口模型</li><li>确定目标系统的运行环境，即环境模型</li><li>目标系统的界面约定，即界面模型</li><li>对目标系统的开发工期、费用、开发进度、系统风险等问题进行分析和评估。</li></ol><h2 id="四、面向流程分析"><a href="#四、面向流程分析" class="headerlink" title="四、面向流程分析"></a>四、面向流程分析</h2><p>&emsp;需求分析是面向流程的，而流程是动态的、实时的。系统的功能、性能、接口、界面都是在流程中反映出来的。在所有的流程中，数据流最为很重要，同时也最具代表性。因为在计算机网络系统中，一切流程都表现为数据流。所以，面向流程分析，实质上是面向数据流程分析或面向数据分析。计算机网络只认识数据，其他所有信息必须转化为数据之后才能流动，所以面向流程分析本质上是面向数据流程分析。</p><h2 id="五、需求分析的方法有哪些？"><a href="#五、需求分析的方法有哪些？" class="headerlink" title="五、需求分析的方法有哪些？"></a>五、需求分析的方法有哪些？</h2><p>&emsp;业界存在三种需求分析方法，分别是：面向功能分析、面向对象分析、面向数据分析。</p><p>&emsp;面向功能分析，是将软件需求看做一棵倒置的功能树，树根在上，树枝与树叶在下，每个节点都是一项具体的功能，从上到下，功能由粗到细，树根是总功能，树叶是细功能，整棵树就是一个信息系统的全部功能树。功能分析体现了“自顶向下，逐步求精”的思想，适合于“结构化分析、结构化设计、结构化编程、结构化测试、结构化组装、结构化维护”的传统式软件工程思想。</p><p>&emsp;面向对象分析，实质上是面向类分析，它也从系统的基本功能入手，或从与系统有关的人和事入手，将所有的功能需求找出来，然后将每一项功能对应一个对象集（类），分析每个对象集的属性、方法和包装方式，最后归并为相同对象集，删除冗余属性，用类与类之间的关联来表示所有的需求。</p><p>&emsp;面向数据分析，是面向元数据和中间数据分析。</p><h2 id="六、需求分析的描述工具有哪些？"><a href="#六、需求分析的描述工具有哪些？" class="headerlink" title="六、需求分析的描述工具有哪些？"></a>六、需求分析的描述工具有哪些？</h2><ol><li><p>面向元数据的需求描述工具</p><p>实体关系图</p></li><li><p>面向过程的需求描述工具</p><p>数据流图DFD、数据字典DD</p></li><li><p>面向对象的需求描述工具</p><p>用例图、类图、</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h4&gt;&lt;p&gt;&amp;emsp;需求分析的输入是软件的《合同》或《立项建议书》，以及对用户现场的调研、分析和确认，输出是《用户需求报告》。&lt;/p
      
    
    </summary>
    
      <category term="软件工程" scheme="http://wanqbin.xyz/categories/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"/>
    
    
      <category term="需求分析" scheme="http://wanqbin.xyz/tags/%E9%9C%80%E6%B1%82%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>软件生命周期模型</title>
    <link href="http://wanqbin.xyz/2019/06/15/%E8%BD%AF%E4%BB%B6%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E6%A8%A1%E5%9E%8B/"/>
    <id>http://wanqbin.xyz/2019/06/15/软件生命周期模型/</id>
    <published>2019-06-15T05:13:00.000Z</published>
    <updated>2019-06-15T12:20:55.250Z</updated>
    
    <content type="html"><![CDATA[<h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>&emsp;开发一个软件项目，首先要选择并确定一个适合于该项目的软件生命周期模型，然后按照该软件生命周期模型的开发路线图，进行开发。</p><ol><li><h3 id="软件生命周期模型"><a href="#软件生命周期模型" class="headerlink" title="软件生命周期模型"></a>软件生命周期模型</h3><p>是指在整个软件生命周期中，软件开发过程应遵循的开发路线图。或者说，软件生命周期模型是软件开发全部过程、活动和任务的结构框架。</p></li><li><h3 id="软件生命周期的9个阶段"><a href="#软件生命周期的9个阶段" class="headerlink" title="软件生命周期的9个阶段"></a>软件生命周期的9个阶段</h3><p>1）立项（或签订合同）、下达任务书</p><p>2）需求分析</p><p>3）概要设计</p><p>4）详细设计</p><p>5）编码实现</p><p>6）软件测试</p><p>7）软件发布与实施</p><p>8）软件维护</p><p>9）版本更新或退役</p></li><li><h3 id="软件生命周期模型有哪些？"><a href="#软件生命周期模型有哪些？" class="headerlink" title="软件生命周期模型有哪些？"></a>软件生命周期模型有哪些？</h3><p>瀑布模型、增量模型、原型模型、迭代模型、螺旋模型、喷泉模型、XP模型</p></li><li><h3 id="瀑布模型是什么？"><a href="#瀑布模型是什么？" class="headerlink" title="瀑布模型是什么？"></a>瀑布模型是什么？</h3><p>具体的详细定义不再展开。</p><p>分为5个阶段：需求、设计、编码、测试、发布。自上而下。</p><p>首先，我们需要知道，瀑布模型师最早的软件生命周期模型，时至今日，仍然有强大的生命力，也是唯一被广泛使用的软件开发模型。</p><p>项目经理或软件管理人员，只要控制好每级台阶的高度和宽度，在每级台阶处设立里程碑或基线，并组织好对基线的评审，就可以控制好项目的开发成本、进度和质量。</p><p>但是，该模型的问题就在于阶梯，瀑布只能向下流，需要向上流的时候就需要付出很大的代价。这就是它的“问题堆积”，错误或发散扩大。</p><p>该模型的“问题堆积”并不是不可解决的，只要采用适合的管理方法，就可以控制或避免。比如微软公司采用的严格的里程碑管理制度。</p></li><li><h3 id="增量模型是什么？"><a href="#增量模型是什么？" class="headerlink" title="增量模型是什么？"></a>增量模型是什么？</h3><p>增量模型是遵循递增方式来进行软件开发的。</p><p>在增量模型中，软件产品被看成了一组增量构件或模块。每次需求分析、设计、实现、集成、测试和交付一块构件。</p><p>对于一个复杂的大型系统，采用分解的方式来将大系统分解成小系统，这样虽然可以将大风险分解成多个小风险，并逐步消除小风险。但是，将一个复杂的大型系统进行合理、有效的分解和划分是最难的地方。</p><p>同时，对大系统进行有效的分解和划分的前提是，该复杂系统可被分解。若复杂系统的拆卸性和组装性不强，那么，增量模型就不再适合该复杂系统的开发。</p></li><li><h3 id="原型模型"><a href="#原型模型" class="headerlink" title="原型模型"></a>原型模型</h3><p>原型模型的本意是在初步需求分析后，立马就向用户展示一个软件产品原型。</p><p>原型模型开发的过程中始终是以原型来驱动的，这很适合于那些已经有软件产品积累的公司。</p><p>但是，画画之前就已经知道画出来的结果是什么了，那么在画的过程中就很难有创新了。对于软件开发也是，这也是原型模型的主要缺点。</p></li><li><h3 id="迭代模型"><a href="#迭代模型" class="headerlink" title="迭代模型"></a>迭代模型</h3><p>迭代模型通过对各个工作流程的多次进行，更好地理解需求，从而可以设计出更为强壮的软件构架，逐步提高开发组织能力。</p><p>从宏观上看，迭代模型有4个状态阶段，分别是：先启、精化、构建和产品化。</p><p>而它的工作流程共有9个，分别是：<br>1）业务建模</p><p>2）需求获取</p><p>3）分析设计</p><p>4）实施</p><p>5）测试</p><p>6）部署</p><p>7）配置与变更管理</p><p>8）项目管理</p><p>9）环境</p><p>在这9个工作流程中，核心流程是业务建模，因为在迭代模型开发之前一定要有一个初始的业务模型，以便对其进行迭代。</p></li><li><h3 id="螺旋模型"><a href="#螺旋模型" class="headerlink" title="螺旋模型"></a>螺旋模型</h3><p>螺旋模型将瀑布模型和原型模型结合起来，特别强调风险分析，特别适用于大型复杂系统。</p></li><li><h3 id="喷泉模型"><a href="#喷泉模型" class="headerlink" title="喷泉模型"></a>喷泉模型</h3><p>喷泉模型认为，软件开发过程自上而下的各个阶段是相互重叠和多次反复进行的。</p><p>喷泉模型有大量的重叠，所以需要大量的开发人员，不利于项目的管理。</p></li><li><h3 id="XP模型"><a href="#XP模型" class="headerlink" title="XP模型"></a>XP模型</h3><p>XP模型即极限编程模型。本是敏捷文化现象。</p><p>XP模型通过需求、实现、重构、测试、发布的迭代过程，来实现一种轻量级的软件开发模型。</p><p>XP的核心要求是：交流、简单、进取、反馈</p><p>XP模型作为一种新的模型，在实际运用中存在较多的问题。同时，它与ISO 9001、CMMI的精神也存在冲突。</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h2&gt;&lt;p&gt;&amp;emsp;开发一个软件项目，首先要选择并确定一个适合于该项目的软件生命周期模型，然后按照该软件生命周期模型的开发路线图，进
      
    
    </summary>
    
      <category term="软件工程" scheme="http://wanqbin.xyz/categories/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"/>
    
    
      <category term="软件生命周期" scheme="http://wanqbin.xyz/tags/%E8%BD%AF%E4%BB%B6%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
    
      <category term="软件生命周期模型" scheme="http://wanqbin.xyz/tags/%E8%BD%AF%E4%BB%B6%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E6%A8%A1%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>软件工程的内容和方法</title>
    <link href="http://wanqbin.xyz/2019/06/14/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E7%9A%84%E5%86%85%E5%AE%B9%E5%92%8C%E6%96%B9%E6%B3%95/"/>
    <id>http://wanqbin.xyz/2019/06/14/软件工程的内容和方法/</id>
    <published>2019-06-13T16:11:00.000Z</published>
    <updated>2019-06-13T16:57:51.983Z</updated>
    
    <content type="html"><![CDATA[<h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>&emsp;经过一个礼拜的准备，终于结束了软件工程的复习。在复习软件工程的同时也在做信息系统综合设计的课程设计。在做课程设计的过程中，发现了软件工程的重要性和必要性。作为立志成为程序猿的我，软件工程在将来的工作中一定大有用处，故总结如下。</p><h2 id="一、软件、软件工程、软件工程学科体系"><a href="#一、软件、软件工程、软件工程学科体系" class="headerlink" title="一、软件、软件工程、软件工程学科体系"></a>一、软件、软件工程、软件工程学科体系</h2><p>学习软件工程，首先得知道软件是什么。其次，得知道软件工程是做什么的，它研究了什么内容，同时也应该知道软件工程学科体系是什么，与软件工程有什么关系。</p><ol><li><h4 id="软件：最新定义为，软件-知识-程序-数据-文档"><a href="#软件：最新定义为，软件-知识-程序-数据-文档" class="headerlink" title="软件：最新定义为，软件=知识+程序+数据+文档"></a>软件：最新定义为，软件=知识+程序+数据+文档</h4><p>那么这里面的知识，程序，数据，文档又是指什么呢？</p><p>知识，即各种各样的相关领域的专业知识。</p><p>程序，即使对计算机任务的处理对象和处理规则的描述。这里，我们一定要注意，软件并不等于程序，这也是一大误区。</p><p>数据，即程序赖以运行的初始化数据。</p><p>文档，即为了理解程序所需的详细描述性资料。</p></li><li><h4 id="软件工程是什么？"><a href="#软件工程是什么？" class="headerlink" title="软件工程是什么？"></a>软件工程是什么？</h4><p>软件工程是研究软件开发和管理的一门工程学科。</p><p>这个定义很短，但是知识点还是挺多的。一强调开发，毕竟开发是软件工程的主体；二强调管理或过程管理，当然，管理是为了更好的开发；三是强调工程，把软件的开发和维护当成一项工程，用工程的办法去开发，按工程的办法去管理；四是强调学科，时至今日，软件工程不只是一门学科，而是一个学科体系。这里也就引出了软件工程学科体系。</p><blockquote><p>软件工程来源于软件危机。软件工程是为了克服软件危机才产生的。</p></blockquote></li><li><h4 id="软件工程学科体系"><a href="#软件工程学科体系" class="headerlink" title="软件工程学科体系"></a>软件工程学科体系</h4><blockquote><p>软件工程作为一个学科体系，到21世纪才初步形成。2004年ACM和IEEE-CS联合制订了SWEBOK 2004版，它将软件工程学科体系的知识划分为10个知识域。</p></blockquote><p>对于这10个知识域，我的理解是它覆盖了整个软件生命周期。</p><p>1） 软件需求</p><p>2）软件设计</p><p>3）软件构造</p><p>4）软件测试</p><p>5）软件维护</p><p>6）软件配置管理</p><p>7）软件工程管理</p><p>8）软件工程过程</p><p>9）软件工程工具和方法</p><p>10）软件质量</p></li><li><h4 id="软件工程和软件工程学科体系的关系"><a href="#软件工程和软件工程学科体系的关系" class="headerlink" title="软件工程和软件工程学科体系的关系"></a>软件工程和软件工程学科体系的关系</h4><p>总体上来说，软件工程是一个局部问题，而软件工程学科体系是一个整体问题。</p></li><li><h4 id="软件工程研究的内容"><a href="#软件工程研究的内容" class="headerlink" title="软件工程研究的内容"></a>软件工程研究的内容</h4><p>软件工程研究的内容主要有五个方面。</p><p>一是软件生命周期模型</p><p>二是软件开发方法</p><p>三是软件支持过程</p><p>四是软件管理过程</p><p>五是软件工程标准与规范</p></li><li><h4 id="软件工程基本原理"><a href="#软件工程基本原理" class="headerlink" title="软件工程基本原理"></a>软件工程基本原理</h4><p>软件工程的三要素：方法、工具和过程</p><p>有7个基本原理，外加一个二八定律。具体内容见文章末尾的链接。</p></li><li><h4 id="软件工程在行业中的作用"><a href="#软件工程在行业中的作用" class="headerlink" title="软件工程在行业中的作用"></a>软件工程在行业中的作用</h4><p>软件工程作为一门工程管理学科，它对软件行业的作用毋庸置疑。那么，这里会有一个问题，既然已经有软件工程了，那么还会不会出现软件危机呢？我的答案是会的。软件工程的产生是为了克服软件危机，但是它的存在并不会完全消除软件危机。这和现实社会中法律存在的意义是相通的。法律的产生是为了消除犯罪，但是法律的存在并不会完全消除犯罪（至少在当前的社会阶段是不会的）。</p><p>软件工程可以作用到从业者，也可以作用到项目组，作用到软件公司，甚至作用到整个国家的软件产业1发展。</p></li></ol><h2 id="二、软件工程方法论和软件工程实践论"><a href="#二、软件工程方法论和软件工程实践论" class="headerlink" title="二、软件工程方法论和软件工程实践论"></a>二、软件工程方法论和软件工程实践论</h2><h4 id="1-软件工程方法论是什么？"><a href="#1-软件工程方法论是什么？" class="headerlink" title="1.  软件工程方法论是什么？"></a>1.  软件工程方法论是什么？</h4><p>软件工程方法论实质上是软件工程中软件开发方法的集合。</p><p>那么软件工程方法的集合包括哪些元素呢？</p><h4 id="2-软件工程方法集合"><a href="#2-软件工程方法集合" class="headerlink" title="2.  软件工程方法集合"></a>2.  软件工程方法集合</h4><p>软件工程方法集合包括面向过程方法、面向对象方法、面向元数据方法。</p><h4 id="3-为什么说面向对象方法可以描述无穷的信息世界呢？"><a href="#3-为什么说面向对象方法可以描述无穷的信息世界呢？" class="headerlink" title="3.  为什么说面向对象方法可以描述无穷的信息世界呢？"></a>3.  为什么说面向对象方法可以描述无穷的信息世界呢？</h4><p>要搞清楚面向对象为什么可以描述无穷的世界，首先需要知道面向对象方法是什么，其次，需要知道现实世界和软件的普遍联系。</p><p>面向对象方法是什么？是一种运用对象、类、消息传递、继承、封装、聚合、多态性等概念构造软件系统的软件开发方法。</p><p>我记得高中哲学里面听到的一句话，世界是物质的，物质是运动的，运动是有规律的。而对于软件而言，其实质是对现实人工系统的一种映射、优化和替换。通过对现实世界的分析，我们可以知道，世界是由对象组成的，对象之间时存在普遍联系的，而物质运动则说明了对象的功能。</p><p>面向方法是将这现实世界抽象映射为对象的手段。分析设计时由对象抽象出类，程序运行时由类还原到了对象。所以它能够描述无穷的信息世界。</p><h4 id="4-软件工程实践论是什么？"><a href="#4-软件工程实践论是什么？" class="headerlink" title="4.  软件工程实践论是什么？"></a>4.  软件工程实践论是什么？</h4><p>软件工程实践论是研究在开发一个大型软件系统时，到底应该怎样选取合适的开发方法。</p><h2 id="5-软件工程实践论指什么？"><a href="#5-软件工程实践论指什么？" class="headerlink" title="5.  软件工程实践论指什么？"></a>5.  软件工程实践论指什么？</h2><p>“五个面向”实践论，指面向流程分析、面向元数据设计、面向对象实现、面向功能测试、面向过程管理。</p><p>在后面，我们会发现软件工程的“五个面向”实践论在各个软件生命周期模型中都有一定的体现。</p><h2 id="三、软件支持过程、软件管理过程"><a href="#三、软件支持过程、软件管理过程" class="headerlink" title="三、软件支持过程、软件管理过程"></a>三、软件支持过程、软件管理过程</h2><ol><li><h4 id="软件过程是什么？"><a href="#软件过程是什么？" class="headerlink" title="软件过程是什么？"></a>软件过程是什么？</h4><p>软件过程，指软件生命周期中的时间序列</p></li><li><h4 id="软件支持过程是什么？"><a href="#软件支持过程是什么？" class="headerlink" title="软件支持过程是什么？"></a>软件支持过程是什么？</h4><p>软件支持过程，由支持软件生命周期模型各个阶段的生产工具组成。</p></li><li><h4 id="软件生命周期中的生产工具有哪些？"><a href="#软件生命周期中的生产工具有哪些？" class="headerlink" title="软件生命周期中的生产工具有哪些？"></a>软件生命周期中的生产工具有哪些？</h4><p>CASE工具、软件开发环境SDE、软件工程环境SEE</p></li><li><h4 id="软件管理是什么？"><a href="#软件管理是什么？" class="headerlink" title="软件管理是什么？"></a>软件管理是什么？</h4><p>管理过程和支持过程又称为“软件过程工程”。它是软件工程的一部分。</p><p>软件管理实质上是过程管理。</p></li><li><h4 id="软件管理有哪几类？"><a href="#软件管理有哪几类？" class="headerlink" title="软件管理有哪几类？"></a>软件管理有哪几类？</h4><p>ISO 9001质量管理和质量保证体系</p><p>CMMI软件能力成熟度模型</p><p>软件企业文化，包括微软企业文化，IBM企业文化，敏捷文化。</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h2&gt;&lt;p&gt;&amp;emsp;经过一个礼拜的准备，终于结束了软件工程的复习。在复习软件工程的同时也在做信息系统综合设计的课程设计。在做课程设计
      
    
    </summary>
    
      <category term="软件工程" scheme="http://wanqbin.xyz/categories/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"/>
    
    
      <category term="软件工程方法论" scheme="http://wanqbin.xyz/tags/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E6%96%B9%E6%B3%95%E8%AE%BA/"/>
    
  </entry>
  
</feed>

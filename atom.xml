<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Aoki&#39;s Blog</title>
  
  <subtitle>“吾生也有涯，而知无涯”</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://wanqbin.xyz/"/>
  <updated>2019-06-17T10:39:25.196Z</updated>
  <id>http://wanqbin.xyz/</id>
  
  <author>
    <name>Aoki</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>ASP.NET Core MVC 视图与控制器传值</title>
    <link href="http://wanqbin.xyz/2019/06/17/%E8%A7%86%E5%9B%BE%E4%B8%8E%E6%8E%A7%E5%88%B6%E5%99%A8%E4%BC%A0%E5%80%BC/"/>
    <id>http://wanqbin.xyz/2019/06/17/视图与控制器传值/</id>
    <published>2019-06-16T23:49:00.000Z</published>
    <updated>2019-06-17T10:39:25.196Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、form表单传值"><a href="#一、form表单传值" class="headerlink" title="一、form表单传值"></a>一、form表单传值</h2><ol><li><h4 id="View页面：GetFormValue-cshtml"><a href="#View页面：GetFormValue-cshtml" class="headerlink" title="View页面：GetFormValue.cshtml"></a>View页面：GetFormValue.cshtml</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>GetFormValue<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">asp-action</span>=<span class="string">"Home/GetFormValue"</span> <span class="attr">method</span>=<span class="string">"post"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">placeholder</span>=<span class="string">"名字"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">"submit"</span> <span class="attr">type</span>=<span class="string">"submit"</span>&gt;</span>提交<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在这个form表单中，用<code>asp-action=&quot;Home/GetFormValue&quot;</code>指定了表单中的值需要传到什么地方，其中<code>Home</code>代表控制器，<code>GetFromValue</code>代表Action。</p></li><li><h4 id="Action-GetFormValue"><a href="#Action-GetFormValue" class="headerlink" title="Action: GetFormValue"></a>Action: GetFormValue</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public IActionResult GetFormValue()</span><br><span class="line">        &#123;</span><br><span class="line">            return View();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        [HttpPost]</span><br><span class="line">        public IActionResult GetFormValue(string name)</span><br><span class="line">        &#123;</span><br><span class="line">            return View();</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p><code>GetFormValue</code>用来接受从视图传过来的值，这次传的是名字。</p></li><li><h4 id="页面输入"><a href="#页面输入" class="headerlink" title="页面输入"></a>页面输入</h4><p><img src="/2019/06/17/视图与控制器传值/2019061701.PNG" alt="Form表单传值"></p></li><li><h4 id="传值结果"><a href="#传值结果" class="headerlink" title="传值结果"></a>传值结果</h4><p><img src="/2019/06/17/视图与控制器传值/201906170102.PNG" alt="Form表单传值结果"></p></li></ol><h2 id="二、JS传值"><a href="#二、JS传值" class="headerlink" title="二、JS传值"></a>二、JS传值</h2><ol><li><h4 id="视图页面：GetJsValue-cshtml"><a href="#视图页面：GetJsValue-cshtml" class="headerlink" title="视图页面：GetJsValue.cshtml"></a>视图页面：GetJsValue.cshtml</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>GetFormValue<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">"testdata"</span> <span class="attr">type</span>=<span class="string">"text"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">"submitButton"</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">"提交"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> &gt;</span></span><br><span class="line">    var button = document.getElementById('submitButton');</span><br><span class="line">    button.onclick = function () &#123;</span><br><span class="line">        var data = $('#testdata').val();</span><br><span class="line">        $.post("Home/GetJsValue", &#123; name: data &#125;, function () &#123;</span><br><span class="line">            alert("submit data success!");</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><h4 id="Action：GetJsValue"><a href="#Action：GetJsValue" class="headerlink" title="Action：GetJsValue"></a>Action：GetJsValue</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public IActionResult GetJsValue()</span><br><span class="line">       &#123;</span><br><span class="line">           return View();</span><br><span class="line">       &#125;</span><br><span class="line">       [HttpPost]</span><br><span class="line">       public IActionResult GetJsValue(string name)</span><br><span class="line">       &#123;</span><br><span class="line">           return View();</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure></li><li><h4 id="页面输入-1"><a href="#页面输入-1" class="headerlink" title="页面输入"></a>页面输入</h4><p><img src="/2019/06/17/视图与控制器传值/201906170103.PNG" alt="JS传值页面输入"></p></li><li><h4 id="传值结果-1"><a href="#传值结果-1" class="headerlink" title="传值结果"></a>传值结果</h4><p><img src="/2019/06/17/视图与控制器传值/201906170104.PNG" alt="JS传值结果"></p></li></ol><h2 id="三、Jquery-AJAX方法传值"><a href="#三、Jquery-AJAX方法传值" class="headerlink" title="三、Jquery AJAX方法传值"></a>三、Jquery AJAX方法传值</h2><ol><li><h4 id="视图页面：GetJqueryValue-cshtml"><a href="#视图页面：GetJqueryValue-cshtml" class="headerlink" title="视图页面：GetJqueryValue.cshtml"></a>视图页面：GetJqueryValue.cshtml</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>GetJqueryValue<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">"testdata"</span> <span class="attr">type</span>=<span class="string">"text"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">"submitButton"</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">"提交"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">"~/js/jQuery.form.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">"~/js/jquery-1.12.4.min.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line">    $("#submitButton").click(function () &#123;</span><br><span class="line">        var name = $("#testdata").val();</span><br><span class="line">        $.ajax(&#123;</span><br><span class="line">            type: 'post',</span><br><span class="line">            url:'/Home/GetJqueryValue',</span><br><span class="line">            data: &#123; "name": name &#125;,</span><br><span class="line">            success: function (data) &#123;</span><br><span class="line">                alert("submit success");</span><br><span class="line">            &#125;,</span><br><span class="line">            error: function (data) &#123;</span><br><span class="line">                alert("failed");</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;);</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在使用jquery的ajax方法传递数据的时候，会出现<code>not defined</code>错误，网上查了一圈也没有解决，最后用上面的方式解决了。</p></li><li><h4 id="Action-GetJqueryValue"><a href="#Action-GetJqueryValue" class="headerlink" title="Action:GetJqueryValue"></a>Action:GetJqueryValue</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public IActionResult GetJqueryValue()</span><br><span class="line">       &#123;</span><br><span class="line">           return View();</span><br><span class="line">       &#125;</span><br><span class="line">       [HttpPost]</span><br><span class="line">       public IActionResult GetJqueryValue(string name)</span><br><span class="line">       &#123;</span><br><span class="line">           return View();</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure></li><li><h4 id="页面结果"><a href="#页面结果" class="headerlink" title="页面结果"></a>页面结果</h4><p><img src="/2019/06/17/视图与控制器传值/201906170106.PNG" alt="页面结果"></p></li><li><h4 id="传值结果-2"><a href="#传值结果-2" class="headerlink" title="传值结果"></a>传值结果</h4><p><img src="/2019/06/17/视图与控制器传值/2011906170105.PNG" alt="传值结果"></p></li></ol><h2 id="四、模型绑定"><a href="#四、模型绑定" class="headerlink" title="四、模型绑定"></a>四、模型绑定</h2><p>模型绑定就是将表单中的传递来的数据，创建对应的model并把数据赋给model的属性。我们能看到的就是表单传过来的数据是一个对象。</p><p>需要注意的是，传递每一项数据的名称和接受的类的属性名称必须相同。</p><ol><li><h4 id="Aoki类："><a href="#Aoki类：" class="headerlink" title="Aoki类："></a>Aoki类：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class Aoki</span><br><span class="line">   &#123;</span><br><span class="line">       [Required(ErrorMessage = &quot;尚有未填写项，请先完善&quot;)]</span><br><span class="line">       public string name &#123; get; set; &#125;</span><br><span class="line">       [Required(ErrorMessage = &quot;尚有未填写项，请先完善&quot;)]</span><br><span class="line">       public string description &#123; get; set; &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>对于Aoki类，我添加了模型验证，Required就是说这个属性不能为空，当表单中这个数据没有填写的时候，是无法提交的。当然，我觉得前端的验证有浏览器完成比较好一些。</p></li><li><h4 id="视图页面：GetModelValue-cshtml"><a href="#视图页面：GetModelValue-cshtml" class="headerlink" title="视图页面：GetModelValue.cshtml"></a>视图页面：GetModelValue.cshtml</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>GetModelValue<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">asp-action</span>=<span class="string">"Home/GetModelValue"</span> <span class="attr">method</span>=<span class="string">"post"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">placeholder</span>=<span class="string">"名字"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"description"</span> <span class="attr">placeholder</span>=<span class="string">"描述"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">"submit"</span> <span class="attr">type</span>=<span class="string">"submit"</span>&gt;</span>提交<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这里要注意的是，<code>name</code>必须和原有对象的属性名相同。</p></li><li><h4 id="Action-GetModelValue"><a href="#Action-GetModelValue" class="headerlink" title="Action:GetModelValue"></a>Action:GetModelValue</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public IActionResult GetModelValue()</span><br><span class="line">        &#123;</span><br><span class="line">            return View();</span><br><span class="line">        &#125;</span><br><span class="line">        [HttpPost]</span><br><span class="line">        public IActionResult GetModelValue(Aoki aoki)</span><br><span class="line">        &#123;</span><br><span class="line">            return View();</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>在第二个Action中会收到前端传过来的一个对象，这个对象的属性是和前端页面中表单中填写的数据绑定的。</p></li><li><h4 id="页面输入："><a href="#页面输入：" class="headerlink" title="页面输入："></a>页面输入：</h4><p><img src="/2019/06/17/视图与控制器传值/201906170108.PNG" alt="页面输入"></p></li><li><h4 id="传值结果："><a href="#传值结果：" class="headerlink" title="传值结果："></a>传值结果：</h4><p><img src="/2019/06/17/视图与控制器传值/201906170109.PNG" alt="传值结果"></p></li></ol><h2 id="五、定位标记帮助程序"><a href="#五、定位标记帮助程序" class="headerlink" title="五、定位标记帮助程序"></a>五、定位标记帮助程序</h2><p>标记帮助程序使服务器端代码可以在Razor文件中参与创建和呈现HTML元素。在下面的代码中，<code>AnchorTagHelper</code>从控制器操作方法和路由ID动态生成HTML<code>href</code>特性值。</p><ol><li><h4 id="视图页面：GetNum-cshtml"><a href="#视图页面：GetNum-cshtml" class="headerlink" title="视图页面：GetNum.cshtml"></a>视图页面：GetNum.cshtml</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>GetNum<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">table</span> <span class="attr">border</span>=<span class="string">"1"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">th</span>&gt;</span>名字<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">th</span>&gt;</span>描述<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">th</span>&gt;</span>操作<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">th</span>&gt;</span></span><br><span class="line">            Aoki</span><br><span class="line">        <span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">th</span>&gt;</span></span><br><span class="line">            试举头，一笑问青天、天无语</span><br><span class="line">        <span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">th</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">a</span> <span class="attr">asp-action</span>=<span class="string">"GetNum"</span> <span class="attr">asp-controller</span>=<span class="string">"Home"</span> <span class="attr">asp-route-ID</span>=<span class="string">"1"</span>&gt;</span>查看<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这里需要注意的是<code>asp-action</code>、<code>asp-controller</code>、<code>asp-route-ID</code>是生成URL。在<code>asp-route-ID</code>中值得注意的是，这里面的<code>ID</code>就是传递的参数，控制器里面的参数名字是什么，这里的<code>ID</code>就换成什么。否则会出错</p></li><li><h4 id="Action-GetNum"><a href="#Action-GetNum" class="headerlink" title="Action:GetNum"></a>Action:GetNum</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public IActionResult GetNum(int ID)</span><br><span class="line">        &#123;</span><br><span class="line">            return View();</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></li><li><h4 id="页面结果-1"><a href="#页面结果-1" class="headerlink" title="页面结果"></a>页面结果</h4><p><img src="/2019/06/17/视图与控制器传值/201906170112.PNG" alt="页面"></p><p>鼠标悬停在查看按钮上，下方会出现URL。如图所示。</p><p><img src="/2019/06/17/视图与控制器传值/201906170114.png" alt="URL"></p><p>在浏览器中“查看源”，生成的HTML的部分如下如图所示。</p><p><img src="/2019/06/17/视图与控制器传值/201906170113.PNG" alt="HTML"></p></li><li><h4 id="传值结果-3"><a href="#传值结果-3" class="headerlink" title="传值结果"></a>传值结果</h4><p><img src="/2019/06/17/视图与控制器传值/201906170111.PNG" alt="传值结果"></p></li></ol><p>&emsp;&emsp;<a href="https://github.com/Aoki-Wang/CheckStation/tree/master/%E6%8E%A7%E5%88%B6%E5%99%A8%E4%B8%8E%E8%A7%86%E5%9B%BE%E4%B9%8B%E9%97%B4%E4%BC%A0%E5%80%BC/WebApplication1" target="_blank" rel="noopener">获得源码</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、form表单传值&quot;&gt;&lt;a href=&quot;#一、form表单传值&quot; class=&quot;headerlink&quot; title=&quot;一、form表单传值&quot;&gt;&lt;/a&gt;一、form表单传值&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;h4 id=&quot;View页面：GetFormValue-csht
      
    
    </summary>
    
      <category term="ASP.NET Core MVC" scheme="http://wanqbin.xyz/categories/ASP-NET-Core-MVC/"/>
    
    
      <category term="ASP.NET Core" scheme="http://wanqbin.xyz/tags/ASP-NET-Core/"/>
    
      <category term="视图与控制器" scheme="http://wanqbin.xyz/tags/%E8%A7%86%E5%9B%BE%E4%B8%8E%E6%8E%A7%E5%88%B6%E5%99%A8/"/>
    
      <category term="传值" scheme="http://wanqbin.xyz/tags/%E4%BC%A0%E5%80%BC/"/>
    
  </entry>
  
  <entry>
    <title>ASP.NET Core MVC控制器与视图传值</title>
    <link href="http://wanqbin.xyz/2019/06/16/ASP-NET-Core-MVC%E6%8E%A7%E5%88%B6%E5%99%A8%E4%B8%8E%E8%A7%86%E5%9B%BE%E4%BC%A0%E5%80%BC/"/>
    <id>http://wanqbin.xyz/2019/06/16/ASP-NET-Core-MVC控制器与视图传值/</id>
    <published>2019-06-16T08:31:00.000Z</published>
    <updated>2019-06-16T17:05:55.415Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、传值方式"><a href="#一、传值方式" class="headerlink" title="一、传值方式"></a>一、传值方式</h2><ul><li>弱类型参数传递数据</li><li>强类型参数传递数据</li></ul><h2 id="二、弱类型参数传递数据"><a href="#二、弱类型参数传递数据" class="headerlink" title="二、弱类型参数传递数据"></a>二、弱类型参数传递数据</h2><ol><li><h2 id="ViewData"><a href="#ViewData" class="headerlink" title="ViewData"></a>ViewData</h2><p>1）派生自ViewDataDictionary，因此它有可用的字典属性，如，ContainsKey、Add、Remove、Clear</p></li></ol><p>&emsp;    2）字典中键是字符串，所以允许有空格</p><p>&emsp;    3）任何非string类型均须在试图中进行强制转换才能使用ViewData</p><ol start="2"><li><h2 id="ViewBag"><a href="#ViewBag" class="headerlink" title="ViewBag"></a>ViewBag</h2><p>1）派生自DynamicViewData，因此它可使用点表示法（<code>ViewBag.name=name</code>)创建动态属性，且无需强制转换</p><p>2) ViewBag的语法使控制器到视图的速度更快</p><p>3) ViewBag更易于检查NULL值</p></li></ol><h3 id="3-ViewData的使用"><a href="#3-ViewData的使用" class="headerlink" title="3. ViewData的使用"></a>3. ViewData的使用</h3><p>1）创建Action：Index</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public IActionResult Index()</span><br><span class="line">        &#123;</span><br><span class="line">            ViewData[&quot;name&quot;] = &quot;Aoki&quot;;</span><br><span class="line">            ViewData[&quot;description&quot;] = &quot;试举头，一笑问青天、天无语&quot;;</span><br><span class="line">            return View();</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>2）创建视图：Index.cshtml</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"text-center"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>@ViewData["name"]<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>@ViewData["description"]<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>3）实现结果：</p><p><img src="/2019/06/16/ASP-NET-Core-MVC控制器与视图传值/viewdata.PNG" alt="结果"></p><h3 id="4-ViewBag的使用"><a href="#4-ViewBag的使用" class="headerlink" title="4. ViewBag的使用"></a>4. ViewBag的使用</h3><p>1）创建Action：Index</p><p>\ASP-NET-Core-MVC控制器与视图传值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public IActionResult Index()</span><br><span class="line">        &#123;</span><br><span class="line">            ViewBag.type = &quot;ViewBag&quot;;</span><br><span class="line">            ViewBag.name = &quot;Aoki&quot;;</span><br><span class="line">            ViewBag.description = &quot;试举头，一笑问青天、天无语&quot;;</span><br><span class="line">            return View();</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>2）创建视图：Index.cshtml</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"text-center"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>@ViewBag.name<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>@ViewBag.description<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h4</span>&gt;</span>Pass the value through @ViewBag.type<span class="tag">&lt;/<span class="name">h4</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>3）实现结果</p><p><img src="/2019/06/16/ASP-NET-Core-MVC控制器与视图传值/viewbag.PNG" alt="结果"></p><h2 id="三、强类型参数传递数据"><a href="#三、强类型参数传递数据" class="headerlink" title="三、强类型参数传递数据"></a>三、强类型参数传递数据</h2><ol><li><h3 id="强类型参数说明"><a href="#强类型参数说明" class="headerlink" title="强类型参数说明"></a>强类型参数说明</h3><p>&emsp;&emsp;视图强类型通常称为ViewModel，可以在<code>return View();</code>时指定参数/对象。并在视图文件（.cshtml）中通过<code>@model</code>语法来指定对应的类型。</p></li><li><h3 id="强类型参数示例"><a href="#强类型参数示例" class="headerlink" title="强类型参数示例"></a>强类型参数示例</h3><p>1）创建Aoki类</p></li></ol>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public class Aoki</span><br><span class="line">    &#123;</span><br><span class="line">        public string name &#123; get; set; &#125;</span><br><span class="line">        public string description &#123; get; set; &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>   2）创建Action：Index</p>   <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public IActionResult Index()</span><br><span class="line">        &#123;</span><br><span class="line">            var aoki = new Aoki</span><br><span class="line">            &#123;</span><br><span class="line">                name = "Aoki",</span><br><span class="line">                description = "试举头，一笑问青天、天无语"</span><br><span class="line">            &#125;;</span><br><span class="line">            return View(aoki);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>   3）创建视图：Index.cshtml</p>   <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"text-center"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>@Model.name<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>@Model.description<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>   4）实现结果</p><p>   <img src="/2019/06/16/ASP-NET-Core-MVC控制器与视图传值/Model.PNG" alt="结果"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、传值方式&quot;&gt;&lt;a href=&quot;#一、传值方式&quot; class=&quot;headerlink&quot; title=&quot;一、传值方式&quot;&gt;&lt;/a&gt;一、传值方式&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;弱类型参数传递数据&lt;/li&gt;
&lt;li&gt;强类型参数传递数据&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;
      
    
    </summary>
    
      <category term="ASP.NET Core MVC" scheme="http://wanqbin.xyz/categories/ASP-NET-Core-MVC/"/>
    
    
      <category term="ASP.NET Core" scheme="http://wanqbin.xyz/tags/ASP-NET-Core/"/>
    
      <category term="MVC" scheme="http://wanqbin.xyz/tags/MVC/"/>
    
  </entry>
  
  <entry>
    <title>软件管理</title>
    <link href="http://wanqbin.xyz/2019/06/16/%E7%AE%A1%E7%90%86/"/>
    <id>http://wanqbin.xyz/2019/06/16/管理/</id>
    <published>2019-06-15T16:58:00.000Z</published>
    <updated>2019-06-15T17:20:37.863Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、软件过程改进模型CMMI"><a href="#一、软件过程改进模型CMMI" class="headerlink" title="一、软件过程改进模型CMMI"></a>一、软件过程改进模型CMMI</h2><p>软件组织的产品质量和服务质量，来自组织内部的过程改进状态。而过程改进是要有模型的，模型是实践、理论、方法、经验和技术的结晶，是软件组织的一种企业文化、工作环境和管理理念；模型能够引导企业从杂乱无章的管理状态到有条不紊的管理状态。</p><p>目前为止，IT企业界的过程管理和过程改进模型共有三个类型：</p><ul><li>ISO 9001 模型</li><li>CMMI模型</li><li>软件企业文化模型<ul><li>微软企业文化</li><li>IBM企业文化</li><li>敏捷文化现象</li></ul></li></ul><ol><li><h4 id="CMMI是什么"><a href="#CMMI是什么" class="headerlink" title="CMMI是什么"></a>CMMI是什么</h4><p>软件能力成熟度模型CMMI是由美国卡内基-梅隆大学软件工程研究所推出的评估软件能力与成熟度等级的一套标准。</p></li><li><h4 id="CMMI的作用是什么"><a href="#CMMI的作用是什么" class="headerlink" title="CMMI的作用是什么"></a>CMMI的作用是什么</h4><ul><li>软件组织，用它来不断改进自身的软件过程管理能力</li><li>评估机构，用它来评估某软件组织当前软件能力成熟度级别</li><li>客户，用它来评估某承包商的软件能力</li></ul></li><li><h4 id="CMMI的实质"><a href="#CMMI的实质" class="headerlink" title="CMMI的实质"></a>CMMI的实质</h4><ul><li>以“过程”为核心，抓软件组织的管理，即软件“组织”的过程改进</li><li>以“项目”为手段，抓团队开发过程的“活动”，即落实过程改进的措施</li><li>以“活动”记录为基础，抓软件过程的“度量”，即“度量”软件组织改进的情况</li></ul></li><li><h4 id="CMMI阶段模型的成熟度等级"><a href="#CMMI阶段模型的成熟度等级" class="headerlink" title="CMMI阶段模型的成熟度等级"></a>CMMI阶段模型的成熟度等级</h4></li></ol><table><thead><tr><th>CMMI等级</th><th>PA数目</th><th>管理特点</th></tr></thead><tbody><tr><td>ML1:初始级</td><td>0</td><td>过程不可预测且缺乏控制</td></tr><tr><td>ML2：已管理级</td><td>7</td><td>过程为项目服务，即项目级管理</td></tr><tr><td>ML3：已定义级</td><td>11</td><td>过程为组织服务，即组织级管理</td></tr><tr><td>ML4：定量管理级</td><td>2</td><td>过程已度量和控制，即定量级管理</td></tr><tr><td>ML5：优化级</td><td>2</td><td>集中于过程改进，即优化管理级</td></tr></tbody></table><ol start="5"><li><h4 id="ISO-9001与CMMI的联系和区别"><a href="#ISO-9001与CMMI的联系和区别" class="headerlink" title="ISO 9001与CMMI的联系和区别"></a>ISO 9001与CMMI的联系和区别</h4><p>&emsp;&emsp;与ISO 9001标准相比，CMMI更为软件产业所看好。原因是CMMI专门针对软件工程控制而设置。它不仅进行软件企业工程能力的评估，更致力于软件开发过程的管理，强调对软件开发过程进行持续改进，引导软件开发过程走向成熟。</p><p>&emsp;&emsp;两者的相同点是：CMMI和ISO 9001标准都致力于质量和过程管理，都是为了解决同样的问题。</p><p>&emsp;&emsp;两者的不同点是：CMMI是动态的、开放的和持续改进的，它强调“没有最好，只有更好”，强调不断改进，强调人在软件开发方面的主动性，非常适用于软件过程改进；ISO 9001是静态的质量控制，只要达到20个关键指标或过程，就能完成质量控制，它更适用于硬件制造行业和第三产业的质量控制。CMMI与IO 9001的设计思路有差异：CMMI是“专用的”，ISO 9001是“通用”的。ISO 9001不覆盖CMMI，CMMI也不覆盖ISO 9001.</p></li></ol><h2 id="二、软件配置管理"><a href="#二、软件配置管理" class="headerlink" title="二、软件配置管理"></a>二、软件配置管理</h2><p>软件配置管理SCM是对软件开发过程中配置项的一组追踪和控制活动，它开始于软件开发之初，结束于软件淘汰之时。</p><h2 id="三、软件质量保证"><a href="#三、软件质量保证" class="headerlink" title="三、软件质量保证"></a>三、软件质量保证</h2><p>软件质量保证SQA是一个过程，是CMMI和ISO 9001的重要议题，同样也是项目管理的重要议题。</p><p>软件质量，是供方提供的软件产品满足用户明确或隐含需求的能力特性的总和。</p><ol><li><h4 id="质量管理的三大支柱"><a href="#质量管理的三大支柱" class="headerlink" title="质量管理的三大支柱"></a>质量管理的三大支柱</h4><ul><li>质量标准</li><li>配置管理</li><li>测试测量</li></ul></li><li><h4 id="质量管理的三大要素"><a href="#质量管理的三大要素" class="headerlink" title="质量管理的三大要素"></a>质量管理的三大要素</h4><ul><li>SQA计划</li><li>SQA进度</li><li>SQA评审和审计</li></ul></li></ol><h2 id="四、软件项目管理"><a href="#四、软件项目管理" class="headerlink" title="四、软件项目管理"></a>四、软件项目管理</h2><ol><li><h4 id="什么是项目"><a href="#什么是项目" class="headerlink" title="什么是项目"></a>什么是项目</h4><p>项目，是一次性的多任务工作，它具有确定的开始日期，结束日期，工作范围，经费预算，质量标准，以及特定的功能、性能和接口要求。</p></li><li><h4 id="什么是项目管理"><a href="#什么是项目管理" class="headerlink" title="什么是项目管理"></a>什么是项目管理</h4><p>项目管理，是为了实现项目目标，运用相关知识、技能、方法与工具，对项目的计划、进度、质量、成本、资源进行管理和控制的活动。</p></li><li><h4 id="项目经理的七项职责"><a href="#项目经理的七项职责" class="headerlink" title="项目经理的七项职责"></a>项目经理的七项职责</h4><ul><li>抓需求获取与确认</li><li>抓计划制订与执行</li><li>抓团队分工与协作</li><li>抓后勤供应与保障</li><li>抓产品测试和交付</li><li>抓开发标准与规范</li><li>抓员工考核与奖励</li></ul></li><li><h4 id="项目经理对程序员的八项要求"><a href="#项目经理对程序员的八项要求" class="headerlink" title="项目经理对程序员的八项要求"></a>项目经理对程序员的八项要求</h4><ul><li>团队协作精神的训练和要求</li><li>数据库和数据结构分析与设计能力的训练和要求</li><li>书写文档习惯的训练和要求</li><li>规范化代码编写能力的训练和要求</li><li>复用性能力与构件技术的训练和要求</li><li>测试习惯的训练和要求</li><li>学习和总结能力的训练和要求</li><li>引导程序员由“丑小鸭”变成“白天鹅”</li></ul></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、软件过程改进模型CMMI&quot;&gt;&lt;a href=&quot;#一、软件过程改进模型CMMI&quot; class=&quot;headerlink&quot; title=&quot;一、软件过程改进模型CMMI&quot;&gt;&lt;/a&gt;一、软件过程改进模型CMMI&lt;/h2&gt;&lt;p&gt;软件组织的产品质量和服务质量，来自组织内部的
      
    
    </summary>
    
      <category term="软件工程" scheme="http://wanqbin.xyz/categories/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"/>
    
    
      <category term="CMMI" scheme="http://wanqbin.xyz/tags/CMMI/"/>
    
      <category term="软件管理" scheme="http://wanqbin.xyz/tags/%E8%BD%AF%E4%BB%B6%E7%AE%A1%E7%90%86/"/>
    
      <category term="项目管理" scheme="http://wanqbin.xyz/tags/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/"/>
    
      <category term="软件质量保证" scheme="http://wanqbin.xyz/tags/%E8%BD%AF%E4%BB%B6%E8%B4%A8%E9%87%8F%E4%BF%9D%E8%AF%81/"/>
    
      <category term="项目经理" scheme="http://wanqbin.xyz/tags/%E9%A1%B9%E7%9B%AE%E7%BB%8F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>软件实施与维护</title>
    <link href="http://wanqbin.xyz/2019/06/16/%E5%AE%9E%E6%96%BD%E4%B8%8E%E7%BB%B4%E6%8A%A4-1/"/>
    <id>http://wanqbin.xyz/2019/06/16/实施与维护-1/</id>
    <published>2019-06-15T16:18:00.000Z</published>
    <updated>2019-06-15T16:22:17.255Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、软件产品"><a href="#一、软件产品" class="headerlink" title="一、软件产品"></a>一、软件产品</h2><ol><li><p>软件企业开发的软件可以分为软件项目和软件产品。</p></li><li><p>软件产品分为三类分别是：</p></li></ol><table><thead><tr><th>类别</th><th>产品特点</th><th>举例</th></tr></thead><tbody><tr><td>1</td><td>不需要客户化的产品</td><td>系统软件</td></tr><tr><td>2</td><td>只需要少量客户化工作的产品</td><td>专业性特强的应用软件产品</td></tr><tr><td>3</td><td>需要重新做业务流程规范和需求规格定义的软件产品</td><td>分行业ERP</td></tr></tbody></table><ol start="3"><li><p>项目与产品的区别与联系</p><p>除了上述三类软件产品外，其他软件一般称为软件项目，不能叫软件产品。</p><p>软件项目就是为用户定制的软件系统，它的专业性强，通用性差，从需求分析、设计、编码、测试，到安装、试运行、正式运行，直至验收交付，整个开发流程一步都不能省。</p><p>软件项目的特点是，业务领域知识所占比重大，工程性强，因此用CMMI模型实现规范化管理和量化控制比较适合。IT企业做软件项目的目的，一般都是为了将软件项目逐步产品化，如同做财务项目是为了做财务产品一样。一方面，只有产品化了才能赚取最大的利润，另一方面，只有拥有自己的软件产品，才能在投标活动中获得更大更好的项目。</p><p>项目和产品既有显著的不同，又有紧密的关系。这种关系是：做软件项目是手段，做软件产品是目的，软件项目做多了，软件项目就慢慢变成了软件产品。</p></li></ol><h2 id="二、软件产品的发布"><a href="#二、软件产品的发布" class="headerlink" title="二、软件产品的发布"></a>二、软件产品的发布</h2><p>&emsp;&emsp;产品的发布时机，是由市场利润、开发进度、产品的功能与质量、客户可接受程度等多方面因素决定的。</p><h2 id="三、软件产品的实施"><a href="#三、软件产品的实施" class="headerlink" title="三、软件产品的实施"></a>三、软件产品的实施</h2><p>软件产品发布以后，销售中心就会获取各种客户信息，并准备用各种方式为客户服务。在服务中，需要各种销售技术人员的支持，这些技术人员包括售前、售中、售后三部分人员。售前技术人员称为售前工程师，售中技术人员称为实施工程师，售后技术人员称为维护工程师。</p><h2 id="四、软件维护的传统方法"><a href="#四、软件维护的传统方法" class="headerlink" title="四、软件维护的传统方法"></a>四、软件维护的传统方法</h2><p>软件维护，是指软件项目或产品爱安装、运行并交付给用户使用后，在新产品升级之前这段时间里，软件厂商向客户提供的服务工作。</p><ol><li><h4 id="软件维护的分类"><a href="#软件维护的分类" class="headerlink" title="软件维护的分类"></a>软件维护的分类</h4></li></ol><table><thead><tr><th>序号</th><th>维护的种类</th><th>维护的内容</th></tr></thead><tbody><tr><td>1</td><td>纠错性维护</td><td>产品或项目中存在缺陷或错误，在测试和验收时未发现，到了使用过程中逐渐暴露出来，需要改正。</td></tr><tr><td>2</td><td>适应性维护</td><td>这类维护是为了产品或项目适应变化了的硬件、系统软件的运行环境，如系统升级</td></tr><tr><td>3</td><td>完善性维护</td><td>这类维护是为了给软件系统增加一些新的功能，使产品或项目更加完善与合理，又不至于对系统进行伤筋动骨的改造，这类维护占维护的大部分</td></tr><tr><td>4</td><td>预防性维护</td><td>这类维护是为了提高产品或项目的可靠性和可维护性，有利于系统的进一步改造或升级换代</td></tr></tbody></table><ol start="2"><li><h4 id="软件维护的副作用"><a href="#软件维护的副作用" class="headerlink" title="软件维护的副作用"></a>软件维护的副作用</h4></li></ol><table><thead><tr><th>序号</th><th>维护的方式</th><th>副作用的表现</th></tr></thead><tbody><tr><td>1</td><td>修改编码</td><td>使编码更加混乱，程序结构更不清晰，可读性更差，而且会有连锁反应</td></tr><tr><td>2</td><td>修改数据结构</td><td>数据结构是系统的骨架，修改数据结构是对系统伤筋动骨的大手术，在数据冗余与数据不一致方面，可能顾此失彼</td></tr><tr><td>3</td><td>修改用户数据</td><td>需要与用户协商，一旦有疏忽，可使系统发生意外</td></tr><tr><td>4</td><td>修改文档</td><td>对非结构化维护不适应，对结构化维护要严防程序与文档的不匹配</td></tr></tbody></table><h2 id="五、软件维护的最新方法"><a href="#五、软件维护的最新方法" class="headerlink" title="五、软件维护的最新方法"></a>五、软件维护的最新方法</h2><ol><li><h4 id="软件维护的最新分类方法"><a href="#软件维护的最新分类方法" class="headerlink" title="软件维护的最新分类方法"></a>软件维护的最新分类方法</h4><ul><li>面向缺陷维护——程序级维护</li><li>面向功能维护——设计级维护</li></ul></li><li><h4 id="软件维护的最新方法"><a href="#软件维护的最新方法" class="headerlink" title="软件维护的最新方法"></a>软件维护的最新方法</h4><ul><li>基于两层结构（客户机/服务器）划分软件维护的方法</li><li>基于三层结构划分软件维护的方法</li><li>基于“三种开发方法”，来划分软件维护的方法</li></ul></li><li><h4 id="软件维护工作流程"><a href="#软件维护工作流程" class="headerlink" title="软件维护工作流程"></a>软件维护工作流程</h4></li></ol><table><thead><tr><th>流程步骤</th><th>流程内容</th></tr></thead><tbody><tr><td>1</td><td>分类整理用户意见</td></tr><tr><td>2</td><td>提出维护申请</td></tr><tr><td>3</td><td>评审、审计、批准维护申请</td></tr><tr><td>4</td><td>修改需求文档</td></tr><tr><td>5</td><td>维护需求文档评审</td></tr><tr><td>6</td><td>维护设计文档</td></tr><tr><td>7</td><td>维护设计文档评审</td></tr><tr><td>8</td><td>修改源程序</td></tr><tr><td>9</td><td>回归测试</td></tr><tr><td>10</td><td>修改软件版本号</td></tr><tr><td>11</td><td>交付用户运行</td></tr><tr><td>12</td><td>收集用户反馈意见，准备进行新一轮维护活动，转向流程第1个步骤</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、软件产品&quot;&gt;&lt;a href=&quot;#一、软件产品&quot; class=&quot;headerlink&quot; title=&quot;一、软件产品&quot;&gt;&lt;/a&gt;一、软件产品&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;软件企业开发的软件可以分为软件项目和软件产品。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;软件产品
      
    
    </summary>
    
      <category term="软件工程" scheme="http://wanqbin.xyz/categories/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"/>
    
    
      <category term="软件维护" scheme="http://wanqbin.xyz/tags/%E8%BD%AF%E4%BB%B6%E7%BB%B4%E6%8A%A4/"/>
    
      <category term="软件产品" scheme="http://wanqbin.xyz/tags/%E8%BD%AF%E4%BB%B6%E4%BA%A7%E5%93%81/"/>
    
      <category term="软件项目" scheme="http://wanqbin.xyz/tags/%E8%BD%AF%E4%BB%B6%E9%A1%B9%E7%9B%AE/"/>
    
  </entry>
  
  <entry>
    <title>软件设计、实现与测试</title>
    <link href="http://wanqbin.xyz/2019/06/15/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E3%80%81%E5%AE%9E%E7%8E%B0%E3%80%81%E6%B5%8B%E8%AF%95/"/>
    <id>http://wanqbin.xyz/2019/06/15/软件设计、实现、测试/</id>
    <published>2019-06-15T15:47:00.000Z</published>
    <updated>2019-06-15T15:48:08.791Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、软件设计"><a href="#一、软件设计" class="headerlink" title="一、软件设计"></a>一、软件设计</h2><ol><li><h4 id="三层结构设计"><a href="#三层结构设计" class="headerlink" title="三层结构设计"></a>三层结构设计</h4><p>1）表示层：也称浏览层，通常采用图形化界面，在客户端PC或工作站上运行。站在“三个模型”的思想上看，系统内部支持表示层的模型是“功能模型”。</p><p>&emsp;表示层的主要功能：</p><p>&emsp;1)接受用户请求，将这些请求反馈给业务逻辑层，等待业务逻辑层的应答信息。</p><p>&emsp;2）对业务逻辑层的应答信息进行显示</p><p>&emsp;3）有时会兼做一些业务逻辑层的小功能</p><p>2）中间层（业务层）：它由许多构件和组件组成，它们完全体现了用户的业务逻辑或业务规则，站在“三个模型”建模思想上看，系统内部支持业务层的模型是“业务模型”。</p><p>&emsp;业务层的主要功能：</p><p>&emsp;1）接受从表示层传来的用户请求信息</p><p>&emsp;2）根据用户的请求信息生成SQL语句</p><p>&emsp;3)利用生成的SQL语句从数据层取数据、修改数据、删除数据</p><p>&emsp;4）将结果返回表示层</p><p>中间层也可以分为两个子层，分别是业务逻辑层和数据访问层。</p><p>在这段时间的信息系统设计中我深有体会，将虽然三层结构从一定程度上可以降低系统的耦合度，但是如果数据层出现问题，需要进行调整，那么中间层也要进行大规模的调整，这对系统的实现进度是有害的。如果将中间层划分为两个子层，那么，如果数据层出现问题，进行了大规模调整，那么我们的业务逻辑层是不会受到影响的，只需要对数据访问层进行适当的修改。</p><p>3）数据层：是数据库服务器上的数据库层，它包括数据库管理系统DBMS和数据库DB两部分。站在“三个模型”建模思想上看，系统内部支持数据层的模型是“数据模型”。</p><p>&emsp;数据层的功能：</p><p>&emsp;1）接受业务层数据处理请求的SQL语句或存储过程</p><p>&emsp;2）利用SQL语句或存储过程，对数据库服务器上数据库的相关表进行存储或检索</p><p>&emsp;3）将存储或检索的结果传递给业务层。</p></li><li><h4 id="软件设计原理"><a href="#软件设计原理" class="headerlink" title="软件设计原理"></a>软件设计原理</h4><p>软件设计原理，就是各种软件设计方法中都应该遵守的共同基本原理。这些原理包括：抽象、模块化、信息隐藏、模块独立性、封装、接口和实现分离。</p><p>1）抽象。</p><p>在每个阶段中，抽象的层次逐步降低，在软件结构设计中的模块分层也是由抽象到具体分析和构造出来的。抽象就是将几个有区别的物体的共同性质或特性，形象地抽取出来，独立地进行考虑的过程。</p><p>常用的抽象技术有：控制抽象、过程抽象、数据抽象</p><p>2）模块化。</p><p>模块指程序中的数据说明、可执行语句等程序对象的集合，或单独命名和编程的元素。</p><p>模块化，就是解决一个复杂问题时，自顶向下、逐步求精地把软件系统划分为若干模块的过程。为了解决复杂的问题，在软件设计中，必须把整个问题分解来降低复杂性，以减小开发工作量，降低开发成本，提高软件生产率。但是模块并不是越多越好，因为这会增加模块之间的接口量。所以划分模块的层次和数量应该避免过多或过少。</p><p>3）信息隐藏。</p><p>信息隐藏，指在设计和确定模块时，使一个模块内包含的信息，对于不需要这些信息的其他模块来说是不能访问的。</p><p>4）模块独立性。</p><p>模块独立性指每个模块只完成系统要求的独立的子功能，并且与其他模块的联系最少，且接口简单。模块独立性是抽象、模块化、信息隐藏的直接产物，在概要设计的过程中，就是要设计出具有良好模块独立性的软件结构。用来衡量软件模块独立性的定性度量标准有：高内聚、低耦合</p><p>5）封装。</p><p>封装是将信息隐藏在一个实体中，使其内部细节对外不可见。封装是实现“低耦合、高内聚”的技术手段之一。要进行正确的封装，必须遵守的原则是：</p><ul><li>实体间相互隐藏内部实现</li><li>尽量减少全局的共享数据</li></ul><p>6）接口和实现分离</p><p>将接口与实现分离，对外只提供接口，隐藏具体的实现。接口与实现的分离，保证了实现的独立变化，降低了模块间的耦合。</p></li></ol><h2 id="二、三种设计方法"><a href="#二、三种设计方法" class="headerlink" title="二、三种设计方法"></a>二、三种设计方法</h2><ol><li><h4 id="面向过程设计"><a href="#面向过程设计" class="headerlink" title="面向过程设计"></a>面向过程设计</h4><p>1）面向过程概要设计的主要方法有：</p><ul><li>功能模块分解方法</li><li>功能模块调用方法</li><li>功能模块转化方法</li><li>数据流图转换为层次结构图方法</li></ul><p>2）面向过程设计技术，采用“自顶向下、逐步求精”的设计方法和“单入口、单出口”的控制结构，并且只包含顺序、选择和循环三种结构，设计目标之一是使程序的控制流程线性化，即程序的动态执行顺序符合静态书写结构。</p><p>3）详细设计的工具有：程序流程图、N-S图、程序设计语言PDL、PAD图等</p></li><li><h4 id="面向对象设计"><a href="#面向对象设计" class="headerlink" title="面向对象设计"></a>面向对象设计</h4><p>面向对象设计描述工具：</p><p>1）系统静态建模图（结构图）</p><ul><li><p>类图</p></li><li><p>部件图</p><p>部件图比类图在更高层次上体现了系统中部件、部件接口以及部件之间的关系。</p></li><li><p>部署图</p><p>表示运行时处理元素（节点）的物理配置情况。</p></li><li><p>界面图</p></li></ul><p>2）系统动态建模（行为图）</p><ul><li><p>用例图</p></li><li><p>顺序图</p><p>&emsp;&emsp;顺序图是系统的动态视图，表示系统基于时间序列的操作。在顺序图中可以包括与系统交互的角色。顺序图以一个二维视图展现交互过程，垂直方向上是时间轴，水平方向上是参与交互的对象或角色。</p><p>&emsp;&emsp;顺序图是类图的补充，类图是系统的静态视图，顺序图反映了系统的动态视图。通常先绘制用例图，接着根据用例图中涉及的实体绘制类图，再绘制顺序图来展现用例的交互过程。</p></li><li><p>状态图</p><p>&emsp;&emsp;状态图是状态机图形化的表现，用于描述用例、部件或类的行为。状态图对实体的有限状态、事件和状态间的转换进行建模。</p></li><li><p>活动图</p><p>&emsp;&emsp;活动图描述的是执行某个功能的活动。</p></li></ul></li><li><h4 id="面向元数据设计"><a href="#面向元数据设计" class="headerlink" title="面向元数据设计"></a>面向元数据设计</h4><p>&emsp;&emsp;面向元数据设计，以实体-关系模型为基础，按照一定的规则将概念模型CDM转换成为能被某种数据库管理系统接受的物理数据模型PDM，创建物理上的数据库表、索引和视图，并且用存储过程和触发器来实现各种业务规则。</p></li></ol><h2 id="三、软件实现"><a href="#三、软件实现" class="headerlink" title="三、软件实现"></a>三、软件实现</h2><ol><li><p>构件：就是被标识的且可被复用的软件制品。</p></li><li><p>中间件：是一个非常大的组件（构件），一般在网络上运行，完成批量数据的传递和通信工作，调用方式是通过一组事先约定的格式与参数进行的。</p></li><li><p>软件实现原则</p><ul><li>尽可能简单。在软件实现过程中，应创建简单、容易阅读的代码；相同功能的代码只写一次；简单的代码易于维护；通过采用一些编码规范和标准，可以有效地降低代码的复杂度。</li><li>易于验证。无论是在编码、测试和实际操作中，软件工程师应该很容易发现其中的错误；自动化的单元测试可产生易于验证的代码；写代码时，要限制使用复杂的难以理解的语言结构</li><li>适应变化。外部环境、软件需求和软件设计，在整个开发过程中可能会随时发生变化，因此要求软件实现时考虑适应这些变化</li><li>遵守某一编程规范。尽量使用了标准库函数和公共函数。不要随意定义全局变量，尽量使用局部变量。使用括号避免二义性。</li><li>选择项目组成员最熟悉的工具或语言。</li></ul><p>除此之外，除了特殊要求之外，任何程序必须遵守”可读性第一、效率第二“的实现原则。</p></li></ol><h2 id="四、软件测试"><a href="#四、软件测试" class="headerlink" title="四、软件测试"></a>四、软件测试</h2><p>在另外的一些文章或资料中有所涉及和详细解释。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、软件设计&quot;&gt;&lt;a href=&quot;#一、软件设计&quot; class=&quot;headerlink&quot; title=&quot;一、软件设计&quot;&gt;&lt;/a&gt;一、软件设计&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;h4 id=&quot;三层结构设计&quot;&gt;&lt;a href=&quot;#三层结构设计&quot; class=&quot;headerl
      
    
    </summary>
    
      <category term="软件工程" scheme="http://wanqbin.xyz/categories/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"/>
    
    
      <category term="软件设计" scheme="http://wanqbin.xyz/tags/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1/"/>
    
      <category term="软件实现" scheme="http://wanqbin.xyz/tags/%E8%BD%AF%E4%BB%B6%E5%AE%9E%E7%8E%B0/"/>
    
      <category term="三层结构" scheme="http://wanqbin.xyz/tags/%E4%B8%89%E5%B1%82%E7%BB%93%E6%9E%84/"/>
    
      <category term="软件设计原理" scheme="http://wanqbin.xyz/tags/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>软件建模</title>
    <link href="http://wanqbin.xyz/2019/06/15/%E8%BD%AF%E4%BB%B6%E5%BB%BA%E6%A8%A1/"/>
    <id>http://wanqbin.xyz/2019/06/15/软件建模/</id>
    <published>2019-06-15T15:46:00.000Z</published>
    <updated>2019-06-15T15:46:54.288Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、三个模型的建模思想"><a href="#一、三个模型的建模思想" class="headerlink" title="一、三个模型的建模思想"></a>一、三个模型的建模思想</h2><ol><li><h4 id="功能模型"><a href="#功能模型" class="headerlink" title="功能模型"></a>功能模型</h4><p>功能模型，实质上是用户需求模型，用来描述系统能做什么，即对系统的功能、性能、接口和界面进行定义。</p><p>从用户角度来看，功能模型就是系统功能需求列表</p><p>从设计者的角度看，功能模型就是系统内部功能模块的有机排列和组合</p><p>从Rose的角度上看，功能模型就是系统的用例的集合</p><p>从产品的角度看，功能模型就是系统的用户操作手册</p><p>从操作界面的角度上看，功能模型就是系统的功能菜单</p><p>从B/A/S的角度上看，功能模型就对应在浏览层上建模</p></li><li><h4 id="业务模型"><a href="#业务模型" class="headerlink" title="业务模型"></a>业务模型</h4><p>业务模型，实质上是业务逻辑模型，用于描述系统在何时、何地、由何角色、按什么业务规则去做、以及做什么的流程或步骤，即对系统的操作流程进行定义。</p><p>业务模型反映了系统的业务行为，是算法设计的主要依据。站在B/A/S的角度上看，业务模型就对应在中间层（业务逻辑层或业务应用层）上建模。</p></li><li><h4 id="数据模型"><a href="#数据模型" class="headerlink" title="数据模型"></a>数据模型</h4><p>数据模型实质上是实体或类的状态关系模型，用于描述系统工作前的数据来自何处、工作中的数据暂存在什么地方、工作后的数据放到哪儿、以及这些数据的状态及相互之间的关联，即对系统的数据结构进行定义。</p></li></ol><h2 id="二、数据模型设计"><a href="#二、数据模型设计" class="headerlink" title="二、数据模型设计"></a>二、数据模型设计</h2><ol><li><h4 id="什么是好的数据模型？"><a href="#什么是好的数据模型？" class="headerlink" title="什么是好的数据模型？"></a>什么是好的数据模型？</h4><p>条件有三：</p><p>1）满足功能需求</p><p>2）满足性能需求</p><p>3）该模型能够长期使用，也就是“以不变应万变</p></li><li><h4 id="数据库的基本表、代码表、中间表和临时表"><a href="#数据库的基本表、代码表、中间表和临时表" class="headerlink" title="数据库的基本表、代码表、中间表和临时表"></a>数据库的基本表、代码表、中间表和临时表</h4><p>存放元素数据的表，称为基本表</p><p>存放信息代码的表，称为代码表</p><p>存放统计信息的表，称为中间表（又称查询表）</p><p>存放临时数据的表，称为临时表</p></li><li><h4 id="基本表的4个特性："><a href="#基本表的4个特性：" class="headerlink" title="基本表的4个特性："></a>基本表的4个特性：</h4><p>1）原子性：基本表中的字段是不可再分解的。</p><p>2）原始性：基本表中的记录是原始数据记录。</p><p>3）演绎性：由基本表与代码表中的数据可以派生出所有的输出数据。</p><p>4）稳定性：基本表的结构是相对稳定的，表中的记录需要长期保存。</p></li><li><h4 id="数据库设计的步骤："><a href="#数据库设计的步骤：" class="headerlink" title="数据库设计的步骤："></a>数据库设计的步骤：</h4><p>1）将原始单据分类整理，理清原始单据与输出数据之间的数据转换关系和算法，澄清一切不确定的问题。</p><p>2）从原始单据出发，划分出各个实体，给实体命名，初步分配属性，标识出主键或外键，理清实体之间的关系。</p><p>3）进行数据库概念数据模型设计，画出实体关系图ERD，定义完整性约束</p><p>4）进行数据库物理数据模型PDM设计，将概念模型CDM转换为物理数据模型PDM</p><p>5）在待定对的数据库管理系统上定义表空间，实现物理建表与建索引</p><p>6）定义触发器与存储过程</p><p>7）定义视图，说明数据库与应用程序之间的关系</p><p>8）数据库加载测试：向基表中追加记录，对数据库的功能、性能进行全面测试</p><p>9）数据库性能优化：从数据库系统的参数配置、数据库设计的反规范化两个方面，对数据库的性能进行优化</p><p>10）数据库设计评审：从数据库的整体功能和性能两个方面，请同行专家评审评价</p></li></ol><h2 id="三、数据库设计理论与方法"><a href="#三、数据库设计理论与方法" class="headerlink" title="三、数据库设计理论与方法"></a>三、数据库设计理论与方法</h2><ol><li><h4 id="数据库范式理论"><a href="#数据库范式理论" class="headerlink" title="数据库范式理论"></a>数据库范式理论</h4><p>1NF，关系模式中的关系的每个分量都是不可再分的数据项</p><p>2NF，满足1NF，且每一非主属性完全函数依赖于候选键</p><p>3NF，消除非主属性对候选键的传递依赖</p></li><li><h4 id="数据库设计中的“第三者插足”设计模式"><a href="#数据库设计中的“第三者插足”设计模式" class="headerlink" title="数据库设计中的“第三者插足”设计模式"></a>数据库设计中的“第三者插足”设计模式</h4><p>当两个实体之间存在多对关系时，必须在它们之间插入第三个实体，以化解这种多对多关系。</p></li><li><h4 id="数据库设计中的“列变行”模式"><a href="#数据库设计中的“列变行”模式" class="headerlink" title="数据库设计中的“列变行”模式"></a>数据库设计中的“列变行”模式</h4><p>就是将第一个表中的某些列，变为第二个表中的某些行。</p></li><li><h4 id="数据库设计中的四个原子化理论"><a href="#数据库设计中的四个原子化理论" class="headerlink" title="数据库设计中的四个原子化理论"></a>数据库设计中的四个原子化理论</h4><p>站在数据库设计者的角度看，只要实现属性原子化、实体原子化、主键原子化、联系原子化，数据的所谓更新异常、插入异常、删除异常、数据冗余现象就从根本上消除了。</p><p>属性原子化：实体的属性本身不能再分解</p><p>实体原子化：实体本身不能再分解</p><p>主键原子化：是指实体的主键本身是一个ID（identifier）</p><p>联系原子化：是指实体之间的联系都是一对多联系。</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、三个模型的建模思想&quot;&gt;&lt;a href=&quot;#一、三个模型的建模思想&quot; class=&quot;headerlink&quot; title=&quot;一、三个模型的建模思想&quot;&gt;&lt;/a&gt;一、三个模型的建模思想&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;h4 id=&quot;功能模型&quot;&gt;&lt;a href=&quot;#功能模型
      
    
    </summary>
    
      <category term="软件工程" scheme="http://wanqbin.xyz/categories/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"/>
    
    
      <category term="软件建模" scheme="http://wanqbin.xyz/tags/%E8%BD%AF%E4%BB%B6%E5%BB%BA%E6%A8%A1/"/>
    
      <category term="功能模型" scheme="http://wanqbin.xyz/tags/%E5%8A%9F%E8%83%BD%E6%A8%A1%E5%9E%8B/"/>
    
      <category term="数据库设计" scheme="http://wanqbin.xyz/tags/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1/"/>
    
      <category term="范式理论" scheme="http://wanqbin.xyz/tags/%E8%8C%83%E5%BC%8F%E7%90%86%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>软件需求分析</title>
    <link href="http://wanqbin.xyz/2019/06/15/%E8%BD%AF%E4%BB%B6%E9%9C%80%E6%B1%82%E5%88%86%E6%9E%90/"/>
    <id>http://wanqbin.xyz/2019/06/15/软件需求分析/</id>
    <published>2019-06-15T05:15:00.000Z</published>
    <updated>2019-06-15T05:15:34.389Z</updated>
    
    <content type="html"><![CDATA[<h4 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h4><p>&emsp;需求分析的输入是软件的《合同》或《立项建议书》，以及对用户现场的调研、分析和确认，输出是《用户需求报告》。</p><h2 id="一、需求分析是什么？"><a href="#一、需求分析是什么？" class="headerlink" title="一、需求分析是什么？"></a>一、需求分析是什么？</h2><p>&emsp;在对需求分析进行了解之前，得知道需求分析是什么。</p><p>&emsp;需求分析的定义如下：</p><ol><li>用户解决问题或达到目标所需的条件或能力</li><li>系统或系统部件要满足合同、标准、规范或其他正式文档规定所需具有的条件或能力</li><li>一种反映1或2所描述的条件或能力的文档说明</li></ol><p>&emsp;我对需求分析的定义时理解是，需求分析中的文档说明起到了至关重要的作用。</p><p>&emsp;当然对于一个软件系统来说，前期的需求分析是十分重要的，这几乎可以决定软件系统开发的成败。</p><h2 id="二、需求获取的三原则"><a href="#二、需求获取的三原则" class="headerlink" title="二、需求获取的三原则"></a>二、需求获取的三原则</h2><p>&emsp;所谓需求获取，就是开发者与用户共同提取并共同确认需求。“划分、抽象、投影”是需求获取的三要素。</p><ol><li>划分，就是捕获问题空间的“整体/部分”关系。</li><li>抽象，就是捕获问题空间的“一般/特殊”或“一般/特例”关系。</li><li>投影，就是捕获问题空间的多维”视图“。</li></ol><p>&emsp;我对这三原则的理解可能欠妥，但这是我在学习过程中的一些想法。首先，划分，就是将整个系统进行划分，将复杂的系统划分为小系统，这样不仅可以简化系统分析的难度，同时，由于对其进行了划分，所以在需求分析的时候，能够对系统的需求细节进行完善。</p><p>&emsp;其次是抽象，对于一个软件系统，能够实现功能的复用性是再好不过了，那么就需要对需求中的“特殊”扩展泛华为“一般”，依次来实现复用。</p><p>&emsp;最后是投影，程序的实质是对现实世界的投影，是对现实世界中不同角色工作流程或工作业务的抽象处理，而对于一个系统来说，操作它的可能有三种角色，比如，高层领导，中层管理和基层操作人员。而这三种角色的业务流程和工作业务是不同，需要从三维视图进行分析。</p><h2 id="三、需求分析的任务是什么？"><a href="#三、需求分析的任务是什么？" class="headerlink" title="三、需求分析的任务是什么？"></a>三、需求分析的任务是什么？</h2><ol><li>画出目标系统的组织结构图，列出各部门的岗位角色表，即组织机构模型。</li><li>画出目标系统的业务操作流程图，即业务模型。</li><li>画出目标系统的数据流图，即单据和报表的流图，掌握业务规则，获得初步的数据模型</li><li>列出目标系统的功能点列表，即功能模型。</li><li>列出系统的性能点列表，即性能模型。</li><li>确定目标系统的接口列表，即接口模型</li><li>确定目标系统的运行环境，即环境模型</li><li>目标系统的界面约定，即界面模型</li><li>对目标系统的开发工期、费用、开发进度、系统风险等问题进行分析和评估。</li></ol><h2 id="四、面向流程分析"><a href="#四、面向流程分析" class="headerlink" title="四、面向流程分析"></a>四、面向流程分析</h2><p>&emsp;需求分析是面向流程的，而流程是动态的、实时的。系统的功能、性能、接口、界面都是在流程中反映出来的。在所有的流程中，数据流最为很重要，同时也最具代表性。因为在计算机网络系统中，一切流程都表现为数据流。所以，面向流程分析，实质上是面向数据流程分析或面向数据分析。计算机网络只认识数据，其他所有信息必须转化为数据之后才能流动，所以面向流程分析本质上是面向数据流程分析。</p><h2 id="五、需求分析的方法有哪些？"><a href="#五、需求分析的方法有哪些？" class="headerlink" title="五、需求分析的方法有哪些？"></a>五、需求分析的方法有哪些？</h2><p>&emsp;业界存在三种需求分析方法，分别是：面向功能分析、面向对象分析、面向数据分析。</p><p>&emsp;面向功能分析，是将软件需求看做一棵倒置的功能树，树根在上，树枝与树叶在下，每个节点都是一项具体的功能，从上到下，功能由粗到细，树根是总功能，树叶是细功能，整棵树就是一个信息系统的全部功能树。功能分析体现了“自顶向下，逐步求精”的思想，适合于“结构化分析、结构化设计、结构化编程、结构化测试、结构化组装、结构化维护”的传统式软件工程思想。</p><p>&emsp;面向对象分析，实质上是面向类分析，它也从系统的基本功能入手，或从与系统有关的人和事入手，将所有的功能需求找出来，然后将每一项功能对应一个对象集（类），分析每个对象集的属性、方法和包装方式，最后归并为相同对象集，删除冗余属性，用类与类之间的关联来表示所有的需求。</p><p>&emsp;面向数据分析，是面向元数据和中间数据分析。</p><h2 id="六、需求分析的描述工具有哪些？"><a href="#六、需求分析的描述工具有哪些？" class="headerlink" title="六、需求分析的描述工具有哪些？"></a>六、需求分析的描述工具有哪些？</h2><ol><li><p>面向元数据的需求描述工具</p><p>实体关系图</p></li><li><p>面向过程的需求描述工具</p><p>数据流图DFD、数据字典DD</p></li><li><p>面向对象的需求描述工具</p><p>用例图、类图、</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h4&gt;&lt;p&gt;&amp;emsp;需求分析的输入是软件的《合同》或《立项建议书》，以及对用户现场的调研、分析和确认，输出是《用户需求报告》。&lt;/p
      
    
    </summary>
    
      <category term="软件工程" scheme="http://wanqbin.xyz/categories/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"/>
    
    
      <category term="需求分析" scheme="http://wanqbin.xyz/tags/%E9%9C%80%E6%B1%82%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>软件生命周期模型</title>
    <link href="http://wanqbin.xyz/2019/06/15/%E8%BD%AF%E4%BB%B6%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E6%A8%A1%E5%9E%8B/"/>
    <id>http://wanqbin.xyz/2019/06/15/软件生命周期模型/</id>
    <published>2019-06-15T05:13:00.000Z</published>
    <updated>2019-06-15T12:20:55.250Z</updated>
    
    <content type="html"><![CDATA[<h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>&emsp;开发一个软件项目，首先要选择并确定一个适合于该项目的软件生命周期模型，然后按照该软件生命周期模型的开发路线图，进行开发。</p><ol><li><h3 id="软件生命周期模型"><a href="#软件生命周期模型" class="headerlink" title="软件生命周期模型"></a>软件生命周期模型</h3><p>是指在整个软件生命周期中，软件开发过程应遵循的开发路线图。或者说，软件生命周期模型是软件开发全部过程、活动和任务的结构框架。</p></li><li><h3 id="软件生命周期的9个阶段"><a href="#软件生命周期的9个阶段" class="headerlink" title="软件生命周期的9个阶段"></a>软件生命周期的9个阶段</h3><p>1）立项（或签订合同）、下达任务书</p><p>2）需求分析</p><p>3）概要设计</p><p>4）详细设计</p><p>5）编码实现</p><p>6）软件测试</p><p>7）软件发布与实施</p><p>8）软件维护</p><p>9）版本更新或退役</p></li><li><h3 id="软件生命周期模型有哪些？"><a href="#软件生命周期模型有哪些？" class="headerlink" title="软件生命周期模型有哪些？"></a>软件生命周期模型有哪些？</h3><p>瀑布模型、增量模型、原型模型、迭代模型、螺旋模型、喷泉模型、XP模型</p></li><li><h3 id="瀑布模型是什么？"><a href="#瀑布模型是什么？" class="headerlink" title="瀑布模型是什么？"></a>瀑布模型是什么？</h3><p>具体的详细定义不再展开。</p><p>分为5个阶段：需求、设计、编码、测试、发布。自上而下。</p><p>首先，我们需要知道，瀑布模型师最早的软件生命周期模型，时至今日，仍然有强大的生命力，也是唯一被广泛使用的软件开发模型。</p><p>项目经理或软件管理人员，只要控制好每级台阶的高度和宽度，在每级台阶处设立里程碑或基线，并组织好对基线的评审，就可以控制好项目的开发成本、进度和质量。</p><p>但是，该模型的问题就在于阶梯，瀑布只能向下流，需要向上流的时候就需要付出很大的代价。这就是它的“问题堆积”，错误或发散扩大。</p><p>该模型的“问题堆积”并不是不可解决的，只要采用适合的管理方法，就可以控制或避免。比如微软公司采用的严格的里程碑管理制度。</p></li><li><h3 id="增量模型是什么？"><a href="#增量模型是什么？" class="headerlink" title="增量模型是什么？"></a>增量模型是什么？</h3><p>增量模型是遵循递增方式来进行软件开发的。</p><p>在增量模型中，软件产品被看成了一组增量构件或模块。每次需求分析、设计、实现、集成、测试和交付一块构件。</p><p>对于一个复杂的大型系统，采用分解的方式来将大系统分解成小系统，这样虽然可以将大风险分解成多个小风险，并逐步消除小风险。但是，将一个复杂的大型系统进行合理、有效的分解和划分是最难的地方。</p><p>同时，对大系统进行有效的分解和划分的前提是，该复杂系统可被分解。若复杂系统的拆卸性和组装性不强，那么，增量模型就不再适合该复杂系统的开发。</p></li><li><h3 id="原型模型"><a href="#原型模型" class="headerlink" title="原型模型"></a>原型模型</h3><p>原型模型的本意是在初步需求分析后，立马就向用户展示一个软件产品原型。</p><p>原型模型开发的过程中始终是以原型来驱动的，这很适合于那些已经有软件产品积累的公司。</p><p>但是，画画之前就已经知道画出来的结果是什么了，那么在画的过程中就很难有创新了。对于软件开发也是，这也是原型模型的主要缺点。</p></li><li><h3 id="迭代模型"><a href="#迭代模型" class="headerlink" title="迭代模型"></a>迭代模型</h3><p>迭代模型通过对各个工作流程的多次进行，更好地理解需求，从而可以设计出更为强壮的软件构架，逐步提高开发组织能力。</p><p>从宏观上看，迭代模型有4个状态阶段，分别是：先启、精化、构建和产品化。</p><p>而它的工作流程共有9个，分别是：<br>1）业务建模</p><p>2）需求获取</p><p>3）分析设计</p><p>4）实施</p><p>5）测试</p><p>6）部署</p><p>7）配置与变更管理</p><p>8）项目管理</p><p>9）环境</p><p>在这9个工作流程中，核心流程是业务建模，因为在迭代模型开发之前一定要有一个初始的业务模型，以便对其进行迭代。</p></li><li><h3 id="螺旋模型"><a href="#螺旋模型" class="headerlink" title="螺旋模型"></a>螺旋模型</h3><p>螺旋模型将瀑布模型和原型模型结合起来，特别强调风险分析，特别适用于大型复杂系统。</p></li><li><h3 id="喷泉模型"><a href="#喷泉模型" class="headerlink" title="喷泉模型"></a>喷泉模型</h3><p>喷泉模型认为，软件开发过程自上而下的各个阶段是相互重叠和多次反复进行的。</p><p>喷泉模型有大量的重叠，所以需要大量的开发人员，不利于项目的管理。</p></li><li><h3 id="XP模型"><a href="#XP模型" class="headerlink" title="XP模型"></a>XP模型</h3><p>XP模型即极限编程模型。本是敏捷文化现象。</p><p>XP模型通过需求、实现、重构、测试、发布的迭代过程，来实现一种轻量级的软件开发模型。</p><p>XP的核心要求是：交流、简单、进取、反馈</p><p>XP模型作为一种新的模型，在实际运用中存在较多的问题。同时，它与ISO 9001、CMMI的精神也存在冲突。</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h2&gt;&lt;p&gt;&amp;emsp;开发一个软件项目，首先要选择并确定一个适合于该项目的软件生命周期模型，然后按照该软件生命周期模型的开发路线图，进
      
    
    </summary>
    
      <category term="软件工程" scheme="http://wanqbin.xyz/categories/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"/>
    
    
      <category term="软件生命周期" scheme="http://wanqbin.xyz/tags/%E8%BD%AF%E4%BB%B6%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
    
      <category term="软件生命周期模型" scheme="http://wanqbin.xyz/tags/%E8%BD%AF%E4%BB%B6%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E6%A8%A1%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>软件工程的内容和方法</title>
    <link href="http://wanqbin.xyz/2019/06/14/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E7%9A%84%E5%86%85%E5%AE%B9%E5%92%8C%E6%96%B9%E6%B3%95/"/>
    <id>http://wanqbin.xyz/2019/06/14/软件工程的内容和方法/</id>
    <published>2019-06-13T16:11:00.000Z</published>
    <updated>2019-06-13T16:57:51.983Z</updated>
    
    <content type="html"><![CDATA[<h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>&emsp;经过一个礼拜的准备，终于结束了软件工程的复习。在复习软件工程的同时也在做信息系统综合设计的课程设计。在做课程设计的过程中，发现了软件工程的重要性和必要性。作为立志成为程序猿的我，软件工程在将来的工作中一定大有用处，故总结如下。</p><h2 id="一、软件、软件工程、软件工程学科体系"><a href="#一、软件、软件工程、软件工程学科体系" class="headerlink" title="一、软件、软件工程、软件工程学科体系"></a>一、软件、软件工程、软件工程学科体系</h2><p>学习软件工程，首先得知道软件是什么。其次，得知道软件工程是做什么的，它研究了什么内容，同时也应该知道软件工程学科体系是什么，与软件工程有什么关系。</p><ol><li><h4 id="软件：最新定义为，软件-知识-程序-数据-文档"><a href="#软件：最新定义为，软件-知识-程序-数据-文档" class="headerlink" title="软件：最新定义为，软件=知识+程序+数据+文档"></a>软件：最新定义为，软件=知识+程序+数据+文档</h4><p>那么这里面的知识，程序，数据，文档又是指什么呢？</p><p>知识，即各种各样的相关领域的专业知识。</p><p>程序，即使对计算机任务的处理对象和处理规则的描述。这里，我们一定要注意，软件并不等于程序，这也是一大误区。</p><p>数据，即程序赖以运行的初始化数据。</p><p>文档，即为了理解程序所需的详细描述性资料。</p></li><li><h4 id="软件工程是什么？"><a href="#软件工程是什么？" class="headerlink" title="软件工程是什么？"></a>软件工程是什么？</h4><p>软件工程是研究软件开发和管理的一门工程学科。</p><p>这个定义很短，但是知识点还是挺多的。一强调开发，毕竟开发是软件工程的主体；二强调管理或过程管理，当然，管理是为了更好的开发；三是强调工程，把软件的开发和维护当成一项工程，用工程的办法去开发，按工程的办法去管理；四是强调学科，时至今日，软件工程不只是一门学科，而是一个学科体系。这里也就引出了软件工程学科体系。</p><blockquote><p>软件工程来源于软件危机。软件工程是为了克服软件危机才产生的。</p></blockquote></li><li><h4 id="软件工程学科体系"><a href="#软件工程学科体系" class="headerlink" title="软件工程学科体系"></a>软件工程学科体系</h4><blockquote><p>软件工程作为一个学科体系，到21世纪才初步形成。2004年ACM和IEEE-CS联合制订了SWEBOK 2004版，它将软件工程学科体系的知识划分为10个知识域。</p></blockquote><p>对于这10个知识域，我的理解是它覆盖了整个软件生命周期。</p><p>1） 软件需求</p><p>2）软件设计</p><p>3）软件构造</p><p>4）软件测试</p><p>5）软件维护</p><p>6）软件配置管理</p><p>7）软件工程管理</p><p>8）软件工程过程</p><p>9）软件工程工具和方法</p><p>10）软件质量</p></li><li><h4 id="软件工程和软件工程学科体系的关系"><a href="#软件工程和软件工程学科体系的关系" class="headerlink" title="软件工程和软件工程学科体系的关系"></a>软件工程和软件工程学科体系的关系</h4><p>总体上来说，软件工程是一个局部问题，而软件工程学科体系是一个整体问题。</p></li><li><h4 id="软件工程研究的内容"><a href="#软件工程研究的内容" class="headerlink" title="软件工程研究的内容"></a>软件工程研究的内容</h4><p>软件工程研究的内容主要有五个方面。</p><p>一是软件生命周期模型</p><p>二是软件开发方法</p><p>三是软件支持过程</p><p>四是软件管理过程</p><p>五是软件工程标准与规范</p></li><li><h4 id="软件工程基本原理"><a href="#软件工程基本原理" class="headerlink" title="软件工程基本原理"></a>软件工程基本原理</h4><p>软件工程的三要素：方法、工具和过程</p><p>有7个基本原理，外加一个二八定律。具体内容见文章末尾的链接。</p></li><li><h4 id="软件工程在行业中的作用"><a href="#软件工程在行业中的作用" class="headerlink" title="软件工程在行业中的作用"></a>软件工程在行业中的作用</h4><p>软件工程作为一门工程管理学科，它对软件行业的作用毋庸置疑。那么，这里会有一个问题，既然已经有软件工程了，那么还会不会出现软件危机呢？我的答案是会的。软件工程的产生是为了克服软件危机，但是它的存在并不会完全消除软件危机。这和现实社会中法律存在的意义是相通的。法律的产生是为了消除犯罪，但是法律的存在并不会完全消除犯罪（至少在当前的社会阶段是不会的）。</p><p>软件工程可以作用到从业者，也可以作用到项目组，作用到软件公司，甚至作用到整个国家的软件产业1发展。</p></li></ol><h2 id="二、软件工程方法论和软件工程实践论"><a href="#二、软件工程方法论和软件工程实践论" class="headerlink" title="二、软件工程方法论和软件工程实践论"></a>二、软件工程方法论和软件工程实践论</h2><h4 id="1-软件工程方法论是什么？"><a href="#1-软件工程方法论是什么？" class="headerlink" title="1.  软件工程方法论是什么？"></a>1.  软件工程方法论是什么？</h4><p>软件工程方法论实质上是软件工程中软件开发方法的集合。</p><p>那么软件工程方法的集合包括哪些元素呢？</p><h4 id="2-软件工程方法集合"><a href="#2-软件工程方法集合" class="headerlink" title="2.  软件工程方法集合"></a>2.  软件工程方法集合</h4><p>软件工程方法集合包括面向过程方法、面向对象方法、面向元数据方法。</p><h4 id="3-为什么说面向对象方法可以描述无穷的信息世界呢？"><a href="#3-为什么说面向对象方法可以描述无穷的信息世界呢？" class="headerlink" title="3.  为什么说面向对象方法可以描述无穷的信息世界呢？"></a>3.  为什么说面向对象方法可以描述无穷的信息世界呢？</h4><p>要搞清楚面向对象为什么可以描述无穷的世界，首先需要知道面向对象方法是什么，其次，需要知道现实世界和软件的普遍联系。</p><p>面向对象方法是什么？是一种运用对象、类、消息传递、继承、封装、聚合、多态性等概念构造软件系统的软件开发方法。</p><p>我记得高中哲学里面听到的一句话，世界是物质的，物质是运动的，运动是有规律的。而对于软件而言，其实质是对现实人工系统的一种映射、优化和替换。通过对现实世界的分析，我们可以知道，世界是由对象组成的，对象之间时存在普遍联系的，而物质运动则说明了对象的功能。</p><p>面向方法是将这现实世界抽象映射为对象的手段。分析设计时由对象抽象出类，程序运行时由类还原到了对象。所以它能够描述无穷的信息世界。</p><h4 id="4-软件工程实践论是什么？"><a href="#4-软件工程实践论是什么？" class="headerlink" title="4.  软件工程实践论是什么？"></a>4.  软件工程实践论是什么？</h4><p>软件工程实践论是研究在开发一个大型软件系统时，到底应该怎样选取合适的开发方法。</p><h2 id="5-软件工程实践论指什么？"><a href="#5-软件工程实践论指什么？" class="headerlink" title="5.  软件工程实践论指什么？"></a>5.  软件工程实践论指什么？</h2><p>“五个面向”实践论，指面向流程分析、面向元数据设计、面向对象实现、面向功能测试、面向过程管理。</p><p>在后面，我们会发现软件工程的“五个面向”实践论在各个软件生命周期模型中都有一定的体现。</p><h2 id="三、软件支持过程、软件管理过程"><a href="#三、软件支持过程、软件管理过程" class="headerlink" title="三、软件支持过程、软件管理过程"></a>三、软件支持过程、软件管理过程</h2><ol><li><h4 id="软件过程是什么？"><a href="#软件过程是什么？" class="headerlink" title="软件过程是什么？"></a>软件过程是什么？</h4><p>软件过程，指软件生命周期中的时间序列</p></li><li><h4 id="软件支持过程是什么？"><a href="#软件支持过程是什么？" class="headerlink" title="软件支持过程是什么？"></a>软件支持过程是什么？</h4><p>软件支持过程，由支持软件生命周期模型各个阶段的生产工具组成。</p></li><li><h4 id="软件生命周期中的生产工具有哪些？"><a href="#软件生命周期中的生产工具有哪些？" class="headerlink" title="软件生命周期中的生产工具有哪些？"></a>软件生命周期中的生产工具有哪些？</h4><p>CASE工具、软件开发环境SDE、软件工程环境SEE</p></li><li><h4 id="软件管理是什么？"><a href="#软件管理是什么？" class="headerlink" title="软件管理是什么？"></a>软件管理是什么？</h4><p>管理过程和支持过程又称为“软件过程工程”。它是软件工程的一部分。</p><p>软件管理实质上是过程管理。</p></li><li><h4 id="软件管理有哪几类？"><a href="#软件管理有哪几类？" class="headerlink" title="软件管理有哪几类？"></a>软件管理有哪几类？</h4><p>ISO 9001质量管理和质量保证体系</p><p>CMMI软件能力成熟度模型</p><p>软件企业文化，包括微软企业文化，IBM企业文化，敏捷文化。</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h2&gt;&lt;p&gt;&amp;emsp;经过一个礼拜的准备，终于结束了软件工程的复习。在复习软件工程的同时也在做信息系统综合设计的课程设计。在做课程设计
      
    
    </summary>
    
      <category term="软件工程" scheme="http://wanqbin.xyz/categories/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"/>
    
    
      <category term="软件工程方法论" scheme="http://wanqbin.xyz/tags/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E6%96%B9%E6%B3%95%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>指针，又见指针</title>
    <link href="http://wanqbin.xyz/2019/06/10/%E6%8C%87%E9%92%88%EF%BC%8C%E5%8F%88%E8%A7%81%E6%8C%87%E9%92%88/"/>
    <id>http://wanqbin.xyz/2019/06/10/指针，又见指针/</id>
    <published>2019-06-10T13:03:00.000Z</published>
    <updated>2019-06-15T13:06:21.270Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、指针简介"><a href="#一、指针简介" class="headerlink" title="一、指针简介"></a>一、指针简介</h2><p>一般来说，指针是一个其数值为地址的变量（或更一般地说是一个数据对象）。正如char类型的变量用字符作为其数值，而int类型变量的数值是整数，指针变量的数值表示的是地址。</p><p>如果你将某个指针变量命名为ptr，就可以使用如下语句：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ptr=&amp;pooh;   <span class="comment">//把pooh的地址赋给ptr</span></span><br></pre></td></tr></table></figure><p>对于这个语句，我们称ptr指向pooh。ptr和&amp;pooh的区别在于前者是变量，后者是常量。ptr可以指向任何地方：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ptr=&amp;bath;    <span class="comment">//令ptr指向bath</span></span><br></pre></td></tr></table></figure><h2 id="二、间接运算符"><a href="#二、间接运算符" class="headerlink" title="二、间接运算符"></a>二、间接运算符</h2><p>假定ptr指向bath：ptr=&amp;bath</p><p>这时就可以使用间接运算符*（也称取值运算符）来获取bath中存放的数值。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">val=*ptr;    <span class="comment">//得到ptr指向的值</span></span><br></pre></td></tr></table></figure><p>语句ptr=&amp;bath；以及语句val=*ptr；放在一起等同于下面的语句：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">val=bath;</span><br></pre></td></tr></table></figure><p>下面进行举例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">nurse=<span class="number">22</span>;</span><br><span class="line">ptr=&amp;nurse;  <span class="comment">//指向nurse的指针</span></span><br><span class="line">val=*ptr;  <span class="comment">//将ptr指向的值赋给val</span></span><br></pre></td></tr></table></figure><p>上述语句实现的功能是把数值22赋给变量val</p><h2 id="三、指针声明"><a href="#三、指针声明" class="headerlink" title="三、指针声明"></a>三、指针声明</h2><p>例如：long和float两种类型的数值可能使用相同大小的存储空间，但是他们的数据存储方式完全不同，指针的声明形式如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *pi;  <span class="comment">//pi是指向一个整数变量的指针</span></span><br><span class="line"><span class="keyword">char</span> *pc;  <span class="comment">//pc是指向一个字符变量的指针</span></span><br><span class="line"><span class="keyword">float</span> *pf,*pg;  <span class="comment">//pf和pg是指向浮点变量的指针</span></span><br></pre></td></tr></table></figure><p>类型标识符表明了被指向变量的类型，而<em>表示该变量是一个指针。声明int * pi;的意思是pi是一个指针，而且</em>pi是int类型的。</p><p>*和指针名之间地空格是可选的。通常程序员在声明中用空格，而在指向变量时将其省略。</p><p>pc所指向的值（*pc）是char类型的。而pc本身是什么类型的？</p><p>我们将其描述为“指向char的指针”类型。pc的值是一个地址，在大多数系统中，它是由一个无符号整数表示。但是这并不表示可以把指针当做整数类型。一些处理整数的方法不能用来处理指针，反之亦然。例如，可以进行两整数相乘，而指针不能。因此指针的确是一种新的数据类型，而不是整数类型。</p><h2 id="四、使用指针在函数间通信"><a href="#四、使用指针在函数间通信" class="headerlink" title="四、使用指针在函数间通信"></a>四、使用指针在函数间通信</h2><p>在下面的程序中，函数interchange（）只用了指针参数，我们将对该函数进行详细的讨论。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">interchange</span><span class="params">(<span class="keyword">int</span> * u, <span class="keyword">int</span> * v)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> x = <span class="number">5</span>, y = <span class="number">10</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Originally x=%d and y= %d.\n"</span>, x, y);</span><br><span class="line">interchange(&amp;x, &amp;y); <span class="comment">//向函数传送地址</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Now x= %d and y=%d.\n"</span>, x, y);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">interchange</span><span class="params">(<span class="keyword">int</span> * u, <span class="keyword">int</span> * v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> temp;</span><br><span class="line">temp = *u;<span class="comment">//temp得到u指向的值。</span></span><br><span class="line">*u = *v;</span><br><span class="line">*v = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面我们分析以上程序的运行情况。首先，函数调用语句如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">interchange(&amp;x, &amp;y); <span class="comment">//向函数传送地址</span></span><br></pre></td></tr></table></figure><p>可以看出，函数传递的是x和y的地址而不是他们的值。这就意味着intechange（）函数原型声明和定义中的形式参数u和v将使用地址作为它们的值。因此他们应该声明为指针，由于x和y都是整数，所以u和v是指向整数的指针。其声明如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">interchange</span><span class="params">(<span class="keyword">int</span> * u, <span class="keyword">int</span> * v)</span></span>;</span><br></pre></td></tr></table></figure><p>接下来，函数体进行如下声明：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> temp;</span><br></pre></td></tr></table></figure><p>从而提供了所需要的临时变量。为了把x的值存在temp中，需要使用下面语句：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">temp = *u;<span class="comment">//temp得到u指向的值。</span></span><br></pre></td></tr></table></figure><p>注意，因为u的值是&amp;x，所以u指向x的地址，这就以意味着*u代表了x的值，而这正是我们需要的数值。</p><p>在示例程序中，我们用一个函数实现x和y的数值交换。首先函数使用x和y的地址作为参数，这使得它可以访问x和y变量。通过使用指针和运算符*，函数可以获得相应存储地址的数据，从而就可以改变这些数据。</p><p>在ANSI原型中可以省略变量名称。这样，函数原型可以按如下形式进行声明：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">interchange</span> <span class="params">(<span class="keyword">int</span> * ,<span class="keyword">int</span> *)</span></span>;</span><br></pre></td></tr></table></figure><p>通常情况下，可以把关于变量的两类信息传递给一个函数，如果函数的调用形式为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">function1(x);</span><br></pre></td></tr></table></figure><p>这时传递的是x的值，但是如果使用下面这种函数调用形式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">function2(&amp;x);</span><br></pre></td></tr></table></figure><p>那么会把x的地址传递给函数。第一种调用形式要求函数定义部分必须包含一个和x具有相同数据类型的形式参数。如下所示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">function1</span><span class="params">(<span class="keyword">int</span> num)</span></span>;</span><br></pre></td></tr></table></figure><p>而第二种形式要求函数定义部分的形式参数必须是指向相应数据类型的指针：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">function2</span><span class="params">(<span class="keyword">int</span> *ptr)</span></span>;</span><br></pre></td></tr></table></figure><p>使用函数进行数据计算等操作时，可以使用第一种调用形式。但是如果需要改变调用函数中的多个变量的值时，就需要使用第二种调用形式。</p><p>尽管interchange（）只使用局部变量，但是通过使用指针，该函数可以操作main（）中的变量的值。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、指针简介&quot;&gt;&lt;a href=&quot;#一、指针简介&quot; class=&quot;headerlink&quot; title=&quot;一、指针简介&quot;&gt;&lt;/a&gt;一、指针简介&lt;/h2&gt;&lt;p&gt;一般来说，指针是一个其数值为地址的变量（或更一般地说是一个数据对象）。正如char类型的变量用字符作为其数值
      
    
    </summary>
    
      <category term="C++" scheme="http://wanqbin.xyz/categories/C/"/>
    
    
      <category term="指针" scheme="http://wanqbin.xyz/tags/%E6%8C%87%E9%92%88/"/>
    
      <category term="C++" scheme="http://wanqbin.xyz/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>软件工程相关名词解释</title>
    <link href="http://wanqbin.xyz/2019/06/10/%E5%B7%A5%E7%A8%8B%E7%9B%B8%E5%85%B3%E5%90%8D%E8%AF%8D%E8%A7%A3%E9%87%8A-1/"/>
    <id>http://wanqbin.xyz/2019/06/10/工程相关名词解释-1/</id>
    <published>2019-06-10T12:16:00.000Z</published>
    <updated>2019-06-15T12:20:28.061Z</updated>
    
    <content type="html"><![CDATA[<ol><li>软件：</li></ol><p>一般认为，程序是计算机为完成特定任务而执行的指令的有效集合。站在应用的角度可以通俗地理解为：</p><p>面向过程的程序=算法+数据结构</p><p>面向对象的程序=对象+消息</p><p>面向构件的程序=构件+构架</p><p>通常，软件有以下定义：</p><p>软件=程序+数据+文档</p><p>这里的“程序”，是对计算机任务的处理对象和处理规则的描述；这里的“文档”，是为了理解程序所需的详细描述性资料；这里的“数据”，主要是软件系统赖以运行的初始化数据。</p><p>软件的最新定义如下：</p><p>软件=知识+程序+数据+文档</p><p>定义中增加了“知识”。这里的“知识”,主要指各种各样的相关行业领域的专业知识。实际上，知识只是网络的外在表现，程序，数据，文档才是网络的内在实质。也就是说，知识是通过程序、数据、文档来实现的。</p><p>对这一定义的另外一种解释是，软件到底是什么呢？软件就是网络，网络就是知识，知识就是信息。站在网民的角度看，软件就是知识加信息。站在程序员角度看，软件就是程序加数据；站在软件管理者角度看，软件就是数据加文档。</p><p>网络是知识的载体，知识是网络的灵魂。</p><ol start="2"><li>软件工程</li></ol><p>软件工程是研究软件开发和管理的一门学科。</p><p>这里，以是强调开发。开发是软件工程的主体，开发是在规定的时间、按照规定的成本，开发出符合规定质量要求的软件。二是强调管理或过程管理。当然，开发中有管理，管理是为了更好地开发。所以开发和管理是一个问题的相辅相成的两个方面。许多软件项目的失败，不是在开发技术上出了问题，二是在管理过程上出了问题。所以在某种程度上说，对于一个软件企业，过程管理比开发技术更重要。三十强调工程。要将软件的开发（包括维护）当成一项工程，既要按照工程的办法去开发，又要按照工程的办法去管理。四是强调学科。时至今日，软件工程不止是一门课程，而是一个学科体系，即软件工程知识体系。</p><ol start="3"><li>软件工程学科体系（swebok2004）：</li></ol><p>软件工程作为一个学科体系，到21世纪初才初步形成。2001年4月18日，美国发布了软件工程知识体系指南SWEBOK（guide to the Software Engineering body of Knowledge）0.95版。2004年，软件工程学科体系的内容才基本确立，就在这一年，美国ACM和IEEE-CS联合制订了SWEBOK2004版，它将软件工程学科体系的知识划分为如下10个知识域：</p><p>（1）软件需求：软件需求是真实世界中的问题而必须展示的特性。软件的需求知识域有7个子域：需求基础、需求过程、需求获取、需求分析、需求规格说明、需求确认、实践考虑。</p><p>（2）软件设计：软件设计既是定义一个系统的体系结构，组件，接口和其他特征的过程，又是这个过程的结果，软件设计知识域有6个子域：软件设计基础，软件设计关键问题，软件结构与体系结构，软件设计质量的分析与评价，软件设计符号，软件设计的策略与方法。</p><p>（3）软件构造：它指通过编码，验证，单元测试，集成测试和排错的组合，具体创建一个可以工作的，有意义的软件。其知识域有3个子域：软件构造基础，管理构造，实际考虑</p><p>（4）软件测试：它由在有限测试用例集合上，根据期望的行为对程序的行为进行的动态验证组成，测试用例是从实际上无限的执行域中适当选择出来的。软件测试知识域有5个子域：软件测试基础和测试级别，测试技术，需求分析，与测试相关的度量，测试过程。</p><p>（5）软件维护：软件一旦投入运行，就可能出现异常，运行环境可能发生改变，用户会提出新的需求。生命周期中的软件维护，从软件交付时开始。软件维护的知识域有4个子域：软件维护基础，软件维护的关键问题，维护过程，维护技术。</p><p>（6）软件配置管理：软件配置是为了系统地控制配置的变更，维护软件在整个系统生命周期中的完整性及可追踪性，而标志软件在不同时间点上的配置的学科。软件配置管理知识域有6个子域：软件配置管理过程管理，软件配置标志，软件配置控制，软件配置状态统计，软件配置审核，软件发行管理和交付。</p><p>（7）软件工程管理：进行软件工程的管理与度量，虽然度量是所有知识域的一个重要方面，但是这里所说的是度量程序的主体。软件工程管理只是域有6个子域：启动和范围定义，软件项目计划，软件项目实施，评审与评价，关闭，软件工程度量。前5个覆盖软件过程工程管理，第6个描述软件度量的程序。</p><p>（8）软件工程过程：涉及软件工程过程本身的定义、实现、评定、度量、管理、变更和改进。软件工程过程知识域有4个子域：过程实施与改变、过程定义、过程评定、过程和产品度量。</p><p>（9）软件工程工具和方法：它具有软件工程工具、软件工程方法两个子域。</p><p>（10）软件质量：处理跨域整个软件生命周期过程的软件质量的考虑，由于软件质量问题在软件工程中无处不在，其他知识领域也涉及到质量问题。软件质量知识域有3个子域：软件质量基础，软件质量过程、时间考虑。</p><p>在上述软件工程学科体系中前5个知识域是讲软件开发，后5个知识域是讲软件管理。由此可见，软件工程知识体系包括软件开发和软件管理两大部分，所以软件工程的定义也应该包括软件开发和软件管理两项内容。</p><ol start="4"><li>软件工程课程</li></ol><p>软件工程课程与软件工程学科体系是有区别的：前者是一门或一组课程，后者是一个知识体系；前者是一个局部问题，后者是一个整体问题。</p><p>作为一门软件工程客户才能，它研究的内容至今没有统一的说法。可以这么认为，软件工程课程研究的内容应该涵盖“软件生命周期模型、软件开发方法、软件支持过程、软件管理过程、软件工程标准与规范”这5个方面。</p><table><thead><tr><th>序号</th><th>研究方向</th><th>具体内容</th></tr></thead><tbody><tr><td>1</td><td>软件生命周期模型</td><td>如：瀑布模型，增量模型</td></tr><tr><td>2</td><td>软件开发方法</td><td>如：面向过程的方法</td></tr><tr><td>3</td><td>软件支持过程</td><td>如：CASE工具ROSE，北大青鸟系统，Power   Designer</td></tr><tr><td>4</td><td>软件管理过程</td><td>如：CMMI，软件企业文化，敏捷（XP）文化现象</td></tr><tr><td>5</td><td>软件工程标准与规范</td><td>如：命名标准与规范，设计标准与规范，编程标准与规范</td></tr></tbody></table><p>尽管软件生命周期模型和软件支持过程非常重要，但是现代软件工程研究的重点，仍然是软件开发方法和软件管理过程。在软件管理过程的内容中，除了ISO9001的CMMI之外，还将软件企业文化也列入其中，如微软企业文化，敏捷文化现象和IBM企业文化。</p><p>软件工程标准是对软件产品的约束，如软件产品的界面标准，包装标准，文档标准，测试标准，评审标准，鉴定标准等。软件工程规范是对软件开发人员行为的约束，例如命名规范，需求规范，设计规范，编码规范，维护规范等。在软件企业内部，企业管理人员特别重视软件工程的标准与规范。为此，每个大型的软件企业，根据自身的特点，都制订并发布了自己的软件工程标准与规范，在自己企业内部严格执行。</p><ol start="5"><li>软件工程基本原理</li></ol><p>习惯上，人们常常把软件工程方法（开发方法）、工具（支持方法的工具）、过程（管理过程）称为软件工程三要素，而把美国著名的软件工程专家B.W Boehm于1983年提出的7条原理作为软件工程的基本原理。</p><p>（1） 用分阶段的生命周期计划严格管理软件开发。阶段划分为计划、分析、设计、编程、测试和运行维护。</p><p>（2） 坚持进行阶段评审。若上一阶段评审不通过，则不能进入下一阶段开发</p><p>（3） 实行严格的产品版本控制</p><p>（4） 采用现代程序设计技术</p><p>（5） 结果应能清楚地审查。因此，对文档要有严格的要求</p><p>（6） 开发小组的成员要少而精</p><p>（7） 要不断地改进软件工程实践的经验和技术，要与时俱进</p><p>上述7条原理，虽然是在面向过程设计时代（结构化时代）提出的，但是，直到今天，在面向元数据和面向对象的程序设计新时代，它仍有效。根据“与时俱进”的原则，还有一条基本原理在软件的开发和管理中特别重要，需要补充进去，作为软件工程的第8条基本原理。</p><p>（8） 二八定律</p><p>在软件工程中，所谓二八定律，就是一般人常常将20%的东西误认为80%的东西，而将80%的东西误认为是20%的东西。</p><p>例如，对软件项目进度和工作量的估计：一般人主观上认为已经完成了80%，但实际上只完成了20%；对于程序中存在问题的估计，：一般人不知道80%的问题存在于20%的程序之中；对模块功能的估计：一般人不知道20%的模块，实现了80%的功能；对人力资源的估计：一般人不知道20%的人，解决了程序中80%的问题；对投入资金的估计：一般人不知道信息系统中80%的问题，可以用20%的资金来解决。</p><p>研究二八定律的现实意义是，指导软件计划的制订与执行。</p><ol start="6"><li>软件生命周期模型</li></ol><p>软件生命周期模型时指在整个软件生命周期中，软件开发过程应该遵循的开发路线图。或者说，软件生命周期模型是软件开发全部过程、活动和任务的结构框架。</p><p>例如：瀑布模型、增量模型、螺旋模型、喷泉模型、XP模型、原型模型和RUP迭代模型，它们都有各自清晰的开发路线图，规定了各自的开发过程、活动和任务的结构框架。</p><p>从字面上理解，“软件生命周期”应该涵盖软件产品、项目或系统从产生、投入使用看到被淘汰的全过程。由于早期人们关注的是技术开发活动，还没有考虑到管理活动，因此“软件生命周期模型”主要描述的还是软件开发的过程及其任务。</p><p>与人不同的是，软件的生命周期和软件生命周期模型有关：不同的软件生命周期模型，可能对应着不同的生命周期。生命周期不同，该软件的开发阶段划分、评审次数、基线标准都有所不同。软件公司的项目组在开发一个大项目或产品时，首先在技术上必须选择一个软件生命周期模型，使该模型非常适合这个项目或产品的生命周期模型；随后通过对软件生命周期模型的裁剪，给出适用于本项目或产品的软件生命周期定义；以生命周期定义为标准，在需求定义之后，编制详细的软件开发计划；然后项目组按计划进行软件开发，软件工程管理部门按计划进行软件过程跟踪和管理。</p><p>软件生命周期模型能清晰、直观地表达软件开发全过程，明确规定了要完成的主要活动和任务，用来作为软件项目工作的基础。一般以时间为序，软件生命周期模型可详细地划分为9个阶段。</p><table><thead><tr><th>序号</th><th>周期名称</th><th>序号</th><th>周期名称</th></tr></thead><tbody><tr><td>1</td><td>立项（或签合同）、下达任务书</td><td>6</td><td>软件测试</td></tr><tr><td>2</td><td>需求分析</td><td>7</td><td>软件发布与实施</td></tr><tr><td>3</td><td>概要设计</td><td>8</td><td>软件维护</td></tr><tr><td>4</td><td>详细设计</td><td>9</td><td>版本更新或退役</td></tr><tr><td>5</td><td>编码实现</td><td></td><td></td></tr></tbody></table><p>软件开发方法是指在软件工程开发路线图中，开发人员对软件需求、设计、实现、维护所采用的开发思想开发技术、描述方法、支持工具等。</p><p>软件工程中软件开发方法的集合，称为软件工程方法论。</p><ol start="7"><li>迭代模型及其9个核心流程</li></ol><p>针对瀑布模型的缺陷，人们提出了迭代模型。</p><p>所谓迭代，是指活动的多次重复。从这个意义法伤来讲，原型不断完善，增量不断产生，都是迭代的过程。因此，快速原型法和增量模型都可以看成局部迭代模型。但这里所讲的迭代模型时RUP推出的一种“逐步求精”的面向对象的软件开发过程模型，被认为是软件界迄今为止最完善、可实现商品化的开发过程模型。</p><p>RUP模型的原型图看起来非常简单，其内涵却非常丰富。它表面上是一个二维图，实质上用一张二维图表示了一个多维空间模型。从宏观上看，它是一个大的迭代过程；横坐标表示软件产品所处的4个阶段：先启、精化、构建、产品化（移交），纵坐标表示软件产品在每个阶段的工作流程。从微观上看，任何一个阶段本身，其内部工作流程也是一个小的迭代过程。</p><p>为使项目能够顺利地进行，一种较灵活（并且风险更小）的方法是：多次执行各个开发工作流程，从饿了更好地理解需求，设计出更为强壮的软件架构，逐步提高开发组织能力，最终交付一系列逐步完善的实施成果，这就是迭代生命周期模型。每次按顺序完成一系列工作流程就称为一次迭代，每次迭代，均以次要里程碑结束，按照特定的迭代成功标准，对迭代的结果进行评估。每个阶段都可以进一步细分为迭代。迭代是产生可执行的产品发布（内部或外部的）的完整开发循环，所发布的产品是开发过程最终产品的子集，它将通过一次又一次的迭代实现递增成长，最后形成最终的软件系统或产品。</p><p>优点：</p><p>n  在开发的早期或中期，用户需求可以变化；</p><p>n  在迭代之初，不要求有一个相近的产品原型</p><p>n  模型的适用范围很广，几乎适用于所有项目的开发</p><p>缺点：传统的组织方法是按顺序（一次且仅一次）完成每个工作流程，即瀑布式生命模型。迭代模型采取循环工作方式，每次循环均使工作产品更靠近目标产品，这要求项目组成员具有很高的水平并掌握先进的开发工具。反之，存在较大的技术和技能风险。</p><p>模型的9个核心流程：</p><p>迭代声明周期模型包含9个核心流程（需要指出的，采用迭代模型，事先要有一个初始业务模型，以便进行迭代。这就是为什么将“业务建模”作为9个核心流程之首的道理）。</p><p>（1） 业务建模：目的是， 了解目标组织的结构和机制；了解目标组织中当前存在的问题，并确定改进的可能性；确保客户、最终用户和开发人员就目标组织达成共识；导出支持目标组织所需的系统需求。通俗地讲，业务建模就是用户业务流程的重新规划与合理改进，即业务流程的优化，目的是使开发出来的系统能反映最优化的业务流程。</p><p>（2） 需求获取：目的是，与客户在系统的工作内容方面达成并保持一致；使系统开发人员能够更清楚地了解系统需求；定义系统边界；为计划迭代的内容提供基础；为估算开发系统所需成本和时间提供基础；定义系统的用户界面，重点是用户的需要和目标。</p><p>（3） 分析设计：目的是，将需求转换为未来系统的设计；逐步开发强壮的系统构架；使设计适合实施环境，为提高性能而进行设计。</p><p>（4） 实施：目的是，对照实施子系统的分层结构定义代码结构；以构件（源文件，二进制文件，可执行文件以及其他文件等）方式实施类和对象；对已开发的构件按单元进行测试；将各实施成员（或团队）完成的结果集成到可执行系统中。</p><p>（5） 测试：目的是，核实对象之间的交互；核实软件的所有构件是否正确集成；核实所有需求是否已经正确实施；确定缺陷并确保在部署软件之前将缺陷解决。</p><p>（6） 部署：目的是，将构件部署到网络的各个节点上，使最终用户可以使用该软件产品。</p><p>（7） 配置与变更管理，目的是，始终保持工作产品的完整性和一致性</p><p>（8） 项目管理：目的是，为软件密集型项目的管理提供框架；为项目计划，人员配备，执行和检测提供实用准则；为风险管理提供框架。</p><p>（9） 环境：目的是，为软件开发组织提供软件开发环境（流程和工具），该环境将支持开发团队。</p><ol start="8"><li>XP模型</li></ol><p>XP模型，即极限编程模型，它本来是敏捷企业文化现象，但是不少人将它当成一种软件开发模型。</p><p>对传统软件开发模型进行重新审视发现，它们太正规、太呆板、太浪费资源，从而提出了省时省力的XP模型。它属于轻量级开发模型，由一组简单规则（需求、实现、重构、测试、发布）组成，它既保持开发人员的自由创造性，又保持对需求变动的适应性，即使在开发的后期，也不怕用户需求的变更。</p><p>在需求、实现、重构、测试、发布的迭代过程中，XP模型有4条核心原则：交流、简单、反馈和进取。XP开发小组包括开发人员、管理人员和客户。</p><p>优点：</p><p>l  采用简单策略，不需要长时间计划和复杂管理，开发周期短</p><p>l  采用迭代增量开发，反馈修正和反复测试的方法，因而软件质量有保证。</p><p>l  适应用户需求变化，因而与用户关系和谐。</p><p>缺点：<br> XP模型作为一种新的模型，在实际应用中还存在一些问题，引起了一些争议。它一般适用于小型项目，同时，它与ISO9001、CMMI的精神也存在冲突。</p><ol start="9"><li>订单软件</li></ol><p>与固定的用户签订软件开发合同，由软件公司启动该项目的开发，这类软件被称为“订单软件”，典型的例子有企业资源规划系统ERP和电子商务大型网站。</p><ol start="10"><li>非订单软件</li></ol><p>市场调研之后，认为某产品将会有巨大的市场空间，而软件公司在人力资源、设备资源、抵抗风险、资金和时间上都具备开发该产品的能力，于是决定立项，这类软件被称为“非订单软件”，典型的例子是网上游戏软件</p><ol start="11"><li>任务书</li></ol><p>有一份《任务书》的正文。包括任务下达的对象、内容、要求完成的日期、决定投入的资源、必要时包括任命项目经理（技术经理和产品经理）、其他保证措施、奖惩措施等。《任务书》正文可长可短，若《合同》或《立项建议书》很详细，则正文可短，若《合同》或《立项建议书》很粗很短，则正文应该很长、很详细。</p><p>有一份《任务书》的附件。一般情况下，它就是软件《合同》/《立项建议书》，如果是指令性计划，它的格式和内容，也应与《合同》/《立项建议书》基本相同，即附件的内容应覆盖系统的功能点列表、接口列表、资源需求列表、开发进度列表、阶段评审列表等。</p><p>《任务书》与《合同》/《立项建议书》一样重要，它是该项目的第二份管理文档。</p><ol start="12"><li>合同</li></ol><p>对于一些大型项目，在签订合同之前，一般有一个招标和投标的过程，只有中标之后才能签订合同。开发“非订单软件”需要“立项”，开发“订单软件”需要签订“合同”。所以“立项”与“合同”是IT企业软件项目（或产品）的两个源头。一旦立项或签订合同，企业领导或软件管理部门就要下达《任务书》，开发部门接到《任务书》后就要组建开发团队，成立项目组。</p><ol start="13"><li>立项建议书</li></ol><p>立项文档就是《立项建议书》，它本身不是软件策划的内容，但是很重要，也很特殊。《立项建议书》的目的，就是在某种程度上代替开发合同或用户需求报告，作为软件策划的基础。《立项建议书》的编制者一般不是软件开发人员，而是软件公司的市场销售人员，因为他们熟悉市场行情及客户需求</p><ol start="14"><li>需求分析</li></ol><p>1997年，IEEE软件工程标准词汇表中定义的需求为：</p><p>（1） 用户解决问题或达到目标所需的条件或能力</p><p>（2） 系统或系统部件要满足合同、标准、规范或其他正式规定文档所具有的条件或能力</p><p>（3） 一般反映（1）或（2）所描述的条件或能力的文档说明</p><p>一般而言，需求分析阶段位于软件开发的前期，它的基本任务是准确地定义未来系统的目标，确定为了满足用户的需要系统必须做什么。</p><p>需求分析分为两个阶段：需求获取阶段和需求规约阶段。需求关系的是系统的目标而不是系统实现。</p><p>需求可以分为两类：功能性需求和非功能性需求。前者定义了系统做什么，后者定义了系统工作时的特性。</p><ol start="15"><li>基线</li></ol><p>基线是软件工作产品，它是要经内部和外部评审过的，是下一阶段工作的基础。</p><ol start="16"><li>审计</li></ol><p>审计，是复查评审活动程序的合法性，是否按程序与规范进行等</p><ol start="17"><li>里程碑</li></ol><p>里程碑是一个标记，只需要经过内部评审。一个里程碑是一个检查点，但不一定对应一条基线</p><p>定义软件过程</p><p>所谓定义软件过程，就是根据选定的生命周期模型，规定软件的开发1模型，以及每一阶段的工作步骤和文档标准等内容。</p><p>在项目策划阶段，先要根据项目特性，使用软件生命周期模型，对项目中将要进行的软件工程过程进行描述。根据项目自身的特点，对项目的类型进行详细划分，然后根据软件组织的“生命周期模型裁剪指南”，对标准软件过程进行裁剪，形成项目定义软件过程。再使用项目定义软件过程，指导项目策划活动的进行。</p><p>开发计划是对项目定义软件过程的具体描述。软件项目的规模、工作量、成本、进度、质量、人员配置和其他资源等，与项目定义软件过程中的活动紧密相关。由于项目定义软件过程的标准，全部由“生命周期模型裁剪指南”而得到，因此软件项目能共享过程数据，并且吸取软件组织中积累的经验教训。</p><ol start="19"><li>LOC</li></ol><p>LOC（line of code），LOC指所有的可执行源代码行数。包括可交付的工作控制语言（job control language，JCL）语句，数据定义，数据类型声明，等价声明，输入/输出格式声明等。一代码行（1LOC）的价值和人月均代码行数可以体现一个软件生产组织的生产能力。组织可以根据对历史项目的审计来核算组织的单行代码价值。</p><ol start="20"><li>功能模型</li></ol><p>（Function Model, FM）。实质上是用户需求模型，用来描述系统能做什么，即对系统的功能，性能，接口和界面进行定义。</p><ol start="21"><li>业务模型</li></ol><p>（Operation Model，OM），实质上是业务逻辑模型，用于描述系统在何时，何地、由何角色、按什么业务规则去做，以及做的步骤或流程，即对系统的操作流程进行定义。</p><ol start="22"><li>数据模型</li></ol><p>（Data Model, DM）,实质上是实体或类的状态关系模型，用于描述系统工作前的数据来自何处，工作中的数据暂存在什么地方，工作后的数据放到何处，以及这些数据的状态以及相互之间的关联，即对系统的数据结构进行定义。</p><ol start="23"><li>风险分析</li></ol><p>软件策划过程，也包括对软件风险进行分析。所谓软件风险分析，指对项目及团队的政策风险、技术风险、技能风险、资源风险等因素，进行逐个分析与分解，将一个大风险分解为若干个小风险，对各个小风险进行排除，最后制订跟踪和监控风险的风险管理计划。软件一般存在5种风险，如下表：</p><table><thead><tr><th>序号</th><th>风险名称</th><th>风险内容</th></tr></thead><tbody><tr><td>1</td><td>政策风险</td><td>IT企业外部和IT企业内部两个方面的政策及政策的变化，将会给项目带来什么风险</td></tr><tr><td>2</td><td>技术风险</td><td>新技术的成熟程度以及难度系数，将会给项目带来什么风险</td></tr><tr><td>3</td><td>技能风险</td><td>项目组成员学习、领会、掌握、运用新技术的能力，将会给项目带来什么风险</td></tr><tr><td>4</td><td>资源风险</td><td>保证项目正常进行所需的各种资源的供应程度，将会给项目带来什么风险</td></tr><tr><td>5</td><td>其他风险</td><td>目前意想不到的风险，即不可预测的风险，如天灾人祸</td></tr></tbody></table><ol start="24"><li>三层结构设计</li></ol><p>三层结构设计通常被划分为表示层、中间层和数据层三层，各个分层之间通过对外接口互相访问。分层的主要目的是，允许各层可以随着需求的变化或技术的变化而独立地升级或替换，如当替换数据库时，只需要变化数据层。</p><p>所谓的三层结构，就是在原来两层结构（Client/Server）的客户层和数据层之间，加入一个中间层（也叫业务层），并将应用程序的业务规则、数据访问、合法型校验等工作放到了中间层进行处理，这样就变成了三层结构，也不仅仅有B/S应用才是三层结构，三层是指逻辑上的三层，即使这三层都放置到了一台机器上。当然，这三层也可以放在两台或三台机器上。</p><p>（1） 表示层（浏览层）</p><p>表示层也称为浏览层，它通常采用图形化用户界面，在客户端PC或工作站上运行。站在“三个模型”建模思想上看，系统内部支持表示层的模型是“功能模型”，尽管“功能模型”中的功能思想组件放在业务层，但是功能组件的表现方式却在表示层上。该层的主要功能是：</p><p>​      1）接受用户请求，将这些请求反馈给业务逻辑层，等待业务逻辑层的应答信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2） 对业务逻辑层的应答信息，进行显示（不进行任何加工）</span><br></pre></td></tr></table></figure><p>​      3） 有时也会兼做业务逻辑层的一些小功能，比如对用户输入数据的验证，以及操作合法性的检验</p><p>（2） 中间层（业务层）</p><p>中间层也称业务层，有时又称为应用层，它由许多构建或组件组成，它们完全体现了用户的业务逻辑或业务规则。站在“三个模型”建模思想看，系统内部支持业务层的模型是“业务模型”。尽管Java EE与.NET在实现业务层上的方法略有差异，但是，业务层本质上在表示层与数据层之间起桥梁作用。有时，业务层被划分为两个子层：业务逻辑层和数据访问层。业务层的主要功能是：</p><p>​        1） 接受从表示层传来的用户请求信息</p><p>​        2） 根据用户的请求信息生成SQL语句</p><p>​        3） 利用生成的SQL语句从数据层取数据、修改数据、删除数据</p><p>​        4） 将结果返回给表示层</p><p>（3） 数据层</p><p>数据层是数据库服务器上的数据库层，它包括数据库管理系统DBMS和数据库DB两部分。站在“三个模型”建模思想看，系统内部支持数据层的模型是“数据模型”，该层的主要功能是：</p><p>​        1）接受业务层数据处理请求的SQL语句或存储过程</p><p>​        2） 利用SQL语句或存储过程，对数据库服务器上数据库的相关表进行存储或检索</p><p>​        3） 将存储或检索的结果信息，传递给业务层</p><ol start="25"><li>构件</li></ol><p>所谓构件，就是被标识的且可被复用的软件制品。</p><p>构件与部件，组件基本上是一个意思，有时会认为部件和组件的粒度比构件大一些或范围更广一些。上述定义有三个特点：第一个特点是构件要被明确标识，即有一个被调用的名字；第二个特点是应该可服用，不可复用的只能称为模块或子系统，第三个特点是构件是软件制品，在宏观上软件制品可以是项目计划、成本估价、体系结构、需求模型、设计模型、程序代码、窗口界面、文档、数据结构、测试用例等。</p><ol start="26"><li>中间件</li></ol><p>中间件是一个非常大的组件（构件），一般在网络上运行，完成批量数据的传递和通信工作，调用方式是通过一组事先约定的格式与参数进行的。常见的中间件为问价传输中间件，如IBM公司的消息队列中间件MQ，在网络节点之间进行点对点的数据通信和传输。又如城市医疗保险系统中的中间件，它在市医保局节点和全市各家医院节点之间，进行点对点的数据通信和传输，病号每次划价计费，节点之间就交换一次信息。在详细设计说明书中已对新增中间件的功能和算法进行了详述，此处只要将详细设计翻译为源程序即可。</p><ol start="27"><li>结对编程</li></ol><p>在敏捷方法中，成对（或结对）编程时极限编程的实践之一。当进行成对编程时每一个程序员输入代码，另一个在旁边观察代码中是否存在错误，并思考下一步要进行的工作。</p><p>优点：</p><p>  1）   可以提高代码的可读性和可理解性，产生高质量的代码</p><p>  2）   提高编程效率，使编程速度更快，代码错误更少，后期测试和纠错的工作量就会大大降低</p><p>  3）   成对编程可以提高开发团队的凝聚力和协作精神</p><p>规则：</p><p>  1）   编码标准</p><p>  2）   积极参与</p><p>  3）   非强制性</p><p>  4）   定期轮换</p><p>  5）   速度匹配</p><p>  6）   新老匹配</p><ol start="28"><li>软件测试</li></ol><p>软件测试按照规定的测试规程发现软件缺陷的问题。</p><p>为了理解这个定义，有如下解释：</p><p>  1）   软件测试是一个过程，而且是一个发现软件缺陷，但不包括修复软件缺陷的过程。</p><p>  2)    软件测试是按照规定的测试规程进行。这些规程包括制定测试计划，搭建测试环境，明确测试任务，规定测试时间、方法和步骤，记录测试数据和产生测试报告</p><p>  3)    在测试规程中，测试计划最为重要，它指导整个测试计划</p><p>  4)    在测试计划中，测试需求的定义很重要。如果没有列出明确的测试需求，那么就并不会设计出正确的测试用例，最后必然导致盲目的测试。这样，隐藏的软件缺陷也无法被发现。</p><p>  5)    软件测试的目的是发现软件缺陷，软件测试的目标是尽可能早地发现软件缺陷，因为缺陷发现越早，其修复成本越低。</p><p>软件测试不仅仅局限于测试程序代码，还可以测试软件数据与软件文档。也就是说，软件生命周期中所产生的软件工作产品，都可以作为测试对象，因为它们影响最终软件产品的质量。</p><ol start="29"><li>软件缺陷</li></ol><p>定义如下：</p><p>软件未实现产品说明书要求的功能。</p><p>软件出现产品说明书指明不应该出现的错误</p><p>软件实现了产品说明书未说明的功能</p><p>软件未实现产品说明书虽未明确提及但应该实现的目标</p><p>软件难以理解，不易使用，运行速度慢，或者软件测员，最终用户认为软件不好。</p><p>由于不同的理解方式和中英文翻译问题，软件缺陷的说法很多，如错误、失效、失败等，本书中统称为软件缺陷（bug）。实际测试中，将软件缺陷定义为不同级别，代表不同程度的软件缺陷。</p><p>随着软件定义的变化，软件缺陷的定义也应随之更新。软件缺陷不仅仅局限于软件代码，还包括文档缺陷（不符合规范或者不详细，有错误和歧义等）、测试缺陷（测试不充分，或测试方法本身的局限）、过程缺陷（软件生命周期的流程问题造成的产品质量问题）和管理缺陷（由于管理本身不到位导致的产品质量问题）。</p><ol start="30"><li>软件测试的V模型</li></ol><p><strong>早期的软件测试V模型</strong></p><p>模型的左侧是开发阶段，右侧是测试阶段。开发阶段从了解并定义软件需求开始，然后要把需求转换到概要设计和详细设计，最后形成程序代码。测试阶段是在代码编写完成之后，先做单元测试，然后做集成测试、系统测试和验收测试。</p><p>单元测试：主要检测代码的编写是否符合详细设计中单个模块或组件的要求</p><p>集成测试：主要检测此前测试过的单个模块或组件，能否正确地集成到系统，与其他模块一起运行，是否符合概要设计和详细设计说明书的要求。</p><p>系统测试：以集成后的完整系统作为测试对象，主要检测其是否符合需求说明书、概要设计说明书和详细设计说明书的要求。</p><p>验收测试：主要检测软件产品是否符合用户需求，用户合同和需求说明书中的要求，需要得到用户认可并签字确认。</p><p><strong>改进后的V模型：</strong></p><p>改进后的V模型，一是加入软件测试分析和测试设计阶段，二是体现“尽早”思想。改进后的V模型，形成了一个没有软件开发过程的、单独的软件测试V模型。它的左边是软件测试需求分析和测试设计，右边是软件测试执行。虽然测试执行过程同样集中在软件编码之后，但是测试需求分析和测试设计已经提前，一直提前到与开发阶段并行开展。一方面可以为后期的测试执行过程做计划和准备，另一方面可以对软件的阶段性产品（软件工作产品）进行测试。前期的软件工作产品主要是文档，如测试需求分析阶段，就是测试软件需求分析过程的工作产品《需求规格说明书》，进而提炼出测试需求。</p><ol start="31"><li>黑盒测试</li></ol><p>黑盒测试又称为不透明盒测试，它给我们的更多启示是它的思考方式，即不考虑（主观上屏蔽）或者不需要（客观条件限制）知道被测对象的内部实现细节，只关心输入输出。在运用黑盒测试方法进行软件测试时，它并不关心软件的内部逻辑结构和实现方法，而是站在使用者的角度，主要测试软件的功能指标，即测试系统的功能模型。黑盒测试的依据是软件的行为描述，是面向功能的穷举输入测试。从理论上讲，只有把所有可能的行为都作为测试用例输入，才能完成黑盒测试工作。黑盒测试的对象可以是软件单元、软件模块、软件组件、软件子系统和软件系统，也可以是发散思维到软件文档，软件管理文档等软件生命周期中的任何可测试对象。</p><p>黑盒测试用例设计方法：</p><p>（1）     等价类划分法</p><p>（2）     边界值分析法</p><p>（3）     错误推测法</p><p>（4）     因果图分析法</p><p>（5）     场景分析法</p><ol start="32"><li>白盒测试</li></ol><p>白盒测试又称为透明盒测试，要求测试人员必须清楚被测对象的内部实现细节。白盒测试方法的测定依据是《详细设计说明书》。理论上讲，面向程序执行路径进行穷举代码测试，直至覆盖所有路径，才算完成了白盒测试。白盒测试的测试对象，侧重于软件单元，模块和构件等小规模对象，绝对不适合软件项目或产品的等大规模测试对象。</p><p>实用的白盒测试覆盖技术有4种，即语句覆盖，条件覆盖，分支覆盖和组合覆盖。覆盖的主要思想，是从不同角度尽可能提高代码的测试覆盖率。为了减少测试工作量，应该使每一个测试用例满足多个覆盖条件。</p><ol start="33"><li>等价类</li></ol><p>等价类划分的具体做法是：把所有可能的输入数据，即软件的输入域，划分成若干部分（子集），使每部分内的数据都是等效的（对于软件而言，等效可以理解为对数据的处理过程以及处理结果都完全一致），然后从每一个子集中选取少数具有代表性的数据，作为测试用例。</p><p>每一个等价类又可以划分为两种不同类别：有效等价类和无效等价类。</p><ol start="34"><li>边界值</li></ol><p>边界值分析方法是对等价类划分方法的补充。</p><p>测试工作者已经总结出经验：大量的错误常常发生在输入或输出范围的边界上，因此针对各种边界情况设计测试用例，可以查出更多的错误。</p><p>使用边界值分析方法设计测试用例使，首先参考等价类划分法确定边界情况，除了在等价类中选取典型代表数据外，通常还要着重测试边界值情况，应当选取正好等于、刚刚大于、或刚刚小于边界的值作为测试数据。</p><ol start="35"><li>测试需求</li></ol><p>它指软件测试员站在与用户相同角度上理解的需求，主要是确保需求的可测试性。同时找出软件需求和用户需求的偏差，并确保认可的偏差修改后体现在软件需求中，因为测试工作以《软件需求说明书》为基准，测试人员需要尽量保证《软件需求说明书》可以满足测试工作。</p><ol start="36"><li>Bug</li></ol><p>即软件缺陷，如错误，失效，失败等。</p><ol start="37"><li>CMMI</li></ol><p>软件能力成熟度模型CMMI，是由美国卡内基-梅隆大学软件工程研究所退出的评估软件能力与成熟度等级的一套标准。该标准基于众多软件专家的实践经验，侧重于软件开发过程管理能力的提高，是软件生产过程改进的标准和软件企业成熟度等级评估的标准。由于该标准不涉及具体的软件开发方法和技术，所以它具有广泛性、通用性和持久性。</p><p>CMMI的作用：概括地讲，过程能力成熟度模型集成CMMI的作用，主要是软件组织的能力评估和过程改进，它的应用领域具体体现在三个方面：</p><p>软件组织，用它来不断改进自身的软件过程管理能力</p><p>评估机构，用它来评估某软件组织当前软件能力成熟度级别</p><p>客户，用它来评价某承包商（软件外包商）的软件能力</p><p>CMMI的实质：</p><p>为了真正达到持续改进软件过程能力的目的，并以尽量低的成本获得高的效益，首先要弄清楚“过程”、“项目”、“组织”、“度量”等五个基本概念。</p><p>以“过程”为核心，抓软件组织的管理，即软件“组织”的过程改进</p><p>以“项目”为手段，抓团队开发过程的“活动”，即落实过程改进的措施</p><p>以“活动”记录为基础，抓软件过程的“度量”，即“度量”软件组织改进的情况</p><ol start="38"><li>软件配置管理</li></ol><p>软件配置管理SCM，是对软件开发过程中配置项的一组追踪和控制活动，它开始于软件开发之初，结束于软件淘汰之时。软件配置管理在软件过程管理中，占有特殊得到地位，也是项目管理的重要内容。无论是ISO9001、CMMI，还是软件企业文化，都非常强调配置管理。在大中型软件企业内部设置专职的配置管理员，在各个项目组内部设置兼职的配置管理员，引进配置管理电子工具，开展配置管理的日常工作。</p><ol start="39"><li>CMMI阶段的成熟度等级</li></ol><p>阶段模型的5个等级，称为成熟度等级ML，从ML1级到ML5级。</p><table><thead><tr><th>CMMI的等级</th><th>PA数目</th><th>管理特点</th></tr></thead><tbody><tr><td>ML1:Initial（初始级）</td><td>0</td><td>过程不可预测且缺乏控制</td></tr><tr><td>ML2：Managed（已管理级）</td><td>7</td><td>过程为项目服务，即项目级管理</td></tr><tr><td>ML3：Defined（以定义级）</td><td>11</td><td>过程为组织服务，即组织级管理</td></tr><tr><td>ML4:Quantitatively Managed(定量管理级)</td><td>2</td><td>过程已度量和控制，即定量级管理</td></tr><tr><td>ML5：Optimizing（优化级）</td><td>2</td><td>集中于过程改进，即优化级管理</td></tr></tbody></table><ol start="40"><li>极限编程</li></ol><p>极限编程（即XP）是一个周密而严谨的软件开发流程。XP从4个基本方面对软件项目进行改善：交流、简单、反馈和进取。</p><p>XP程序员与客户交流、与同事交流；</p><p>他们的设计简单而干净；</p><p>他们通过测试来得到反馈；</p><p>他们根据变化修改代码，并争取尽可能早地将软件交付给客户。</p><p>在此基础上，XP程序员能够勇于面对需求变化和技术变化，“船小好调头”，对需求变化和技术变化做出敏捷反应，把那个取得成功，是敏捷文化的特色和本质。</p><ol start="41"><li>软件质量管理的三大支柱</li></ol><p>软件质量保证SQA是一个过程，是CMMI和ISO9001的重要议题，是微软公司和IBM公司的重点课题，同样也是项目管理的重要内容。</p><p>软件质量：是供方提供的软件产品满足用户明确和隐含需求的能力特性的总和。</p><p>通常，人们将“质量标准”、“配置管理”、“质量测试”作为质量管理的三大支柱。</p><p>而将”SQA计划”、“SQA进度”、“SQA评审和审计”作为质量管理三大要素。</p><p>软件质量保证是一个质量管理过程，基本思想是“以事先预防为主，以事后纠偏为辅”，采取标本兼治的方法。  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;软件：&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;一般认为，程序是计算机为完成特定任务而执行的指令的有效集合。站在应用的角度可以通俗地理解为：&lt;/p&gt;
&lt;p&gt;面向过程的程序=算法+数据结构&lt;/p&gt;
&lt;p&gt;面向对象的程序=对象+消息&lt;/p&gt;
&lt;p&gt;面向构件的程序=构件+构架&lt;/
      
    
    </summary>
    
      <category term="软件工程" scheme="http://wanqbin.xyz/categories/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"/>
    
    
      <category term="软件工程名词解释" scheme="http://wanqbin.xyz/tags/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%90%8D%E8%AF%8D%E8%A7%A3%E9%87%8A/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络体系结构</title>
    <link href="http://wanqbin.xyz/2019/06/10/%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/"/>
    <id>http://wanqbin.xyz/2019/06/10/算机网络体系结构/</id>
    <published>2019-06-09T16:45:00.000Z</published>
    <updated>2019-06-15T12:22:44.026Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、计算机网络分层结构"><a href="#一、计算机网络分层结构" class="headerlink" title="一、计算机网络分层结构"></a>一、计算机网络分层结构</h2><p>两个系统中实体间的通信是一个很复杂的过程，为了降低协议设计和调试过程的复杂性，也为了便于对网络进行研究、实现和维护，促进标准化工作，通常对及时算计网络的体系结构以分层的形式进行建模。</p><p>我们将计算机网络的各层及其协议的集合称为网络的体系结构。</p><p>网络设计者以分层的方式组织协议以及实现这些协议的网络硬件和软件，每个协议就属于这些层次之一。某层向它的上一层提供服务，即所谓每一层的服务模型。例如，第n层提供的服务可能包括报文从网络的一边到另一边的可靠传送。这可能是通过使用第n-1层的边缘到边缘的不可靠报文传送，加上第n层的检测和重传丢失报文的功能来实现的。</p><p>计算机网络的体系结构通常都具有可分层的特性，它将复杂的大系统分为若干个较容易实现的层次。分层的基本原则如下：</p><ol><li>每次都实现一种相对独立的功能，降低大系统的复杂度</li><li>各层之间界面自然清晰，易于理解，相互交流尽可能少</li><li>各层功能的精确定义独立于具体的实现方法，可以采用合适的技术来实现</li><li>整个分层结构应该促进标准化工作</li></ol><p>在计算机网路的分层结构中，第n层中的活动元素通常被称为n层实体。具体来说，<strong>实体指任何可发送或接受信息的硬件或软件进程，通常是一个特定的软件模块</strong>。不同机器上的同一层称为对等层，同一层的实体称为对等实体。</p><p>在计算机网络体系结构的各个层次中，每个报文都分为两部分：一是数据部分，即SDU；二是控制信息部分，即PCI，它们共同组成PDU。</p><p>服务数据单元（SDU）：为完成用户所要求的功能而应传送的是数据。第n层的服务数据单元记为n-SDU。</p><p>协议控制信息（PCI）：控制协议操作的信息。第n层的协议控制信息记为n-PCI。</p><p>协议数据单元（PDU）：对等层次之间传送的数据单位称为该层的PDU。第n层的协议数据记为n-PDU。在实际的网络中，每层的协议数据单元都有一个通俗的名称，如物理层的PDU称为比特，链路层的PDU称为帧，网络层的PDU称为分组，传输层的PDU称为报文。</p><p>在各层间传输数据时，把从第n+1层收到的PDU作为第n层的SDU，加上第n层的PCI，变成了第n层的PDU，交给第n-1层后作为SDU发送，接收方接收时做相反处理。故可知三者的关系是n-SDU+n-PCI=n-PDU=(n-1)-SDU.</p><h2 id="二、协议、接口、服务"><a href="#二、协议、接口、服务" class="headerlink" title="二、协议、接口、服务"></a>二、协议、接口、服务</h2><ol><li><p>协议</p><p>协议，就是规则的集合。在网络中要做到有条不紊地交换数据，就必须遵循一些事先约定好的规则，这些规则明规定了所交换的数据的格式及有关的同步问题。这些为进行网络中的数据交换而建立的规则、标准或约定称为网络协议。它是控制两个（或多个）对等实体进行通信的规则的集合，是水平的。不对等的实体之间没有协议。</p></li><li><p>接口</p><p>接口是同一结点内相邻两层之间交换信息的连接点，是一个系统内部的规定。每层只能为紧邻的层次之间定义接口，不能跨层定义接口。在典型的接口上，同一结点相邻两层的实体通过服务访问点（SAP）进行交互。服务是通过SAP提供给上层使用的，第n层的SAP就是第n+1层可以访问第n层服务的地方。</p></li><li><p>服务</p><p>服务是指下层为紧邻的上层提供的功能调用，它是垂直的。</p><p>上层使用下层所提供的服务时必须与下层交换一些命令，这些命令在OSI中称为服务原语。OSI将原语划分为4类：<br>1）请求：由服务用户发往服务提供者，请求完成某项工作</p><p>2）指示：由服务提供者发往服务用户，提示用户做某件事</p><p>3）相应：由服务用户发往服务提供者，作为对指示的响应</p><p>4）证实：由服务提供者发往服务用户，作为对请求的证实</p></li></ol><p>   并非在一层内完成的全部功能都称为服务，只有那些能够被高一层实体“看得见”的功能才称为服务。</p><p>   计算机网络提供的服务可按以下三种方式分类：</p><p>   （1）面向连接服务于无连接服务</p><p>   在面向连接服务中，通信前双方必须先建立连接，分配相应的资源，以保证通信能正常进行，传输结束后释放连接和所占用的资源。因此这种服务可分为建立连接、数据传输和释放连接三个阶段。TCP就是一种面向连接服务的协议。</p><p>   在无连接服务中，通信前双方不需要先建立连接，需要发送数据时可直接发送，把每个带有目的地址的包传送到线路上，由系统选定路线进行传输。这是一种不可靠的服务，这种服务常被描述为“尽最大可能交付”，它不能保证通信的可靠性。例如IP、UDP就是一种无连接服务的协议。</p><p>   （2）可靠服务与不可靠服务</p><p>   可靠服务是网络具有检错、纠错、应答机制，能保证数据正确、可靠地传送到目的地。</p><p>   不可靠服务是指网络只是尽量正确、可靠地传送，而不能保证数据正确、可靠地传送到目的地，是一种尽力而为的服务。</p><p>   （3）有应答服务和无应答服务</p><p>   有应答服务是指接收方在收到数据后向发送方给出相应的应答，该应答由传输系统同内部自动实现，而不由用户实现。所发送的应答既可以是可乐定应答，也可以是否定应答，通常在接收到数据有错误时发送否定应答。文件传输服务就是一种有应答服务。</p><p>   无应答服务是指接收方收到数据后不自动给出应答。若需要应答，则由高层实现。例如，对于WWW服务，客户端收到服务器发送的页面文件不给出应答。</p><h2 id="三、ISO-OSI参考模型和TCP-IP模型"><a href="#三、ISO-OSI参考模型和TCP-IP模型" class="headerlink" title="三、ISO/OSI参考模型和TCP/IP模型"></a>三、ISO/OSI参考模型和TCP/IP模型</h2><ol><li><p>OSI参考模型</p><p>国际标准化组织（ISO）提出的网络体系结构模型，称为开放系统互联参考模型。通常简称为OSI模型。OSI有7层，自下而上依次是物理层、数据链路层、网络层、传输层、会话层、表示层、应用层。</p><p>低三层称为通信子网，它是为了联网而附加的通信设备，完成数据的传输功能；高三层统称为资源子网，它相当于计算机系统，完成数据的处理等功能。</p><p>1）物理层</p><p>物理层的传输单位是比特，任务是透明的传输比特流，功能是在物理媒体上为数据端设备透明地提供传输原始比特流。</p><p>物理层主要定义数据终端设备(DTE)和数据通信设备（DCE）的物理与逻辑连接方法，所以物理层协议也称为物理层接口标准，也称为规程。</p><p>2）数据链路层</p><p>数据链路层的传输单位是帧，任务是将网络层传来的IP数据报组装成帧。数据链路层的功能可以概括为成帧、差错控制、流量控制和传输管理。</p><p>典型的数据链路层协议有SDLC、HDLC、PPP、STP和帧中继等。</p><p>3）网络层</p><p>网络层的传输单位是数据报，它关心的是通信子网的运行控制，主要任务是把网络层的协议数据单元（分组）从源端传送到目的端，为分组交换网上的不同主机提供通信服务。关键问题是对分组进行路由选择，并实现流量控制、拥塞控制、差错控制和网际互联等功能。</p><p>网络层的协议有IP、IPX、ICMP、IGMP、ARP 、RARP、OSPF等</p><p>4）传输层</p><p>传输层也称为运输层，传输大单位是报文段（TCP）或用户数据报（UDP），传输层负责主机中两个进程之间的通信，功能是为端到端连接提供可靠的传输服务，为端到端连接提供流量控制、差错控制、服务质量、数据传输管理等服务。</p><p>数据链路层提供的是点对点的通信，传输层提供的是端到端的通信。</p><p>传输层的协议有TCP、UDP</p><p>5）会话层</p><p>会话层允许不同的主机上的各个进程之间进行通信。会话层利用传输层提供的端到端的服务向表示层提供它的增值服务。这种服务主要为表示层实体或用户进程建立连接并在连接上有序地传输数据，这就是会话，也称为建立同步(SYN)。</p><p>会话层负责管理主机间的会话进程，包括建立、管理及终止进程间的会话。会话层可以使用校验点使通信会话在通信失效时从校验点继续恢复通信，实现数据同步。</p><p>6）表示层</p><p>表示层主要用于处理在两个通信系统中交换信息的表示形式。不同机器采用的编码和表示方法不同，使用的数据结构也不同。为了使不同表示方法的数据和信息之间能互相交流，表示层采用抽象的标准方法定义数据结构，并采用标准的编码形式。数据压缩、加密和解密也是表示层可提供的数据表示交换功能。</p><p>7）应用层</p><p>应用层是OIS模型的最高层，是用户与网络的界面。应用层为特定类型的网络应用提供访问OSI环境的手段。因为用户的实际应用多种多样，这就要求应用层采用不同的应用协议来解决不同类型的应用要求，因此应用层是最复杂的一层，使用的协议也最多。</p><p>典型的应用层协议有用于文件传输的FTP、用于电子邮件的SMTP、用于万维网的HTTP等。</p></li><li><p>TCP/IP模型</p><p>TCP/IP模型从低到高依次是网络接口层（对应OSI参考模型中的物理层和数据链路层）、网际层、传输层和应用层（对应OSI模型的会话层、表示层、应用层）。</p><p>1）网络接口层</p><p>网络接口层的功能类似于OSI的物理层和数据链路层。它表示与物理网络的接口，但实际上TCP/IP本身并未真正描述这一部分，只是指出主机必须使用某种协议和网络连接，以便在其上传递IP分组。</p><p>2）网际层</p><p>网际层（主机-主机）是TCP/IP体系结构的关键部分。它和OSI网络层在功能上是非常相似的。网际层将分组发往任何网络，并为之独立地选择合适的路由，但它不保证各个分组有序地到达，各个分组的有序交付由高层负责。</p><p>3）传输层</p><p>传输层（应用-应用或进程-进程）的功能同样与OSI中的传输层类似，使得发送端和目的端主机的对等实体进行会话。传输层主要使用以下两种协议：<br>（1） 传输控制协议（Transmission Control Protocol，TCP）。它是面向连接的，数据传输的单位是报文段，能够提供可靠的交付。</p><p>（2）用户数据报协议（User Datagram Protocol，UDP）。它是无连接的，数据传输的单位是用户数据报，不能保证提供可靠的交付，只能提供“尽最大努力交付”。</p><p>4）应用层（用户-用户）包含所有的高层协议。IP协议是因特网中的核心协议；TCP/IP可以为各种各样的应用提供服务，同时TCP/IP也允许在由各种网络构成的互联网上运行。</p></li><li><p>TCP/IP模型与OSI模型的比较</p><p>1）二者都采用分层的体系结构，分层的功能也大体相似</p><p>2）二者都基于独立的协议栈概念</p><p>3）二者都可以解决异构网络的互联，实现世界上不同厂家生产的计算机之间的通信</p><p>4）OSI模型最大的贡献是精确地定义了三个主要的概念：服务，协议和接口，与现代的面向对象程序设计思想非常吻合。而TCP/IP模型在这三个概念上却没有明确区分，不符合软件工程的思想</p><p>5）OSI模型产生在协议之前，没有偏向于任何特定的协议，通用性良好。TCP/IP模型产生于协议之后，实际是对协议的描述</p><p>6）TCP/IP在设计之初就考虑了多种异构网的互联问题，并将网际协议（IP）作为一个单独的重要层次。OSI模型最初只考虑到用一种标准的公用数据网络将不同的系统互联。OSI模型认识到网际协议IP的重要性后，只好在网络层中划分出一个子层来完成类似于TCP/IP模型中的IP功能</p><p>7）<strong>OSI模型在网络层支持无连接和面向连接的通信，但在传输层仅有面向连接的通信。而TCP/IP模型认为可靠性是端到端的问题，因此它在网际层仅有一种无连接的通信模式，但传输层支持无连接和面向连接两种模式</strong>。</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、计算机网络分层结构&quot;&gt;&lt;a href=&quot;#一、计算机网络分层结构&quot; class=&quot;headerlink&quot; title=&quot;一、计算机网络分层结构&quot;&gt;&lt;/a&gt;一、计算机网络分层结构&lt;/h2&gt;&lt;p&gt;两个系统中实体间的通信是一个很复杂的过程，为了降低协议设计和调试过程
      
    
    </summary>
    
      <category term="计算机网络" scheme="http://wanqbin.xyz/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="网络体系结构" scheme="http://wanqbin.xyz/tags/%E7%BD%91%E7%BB%9C%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>通信基础</title>
    <link href="http://wanqbin.xyz/2019/06/10/%E9%80%9A%E4%BF%A1%E5%9F%BA%E7%A1%80/"/>
    <id>http://wanqbin.xyz/2019/06/10/通信基础/</id>
    <published>2019-06-09T16:42:00.000Z</published>
    <updated>2019-06-13T16:43:00.054Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>写在前面</p></blockquote><p>物理层协议的主要任务就是确定与传输媒体的接口有关的一些特性，如下所述：</p><ol><li>机械特性：指明接口所用接线器的形状和尺寸、引脚数目和排列、固定和锁定装置等。</li><li>电气特性：指明在接口电缆的各条线上出现的电压范围1.</li><li>功能特性：指明某条线上出现的某一电平代表何种意义。</li><li>过程特性：指明对于不同功能的各种可能事件的出现顺序。</li></ol><h2 id="一、数据通信的模型"><a href="#一、数据通信的模型" class="headerlink" title="一、数据通信的模型"></a>一、数据通信的模型</h2><p>一个数据通信系统可划分为三大部分，即源系统（或发送端，发送方）、传输系统（或传输网络）和目的系统（或接收方、接收端）。</p><p>源系统一般包括两部分：</p><ol><li>源点：源点设备产生要传输的数据。</li><li>发送器：通常源点生成的数字比特流要通过发送器编码之后才能在传输系统中进行传输。</li></ol><p>目的系统一般包括两部分：</p><ol><li>接收器：接收传输系统传送过来的信号，并把它转换为能够被目的设备处理的信息。</li><li>终点：终点设备从接收器获取传送来的数字比特流，然后进行信息输出。终点又称为目的站或信宿。</li></ol><p>在源系统和目的系统之间的传输系统可以是简单的传输线路，也可以是连接在源系统和目的系统之间的复杂网络系统。</p><p>通信的目的是传送<strong>消息</strong>。</p><p><strong>数据</strong>是消息的实体。</p><p><strong>信号</strong>是数据的电器或电磁表现。根据信号中代表的消息的参数的取值方式不同，信号可分为两类：</p><ol><li>模拟信号（或连续信号）——消息的参数的取值时连续的</li><li>数字信号（或离散信号）——消息的参数的取值时离散的。在使用时间域的波形表示数字信号时，代表不同离散数值的基本波形就称为<strong>码元</strong>。在使用二进制编码时，只有两种不同的码元，一种代表0状态，另一种代表1状态。</li></ol><p><strong>速率、波特与带宽</strong></p><p>速率也称为数据率，指的是数据的传输速率，表示单位之间内传输的数据量。可以用码元传输速率和信息传输速率表示。</p><ol><li>码元传输速率。又称码元速率，波形速率等，它表示单位时间内数字通信系统所传输的码元个数，单位是波特（Baud）。1波特表示数字通信系统每秒传输一个码元。这里的码元可以是多进制的，也可以是二进制的，但码元速率与进制数无关。</li><li>信息传输速率。又称信息速率，比特率等。它表示单位时间内数字通信系统传输的二进制码元数（即比特数），单位是比特/秒（b/s).</li></ol><h2 id="二、编码与调制"><a href="#二、编码与调制" class="headerlink" title="二、编码与调制"></a>二、编码与调制</h2><ol><li><p>常用编码方式</p><p>要利用信道传输数据，必须将数据转换为能在传输媒体媒体上传送的信号。信道可以分为传送模拟信号的<strong>模拟信道</strong>和传送数字信号的<strong>数字信道</strong>两大类。</p><p>将数字数据转换为数字信号的过程称为<strong>编码</strong>。</p><p>将数字信号转换为模拟信号的过程称为<strong>调制</strong>。</p><p><img src="https://i.imgur.com/nvmtArH.png" alt></p></li></ol><p>   归零制：正脉冲代表1，负脉冲代表0；</p><p>   不归零制：正电平代表1，负电平代表0；</p><p>   曼彻斯特编码：位周期中心的是上跳变代表0，位周期中心的下跳变代表1；</p><p>   差分曼彻斯特编码：在每一位的中心处始终有跳变。位开始边界有跳变代表0，而位边界没有跳变代表1；</p><ol start="2"><li><p>基本的调制方法</p><p>矩形脉冲波形的数字信号包含从直流开始的低频分量，被称为<strong>基带信号</strong></p><p>在数字信道上直接传输基带信号的方法称为<strong>基带传输</strong></p><p>基带信号往往包含较多的低频成分，甚至直流成分。而许多模拟信道仅能通过某一频率范围的信号，不能直接传输这种基带信号。因此必须对基带信号进行<strong>调制</strong>，使它能够在模拟信道中传输。</p><p>在很多情况下，需要使用<strong>载波</strong>进行调制，把基带信号的频率范围搬移到较高的频段以便在信道中传输。经过载波调制后的信号称为<strong>带通信号</strong>，而使用载波的调制称为<strong>带通调制</strong>。</p><p>最基本的带通调制的方法有：<br>1）调幅（AM），即载波的增幅随基带数字信号而变化。</p><p>2）调频（FM），即载波的频率随着基带数字信号的变化而变化。</p><p>3）调相（PM），即载波的初始相位随基带数字信号而变化。</p><p>在数字通信中，调幅、调频和调相相应地称为<strong>幅移键控</strong>、<strong>频移键控</strong>和<strong>相移键控</strong>。实现调制和解调功能的设备称为<strong>调制解调器</strong>。</p></li></ol><h2 id="三、奈奎斯特定理与香农定理"><a href="#三、奈奎斯特定理与香农定理" class="headerlink" title="三、奈奎斯特定理与香农定理"></a>三、奈奎斯特定理与香农定理</h2><ol><li><p>奈奎斯特定理</p><p>奈奎斯特定理又称<strong>奈氏准则</strong>。它指出在理想低通（没有噪声、带宽有限）的信道中，极限码元速率为2W波特，其中W是理想低通信道的带宽，单位是Hz。若用V表示每个码元离散电平的数目（码元的离散电平数目是指有多少种不同的码元，比如有16种不同的码元，则需要有4位二进制位，因此数据传输率是码元传输率的4倍），则极限速率为</p><p>​                                理想低通信道下的极限数据传输率=$2Wlog_2V$（单位为b/s)</p><p>对于奈氏准则，可以得出以下结论：</p><p>1）在任何信道中，码元传输的速率是有上限的。若传输速率超过此上限，就会出现严重的码间串扰问题，使得接收端不可能完全正确地识别码元。</p><p>2）信道的频带越宽(即通过的信号高频分量越多)，就可用更高的速率进行码元的有效传输。</p><p>3）奈氏准则给出了码元传输速率的限制，但是并未对信息传输速率给出限制，即未对一个码元可以对应多少个二进制位给出限制。</p><p>由于码元的传输速率受奈氏准则的制约，所以要提高数据的传输速率，就必须设法使每个码元携带更多个比特的信息量，此时就需要多元制的调制方法。</p></li><li><p>香农定理</p><p>香农定理给出了带宽受限且有高斯白噪声干扰的信道的极限数据传输率，当用此速率进行传输时，可以做到不产生误差。香农定理定义为：</p><p>​    信道的极限数据传输率=$Wlog_2(1+S/N)$ 单位为b/s</p><p>式中，W为信道带宽，S为信道所传输信号的平均功率，N为信道内部的高斯噪声功率，$S/N$为信噪比，即信号的平均功率与噪声的平均功率之比。</p><p>对于香农定理，可以得出以下的结论：<br>1）信道的带宽或信道中的信噪比越大，信息的极限传输速率越高。</p><p>2）对一定的传输带宽和一定的信噪比，信息传输速率的上限是确定的。</p><p>3）只要信息的传输速率低于信道的极限传输速率，就能找到某种方法来实现无差错的传输。</p><p>4）香农定理得出的是极限信息传输速率，实际信道能达到的传输速率比它低不少。</p><p>从香农定理可以看出，若信道带宽W或信噪比S/N没有上限，则信道的极限信息传输速率也没有上限。</p><p>奈氏准则只考虑了带宽与极限码元速率的关系，而香农定义不仅考虑了带宽，而且考虑到了信噪比。这从另一个侧面表明，一个码元对应的二进制位数是有限的。</p><h2 id="四、传输方式"><a href="#四、传输方式" class="headerlink" title="四、传输方式"></a>四、传输方式</h2><ol><li><p>并行传输与串行传输</p><p>并行传输，是指一次发送n个比特而不是一个比特，为此，在发送端和接收端之间需要有n条传输线路。</p><p>串行传输，是指数据是一个比特一个比特发送的，为此，发送端和接收端之间只需要一条传输线路。</p></li><li><p>异步传输与同步传输</p><p>异步传输以字节为独立的传输单位，字节之间的时间间隔不是固定的，接收端仅在每个字节的起始处对字节内的比特实现同步。为此，通常需要在每个字节前后分别加上起始位和结束位，这里的异步是指在字节级上的异步，但是字节中的每个比特仍然要同步，它们的持续时间是相同的。</p><p>采用同步传输方式时，数据块以稳定的比特流形式传输，字节之间没有间隔，也没有起始位和结束位。由于不同设备的时钟频率存在一定差异，为避免在传输大量数据的过程中累积误差所导致的错误，要采取技术使得收发双方的时钟保持同步。实现收发双方时钟同步的方法有两种，即外同步和内同步。</p><p><strong>外同步</strong>，是在发送端和接收端之间提供一条单独的时钟线，发送端在发送数据信号的同时，另外发送一条时钟同步信号。接收端根据接收到的时钟同步信号来校正时间基准，实现收发双方之间的同步。</p><p><strong>内同步</strong>，是发送端将时钟同步信号编码到发送数据中一起传输，如曼彻斯特编码与差分曼彻斯特编码都含有时钟编码，具有自同步能力。</p></li><li><p>单工、半双工、全双工</p><p>1）单向通信，又称为单工通信，即只能有一个方向的通信而没有反方向的交互。如广播等。</p><p>2）双向交替通信，又称半双工通信，即通信的双方都可以发送信息，但不能双方同时发送。这种通信方式是一方发送另一方接收，过一段时间再反回来。</p><p>3）双向同时通信，又称为全双工通信，即通信的双方可以同时发送和接收信息。</p></li></ol></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;写在前面&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;物理层协议的主要任务就是确定与传输媒体的接口有关的一些特性，如下所述：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;机械特性：指明接口所用接线器的形状和尺寸、引脚数目和排列、固定和锁定装置等。&lt;/li&gt;
&lt;li&gt;电
      
    
    </summary>
    
      <category term="计算机网络" scheme="http://wanqbin.xyz/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="通信" scheme="http://wanqbin.xyz/tags/%E9%80%9A%E4%BF%A1/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络概述</title>
    <link href="http://wanqbin.xyz/2019/06/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%A6%82%E8%BF%B0/"/>
    <id>http://wanqbin.xyz/2019/06/10/计算机网络概述/</id>
    <published>2019-06-09T16:40:00.000Z</published>
    <updated>2019-06-15T12:54:43.727Z</updated>
    
    <content type="html"><![CDATA[<h4 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h4><p>一般认为，计算机网路是一个将分散的、具有独立功能的计算机系统，通过通信设备与线路连接在一起，由功能完善的软件实现资源共享和信息传递的系统。简言之，计算机网络就是一些互联的、自治的计算机系统的集合。 </p><h2 id="一、计算机网络"><a href="#一、计算机网络" class="headerlink" title="一、计算机网络"></a>一、计算机网络</h2><p>在计算机的不同发展阶段，网络有不同的定义，这些定义反映了当时网络技术的发展水平。分为三类：</p><ol><li><p>广义观点</p><p>广义观点认为，只要是能实现远程信息处理的系统或能进一步达到资源共享的系统，，都是计算机网络。</p></li><li><p>资源共享观点</p><p>资源共享观点认为，计算机网络是“以能够相互共享资源的方式互联起来的自治计算机系统的集合”。这个定义符合目前计算机网络的基本特征。</p></li><li><p>用户透明性观点</p><p>这种观点认为，存在一个能为用户自动管理资源的网络操作系统。它能够调用用户所需要的资源，而整个网络就像是一个大的计算机系统一样对用户是透明的。用户透明性观点的定义描述了一个分布式系统，它是网络未来发展追求的目标。</p></li></ol><h2 id="二、计算机网络的组成"><a href="#二、计算机网络的组成" class="headerlink" title="二、计算机网络的组成"></a>二、计算机网络的组成</h2><p>从不同的角度，可以将计算机网路的组成分为以下几类：</p><ol><li>从组成部分上来看，一个完整的计算机网络主要由硬件、软件、协议散发部分组成。<strong>硬件</strong>主要由主机（端系统）、通信链路（如双绞线、光纤）、交换设备（如交换机、路由器）和通信处理机（如网卡）等组成。<strong>软件</strong>主要包括各种实现资源共享的软件和方便用户使用的各种工具软件。软件部分多属于应用层。<strong>协议</strong>是计算机网络的核心。</li><li>从工作方式看，计算机网络可分为边缘部分和核心部分。边缘部分由所有连接到因特网上、供用户使用的端系统组成，用来进行通信和资源共享。核心部分由大量的网络和连接这些网络的路由器组成，为边缘部分提供连通性和交换服务。</li><li>从功能组成上看，计算机网络由通信子网和资源子网构成。通信子网由各种传输介质、通信设备和相应的网络协议组成，它使网络具有数据传输、交换、控制和存储的能力，实现联网计算机之间的数据通信。资源子网是实现资源共享功能的设备及其软件的集合，向用户提供共享其他其他计算机上的硬件资源、软件资源和数据资源的服务。</li></ol><h2 id="三、计算机网络的功能"><a href="#三、计算机网络的功能" class="headerlink" title="三、计算机网络的功能"></a>三、计算机网络的功能</h2><p>计算机网路的功能很多，现如今的很多应用都与网络有关。主要有下面5个部分。</p><ol><li><p>数据通信</p><p>它是计算机网络最基本也是最重要的功能，用来实现联网计算机之间的各种信息的传输，并将分散在不同地理位置的计算机联系起来，进行统一的调配、控制和管理。</p></li><li><p>资源共享</p><p>资源共享可以是软件共享、数据共享，也可以是硬件共享。使计算机网络中的资源互通有无，分工协作，从而极大地提高了硬件资源、软件资源和数据资源的利用率</p></li><li><p>分布式处理</p><p>当计算机网络中的某个计算机负荷过重时，可以将其处理的某个复杂的任务分配给网络中的其他计算机系统，从而利用空闲资源以提高整个系统的利用率</p></li><li><p>提高可靠性</p><p>计算机网络中的各台计算机通过网络互为替代机</p></li><li><p>负载均衡</p><p>将工作任务均衡地分配给计算机网络中的各台计算机。</p></li></ol><h2 id="四、计算机网络的分类"><a href="#四、计算机网络的分类" class="headerlink" title="四、计算机网络的分类"></a>四、计算机网络的分类</h2><ol><li><p>按分布范围分：</p><p>1) 广域网（WAN）。任务是提供长距离通信，运送主机所发送的数据。</p><p>2）城域网（MAN）。城域网的覆盖范围可以跨越几个街区甚至几个城市，大多采用以太网技术。</p><p>3）局域网（LAN）。局域网一般用微机或工作站通过高速线路相连，覆盖范围较小。传统上，局域网使用广播技术，而广域网使用交换技术。</p><p>4）个人局域网（PAN）。在个人工作的地方将消费电子设备用无线技术连接起来的网络。</p></li><li><p>按传输技术分：</p><p>1）广播式网络。所有联网计算机都共享一个公共通信信道。当一台计算机利用共享通信信道发送报文分组时，所有其他的计算机都会“收听”到这个分组。接收到该分组的计算机将通过检查目的地址来决定是否接收该分组。</p><p>局域网基本上都采用广播式通信技术，广域网中的无线，卫星通信网络也采用广播式通信技术。</p><p>2）点对点网络。每条物理线路连接一对计算机。如果通信的两台计算机之间没有直接连接线路，那么它们之间的分组传输就要通过中间结点的接收、存储和转发，直至目的结点。</p><p>是否采用分组存储转发与路由选择机制是点对点网络与广播式网络的重要区别，广域网基本都属于点对点网络。</p></li><li><p>按拓扑结构分:</p><p>网络拓扑结构是指由网中结点（路由器、主机等）与通信线路（网线）之间的几何关系表示的网络结构，主要指通信子网的拓扑结构。</p><p>按网络的拓扑结构，主要分为星形、总线形、环形和网状形网络等。星形、总线形和环形网络多用于局域网，网状网络多用于广域网。</p><p>1）星形网络。每个终端或计算机都以单独的线路与中央设备相连。中央设备早期是计算机，现在一般是交换机或路由器。星形网络便于集中控制和管理，因为端用户之间的通信必须通过中间设备。缺点是成本高，中心节点对故障敏感。</p><p>2）总线形网络。用单根传输线将计算机连接起来。总线形网络的优点是建网容易，增减节点方便，节省线路。缺点是重负载时通信效率不高，总线任意一处对故障敏感。</p><p>3）环形网络。所有计算机接口设备连接成一个环。环形网络最典型的例子是令牌环局域网。环可以是单环，也可以是双环，环中信号是单向传输的。</p><p>4）网状网络。一般情况下，每个结点至少有两条路径与其他节点相连，多用于广域网中。有规则型和非规则型。其优点是可靠性高，缺点是控制复杂，线路成本高。</p></li><li><p>按使用者分:</p><p>1）公用网。指电信公司出资建造的大型网络。</p><p>2）专用网。指某个部门为了满足本单位特殊业务的需要而建造的网络，这种网络不对单位以外的人开放。</p></li><li><p>按交换技术分：</p><p>1）电路交换网络。在源结点和目的结点之间建立一条专用的通路用于传送数据，包括建立连接、传输数据和断开连接三个阶段。最典型的电路交换网络是传统电话网络。</p><p>该类网络的主要特点是整个报文的比特流连续地从源点直达终点，好像是在一条管道中传送。优点是数据直接传送，时延小。缺点是线路利用率低、不能充分利用线路容量，不便于进行差错控制。</p><p>2）报文交换网络。用户数据加上源地址、目的地址、校验码等辅助信息，然后封装成报文。整个报文传送到相邻结点全部存储后，再转发到下一个结点，重复这一过程直到到达目的结点。每个报文可以单独选择到达目的结点的路径。</p><p>报文交换网络也称存储-转发网络，主要特点是整个报文先传送到相邻结点，全部存储后查找转发表，转发到下一个结点。优点是可以较为充分的利用线路容量，可以实现不同链路之间不同数据率的转换，可以实现格式转换，可以实现一对多，多对一的访问，可以实现差错控制。缺点是增大了资源开销，增加了缓冲时延，需要额外的控制机制来保证多个报文的顺序不乱序，缓冲区难以管理。</p><p>3）分组交换网络。也称包交换网络。其原理是将数据分为较短的固定长度的数据块，在每个数据块中加上目的地址、源地址等辅助信息组成分组（包），以存储-转发方式传输。</p><p>其主要特点是单个分组传送到相邻结点，存储后查找转发表，转发到下一个结点。除具备报文交换网络的优点外，分组交换网络还具有自身的优点：缓冲易于管理；包的平均时延更小，网络占用的平均缓冲更少；易于标准化；更适合应用。现在的主流网络基本上都可视为分组交换网络。</p></li><li><p>按传输介质分：</p><p>传输介质可分为有线和无线两大类，故网络可分为有线网络和无线网络。有线网络又分为双绞线网络，同轴电缆网络等。无线网络可分为蓝牙、微波、无线电等。</p></li></ol><h2 id="五、计算机网络的的性能指标"><a href="#五、计算机网络的的性能指标" class="headerlink" title="五、计算机网络的的性能指标"></a>五、计算机网络的的性能指标</h2><p>性能指标从不同的方面来度量计算机网络的性能。</p><ol><li><p>速率</p><p>速率是数据的传送速率，它也称为数据率或比特率。</p></li><li><p>带宽</p><p>本来表示某个信号具有的频带宽度，单位是赫兹（Hz），而在计算机网络分钟，带宽用来表示网络的通信线路所能传送数据的能力，单位是比特/秒（b/s）</p></li><li><p>吞吐量</p><p>也称为吞吐率，表示单位时间内通过某个网络（或信道、接口）的数据量。</p></li><li><p>时延</p><p>时延是指一个数据（一个报文或分组，甚至比特）从网路（或链路）的一端传送到另一端所需要的时间。时延有时称为延迟或迟延。</p><p>1）发送时延，是主机或路由器将分组发送到通信线路上所需要的时间。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">发送时延=分组长度/发送速率</span><br></pre></td></tr></table></figure><p>2）传播时延，是电磁波在信道中传播需要一定的距离而花费的时间。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">传播时延=信道长度/电磁波在信道上的传播速率</span><br></pre></td></tr></table></figure><p>3）处理时延，主机或路由器收到分组时要花费一定的时间进行处理，例如，分析分组的首部、从分组中提取数据部分、进行差错检验或查找适当的路由等，这就产生了处理时延。</p><p>4）排队时延，分组在进入路由器后要先在输入队列在排队等待处理。路由器确定转发端口后，还要在输出队列中排队等待转发，这就产生了排队时延。</p><p>这样，分组从一个结点转发到另一个结点转发到另一个结点所经历的时延就是以上4种时延之和。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">总时延=发送时延+传播时延+处理时延+排队时延</span><br></pre></td></tr></table></figure></li><li><p>丢包率</p><p>即分组丢失率，是指在一定的时间范围内，分组在传输过程中丢失的分组数量和总的分组数量的比率。</p><p>分组丢失的两种情况：一是因为传输过程中出现比特级差错被结点丢弃。二是因为分组交换机队列溢出。</p></li><li><p>利用率</p><p>令D0表示网络空闲时的时延，D表示网络当前时延，那么在适当的假定条件下，利用率可表示为：D=D0/1-U。</p><p>信道或网络利用率过高会产生非常大的时延。</p></li><li><p>时延带宽积</p><p>指发送端连续发送数据且发送的第一个比特即将到达终点时，发送端已经发出的比特数，即时延带宽积=传播时延*信道带宽。</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h4&gt;&lt;p&gt;一般认为，计算机网路是一个将分散的、具有独立功能的计算机系统，通过通信设备与线路连接在一起，由功能完善的软件实现资源共享和信
      
    
    </summary>
    
      <category term="计算机网络" scheme="http://wanqbin.xyz/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="计算机网络" scheme="http://wanqbin.xyz/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>顺序循环链表的实现</title>
    <link href="http://wanqbin.xyz/2019/03/31/%E9%A1%BA%E5%BA%8F%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8%E7%9A%84%E5%AE%9E%E7%8E%B0/"/>
    <id>http://wanqbin.xyz/2019/03/31/顺序循环链表的实现/</id>
    <published>2019-03-31T13:02:00.000Z</published>
    <updated>2019-06-15T13:02:54.376Z</updated>
    
    <content type="html"><![CDATA[<h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>&emsp;&emsp;队列（Queue)是一种特殊的线性表，是一种只允许在表的一端进行插入操作，在表的另一端进行删除操作的线性表。表中允许进行插入操作的一端称为队尾，允许进行删除操作的一端为队头。队头和队尾分别由队头指示器和队尾指示器指示。队列的插入操作通常称为入队，队列的删除操作通常称为出队。当队列中没有元素时，为空队列。<br>&emsp;&emsp;根据队列的定义，每次进队列的数据元素都放在原来的队尾之后成为新的队尾元素，每次出队列得到数据元素都是原来的队头元素。这样，最先入队的数据元素总是最先出队，所以队列也被称为先进先出表。<br>&emsp;&emsp;对队列的操作主要有：初始化建立队列、入队列、出队列、取队头元素、判断队列是否为空等操作。   </p><blockquote><h1 id="1-顺序队列的类定义"><a href="#1-顺序队列的类定义" class="headerlink" title="1.顺序队列的类定义"></a>1.顺序队列的类定义</h1></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxsize = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">Queue</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Queue();<span class="comment">//构造函数</span></span><br><span class="line">~Queue() &#123;&#125;;<span class="comment">//析构函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">const</span> T&amp;item)</span></span>;<span class="comment">//入队</span></span><br><span class="line"><span class="function">T <span class="title">delet</span><span class="params">()</span></span>;<span class="comment">//出队列</span></span><br><span class="line"><span class="function">T <span class="title">readFront</span><span class="params">()</span> <span class="keyword">const</span></span>;<span class="comment">//读队头元素</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="keyword">const</span></span>;<span class="comment">//判断队列是否为空</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clearQueue</span><span class="params">()</span></span>;<span class="comment">//清空队列</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getsize</span><span class="params">()</span> <span class="keyword">const</span></span>;<span class="comment">//获取队列长度</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> <span class="keyword">const</span></span>;<span class="comment">//输出队列中的元素</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">T data[maxsize];</span><br><span class="line"><span class="keyword">int</span> front;</span><br><span class="line"><span class="keyword">int</span> rear;</span><br><span class="line"><span class="keyword">int</span> count;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><h1 id="2-顺序队列类的实现"><a href="#2-顺序队列类的实现" class="headerlink" title="2.顺序队列类的实现"></a>2.顺序队列类的实现</h1></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">Queue</span>&lt;T&gt;:</span>:Queue()</span><br><span class="line">&#123;</span><br><span class="line">front = <span class="number">0</span>;</span><br><span class="line">rear = <span class="number">0</span>;</span><br><span class="line">count = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> <span class="title">Queue</span>&lt;T&gt;:</span>:insert(<span class="keyword">const</span> T &amp; item)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (count == maxsize)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Queue is full"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">count++;</span><br><span class="line">data[rear] = item;</span><br><span class="line">rear = ((rear + <span class="number">1</span>) == maxsize) ? <span class="number">0</span> : (rear + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">T</span> <span class="title">Queue</span>&lt;T&gt;:</span>:delet()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (count&lt;=<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Queue is empty"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">count--;</span><br><span class="line">T p = data[front];</span><br><span class="line">front = ((front + <span class="number">1</span>) == maxsize) ? <span class="number">0</span> : (front + <span class="number">1</span>);</span><br><span class="line"><span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">T</span> <span class="title">Queue</span>&lt;T&gt;:</span>:readFront() <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> data[front];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">bool</span> <span class="title">Queue</span>&lt;T&gt;:</span>:empty() <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> (count == <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> <span class="title">Queue</span>&lt;T&gt;:</span>:clearQueue()</span><br><span class="line">&#123;</span><br><span class="line">count = <span class="number">0</span>;</span><br><span class="line">front = rear = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">int</span> <span class="title">Queue</span>&lt;T&gt;:</span>:getsize() <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> <span class="title">Queue</span>&lt;T&gt;:</span>:display() <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (i != count)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">"号元素："</span> &lt;&lt; data[i] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><h1 id="3-测试主函数"><a href="#3-测试主函数" class="headerlink" title="3.测试主函数"></a>3.测试主函数</h1></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Queue&lt;<span class="keyword">int</span>&gt; <span class="built_in">queue</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">queue</span>.insert(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt;<span class="string">"队列的长度为："</span>&lt;&lt; <span class="built_in">queue</span>.getsize() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">queue</span>.display();</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt;<span class="string">"队头元素为："</span>&lt;&lt; <span class="built_in">queue</span>.readFront() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"元素："</span>&lt;&lt;<span class="built_in">queue</span>.delet()&lt;&lt;<span class="string">"已删除"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">test();</span><br><span class="line">system(<span class="string">"pause"</span>);</span><br><span class="line"><span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果如下：  </p><p><img src="https://i.imgur.com/y68ufXG.png" alt>  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h2&gt;&lt;p&gt;&amp;emsp;&amp;emsp;队列（Queue)是一种特殊的线性表，是一种只允许在表的一端进行插入操作，在表的另一端进行删除操作的
      
    
    </summary>
    
      <category term="C++" scheme="http://wanqbin.xyz/categories/C/"/>
    
    
      <category term="C++" scheme="http://wanqbin.xyz/tags/C/"/>
    
      <category term="顺序循环链表" scheme="http://wanqbin.xyz/tags/%E9%A1%BA%E5%BA%8F%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8/"/>
    
      <category term="链表" scheme="http://wanqbin.xyz/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>链式队列的实现</title>
    <link href="http://wanqbin.xyz/2019/03/31/%E9%93%BE%E5%BC%8F%E9%98%9F%E5%88%97%E7%9A%84%E5%AE%9E%E7%8E%B0-1/"/>
    <id>http://wanqbin.xyz/2019/03/31/链式队列的实现-1/</id>
    <published>2019-03-31T13:01:00.000Z</published>
    <updated>2019-06-15T13:01:45.214Z</updated>
    
    <content type="html"><![CDATA[<h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>&emsp;&emsp;链式队列是队列的链式存储结构表示。队列是操作受限的表，队列有队头和队尾，插入元素的一端称为队尾，删除元素的一端称为队头。这和一般排队的概念一样，后来的人排在队尾，首先对队头的人进行服务，对队头的人服务后，原当前队头后的人就排在了当前队头。新来的人排在队尾后，原队尾的人就不再是当前队尾了，新来的人就成了当前队尾。<br>&emsp;&emsp;链式队列的队头指针指在队列的当前队头节点位置，队尾指针指在队列的当前队尾节点位置。不带头节点的链式队列，出队列时可直接删除头指针所指的节点，因此，链式队列不带头指针时更加方便。<br><br></p><blockquote><h1 id="1-链式队列节点类的定义和实现"><a href="#1-链式队列节点类的定义和实现" class="headerlink" title="1.链式队列节点类的定义和实现"></a>1.链式队列节点类的定义和实现</h1></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">LinkQueue</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">QueueNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkQueue</span>&lt;T&gt;;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">T data;</span><br><span class="line">QueueNode&lt;T&gt;(<span class="keyword">const</span> T&amp; item, QueueNode&lt;T&gt; *ptrNext = <span class="literal">NULL</span>);</span><br><span class="line">~QueueNode() &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">QueueNode&lt;T&gt; *next;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">QueueNode</span>&lt;T&gt;:</span>:QueueNode(<span class="keyword">const</span> T &amp; item, QueueNode&lt;T&gt;* ptrNext)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;data = item;</span><br><span class="line"><span class="keyword">this</span>-&gt;next = ptrNext;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><h1 id="2-链式队列类的定义"><a href="#2-链式队列类的定义" class="headerlink" title="2.链式队列类的定义"></a>2.链式队列类的定义</h1></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">LinkQueue</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">LinkQueue();<span class="comment">//构造函数</span></span><br><span class="line">~LinkQueue();<span class="comment">//析构函数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">const</span> T&amp; item)</span></span>;<span class="comment">//入队</span></span><br><span class="line"><span class="function">T <span class="title">delet</span><span class="params">()</span></span>;<span class="comment">//出队</span></span><br><span class="line"><span class="function">T <span class="title">readFront</span><span class="params">()</span> <span class="keyword">const</span></span>;<span class="comment">//读队头元素</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="keyword">const</span></span>;<span class="comment">//判断队列是否为空</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clearQueue</span><span class="params">()</span></span>;<span class="comment">//清空队列</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span> <span class="keyword">const</span></span>;<span class="comment">//取队列长度</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> <span class="keyword">const</span></span>;<span class="comment">//输出队列元素</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">QueueNode&lt;T&gt; *front;<span class="comment">//指向队头的指针</span></span><br><span class="line">QueueNode&lt;T&gt; *rear;<span class="comment">//指向队尾的指针</span></span><br><span class="line"><span class="keyword">int</span> size;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><h1 id="3-链式队列类的实现"><a href="#3-链式队列类的实现" class="headerlink" title="3.链式队列类的实现"></a>3.链式队列类的实现</h1></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">LinkQueue</span>&lt;T&gt;:</span>:LinkQueue()</span><br><span class="line">&#123;</span><br><span class="line">size = <span class="number">0</span>;</span><br><span class="line">front = rear = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">LinkQueue</span>&lt;T&gt;:</span>:~LinkQueue()</span><br><span class="line">&#123;</span><br><span class="line">clearQueue();</span><br><span class="line">front = rear = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> <span class="title">LinkQueue</span>&lt;T&gt;:</span>:insert(<span class="keyword">const</span> T &amp; item)</span><br><span class="line">&#123;</span><br><span class="line">QueueNode&lt;T&gt; *new_node = <span class="keyword">new</span> QueueNode&lt;T&gt;(item);</span><br><span class="line"><span class="keyword">if</span> (rear != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">rear-&gt;next = new_node;</span><br><span class="line">&#125;</span><br><span class="line">rear = new_node;</span><br><span class="line"><span class="keyword">if</span> (front == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">front = new_node;</span><br><span class="line">&#125;</span><br><span class="line">size++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">T</span> <span class="title">LinkQueue</span>&lt;T&gt;:</span>:delet()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (size == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Queue is empty"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">T member = front-&gt;data;</span><br><span class="line">QueueNode&lt;T&gt; *p = front-&gt;next;</span><br><span class="line"><span class="keyword">delete</span> front;</span><br><span class="line">front = p;</span><br><span class="line">size--;</span><br><span class="line"><span class="keyword">return</span> member;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">T</span> <span class="title">LinkQueue</span>&lt;T&gt;:</span>:readFront() <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> front-&gt;data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">bool</span> <span class="title">LinkQueue</span>&lt;T&gt;:</span>:empty() <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> (size==<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> <span class="title">LinkQueue</span>&lt;T&gt;:</span>:clearQueue()</span><br><span class="line">&#123;</span><br><span class="line">QueueNode&lt;T&gt; *p1, *p2;</span><br><span class="line">p1 = front;</span><br><span class="line"><span class="keyword">while</span> (p1 != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">p2 = p1;</span><br><span class="line">p1 = p1-&gt;next;</span><br><span class="line"><span class="keyword">delete</span> p2;</span><br><span class="line">&#125;</span><br><span class="line">size = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">int</span> <span class="title">LinkQueue</span>&lt;T&gt;:</span>:getSize() <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> <span class="title">LinkQueue</span>&lt;T&gt;:</span>:display() <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">QueueNode&lt;T&gt; *p = front;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (p != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"第"</span> &lt;&lt; i &lt;&lt; <span class="string">"号元素为："</span> &lt;&lt; p-&gt;data &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">i++;</span><br><span class="line">p = p-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><h1 id="4-测试主函数"><a href="#4-测试主函数" class="headerlink" title="4.测试主函数"></a>4.测试主函数</h1></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">LinkQueue&lt;<span class="keyword">int</span>&gt; <span class="built_in">queue</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">queue</span>.insert(i * <span class="number">10</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"队列长度为："</span> &lt;&lt; <span class="built_in">queue</span>.getSize() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">queue</span>.display();</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"栈顶元素为："</span> &lt;&lt; <span class="built_in">queue</span>.readFront() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"元素："</span> &lt;&lt; <span class="built_in">queue</span>.delet() &lt;&lt; <span class="string">"被删除"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"队列长度为："</span> &lt;&lt; <span class="built_in">queue</span>.getSize() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">test();</span><br><span class="line">system(<span class="string">"pause"</span>);</span><br><span class="line"><span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">&#125;<span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">LinkQueue&lt;<span class="keyword">int</span>&gt; <span class="built_in">queue</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">queue</span>.insert(i * <span class="number">10</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"队列长度为："</span> &lt;&lt; <span class="built_in">queue</span>.getSize() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">queue</span>.display();</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"栈顶元素为："</span> &lt;&lt; <span class="built_in">queue</span>.readFront() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"元素："</span> &lt;&lt; <span class="built_in">queue</span>.delet() &lt;&lt; <span class="string">"被删除"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"队列长度为："</span> &lt;&lt; <span class="built_in">queue</span>.getSize() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">test();</span><br><span class="line">system(<span class="string">"pause"</span>);</span><br><span class="line"><span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果如下：<br><img src="https://i.imgur.com/NmtLrOb.png" alt>   </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h2&gt;&lt;p&gt;&amp;emsp;&amp;emsp;链式队列是队列的链式存储结构表示。队列是操作受限的表，队列有队头和队尾，插入元素的一端称为队尾，删除
      
    
    </summary>
    
      <category term="C++" scheme="http://wanqbin.xyz/categories/C/"/>
    
    
      <category term="C++" scheme="http://wanqbin.xyz/tags/C/"/>
    
      <category term="队列" scheme="http://wanqbin.xyz/tags/%E9%98%9F%E5%88%97/"/>
    
      <category term="链式队列" scheme="http://wanqbin.xyz/tags/%E9%93%BE%E5%BC%8F%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>双向循环链表</title>
    <link href="http://wanqbin.xyz/2019/03/28/%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8/"/>
    <id>http://wanqbin.xyz/2019/03/28/循环链表/</id>
    <published>2019-03-28T13:00:00.000Z</published>
    <updated>2019-06-15T13:02:37.349Z</updated>
    
    <content type="html"><![CDATA[<h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>&emsp;&emsp;双向循环链表（Double Circular Linked List)是每个节点有前趋指针和后继指针，且后继指针和前趋指针各自构成自己的单循环链表的链表。<br>&emsp;&emsp;在单链表中查找当前节点的后继节点并不困难，可以通过当前节点的next指针进行，但要查找当前节点的前趋节点就要从头指针head开始重新进行。对于一个要进行频繁查找当前节点的后继节点和当前节点的前趋节点的应用来说，使用单链表的时间效率是非常低的，双向链表是有效解决这类问题的选择。<br>&emsp;&emsp;在双向链表中，每个节点包括三个域，分别是<code>data</code>,<code>next</code>,<code>prior</code>。其中data为数据域，next为后继节点指针，prior为前趋节点指针。<br>&emsp;&emsp;双向链表通常均为双向循环链表，这是因为读双向循环链表，不论是插入还是删除，对第一个节点、最后一个节点的操作和对链表中间任意一个节点的操作过程是一样的。而双向非循环链表对这些节点的操作是不同的。   </p><blockquote><h1 id="1-节点类的定义和实现"><a href="#1-节点类的定义和实现" class="headerlink" title="1.节点类的定义和实现"></a>1.节点类的定义和实现</h1></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">DCirlist</span>;</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">DLnode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">DCirlist</span>&lt;T&gt;;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">T data;</span><br><span class="line"><span class="comment">//构造函数，无数据域的头结点</span></span><br><span class="line">DLnode&lt;T&gt;(DLnode&lt;T&gt; *ptrn = <span class="literal">NULL</span>, DLnode&lt;T&gt; *ptrp = <span class="literal">NULL</span>)&#123;&#125;;</span><br><span class="line"><span class="comment">//构造函数，非头节点的节点</span></span><br><span class="line">DLnode&lt;T&gt;( T item, DLnode&lt;T&gt; *ptrn = <span class="literal">NULL</span>, DLnode&lt;T&gt; *ptrp = <span class="literal">NULL</span>);</span><br><span class="line"><span class="comment">//析构函数</span></span><br><span class="line">~DLnode() &#123;&#125;;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">DLnode&lt;T&gt; *next;</span><br><span class="line">DLnode&lt;T&gt; *prior;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">DLnode</span>&lt;T&gt;:</span>:DLnode(T item, DLnode&lt;T&gt;* ptrn, DLnode&lt;T&gt;* ptrp)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;data = item;</span><br><span class="line"><span class="keyword">this</span>-&gt;next = ptrn;</span><br><span class="line"><span class="keyword">this</span>-&gt;prior = ptrp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;双向循环链表只是在单循环链表的基础上又增加了一个指向前趋节点的指针，而且指向前趋节点指针也构成了自己的单循环链表。双循环链表的定义与单循环链表的定义非常相似。   </p><blockquote><h1 id="2-双向循环链表类的定义"><a href="#2-双向循环链表类的定义" class="headerlink" title="2.双向循环链表类的定义"></a>2.双向循环链表类的定义</h1></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">DCirlist</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">DCirlist();<span class="comment">//构造函数</span></span><br><span class="line">~DCirlist();<span class="comment">//析构函数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">listsize</span><span class="params">()</span> <span class="keyword">const</span></span>;<span class="comment">//返回链表长度</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="keyword">const</span></span>;<span class="comment">//判断链表是否为空</span></span><br><span class="line">DLnode&lt;T&gt; *index(<span class="keyword">int</span> pos) <span class="keyword">const</span>;<span class="comment">//返回指向第pos个节点的指针</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">const</span> T &amp;item, <span class="keyword">int</span> pos)</span></span>;<span class="comment">//在第pos个节点插入item</span></span><br><span class="line"><span class="function">T <span class="title">del</span><span class="params">(<span class="keyword">int</span> pos)</span></span>;<span class="comment">//删除第pos个节点，并返回数据域</span></span><br><span class="line"><span class="function">T <span class="title">getdata</span><span class="params">(<span class="keyword">int</span> pos)</span> <span class="keyword">const</span></span>;<span class="comment">//返回第pos个节点的值</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clearlist</span><span class="params">()</span></span>;<span class="comment">//清空表</span></span><br><span class="line"></span><br><span class="line">DLnode&lt;T&gt; *reset(<span class="keyword">int</span> pos = <span class="number">0</span>);</span><br><span class="line">DLnode&lt;T&gt; *next();</span><br><span class="line">DLnode&lt;T&gt; *prior();</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">EndOfList</span><span class="params">()</span> <span class="keyword">const</span></span>;<span class="comment">//是否到链表尾</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">nextEndoflist</span><span class="params">()</span> <span class="keyword">const</span></span>;<span class="comment">//currPtr-&gt;next是否到链表尾</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">PriorEndoflist</span><span class="params">()</span> <span class="keyword">const</span></span>;<span class="comment">//currPtr-&gt;prior是否到链表尾</span></span><br><span class="line"><span class="function">T <span class="title">deleprior</span><span class="params">()</span></span>;<span class="comment">//删除currPtr节点，新currPtr是原currPtr的前趋，返回数据域</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">DLnode&lt;T&gt; *head;</span><br><span class="line">DLnode&lt;T&gt; *currPtr;</span><br><span class="line"><span class="keyword">int</span> size;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><h1 id="3-双向循环链表类的实现"><a href="#3-双向循环链表类的实现" class="headerlink" title="3.双向循环链表类的实现"></a>3.双向循环链表类的实现</h1></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">DCirlist</span>&lt;T&gt;:</span>:DCirlist()</span><br><span class="line">&#123;</span><br><span class="line">head = <span class="keyword">new</span> DLnode&lt;T&gt;();</span><br><span class="line">head-&gt;next = head;</span><br><span class="line">head-&gt;prior = head;</span><br><span class="line">size = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">DCirlist</span>&lt;T&gt;:</span>:~DCirlist()</span><br><span class="line">&#123;</span><br><span class="line">clearlist();</span><br><span class="line"><span class="keyword">delete</span> head;</span><br><span class="line">head = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">int</span> <span class="title">DCirlist</span>&lt;T&gt;:</span>:listsize() <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">bool</span> <span class="title">DCirlist</span>&lt;T&gt;:</span>:empty() <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> (size == <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">DLnode</span>&lt;T&gt;* <span class="title">DCirlist</span>&lt;T&gt;:</span>:index(<span class="keyword">int</span> pos) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (pos == <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (pos&lt;<span class="number">0</span> || pos&gt;size)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"illegal operator"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">DLnode&lt;T&gt; *p = head-&gt;next;</span><br><span class="line"><span class="keyword">while</span> (i &lt; pos&amp;&amp;p != head)</span><br><span class="line">&#123;</span><br><span class="line">p = p-&gt;next;</span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> <span class="title">DCirlist</span>&lt;T&gt;:</span>:insert(<span class="keyword">const</span> T &amp; item, <span class="keyword">int</span> pos)</span><br><span class="line">&#123;</span><br><span class="line">DLnode&lt;T&gt; *p = index(pos<span class="number">-1</span>);</span><br><span class="line">DLnode&lt;T&gt; *new_node = <span class="keyword">new</span> DLnode&lt;T&gt;(item, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">new_node-&gt;prior = p;</span><br><span class="line">p-&gt;next-&gt;prior = new_node;</span><br><span class="line">new_node-&gt;next = p-&gt;next;</span><br><span class="line">p-&gt;next = new_node;</span><br><span class="line">size++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">T</span> <span class="title">DCirlist</span>&lt;T&gt;:</span>:del(<span class="keyword">int</span> pos)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (size == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"list is empty"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (pos&lt;<span class="number">0</span> || pos&gt;size)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"illegal operator"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">DLnode&lt;T&gt; *p = index(pos);</span><br><span class="line">p-&gt;prior-&gt;next = p-&gt;next;</span><br><span class="line">p-&gt;next-&gt;prior = p-&gt;prior;</span><br><span class="line">T data = p-&gt;data;</span><br><span class="line"><span class="keyword">delete</span> p;</span><br><span class="line">size--;</span><br><span class="line"><span class="keyword">return</span> data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">T</span> <span class="title">DCirlist</span>&lt;T&gt;:</span>:getdata(<span class="keyword">int</span> pos) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">DLnode&lt;T&gt; *p = index(pos);</span><br><span class="line"><span class="keyword">return</span> p-&gt;data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> <span class="title">DCirlist</span>&lt;T&gt;:</span>:clearlist()</span><br><span class="line">&#123;</span><br><span class="line">DLnode&lt;T&gt; *p1, *p2;</span><br><span class="line">p1 = head-&gt;next;</span><br><span class="line"><span class="keyword">while</span> (p1 != head)</span><br><span class="line">&#123;</span><br><span class="line">p2 = p1;</span><br><span class="line">p1 = p1-&gt;next;</span><br><span class="line"><span class="keyword">delete</span> p2;</span><br><span class="line">&#125;</span><br><span class="line">size = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">DLnode</span>&lt;T&gt;* <span class="title">DCirlist</span>&lt;T&gt;:</span>:reset(<span class="keyword">int</span> pos)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (pos == <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (pos&lt;<span class="number">0</span> || pos&gt;size)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"illegal operator"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">currPtr = head-&gt;next;</span><br><span class="line"><span class="keyword">while</span> (i &lt; pos&amp;&amp;currPtr != head)</span><br><span class="line">&#123;</span><br><span class="line">currPtr = currPtr-&gt;next;</span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> currPtr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">DLnode</span>&lt;T&gt;* <span class="title">DCirlist</span>&lt;T&gt;:</span>:next()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (currPtr!= <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">currPtr = currPtr-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> currPtr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">DLnode</span>&lt;T&gt;* <span class="title">DCirlist</span>&lt;T&gt;:</span>:prior()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (currPtr != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">currPtr = currPtr-&gt;prior;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> currPtr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">bool</span> <span class="title">DCirlist</span>&lt;T&gt;:</span>:EndOfList() <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> (currPtr == head);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">bool</span> <span class="title">DCirlist</span>&lt;T&gt;:</span>:nextEndoflist() <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> (currPtr-&gt;next == head);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">bool</span> <span class="title">DCirlist</span>&lt;T&gt;:</span>:PriorEndoflist() <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> (currPtr-&gt;prior == head);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">T</span> <span class="title">DCirlist</span>&lt;T&gt;:</span>:deleprior()</span><br><span class="line">&#123;<span class="comment">//删除当前节点的前一节点</span></span><br><span class="line">DLnode&lt;T&gt; *p = currPtr-&gt;prior;</span><br><span class="line">currPtr-&gt;prior-&gt;next = currPtr-&gt;next;</span><br><span class="line">currPtr-&gt;next-&gt;prior = currPtr-&gt;prior;</span><br><span class="line">T data = currPtr-&gt;data;</span><br><span class="line"><span class="keyword">delete</span> currPtr;</span><br><span class="line">size--;</span><br><span class="line">currPtr = p;</span><br><span class="line"><span class="keyword">return</span> currPtr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><h1 id="4-测试主函数"><a href="#4-测试主函数" class="headerlink" title="4.测试主函数"></a>4.测试主函数</h1></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">DCirlist&lt;<span class="keyword">int</span>&gt; <span class="built_in">list</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">list</span>.insert(i * <span class="number">10</span>, i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"list中元素的个数为："</span> &lt;&lt; <span class="built_in">list</span>.listsize() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">DLnode&lt;<span class="keyword">int</span>&gt; *p = <span class="built_in">list</span>.reset();</span><br><span class="line"><span class="keyword">while</span> (!<span class="built_in">list</span>.EndOfList())</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; p-&gt;data &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">p = <span class="built_in">list</span>.next();</span><br><span class="line">&#125;</span><br><span class="line">p = <span class="built_in">list</span>.next();</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">list</span>.del(<span class="number">1</span>) &lt;&lt; <span class="string">"已被删除"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"list中元素的个数为："</span> &lt;&lt; <span class="built_in">list</span>.listsize() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">while</span> (!<span class="built_in">list</span>.EndOfList())</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; p-&gt;data &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">p = <span class="built_in">list</span>.next();</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">list</span>.getdata(<span class="number">1</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">list</span>.index(<span class="number">2</span>)-&gt;data &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">test();</span><br><span class="line">system(<span class="string">"pause"</span>);</span><br><span class="line"><span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果如下：<br><img src="https://i.imgur.com/WZiHghb.png" alt>   </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h2&gt;&lt;p&gt;&amp;emsp;&amp;emsp;双向循环链表（Double Circular Linked List)是每个节点有前趋指针和后继指针
      
    
    </summary>
    
      <category term="C++" scheme="http://wanqbin.xyz/categories/C/"/>
    
    
      <category term="C++" scheme="http://wanqbin.xyz/tags/C/"/>
    
      <category term="双向循环链表" scheme="http://wanqbin.xyz/tags/%E5%8F%8C%E5%90%91%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>单循环链表</title>
    <link href="http://wanqbin.xyz/2019/03/28/%E5%8D%95%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8/"/>
    <id>http://wanqbin.xyz/2019/03/28/单循环链表/</id>
    <published>2019-03-28T12:58:00.000Z</published>
    <updated>2019-06-15T12:59:10.117Z</updated>
    
    <content type="html"><![CDATA[<h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>&emsp;&emsp;单循环链表，简称循环链表（circular linked list)，是表的一种链式存储结构。<br>&emsp;&emsp;设<code>p</code>是指向循环链表的指针，<code>currPtr</code>是当前指向对的循环链表的指针，<code>head</code>是指向循环链表的头指针，与链表判断是否到达链尾相比，循环链表中判断是否到达链表尾的条件是：<code>p!=head</code>或者是<code>currPtr!=head</code>。所以，循环链表类中成员函数的实现与链表类中的成员函数的实现差别不大，只是把<code>p!=null</code>换成了<code>p!=head</code>，把<code>currPtr!=null</code>换成了<code>currptr!=head</code>.</p><blockquote><h1 id="1-节点类的定义和实现"><a href="#1-节点类的定义和实现" class="headerlink" title="1.节点类的定义和实现"></a>1.节点类的定义和实现</h1></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">CirList</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">ListNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">CirList</span>&lt;T&gt;;</span><span class="comment">//声明友元类</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">T data;<span class="comment">//数据域</span></span><br><span class="line">ListNode(ListNode&lt;T&gt; *ptrNext = <span class="literal">NULL</span>);<span class="comment">//构造函数，用于构造头节点，头节点没有data参数</span></span><br><span class="line">ListNode(<span class="keyword">const</span> T &amp;item, ListNode&lt;T&gt; *ptrNext = <span class="literal">NULL</span>);<span class="comment">//构造函数，主要用于构造非头节点的节点</span></span><br><span class="line">~ListNode() &#123;&#125;;<span class="comment">//析构函数</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">ListNode&lt;T&gt; *next;<span class="comment">//指向下一节点的指针</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">ListNode</span>&lt;T&gt;:</span>:ListNode(ListNode&lt;T&gt;* ptrNext) :next(ptrNext)</span><br><span class="line">&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">ListNode</span>&lt;T&gt;:</span>:ListNode(<span class="keyword">const</span> T &amp; item, ListNode&lt;T&gt;* ptrNext)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;data = item;</span><br><span class="line"><span class="keyword">this</span>-&gt;next = ptrNext;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><h1 id="2-循环链表类的定义"><a href="#2-循环链表类的定义" class="headerlink" title="2.循环链表类的定义"></a>2.循环链表类的定义</h1></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">CirList</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">CirList();<span class="comment">//构造函数</span></span><br><span class="line">~CirList();<span class="comment">//析构函数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">listsize</span><span class="params">()</span></span>;<span class="comment">//长度</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">listempty</span><span class="params">()</span> <span class="keyword">const</span></span>;<span class="comment">//是否为空</span></span><br><span class="line">ListNode&lt;T&gt; *index(<span class="keyword">int</span> pos);<span class="comment">//返回指向位置pos的指针</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">const</span> T&amp; item, <span class="keyword">int</span> pos)</span></span>;<span class="comment">//在pos节点前插入一个节点</span></span><br><span class="line"><span class="function">T <span class="title">del</span><span class="params">(<span class="keyword">int</span> pos)</span></span>;<span class="comment">//删除第pos个节点</span></span><br><span class="line"><span class="function">T <span class="title">getdata</span><span class="params">(<span class="keyword">int</span> pos)</span> <span class="keyword">const</span></span>;<span class="comment">//返回pos节点的值域</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clearlist</span><span class="params">()</span></span>;<span class="comment">//清空表为初始状态</span></span><br><span class="line"></span><br><span class="line">ListNode&lt;T&gt; *reset();<span class="comment">//currptr指向节点pos并返回currptr</span></span><br><span class="line">ListNode&lt;T&gt; *next();<span class="comment">//currptr指向下一节点并返回currptr</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">EndOfList</span><span class="params">()</span> <span class="keyword">const</span></span>;<span class="comment">//判断是否到了尾部 ，currptr==head</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">nextEndofList</span><span class="params">()</span> <span class="keyword">const</span></span>;<span class="comment">//currptr-&gt;next是否链表尾</span></span><br><span class="line"><span class="function">T <span class="title">delAfter</span><span class="params">()</span></span>;<span class="comment">//删除currptr-&gt;next所指节点并返回被删除节点的data</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">ListNode&lt;T&gt; *head;<span class="comment">//表头指针</span></span><br><span class="line"><span class="keyword">int</span> size;<span class="comment">//链表的节点个数</span></span><br><span class="line">ListNode&lt;T&gt; *currPtr;<span class="comment">//当前节点指针</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><h1 id="3-循环链表类的实现"><a href="#3-循环链表类的实现" class="headerlink" title="3.循环链表类的实现"></a>3.循环链表类的实现</h1></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">CirList</span>&lt;T&gt;:</span>:CirList()</span><br><span class="line">&#123;</span><br><span class="line">head = <span class="keyword">new</span> ListNode&lt;T&gt;();</span><br><span class="line">size = <span class="number">0</span>;</span><br><span class="line">head-&gt;next = head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">CirList</span>&lt;T&gt;:</span>:~CirList()</span><br><span class="line">&#123;</span><br><span class="line">clearlist();</span><br><span class="line"><span class="keyword">delete</span> head;</span><br><span class="line">head = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">int</span> <span class="title">CirList</span>&lt;T&gt;:</span>:listsize()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">bool</span> <span class="title">CirList</span>&lt;T&gt;:</span>:listempty() <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> (size == <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">ListNode</span>&lt;T&gt;* <span class="title">CirList</span>&lt;T&gt;:</span>:index(<span class="keyword">int</span> pos)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (pos == <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (pos&lt;<span class="number">0</span> || pos&gt;size)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"illegal operator"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">currPtr = head-&gt;next;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (currPtr != <span class="literal">NULL</span> &amp; i &lt; pos)</span><br><span class="line">&#123;</span><br><span class="line">currPtr = currPtr-&gt;next;</span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> currPtr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> <span class="title">CirList</span>&lt;T&gt;:</span>:insert(<span class="keyword">const</span> T &amp; item, <span class="keyword">int</span> pos)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (pos&lt;<span class="number">0</span> || pos&gt;size)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"illegal operator"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">ListNode&lt;T&gt; *p = index(pos - <span class="number">1</span>);</span><br><span class="line">ListNode&lt;T&gt; *newnode = <span class="keyword">new</span> ListNode&lt;T&gt;(item, p-&gt;next);</span><br><span class="line">p-&gt;next = newnode;</span><br><span class="line">size++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">T</span> <span class="title">CirList</span>&lt;T&gt;:</span>:del(<span class="keyword">int</span> pos)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (pos&lt;<span class="number">0</span> || pos&gt;size)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"illegal operator"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">ListNode&lt;T&gt; *p = index(pos<span class="number">-1</span>);</span><br><span class="line">ListNode&lt;T&gt; *q;</span><br><span class="line">q = p-&gt;next;</span><br><span class="line">p-&gt;next = q-&gt;next;</span><br><span class="line">T data = q-&gt;data;</span><br><span class="line"><span class="keyword">delete</span> q;</span><br><span class="line">size--;</span><br><span class="line"><span class="keyword">return</span> data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">T</span> <span class="title">CirList</span>&lt;T&gt;:</span>:getdata(<span class="keyword">int</span> pos) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">ListNode&lt;T&gt; *p = index(pos);</span><br><span class="line"><span class="keyword">return</span> p-&gt;data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> <span class="title">CirList</span>&lt;T&gt;:</span>:clearlist()</span><br><span class="line">&#123;</span><br><span class="line">ListNode&lt;T&gt; *p, *p1;</span><br><span class="line">p = head-&gt;next;</span><br><span class="line"><span class="keyword">while</span> (p != head)</span><br><span class="line">&#123;</span><br><span class="line">p1 = p;</span><br><span class="line">p= p-&gt;next;</span><br><span class="line"><span class="keyword">delete</span> p1;</span><br><span class="line">&#125;</span><br><span class="line">size = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">ListNode</span>&lt;T&gt;* <span class="title">CirList</span>&lt;T&gt;:</span>:reset()</span><br><span class="line">&#123;</span><br><span class="line">currPtr = head-&gt;next;</span><br><span class="line"><span class="keyword">return</span> currPtr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">ListNode</span>&lt;T&gt;* <span class="title">CirList</span>&lt;T&gt;:</span>:next()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (currPtr != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">currPtr = currPtr-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> currPtr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">bool</span> <span class="title">CirList</span>&lt;T&gt;:</span>:EndOfList() <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> (currPtr == head);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">bool</span> <span class="title">CirList</span>&lt;T&gt;:</span>:nextEndofList() <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> (currPtr-&gt;next == head);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">T</span> <span class="title">CirList</span>&lt;T&gt;:</span>:delAfter()</span><br><span class="line">&#123;<span class="comment">//删除currpter-&gt;next,并返回currptr-&gt;next-&gt;data</span></span><br><span class="line"><span class="keyword">if</span> (currPtr-&gt;next != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">ListNode&lt;T&gt; *p = currPtr-&gt;next;</span><br><span class="line">currPtr-&gt;next = p-&gt;next;</span><br><span class="line">T data = p-&gt;data;</span><br><span class="line"><span class="keyword">delete</span> p;</span><br><span class="line">size--;</span><br><span class="line"><span class="keyword">return</span> data;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><h1 id="4-测试主函数"><a href="#4-测试主函数" class="headerlink" title="4.测试主函数"></a>4.测试主函数</h1></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">CirList&lt;<span class="keyword">int</span>&gt; <span class="built_in">list</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"当前链表中的元素有"</span> &lt;&lt; <span class="built_in">list</span>.listsize() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">list</span>.insert(<span class="number">10</span> * i, i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">list</span>.insert(<span class="number">100</span>, <span class="number">0</span>);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"当前链表中的元素有"</span> &lt;&lt; <span class="built_in">list</span>.listsize() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">ListNode&lt;<span class="keyword">int</span>&gt; *p = <span class="built_in">list</span>.reset();</span><br><span class="line"><span class="keyword">while</span> (!<span class="built_in">list</span>.EndOfList())</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; p-&gt;data &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">p = <span class="built_in">list</span>.next();</span><br><span class="line">&#125;</span><br><span class="line"> <span class="built_in">cout</span>&lt;&lt; <span class="built_in">list</span>.del(<span class="number">1</span>)&lt;&lt;<span class="string">"已被删除"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"> <span class="keyword">while</span> (!<span class="built_in">list</span>.EndOfList())</span><br><span class="line"> &#123;</span><br><span class="line"> <span class="built_in">cout</span> &lt;&lt; p-&gt;data &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"> p = <span class="built_in">list</span>.next();</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="built_in">cout</span> &lt;&lt; <span class="built_in">list</span>.index(<span class="number">5</span>)-&gt;data &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">test();</span><br><span class="line">system(<span class="string">"pause"</span>);</span><br><span class="line"><span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果如下：<br><img src="https://i.imgur.com/TuTEus3.png" alt>  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h2&gt;&lt;p&gt;&amp;emsp;&amp;emsp;单循环链表，简称循环链表（circular linked list)，是表的一种链式存储结构。&lt;br
      
    
    </summary>
    
      <category term="C++" scheme="http://wanqbin.xyz/categories/C/"/>
    
    
      <category term="单循环链表" scheme="http://wanqbin.xyz/tags/%E5%8D%95%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8/"/>
    
      <category term="C++" scheme="http://wanqbin.xyz/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>顺序表的简单实现</title>
    <link href="http://wanqbin.xyz/2019/03/27/%E9%A1%BA%E5%BA%8F%E8%A1%A8%E7%9A%84%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0/"/>
    <id>http://wanqbin.xyz/2019/03/27/顺序表的简单实现/</id>
    <published>2019-03-27T12:57:00.000Z</published>
    <updated>2019-06-15T12:57:59.942Z</updated>
    
    <content type="html"><![CDATA[<blockquote><h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1></blockquote><p>&emsp;&emsp;数据结构是一个数据对象，同时这个对象的实例以及构成实例的元素都存在着联系，而且这些联系是由相关函数来规定的。<br>&emsp;&emsp;研究数据结构，关心的是数据对象（实际上是实例）的描述以及相关函数的具体实现。数据对象描述得好，函数的实现就会高效。<br>&emsp;&emsp;最常用的数据对象以及操作都已经在C++中作为基本数据类型而实现，如整数对象，布尔对象等。其他数据对象均可以用基本数据类型以及由C++的类、数组和指针所提供的组合功能来实现。   </p><br><blockquote><h1 id="1-线性表的数据结构"><a href="#1-线性表的数据结构" class="headerlink" title="1.线性表的数据结构"></a>1.线性表的数据结构</h1></blockquote><p>&emsp;&emsp;线性表（linear list)也称有序表，它的每一个实例都是元素的一个有序集合。<br>&emsp;&emsp;对线性表实施的操作有：  </p><ul><li>创建一个线性表</li><li>撤销一个线性表</li><li>确定线性表是否为空</li><li>确定线性表的长度</li><li>按给定的索引查找一个元素</li><li>按一个给定的元素查找其索引</li><li>按一个给定的索引删除一个元素</li><li>按一个给定的索引插入一个元素</li><li>从左至右顺序输出线性表元素  </li></ul><p>&emsp;&emsp;用顺序存储结构存储的表称为顺序表（sequent list）。顺序表中任意数据元素的存取和访问都可以通过它的位置指针来（即数组下标）进行访问。对顺序表中元素访问的效率是一个比较重要的问题。通常情况下，有序顺序表的访问效率大大高于无序顺序表的访问效率。  </p><br><blockquote><h1 id="2-顺序表的类定义"><a href="#2-顺序表的类定义" class="headerlink" title="2.顺序表的类定义"></a>2.顺序表的类定义</h1></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> Seqlist_Entry;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxsize = <span class="number">10</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Seqlist</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Seqlist();<span class="comment">//构造函数</span></span><br><span class="line">~Seqlist();<span class="comment">//析构函数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">listsize</span><span class="params">()</span><span class="keyword">const</span></span>;<span class="comment">//返回元素的个数</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">listempty</span><span class="params">()</span> <span class="keyword">const</span></span>;<span class="comment">//判断表是否为空</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">const</span> Seqlist_Entry  &amp;item)</span></span>;<span class="comment">//返回元素item在表中的位置</span></span><br><span class="line"><span class="function">Seqlist_Entry <span class="title">getdata</span><span class="params">(<span class="keyword">int</span> pos)</span> <span class="keyword">const</span></span>;<span class="comment">//返回位置pos的元素</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">const</span> Seqlist_Entry  &amp;item, <span class="keyword">int</span> pos)</span></span>;<span class="comment">//在位置pos处插入元素item</span></span><br><span class="line"><span class="function">Seqlist_Entry  <span class="title">Delete</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> pos)</span></span>;<span class="comment">//删除位置pos的元素并返回</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clearlist</span><span class="params">()</span></span>;<span class="comment">//清空表</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">showall</span><span class="params">()</span> <span class="keyword">const</span></span>;<span class="comment">//输出表</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">Seqlist_Entry  data[maxsize];</span><br><span class="line"><span class="keyword">int</span> size;<span class="comment">//数据元素的个数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><h1 id="3-顺序表的类实现"><a href="#3-顺序表的类实现" class="headerlink" title="3.顺序表的类实现"></a>3.顺序表的类实现</h1></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//构造函数</span></span><br><span class="line">Seqlist::Seqlist()</span><br><span class="line">&#123;</span><br><span class="line">size = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//析构函数</span></span><br><span class="line">Seqlist::~Seqlist() &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回顺序表元素的个数</span></span><br><span class="line"><span class="keyword">int</span> Seqlist::listsize() <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> size;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//判断顺序表是否为空</span></span><br><span class="line"><span class="keyword">bool</span> Seqlist::listempty() <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> (size == <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//查找item，并返回位置索引</span></span><br><span class="line"><span class="keyword">int</span> Seqlist::find(<span class="keyword">const</span> Seqlist_Entry &amp; item)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (size == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"list is empty "</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (i &lt; size&amp;&amp;item != data[i])</span><br><span class="line">&#123;</span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (i &lt; size)</span><br><span class="line"><span class="keyword">return</span> i;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"illegal operator"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//取出pos位置上的元素</span></span><br><span class="line">Seqlist_Entry Seqlist::getdata(<span class="keyword">int</span> pos) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (pos&lt;<span class="number">0</span> || pos&gt;size - <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"illegal operator"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> data[pos];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//在pos位置插入元素item</span></span><br><span class="line"><span class="keyword">void</span> Seqlist::insert(<span class="keyword">const</span> Seqlist_Entry &amp; item, <span class="keyword">int</span> pos)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (size == maxsize)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"list is full"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (pos&lt;<span class="number">0</span> || pos&gt;size )</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"illegal operator"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = size; i &gt; pos; i--)</span><br><span class="line">&#123;</span><br><span class="line">data[i] = data[i - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line">data[pos] = item;</span><br><span class="line">size++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//删除pos位置的元素</span></span><br><span class="line">Seqlist_Entry Seqlist::Delete(<span class="keyword">const</span> <span class="keyword">int</span> pos)</span><br><span class="line">&#123;</span><br><span class="line">Seqlist_Entry tmp=data[pos];</span><br><span class="line"><span class="keyword">if</span> (size == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"list is empty"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (pos&lt;<span class="number">0</span> || pos&gt;size - <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"illegal operator"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = pos; i &lt; size<span class="number">-1</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">data[i] = data[i + <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line">size--;</span><br><span class="line"><span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//置顺序表为空</span></span><br><span class="line"><span class="keyword">void</span> Seqlist::clearlist()</span><br><span class="line">&#123;</span><br><span class="line">size = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"已清空"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出顺序表中所有元素</span></span><br><span class="line"><span class="keyword">void</span> Seqlist::showall() <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (size == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"list is empty"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt;i&lt;&lt;<span class="string">"号元素:"</span>&lt;&lt; data[i] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><h1 id="4-测试主函数"><a href="#4-测试主函数" class="headerlink" title="4.测试主函数"></a>4.测试主函数</h1></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Seqlist <span class="built_in">list</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">list</span>.insert(i * <span class="number">12</span>, i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">list</span>.getdata(i) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> tmp = <span class="built_in">list</span>.Delete(<span class="number">2</span>);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"元素"</span> &lt;&lt; tmp &lt;&lt; <span class="string">"已经被删除了"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">list</span>.showall();</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"84在顺序表的"</span>&lt;&lt;<span class="built_in">list</span>.find(<span class="number">84</span>)&lt;&lt;<span class="string">"号位置"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">list</span>.clearlist();</span><br><span class="line"><span class="built_in">list</span>.showall();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">test();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果如下图：<br><img src="https://i.imgur.com/6Z8Kob3.png" alt>  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;h1 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h1&gt;&lt;/blockquote&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;数据结构是一个数据对象，同时这个对象的实例以及
      
    
    </summary>
    
      <category term="数据结构" scheme="http://wanqbin.xyz/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="C++" scheme="http://wanqbin.xyz/tags/C/"/>
    
      <category term="顺序表" scheme="http://wanqbin.xyz/tags/%E9%A1%BA%E5%BA%8F%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>栈的实现</title>
    <link href="http://wanqbin.xyz/2019/03/27/%E6%A0%88%E7%9A%84%E5%AE%9E%E7%8E%B0-1/"/>
    <id>http://wanqbin.xyz/2019/03/27/栈的实现-1/</id>
    <published>2019-03-27T12:56:00.000Z</published>
    <updated>2019-06-15T12:56:50.104Z</updated>
    
    <content type="html"><![CDATA[<h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>&emsp;栈（Stack)是一种特殊的线性表，是一种只允许在表的一端进行插入和删除操作的线性表。栈中允许进行插入和删除操作的一端称为栈顶，另一端为栈底。栈顶的当前位置是动态的，标识栈顶当前位置的称为栈顶指示器（或栈顶指针）。栈的插入和删除操作通常称为入栈或进栈，栈的删除操作称为出栈或退栈。当栈中没有数据元素时称为空栈。<br>&emsp;&emsp;根据栈的定义，每次进栈的数据元素都放在原当前栈顶元素之前而成为新的栈顶元素，每次退栈的数据元素都是当前栈顶元素，这样，最后进入堆栈的数据元素总是最先出栈，因此栈也被成为后进先出表。  </p><blockquote><h1 id="1-栈的基本运算"><a href="#1-栈的基本运算" class="headerlink" title="1.栈的基本运算"></a>1.栈的基本运算</h1></blockquote><ul><li>初始化栈</li><li>销毁栈</li><li>判断栈是否为空</li><li>进栈</li><li>出栈</li><li>取栈顶元素</li></ul><blockquote><h1 id="2-顺序栈四要素"><a href="#2-顺序栈四要素" class="headerlink" title="2.顺序栈四要素"></a>2.顺序栈四要素</h1></blockquote><ul><li>栈空条件： <code>top==-1</code></li><li>栈满条件： <code>top==max_stack - 1</code></li><li>item进栈操作：top++,将item放在top处</li><li>退栈操作：从top处取出元素item，top–</li></ul><blockquote><h1 id="3-类说明"><a href="#3-类说明" class="headerlink" title="3.类说明"></a>3.类说明</h1></blockquote><p>&emsp;对于顺序栈Stack的实现，应创建一个数组来存放栈中的元素，并用一个始终指向栈顶的变量top来表示栈顶的位置。类定义如下：  </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> Stack_Entry;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> max_stack = <span class="number">10</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stack</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Stack();</span><br><span class="line"><span class="comment">//构造函数</span></span><br><span class="line">~Stack() &#123;&#125;;</span><br><span class="line"><span class="comment">//析构函数</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"><span class="comment">//判断栈是否为空</span></span><br><span class="line"><span class="function">Stack_Entry <span class="title">pop</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">//出栈数据元素</span></span><br><span class="line"><span class="function">Stack_Entry <span class="title">Top</span><span class="params">(Stack_Entry &amp;item)</span> <span class="keyword">const</span></span>;</span><br><span class="line"><span class="comment">//返回栈顶元素</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">const</span> Stack_Entry &amp;item)</span></span>;</span><br><span class="line"><span class="comment">//数据元素item进栈</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getsize</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"><span class="comment">//获取栈中元素的个数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clearstack</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">//清空栈</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">int</span> top;<span class="comment">//栈顶位置指示器</span></span><br><span class="line">Stack_Entry entry[max_stack];<span class="comment">//Stack_Entry类型的数组</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><h1 id="4-具体实现"><a href="#4-具体实现" class="headerlink" title="4.具体实现"></a>4.具体实现</h1></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">Stack::Stack()</span><br><span class="line">&#123;</span><br><span class="line">top=<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> Stack::empty() <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> (top==<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Stack_Entry Stack::pop()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (top==<span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Stack is empty"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> entry[top--];</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Stack_Entry Stack::Top(Stack_Entry &amp; item) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (top == <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Stack is empty"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> entry[top];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> Stack::push(<span class="keyword">const</span> Stack_Entry &amp; item)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (top == max_stack - <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Stack is full"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">top++;</span><br><span class="line">entry[top] = item;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> Stack::getsize() <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> top+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> Stack::clearstack()</span><br><span class="line">&#123;</span><br><span class="line">top = <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><h1 id="5-主函数"><a href="#5-主函数" class="headerlink" title="5.主函数"></a>5.主函数</h1></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Stack <span class="built_in">stack</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">stack</span>.push(i+<span class="number">10</span>*i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"当前栈中元素数为："</span> &lt;&lt; <span class="built_in">stack</span>.getsize() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">Stack_Entry tmp;</span><br><span class="line">tmp = <span class="built_in">stack</span>.pop();</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"我是"</span> &lt;&lt; i &lt;&lt; <span class="string">"号元素:"</span>&lt;&lt;tmp &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"当前栈中元素数为："</span> &lt;&lt; <span class="built_in">stack</span>.getsize() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">stack</span>.empty())</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Stack is empty"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Stack is not empty"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">test();</span><br><span class="line">system(<span class="string">"pause"</span>);</span><br><span class="line"><span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果如下图：<br><img src="https://i.imgur.com/zuBXHXy.png" alt>  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h2&gt;&lt;p&gt;&amp;emsp;栈（Stack)是一种特殊的线性表，是一种只允许在表的一端进行插入和删除操作的线性表。栈中允许进行插入和删除操作
      
    
    </summary>
    
      <category term="数据结构" scheme="http://wanqbin.xyz/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="栈" scheme="http://wanqbin.xyz/tags/%E6%A0%88/"/>
    
      <category term="数据结构" scheme="http://wanqbin.xyz/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
</feed>

<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Aoki&#39;s Blog</title>
  
  <subtitle>“吾生也有涯，而知无涯”</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://wanqbin.xyz/"/>
  <updated>2019-08-08T12:00:54.923Z</updated>
  <id>http://wanqbin.xyz/</id>
  
  <author>
    <name>Aoki</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Linux添加系统调用</title>
    <link href="http://wanqbin.xyz/2019/08/08/Linux%E6%B7%BB%E5%8A%A0%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/"/>
    <id>http://wanqbin.xyz/2019/08/08/Linux添加系统调用/</id>
    <published>2019-08-08T11:59:00.000Z</published>
    <updated>2019-08-08T12:00:54.923Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;在Linux中为系统添加一个系统调用并不是很难的事情，首先需要编写自己的系统调用，然后再把编写好的系统调用注册进内核使它成为一个正式的系统调用即可。系统调用函数可以静态添加，也可以动态添加，静态方式就是把系统掉用那个直接加入到内核中，这需要重新编译内核；动态方式是以模块的方式添加系统调用，这种方式下，不需要重新编译内核。</p><ol><li><h3 id="编写系统调用函数"><a href="#编写系统调用函数" class="headerlink" title="编写系统调用函数"></a>编写系统调用函数</h3><p>&emsp;&emsp;编写自己的系统调用前，必须首先清楚该系统调用所要实现的功能是什么，在Linux中，尽量不要用一个系统调用来实现多个功能。系统调用接口应该尽量简洁，参数尽量少，当然还要考虑到系统调用的通用性，即系统调用是否可移植等因素。</p><p>&emsp;&emsp;内核执行系统调用的时候处于进程上下文中，因此可以睡眠，也可以被抢占，这样系统调用可以使用内核提供的绝大多数函数。系统调用函数的一般形式如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">asmlinkage <span class="keyword">long</span> sys_ <span class="title">xxx</span><span class="params">(type1 arg1,type2 arg2……）</span></span></span><br></pre></td></tr></table></figure></li><li><h3 id="把系统调用添加到系统调用表中"><a href="#把系统调用添加到系统调用表中" class="headerlink" title="把系统调用添加到系统调用表中"></a>把系统调用添加到系统调用表中</h3><p>&emsp;&emsp;把编写好的系统调用添加到系统表的最后，对于支持该系统调用的所有硬件体系结构都必须做这样的工作。从0开始算起，系统调用在该表中的位置就是它的系统调用号。每种体系结构下对应的系统调用号不一定相同。</p></li><li><h3 id="添加系统调用号"><a href="#添加系统调用号" class="headerlink" title="添加系统调用号"></a>添加系统调用号</h3><p>&emsp;&emsp;对于系统调用所支持的各种体系结构，把由上一步得到的系统调用号添加到文件<code>unistd.h</code>中，并修改总的系统调用个数<code>NR_syscalls</code>的值。</p></li><li><h3 id="添加系统调用函数"><a href="#添加系统调用函数" class="headerlink" title="添加系统调用函数"></a>添加系统调用函数</h3><p>&emsp;&emsp;最后把编写好的系统调用函数添加到内核中时，要保证系统必须被编译进内核映像（而不是被编译成模块）。</p></li><li><h3 id="重新编译内核"><a href="#重新编译内核" class="headerlink" title="重新编译内核"></a>重新编译内核</h3><p>&emsp;&emsp;编译修改过的Linux内核，再次系统选择启动新内核，这样就可以使用刚才写好的系统调用了。</p></li><li><h3 id="从用户空间使用系统调用"><a href="#从用户空间使用系统调用" class="headerlink" title="从用户空间使用系统调用"></a>从用户空间使用系统调用</h3><p>&emsp;&emsp;通常，系统调用靠C库的支持，用户程序通过包含标准头文件并和C库链接，就可以使用系统调用了。但是如果仅仅写出系统调用，glibc库恐怕并提供支持。在2.6.20之后，出于安全的考虑，Linux删除了<code>_syscalln</code>的一组宏，这样就只有使用内核为用户程序提供的另外一个函数<code>syscall</code>。该函数的形式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">syscall(_NR_mysyscall,arg1,arg2……）;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&amp;emsp;&amp;emsp;在Linux中为系统添加一个系统调用并不是很难的事情，首先需要编写自己的系统调用，然后再把编写好的系统调用注册进内核使它成为一个正式的系统调用即可。系统调用函数可以静态添加，也可以动态添加，静态方式就是把系统掉用那个直接加入到内核中，这需要重新编译内
      
    
    </summary>
    
      <category term="Linux内核" scheme="http://wanqbin.xyz/categories/Linux%E5%86%85%E6%A0%B8/"/>
    
    
      <category term="操作系统" scheme="http://wanqbin.xyz/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="Linux内核" scheme="http://wanqbin.xyz/tags/Linux%E5%86%85%E6%A0%B8/"/>
    
      <category term="Linux系统调用" scheme="http://wanqbin.xyz/tags/Linux%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/"/>
    
      <category term="Linux添加系统调用" scheme="http://wanqbin.xyz/tags/Linux%E6%B7%BB%E5%8A%A0%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/"/>
    
  </entry>
  
  <entry>
    <title>Linux系统调用实现分析</title>
    <link href="http://wanqbin.xyz/2019/08/08/Linux%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E5%AE%9E%E7%8E%B0%E5%88%86%E6%9E%90/"/>
    <id>http://wanqbin.xyz/2019/08/08/Linux系统调用实现分析/</id>
    <published>2019-08-08T11:33:00.000Z</published>
    <updated>2019-08-08T11:33:37.412Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、C程序库和系统调用"><a href="#一、C程序库和系统调用" class="headerlink" title="一、C程序库和系统调用"></a>一、C程序库和系统调用</h2><p>&emsp;&emsp;系统调用视为了编程人员提供内核服务的一组函数，而C程序库通过软中断陷入内核，实现内核服务。</p><p>&emsp;&emsp;系统调用时系统内核向用户程序提供支持的接口，通过这些接口应用程序向系统内核服务，控制转向系统内核，而系统内核在完成服务之后，将控制和结果返回给用户程序。系统调用是用户程序与系统内核的边界，通过系统调用，进程可由用户模式转入内核模式，在内核模式下完成一定的服务请求后再返回用户模式。系统调用只是提供一个基本功能集，而通过对这些操作的引用和封装，可以形成丰富而且强大的系统调用库。这里体现了Linux的机制与策略相分离的编程思想——系统调用只是提供访问核心的基本机制，而策略是通过系统调用库来实现的。</p><p>&emsp;&emsp;在Linux中，系统调用库实体通过C程序来实现的，又称为C程序库。C程序库主要是为编程人员提供应用程序编程接口（API），即为编程人员提供与内核进行交互的一组法术。一般情况下，应用程序使用的这种编程接口实际上并不需要和内核提供的系统调用对应。一个API的功能可以通过一个系统调用来实现，也可以通过多个系统调用来实现，也可以完全不使用系统调用。实际上，API可以在各种操作系统上实现，给应用程序提供完全相同的接口，而它们自身在这些系统同上的实现可能不同。</p><p>&emsp;&emsp;从程序员的角度来看，系统调用无关紧要；他们只需要跟C库的API打交道就可以。相反的，内核只跟系统调用打交道；库函数及应用程序怎么使用系统调用并不是内核所关心的。只是内核必须时刻牢记系统调用所有潜在的用途并保证它们有良好的通用性和灵活性。</p><h2 id="二、系统调用实现分析"><a href="#二、系统调用实现分析" class="headerlink" title="二、系统调用实现分析"></a>二、系统调用实现分析</h2><p>&emsp;&emsp;在Linux系统中系统调用时用户空间访问内核的一种方式，系统调用执行大致过程如下：</p><p>（1）在应用程序中调用用户空间的库函数</p><p>（2）库函数在执行一系列预处理后，取得系统调用号，传递相应的参数并执行软中断指令<code>INT</code>产生中断</p><p>（3）Linux系统进行地址空间的转换和堆栈的切换，执行<code>SAVE_ALL</code>宏定义，从而保存现场</p><p>（4）根据系统调用号从系统调用表找到对应系统调用处理程序的入口地址</p><p>（5）执行系统调用对应的处理程序</p><p>（6）执行<code>RESTORE_ALL</code>宏定义，恢复系统调用前的任务现场并返回用户模式</p><p>不同的平台，系统调用的实现也不同。下面是在x86体系结构中系统调用的实现。</p><ol><li><h4 id="系统调用的初始化"><a href="#系统调用的初始化" class="headerlink" title="系统调用的初始化"></a>系统调用的初始化</h4><p>&emsp;&emsp;在应用程序调用系统调用时，应该以某种方式从用户态陷入到内核态，在Linux中可以通过软中断（这里的软中断是相对于外部的硬件中断来说的）来实现陷入，在x86平台上，这条指令是<code>init 0x80</code>。也就是说在Linux中，向系统调用的接口是一个中断处理函数的特例。这样，就需要在系统启动时，对系统调用中断进行初始化。</p><p>&emsp;&emsp;Linux内核在初始化期间会调用<code>arch/i386/kernel/traps.c</code>文件中的<code>trap_init()</code>函数来设置中断描述符表。在这个函数中，通过调用函数<code>set_system_gate(SYSCALL_VECTOR,&amp;SYSTEM_call)</code>来完成该项的设置。其中的<code>SYSTEMCALL_VECTOR</code>就是<code>0x80</code>，而<code>system_call</code>则是一个汇编子函数，它是中断<code>0x80</code>的处理函数，也是系统调用的入口函数。</p></li><li><h4 id="与系统调用相关的数据结构"><a href="#与系统调用相关的数据结构" class="headerlink" title="与系统调用相关的数据结构"></a>与系统调用相关的数据结构</h4><h4 id="（1）系统调用号"><a href="#（1）系统调用号" class="headerlink" title="（1）系统调用号"></a>（1）系统调用号</h4><p>&emsp;&emsp;在Linux中每个系统调用被赋予一个唯一的编号，这个编号被称为系统调用号。这样通过这个独一无二的号就可以关联到相应的系统调用处理处理程序。系统调用号定义在<code>include/asm/unistd.h</code>中，编号的定义方式如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _NR_result_syscall0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _NR_exit   1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _NR_fork  2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _NR_read                         3</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _NR_write  4</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _NR_open5</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _NR_close  6</span></span><br><span class="line"></span><br><span class="line">……</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NR_syscalls  325</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;其中，<code>NR_syscalls</code>表示系统调用的总数，在检查一个系统调用号是否合法时要用到。</p><p>&emsp;&emsp;系统调用号非常关键，当用户空间的进程执行一个系统调用的时候，系统使用系统调用号而不是系统调用的函数名称，来指明到底是要执行那个系统调用。系统调用号一旦分配就不能再有任何变更，否则编译好的应用程序就会崩溃。此外，如果一个系统调用被删除，它所占用的系统调用号也不允许被回收利用，否则，以前编译过的代码在调用这个系统调用时，就会出错。为此，Linux设置了专门的“未实现”系统调用<code>sys_ni_syscall()</code>，它除了返回<code>-ENOSYS</code>外，不做任何其他的事。当系统调用一个被删除的系统调用时，或者无效的系统调用时，这个函数就会被执行。</p><h4 id="（2）系统调用表"><a href="#（2）系统调用表" class="headerlink" title="（2）系统调用表"></a>（2）系统调用表</h4><p>&emsp;&emsp;内核使用系统调用表记录了各个系统调用处理函数的入口地址，以系统同调用号为偏移量能够很容易地在该表中找到对应的处理函数地址。系统调用表存储在<code>sys_call_table</code>中，它与体系结构有关，x86体系结构的系统调用表定义在<code>arch/x86/kernel/syscall_table.S</code>中，其定义方式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ENTER(sys_call_table)</span><br><span class="line">.long sys_restart_syscall</span><br><span class="line">.long sys_exit</span><br><span class="line">.long sys_fork</span><br><span class="line">.long sys_read</span><br><span class="line">……</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;当用户空间程序调用一个系统调用时，系统调用号作为参数传递给中断<code>0x80</code>，而该标号实际上就相当于系统调用表的下标，通过该值可以找到相应的系统调用的处理函数。</p></li><li><h4 id="系统调用入口函数"><a href="#系统调用入口函数" class="headerlink" title="系统调用入口函数"></a>系统调用入口函数</h4><p>&emsp;&emsp;当用户执行了软中断指令后，系统从用户空间进入内核空间，并在内核空间执行系统调用入口函数。系统调用入口函数由<code>arch/x386/kernel/entry_32.S</code>文件中的<code>system_call</code>汇编代码段定义，其主要功能是对系统调用进行预处理，并调用相应的系统调用服务例程。函数的执行过程如下：</p><p>（1）首先将系统调用号（eax的值，因为在save_all中保存的eax寄存器会被调用的返回值覆盖）放入栈中</p><p>（2）调用<code>save_all</code>保存寄存器上下文</p><p>（3）得到进程的<code>thread_info</code>结构指针放到<code>ebp</code>中。检查<code>struct thread_info</code>中的<code>flags</code>标志，看是否有系统管理调用跟踪等，有则跳到<code>syscall_trace_entry</code></p><p>（4）检查系统调用号的有效性，若不小于<code>nr_syscalls</code>则报错并返回<code>-ENOOSYS</code>，否则跳转到该系统调用的处理函数入口。这里以eax作为偏移，在系统调用表<code>sys_call_table</code>中查找处理函数入口地址，并跳转到该入口地址</p><p>（5）将返回值存放在eax中，调用<code>restore_all</code>恢复寄存器上下文。</p></li><li><h4 id="系统调用的参数传递"><a href="#系统调用的参数传递" class="headerlink" title="系统调用的参数传递"></a>系统调用的参数传递</h4><p>&emsp;&emsp;与普通的函数类似，系统调用通常也需要输入/输出参数，这些参数可能是实际的值，也可能是函数的地址及用户态进程地址空间的变量。在系统调用需要传递少量参数的情况下，通常采用处理器中的寄存器完成参数的传递工作。系统调用过程中所需要的参数由寄存器<code>%eax</code>,<code>%ebx</code>,<code>%ecx</code>,<code>%edx</code>,<code>%esi</code>,<code>%edi</code>来传递。</p><p>&emsp;&emsp;事实上，系统调用过程中系统调用号就是通过处理器中的寄存器<code>%eax</code>进行传递的，系统调用入口函数<code>system_call()</code>根据保存在该寄存器中的不同系统调用号，调用相应的系统调用处理函数来完成具体的系统调用。</p><p>&emsp;&emsp;具体的系统调用处理函数所需参数依次由除了<code>%eax</code>外剩余的5个寄存器<code>%ebx</code>,<code>%ecx</code>,<code>%edx</code>,<code>%esi</code>,<code>%edi</code>来传递。在系统调用处理过程中，这些保存在处理器寄存器中的参数被系统调用入口函数<code>system_call()</code>通过调用<code>save_all()</code>函数压入到内核态栈中。具体的系统调用处理函数从内核态栈中取得相应的参数值，完成具体的处理工作。</p><p>&emsp;&emsp;当系统调用需要在用户态和内核态传递大量数据时，处理器中内置的寄存器显然不够使用。通常的做法是，把所传递的参数封装到特定的结构中，此时采用一个指向该结构的指针和该结构的长度值来描述这一参数，再和传递少量数据的情况一样将这两个通过处理器中的参数进行传递。</p><p>&emsp;&emsp;由于在内核中，不可以访问用户态地址空间，Linux提供了<code>copy_from_user()</code>和<code>copy_to_user()</code>两个函数，用于用户态空间和内核态空间的数据交换。</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、C程序库和系统调用&quot;&gt;&lt;a href=&quot;#一、C程序库和系统调用&quot; class=&quot;headerlink&quot; title=&quot;一、C程序库和系统调用&quot;&gt;&lt;/a&gt;一、C程序库和系统调用&lt;/h2&gt;&lt;p&gt;&amp;emsp;&amp;emsp;系统调用视为了编程人员提供内核服务的一组函数
      
    
    </summary>
    
      <category term="Linux内核" scheme="http://wanqbin.xyz/categories/Linux%E5%86%85%E6%A0%B8/"/>
    
    
      <category term="操作系统" scheme="http://wanqbin.xyz/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="系统调用" scheme="http://wanqbin.xyz/tags/%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/"/>
    
      <category term="Linux系统调用" scheme="http://wanqbin.xyz/tags/Linux%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/"/>
    
      <category term="C程序库" scheme="http://wanqbin.xyz/tags/C%E7%A8%8B%E5%BA%8F%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>Linux调度相关系统调用</title>
    <link href="http://wanqbin.xyz/2019/08/08/Linux%E8%B0%83%E5%BA%A6%E7%9B%B8%E5%85%B3%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/"/>
    <id>http://wanqbin.xyz/2019/08/08/Linux调度相关系统调用/</id>
    <published>2019-08-08T09:00:00.000Z</published>
    <updated>2019-08-08T09:00:48.927Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;Linux内核提供的一些系统调用主要用于管理和维护与进程调度相关的参数值，这些系统调用可以用来获取和设置进程的优先级、进程调度策略，以及进程与处理器的亲和力等。</p><div class="table-container"><table><thead><tr><th>系统调用</th><th>功能简介</th></tr></thead><tbody><tr><td>nice()</td><td>用于设置普通进程的静态优先级，即设置进程的nice值</td></tr><tr><td>getprioprity()</td><td>返回20减去给定进程组中所有进程之中最低nice字段的值，即获得一组普通进程的最大优先级</td></tr><tr><td>setpriority()</td><td>把给定组中所有进程的静态优先级都设置为一个给定的值</td></tr><tr><td>sched_getaffinity()</td><td>获取进程与处理器的亲和力掩码</td></tr><tr><td>sched_setaffinity()</td><td>设置进程与处理器的亲和力掩码</td></tr><tr><td>sched_getscheduler()</td><td>获取进程的调度策略</td></tr><tr><td>sched_setschedule()</td><td>设置一个进程的调度策略和实时优先级</td></tr><tr><td>sched_getparam()</td><td>获取一个进程的实时优先级</td></tr><tr><td>sched_setparam()</td><td>设置一个进程的实时优先级</td></tr><tr><td>sched_yield()</td><td>进程自愿暂时让出CPU</td></tr><tr><td>sched_get_priority_min()</td><td>获取最小的实时静态优先级</td></tr><tr><td>sched_get_priority_max()</td><td>获取最大的实时静态优先级</td></tr><tr><td>sched_rr_get_interval()</td><td>获得时间片轮转策略的时间片值</td></tr></tbody></table></div><ol><li><p><code>nice()</code>系统调用</p><p>&emsp;&emsp;该函数用于设置普通进程的静态优先级，它可以将给定进程的静态优先级增加一个给定的量，这时我们应该注意，这个给定的量有两种情况，第一种是将给定的进程的静态优先级加上一个正值，其实这相当于降低进程的优先级，第二种是将给定的进程的静态优先级加上一个负值，其实这相当于提高进程的优先级。</p><p>&emsp;&emsp;在Linux中规定，作为一般原则，总是允许用户降低他们进程的优先级，即给定的那个量是一个正值。然而，如果他们想修改属于某一用户进程的优先级，或者如果他们想增加自己进程的优先级，即给定的量是一个负值，那么，他们必须拥有超级用户的特权。</p><p>&emsp;&emsp;<code>nice()</code>函数会调用内核的<code>set_uer_nice()</code>函数，这个函数会设置进程的<code>task_struct</code>中的<code>static_prio</code>和<code>prio</code>的值。</p></li><li><p><code>getprioriity()</code>和<code>setpriority()</code>系统调用</p><p>&emsp;&emsp;<code>nice()</code>系统调用只影响调用它的进程，而另外两个系统调用<code>getpriority()</code>和<code>setpriority()</code>则作用于给定组中所有进程的基本优先级。<code>getpriority()</code>返回20减去给定组中所有进程之中最低<code>nice</code>字段的值，<code>setpriority()</code>把给定组中所有进程的基本优先级都设置为一个给定的值。</p></li><li><p><code>getaffinity()</code>和<code>setaffinity()</code>系统调用</p><p>&emsp;&emsp;Linux调度程序提供强制的处理器绑定机制，即它允许用户强制指定某个进程必须在相应的CPU上运行，所谓亲和力掩码就是用于指定该进程可以在哪个CPU上运行的一个标志位，它保存在进程结构体（<code>task_struct</code>)的<code>cpu_allowed</code>这个位掩码标志中。该掩码1的每一位对应于系统中的一个CPU，在默认情况下一个进程的该掩码所有的位都被设置，即默认情况下一个进程可以在系统中所有可用的CPU上运行。</p></li><li><p><code>sched_getscheduler()</code>和<code>sched_setscheduler()</code>系统调用</p><p>&emsp;&emsp;<code>sched_getscheduler()</code>和<code>sched_setscheduler()</code>分别用于设置和获取进程的调度策略和实时优先级。其主要工作就是读取和设置进程结构体<code>task_struct</code>中的<code>policy</code>和<code>rt_priority</code>域的值。</p><p>&emsp;&emsp;<code>sched_getscheduler()</code>函数查询与给定的pid相对应的进程当前所用的调度策略。如果pid为0，将检索调用该函数的进程的调度策略；如果成功，这个系统调用为进程返回策略。</p><p>&emsp;&emsp;<code>sched_setscheduler()</code>系统调用既可以设置调度策略，也可以设置与给定的pid相对应的进程的相关参数。如果pid为0，调用该函数的进程的调度程序参数将被设置。</p></li><li><p><code>sched_getparam()</code>和<code>sched_setparam()</code>系统调用</p><p>&emsp;&emsp;<code>sched_getparam()</code>和<code>sched_setparam()</code>分别用于设置和获取进程的实时优先级。<code>sched_getparam()</code>系统调用可以获取与给定的pid相对应的进程的实时优先级。如果pid为0，<code>current</code>进程的实时优先级将被检索。它首先找到与pid相关的进程描述符指针，把它的<code>rt_priority</code>字段存放在类型为<code>sched_param</code>的局部变量中，并调用<code>copy_to_user()</code>把它复制到进程地址空间中由<code>param</code>参数指定的地址。<code>sched_setparam()</code>系统调用类似于<code>sched_setscheduler()</code>，它与后者的不同在于不让调用者设置<code>policy</code>字段的值。</p></li><li><p><code>sched_yield()</code>系统调用</p><p>&emsp;&emsp;<code>sched_yield()</code>系统调用提供了一种让进程资源地让出CPU给其他等待执行的进程的方法，这个调用主要由<code>SCHED_FIFO</code>实时进程调用。</p><p>&emsp;&emsp;在Linux中对于实时进程和普通进程在调用该函数后的处理有些不同。当调用该函数的进程是一个普通进程时，内核会把该进程移到进程队列中的过期队列中，这样可以保证该进程在一段时间内不会再次被调度。当调用该函数的进程是一个实时进程时，由于实时进程不会过期，所以内核会将调用该函数的进程放到优先级队列的后面，而不是移到过期队列中。</p></li><li><p><code>sched_get_priority_min()</code>和<code>sched_get_priority_max()</code>系统调用</p><p>&emsp;&emsp;该系统调用主要用于返回给定调度策略的最大和最小优先级。实时调度策略的最大优先级时<code>MAX_USER_RT_PRIO</code>减1，最小优先级是1.当调用该函数时若<code>current</code>是实时进程,<code>sys_sched_get_priority_min()</code>服务例程返回1，否则返回0；<code>sys_sched_get_priority_max()</code>服务例程返回99（最高优先级），否则返回0.</p></li><li><p><code>sched_rr_get_interval()</code>系统调用</p><p><code>sched_rr_get_interval()</code>系统调用把参数pid表示的实时进程的轮转时间片写入用户态地址空间的一个结构中。如果pid等于0，系统调用就写当前进程的时间片。相应的<code>sys_sched_rr_get_interval()</code>服务例程同样带哦用<code>find_process_by_pid()</code>检索与pid相关的进程描述符。然后，把存放在所选中进程的基本时间片转换为秒数和纳秒数，并把它们复制到用户态的结构中，通常，FIFO实时进程的时间片等于0。</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&amp;emsp;&amp;emsp;Linux内核提供的一些系统调用主要用于管理和维护与进程调度相关的参数值，这些系统调用可以用来获取和设置进程的优先级、进程调度策略，以及进程与处理器的亲和力等。&lt;/p&gt;
&lt;div class=&quot;table-container&quot;&gt;
&lt;table&gt;
&lt;t
      
    
    </summary>
    
      <category term="Linux内核" scheme="http://wanqbin.xyz/categories/Linux%E5%86%85%E6%A0%B8/"/>
    
    
      <category term="操作系统" scheme="http://wanqbin.xyz/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="Linux内核" scheme="http://wanqbin.xyz/tags/Linux%E5%86%85%E6%A0%B8/"/>
    
      <category term="系统调用" scheme="http://wanqbin.xyz/tags/%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/"/>
    
  </entry>
  
  <entry>
    <title>Linux内核调度</title>
    <link href="http://wanqbin.xyz/2019/08/08/Linux%E5%86%85%E6%A0%B8%E8%B0%83%E5%BA%A6/"/>
    <id>http://wanqbin.xyz/2019/08/08/Linux内核调度/</id>
    <published>2019-08-08T08:08:00.000Z</published>
    <updated>2019-08-08T08:09:17.115Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、schedule"><a href="#一、schedule" class="headerlink" title="一、schedule()"></a>一、<code>schedule()</code></h2><p>&emsp;&emsp;选定下一个需要调度的进程并切换到该进程上面去执行是通过<code>schedule()</code>函数来实现的。当内核代码想要休眠时，将会直接调用该函数；另外，在系统返回到用户态以及从中断返回时，内核都会调用<code>need_resched()</code>函数检查时候设置了<code>need_resched</code>标志，来决定是否调用<code>schedule()</code>函数。<code>need_resched</code>存放在<code>thread_info</code>结构体中，用一个标志变量中的一位来表示，用于表示当前是否需要重新调度。</p><p>&emsp;&emsp;<code>schedule()</code>函数独立于每个处理器运行，每个CPU都有自己的标号id和运行队列，因此每个CPU可以独立地对下一次该运行那个进程做出判断。通过<code>smp_processor_id()</code>可以获取当前的CPU标号，其类型为<code>unsigned int</code>。通过<code>cpu_rq(cpu)</code>可以获取CPU的运行队列。</p><p><code>schedule()</code>函数中的部分代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">need_resched:</span><br><span class="line">preempt_disable();</span><br><span class="line">cpu=smp_processor_id();</span><br><span class="line">rq=cpu_rq(cpu);</span><br><span class="line">rcu_qsctr_inc(cpu);</span><br><span class="line">prev=rq-&gt;curr;</span><br><span class="line">switch_count=&amp;prev-&gt;nivcsw;</span><br><span class="line">release_kernel_lock(prev);</span><br></pre></td></tr></table></figure><p>调用<code>preempt_disable()</code>函数禁止内核抢占，然后获取当前CPU的运行队列。调用<code>release_kernel_lock()</code>函数，如果内核被锁定，该函数释放大内核锁。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">local_irq_disable();</span><br><span class="line">_update_rq_clock(rq);</span><br><span class="line">sppin_lock(&amp;rq-&gt;lock);</span><br><span class="line">clear_tsk_need_resched(prev);</span><br></pre></td></tr></table></figure><p>代码中<code>local_irq_disable()</code>函数用于禁止当前处理器中断，<code>_update_rq_clock()</code>函数用于更新当前运行队列<code>rq</code>的时钟，<code>clear_tsk_need_resched()</code>函数用于清除当前进程的<code>need_resched()</code>标志。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(prev-&gt;state&amp;&amp;!(preempt_count()&amp;&amp;PREEMPT_ACCTIVE))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(unlikely((prev-&gt;state&amp;TASK_INTERRUPTIBLE)&amp;&amp;unlikely(signal_pending(prev))))</span><br><span class="line">        &#123;</span><br><span class="line">          prev-&gt;state=TASK_RUNNING;  </span><br><span class="line">        &#125;</span><br><span class="line">       <span class="keyword">else</span></span><br><span class="line">       &#123;</span><br><span class="line">           deactivate_task(rq,prev,<span class="number">1</span>);</span><br><span class="line">       &#125;</span><br><span class="line">      switch_count=&amp;prev-&gt;nvcsw;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>if(prev-&gt;state&amp;&amp;!(preempt_count()&amp;&amp;PREEMPT_ACCTIVE))</code>,表示判断当前进程的状态是否为<code>TASK_RUNNING</code>状态，并且当前的内核是否为非抢占式。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(unlikely((prev-&gt;state&amp;TASK_INTERRUPTIBLE)&amp;&amp;unlikely(signal_pending(prev))))</span><br><span class="line">       &#123;</span><br><span class="line">         prev-&gt;state=TASK_RUNNING;  </span><br><span class="line">       &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">          deactivate_task(rq,prev,<span class="number">1</span>);</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure><p>其中，以上代码查看当前进程的状态是否为可中断睡眠状态<code>TASK_INTERRUPTIBLE</code>，并且等待的信号已经发生。如果是，则将当前进程的状态重新设置为可执行状态<code>TASK_RUNNING</code>，否则将当前进程从运行队列中删除。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(unlikely(!rq-&gt;nr_running))</span><br><span class="line">&#123;</span><br><span class="line">    idle_balance(cpu,rq);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码检查当前CPU的运行队列是否有可执行的进程，如果没有可执行的进程且定义了SMP，调用<code>idle_balance()</code>函数进行负载平衡。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">prev-&gt;sched_class-&gt;put_prev_task(rq,prev);</span><br></pre></td></tr></table></figure><p>以上代码调用当前进程调度类的<code>put_prev_task()</code>函数，根据进程的状态将其放入到相应的队列中。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">next=pick_next_task(rq,prev);</span><br></pre></td></tr></table></figure><p>以上代码调用<code>pick_next_task()</code>函数从当前CPU的运行队列中选取下一个需要执行的任务。<code>pick_next_task()</code>函数在选择下一个需要调度的进程时，充分体现了模块化调度的好处。它首先检查是否有实时进程，如果没有，就调用CFS调度类的<code>pick_next_task()</code>函数选择下一个需要调度的进程；如果存在实时进程，则调用实时进程调度类的<code>pick_next_task()</code>函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(likely(prev!=next))</span><br><span class="line">&#123;</span><br><span class="line">    rq-&gt;nr_switchs++;</span><br><span class="line">    rq-&gt;curr=next;</span><br><span class="line">    ++*switch_count;</span><br><span class="line">    context_switch(rq,prev,next);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    spin_unlock_irq(&amp;rq-&gt;lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码检查下一个需要调度的进程和当前进程是否为同一个进程。如果不是，则调用<code>context_switch()</code>函数进行上下文切换。<code>context_switch()</code>函数负责上下文的切换，即从一个进程切换到另一个可执行的进程。它主要完成以下两个工作：</p><ul><li>虚拟内存映射的切换：负责把虚拟内存从被切换下来的进程映射到新进程中，该功能是由函数<code>switch_mm()</code>来实现的。</li><li>进程的寄存器状态的切换：负责从一个进程的处理器状态切换到新进程的处理器状态，该功能是由函数<code>switch_to()</code>来实现的。</li></ul><h2 id="二、内核抢占"><a href="#二、内核抢占" class="headerlink" title="二、内核抢占"></a>二、内核抢占</h2><p>&emsp;&emsp;为了提高系统的响应能力、实时能力以及用户的满意度，在Linux2.6内核中引入了抢占机制；即只要重新调度是安全的，那么内核就可以在任何时间抢占正在执行的任务。内核抢占与用户抢占一样，包含显式内核抢占和隐式内核抢占。</p><p>（1）显式内核抢占：这种抢占很简单，它发生在内核代码调用<code>schedule()</code>函数时的内核空间中，内核代码可以用两种方式调用<code>schedule()</code>函数，即主动调用<code>schedule()</code>函数让出CPU控制权或内核代码被阻塞时调用<code>schedule()</code>函数。显式内核抢占从来都是受支持的，因为它无需额外的逻辑来保证内核可以安全地被抢占，如果内核代码调用<code>schedule()</code>，那么它应该很清楚自己是可以被安全地抢占的。</p><p>（2）隐式内核抢占：这是Linux2.6新增的功能，当一个内核任务拥有对CPU控制权时，只要当前进程没有持有任何锁（即重新调度是安全的），这个内核任务就可以被另一个更高优先级的内核任务抢占。为了支持隐式内核抢占，在每个进程的<code>thread_info</code>结构中引入了<code>preempt_count</code>计数器，该计数器的初始值为0，每当使用锁的时候数值增加1，释放锁的时候数值减1。当数值为0时，内核就可以执行抢占。从中断返回内核空间的时候，内核会检查<code>need_resched</code>和<code>preempt_count</code>的值，如果<code>need_resched</code>被设置，并且<code>preempt_count</code>为0的话，这说明有一个更为重要的任务需要执行且可以安全地被抢占，此时，调度程序就会被调用。如果<code>preempt_count</code>不为0，说明当前的任务持有锁，不能被抢占，这时就会直接从中断返回到当前执行的任务中。如果当前的任务持有的锁被释放，<code>preempt_count</code>等于0，释放锁的代码就会检查<code>need_resched</code>时候被设置，如果是，就会调用调度程序。与内核相关的几个函数如下：</p><ul><li><p><code>preempt_enable_no_resched()</code>函数激活内核抢占，该函数会调用<code>dec_preempt_count()</code>函数，使<code>preempt_count</code>的值减1。</p></li><li><p><code>preempt_disable()</code>函数禁止内核抢占，该函数会调用<code>inc_preempt_count()</code>,使<code>preempt_count</code>的值加1。</p></li><li><p><code>preempt_enable()</code>函数激活内核抢占且检查是否需要内核抢占，该函数会调用<code>preempt_enable_no_resched()</code>函数，同时会调用<code>preempt_check_resched()</code>判断当前进程是否被标记为重新调度，如果是，它调用<code>preempt_schedule()</code>函数进行内核抢占。</p></li></ul><p>根据以上描述，可知内核抢占的时机是：</p><ul><li>从中断处理程序返回内核空间时</li><li>内核代码再一次具有可抢占性的时候</li><li>内核中显式地调用<code>schedule()</code></li><li>内核的任务阻塞</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、schedule&quot;&gt;&lt;a href=&quot;#一、schedule&quot; class=&quot;headerlink&quot; title=&quot;一、schedule()&quot;&gt;&lt;/a&gt;一、&lt;code&gt;schedule()&lt;/code&gt;&lt;/h2&gt;&lt;p&gt;&amp;emsp;&amp;emsp;选定下一个需要调度
      
    
    </summary>
    
      <category term="Linux内核" scheme="http://wanqbin.xyz/categories/Linux%E5%86%85%E6%A0%B8/"/>
    
    
      <category term="操作系统" scheme="http://wanqbin.xyz/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="Linux内核调度" scheme="http://wanqbin.xyz/tags/Linux%E5%86%85%E6%A0%B8%E8%B0%83%E5%BA%A6/"/>
    
      <category term="内核抢占" scheme="http://wanqbin.xyz/tags/%E5%86%85%E6%A0%B8%E6%8A%A2%E5%8D%A0/"/>
    
  </entry>
  
  <entry>
    <title>Linux内核调度</title>
    <link href="http://wanqbin.xyz/2019/08/08/nux%E5%86%85%E6%A0%B8%E8%B0%83%E5%BA%A6/"/>
    <id>http://wanqbin.xyz/2019/08/08/nux内核调度/</id>
    <published>2019-08-08T08:06:00.000Z</published>
    <updated>2019-08-08T08:07:31.330Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、schedule"><a href="#一、schedule" class="headerlink" title="一、schedule()"></a>一、<code>schedule()</code></h2><p>&emsp;&emsp;选定下一个需要调度的进程并切换到该进程上面去执行是通过<code>schedule()</code>函数来实现的。当内核代码想要休眠时，将会直接调用该函数；另外，在系统返回到用户态以及从中断返回时，内核都会调用<code>need_resched()</code>函数检查时候设置了<code>need_resched</code>标志，来决定是否调用<code>schedule()</code>函数。<code>need_resched</code>存放在<code>thread_info</code>结构体中，用一个标志变量中的一位来表示，用于表示当前是否需要重新调度。</p><p>&emsp;&emsp;<code>schedule()</code>函数独立于每个处理器运行，每个CPU都有自己的标号id和运行队列，因此每个CPU可以独立地对下一次该运行那个进程做出判断。通过<code>smp_processor_id()</code>可以获取当前的CPU标号，其类型为<code>unsigned int</code>。通过<code>cpu_rq(cpu)</code>可以获取CPU的运行队列。</p><p><code>schedule()</code>函数中的部分代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">need_resched:</span><br><span class="line">preempt_disable();</span><br><span class="line">cpu=smp_processor_id();</span><br><span class="line">rq=cpu_rq(cpu);</span><br><span class="line">rcu_qsctr_inc(cpu);</span><br><span class="line">prev=rq-&gt;curr;</span><br><span class="line">switch_count=&amp;prev-&gt;nivcsw;</span><br><span class="line">release_kernel_lock(prev);</span><br></pre></td></tr></table></figure><p>调用<code>preempt_disable()</code>函数禁止内核抢占，然后获取当前CPU的运行队列。调用<code>release_kernel_lock()</code>函数，如果内核被锁定，该函数释放大内核锁。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">local_irq_disable();</span><br><span class="line">_update_rq_clock(rq);</span><br><span class="line">sppin_lock(&amp;rq-&gt;lock);</span><br><span class="line">clear_tsk_need_resched(prev);</span><br></pre></td></tr></table></figure><p>代码中<code>local_irq_disable()</code>函数用于禁止当前处理器中断，<code>_update_rq_clock()</code>函数用于更新当前运行队列<code>rq</code>的时钟，<code>clear_tsk_need_resched()</code>函数用于清除当前进程的<code>need_resched()</code>标志。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(prev-&gt;state&amp;&amp;!(preempt_count()&amp;&amp;PREEMPT_ACCTIVE))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(unlikely((prev-&gt;state&amp;TASK_INTERRUPTIBLE)&amp;&amp;unlikely(signal_pending(prev))))</span><br><span class="line">        &#123;</span><br><span class="line">          prev-&gt;state=TASK_RUNNING;  </span><br><span class="line">        &#125;</span><br><span class="line">       <span class="keyword">else</span></span><br><span class="line">       &#123;</span><br><span class="line">           deactivate_task(rq,prev,<span class="number">1</span>);</span><br><span class="line">       &#125;</span><br><span class="line">      switch_count=&amp;prev-&gt;nvcsw;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>if(prev-&gt;state&amp;&amp;!(preempt_count()&amp;&amp;PREEMPT_ACCTIVE))</code>,表示判断当前进程的状态是否为<code>TASK_RUNNING</code>状态，并且当前的内核是否为非抢占式。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(unlikely((prev-&gt;state&amp;TASK_INTERRUPTIBLE)&amp;&amp;unlikely(signal_pending(prev))))</span><br><span class="line">       &#123;</span><br><span class="line">         prev-&gt;state=TASK_RUNNING;  </span><br><span class="line">       &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">          deactivate_task(rq,prev,<span class="number">1</span>);</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure><p>其中，以上代码查看当前进程的状态是否为可中断睡眠状态<code>TASK_INTERRUPTIBLE</code>，并且等待的信号已经发生。如果是，则将当前进程的状态重新设置为可执行状态<code>TASK_RUNNING</code>，否则将当前进程从运行队列中删除。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(unlikely(!rq-&gt;nr_running))</span><br><span class="line">&#123;</span><br><span class="line">    idle_balance(cpu,rq);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码检查当前CPU的运行队列是否有可执行的进程，如果没有可执行的进程且定义了SMP，调用<code>idle_balance()</code>函数进行负载平衡。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">prev-&gt;sched_class-&gt;put_prev_task(rq,prev);</span><br></pre></td></tr></table></figure><p>以上代码调用当前进程调度类的<code>put_prev_task()</code>函数，根据进程的状态将其放入到相应的队列中。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">next=pick_next_task(rq,prev);</span><br></pre></td></tr></table></figure><p>以上代码调用<code>pick_next_task()</code>函数从当前CPU的运行队列中选取下一个需要执行的任务。<code>pick_next_task()</code>函数在选择下一个需要调度的进程时，充分体现了模块化调度的好处。它首先检查是否有实时进程，如果没有，就调用CFS调度类的<code>pick_next_task()</code>函数选择下一个需要调度的进程；如果存在实时进程，则调用实时进程调度类的<code>pick_next_task()</code>函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(likely(prev!=next))</span><br><span class="line">&#123;</span><br><span class="line">    rq-&gt;nr_switchs++;</span><br><span class="line">    rq-&gt;curr=next;</span><br><span class="line">    ++*switch_count;</span><br><span class="line">    context_switch(rq,prev,next);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    spin_unlock_irq(&amp;rq-&gt;lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码检查下一个需要调度的进程和当前进程是否为同一个进程。如果不是，则调用<code>context_switch()</code>函数进行上下文切换。<code>context_switch()</code>函数负责上下文的切换，即从一个进程切换到另一个可执行的进程。它主要完成以下两个工作：</p><ul><li>虚拟内存映射的切换：负责把虚拟内存从被切换下来的进程映射到新进程中，该功能是由函数<code>switch_mm()</code>来实现的。</li><li>进程的寄存器状态的切换：负责从一个进程的处理器状态切换到新进程的处理器状态，该功能是由函数<code>switch_to()</code>来实现的。</li></ul><h2 id="二、内核抢占"><a href="#二、内核抢占" class="headerlink" title="二、内核抢占"></a>二、内核抢占</h2><p>&emsp;&emsp;为了提高系统的响应能力、实时能力以及用户的满意度，在Linux2.6内核中引入了抢占机制；即只要重新调度是安全的，那么内核就可以在任何时间抢占正在执行的任务。内核抢占与用户抢占一样，包含显式内核抢占和隐式内核抢占。</p><p>（1）显式内核抢占：这种抢占很简单，它发生在内核代码调用<code>schedule()</code>函数时的内核空间中，内核代码可以用两种方式调用<code>schedule()</code>函数，即主动调用<code>schedule()</code>函数让出CPU控制权或内核代码被阻塞时调用<code>schedule()</code>函数。显式内核抢占从来都是受支持的，因为它无需额外的逻辑来保证内核可以安全地被抢占，如果内核代码调用<code>schedule()</code>，那么它应该很清楚自己是可以被安全地抢占的。</p><p>（2）隐式内核抢占：这是Linux2.6新增的功能，当一个内核任务拥有对CPU控制权时，只要当前进程没有持有任何锁（即重新调度是安全的），这个内核任务就可以被另一个更高优先级的内核任务抢占。为了支持隐式内核抢占，在每个进程的<code>thread_info</code>结构中引入了<code>preempt_count</code>计数器，该计数器的初始值为0，每当使用锁的时候数值增加1，释放锁的时候数值减1。当数值为0时，内核就可以执行抢占。从中断返回内核空间的时候，内核会检查<code>need_resched</code>和<code>preempt_count</code>的值，如果<code>need_resched</code>被设置，并且<code>preempt_count</code>为0的话，这说明有一个更为重要的任务需要执行且可以安全地被抢占，此时，调度程序就会被调用。如果<code>preempt_count</code>不为0，说明当前的任务持有锁，不能被抢占，这时就会直接从中断返回到当前执行的任务中。如果当前的任务持有的锁被释放，<code>preempt_count</code>等于0，释放锁的代码就会检查<code>need_resched</code>时候被设置，如果是，就会调用调度程序。与内核相关的几个函数如下：</p><ul><li><p><code>preempt_enable_no_resched()</code>函数激活内核抢占，该函数会调用<code>dec_preempt_count()</code>函数，使<code>preempt_count</code>的值减1。</p></li><li><p><code>preempt_disable()</code>函数禁止内核抢占，该函数会调用<code>inc_preempt_count()</code>,使<code>preempt_count</code>的值加1。</p></li><li><p><code>preempt_enable()</code>函数激活内核抢占且检查是否需要内核抢占，该函数会调用<code>preempt_enable_no_resched()</code>函数，同时会调用<code>preempt_check_resched()</code>判断当前进程是否被标记为重新调度，如果是，它调用<code>preempt_schedule()</code>函数进行内核抢占。</p></li></ul><p>根据以上描述，可知内核抢占的时机是：</p><ul><li>从中断处理程序返回内核空间时</li><li>内核代码再一次具有可抢占性的时候</li><li>内核中显式地调用<code>schedule()</code></li><li>内核的任务阻塞</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、schedule&quot;&gt;&lt;a href=&quot;#一、schedule&quot; class=&quot;headerlink&quot; title=&quot;一、schedule()&quot;&gt;&lt;/a&gt;一、&lt;code&gt;schedule()&lt;/code&gt;&lt;/h2&gt;&lt;p&gt;&amp;emsp;&amp;emsp;选定下一个需要调度
      
    
    </summary>
    
      <category term="Linux内核" scheme="http://wanqbin.xyz/categories/Linux%E5%86%85%E6%A0%B8/"/>
    
    
      <category term="操作系统" scheme="http://wanqbin.xyz/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="Linux内核调度" scheme="http://wanqbin.xyz/tags/Linux%E5%86%85%E6%A0%B8%E8%B0%83%E5%BA%A6/"/>
    
      <category term="内核抢占" scheme="http://wanqbin.xyz/tags/%E5%86%85%E6%A0%B8%E6%8A%A2%E5%8D%A0/"/>
    
  </entry>
  
  <entry>
    <title>Linux进程调度——实时调度算法</title>
    <link href="http://wanqbin.xyz/2019/08/08/Linux%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6%E2%80%94%E2%80%94%E5%AE%9E%E6%97%B6%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95/"/>
    <id>http://wanqbin.xyz/2019/08/08/Linux进程调度——实时调度算法/</id>
    <published>2019-08-08T06:38:00.000Z</published>
    <updated>2019-08-08T08:09:26.002Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、实时调度策略"><a href="#一、实时调度策略" class="headerlink" title="一、实时调度策略"></a>一、实时调度策略</h2><p>&emsp;&emsp;在Linux中，实时优先级范围从0到<code>MAX_RT_PRIO-1</code>，默认情况下，<code>MAX_RT_PRIO</code>为100，所以默认情况的实时优先级从0到99。任何实时进程都比普通进程先得到调度，Linux提供了两种调度策略：<code>SCHED_FIFO</code>和<code>SCHED_RR</code>。</p><p>&emsp;&emsp;<code>SCHED_FIFO</code>实现了一种非常简单的、先进先出的调度算法。适用于对相应时间要求比较高，运行所需时间比较短的实时进程。采用该策略时，各实时进程按其进入可运行队列的顺序依次获得CPU。除了因等待某一时间主动放弃CPU，或者出现优先级更高的进程而剥夺CPU之外，该进程将一直占用CPU，直到进程运行结束。</p><p>&emsp;&emsp;<code>SCHED_RR</code>与<code>SCHED_FIFO</code>大致相同，是带有时间片的<code>SCHED_FIFO</code>。适用于对响应时间要求比较高，运行所需时间比较长的实时进程。采用该策略时，各实时进程按时间片轮流使用CPU。当一个运行进程的时间片用完之后，重置其时间片，进程调度程序停止其运行并将其置于可运行队列的末尾。</p><p>&emsp;&emsp;Linux实时调度策略提供的实时调度是软实时调度。软实时的含义是：内核调度进程尽力使进程在它优先的限定时间到来前运行，但内核并不保证总能满足这些进程的要求。相反，硬实时系统保证在一定条件下，可以满足任何调度的要求。Linux对于实时任务的调度不做任何保证，虽然不能保证硬实时工作方式，但是Linux的实时调度算法经过简单的修改可以满足硬实时的要求。</p><p>&emsp;&emsp;实时任务存放在实时运行队列中。由结构<code>rt-rq</code>表示。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rt</span>-<span class="title">rq</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rt_prio_array</span> <span class="title">active</span>;</span><span class="comment">/*实时任务的优先级数组*/</span></span><br><span class="line"><span class="keyword">int</span> rt_load_balance_idx;<span class="comment">/*需要进行负载平衡的实时队列的下标*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> *<span class="title">rt_load_balance_head</span> *<span class="title">rt_load_balance_curr</span>;</span><span class="comment">/*需要进行负载平衡队列的链表头节点，需要负载平衡的下一个任务*/</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在实时运行队列<code>rt_rq</code>中有一个实时优先队列数组，定义在<code>kernel/sched.c</code>中，由结构<code>rt_prio_array</code>表示。实时优先级数组使处理器中实时进程的每个优先级包含一个相应的队列，而这些队列包含了对应优先级上的可运行实时任务链表。优先级数组还有一个优先级位图，当需要查找当前系统内拥有最高优先级的可执行进程时，它可以帮助提高效率，<code>rt_prio_array</code>定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">re_prio_array</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    DECLARE_BITMAP(bitmap,MAX_RT_PRIO+<span class="number">1</span>);<span class="comment">/*优先级位图*/</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">queue</span>[<span class="title">MAX_RT_PRIO</span>];</span><span class="comment">/*优先级队列*/</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;优先级位图的实际类型为<code>unsigned long</code>长整型数组，数组的大小通过<code>BITS_TO_LONGS(bits)</code>来确定，默认的<code>MAX_RT_PRIO</code>值为100，因此需要使用5个长整型的数来表示。长整型数组中的每一位代表一个优先级。一开始，所有的位都被设置为0，当某个任务的状态变为可执行状态时，位图中相应的优先级位被设置为1.</p><p>&emsp;&emsp;比如一个优先级为2的实时任务变为可执行状态时，第2位就被置为1.这样，查找系统中最高的优先级就成了查找位图中第一个被设置的位。因为优先级格式是一个定值，所以查找时间恒定。此外，Linux对它支持的每个体系结构上都提供了对应的快速查找函数<code>sched_find_first_bit()</code>，以保证对位图的快速查找。</p><p>&emsp;&emsp;每个优先级数组还包含了一个叫做<code>struct list_head</code>的队列，每个队列上都包含对应处理器上相应优先级的全部可运行任务。</p><h2 id="二、实时调度的具体实现"><a href="#二、实时调度的具体实现" class="headerlink" title="二、实时调度的具体实现"></a>二、实时调度的具体实现</h2><p>&emsp;&emsp;实时调度类定义在<code>sched_rt.c</code>中，下面对实时调度类对应的每个函数进行简要的说明。</p><ol><li><p><code>enqueue_task_rt()</code></p><p>把实时进程插入到相应的运行队列尾部，并设置对应的优先级位图。</p></li><li><p><code>dequeue_task_rt()</code></p><p>记录实时任务的运行时间，把进程从相应的优先级队列中删除，检查相对应的优先级队列是否为空，如果为空，清除相应的优先级位图。</p></li><li><p><code>yidld_task_rt()</code></p><p>把实时进程从相应的优先级队列的头部插入到尾部。</p></li><li><p><code>check_preempt_curr_rt()</code></p><p>函数原型如下：</p><p><code>static void check_preempt_curr_rt(struct rq*rq,struct task_struct *p)</code></p><p>检查任务p的优先级是否大于当前运行队列中的优先级，如果是，调用<code>resched_task()</code>函数，设置当前进程需要被调度的标志。</p></li><li><p><code>pick_next_task_rt()</code></p><p>从优先级数组中选取一个优先级最高的进程。</p></li><li><p><code>put_prev_task_rt()</code></p><p>更新当前任务的运行时间信息。</p></li><li><p><code>set_curr_task_rt()</code></p><p>重新计算实时进程运行的开始时间。</p></li><li><p><code>task_tick_rt()</code></p><p>当时间节拍函数被调用时，函数执行流程如下：</p><p>首先更新当前进程的运行时间信息，然后再查看该进程是否是时间片轮转的实时进程，如果是，对实时进程的时间片<code>time_slice</code>减1，如果<code>time_slice</code>等于0，则设置进程的<code>time_slice</code>为默认时间片（100*Hz/1000),并把当前进程加入到所对应的优先级队列的尾部。</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、实时调度策略&quot;&gt;&lt;a href=&quot;#一、实时调度策略&quot; class=&quot;headerlink&quot; title=&quot;一、实时调度策略&quot;&gt;&lt;/a&gt;一、实时调度策略&lt;/h2&gt;&lt;p&gt;&amp;emsp;&amp;emsp;在Linux中，实时优先级范围从0到&lt;code&gt;MAX_RT_PRI
      
    
    </summary>
    
      <category term="Linux内核" scheme="http://wanqbin.xyz/categories/Linux%E5%86%85%E6%A0%B8/"/>
    
    
      <category term="操作系统" scheme="http://wanqbin.xyz/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="Linux进程调度" scheme="http://wanqbin.xyz/tags/Linux%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6/"/>
    
      <category term="实时调度策略" scheme="http://wanqbin.xyz/tags/%E5%AE%9E%E6%97%B6%E8%B0%83%E5%BA%A6%E7%AD%96%E7%95%A5/"/>
    
      <category term="实时调度算法" scheme="http://wanqbin.xyz/tags/%E5%AE%9E%E6%97%B6%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Linux进程调度——CFS调度算法</title>
    <link href="http://wanqbin.xyz/2019/08/08/Linux%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6%E2%80%94%E2%80%94CFS%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95/"/>
    <id>http://wanqbin.xyz/2019/08/08/Linux进程调度——CFS调度算法/</id>
    <published>2019-08-08T04:10:00.000Z</published>
    <updated>2019-08-08T08:09:30.732Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、进程优先级和虚拟运行时间"><a href="#一、进程优先级和虚拟运行时间" class="headerlink" title="一、进程优先级和虚拟运行时间"></a>一、进程优先级和虚拟运行时间</h2><p>&emsp;&emsp;对于普通的进程，CFS保留了系统的静态优先级<code>nice</code>值。其范围从-20到19，默认值为0，<code>nice</code>值越大，优先级越低。但是CFS不再使用动态优先级的概念，而是对每个进程进行加权，权值越大的进程获得CPU时间相对较多。<code>nice</code>值与权值之间存在着对应关系，<code>nice</code>每增加1，其对应权值就会降低25%；<code>nice</code>值每减小1，其对应的权值就会增大25%；<code>nice</code>值为0，对应的权值为1024.<code>nice</code>值和权值可以通过<code>prio_to_weight</code>数组进行转换。</p><p>&emsp;&emsp;CFS中每个任务的权值由<code>load_weight</code>结构来存储。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">load_weight</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> weight,inv_weight;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;其中，<code>weight</code>是任务的权值，<code>inv_weight</code>表示权值的倒置，在根据权值计算进程的虚拟运行时间时，需要使用该值。</p><p>&emsp;&emsp;<code>vruntime</code>(单位：纳秒)记录每个任务已经获得的CPU时间。理想的状态下，在任何时刻，系统中所有任务都应该得到相同额<code>vruntime</code>。但是由于同一时刻，系统中只能有一个任务（在单CPU的机器上）可以执行，因此每个任务的<code>vruntime</code>并不相同。<code>vruntime</code>是CFS选择下一个需要运行的任务的依据，是红黑树中每个实体的键值，系统从红黑树中选择<code>vruntime</code>最小值的节点（最左边的节点）作为下一个可运行的实体。</p><p>&emsp;&emsp;一个任务的<code>vruntime</code>的值与其权值<code>weight</code>有关，当一个新的任务产生时，<code>vruntime</code>可简单地通过下面的公司计算获得：</p><p><code>vruntime=sysctl_sched_latecy *NICE_TO_LOAD/weight</code></p><p>&emsp;&emsp;其中<code>sysctl_sched_latecy</code>是任务的一次可执行时间，默认为20ms；<code>NICE_TO_LOAD</code>是<code>nice</code>值为0的权值，即1024；<code>weight</code>为任务的权值。</p><p>&emsp;&emsp;任务在运行时，权值不同的任务执行相同的时间，其对应的<code>vruntime</code>的增量是不同的，<code>vruntime</code>的增量<code>delta_vruntime</code>可以使用下面的公式来计算。</p><p><code>delta_vruntime=exec_time*NICE_TO_LOAD/weight</code></p><p>通过给每个任务赋予一定的权值，我们就可以区别每个任务的重要性，权值越高的任务越重要，其<code>vruntime</code>增长得越慢，得到的执行时间就会越多。</p><h2 id="二、CFS调度算法的实现"><a href="#二、CFS调度算法的实现" class="headerlink" title="二、CFS调度算法的实现"></a>二、CFS调度算法的实现</h2><p>我们根据CFS调度类<code>fair_sched_class</code>所对应的每个函数进行简要的说明。</p><ol><li><p><code>enqueue_task_fair()</code>：</p><p>该函数首先获取任务的调度实体，检查该调度实体是否已经在运行队列上，如果是，函数退出；否则计算调度实体的<code>vruntime</code>，并把调度实体加入到相应的运行队列中，运行队列的<code>nr_running</code>加1。如果定义了组调度，则要查看对应的父调度实体是否在相应的运行队列上，如果不是，则更新调度实体的<code>vruntime</code>，并加入到相应的运行队列，运行队列的<code>nr_running</code>加1。重复以上过程，直到到达最上层的调度实体。</p></li><li><p><code>dequeue_task_fair()</code></p><p>当任务执行完毕，或者阻塞的时候，调用该函数，把相应的调度实体从CFS的运行队列中删除。该函数首先获取任务的调度实体，把它从相应的运行队列中删除，运行队列的<code>nr_running</code>减1；如果定义了组调度，则检查调度实体对应的运行队列是否为空，如果是，把父调度实体从相应的运行队列中删除，重复以上过程。</p></li><li><p><code>yield_task_fair()</code></p><p>这个函数的实现很简单，只是把当前正在运行的任务调度实体的<code>vruntime</code>设置为运行队列最左边调度实体（<code>vruntime</code>最小的调度实体）的<code>vruntime</code>加1.当我们希望当前任务让出CPU时，首先调用该函数，更新当前运行的调度实体的<code>vruntime</code>，然后调用<code>put_prev_task()</code>把当前的调度实体加入到队列中。</p></li><li><p><code>put_prev_task_fair()</code></p><p>把当前任务的调度实体放入相应的运行队列中。如果定义了组调度，把父调度实体也放入相应的运行队列，重复此过程，直到到达最上层的调度实体。</p></li><li><p><code>check_preempt_wakeup()</code></p><p>函数原型为：<code>static void check_preempt_wakeup(struct rq* rq,struct task_struct *p)</code>。该函数检查刚创建的任务或者从阻塞状态转为可执行的任务p，是否应该抢占当前正在运行的任务。即查看当前调度实体的<code>vruntime</code>加上环形粒度（<code>wakeup_granularity</code>)是否大于任务p的调度实体的<code>vruntime</code>。如果是，调用<code>resched_task()</code>函数，设置当前进程需要被调度的标志。</p></li><li><p><code>pick_next_task_fair()</code></p><p>从运行队列中找出下一个需要调度的调度实体（红黑树最左边的节点），并返回该调度实体对应的任务。如果定义了组调度，查看该调度实体是否有自己的运行队列，如果有，从其运行队列中找出下一个调度实体，重复此过程，直到最底层的调度实体，当调度实体不存在自己的运行队列时，该调度实体只包含一个任务。</p></li><li><p><code>set_curr_task_fair()</code></p><p>函数原型为：<code>static void set_curr_task_fair(struct rq*rq)</code>。该函数把CPU的运行队列<code>rq</code>的当前任务p，设置成任务p的调度实体所对应的CFS运行队列的当前任务。如果定义了组调度，重复此过程，直到到达最上层的调度实体。</p></li><li><p><code>task_tick_fair()</code></p><p>时间节拍函数，检查当前的调度实体的运行时间是否大于其一次应该具有的运行时间，如果是，调用<code>resched_task()</code>函数，设置当前进程需要被调度的标志。如果定义了组调度，重复此过程，直到到达最上层的调度实体。</p></li><li><p><code>task_new_fair()</code></p><p>计算新任务调度实体的<code>vruntime</code>，并把任务实体放入到对应的运行队列中，调用<code>resched_task()</code>函数，设置当前进程需要被调度的标志。如果我们指定子进程先运行，则检查新任务调度实体的<code>vruntime</code>是否小于当前正在运行的调度实体的<code>vruntime</code>，如果不是，交换这两个调度实体<code>vruntime</code>，使新任务调度实体的<code>vruntime</code>最小。</p></li></ol><p>&emsp;&emsp;在CFS调度算法的实现中，引入了重要的<code>sysctl()</code>函数来在运行时对调度程序进行调优，时间都是以纳秒为单位。</p><p>(1)<code>sysctl_sched_latecy</code></p><p>抢占潜伏时间，一个任务一次可运行的最长时间。这个值与时间片长度不一样，它表示一个时间长度的变量，默认为20ms。针对CPU密集型任务进行目标抢占延迟。</p><p>(2)<code>sysctl_sched_min_granularity</code></p><p>最小抢占粒度，默认为4ms。针对CPU密集型任务执行最低级别抢占粒度。</p><p>(3)<code>sysctl_nr_latecy</code></p><p>在一个抢占潜伏期内可调度的次数。其值等于<code>sysctl_sched_latecy/sysctl_sched_min_granlarity</code></p><p>(4)<code>sysctl_sched_child_runs_first</code></p><p>在创建新进程时，子进程是否先运行，设置为1，表示子进程向运行，设置为0，表示父进程先运行。</p><p>(5)<code>sysctl_sched_batch_wakeup_granularity</code></p><p>针对<code>SCHED_BATCH</code>的唤醒粒度，默认为10ms</p><p>(6)<code>sysctl_sched_wakeup_granularity</code></p><p>针对<code>SCHED_OTHER</code>的唤醒粒度，默认为10ms。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、进程优先级和虚拟运行时间&quot;&gt;&lt;a href=&quot;#一、进程优先级和虚拟运行时间&quot; class=&quot;headerlink&quot; title=&quot;一、进程优先级和虚拟运行时间&quot;&gt;&lt;/a&gt;一、进程优先级和虚拟运行时间&lt;/h2&gt;&lt;p&gt;&amp;emsp;&amp;emsp;对于普通的进程，CF
      
    
    </summary>
    
      <category term="Linux内核" scheme="http://wanqbin.xyz/categories/Linux%E5%86%85%E6%A0%B8/"/>
    
    
      <category term="操作系统" scheme="http://wanqbin.xyz/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="Linux进程调度" scheme="http://wanqbin.xyz/tags/Linux%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6/"/>
    
      <category term="CFS调度算法" scheme="http://wanqbin.xyz/tags/CFS%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Linux进程调度——模块化调度和组调度</title>
    <link href="http://wanqbin.xyz/2019/08/08/inux%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6%E2%80%94%E2%80%94%E6%A8%A1%E5%9D%97%E5%8C%96%E8%B0%83%E5%BA%A6%E5%92%8C%E7%BB%84%E8%B0%83%E5%BA%A6/"/>
    <id>http://wanqbin.xyz/2019/08/08/inux进程调度——模块化调度和组调度/</id>
    <published>2019-08-08T03:09:00.000Z</published>
    <updated>2019-08-08T08:11:35.050Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、模块化调度"><a href="#一、模块化调度" class="headerlink" title="一、模块化调度"></a>一、模块化调度</h2><p>&emsp;&emsp;CFS提供了模块化调度，使得各种不同的调度算法都可以作为一个模块注册到该管理器中。不同的进程可以选择不同的调度模块。为了实现模块化调度，引入了称为“调度类”的概念。</p><p>&emsp;&emsp;调度类类似于一个模块链，封装了关于调度算法的信息，协助内核调度程序工作，每个调度算法模块需要实现由调度类建议的一组函数。CFS实现了两个调度算法模块，CFS算法模块(<code>sched_fair.c</code>)和实时调度模块(<code>sched_re.c</code>)。对应实时进程，将使用实时调度模块，对应普通进程则使用CFS算法。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sched_class</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">sched_class</span> *<span class="title">next</span>;</span><span class="comment">/*指向下一个调度类*/</span></span><br><span class="line">    <span class="keyword">void</span>(*enqueue_task)(struct rq *rq,struct task_struct *p,<span class="keyword">int</span> wakeup);</span><br><span class="line">    <span class="keyword">void</span>(*dequeue_task)(struct rq *rq,struct task_struct *p,<span class="keyword">int</span> sleep);</span><br><span class="line">    <span class="keyword">void</span>(*yield_task)(struct rq *rq);</span><br><span class="line">    <span class="keyword">void</span>(*check_preempt_curr)(struct rq *rq,struct task_struct *p);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *(*<span class="title">pick_next_task</span>)(<span class="title">struct</span> <span class="title">rq</span> *<span class="title">rq</span>);</span></span><br><span class="line">    <span class="keyword">void</span>(*put_prev_task)(struct rq *rq,struct task_struct *p);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_SMP</span></span><br><span class="line">    <span class="function"><span class="keyword">unsigned</span> <span class="title">long</span><span class="params">(*load_balance)</span><span class="params">(struct rq *this_rq,<span class="keyword">int</span> this_cpu,</span></span></span><br><span class="line"><span class="function"><span class="params">                                struct rq *busiest,<span class="keyword">unsigned</span> <span class="keyword">long</span> max_load_move,</span></span></span><br><span class="line"><span class="function"><span class="params">                                struct sched_domain *sd,<span class="keyword">enum</span> cpu_idle_type idle,</span></span></span><br><span class="line"><span class="function"><span class="params">                                <span class="keyword">int</span> *all_pinned,<span class="keyword">int</span> *this_best_prio)</span></span>;</span><br><span class="line">    <span class="keyword">int</span>(*move_one_task)(struct rq * this_rq,<span class="keyword">int</span> this_cpu,</span><br><span class="line">                       struct rq *busiest,struct sched_domain *sd,</span><br><span class="line">                       <span class="keyword">enum</span> cpu_idle_type idle);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">void</span>(*set_curr_task)(struct rq *rq);</span><br><span class="line">    <span class="keyword">void</span>(*task_tick)(struct rq *rq,struct task_struct *p);</span><br><span class="line">    <span class="keyword">void</span>(*task_new)(struct rq *rq,struct  task_struct *p);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ol><li><code>enqueue_task</code>:当某个任务进入可运行状态时，该函数将得到调用。它将调度实体（进程）放入相应的运行队列中，并对运行队列成员变量<code>nr_running</code>加1</li><li><code>dequeue_task</code>：当某个任务退出运行状态时调用该函数，它将从相应的运行队列中去掉对应的调度实体，并从<code>nr_running</code>变量中减1</li><li><code>yield_task</code>：在<code>compat_yield_syscttl</code>选项关闭的情况下，该函数实际上执行先出队后入队，这样就将相应的调度实体放在运行队列的最后。（如果是CFS运行队列，则将调度实体放在红黑树的最右端）</li><li><code>check_preempt_curr</code>：该函数将检查当前运行的任务是否被抢占。在实际抢占正在运行的任务之前，CFS调度程序模块将执行公平性测试。这将驱动唤醒（wakeup）抢占。</li><li><code>pick_next_task</code>：该函数选择接下来要运行的最合适的进程。</li><li><code>put_prev_task</code>：当一个进程不再运行时，调用该函数通知相应的调度模块。</li><li><code>load_balance</code>：每个调度程序模块实现两个函数，<code>load_balance_start()</code>和<code>load_balance_next()</code>，使用者两个函数实现一个迭代器，在调度模块的<code>load_balance</code>例程中调用。内核调度程序使用这种方法实现由调度模块管理的进程的负载平衡。</li><li><code>set_curr_task</code>：当任务修改其调度类或修改其任务组时，将调用这个函数。</li><li><code>task_tick</code>：该函数通常为时间节拍函数；它可能引起进程切换。这将驱动运行时（running）抢占。</li><li><code>task_new</code>：内核调度程序为调度模块提供了管理新任务启动的机会。CFS调度模块使用它进行组调度，而用于实时任务的调度模块不会使用这个函数。</li></ol><h2 id="二、组调度"><a href="#二、组调度" class="headerlink" title="二、组调度"></a>二、组调度</h2><p>&emsp;&emsp;通常情况下，调度器都是针对单个任务进行调度，为每个任务提供公平的CPU时间。但是在有些时候，我们需要为任务组提供公平的CPU时间考虑一个两用户的例子：用户A和用户B在一台机器上运行任务。用户A只有两个任务正在运行，而用户B正在运行48个任务。组调度使CFS能够对用户A和用户B进行公平调度，而不是对系统运行50个任务进行公平调度。每个用户拥有50%的CPU使用。用户B使用自己50%的CPU分配他的48个任务，而不会占用属于用户A的另外50%的CPU分配。</p><p>&emsp;&emsp;为了实现组调度，引入了一个称为“调度实体”的概念，用以指代被调度的对象，这个对象不一定是一个进程。调度实体保持了每个实体的调度信息，并将它们封装在<code>sched_entity</code>结构中，但它并没有改变CFS调度的工作方式。</p><p>&emsp;&emsp;调度实体是一个层次结构，每个调度实体代表一组进程，每个调度实体内部有一个自己的运行队列<code>my_q</code>。当我们定义了组调度时，调度实体内还存在一个指向上一层的实体<code>parent</code>指针和一个该实体所在的运行队列<code>cfs_rq</code>。缺省地，调度实体中只存在一个进程，且都在顶级层次结构中。</p><p>&emsp;&emsp;但当调度器选择下一个要运行的任务的时候，它首先检查所有顶级调度实体，取出最应获取CPU的实体，如果这个实体是一个高层调度实体，那么调度器就会检查调度实体中运行队列，并重复这一过程，直到达到层次结构的最底层，找到一个可执行的进程。在进程运行过程中，同样会收集一些运行时信息，这些信息同时会向上层调度实体传播，从而在每个级别上都正确度量其占用CPU的时间。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sched_entity</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">load_weight</span> <span class="title">load</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> <span class="title">run_node</span>;</span><span class="comment">/*调度实体上的运行节点*/</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> on_rq;<span class="comment">/*该调度实体上是否在运行队列上*/</span></span><br><span class="line">    u64 exec_strart;<span class="comment">/*任务开始运行的时间*/</span></span><br><span class="line">    u64 sum_exec_runtime;<span class="comment">/*任务总的运行时间*/</span></span><br><span class="line">    u64 vruntime;<span class="comment">/*应当占用CPU的时间*/</span></span><br><span class="line">    u64 prev_sum_exec_runtime;<span class="comment">/*任务最近一次执行前的sum_exec_runtime*/</span></span><br><span class="line">    </span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_FAIR_GROUP_SCHED</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sched_entity</span> *<span class="title">parent</span>;</span><span class="comment">/*指向该调度实体的父节点*/</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">cfs_rq</span> *<span class="title">cfs_rq</span>;</span><span class="comment">/*调度实体所在的CFS运行队列*/</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">cfs_rq</span> *<span class="title">my_q</span>;</span><span class="comment">/*调度实体所拥有的CFS运行队列*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;从调度实体可以看出，当我们定义了<code>CONFIG_FAIR_GROUP_SCHED</code>时，就开启了组调度。到目前为止，有两种策略对任务进行分组。</p><p>（1）基于用户id的分组策略（<code>CONFIG_FAIR_GROUP_SCHED</code>)</p><p>在这种分组策略中，根据任务所属的用户，对任务进行分组。</p><p>（2）基于cgroup的伪文件系统（<code>CONFIG_FAIR_CGROUP_SCHED</code>)</p><p>在这种分组策略中，管理员可以使用<code>cgroup</code>伪文件系统任意地创建任务组。调度器只能采用这两种策略中的一个，不能全部采用。Linux内核使用<code>task group</code>结构描述与任务组相关的信息。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_group</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_FAIR_CGROUP_SCHED</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">cgroup_subsys_state</span> <span class="title">css</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sched_entity</span> **<span class="title">se</span>;</span><span class="comment">/*任务组在每个CPU上所包含的调度实体*/</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">cfs_rq</span> **<span class="title">cfs_rq</span>;</span><span class="comment">/*任务组在每个CPU上所用的运行队列*/</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> shares;</span><br><span class="line">    <span class="keyword">spinlock_t</span> lock;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rcu</span>)<span class="title">head</span> <span class="title">rcu</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、模块化调度&quot;&gt;&lt;a href=&quot;#一、模块化调度&quot; class=&quot;headerlink&quot; title=&quot;一、模块化调度&quot;&gt;&lt;/a&gt;一、模块化调度&lt;/h2&gt;&lt;p&gt;&amp;emsp;&amp;emsp;CFS提供了模块化调度，使得各种不同的调度算法都可以作为一个模块注册到该管理
      
    
    </summary>
    
      <category term="Linux内核" scheme="http://wanqbin.xyz/categories/Linux%E5%86%85%E6%A0%B8/"/>
    
    
      <category term="操作系统" scheme="http://wanqbin.xyz/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="Linux内核" scheme="http://wanqbin.xyz/tags/Linux%E5%86%85%E6%A0%B8/"/>
    
      <category term="进程调度" scheme="http://wanqbin.xyz/tags/%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6/"/>
    
      <category term="模块化调度" scheme="http://wanqbin.xyz/tags/%E6%A8%A1%E5%9D%97%E5%8C%96%E8%B0%83%E5%BA%A6/"/>
    
      <category term="组调度" scheme="http://wanqbin.xyz/tags/%E7%BB%84%E8%B0%83%E5%BA%A6/"/>
    
  </entry>
  
  <entry>
    <title>Linux进程调度——内核调度概述</title>
    <link href="http://wanqbin.xyz/2019/08/07/Linux%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6%E2%80%94%E2%80%94%E5%86%85%E6%A0%B8%E8%B0%83%E5%BA%A6%E6%A6%82%E8%BF%B0/"/>
    <id>http://wanqbin.xyz/2019/08/07/Linux进程调度——内核调度概述/</id>
    <published>2019-08-07T15:31:00.000Z</published>
    <updated>2019-08-07T15:32:17.962Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、调度原理"><a href="#一、调度原理" class="headerlink" title="一、调度原理"></a>一、调度原理</h2><p>&emsp;&emsp;调度程序是内核的组成部分，它负责选择下一个要运行的进程。进程调度器可以看做是为处于就绪态的所有进程分配有限的处理器时间资源的内核子系统。在多任务的操作系统中，进程调度是一个全局性的关键的问题，它对系统的总体设计、系统的实现、功能设置以及各方面的性能都有着决定性的影响，是多任务操作系统的基础，只有通过调度程序的合理调度，系统资源才能最大限度地发挥作用，多任务才会有并发执行的效果。</p><p>&emsp;&emsp;调度程序的主要目标是：最大限度地利用处理器时间，同时要保证进程之间的公平性，使系统中的所有进程都有机会执行。为了满足这些目标，在设计进程调度程序时，应该考虑以下三个方面：</p><ul><li>调度时机：什么时候，什么情况下进行程序调度</li><li>调度策略：使用什么样的策略来选择下一个进入运行的进程</li><li>调度的方式：是抢占式还是非抢占式。当由调度程序来决定什么时候停止一个进程的执行，以便让其他程序能够得到执行机会时，这种强制挂起进程的动作称为抢占式。</li></ul><p>&emsp;进程调度器的设计，对系统的复杂性有着极大的影响，常常会由于调度器实现过于复杂而需要在功能与性能方面做出必要的权衡和让步。一个好的操作系统调度算法要兼顾三种不同应用的需要。</p><ol><li>交互式进程:在这种应用中，着重于系统的响应速度，使共用一个系统的各个用户都能感觉到自己是在独占地使用一个系统。特别是，当系统中有大量进程共存时，需要能保证每个交互式进程都有可接受的响应速度而使每个用户感觉不到明显的延时。</li><li>批处理进程：批处理进程往往是作为“后台作业”运行的，所以对响应速度并无要求，但是完成一个作业所要的时间仍是一个重要的因素，主要考虑“平均速度”。</li><li>实时进程：这是时间性最强的一类进程，不但要考虑进程执行的平均速度，还要考虑“即时速度”；不但要考虑响应速度，还要考虑有关程序能否在规定时间内执行完毕。</li></ol><h2 id="二、Linux调度器的发展"><a href="#二、Linux调度器的发展" class="headerlink" title="二、Linux调度器的发展"></a>二、Linux调度器的发展</h2><ol><li><h3 id="Linux2-4内核的调度器"><a href="#Linux2-4内核的调度器" class="headerlink" title="Linux2.4内核的调度器"></a>Linux2.4内核的调度器</h3><p>&emsp;&emsp;Linux2.4中使用的调度器采用基于优先级的设计。该调度器的<code>pick_next</code>算法非常简单：对运行队列<code>runqueue</code>中所有进程优先级依次进行比较，选择最高优先级的进程作为下一个被调度的进程。</p><p>&emsp;&emsp;每个进程被创建时都被赋予一个时间片。时钟中断则递减当前运行进程的时间片，当进程的时间片被用完时，它必须等待重新赋予时间片才能有机会运行。Linux2.4调度器保证只有当所有处于<code>RUNNING</code>状态的进程的时间片都被用完之后，才对所有进程重新分配时间片。这种设计保证了每个进程都有机会得到执行。</p><p>&emsp;&emsp;对于实时进程，调度器将实时进程的优先级静态设定，而且始终大于普通进程的优先级。因此只有当<code>runqueue</code>队列中没有实时进程存在的情况下，普通进程才能够得到调度，获得处理器时间。在Linux内核，实时进程采用两种调度策略：<code>SCHED_FIFO</code>和<code>SCHED_RR</code>。FIFO调度采用先进先出的策略，对于所有相同优先级的进程，最先进入<code>runqueue</code>队列的进程总能优先获得调度；<code>SCHED_RR</code>调度采用更加公平的轮转策略，使得相同优先级的实时进程能够轮流得到执行。</p><p>&emsp;&emsp;对于普通进程，调度器倾向于提高交互式进程的优先级，因为它们需要快速地用户响应。普通进程的优先级主要由进程描述符中的<code>counter</code>字段决定。进程被创建时子进程的<code>counter</code>值为父进程<code>counter</code>值的一半，这样保证了任何进程不能依靠不断的调用<code>fork()</code>函数创建子进程从而获得更多的执行机会。Linux2.4调度器在提高交互式进程的优先级时，做了如下工作：当所有<code>RUNNING</code>状态进程的时间片被用完之后，将重新计算所有进程的<code>counter</code>值，所有进程不仅包括<code>RUNNING</code>进程，也包括处于睡眠状态的进程。处于睡眠状态的进程的<code>counter</code>本来就没有用完，在重新计算时，它们的<code>counter</code>值会加上这些原来未用完的部分，从而提高了它们的优先级。交互式进程经常因为等待用户输入而处于睡眠状态，当它们重新被唤醒并进入<code>runqueue</code>队列时，就会优于其他进程而获得CPU。从用户的角度来看，交互式进程的响应速度就提高了。</p><p>&emsp;&emsp;这种调度的主要不足在于：</p><p>（1）可扩展性不好：调度器选择进程时需要遍历整个<code>runqueue</code>队列，从中选出最佳调度进程，因此该算法的执行时间与进程数成正比。另外每次重新计算<code>counter</code>所花费的时间也会随着系统中进程数的增加而线性增长，当进程数很大时，更新<code>counter</code>操作的代价会非常高，导致系统整体的性能下降。</p><p>（2）高负载系统上的调度性能比较低：Linux2.4的调度器预分配给每个进程的时间片比较大，因此在高负载的服务器上，该调度器的效率比较低，因为平均每个进程的等待时间与该时间片的大小成正比。</p><p>（3）交互式进程的优化并不完善：Linux2.4识别交互式进程的原理基于如下假设：即交互式进程比批处理进程更频繁地处于阻塞状态。然而现实情况往往并非如此，有些批处理进程虽然没有用户交互，但是也会频繁地进行I/O操作，比如一个数据库引擎在处理查询时会经常地进行磁盘I/O，虽然它们并不需要快速的用户响应，还是被提高了优先级。当系统中这类进程的负载较重时，会影响真正的交互式进程的响应时间。</p><p>（4）对实时进程的支持不够：Linux2.4内核是非抢占的，当进程处于内核态时不会发生抢占，这对于真正的实时应用是不能接受的。</p></li><li><h3 id="Linux2-6内核的O-1-调度器"><a href="#Linux2-6内核的O-1-调度器" class="headerlink" title="Linux2.6内核的O(1)调度器"></a>Linux2.6内核的O(1)调度器</h3><p>&emsp;&emsp;O(1)调度算法所花费的时间为常数，与当前系统中的进程个数无关。此外Linux2.6内核支持内核抢占，因此更好地支持了实时进程。相比于前任，O(1)调度器还更好地区分了交互式进程和批处理式进程。</p><p>&emsp;&emsp;Linux2.6内核也支持三种调度策略：<code>SCHED_NORMAL</code>、<code>SCHED_FIFO</code>、<code>SHCED_RR</code>。其中，<code>SCHED_FIFO</code>和<code>SCHED_RR</code>用于实时进程，而<code>SCHED_NORMAL</code>用于普通进程。O(1)调度器在两个方面修改了Linux2.4调度器，一是进程优先级的计算方法，二是<code>pick_next</code>算法。</p><p>&emsp;&emsp;（1）优先级计算方法</p><p>&emsp;&emsp;普通进程优先级是动态计算的，计算公式中包含了静态优先级。一般来讲，静态优先级越高，进程所能分配到的时间片越长，用户可通过<code>nice</code>系统调用修改进程的静态优先级。动态优先级由下面的公式计算得出。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dynamic_priority=max(<span class="number">100</span>,min(<span class="keyword">static</span> prority-bonus+<span class="number">5139</span>))</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;其中，<code>bouns</code>取决于进程的平均睡眠时间。平均睡眠时间越长，其<code>bouns</code>越大，从而得到更高的优先级。</p><p>&emsp;&emsp;实时进程的优先级由系统调用<code>sys_sched_setschedule()</code>设置。该值不会动态修改，而且总是比普通进程的优先级高。在进程描述符中用<code>rt_prioriity</code>域表示。</p><p>&emsp;&emsp;(2)<code>pick_next</code>算法</p><p>&emsp;&emsp;普通进程的调度选择算法基于进程优先级，拥有最高优先级的进程被调度器选中。在Linux2.4内核中，时间片<code>counter</code>同时也表示了一个进程的优先级。Linux2.6中的时间片用任务描述符中的<code>time_slice</code>域表示，而优先级用<code>prio(普通进程)</code>或者<code>rt_priority（实时进程）</code>表示。</p><p>&emsp;&emsp;调度器为每个CPU维护了两个进程队列数组：<code>active</code>数组（时间片未耗尽的进程队列）和<code>expire</code>数组（时间片以耗尽的进程队列）。数组中的元素保存某一优先级的进程队列指针。系统一共有140个不同的优先级，因此这两个数组大小都是140。当需要选择最高优先级进程时，Linux2.6内核的调度器不用遍历整个<code>runqueue</code>，而是直接从<code>active</code>数组中选择当前最高优先级队列中的第一个进程。</p><p>&emsp;&emsp;为了实现上述算法，<code>active</code>数组维护了一个<code>bitmap</code>位图，当某个优先级别上有进程被插入列表时，相应的比特位就被置位。<code>sched_find_first_bit()</code>函数查询位图bitmap，返回当前被置位的最高优先级的数组下标。</p><p>&emsp;&emsp;为了二提高交互式进程的响应时间，O(1)调度器不仅动态地提高该类进程的优先级，还采用以下方法。</p><p>&emsp;&emsp;在每次时钟<code>tick</code>中断时，进程的时间片(time_slice)被减1。当time_slice为0时，调度器判断当前进程的类型，如果是交互式进程或者实时进程，则重置时间片并重新插入<code>active</code>数组。如果不是交互式进程则从<code>active</code>数组中移到<code>expired</code>数组。这样实时进程和交互式进程就总能获得CPU。然而这些进程不能始终留在<code>active</code>数组，否则进入<code>expire</code>数组的进程就会产生饥饿现象。当进程已经占用CPU的时间超过一个固定值后，即使它是交互式进程或实时进程也会被移到<code>expire</code>数组中。</p><p>&emsp;&emsp;当<code>active</code>数组中的所有进程都被移到<code>expire</code>数组中后，调度器就会交换<code>active</code>数组和<code>expire</code>数组。当进程被调度器移入<code>active</code>数组中时，调度器会重置其时间片，因此新的<code>active</code>数组又恢复了初始情况，而<code>expire</code>数组为空，从而开始新的一轮调度。</p><p>&emsp;&emsp;这种调度器的主要不足是：</p><p>&emsp;&emsp;O(1)调度器群交互式进程和批处理进程的算法与以前虽大有改进，但是仍然在很多情况下会失效。有一些著名的程序总能让该调度器性能下降，导致交互式进程反应缓慢。</p></li></ol><h2 id="三、CFS调度器"><a href="#三、CFS调度器" class="headerlink" title="三、CFS调度器"></a>三、CFS调度器</h2><p>&emsp;&emsp;CFS(Completely Fair Scheduler)即“完全公平调度”，是一个新的进程调度器。</p><p>&emsp;&emsp;CFS的设计思想可以用一句话概括：CFS建立了一个调度模型，在实际的硬件上模拟出一个理想的、精确的多任务CPU。理想的多任务CPU即是要发挥实际CPU100%的能量，在CPU上并行地执行每个任务，且任务的执行速度相同，即1/nr_running。例如，假如系统中有两个任务在执行，则每个任务并行化地占有50%的资源，但是在实际的硬件条件下，每时每刻都只能有一个任务运行，为此引入了虚拟运行时间（vruntime)。一个任务的虚拟运行时间用来表示任务已经获得的CPU时间。CFS根据vruntime的值来选择下一个需要运行的任务。</p><p>&emsp;&emsp;与O(1)调度器相比，具有以下特点：</p><p>（1）CFS的核心数据结构不再基于队列数组，而是红黑树。树里面包含了所有的处理RUNNING状态的进程，而在最左边的进程就是下一个被调度的进程。</p><p>（2）CFS彻底以时间和系统负载为参照，完全抛弃原有调度方案中的双优先级数组的概念，使用红黑树来代替运行队列数组，vruntime作为红黑树中节点的键值。</p><p>（3）对于普通的进程，不再进一步区分是I/O消耗型进程还是处理器消耗型进程。</p><p>（4）不再使用时间片的概念，也不使用<code>jiffies</code>或者其他的Hz，而使用单位为纳秒的时间长度变量。</p><p>（5）引入了模块化调度：调度实体和调度类。</p><p>（6）对SMP负载平衡进行了重构，使用调度模块的迭代器。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、调度原理&quot;&gt;&lt;a href=&quot;#一、调度原理&quot; class=&quot;headerlink&quot; title=&quot;一、调度原理&quot;&gt;&lt;/a&gt;一、调度原理&lt;/h2&gt;&lt;p&gt;&amp;emsp;&amp;emsp;调度程序是内核的组成部分，它负责选择下一个要运行的进程。进程调度器可以看做是为处于就
      
    
    </summary>
    
      <category term="Linux内核" scheme="http://wanqbin.xyz/categories/Linux%E5%86%85%E6%A0%B8/"/>
    
    
      <category term="操作系统" scheme="http://wanqbin.xyz/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="Linux进程调度" scheme="http://wanqbin.xyz/tags/Linux%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6/"/>
    
      <category term="内核调度器" scheme="http://wanqbin.xyz/tags/%E5%86%85%E6%A0%B8%E8%B0%83%E5%BA%A6%E5%99%A8/"/>
    
      <category term="内核调度算法" scheme="http://wanqbin.xyz/tags/%E5%86%85%E6%A0%B8%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Linux进程调度——内核调度概述</title>
    <link href="http://wanqbin.xyz/2019/08/07/Linux%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6%E2%80%94%E2%80%94%E5%86%85%E6%A0%B8%E8%B0%83%E5%BA%A6%E6%A6%82%E8%BF%B0-1/"/>
    <id>http://wanqbin.xyz/2019/08/07/Linux进程调度——内核调度概述-1/</id>
    <published>2019-08-07T15:30:58.783Z</published>
    <updated>2019-08-07T15:34:40.575Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>vim的使用</title>
    <link href="http://wanqbin.xyz/2019/08/07/vim%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>http://wanqbin.xyz/2019/08/07/vim的使用/</id>
    <published>2019-08-07T12:24:00.000Z</published>
    <updated>2019-08-07T13:51:06.335Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、vim"><a href="#一、vim" class="headerlink" title="一、vim"></a>一、vim</h2><p><img src="/2019/08/07/vim的使用/1.PNG" alt="vim"></p><p>&emsp;&emsp;vim是从vi发展出来的一个文本编辑器。代码补全、编译及错误跳转等方便编程的功能特别丰富，在程序员中被广泛使用，和Emacs并列称为类Unix系统用户最喜欢的文本编辑器。</p><p>&emsp;vim的设计理念是命令的组合。用户学习了各种各样的文本间移动/跳转的命令和其他的普通模式的编辑命令，并且能够灵活使用的话，能够比那些没有模式的编辑器是更加高效地进行文本编辑。同时vim与很多快捷键设置和正则表达式类似，可以辅助记忆，并且vim针对程序员做了优化。</p><h2 id="二、vim的使用"><a href="#二、vim的使用" class="headerlink" title="二、vim的使用"></a>二、vim的使用</h2><ol><li><h4 id="光标移动"><a href="#光标移动" class="headerlink" title="光标移动"></a>光标移动</h4></li></ol><table><thead><tr><th>按键</th><th>动作</th></tr></thead><tbody><tr><td>k</td><td>上</td></tr><tr><td>j</td><td>下</td></tr><tr><td>h</td><td>左</td></tr><tr><td>l</td><td>右</td></tr><tr><td>0</td><td>到行首</td></tr><tr><td>shift+4（即$)</td><td>到行尾</td></tr><tr><td>gg</td><td>移动到文件头</td></tr><tr><td>G</td><td>移动到文件尾部</td></tr><tr><td>nG（n为行数）</td><td>移动到某一行</td></tr></tbody></table><ol start="2"><li><h4 id="删除内容"><a href="#删除内容" class="headerlink" title="删除内容"></a>删除内容</h4></li></ol><table><thead><tr><th>按键</th><th>动作</th></tr></thead><tbody><tr><td>x</td><td>删除光标所在字母</td></tr><tr><td>u</td><td>撤销</td></tr><tr><td>X</td><td>删除光标前面的内容</td></tr><tr><td>dw</td><td>从光标删除一个单词</td></tr><tr><td>d0</td><td>删除光标到行首</td></tr><tr><td>D</td><td>删除光标到行尾</td></tr><tr><td>dd</td><td>删除光标所在行</td></tr><tr><td>ndd</td><td>删除光标所在行开始n行</td></tr></tbody></table><ol start="3"><li><h4 id="复制粘贴与可视模式"><a href="#复制粘贴与可视模式" class="headerlink" title="复制粘贴与可视模式"></a>复制粘贴与可视模式</h4></li></ol><table><thead><tr><th>按键</th><th>动作</th></tr></thead><tbody><tr><td>yy</td><td>复制一行内容</td></tr><tr><td>dd</td><td>剪切一方内容</td></tr><tr><td>nyy</td><td>复制n行内容</td></tr><tr><td>p</td><td>粘贴到当前行</td></tr><tr><td>P</td><td>粘贴到上一行</td></tr><tr><td>r</td><td>替换一个字母（输入r之后，再输入一个字母）</td></tr></tbody></table><p>   可视模式：</p><ul><li><p>按v进入可视模式</p></li><li><p>移动光标选中内容</p></li><li><p>按y复制内容</p></li><li><p>移动光标到目的地</p></li><li><p>按p/P将内容粘贴</p></li></ul><ol start="4"><li><h4 id="查找-amp-格式调整-amp-查看"><a href="#查找-amp-格式调整-amp-查看" class="headerlink" title="查找&amp;格式调整&amp;查看"></a>查找&amp;格式调整&amp;查看</h4><p>内容查找：</p><ul><li>/要查找的字符或字符串</li><li>n/N进行遍历，向前或向后</li><li>?要查找的字符或字符串</li><li>光标移动到字符串上，按#也可以查找该字符串</li></ul><p>格式调整：</p><ul><li>gg=G 文件整体调整格式</li><li><code>&gt;&gt;</code>当前光标所在行右移一个Tab</li><li><code>&lt;&lt;</code>光标所在行左移一个Tab</li><li>n<code>&gt;&gt;</code>光标开始n行左移一个Tab</li></ul></li><li><h4 id="从命令模式到编辑模式"><a href="#从命令模式到编辑模式" class="headerlink" title="从命令模式到编辑模式"></a>从命令模式到编辑模式</h4><p>命令模式变为编辑模式：</p><ul><li><code>i</code>在光标前插入</li><li><code>a</code>在光标后插入</li><li><code>I</code>在行首插入</li><li><code>A</code>在行尾插入</li><li><code>o/O</code>在下一行或上一行插入</li><li><code>s</code>删除当前字母，进入插入模式</li><li><code>S</code>删除当前行，进入插入模式</li></ul></li><li><h4 id="末行查找替换与保存退出"><a href="#末行查找替换与保存退出" class="headerlink" title="末行查找替换与保存退出"></a>末行查找替换与保存退出</h4><p>末行模式：</p><ul><li><code>:s/被替换内容/替换内容</code>只替换当前行第一个匹配的“被替换内容”为“替换内容”</li><li><code>:s/被替换内容/替换内容/g</code>替换当前行所有的“被替换类同”为“替换内容”</li><li><code>:%s/被替换内容/替换内容</code>替换所有行的第一个匹配“被替换内容”为“替换内容”</li><li><code>:%s/被替换内容/替换内容/g</code>替换文件内所有的“被替换内容”为“替换内容”</li></ul><p>保存退出：</p><ul><li><code>wq</code>保存退出</li><li><code>:w</code>只保存</li><li><code>:q</code>只退出，文件不能修改</li><li><code>:q!</code>强退，不保存</li><li><code>:x</code>保存退出</li><li><code>ZZ</code>保存退出（命令模式下）</li></ul></li><li><h4 id="分屏"><a href="#分屏" class="headerlink" title="分屏"></a>分屏</h4><p><code>:sp filename</code>横分</p><p><code>:vsp filename</code>竖分</p><p><img src="/2019/08/07/vim的使用/2.PNG" alt="分屏——横分"></p><p><img src="/2019/08/07/vim的使用/3.PNG" alt="分屏——竖分"></p><p>退出：<br><code>:q</code>退出一个文件</p><p><code>:qall</code>全部文件退出</p><p><code>:wqall</code>全部保存退出</p><p>切换屏幕：</p><p>​    Ctrl+w+w</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、vim&quot;&gt;&lt;a href=&quot;#一、vim&quot; class=&quot;headerlink&quot; title=&quot;一、vim&quot;&gt;&lt;/a&gt;一、vim&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;/2019/08/07/vim的使用/1.PNG&quot; alt=&quot;vim&quot;&gt;&lt;/p&gt;
&lt;p&gt;&amp;ems
      
    
    </summary>
    
      <category term="Linux命令" scheme="http://wanqbin.xyz/categories/Linux%E5%91%BD%E4%BB%A4/"/>
    
    
      <category term="Ubuntu" scheme="http://wanqbin.xyz/tags/Ubuntu/"/>
    
      <category term="Linux" scheme="http://wanqbin.xyz/tags/Linux/"/>
    
      <category term="Vim" scheme="http://wanqbin.xyz/tags/Vim/"/>
    
  </entry>
  
  <entry>
    <title>Linux压缩解压命令及其他命令</title>
    <link href="http://wanqbin.xyz/2019/08/07/Linux%E5%8E%8B%E7%BC%A9%E8%A7%A3%E5%8E%8B%E5%91%BD%E4%BB%A4%E5%8F%8A%E5%85%B6%E4%BB%96%E5%91%BD%E4%BB%A4/"/>
    <id>http://wanqbin.xyz/2019/08/07/Linux压缩解压命令及其他命令/</id>
    <published>2019-08-07T11:43:00.000Z</published>
    <updated>2019-08-07T12:11:04.076Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、压缩解压命令"><a href="#一、压缩解压命令" class="headerlink" title="一、压缩解压命令"></a>一、压缩解压命令</h2><ol><li><h3 id="压缩解压命令：gzip"><a href="#压缩解压命令：gzip" class="headerlink" title="压缩解压命令：gzip"></a>压缩解压命令：<code>gzip</code></h3><ul><li><p>命令名称：gzip</p></li><li><p>命令英文原意：GUN zip</p></li><li><p>命令所在路径：/bin/gzip</p></li><li><p>执行权限：所有用户</p></li><li><p>语法：gzip [文件]</p></li><li><p>功能描述：压缩文件</p></li><li><p>压缩后文件格式：.gz</p></li><li><p>注意：</p><ul><li><p>gizp只能压缩文件，不能压缩目录</p></li><li><p>压缩之后不保留原文件</p></li></ul></li></ul><p><img src="/2019/08/07/Linux压缩解压命令及其他命令/1.PNG" alt="压缩解压命令"></p></li><li><h3 id="压缩解压命令：gunzip"><a href="#压缩解压命令：gunzip" class="headerlink" title="压缩解压命令：gunzip"></a>压缩解压命令：<code>gunzip</code></h3><ul><li><p>命令名称：gunzip</p></li><li><p>命令英文原意：GUN unzip</p></li><li><p>命令所在路径：/bin/gunzip</p></li><li><p>执行权限：所有用户</p></li><li><p>语法： gunzip [压缩文件]</p></li><li><p>功能描述： 解压缩.gz的压缩文件</p></li></ul><p><img src="/2019/08/07/Linux压缩解压命令及其他命令/2.PNG" alt="压缩解压命令"></p></li><li><h3 id="压缩解压命令：tar"><a href="#压缩解压命令：tar" class="headerlink" title="压缩解压命令：tar"></a>压缩解压命令：<code>tar</code></h3><ul><li><p>命令名称：tar</p></li><li><p>命令所在路径：/bin/tar</p></li><li><p>执行权限：所有用户</p></li><li><p>语法：tar 选项[-zcf] [压缩后文件名] [目录]</p><p>-c 打包</p><p>-v 显示详细信息</p><p>-f 指定文件名</p><p>-z 打包同时压缩</p></li><li><p>功能描述：打包目录</p></li><li><p>压缩后文件格式：<code>.tar.gz</code></p></li></ul><p><img src="/2019/08/07/Linux压缩解压命令及其他命令/3.PNG" alt="压缩解压缩命令"></p></li><li><h3 id="压缩解压缩命令：tar"><a href="#压缩解压缩命令：tar" class="headerlink" title="压缩解压缩命令：tar"></a>压缩解压缩命令：<code>tar</code></h3><ul><li><p>tar命令解压缩语法：</p><p>​    -x 解包</p><p>​    -v 显示详细信息</p><p>​    -f 指定解压文件</p><p>​    -z 解压缩</p></li></ul><p><img src="/2019/08/07/Linux压缩解压命令及其他命令/4.PNG" alt="压缩解压命令"></p></li><li><h3 id="压缩解压缩命令：zip"><a href="#压缩解压缩命令：zip" class="headerlink" title="压缩解压缩命令：zip"></a>压缩解压缩命令：<code>zip</code></h3><ul><li><p>命令名称：zip</p></li><li><p>命令所在路径：/usr/bin/zip</p></li><li><p>执行权限：所有用户</p></li><li><p>语法： zip 选项 [-r] [压缩后文件名] [文件或目录] </p><p>​     -r 压缩目录</p></li><li><p>功能描述：压缩文件或目录</p></li><li><p>压缩后文件格式：zip</p></li><li><p>压缩之后可以保留原文件</p></li></ul><p><img src="/2019/08/07/Linux压缩解压命令及其他命令/5.PNG" alt="压缩解压命令"></p></li><li><h3 id="压缩解压缩命令：unzip"><a href="#压缩解压缩命令：unzip" class="headerlink" title="压缩解压缩命令：unzip"></a>压缩解压缩命令：<code>unzip</code></h3><ul><li><p>命令名称：unzip</p></li><li><p>命令所在路径：/usr/bin/unzip</p></li><li><p>执行权限：所有用户</p></li><li><p>语法：unzip [压缩文件]</p></li><li><p>功能描述：解压.zip的压缩文件</p></li></ul><p><img src="/2019/08/07/Linux压缩解压命令及其他命令/6.PNG" alt="压缩解压命令"></p></li><li><h3 id="压缩解压缩命令：bzip2"><a href="#压缩解压缩命令：bzip2" class="headerlink" title="压缩解压缩命令：bzip2"></a>压缩解压缩命令：<code>bzip2</code></h3><ul><li><p>命令名称：bzip2</p></li><li><p>命令所在路径：/usr/bin/bzip2</p></li><li><p>执行权限：所有用户</p></li><li><p>语法：bzip2 选项[-k] [文件]</p><p>​    -k 产生压缩文件后保留原文件</p></li><li><p>功能描述：压缩文件</p></li><li><p>压缩后文件格式：.bz2</p></li><li><p>不能压缩目录</p></li></ul><p><img src="/2019/08/07/Linux压缩解压命令及其他命令/7.PNG" alt="压缩解压命令"></p></li><li><h3 id="压缩解压缩命令：bunzip2"><a href="#压缩解压缩命令：bunzip2" class="headerlink" title="压缩解压缩命令：bunzip2"></a>压缩解压缩命令：<code>bunzip2</code></h3><ul><li><p>命令名称：bunzip2</p></li><li><p>命令所在权限：所有用户</p></li><li><p>语法：bunzip2 选项[-k] [压缩文件]</p><p>​        -k 解压缩后保留原文件</p></li><li><p>功能描述：解压缩</p></li></ul><p><img src="/2019/08/07/Linux压缩解压命令及其他命令/8.PNG" alt="压缩解压命令"></p></li></ol><h2 id="二、用户管理命令"><a href="#二、用户管理命令" class="headerlink" title="二、用户管理命令"></a>二、用户管理命令</h2><ol><li><h3 id="用户管理命令：useradd"><a href="#用户管理命令：useradd" class="headerlink" title="用户管理命令：useradd"></a>用户管理命令：<code>useradd</code></h3><ul><li><p>命令名称：useradd</p></li><li><p>命令所在路径：/usr/sbin/useradd</p></li><li><p>执行权限：root</p></li><li><p>语法：useradd 用户名</p></li><li><p>功能描述：添加新用户</p></li></ul></li><li><h3 id="用户管理命令：passwd"><a href="#用户管理命令：passwd" class="headerlink" title="用户管理命令：passwd"></a>用户管理命令：<code>passwd</code></h3><ul><li><p>命令名称：passwd</p></li><li><p>命令所在路径：/usr/bin/passwd</p></li><li><p>执行权限：所有用户</p></li><li><p>语法：passwd 用户名</p></li><li><p>功能描述：设置用户密码</p></li></ul><p><img src="/2019/08/07/Linux压缩解压命令及其他命令/9.PNG" alt="用户管理命令"></p></li><li><h3 id="用户管理命令：who"><a href="#用户管理命令：who" class="headerlink" title="用户管理命令：who"></a>用户管理命令：<code>who</code></h3><ul><li><p>命令名称：who</p></li><li><p>命令所在路径：/usr/bin/who</p></li><li><p>执行权限：所有用户</p></li><li><p>语法：who</p></li><li><p>功能描述：查看登录用户信息</p></li></ul><p><img src="/2019/08/07/Linux压缩解压命令及其他命令/10.PNG" alt="用户管理命令"></p></li></ol><h2 id="三、帮助命令"><a href="#三、帮助命令" class="headerlink" title="三、帮助命令"></a>三、帮助命令</h2><ol><li><h3 id="帮助命令：man"><a href="#帮助命令：man" class="headerlink" title="帮助命令：man"></a>帮助命令：<code>man</code></h3><ul><li><p>命令名称：man</p></li><li><p>命令英文原意：mannual</p></li><li><p>命令所在路径：/usr/bin/man</p></li><li><p>执行权限：所有用户</p></li><li><p>语法： man [命令或配置文件]  //配置文件不写绝对路径</p></li><li><p>功能描述：获得帮助信息</p></li></ul><p><img src="/2019/08/07/Linux压缩解压命令及其他命令/11.PNG" alt="帮助命令"></p></li><li><h3 id="帮助命令：help"><a href="#帮助命令：help" class="headerlink" title="帮助命令：help"></a>帮助命令：<code>help</code></h3><ul><li><p>命令名称：help</p></li><li><p>命令所在路径：Shell内置命令</p></li><li><p>执行权限：所有用户</p></li><li><p>语法 ：help 命令</p></li><li><p>功能描述：获得shell 内置命令的帮助信息</p></li><li><p>范例：$help umask</p><p>​            查看umask命令的帮助信息</p></li></ul><p><img src="/2019/08/07/Linux压缩解压命令及其他命令/12.PNG" alt="帮助命令"></p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、压缩解压命令&quot;&gt;&lt;a href=&quot;#一、压缩解压命令&quot; class=&quot;headerlink&quot; title=&quot;一、压缩解压命令&quot;&gt;&lt;/a&gt;一、压缩解压命令&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;h3 id=&quot;压缩解压命令：gzip&quot;&gt;&lt;a href=&quot;#压缩解压命令：gz
      
    
    </summary>
    
      <category term="Linux命令" scheme="http://wanqbin.xyz/categories/Linux%E5%91%BD%E4%BB%A4/"/>
    
    
      <category term="Linux命令" scheme="http://wanqbin.xyz/tags/Linux%E5%91%BD%E4%BB%A4/"/>
    
      <category term="Ubuntu" scheme="http://wanqbin.xyz/tags/Ubuntu/"/>
    
      <category term="Linux压缩解压" scheme="http://wanqbin.xyz/tags/Linux%E5%8E%8B%E7%BC%A9%E8%A7%A3%E5%8E%8B/"/>
    
      <category term="Linux用户管理" scheme="http://wanqbin.xyz/tags/Linux%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86/"/>
    
      <category term="Linux帮助命令" scheme="http://wanqbin.xyz/tags/Linux%E5%B8%AE%E5%8A%A9%E5%91%BD%E4%BB%A4/"/>
    
  </entry>
  
  <entry>
    <title>Linux文件搜索命令</title>
    <link href="http://wanqbin.xyz/2019/08/07/Linux%E6%96%87%E4%BB%B6%E6%90%9C%E7%B4%A2%E5%91%BD%E4%BB%A4/"/>
    <id>http://wanqbin.xyz/2019/08/07/Linux文件搜索命令/</id>
    <published>2019-08-07T09:02:00.000Z</published>
    <updated>2019-08-07T11:19:13.674Z</updated>
    
    <content type="html"><![CDATA[<ol><li><p>文件搜索命令：<code>find</code></p><p>注意：搜索会占用大量服务器资源。</p><ul><li><p>命令名称：find</p></li><li><p>命令所在路径：/bin/find</p></li><li><p>执行权限：所有用户</p></li><li><p>语法：find [搜索范围] [匹配条件]</p></li><li><p>执行权限： 所有用户</p></li><li><p>语法：find [文件搜索] [匹配条件]</p></li><li><p>功能描述：文件搜索</p></li></ul><p><code>$find aokis -name cpp</code></p><p>在目录<code>aokis</code>中查找文件<code>cpp</code></p><p><img src="/2019/08/07/Linux文件搜索命令/1.PNG" alt="文件搜索命令"></p><p><code>$find aokis -size +1024</code></p><p>+n代表大于， -n代表小于， n 表示等于</p><p><img src="/2019/08/07/Linux文件搜索命令/2.PNG" alt="文件搜索命令"></p><p><code>$find aokis -user aoki</code></p><p>在目录<code>aokis</code>中查找所有者为<code>aoki</code>的文件</p><p><code>-group</code>为根据所属组查找</p><p><code>$find aokis -cmin -120</code></p><p>在目录aokis下查找120分钟内修改过的文件和目录。</p><p><img src="/2019/08/07/Linux文件搜索命令/4.PNG" alt="文件搜索命令"></p><p><code>-amin</code> 访问时间access</p><p><code>-cmin</code> 文件属性change，改变文件属性的时间</p><p><code>-mmin</code> 文件内modify,文件内容被改变</p><p><code>find aokis -size +0 -a -size -1024</code></p><p>在aokis目录下查找大于0，小于1024的文件</p><p><img src="/2019/08/07/Linux文件搜索命令/5.PNG" alt="文件搜索命令"></p><p><code>-a</code>两个条件同时满足</p><p><code>-o</code>两个条件满足任意一个即可。</p><p><code>$find aokis -name aoki -exec cat {} \;</code></p><p>在aokis下查找aoki文件，并对其进行查看操作</p><p><code>-exec/-ok 命令{}\</code>对搜索结果执行操作</p><p><code>-type</code>根据文件类型查找</p><ul><li><code>-f</code>文件 <code>-d</code>目录  <code>-l</code>软链接文件</li></ul><p><code>-inum</code>根据i结点查找</p><p><img src="/2019/08/07/Linux文件搜索命令/6.PNG" alt="文件搜索命令"></p></li><li><p>文件搜索命令：<code>locate</code></p><ul><li><p>命令名称：locate</p></li><li><p>命令所在路径：/usr/bin/locate</p></li><li><p>执行权限:所有用户</p></li><li><p>语法：locate 文件名</p></li><li><p>功能描述：在文件资料库中查找文件</p></li><li><p>updatedb 更新locate文件资料库</p></li><li><p>注意：</p><ul><li>/tmp临时文件并不在locate的文件资料库中</li><li>locate 严格区分大小写</li><li>locate -i 不严格区分大小写</li></ul></li></ul><p><img src="/2019/08/07/Linux文件搜索命令/7.PNG" alt="文件搜索命令"></p></li><li><p>文件搜索命令：<code>which</code></p><ul><li><p>命令名称：which</p></li><li><p>命令所在路径：/usr/bin/which</p></li><li><p>执行权限：所有用户</p></li><li><p>语法：which 命令</p></li><li><p>功能描述：搜索命令所在目录及别名信息</p></li></ul><p><img src="/2019/08/07/Linux文件搜索命令/8.PNG" alt="文件搜索命令"></p></li><li><p>文件搜索命令：<code>grep</code></p><ul><li><p>命令名称：grep</p></li><li><p>命令所在路径：/bin/grep</p></li><li><p>执行权限：所有用户</p></li><li><p>语法：grep -iv [指定字符串] [文件]</p></li><li><p>功能描述：在文件中搜寻字符串匹配的行并输出</p><p>​                    -i  不区分大小写</p><p>​                    -v  排除指定字串</p><p><img src="/2019/08/07/Linux文件搜索命令/9.PNG" alt="文件搜索命令"></p><p><img src="/2019/08/07/Linux文件搜索命令/10.PNG" alt="文件搜索命令"></p></li></ul></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;&lt;p&gt;文件搜索命令：&lt;code&gt;find&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;注意：搜索会占用大量服务器资源。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;命令名称：find&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;命令所在路径：/bin/find&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;执行
      
    
    </summary>
    
      <category term="Linux命令" scheme="http://wanqbin.xyz/categories/Linux%E5%91%BD%E4%BB%A4/"/>
    
    
      <category term="Linux命令" scheme="http://wanqbin.xyz/tags/Linux%E5%91%BD%E4%BB%A4/"/>
    
      <category term="Ubuntu" scheme="http://wanqbin.xyz/tags/Ubuntu/"/>
    
      <category term="Linux文件搜索" scheme="http://wanqbin.xyz/tags/Linux%E6%96%87%E4%BB%B6%E6%90%9C%E7%B4%A2/"/>
    
  </entry>
  
  <entry>
    <title>Linux链接命令及权限管理命令</title>
    <link href="http://wanqbin.xyz/2019/08/07/Linux%E9%93%BE%E6%8E%A5%E5%91%BD%E4%BB%A4%E5%8F%8A%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86%E5%91%BD%E4%BB%A4/"/>
    <id>http://wanqbin.xyz/2019/08/07/Linux链接命令及权限管理命令/</id>
    <published>2019-08-07T07:45:00.000Z</published>
    <updated>2019-08-07T08:26:16.332Z</updated>
    
    <content type="html"><![CDATA[<ol><li><h3 id="文件处理命令：ln"><a href="#文件处理命令：ln" class="headerlink" title="文件处理命令：ln"></a>文件处理命令：<code>ln</code></h3><ul><li><p>命令名称：ln</p></li><li><p>命令英文原意：link</p></li><li><p>命令所在路径：/bin/ln</p></li><li><p>执行权限：所有用户</p></li><li><p>语法：ln -s [原文件] [目标文件]</p><p>​            -s 创建软链接</p></li><li><p>功能描述：生成链接文件</p></li></ul><p><img src="/2019/08/07/Linux链接命令及权限管理命令/1.PNG" alt="链接命令"></p><p>软链接特征：类似于Windos快捷方式</p><ul><li><code>lrwxrwxrwx</code> l代表软链接</li><li>文件大小只是符号链接的大小</li><li>cpp.soft-&gt;aokis/cpp 指向源文件</li></ul><p>硬链接特征：</p><ul><li>相当于执行了‘cp -p’命令，复制了相同属性的文件，且硬链接可以同步更新</li><li>通过i结点识别</li><li>不能跨分区</li><li>不能针对目录使用</li></ul><p><img src="/2019/08/07/Linux链接命令及权限管理命令/2.PNG" alt="硬链接"></p></li><li><h3 id="权限管理命令：chmod"><a href="#权限管理命令：chmod" class="headerlink" title="权限管理命令：chmod"></a>权限管理命令：<code>chmod</code></h3><ul><li>命令名称：chmod</li><li>命令英文原意：<strong>ch</strong>ange the  permissions <strong>mod</strong>e of a file</li><li>命令所在路径：/bin/chmod</li><li>执行权限：所有用户</li><li>语法：chmod  [{ugoa} {+-=} {rwx}] [文件或目录]   a表示所有人   u 表示所有者 g表示所属组  o表示other，其他人</li></ul><p>​            [mode=421] [文件或目录]          </p><p>​            -R 递归修改</p><ul><li><p>功能描述：改变文件或目录权限</p></li><li><p>权限的数字表示：</p><p>r —-4</p><p>w —-2</p><p>x —–l</p><p>rwxrw-r–</p><p>7  6  4</p></li></ul></li></ol><table><thead><tr><th>代表字符</th><th>权限</th><th>对文件的含义</th><th>对目录的含义</th></tr></thead><tbody><tr><td>r</td><td>读权限</td><td>可以查看文件内容</td><td>可以列出目录中的内容</td></tr><tr><td>w</td><td>写权限</td><td>可以修改文件内容</td><td>可以在目录中创建、删除文件</td></tr><tr><td>x</td><td>执行权限</td><td>可以执行文件内容</td><td>可以进入目录</td></tr></tbody></table><p>   <img src="/2019/08/07/Linux链接命令及权限管理命令/3.PNG" alt="权限管理命令"></p><ol start="3"><li><h3 id="权限管理命令：useradd-amp-groupadd"><a href="#权限管理命令：useradd-amp-groupadd" class="headerlink" title="权限管理命令：useradd &amp; groupadd"></a>权限管理命令：<code>useradd &amp; groupadd</code></h3><p>添加用户：<code>useradd</code></p><p><img src="/2019/08/07/Linux链接命令及权限管理命令/4.PNG" alt="添加用户"></p><p>添加结果：</p><p><img src="/2019/08/07/Linux链接命令及权限管理命令/5.PNG" alt="添加结果"></p><p>添加组：</p><p><img src="/2019/08/07/Linux链接命令及权限管理命令/6.PNG" alt="添加组"></p></li><li><h3 id="权限管理命令：chown"><a href="#权限管理命令：chown" class="headerlink" title="权限管理命令：chown"></a>权限管理命令：<code>chown</code></h3><ul><li><p>权限管理命令：chown</p></li><li><p>命令名称：chown</p></li><li><p>命令英文原意：change  owership file</p></li><li><p>命令所在路径：/bin/chown</p></li><li><p>执行权限：所有用户</p></li><li><p>语法：chown [用户] [文件或目录]</p></li><li><p>功能描述：改变文件或目录的所有者</p></li></ul><p><img src="/2019/08/07/Linux链接命令及权限管理命令/7.PNG" alt="权限管理命令"></p></li><li><h3 id="权限管理命令：chgrp"><a href="#权限管理命令：chgrp" class="headerlink" title="权限管理命令：chgrp"></a>权限管理命令：<code>chgrp</code></h3><ul><li><p>权限管理命令：chgrp</p></li><li><p>命令名称：chgrp</p></li><li><p>命令英文原意：change file group ownership</p></li><li><p>命令所在路径：/bin/chgrp</p></li><li><p>执行权限：所有用户</p></li><li><p>语法：chgrp [用户组] [文件或目录]</p></li><li><p>功能描述：改变文件或目录的所属组</p></li></ul><p><img src="/2019/08/07/Linux链接命令及权限管理命令/8.PNG" alt="权限管理命令"></p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;&lt;h3 id=&quot;文件处理命令：ln&quot;&gt;&lt;a href=&quot;#文件处理命令：ln&quot; class=&quot;headerlink&quot; title=&quot;文件处理命令：ln&quot;&gt;&lt;/a&gt;文件处理命令：&lt;code&gt;ln&lt;/code&gt;&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;命令名称：ln&lt;/p&gt;
      
    
    </summary>
    
      <category term="Linux命令" scheme="http://wanqbin.xyz/categories/Linux%E5%91%BD%E4%BB%A4/"/>
    
    
      <category term="Ubuntu" scheme="http://wanqbin.xyz/tags/Ubuntu/"/>
    
      <category term="Linux" scheme="http://wanqbin.xyz/tags/Linux/"/>
    
      <category term="文件处理命令" scheme="http://wanqbin.xyz/tags/%E6%96%87%E4%BB%B6%E5%A4%84%E7%90%86%E5%91%BD%E4%BB%A4/"/>
    
  </entry>
  
  <entry>
    <title>Linux文件处理命令</title>
    <link href="http://wanqbin.xyz/2019/08/07/Linux%E6%96%87%E4%BB%B6%E5%A4%84%E7%90%86%E5%91%BD%E4%BB%A4/"/>
    <id>http://wanqbin.xyz/2019/08/07/Linux文件处理命令/</id>
    <published>2019-08-07T07:01:00.000Z</published>
    <updated>2019-08-07T07:29:18.560Z</updated>
    
    <content type="html"><![CDATA[<ol><li><h3 id="文件处理命令：touch"><a href="#文件处理命令：touch" class="headerlink" title="文件处理命令：touch"></a>文件处理命令：touch</h3><ul><li><p>命令名称：touch</p></li><li><p>命令所在路径：/bin/touch</p></li><li><p>执行权限：所有用户</p></li><li><p>语法：touh [文件名] </p></li><li><p>功能描述：创建空文件</p></li><li><p>范例：</p><p>​    touch program files //会在当前目录下创建两个文件，一个为program，另一个为files</p><p>​    创建一个文件 ：touch “program files” //不建议加空格</p><p><img src="/2019/08/07/Linux文件处理命令/1.PNG" alt="文件处理命令"></p></li></ul></li><li><h3 id="文件处理命令：cat"><a href="#文件处理命令：cat" class="headerlink" title="文件处理命令：cat"></a>文件处理命令：cat</h3><ul><li><p>文件处理命令：cat</p></li><li><p>命令名称：cat</p></li><li><p>命令所在路径：/bin/cat</p></li><li><p>执行权限：所有用户</p></li><li><p>语法：cat [文件名]</p></li><li><p>功能描述：显示文件内容</p><p>​                    -n 显示行号</p><p><img src="/2019/08/07/Linux文件处理命令/2.PNG" alt="文件处理命令"></p></li></ul></li><li><h3 id="文件处理命令：more"><a href="#文件处理命令：more" class="headerlink" title="文件处理命令：more"></a>文件处理命令：more</h3><ul><li><p>文件处理命令：more</p></li><li><p>命令名称：more</p></li><li><p>命令所在路径：/bin/more</p></li><li><p>执行权限：所有用户</p></li><li><p>语法：more [文件名]</p><p>​            (空格)或f   翻页</p><p>​        （Enter） 换行</p><p>​            q或Q         退出</p></li><li><p>功能描述：分页显示文件内容</p></li></ul><p><img src="/2019/08/07/Linux文件处理命令/3.PNG" alt="文件处理命令"></p></li><li><h3 id="文件处理命令：less"><a href="#文件处理命令：less" class="headerlink" title="文件处理命令：less"></a>文件处理命令：less</h3><ul><li>文件处理命令：less</li><li>命令名称：less</li><li>命令所在路径： /usr/bin/less</li><li>执行权限：所有用户</li><li>语法：less [文件名]</li><li>功能描述：分页显示文件内容 （可向上翻页）</li></ul></li><li><h3 id="文件处理命令：head"><a href="#文件处理命令：head" class="headerlink" title="文件处理命令：head"></a>文件处理命令：head</h3><ul><li><p>文件处理命令：head</p></li><li><p>命令名称：head</p></li><li><p>命令所在路径：/usr/bin/head</p></li><li><p>执行权限：所有用户</p></li><li><p>语法：head [文件名]</p></li><li><p>功能描述：显示文件前面几行</p><p>​                    -n 指定行数</p></li></ul><p><img src="/2019/08/07/Linux文件处理命令/4.PNG" alt="文件处理命令"></p></li><li><h3 id="文件处理命令：tail"><a href="#文件处理命令：tail" class="headerlink" title="文件处理命令：tail"></a>文件处理命令：tail</h3><ul><li><p>文件处理命令：tail</p></li><li><p>命令名称：tail</p></li><li><p>命令所在路径：/usr/bin/tail</p></li><li><p>执行权限：所有用户</p></li><li><p>语法： tail [文件名]</p></li><li><p>功能描述：显示文件后面几行</p><p>​                -n 指定行数</p><p>​                -f 动态显示文件末尾内容</p></li></ul><p><img src="/2019/08/07/Linux文件处理命令/5.PNG" alt="文件处理命令"></p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;&lt;h3 id=&quot;文件处理命令：touch&quot;&gt;&lt;a href=&quot;#文件处理命令：touch&quot; class=&quot;headerlink&quot; title=&quot;文件处理命令：touch&quot;&gt;&lt;/a&gt;文件处理命令：touch&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;命令名称：touch&lt;/
      
    
    </summary>
    
      <category term="Linux命令" scheme="http://wanqbin.xyz/categories/Linux%E5%91%BD%E4%BB%A4/"/>
    
    
      <category term="Linux命令" scheme="http://wanqbin.xyz/tags/Linux%E5%91%BD%E4%BB%A4/"/>
    
      <category term="Ubuntu" scheme="http://wanqbin.xyz/tags/Ubuntu/"/>
    
      <category term="Linux文件处理命令" scheme="http://wanqbin.xyz/tags/Linux%E6%96%87%E4%BB%B6%E5%A4%84%E7%90%86%E5%91%BD%E4%BB%A4/"/>
    
  </entry>
  
  <entry>
    <title>Linux目录及常用命令</title>
    <link href="http://wanqbin.xyz/2019/08/07/Linux%E7%9B%AE%E5%BD%95%E5%8F%8A%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    <id>http://wanqbin.xyz/2019/08/07/Linux目录及常用命令/</id>
    <published>2019-08-07T06:16:00.000Z</published>
    <updated>2019-08-07T06:45:48.272Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、Ubuntu各目录含义"><a href="#一、Ubuntu各目录含义" class="headerlink" title="一、Ubuntu各目录含义"></a>一、Ubuntu各目录含义</h2><table><thead><tr><th>目录名</th><th>作用</th></tr></thead><tbody><tr><td>/boot/</td><td>启动目录，保存系统启动相关文件</td></tr><tr><td>/boot/grub/</td><td>grub引导其器相关的配置文件</td></tr><tr><td>/dev/</td><td>设备文件保存位置。Linux中所有内容以文件形式保存，包括硬件。那么这个目录就是用来保存所有硬件设备文件的</td></tr><tr><td>/proc/</td><td>虚拟文件目录，该目录中的数据并不保存到硬盘当中，而是保存到内存中。主要保存系统同的内核、进程、外部设备状态和网络状态灯</td></tr><tr><td>/mnt/</td><td>挂载目录，系统建议用来挂载NFS服务的共享目录。只要是一个已经建立的空目录就可以作为挂载点。系统虽然准备了三个默认挂载点/media、/mnt、/misc，但是到底哪个目录挂载什么设备都可以由管理员自己决定。</td></tr><tr><td>/media/</td><td>挂载目录，系统建议用来挂载媒体设备的，例如光盘和软盘</td></tr><tr><td>/root/</td><td>超级用户的家目录。普通用户家目录在/home下，超级用户家目录直接在/下</td></tr><tr><td>/home/用户名/</td><td>普通用户的家目录，创建一个一般用户账号时，默认的用户主文件夹就在该目录下</td></tr><tr><td>/bin/</td><td>存放系统命令的目录，普通用户和超级用户都可以执行</td></tr><tr><td>/sbin/</td><td>保存和系统环境设置相关的命令，只有超级用户可以使用这些命令进行系统环境设置</td></tr><tr><td>/lib/</td><td>系统调用的函数库保存位置</td></tr><tr><td>/etc/</td><td>配置文件保存位置。</td></tr><tr><td>/etc/init.d/</td><td>System V分类风格的启动脚本</td></tr><tr><td>/etc/X11/</td><td>图形界面配置文件</td></tr><tr><td>/lost+found</td><td>包含了系统修复时的恢复文件</td></tr><tr><td>/sys/</td><td>虚拟文件系统。和/proc目录相似，都是保存在内存当中的，主要保存与内核相关信息</td></tr><tr><td>/usr</td><td>Unix Software Resouce,即Unix操作系统软件资源放在该目录，而不是用户的是数据</td></tr><tr><td>/usr/bin</td><td>用户可使用的大部分命令都放在这儿</td></tr><tr><td>/usr/include</td><td>存放C/C++等程序语言的头文件和目标文件</td></tr><tr><td>/usr/lib</td><td>包含各应用软件的函数库，目标文件</td></tr><tr><td>/usr/local</td><td>系统管理员在本机执行下载自行安装的软件</td></tr><tr><td>/var</td><td>动态数据保存位置。主要保存缓存，日志以及软件运行所产生的文件</td></tr><tr><td>/var/cache</td><td>应用缓存目录</td></tr><tr><td>/var/lib</td><td>存放程序执行过程中，需要使用到的数据文件</td></tr><tr><td>/var/lock</td><td>它是/run/lock目录的软链接，某些设备或文件一次只能被一个应用所使用</td></tr><tr><td>var/log</td><td>日志文件目录</td></tr></tbody></table><h2 id="二、Linux相关知识"><a href="#二、Linux相关知识" class="headerlink" title="二、Linux相关知识"></a>二、Linux相关知识</h2><ol><li>Linux严格区分大小写</li><li>Linux中所有内容以文件形式保存，包括硬件<ul><li>硬盘文件是/dev/sd[a-p]</li><li>光盘文件是/dev/sr0等</li></ul></li><li>Linux不靠扩展名区分文件类型<ul><li>压缩包：.gz、.bz、.tar、.bz2、.tgz</li><li>二进制软件包：.rpm</li><li>网页文件：.html、.php</li><li>脚本文件：.ssh</li><li>配置文件：.conf</li></ul></li><li>Linux所有的存储设备都必须挂载之后用户才能使用，包括硬盘，U盘，光盘。</li><li>Windows下的程序不能直接在Linux中安装和运行</li></ol><h2 id="三、Linux目录处理命令"><a href="#三、Linux目录处理命令" class="headerlink" title="三、Linux目录处理命令"></a>三、Linux目录处理命令</h2><ol><li><p>命令格式</p><p>命令格式： <code>命令 [-选项] [参数]</code></p><p>例如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls -la</span><br></pre></td></tr></table></figure><p>说明：</p><ul><li>个别命令使用不遵循此格式</li><li>当有多个选项时，可以写在一起</li><li>简化选项与完整选项 -a等于–all</li></ul></li><li><p>目录处理命令：ls</p><ul><li><p>命令名称：ls</p></li><li><p>命令英文原意：list</p></li><li><p>命令所在路径：/bin/ls</p></li><li><p>执行权限：所有用户</p></li><li><p>功能描述：显示目录文件夹</p></li><li><p>语法： ls 选项[-add] [文件或目录]</p><p>​            -a 显示所有文件，包括隐藏文件</p><p>​            -l详细信息显示</p><p>​            -d查看指定目录的详细信息</p><p>​            -i 查询任何一个文件的id</p><p><img src="/2019/08/07/Linux目录及常用命令/1.PNG" alt="目录处理命令"></p><p><img src="/2019/08/07/Linux目录及常用命令/2.PNG" alt="目录处理命令"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls -lh  #人性化显示</span><br></pre></td></tr></table></figure><p><img src="/2019/08/07/Linux目录及常用命令/3.%E4%BA%BA%E6%80%A7%E5%8C%96%E6%98%BE%E7%A4%BA.PNG" alt="人性化显示"></p></li></ul></li><li><p>目录处理命令：mkdir</p><ul><li><p>命令名称：mkdir</p></li><li><p>命令英文原意：make directories【目录】</p></li><li><p>命令所在路径:/bin/mkdir</p></li><li><p>执行权限：所有用户</p></li><li><p>语法：mkdir -p[目录名]</p></li><li><p>功能描述：创建新目录</p><p>​                    -p   递归创建</p><p><img src="/2019/08/07/Linux目录及常用命令/4.PNG" alt="目录处理命令mkdir"></p></li></ul></li><li><p>目录处理命令：cd</p><ul><li><p>命令名称：cd</p></li><li><p>命令英文原意：change directory</p></li><li><p>命令所在路径：shell内置命令</p></li><li><p>执行权限：所有用户</p></li><li><p>语法：cd [目录]</p></li><li><p>功能描述：切换目录</p></li></ul></li><li><p>目录处理命令：pwd</p><ul><li><p>目录处理命令：pwd</p></li><li><p>命令名称：pwd</p></li><li><p>命令英文原意：print working directory</p></li><li><p>命令所在路径：/bin/pwd</p></li><li><p>执行权限：所有用户</p></li><li><p>语法：pwd</p></li><li><p>功能描述：显示当前目录</p></li></ul><p><img src="/2019/08/07/Linux目录及常用命令/5.PNG" alt="目录处理命令"></p></li><li><p>目录处理命令：rmdir</p><ul><li><p>命令名称：rmdir</p></li><li><p>命令英文原意：remove empty directories</p></li><li><p>命令所在路径：/bin/rmdir</p></li><li><p>执行权限：所有用户</p></li><li><p>语法：rmdir [目录名]</p></li><li><p>功能：删除空目录</p></li></ul><p><img src="/2019/08/07/Linux目录及常用命令/6.PNG" alt="目录处理命令"></p><p>当目录非空时，使用rmdir无法删除目录。</p><p>将目录为空时，可以使用rmdir删除目录。这里删除了xiaoming目录下的文件，删除成功。</p><p><img src="/2019/08/07/Linux目录及常用命令/7.PNG" alt="目录处理命令"></p></li><li><p>目录处理命令：cp</p><ul><li><p>命令名称：cp</p></li><li><p>命令英文原意：copy</p></li><li><p>命令所在路径：/bin/cp</p></li><li><p>执行权限：所有用户</p></li><li><p>语法： cd -rp [原文件或目录] [目标目录]</p><p>​            -r 复制目录</p><p>​            -p 保留文件属性</p></li><li><p>功能：复制文件或目录</p><p>​            可以同时复制多个文件</p></li></ul><p><img src="/2019/08/07/Linux目录及常用命令/8.PNG" alt="目录处理命令"></p></li><li><p>目录处理命令：mv</p><ul><li><p>命令名称：mv</p></li><li><p>命令英文原意：move</p></li><li><p>命令所在路径：/bin/mv</p></li><li><p>执行权限：所有用户</p></li><li><p>语法：mv [原文件或目录] [目标目录]</p></li><li><p>功能描述：剪切文件、改名</p></li></ul><p><img src="/2019/08/07/Linux目录及常用命令/9.PNG" alt="目录处理命令"></p><p>上图所示操作将<code>/xiaohong/xiaoming</code>目录下的<code>my</code>目录剪切到了<code>/xiaohong</code>目录下，并改名为<code>aokis</code>。</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、Ubuntu各目录含义&quot;&gt;&lt;a href=&quot;#一、Ubuntu各目录含义&quot; class=&quot;headerlink&quot; title=&quot;一、Ubuntu各目录含义&quot;&gt;&lt;/a&gt;一、Ubuntu各目录含义&lt;/h2&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;目录名&lt;
      
    
    </summary>
    
      <category term="Linux命令" scheme="http://wanqbin.xyz/categories/Linux%E5%91%BD%E4%BB%A4/"/>
    
    
      <category term="Linux命令" scheme="http://wanqbin.xyz/tags/Linux%E5%91%BD%E4%BB%A4/"/>
    
      <category term="Ubuntu" scheme="http://wanqbin.xyz/tags/Ubuntu/"/>
    
      <category term="目录处理命令" scheme="http://wanqbin.xyz/tags/%E7%9B%AE%E5%BD%95%E5%A4%84%E7%90%86%E5%91%BD%E4%BB%A4/"/>
    
  </entry>
  
  <entry>
    <title>Linux进程管理（二）</title>
    <link href="http://wanqbin.xyz/2019/08/07/Linux%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <id>http://wanqbin.xyz/2019/08/07/Linux进程管理（二）/</id>
    <published>2019-08-07T03:44:00.000Z</published>
    <updated>2019-08-07T06:44:21.993Z</updated>
    
    <content type="html"><![CDATA[<h2 id="三、进程创建"><a href="#三、进程创建" class="headerlink" title="三、进程创建"></a>三、进程创建</h2><ol><li><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>&emsp;&emsp;在创建进程时，Windows等操作系统都提供了产生（spawn)进程的机制，即首先在新的地址空间里创建进程，读入可执行文件，最后开始执行。Linux采用了一种不同的方式，它把上述过程分解到两个单独的函数(fork()和exec())中去执行。</p><p>&emsp;&emsp;首先<code>fork()</code>函数通过复制当前进程创建一个子进程，子进程与父进程的唯一区别是<code>task_struct</code>不同；接着<code>exec()</code>函数负责读取可执行文件并将其载入地址空间开始运行。</p><p>&emsp;&emsp;在Linux中，除了<code>init</code>进程外，所有进程都是由其他进程创建的。为此，Linux提供了三个函数来创建一个新的进程，分别是<code>fork()</code>、<code>vfork()</code>和<code>clone()</code>,内核中提供了三个与它们相对应的系统调用，分别是<code>sys_fork()</code>、<code>sys_vfork()</code>和<code>sys_clone()</code>，而这三个系统调用其实最终都是通过调用一个叫做<code>do_fork()</code>函数来完成一个进程的创建的。</p></li><li><h3 id="写时复制"><a href="#写时复制" class="headerlink" title="写时复制"></a>写时复制</h3><p>&emsp;&emsp;在创建进程时，传统的<code>fork()</code>函数的系统调用直接把所有的资源复制到新创建的进程内存空间，这种实现过于简单并且效率低下，因为如果新进程打算立即执行新的映像，那么所有的复制都将是无用的。</p><p>&emsp;&emsp;为了克服这个缺点，Linux在创建进程时，采用“写时复制”（copy-on-write)技术，即指在创建进程时并不将父进程的所有资源都复制到子进程，而是在需要的时候才进行资源的复制，采用该方法可以大大提高Linux的系统性能。该技术之所以有时可以避免数据复制，是因为在产生子进程时，并不复制父进程的所有页面，而是置父进程所有页面的写时复制位，子进程共享父进程的所有页面，直到父进程或子进程写某个页面时，就会发生一个保护性错误，并复制该页面。也就是说资源的复制只有在需要写入的时候才进行，在这之前，只是以只读的方式共享。</p></li><li><h3 id="fork-、vfork-与clone"><a href="#fork-、vfork-与clone" class="headerlink" title="fork()、vfork()与clone()"></a>fork()、vfork()与clone()</h3><ul><li><p>fork()函数</p><p><code>fork()</code>函数调用一次返回两次：一次在父进程，一次在子进程。如果在子进程中，则返回0；如果在父进程中，则将返回子进程的<code>pid</code>。<code>fork()</code>函数通过系统调用<code>sys_fork()</code>来实现，<code>sys_fork()</code>函数的实现依赖于体系结构，因为它的参数需要系统寄存器来传递。</p><p>在x86体系结构下该函数定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">asminkage <span class="keyword">int</span> <span class="title">sys_fork</span><span class="params">(struct pt_regs regs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> do_fork(SIGCHILD,reg.esp,&amp;reg,<span class="number">0</span>,<span class="literal">NULL</span>,<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ol><ul><li><p>vfork()函数</p><p><code>vfork()</code>函数和<code>fork()</code>函数类似，但前者的父进程一直阻塞，直到子进程退出或者调用<code>exec()</code>函数。之所以引进该函数，是因为当时还没有引入“写时复制”技术，调用<code>fork()</code>来创建新的进程需要复制整个父进程的数据，在有些情况下，这样会降低系统的利用率，引入<code>vfork()</code>就是为了在创建进程时子进程不复制父进程的页表项。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">asmlinkage <span class="keyword">int</span> <span class="title">sys_vfork</span><span class="params">(struct pt_regs regs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> do_fork(CLONE_VFORK|CLONE_VM|SIGCHLD,regs.esp,&amp;regs,<span class="number">0</span>,<span class="literal">NULL</span>,<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>clone()函数</p><p><code>clone()</code>函数不同于<code>fork()</code>和<code>vfork()</code>函数，它接受一个指向函数的指针和该函数的参数，由<code>do_fork()</code>创建的子进程刚一创建就去调用这个函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">asmlinkage <span class="keyword">int</span> <span class="title">sys_clone</span><span class="params">(struct pt_regs regs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> clone_flags;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> newsp;</span><br><span class="line">    <span class="keyword">int</span> _user *parent_tidptr,*child_tidptr;</span><br><span class="line">    clone_flags=regs.ebx;</span><br><span class="line">    newsp=reg.ecx;</span><br><span class="line">    parent_tidptr=(<span class="keyword">int</span> _user *)regs.edx;</span><br><span class="line">    child_tidptr=(<span class="keyword">int</span> _user *)regs.edi;</span><br><span class="line">    <span class="keyword">if</span>(!newsp)</span><br><span class="line">        newsp=regs.esp;</span><br><span class="line">    <span class="keyword">return</span> do_fork(clone_flags,newsp,&amp;regs,<span class="number">0</span>,parent_tidptr,child_tidptr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>do_fork()函数</p><p>我们知道需要通过调用<code>fork()</code>、<code>vfork()</code>、<code>clone()</code>来创建进程，这三个函数调用相应的系统调用<code>sys_fork()</code>、<code>sys_vfork()</code>和<code>sys_clone()</code>，而这三个系统调用的区别在于调用<code>do_fork()</code>函数时设置的那些标志不同，该函数实现真正的进程创建。函数原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">do_fork</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> clone_flags,<span class="keyword">unsigned</span> <span class="keyword">long</span> stack_start,struct pt_regs *regs,<span class="keyword">unsigned</span> <span class="keyword">long</span> stack_size,<span class="keyword">int</span> _user *parent_tidptr,<span class="keyword">int</span> _user *child_tidptr)</span></span>;</span><br></pre></td></tr></table></figure><p>其中，参数<code>stack_start</code>表示栈的起始地址，参数<code>regs</code>表示存储所有寄存器的结构指针，参数<code>stack_size</code>表示栈的大小，参数<code>parent_tidptr</code>表示父进程的用户态变量<code>pid</code>地址，参数<code>child_tidptr</code>表示子进程的用户态变量<code>pid</code>地址，<code>clone_flags</code>表示<code>clone</code>标志位，包括<code>CLONE_VM</code>,<code>CLONE_FILES</code>,<code>CLONE_SIGHAND</code>,<code>CLONE_PID</code>,<code>CLONE_VFORK</code>等，任何一位被置1则表明创建的子进程和父进程共享该位对应的资源。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CSIGNAL                         0x000000ff <span class="comment">/*进程退出时需要传递的信号*/</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CLONE_VM                        0x00000100 <span class="comment">/*父子进程共享地址空间*/</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CLONE_FS                        0x00000200 <span class="comment">/*父子进程共享文件系统信息*/</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CLONE_FILES                     0x00000400 <span class="comment">/*父子进程共享已打开的文件*/</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CLONE_SIGHAND                   0x00000800 <span class="comment">/*父子进程共享信号处理*/</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CLONE_PTRACE                    0x00002000 <span class="comment">/*继续调试子进程*/</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CLONE_VFORK                     0x00004000 <span class="comment">/*调用vfork(),父进程休眠*/</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CLONE_PARENT                    0x00008000 <span class="comment">/*设置一个共有的父进程*/</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CLONE_THREAD                    0x00010000 <span class="comment">/*父子进程在同一个线程组*/</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CLONE_NEWNS                     0x00020000 <span class="comment">/*为子进程创建一个新的命名空间*/</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CLONE_SYSVSEM                   0x00040000 <span class="comment">/*父子进程共享system V SEM_UNDO*/</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CLONE_SETTLES                   0x00080000 <span class="comment">/*为子进程创建新的TLS*/</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CLONE_PARENT_SETTID             0x00100000 <span class="comment">/*设置父进程TID*/</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CLONE_CHILD_CLEARTID            0x00200000 <span class="comment">/*清除子进程TID*/</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CLONE_DETACHED                  0x00400000 <span class="comment">/*Unused,ignored*/</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CLONE_UNTRACED                  0x00800000 <span class="comment">/*不允许调试子进程*/</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CLONE_CHILD_SETTID              0x01000000 <span class="comment">/*设置子进程TID*/</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CLONE_STOPPED                   0x02000000 <span class="comment">/*设置进程停止状态*/</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CLONE_NEWUTS                    0x04000000 <span class="comment">/*创建新的utsname组*/</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CLONE_NEWIPC                    0x08000000 <span class="comment">/*创建新的IPC*/</span></span></span><br></pre></td></tr></table></figure></li></ul><h2 id="四、进程终止"><a href="#四、进程终止" class="headerlink" title="四、进程终止"></a>四、进程终止</h2><ol><li><h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><p>&emsp;&emsp;进程的终止方式有两种：<br>（1）正常结束，即在进程执行过程中调用<code>exit()</code>函数，或者在<code>main</code>函数中执行<code>return</code>语句，或者是main函数执行完，进程就正常结束了。<br>（2）异常结束，在进程运行过程中出现了错误或故障被迫结束。这类错误或故障有很多，常见的有：进程收到自己不能处理的一个信号，进程在内核执行期间可能产生一个异常，进程可能收到SIGABRT或其他终止信号等。</p><p>无论进程以哪一种方式终止，Linux内核并不是在进程终止的同时就将与进程相关的所有资源都释放掉，而是分为两步执行的：</p><ul><li>首先，通过调用<code>do_eait()</code>函数，释放掉与进程相关的大部分资源，并使进程处于ZMOBIE（僵死）状态，但此时进程描述符并没有释放。</li><li>然后，根据父进程是否终止，对子进程进行相应的处理。若子进程先于父进程终止了，则子进程会一直处于僵死状态直到父进程调用<code>wait()</code>或<code>waitpid()</code>，当父进程调用了<code>wait()</code>或<code>waitpid()</code>函数时，子进程的进程描述符和所有其独享的资源都将被释放掉；若父进程先于子进程终止，则内核必须首先为子进程找到一个新的父进程，方法是首先给子进程在当前进程组内找一个进程作为其父进程，如果该方法不行则让<code>init</code>进程作该进程的父进程。</li></ul><p>下面详细说明父进程是如何获得子进程死亡的消息以及内核是如何完成进程终止的第二步。</p><ul><li>当一个进程进入僵死状态后，尽管它已经不能再次被调度运行了，但是并不能将其马上就释放掉，而是应该保存其进程描述符，这样可以使得系统在子进程终止了的情况下仍然可以获得它的信息。</li><li>当子进程终止时，父进程会收到内核发送给它的SIGCHLD信号，父进程可以通过调用<code>wait()</code>函数来处理信号，<code>wait()</code>函数族有两个作用:获取子进程终止的消息和清除子进程的所有独享资源。<code>wait()</code>函数首先会挂起调用它的进程，直到该进程的一个子进程终止，此时，该函数会返回该子进程的pid给父进程。</li></ul></li><li><h3 id="do-exit-函数"><a href="#do-exit-函数" class="headerlink" title="do_exit()函数"></a>do_exit()函数</h3><p>&emsp;&emsp;在Linux中不管是以何种方式结束进程，最终都要调用内核函数<code>do_exit()</code>。该函数释放掉与该进程有关系的大多数资源（如果进程是这些资源的唯一使用者），进程运行该函数后将不再可以运行，处于<code>TASK_ZOMBIE</code>状态，此时进程占有的所有资源就是内核栈、<code>thread_info</code>结构和<code>task_struct</code>结构，用于向它的父进程提供信息。</p><p>&emsp;&emsp;<code>do_exit()</code>函数的大致处理流程：</p><ul><li>排除一些无效的特殊情况，即确保该进程不处于中断处理中，确保该进程不是<code>idle进程(pid=0)</code>。如果该进程正在被追踪并且设置了<code>PT_TRACE_EXIT</code>标志，就传递退出码并通知父进程。</li><li>对重读调用<code>do_exit</code>进行处理，并把进程的标志置为<code>PF_EXITING</code>，表明进程正在关闭。</li><li>如果进程审计功能开启，则记录进程的运行信息。</li><li>进程资源释放。例如，更新内存信息，然后调用<code>exit_mm()</code>函数释放进程所占用的内存，并释放<code>mm_struct</code>结构；调用<code>exit_sem()</code>函数把进程从任一IPC信号量中释放出来；调用<code>_exit_files()</code>函数释放分配给进程的所有文件，减少文件描述符的个数；调用<code>module_put()</code>函数减少模块的引用数。</li><li>调用<code>exit_notify()</code>函数向父进程发送信号，将子进程的父进程重新设置为线程组中的其他线程或者<code>init</code>进程，并把进程的状态设置为<code>TASK_ZOMBIE</code>状态。</li><li>最后调用<code>schedule()</code>函数切换到其他进程。</li></ul></li><li><h3 id="wait-函数"><a href="#wait-函数" class="headerlink" title="wait()函数"></a>wait()函数</h3><p>&emsp;&emsp;在调用了<code>do_exit()</code>函数之后，尽管进程已经僵死不能再运行了，但是系统还保留了它的进程描述符，系统可以通过<code>wait()</code>函数来获取进程信息。父进程可以选择调用<code>wait()</code>函数族中的4个函数之一。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pid_t</span> wait(<span class="keyword">int</span> *status);</span><br><span class="line"><span class="keyword">pid_t</span> waitpid(<span class="keyword">pid_t</span> pid,<span class="keyword">int</span> *status,<span class="keyword">int</span> options);</span><br><span class="line"><span class="keyword">pid_t</span> wait3(<span class="keyword">int</span> *status,<span class="keyword">int</span> options,struct rusage*rusage);</span><br><span class="line"><span class="keyword">pid_t</span> wait4(<span class="keyword">pid_t</span> pid,<span class="keyword">int</span> * status,<span class="keyword">int</span> options,struct rusage *rusage);</span><br></pre></td></tr></table></figure><p>每个函数又会调用系统调用<code>sys_wait4</code>，而<code>sys_wait4</code>只做一些错误检查，随后调用<code>do_wait()</code>函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">long</span> <span class="title">do_wait</span><span class="params">(<span class="keyword">pid_t</span> pid,<span class="keyword">int</span> options,struct signinfo _user *infop,<span class="keyword">int</span> _user *stat_addr,struct rusage _user *ru)</span></span>;</span><br></pre></td></tr></table></figure><p>其中参数<code>pid</code>表示目标进程的<code>pid</code>，<code>options</code>表示传递给该函数的标志，<code>infop</code>指向进程的信号信息的指针，<code>stat_addr</code>表示子进程退出状态应存放的地址，<code>ru</code>表示子进程资源使用信息应存放的地址。<code>do_wait()</code>函数的处理流程如下:</p><ul><li>把当前进程放到等待队列中，设置进程的状态为<code>TASK_INTERRUPRIBLE</code></li><li>检查进程的每个子进程的状态。如果进程正在睡眠、就绪或者运行，则什么都不做；如果进程停止或僵死，调用<code>wait_task_zombie()</code>函数，对僵死进程进行处理。</li><li>将进程的状态再一次置为<code>TASK_RUNNING</code>，从等待队列中删除该进程。</li></ul></li></ol><h2 id="五、线程的实现"><a href="#五、线程的实现" class="headerlink" title="五、线程的实现"></a>五、线程的实现</h2><ol><li><h3 id="用户线程"><a href="#用户线程" class="headerlink" title="用户线程"></a>用户线程</h3><p>&emsp;&emsp;线程的概念是现代操作系统中比较重要的一个概念，线程的引入实现了程序的并发执行，改善了资源的利用率，并提高了系统的吞吐量，通常情况下将线程看做是进程内的一个执行单元，一般定义为：线程是进程内的一个相对独立的、可独立调度和指派的执行单元。进程是资源管理的最小单位，线程时程序执行的最小单位。在操作系统设计上，从进程演化出线程，最主要的目的就是更好地支持SMP(对称多处理)以及减小（进程/线程）上下文切换开销。</p><p>&emsp;&emsp;在Linux中线程的实现比较特殊，它不像其他操作系统将进程与线程严格分开对待和处理，并在系统内核中提供专门的支持线程的机制，而是将系统中所有的线程都当作进程来实现的，在内核中没有准备一个特定的数据结构来表示线程，也没有为线程定义它们自己的调度策略，相反在Linux中线程仅仅是被看作一个与其他进程共享某些资源的进程。</p><p>&emsp;&emsp;正是由于Linux并没有将线程作为一个单独的对象来对待，在Linux中创建一个线程与一个进程非常相似，唯一的区别就是调用特定的函数的时候所传递的参数不同，在Linux中可以通过系统调用<code>clone()</code>来创建一个线程，它与创建进程的区别就在于调用<code>clone()</code>的时候需要传递一些参数来指定需要共享的资源。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clone(CLONE_VM|CLONE_FS|CLONE_FILES|CLONE_SIGHAND,<span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;上面的代码产生的结果和调用<code>fork()</code>差不多，只是“父子俩”共享地址空间、文件系统资源、文件描述符和信号处理程序。</p></li><li><h3 id="内核线程"><a href="#内核线程" class="headerlink" title="内核线程"></a>内核线程</h3></li></ol><p>&emsp;&emsp;内核经常需要在后台执行一些操作。这种任务可以通过内核线程完成——独立运行在内核空间的标准进程。内核线程和普通进程间的区别在于内核线程没有独立的地址空间，它们只是在内核空间运行，从来不切换到用户空间去。内核线程和普通进程一样，可以被调度，也可以被抢占。</p><p>&emsp;&emsp;Linux确实会把一些任务交给内核线程去做，像<code>pdflush</code>和<code>ksoftrqd</code>这些任务就是明显的例子。这些线程在系统启动时由另外一些内核线程启动。实际上，内核线程也只能由其他内核线程创建。内核通过<code>kernel_thread()</code>函数来创建内核线程，该函数的实现与体系结构有关。在x86体系结构中，该函数定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kernel_thread</span><span class="params">(<span class="keyword">int</span>(*fn)(<span class="keyword">void</span>*),<span class="keyword">void</span>* arg,<span class="keyword">unsigned</span> <span class="keyword">long</span> flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/*声明一个寄存器变量，并对其进行初始化*/</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pt_regs</span> <span class="title">regs</span>;</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;regs,<span class="number">0</span>,<span class="keyword">sizeof</span>(regs));</span><br><span class="line">    regs.ebx=(<span class="keyword">unsigned</span> <span class="keyword">long</span>)fn;</span><br><span class="line">    regs.edx=(<span class="keyword">unsigned</span> <span class="keyword">long</span>)arg;</span><br><span class="line">    regs.xds=_USER_DS;</span><br><span class="line">    regs.xes=_USER_DS;</span><br><span class="line">    regs.xfs=_KERNEL_PERCPU;</span><br><span class="line">    regs.orig_eax=<span class="number">-1</span>;</span><br><span class="line">    regs.eip=(<span class="keyword">unsigned</span> <span class="keyword">long</span>)kernel_thread_helper;</span><br><span class="line">    regs.xcs=_KERNEL_CS|get_kernel_rpl();</span><br><span class="line">    regs.eflags=x86_EFLAGS_IF|X86_EFLAGS_SF|X86_EFLAGS_PF|<span class="number">0X2</span>;</span><br><span class="line">    <span class="comment">/*调用do_fork()函数创建一个内核线程*/</span></span><br><span class="line">    <span class="keyword">return</span> do_fork(flags|CLONE_VM|CLONE_UNTRACED,<span class="number">0</span>,&amp;regs,<span class="number">0</span>,<span class="literal">NULL</span>,<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;三、进程创建&quot;&gt;&lt;a href=&quot;#三、进程创建&quot; class=&quot;headerlink&quot; title=&quot;三、进程创建&quot;&gt;&lt;/a&gt;三、进程创建&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;h3 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; tit
      
    
    </summary>
    
      <category term="Linux内核" scheme="http://wanqbin.xyz/categories/Linux%E5%86%85%E6%A0%B8/"/>
    
    
      <category term="Linux" scheme="http://wanqbin.xyz/tags/Linux/"/>
    
      <category term="Linux进程管理" scheme="http://wanqbin.xyz/tags/Linux%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/"/>
    
      <category term="Linux进程创建" scheme="http://wanqbin.xyz/tags/Linux%E8%BF%9B%E7%A8%8B%E5%88%9B%E5%BB%BA/"/>
    
      <category term="Linux进程终止" scheme="http://wanqbin.xyz/tags/Linux%E8%BF%9B%E7%A8%8B%E7%BB%88%E6%AD%A2/"/>
    
  </entry>
  
  <entry>
    <title>Linux进程管理（一）</title>
    <link href="http://wanqbin.xyz/2019/08/06/Linux%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>http://wanqbin.xyz/2019/08/06/Linux进程管理（一）/</id>
    <published>2019-08-06T12:31:00.000Z</published>
    <updated>2019-08-07T03:47:06.505Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、进程描述"><a href="#一、进程描述" class="headerlink" title="一、进程描述"></a>一、进程描述</h2><p>&emsp;&emsp;进程的定义：进程是可并发执行的程序在一个数据集合上的运行过程。进程具有动态性、并发性、独立性、异步性等基本特征。</p><p>&emsp;&emsp;为了使参与并发执行的每个程序（含数据）都能独立地运行，在操作系统中必须为之配置一个专门的数据结构，称为进程控制块（PCB）。系统利用PCB来描述进程的基本情况和活动过程，进而控制和管理进程。这样，由程序段、相关数据段和PCB三部分便构成了进程实体。进程的程序段就是该进程所对应静态程序实体在进程地址空间中的映像，而数据段就是进程数据工作集合在进程地址空间中的映像。</p><p>&emsp;&emsp;进程控制块是系统为了管理进程而设置的专门数据结构，用于记录进程的外部特征，描述进程的运动变化过程；它包含了有关进程的描述信息、控制信息以及资源信息，是进程动态特征的集中反映。因此，系统同利用PCB来控制和管理进程。PCB是系统感知进程存在的唯一标志，所以进程与PCB是一一对应的。也就是说，进程的创建以PCB的产生为标志，进程的消亡以PCB的删除为标志。</p><h3 id="1-Linux进程描述符"><a href="#1-Linux进程描述符" class="headerlink" title="1.Linux进程描述符"></a>1.Linux进程描述符</h3><p>&emsp;&emsp;在Linux中，PCB使用<code>task_struct</code>结构来描述，该结构定义在&lt;Linux/sched.h&gt;文件中，称为Linux进程描述符。该描述符结构<code>task_struct</code>存放在任务对内的双向链表<code>task_list</code>中，当有新的程序创建的时候，系统从内存中分配一个新的<code>task_struct</code>结构，并把它放到双向链表中，为了便于查找，系统用全局指针<code>current</code>指向当前运行进程的<code>task_struct</code>。</p><p>&emsp;&emsp;进程描述符<code>task_struct</code>结构包括了许多字段，下面按照字段进程管理过程中的不同作用，分为以下几类来介绍其中的基本功能。</p><ul><li>进程的基本属性</li><li>进程之间的关系</li><li>调度相关</li><li>进程地址空间</li><li>进程的文件系统信息</li><li>进程的信号处理</li><li>进程的访问权限</li><li>资源限制</li></ul><h4 id="1）进程的基本属性"><a href="#1）进程的基本属性" class="headerlink" title="1）进程的基本属性"></a>1）进程的基本属性</h4><ul><li><p><code>volatile long state</code></p><p>用于保存进程的状态，在进程的生命期内，可以从该域获得自己的状态，在2.6中进程可以有以下几种状态：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TASK_RUNNING 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TASK_INTERRUPTIABLE 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TASK_UNINTERRUPTIBLE 2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TASK_STOPPED 4</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TASK_TRACED 8</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EXIT_ZOMBIE 16</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EXIT_DEAD 32</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TASK_DEAD 64</span></span><br></pre></td></tr></table></figure><p><code>TASK_RUNNING</code>：进程当前正在运行，或者正在运行队列中等待调度</p><p><code>TASK_INTERRUPTIABLE</code>：进程处于睡眠状态，正在等待某些事件发生。进程可以被信号中断。进程被显式唤醒或接收到信号之后，将转变为<code>TASK_RUNNING</code>状态。</p><p><code>TASK_UNINTERRUPTIBLE</code>：进程状态类似<code>TASK_INTERRUPTIABLE</code>，只是它不会处理信号。中断处于这种状态的进程是不合适的，因为它可能正在完成某些重要的任务。当它所等待的事件发生时，进程将被唤醒。</p><p><code>TASK_STOPPED</code>：进程已中止执行，它没有运行，并且不能运行，接收到<code>SIGSTOP</code>和<code>SIGSTP</code>等信号时，进程将进入这种状态。接收到<code>SIGCONT</code>信号之后，进程将再次变得可运行。</p><p><code>TASK_TRACED</code>：正在被调试程序等其他进程监控时，进程将进入这种状态。</p><p><code>EXIT_ZOMBIE</code>:进程已终止，它正等待其父进程收集关于它的一些统计信息。</p><p><code>EXIT_DEAD</code>:最终状态，将进程从系统中删除时，它将会进入此状态，因为其父进程已经通过<code>wait4()</code>和<code>waitpid()</code>调用收集了所有统计信息。</p><p><code>TASK_DEAD</code>：表示已经退出且不需要父进程回收的进程的状态。</p><p><img src="/2019/08/06/Linux进程管理（一）/Linux.PNG" alt="Linux进程状态转换图"></p></li><li><p><code>atomic_t usage</code></p><p>表示对该结构的引用次数，在进程退出时，只有当对该结构的引用次数为0时，才可以删除该结构。</p></li><li><p><code>int lock_depth</code></p><p>表示大内核锁深度，主要用于实现内核的同步机制。</p></li><li><p><code>pid_t pid</code></p><p>进程标识符，系统通过进程标识符唯一地标识一个进程。<code>pid_t</code>是一个隐含类型，实际上就是一个int类型，为了与老版本的UNIX和Linux兼容，pid的最大默认值为32768(short int短整型数的最大值).如果需要更大的取值范围，可以修改<code>/proc/sys/kernel/pid_max</code>，从而提高进程数的上限。</p></li><li><p><code>struct pid_link pids[PIDTYPE_MAX]</code></p><p>标识该进程的pid所对应的哈希链表。</p></li><li><p><code>pid_t tgid</code></p><p>表示线程组的ID</p></li><li><p><code>unsigned int flags</code></p><p>定义了该进程的特殊属性，flags的值定义在Linux/sched.h中。</p></li><li><p><code>int exit_code, exit_signal</code></p><p>系统强行退出时发出的信号，父进程通过这两个值来获取子进程的退出状态。exit_code表示进程的退出值，exit_signal表示进程通过信号被终止的信号值。</p></li><li><p><code>struct Linux_binfmt *binfmt</code></p><p>Linux支持多种可执行文件格式，每种可执行文件格式都定义了一种数据结构，指明程序代码如何被载入内存。</p></li><li><p><code>unsigned int ptrace</code></p><p>当调用ptrace()系统调用时，prtace被设置，ptrace的值定义在linux/ptrace.h中。</p></li><li><p><code>char comm[TASK_COMM_LEN]</code></p><p>通常在命令行调用一个可执行程序来创建进程，当在命令行调用可执行程序的时候用comm表示其命令名称。</p></li></ul><h4 id="2）进程之间的关系"><a href="#2）进程之间的关系" class="headerlink" title="2）进程之间的关系"></a>2）进程之间的关系</h4><ul><li><p><code>struct task_struct *group_leader</code></p><p>每个进程组都有一个被定义为该组领头的进程，如果进程是某个组的成员，<code>group_leader</code>则是一个指向其组领头的进程描述符的指针，组领头进程拥有自己的终端设备<code>tty</code>，它就是从这个终端创建的。</p></li><li><p><code>struct list_head thread_group</code></p><p>指向该进程所在进程组的所有进程链表。</p></li><li><p><code>struct task_struct *real_parent</code></p><p>指向当前进程的父进程，如果父进程已经死亡，则指向init进程。</p></li><li><p><code>struct task_struct *parent</code></p><p>指向当前进程的父进程，这个值通常和<code>real_parent</code>相同，但在某些情况会和<code>real_parent</code>不同，例如使用gdb对程序进行调试时，parent指向gdb进程。</p></li><li><p><code>struct list_head children</code></p><p>指向当前进程的子进程的链表</p></li><li><p><code>struct list_head sibling</code></p><p>指向当前进程的兄弟进程的链表。</p></li></ul><p>&emsp;&emsp;Linux系统进程之间存在明显的继承关系，所有的进程都是init进程的后代，内核在系统启动的最后阶段启动此进程。系统中的每个进程都有一个父进程，相应地，每个进程可以拥有0个或多个子进程，拥有相同父进程的所有进程都成为兄弟。</p><h4 id="3）进程调度"><a href="#3）进程调度" class="headerlink" title="3）进程调度"></a>3）进程调度</h4><ul><li><p><code>int prio,static_prio,normal_prio</code></p><p>prio表示进程的动态优先级，取值范围[0,139]。根据进程prio取值的不同，可以把进程分为实时进程（prio$\in$[0,99])和非实时进程（普通进程，prio$\in$[100,139]),针对他们分别由不同的调度策略。动态优先级prio是调度器选择候选进程next的主要依据，数值越小，进程的优先级越高，越早被调度到。</p><p>static_prio是进程的静态优先级，取值范围[0,139]，进程刚被创建时从父进程继承而来，主要用于进程初始时间片的计算和动态优先级prio的计算。</p><p>normal_prio是常规动态优先级，使用“优先级继承协议”时，可能会临时提升进程的优先级，但提升后应该立即返回到其应有的优先级上。这个成员保存的正是这个“应有的优先级”。</p></li><li><p><code>struct list_head run_list</code></p><p>指向就绪队列<code>runqueue</code></p></li><li><p><code>const struct sched_class *sched_class</code></p><p>调度类，该调度类类似一个模块链，协助内核调度程序工作。每个调度程序模块需要实现<code>struct sched_class</code>建议的一组函数。</p></li><li><p><code>struct sched_entitu se</code></p><p>该结构包含了关于调度的完整信息，用于实现对于单个任务或任务组的调度，调度实体可能与进程没有关联。</p></li><li><p><code>undigned int policy</code></p><p>进程的调度策略。包括实时调度和非实时调度。</p></li><li><p><code>cpumask_t cpus_allowed</code></p><p>当存在多个处理器时，用它来指明该进程可以由哪个CPU来执行。</p></li><li><p><code>unsigned int time_slice</code></p><p>进程的时间片余额，相当于内核2.4的<code>counter</code>，但不再直接影响进程的动态优先级。</p></li><li><p><code>unsigned int rt_priority</code></p><p>实时进程的优先级，在调用<code>schedule()</code>时被更新，仅对实时进程有效。</p></li><li><p><code>unsigned long nvcsw,nivcsw</code></p><p>nvcsw，主动的上下文切换数，计算非基于内核抢占的上下文切换数。nivcsw，被动的上下文切换数，计算进程被内核抢占的次数，其值仅当进程从内核返回的时候才增加。</p></li></ul><h4 id="4）进程地址空间和文件系统"><a href="#4）进程地址空间和文件系统" class="headerlink" title="4）进程地址空间和文件系统"></a>4）进程地址空间和文件系统</h4><ul><li><p><code>struct mm_struct *mm,*active_mm</code></p><p>mm是一个指向地址空间和内存管理相关的信息，active_mm是一个指向最近最常使用的地址空间的指针。</p></li><li><p><code>struct fs_struct *fs,*files</code></p><p>fs保存了进程本身与VFS的关系信息，files包含了进程当前所打开的文件列表。</p></li></ul><h4 id="5）进程的信号管理"><a href="#5）进程的信号管理" class="headerlink" title="5）进程的信号管理"></a>5）进程的信号管理</h4><ul><li><p><code>sigset_t saved_sigmask</code></p><p>进程所能接收信号的位掩码。置位表示屏蔽，复位表示不屏蔽。</p></li><li><p><code>struct sigpending pending</code></p><p>存放进程中所有挂起的信号，即记录进程所有已经触发但是还未处理的信号</p></li><li><p><code>struct signal_struct *signal</code></p><p>指向进程信号的描述符</p></li><li><p><code>struct sughand_struct *sighand</code></p><p>指向信号的处理标识符</p></li><li><p><code>int pdeath_signal</code></p><p>是父进程死亡时设置的信号</p></li></ul><h4 id="6）进程的访问权限"><a href="#6）进程的访问权限" class="headerlink" title="6）进程的访问权限"></a>6）进程的访问权限</h4><ul><li><p><code>uid</code>和<code>gid</code></p><p>该进程的用户ID，通常是进程的创建者。因为每个用户可能属于多个组，所以还需要gid来表示该进程属于哪个用户组。</p></li><li><p><code>euid</code>和<code>egid</code></p><p>有效的<code>uid</code>和<code>gid</code>,处于系统安全权限的考虑，运行程序时要检查<code>euid</code>和<code>egid</code>的合法性。通常，uid等于euid，gid等于egid。有时候，系统会赋予一般用户暂时拥有root的uid和gid，以便于进行运作。</p></li><li><p><code>suid</code>和<code>sgid</code></p><p>根据POSIX标准引入的，在系统调用改变uid和gid时，用于保留真正的uid和gid</p></li><li><p><code>fsuid</code>和<code>fsgid</code></p><p>文件系统的uid和gid，用于对文件系统操作时的合法性检查，是Linux独特的标识类型。它们一般分别和euid和egid一致，但在NFS文件系统中NFS服务器需要一个特殊的进程访问文件，这时只修改客户进程的fsuid和fsgid以便确保对于该文件的访问权限。</p></li><li><p><code>struct group_info *group_info</code></p><p>一个Linux进程可以属于多个用户组，group_info保存与这些组相关的信息。</p></li></ul><h2 id="二、进程的组织形式"><a href="#二、进程的组织形式" class="headerlink" title="二、进程的组织形式"></a>二、进程的组织形式</h2><p>&emsp;&emsp;为了高效地对进程进行管理，内核中采用了不同的数据结构将系统中的进程通过不同方式组织起来，以满足进程管理子系统中各种不同需求。</p><ol><li><h3 id="进程链表"><a href="#进程链表" class="headerlink" title="进程链表"></a>进程链表</h3><p>Linux采用了双向链表将系统中的所有进程连接起来，该双向链表基于进程描述符中类型为<code>struct list_head</code>的成员变量<code>tasks</code>。</p><p>Linux内核提供了宏定义<code>for_each_process()</code>用于遍历系统中的每一个进程，该宏定义在需要对系统中每一个进程进行操作时非常有用。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> for_each_process(p)\</span></span><br><span class="line"><span class="keyword">for</span>(p=&amp;init_task;(p=next_task(p))!=&amp;init_task;)</span><br></pre></td></tr></table></figure><p>其中，init_task是系统初始化过程中创建的第一个进程的进程描述符，宏定义next_task表示链表的下一个进程。</p></li></ol><table><thead><tr><th>函数原型</th><th>说明</th></tr></thead><tbody><tr><td>next_task(p)</td><td>当前进程p的下一进程</td></tr><tr><td>add_task(p)</td><td>从p的父进程孩子链表中添加该进程</td></tr><tr><td>remove_task(p)</td><td>从p的父进程孩子链表中删除该进程</td></tr></tbody></table><ol start="2"><li><h3 id="哈希链表"><a href="#哈希链表" class="headerlink" title="哈希链表"></a>哈希链表</h3><p>&emsp;&emsp;内核中使用一个进程描述符来表示一个进程，因此通过进程描述符的地址来访问一个进程再方便不过了。但是POSIX规范中规定，每一个进程要有进程号，而且POSIX规范中规定的系统调用<code>kill()</code>是基于进程号向其他进程发送信号的。这就需要一种机制来高效地完成从进程号到进程描述符地址的转换。Linux内核引入了哈希表来完成进程号到进程描述符<code>task_struct</code>结构的映射。</p><p>&emsp;&emsp;根据进程类型的不同以及效率上的考虑，内核设置了<code>PIDTYPE_MAX</code>（默认值为3）个不同用途的哈希表，哈希表的类型使用枚举类型<code>pid_type</code>进行定义。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> pid_type</span><br><span class="line">&#123;</span><br><span class="line">PIDTYPE_PID,</span><br><span class="line">PIDTYPE_PGID,</span><br><span class="line">PIDTYPE_SID,</span><br><span class="line">PIDTYPE_MAX</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;其中，PIDTYPE_PID代表了进程号（Process ID）哈希表，系统中所有进程（包括线程）的进程号都在该哈希表中有相应的存储位置。PIDTYPE_PGID代表了进程组号（Process）哈希表。PIDTYPE_SID代表了会话号（Session ID）哈希表。</p><p>&emsp;&emsp;为了查找哈希表，需要知道进程号（pid）与哈希表中位置之间的映射函数——哈希函数，定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pid_hashfn(nr,ns)</span></span><br><span class="line">Hash_long((<span class="keyword">unsigned</span> <span class="keyword">long</span>)nr+(<span class="keyword">unsigned</span> <span class="keyword">long</span>)ns,pidhash_shift)</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;其中nr表示进程的pid，ns表示进程的pid命名空间结构<code>pid_namespace</code>,<code>pidhash_shift</code>表示哈希表的大小（1&lt;&lt;pidhash_shift).</p><p>&emsp;&emsp;Linux把通过哈希函数计算得到的哈希值作为数组pid_Hash的下标，并且把哈希值相同的进程组成哈希链表，我们称该链表为哈希链表的主链表。链表中的每个哈希结点（hlist_node结构）表示进程的pid。</p><h4 id="1-相关的数据结构"><a href="#1-相关的数据结构" class="headerlink" title="(1)相关的数据结构"></a>(1)相关的数据结构</h4><p>&emsp;&emsp;随着在Linux内核2.6.24中引入了pid命名空间，结构pid被分割成结构pid和结构upid，其定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">upid</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> nr;<span class="comment">/*pid值*/</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pid_namespace</span> *<span class="title">ns</span>;</span><span class="comment">/*所在的命名空间*/</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hlist_node</span> <span class="title">pid_chain</span>;</span><span class="comment">/*哈希链表节点*/</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pid</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">atomic_t</span> count;<span class="comment">/*引用计数*/</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hlist_head</span> <span class="title">tasks</span>[<span class="title">PIDTYPE_MAX</span>];</span><span class="comment">/*保存所有使用此pid的进程*/</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rcu_head</span> <span class="title">rcu</span>;</span><span class="comment">/*读写锁*/</span></span><br><span class="line">    <span class="keyword">int</span> level;<span class="comment">/*包含upid结构的个数*/</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">upid</span> <span class="title">numbers</span>[1];</span><span class="comment">/*包含的upid结构*/</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在pid结构中，包含一个struct hlist_head类型的成员变量tasks，该变量把具有相同pid值的进程联系起来，如同一个进程组的进程拥有相同的进程组号pgid，此时可以将同一个进程组的进程通过该变量联系起来，我们称该链表尾哈希链表的从链表。</p><p>&emsp;&emsp;在进程描述符<code>task_struct</code>中存在成员变量pids，定义如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pid_link</span> <span class="title">pids</span>[<span class="title">PIDTYPE_MAX</span>];</span></span><br></pre></td></tr></table></figure><p>该成员变量的数据类型<code>pid_link</code>的定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pid_link</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hlist_nnode</span> <span class="title">node</span>;</span><span class="comment">/*从哈希表节点*/</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pid</span> *<span class="title">pid</span>;</span><span class="comment">/*进程对应的pid结构*/</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>该结构是表示进程描述符<code>task_struct</code>与结构<code>pid</code>之间的映射关系。使用这个变量可以根据pid结构找出对应的描述符。</p></li></ol><h4 id="2-哈希表相关的操作"><a href="#2-哈希表相关的操作" class="headerlink" title="(2)哈希表相关的操作"></a>(2)哈希表相关的操作</h4><ul><li><p><code>find_pid()</code>函数根据nr的值，利用哈希函数计算其哈希值，从哈希表pid_Hash中找出哈希链表头节点，然后遍历整个链表，找出哈希值为nr的pid结构。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct pid* <span class="title">find_pidd</span><span class="params">(<span class="keyword">int</span> nr)</span></span>;<span class="comment">/*nr表示进程的pid值*/</span></span><br></pre></td></tr></table></figure></li></ul><ul><li><p><code>pid_task()</code>函数根据pid返回其对应的进程描述符地址</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct task_struct *fastcall <span class="title">pid</span><span class="params">(struct pid* pid,<span class="keyword">enum</span> pid_type type)</span></span>;<span class="comment">/*参数type表示pid的类型*/</span></span><br></pre></td></tr></table></figure></li></ul><ul><li><p><code>transfer_pid()</code>函数使用新的继承描述符new替换旧的进程描述符</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> fastcall <span class="title">transfer_pid</span><span class="params">(struct task_struct *old,struct task_struct *<span class="keyword">new</span> ,<span class="keyword">enum</span> pid_type type)</span></span>;</span><br></pre></td></tr></table></figure></li></ul><ul><li><p><code>attach_pid()</code>函数建立进程描述符task与结构pid之间的映射关系，并将pid添加到相应的哈希链表的开头。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> fastcall <span class="title">attach_pid</span><span class="params">(struct task_struct *task,<span class="keyword">enum</span> pid_type,struct pid* pid)</span></span>;</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>当进程被销毁时需要将进程在哈希表中的映射关系解除，这一过程通过函数<code>detach_pid()</code>完成。该函数首先解除进程描述符与哈希链表的映射关系，然后检查pid结构中是否还包含别的进程，如果不是，则释放pid结构。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> fastcall <span class="title">detach_pid</span><span class="params">(struct task_struct *task,<span class="keyword">enum</span> pid_type type)</span></span>;</span><br></pre></td></tr></table></figure></li></ul><ol start="3"><li><h3 id="等待队列"><a href="#等待队列" class="headerlink" title="等待队列"></a>等待队列</h3><p>&emsp;&emsp;当进程等待一个外部事件发生时，就把它从运行队列中删除并放到等待队列上。</p><p>&emsp;&emsp;在Linux内核中，使用<code>wait_queue_t</code>结构的双向链表来表示一个等待队列。在每个等待队列链表中，以<code>wait_queue_head_t</code>结构表示等待队列的表头，<code>wait_queue_t</code>表示等待队列中的每一个节点，它记录了等待进程所需要的所有信息。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">wait_queue_head</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">spinlock_t</span> lock;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">task_list</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _ <span class="title">wait_queue_head</span> <span class="title">wait_queue_head_t</span>;</span></span><br></pre></td></tr></table></figure><p><code>lock</code>用于保护该等待队列中数据的一致性。</p><p><code>task_list</code>表示睡眠在该等待队列上的所有进程构成的链表的表头</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _ <span class="title">wait_queue</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> flags;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> WQ_FLAG_EXCLUSIVE 0X01</span></span><br><span class="line">    <span class="keyword">void</span> *<span class="keyword">private</span>;</span><br><span class="line">    <span class="keyword">wait_queue_func_t</span> func;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">task_list</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _ <span class="title">wait_queue</span> <span class="title">wait_queue_t</span>;</span></span><br></pre></td></tr></table></figure><p>flags:它指示了该结点对应进程的环形方式，取值为<code>WQ_FLAG_EXCLUSIVE</code>或0；<code>WQ_FLAG_EXCLUSIVE</code>表示节点对应进程对临界区资源使用是排他性的，即进程是独占式进程。</p><p>private:一个私有数据指针，通常保存了睡眠进程的进程描述符task_struct的地址</p><p>func:存放函数的一个结构，这个函数用于唤醒等待队列上的进程。这个域的默认值为<code>default_wake_function()</code>函数，该函数负责将变量private指示的进程设置为可运行状态并插入到合适的运行队列中。</p></li><li><h3 id="当前进程"><a href="#当前进程" class="headerlink" title="当前进程"></a>当前进程</h3><p>&emsp;&emsp;Linux关于进程管理的大部分代码都需要获得或设置当前进程的信息，因此，是否能快速、高效地找到当前进程的描述符task_struct对系统的性能有很大的影响。Linux内核2.2开始采用了宏定义<code>current</code>来获取当前进程的描述符。硬件体系结构把不同，该宏的定义也不同，它必须针对专门的硬件体系结构作处理。有的硬件体系结构可以拿出一个专门的寄存器来存放指向当前进程描述符task_struct的指针，而像x86这样的体系由于寄存器并不富余，就只能在当前内核栈的尾端创建<code>thread_info</code>结构，通过计算偏移间接地查找task_struct结构。</p><p>&emsp;&emsp;在x86体系结构中，每个进程拥有一个内核栈，且通过寄存器<code>%esp</code>即可访问内核栈的元素。基于这种思想，内核首先将当前进程的地址以及需要快速访问的其他状态标记记录在数据结构<code>struct thread info</code>中，然后将该数据结构保存到内核栈空间中的最低地址位置。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">union</span> thread_union</span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">thread_info</span> <span class="title">thread_info</span>;</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="built_in">stack</span>[THREAD_SIZE/<span class="keyword">sizeof</span>(<span class="keyword">long</span>)];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>从该结构中可以看出，内核栈<code>stack</code>和数据结构<code>thread_info</code>共享同一块内存。</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、进程描述&quot;&gt;&lt;a href=&quot;#一、进程描述&quot; class=&quot;headerlink&quot; title=&quot;一、进程描述&quot;&gt;&lt;/a&gt;一、进程描述&lt;/h2&gt;&lt;p&gt;&amp;emsp;&amp;emsp;进程的定义：进程是可并发执行的程序在一个数据集合上的运行过程。进程具有动态性、并发性
      
    
    </summary>
    
      <category term="Linux内核" scheme="http://wanqbin.xyz/categories/Linux%E5%86%85%E6%A0%B8/"/>
    
    
      <category term="Linux" scheme="http://wanqbin.xyz/tags/Linux/"/>
    
      <category term="Linux内核" scheme="http://wanqbin.xyz/tags/Linux%E5%86%85%E6%A0%B8/"/>
    
      <category term="Liinux进程管理" scheme="http://wanqbin.xyz/tags/Liinux%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>关于Linux内核</title>
    <link href="http://wanqbin.xyz/2019/08/06/%E5%85%B3%E4%BA%8ELinux%E5%86%85%E6%A0%B8/"/>
    <id>http://wanqbin.xyz/2019/08/06/关于Linux内核/</id>
    <published>2019-08-06T06:55:00.000Z</published>
    <updated>2019-08-07T03:47:13.725Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、Linux内核特征"><a href="#一、Linux内核特征" class="headerlink" title="一、Linux内核特征"></a>一、Linux内核特征</h2><p>&emsp;&emsp;&emsp;Linux操作系统的内核稳定而高效，以独占的方式执行最底层任务，保证其他程序的正常运行。它是整个系统的核心，具有独特的性质。</p><ol><li><h3 id="接口特色"><a href="#接口特色" class="headerlink" title="接口特色"></a>接口特色</h3><p>&emsp;&emsp;按照POSIX标准，一个可以运行UNIX程序的系统就是UNIX。Linux系统提供和一般UNIX系统相同的标准界面，包括程序级和用户级的界面。</p><p>&emsp;&emsp;在程序级，Linux系统提供标准的UNIX函数库，一个在Linux下开发的应用程序，几乎不经过任何改动就可以在其他UNIX系统下编译执行，完成同样的功能。</p><p>&emsp;&emsp;Linux系统对用户同时提供图形和文本用户界面，文本界面是shell接口，图形界面是X-Window系统。UNIX下的基本命令在Linux下的功能和使用方式都完全相同。而最早在UNIX平台开发的图形用户界面X-Window系统，在Linux系统下运行良好并可以展示与其他版本UNIX系统下相同甚至更好的效果。</p></li><li><h3 id="功能特色"><a href="#功能特色" class="headerlink" title="功能特色"></a>功能特色</h3><p>&emsp;&emsp;Linux系统可以支持多种硬件设备。Linux系统下的驱动程序开发和Windows系统相比简单得多。</p><p>&emsp;&emsp;Linux自身使用的专用的文件系统为Ext3，可以提供方便有效的文件共享及保护机制。同时，它可以通过虚拟文件系统的技术，支持包括微软系列操作系统所使用的FAT16、FAT32和NTFS等文件系统在内的几十种现有的文件系统。</p><p>&emsp;&emsp;Linux系统具有内置的TCP/IP协议栈，可以提供各种高效的网络功能，包括基本的进程间通信、网络文件服务等。</p></li><li><h3 id="结构特征"><a href="#结构特征" class="headerlink" title="结构特征"></a>结构特征</h3><p>&emsp;&emsp;Linux内核基本采用模块结构，单内核模式，这使得系统具有很高的运行效率，但系统的可扩展性及移植性会受到一定的影响。为了解决这个问题，Linux使用了附加模块技术。利用模块技术，可以方便地在内核中添加新的组件或卸载不再需要的内核组件，而且这种装载和卸载可以动态进行。</p><p>&emsp;&emsp;内核模块的引入也带来了对系统性能、内存利用和系统稳定性的一些影响，可动态装卸的模块需要系统增加额外的资源来记录、管理，而装入的内核模块和其他内核部分一样，具有相同的访问权限，差的内核模块会导致系统不稳定甚至崩溃，一些恶意的内核模块可能对系统安全造成极大的威胁。</p><p>&emsp;&emsp;总的来说，Linux内核基本采用模块式结构构造，同时加入动态的模块技术，在追求系统整体效率的同时，实现了内核的动态可伸缩性。这样的结构给系统移植带来一定的负面影响。</p></li></ol><h2 id="二、Linux内核体系结构"><a href="#二、Linux内核体系结构" class="headerlink" title="二、Linux内核体系结构"></a>二、Linux内核体系结构</h2><p>&emsp;&emsp;Linux内核主要由5个模块构成，分别是进程调度模块、内存管理模块、虚拟文件系统模块、进程间通信模块和网络接口模块。</p><p><img src="/2019/08/06/关于Linux内核/1.Linux%E5%86%85%E6%A0%B8%E5%AD%90%E7%B3%BB%E7%BB%9F%E5%8F%8A%E5%85%B6%E5%85%B3%E7%B3%BB.PNG" alt="Linux内核子系统及其关系"></p><p>&emsp;（1）进程调度模块：进程调度模块程序是内核的重要组成部分，它选择下一个要运行的进程并负责控制进程对CPU资源的使用，调度程序采用一种策略使各个进程能够公平合理地访问CPU，同时保证内核能够实时地执行必要的硬件操作。</p><p>&emsp;（2）内存管理模块：内存管理模块负责管理系统，用于确保所有进程能够安全地共享计算机的内存，同时，内存管理模块还支持虚拟内存，使得Linux能够支持进程使用比实际内存空间更大的内存地址空间。</p><p>&emsp;（3）虚拟文件系统模块：虚拟文件系统（VFS）模块通过向所有的外部存储设备提供一个通用的文件接口，隐藏了各种硬件的不同细节，从而提供并支持与其他操作系统兼容的多种文件系统。Linux最好的特征之一就是它支持多种文件系统，用户不仅可以从它自己的文件系统如Ext2，Ext3，ReiserFS等查看文件，而且可以从与其他操作相关的文件系统插卡文件。对用户来说，从一种文件系统到另一种文件系统就没有任何差异，只要是Linux支持的文件系统类型，用户就可以很方便地将它安装到Linux系统中使用。</p><p>&emsp;（4）进程间通信模块：进程间通信模块主要负责进程之间如何进行信息交换或共享信息等工作，Linux提供了多种进程之间的通信机制，其中信号和管道是最基本的两种。除此之外，Linux还提供了System V特有的进程间通信机制，包括消息队列，信号量，共享内存等，为了支持网络通信，Linux还引入了套接字（Socket）机制。</p><p>&emsp;（5）网络接口模块：网络接口模块提供对多种网络通信标准的访问并支持许多网络硬件，网络接口分为网络协议和网络驱动程序，其中网络协议部分负责实现网络传输协议，网络驱动程序部分负责与硬件设备的通信。</p><p>&emsp;（6）进程调度与内存管理模块之间的关系：这两个子系统互相依赖。在多道程序环境下，程序要运行必须为之创建进程，而创建进程的第一件事情就是将程序和数据装入内存。</p><p>&emsp;（7）进程间通信与内存管理之间的关系：进程间通信子系统要依赖内存管理支持共享内存机制，这种机制允许两个进程除了拥有自己的私有空间，还可以存取共同的内存区域。</p><p>&emsp;（8）虚拟文件系统与网络接口和内存管理之间的关系：虚拟文件系统利用网络接口支持网络文件系统（NFS），也利用内存管理支持RAMDISK设备。</p><p>&emsp;（9）内存管理与虚拟文件系统之间的关系：内存管理利用虚拟文件系统支持交换，交换进程(swapd)定期由调度程序调度，这也是内存管理依赖于进程调度的唯一原因。当一个进程存取的内存映射被换出时，内存管理向文件系统发出请求，同时，挂起当前正在运行的进程。</p><h2 id="三、单内核与微内核"><a href="#三、单内核与微内核" class="headerlink" title="三、单内核与微内核"></a>三、单内核与微内核</h2><p>&emsp;&emsp;微内核（MicroKernel Kernel）:在微内核中，大部分内核都作为独立的进程在特权状态下运行，它们通过消息传递进行通信。在典型情况下，每个概念模块都有一个进程。因此，如果在设计中有一个系统调用模块，那么就必然有一个相应的进程来接收系统调用，并和能够执行系统调用的其他进程（或模块）通信以完成所需任务。</p><p>&emsp;&emsp;微内核设计的一个优点是在不影响系统其他部分的情况下，更高效地实现代替现有的文件系统模块的工作将会更加容易。我们甚至可以在系运行时将开发出的新系统模块或者需要替换现有模块的模块直接而且迅速地加入系统。另外一个优点是不需要的模块将不会被加载到内存中，因此微内核就可以更有效地利用内存。</p><p>&emsp;&emsp;单内核（Monolithic kernel):单内核是一个很大的进程。它的内部又可以被分为若干模块（或者是层次或其他）。但是在运行的时候，它是一个独立的二进制大映像。其模块间的通信是通过直接调用其他模块中的函数实现的，而不是消息传递。</p><p>&emsp;&emsp;单内核的支持者声称微内核的消息传递开销引起了效率的损失，微内核的支持者则认为因此而增加的内核设计的灵活性和可维护性可以弥补任何损失。</p><p>&emsp;&emsp;Linux是一个单内核结构，也就是说，Linux运行在单独的内核地址空间。同时吸收了微内核的优点：模块化设计，支持动态装载内核模块。Linux还避免了微内核设计上的缺陷，让一切都运行在内核态，直接调用函数，无需消息传递。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、Linux内核特征&quot;&gt;&lt;a href=&quot;#一、Linux内核特征&quot; class=&quot;headerlink&quot; title=&quot;一、Linux内核特征&quot;&gt;&lt;/a&gt;一、Linux内核特征&lt;/h2&gt;&lt;p&gt;&amp;emsp;&amp;emsp;&amp;emsp;Linux操作系统的内核稳定而高
      
    
    </summary>
    
      <category term="Linux内核" scheme="http://wanqbin.xyz/categories/Linux%E5%86%85%E6%A0%B8/"/>
    
    
      <category term="Linux" scheme="http://wanqbin.xyz/tags/Linux/"/>
    
      <category term="微内核" scheme="http://wanqbin.xyz/tags/%E5%BE%AE%E5%86%85%E6%A0%B8/"/>
    
      <category term="单内核" scheme="http://wanqbin.xyz/tags/%E5%8D%95%E5%86%85%E6%A0%B8/"/>
    
      <category term="操作系统" scheme="http://wanqbin.xyz/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>map容器</title>
    <link href="http://wanqbin.xyz/2019/08/03/map%E5%AE%B9%E5%99%A8/"/>
    <id>http://wanqbin.xyz/2019/08/03/map容器/</id>
    <published>2019-08-03T08:42:00.000Z</published>
    <updated>2019-08-03T09:07:30.397Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、map容器概述"><a href="#一、map容器概述" class="headerlink" title="一、map容器概述"></a>一、map容器概述</h2><p>&emsp;&emsp;map的特性是，所有元素都会根据元素的键值被自动排序。map所有元素都是<code>pair</code>，同时拥有实值(value)和键值(key)。pair的第一元素被视为键值，第二元素被视为实值。map并不允许两个元素拥有相同的键值。</p><p>&emsp;&emsp;我们不可以通过map的迭代器改变map的键值，因为map的键值关系到map元素的排列规则，任意改变map键值将会严重破坏map组织。如果想要修改元素的实值，是可以的。</p><p>&emsp;&emsp;map和list拥有相同的某些性质，当对它的容器元素进行新增操作或者删除操作时，操作之前的所有迭代器，在操作完成之后依然有效，当然被删除的那个元素的迭代器必然是个例外。</p><p>&emsp;&emsp;multimap和map的操作类似，唯一区别是multimap键值可重复。</p><p>&emsp;&emsp;map和multimap都是以RB-tree为底层机制。又由于map所开放的各种操作接口，RB-tree也都提供了，所以几乎所有map操作行为的，都只是转调用RB-tree的操作行为而已。</p><h2 id="二、map-multimap容器常用API"><a href="#二、map-multimap容器常用API" class="headerlink" title="二、map/multimap容器常用API"></a>二、map/multimap容器常用API</h2><ul><li>map构造函数</li></ul>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">map</span>&lt;T1,T2&gt; mapTT;<span class="comment">//map默认构造函数</span></span><br><span class="line"><span class="built_in">map</span>(<span class="keyword">const</span> <span class="built_in">map</span>&amp;<span class="built_in">map</span>);<span class="comment">//拷贝构造函数</span></span><br></pre></td></tr></table></figure><ul><li>map赋值操作</li></ul>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">map</span>&amp;<span class="keyword">operator</span>=(<span class="keyword">const</span> <span class="built_in">map</span>&amp;mp);<span class="comment">//重载等号操作符</span></span><br><span class="line">swap(mp);<span class="comment">//交换两个集合容器</span></span><br></pre></td></tr></table></figure><ul><li>map大小操作</li></ul>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">size();<span class="comment">//返回容器中元素的数目</span></span><br><span class="line">empty();<span class="comment">//判断容器是否为空</span></span><br></pre></td></tr></table></figure><ul><li>map插入数据元素操作</li></ul>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">map</span>.insert(<span class="number">1</span>);<span class="comment">//往容器中插入元素，返回pair&lt;iterator,bool&gt;</span></span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>,<span class="built_in">string</span>&gt;mapStu;<span class="comment">//通过pair方式插入对象</span></span><br><span class="line">mapStu.insert(pair&lt;<span class="keyword">int</span>,<span class="built_in">string</span>&gt;(<span class="number">3</span>,<span class="string">"Aoki"</span>));<span class="comment">//通过pair方式插入对象</span></span><br><span class="line">mapStu.insert(make_pair(<span class="number">-1</span>,<span class="string">"Aoki"</span>));<span class="comment">//通过value_type的方式插入对象</span></span><br><span class="line">mapStu.insert(<span class="built_in">map</span>&lt;<span class="keyword">int</span>,<span class="built_in">string</span>&gt;::value_type(<span class="number">1</span>,<span class="string">"Aoki"</span>));</span><br><span class="line">mapStu[<span class="number">3</span>]=<span class="string">"Aoki"</span>;</span><br><span class="line">mapStu[<span class="number">5</span>]=<span class="string">"青木"</span>;</span><br></pre></td></tr></table></figure><ul><li>map删除操作</li></ul>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">clear();<span class="comment">//删除所有元素</span></span><br><span class="line">erase(pos);<span class="comment">//删除pos迭代器所指元素，返回下一个元素的迭代器</span></span><br><span class="line">erase(beg,end);<span class="comment">//删除区间[beg,end)的所有元素，返回下一个元素的迭代器</span></span><br><span class="line">erase(keyElem);<span class="comment">//删除容器中key为keyElem的对组</span></span><br></pre></td></tr></table></figure><ul><li>map查找操作</li></ul>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">find(key);<span class="comment">//查找键key是否存在，若存在，返回该键的元素的迭代器，若不存在，返回map.end()</span></span><br><span class="line">count(keyElem);<span class="comment">//返回容器中key为keyElem的对组个数。对于map来说，要么是0，要么是1，对于multimap来说，值可能大于1</span></span><br><span class="line">lower_bound(keyElem);<span class="comment">//返回第一个key&gt;=keyElem元素的迭代器</span></span><br><span class="line">upper_bound(keyElem);<span class="comment">//返回第一个key&gt;keyElem元素的迭代器</span></span><br><span class="line">equal_range(keyElem);<span class="comment">//返回容器中key与keyElem相等的上下限的两个迭代器</span></span><br></pre></td></tr></table></figure><h2 id="三、map容器示例"><a href="#三、map容器示例" class="headerlink" title="三、map容器示例"></a>三、map容器示例</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt; m1;</span><br><span class="line">m1.insert(make_pair(<span class="number">1</span>, <span class="string">"张三"</span>));</span><br><span class="line">m1.insert(make_pair(<span class="number">2</span>, <span class="string">"李四"</span>));</span><br><span class="line">m1.insert(pair&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt;(<span class="number">3</span>, <span class="string">"李五"</span>));</span><br><span class="line">m1.insert(<span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt;::value_type(<span class="number">4</span>, <span class="string">"张六"</span>));</span><br><span class="line">m1[<span class="number">5</span>] = <span class="string">"张四"</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt;::iterator it = m1.begin(); it != m1.end(); it++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"ID:"</span> &lt;&lt; it-&gt;first &lt;&lt; <span class="string">"  姓名："</span> &lt;&lt; it-&gt;second &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (m1.empty())</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"map为空"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"size="</span> &lt;&lt; m1.size() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果：</p><p><img src="/2019/08/03/map容器/test01.PNG" alt="执行结果"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;m2;</span><br><span class="line">m2.insert(make_pair(<span class="number">1</span>, <span class="number">10</span>));</span><br><span class="line">m2.insert(make_pair(<span class="number">2</span>, <span class="number">50</span>));</span><br><span class="line">m2.insert(make_pair(<span class="number">3</span>, <span class="number">40</span>));</span><br><span class="line">m2.insert(make_pair(<span class="number">4</span>, <span class="number">60</span>));</span><br><span class="line">m2.insert(make_pair(<span class="number">5</span>, <span class="number">10</span>));</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;::iterator it1 = m2.begin(); it1 != m2.end(); it1++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"key:"</span> &lt;&lt; (*it1).first &lt;&lt; <span class="string">" value:"</span> &lt;&lt; (*it1).second &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">m2.erase(<span class="number">3</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;::iterator it1 = m2.begin(); it1 != m2.end(); it1++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"key:"</span> &lt;&lt; (*it1).first &lt;&lt; <span class="string">" value:"</span> &lt;&lt; (*it1).second &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (m2.find(<span class="number">5</span>) != m2.end())</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"找到了"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"ID:"</span> &lt;&lt; m2.find(<span class="number">5</span>)-&gt;first &lt;&lt; <span class="string">" value:"</span> &lt;&lt; m2.find(<span class="number">5</span>)-&gt;second &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"没有找到"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;::iterator pos = m2.lower_bound(<span class="number">4</span>);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"ID:"</span> &lt;&lt; pos-&gt;first &lt;&lt; <span class="string">" value:"</span> &lt;&lt; pos-&gt;second &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;::iterator pos1 = m2.upper_bound(<span class="number">4</span>);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"ID:"</span> &lt;&lt; pos-&gt;first &lt;&lt; <span class="string">" value:"</span> &lt;&lt; pos-&gt;second &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">pair&lt;<span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;::iterator, <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;::iterator&gt;ret = m2.equal_range(<span class="number">4</span>);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"ID:"</span> &lt;&lt; ret.first-&gt;first &lt;&lt; <span class="string">" value:"</span> &lt;&lt; ret.first-&gt;second &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"ID:"</span> &lt;&lt; ret.second-&gt;first &lt;&lt; <span class="string">" value:"</span> &lt;&lt; ret.second-&gt;second &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果：</p><p><img src="/2019/08/03/map容器/test02.PNG" alt="执行结果"></p><h2 id="四、multimap示例"><a href="#四、multimap示例" class="headerlink" title="四、multimap示例"></a>四、multimap示例</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test03</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">multimap</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;mulmap;</span><br><span class="line">mulmap.insert(make_pair(<span class="number">1</span>, <span class="number">15</span>));</span><br><span class="line">mulmap.insert(make_pair(<span class="number">1</span>, <span class="number">20</span>));</span><br><span class="line">mulmap.insert(make_pair(<span class="number">1</span>, <span class="number">25</span>));</span><br><span class="line">mulmap.insert(make_pair(<span class="number">1</span>, <span class="number">5</span>));</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">multimap</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;::iterator it0 = mulmap.begin(); it0 != mulmap.end(); it0++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"ID："</span> &lt;&lt; it0-&gt;first &lt;&lt; <span class="string">"  value:"</span> &lt;&lt; it0-&gt;second &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"键值为1的对组的个数："</span> &lt;&lt; mulmap.count(<span class="number">1</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果：</p><p><img src="/2019/08/03/map容器/test03.PNG" alt="执行结果"></p><h2 id="五、源码地址"><a href="#五、源码地址" class="headerlink" title="五、源码地址"></a>五、源码地址</h2><p>​            <a href="https://github.com/Aoki-Wang/CheckStation/tree/master/STL/map" target="_blank" rel="noopener">map示例源码</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、map容器概述&quot;&gt;&lt;a href=&quot;#一、map容器概述&quot; class=&quot;headerlink&quot; title=&quot;一、map容器概述&quot;&gt;&lt;/a&gt;一、map容器概述&lt;/h2&gt;&lt;p&gt;&amp;emsp;&amp;emsp;map的特性是，所有元素都会根据元素的键值被自动排序。map
      
    
    </summary>
    
      <category term="STL" scheme="http://wanqbin.xyz/categories/STL/"/>
    
    
      <category term="STL" scheme="http://wanqbin.xyz/tags/STL/"/>
    
      <category term="map容器" scheme="http://wanqbin.xyz/tags/map%E5%AE%B9%E5%99%A8/"/>
    
      <category term="multimap" scheme="http://wanqbin.xyz/tags/multimap/"/>
    
      <category term="C++" scheme="http://wanqbin.xyz/tags/C/"/>
    
  </entry>
  
</feed>

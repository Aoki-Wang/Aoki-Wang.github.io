<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Aoki&#39;s Blog</title>
  
  <subtitle>“吾生也有涯，而知无涯”</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://wanqbin.xyz/"/>
  <updated>2019-11-18T16:53:22.208Z</updated>
  <id>http://wanqbin.xyz/</id>
  
  <author>
    <name>Aoki</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Git的基本操作</title>
    <link href="http://wanqbin.xyz/2019/11/19/Git%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/"/>
    <id>http://wanqbin.xyz/2019/11/19/Git的基本操作/</id>
    <published>2019-11-18T16:48:00.000Z</published>
    <updated>2019-11-18T16:53:22.208Z</updated>
    
    <content type="html"><![CDATA[<h2 id="第一阶段-初始化"><a href="#第一阶段-初始化" class="headerlink" title="第一阶段:初始化"></a>第一阶段:初始化</h2><p>想要让git对一个目录进行版本控制需要以下步骤：</p><ul><li><p>进入要管理的文件夹</p></li><li><p>执行初始化命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git init</span><br></pre></td></tr></table></figure></li><li><p>管理目录下的文件状态</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git status</span><br><span class="line"><span class="meta">#</span> 注：新增的文件和修改过后的文件都是红色</span><br></pre></td></tr></table></figure></li><li><p>管理指定文件（红变绿）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git add 文件名</span><br><span class="line">git add . #添加当前文件夹下的全部文件</span><br></pre></td></tr></table></figure></li><li><p>个人信息配置：用户名，邮箱【一次即可】</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.email "Your Email"</span><br><span class="line">git config --global user.name "Your Name"</span><br></pre></td></tr></table></figure></li><li><p>生成版本</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit -m '描述信息'</span><br></pre></td></tr></table></figure></li><li><p>查看版本记录</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git log</span><br></pre></td></tr></table></figure></li></ul><h2 id="第二阶段：扩展新功能"><a href="#第二阶段：扩展新功能" class="headerlink" title="第二阶段：扩展新功能"></a>第二阶段：扩展新功能</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git add .</span><br><span class="line">git commmit -m 'message'</span><br></pre></td></tr></table></figure><h2 id="第三阶段：回滚"><a href="#第三阶段：回滚" class="headerlink" title="第三阶段：回滚"></a>第三阶段：回滚</h2><ul><li><p>回滚至之前的版本</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git log</span><br><span class="line">git reset --hard 版本号</span><br></pre></td></tr></table></figure></li><li><p>回滚至之后的版本</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git reflog</span><br><span class="line">git reset --hard 版本号</span><br></pre></td></tr></table></figure></li></ul><h2 id="第四阶段：分支-amp-修改"><a href="#第四阶段：分支-amp-修改" class="headerlink" title="第四阶段：分支&amp;修改"></a>第四阶段：分支&amp;修改</h2><ul><li><p>分支</p><p>分支可以给使用者提供多个环境，意味着你可以把你的工作从开发主线上分离开来，以免影响开发主线</p></li><li><p>修改方案</p><p><img src="/2019/11/19/Git的基本操作/git分支.PNG" alt="git分支"></p></li><li><p>查看分支</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch</span><br></pre></td></tr></table></figure></li><li><p>创建分支</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch 分支名</span><br></pre></td></tr></table></figure></li><li><p>切换分支</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout 分支名</span><br></pre></td></tr></table></figure></li><li><p>分支合并（可能产生冲突）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git merge 要合并的分支</span><br><span class="line"><span class="meta">#</span>注：切换分支再合并，</span><br></pre></td></tr></table></figure></li><li><p>删除分支</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -d 分支名称</span><br></pre></td></tr></table></figure></li></ul><h2 id="第五阶段：GitHub"><a href="#第五阶段：GitHub" class="headerlink" title="第五阶段：GitHub"></a>第五阶段：GitHub</h2><ul><li><p>在家里上传代码</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git remote add origin 远程仓库地址   #给远程仓库起名字</span><br><span class="line">git push -u origin 分支  #推送代码</span><br></pre></td></tr></table></figure></li><li><p>到公司新电脑上第一次获取代码</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git clone #远程仓库地址</span><br><span class="line">git checkout 分支 #切换分支</span><br></pre></td></tr></table></figure></li><li><p>在公司进行开发</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">git checkout dev  #切换到dev分支进行开发</span><br><span class="line">git merge master #把master分支合并到dev（仅一次）</span><br><span class="line"><span class="meta">#</span>修改代码</span><br><span class="line"><span class="meta">#</span>提交代码</span><br><span class="line">git add .</span><br><span class="line">git commit -m 'xxx'</span><br><span class="line">git push origin dev</span><br></pre></td></tr></table></figure></li><li><p>回家继续写代码</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span>切换到dev分支进行开发</span><br><span class="line">git checkout dev</span><br><span class="line"><span class="meta">#</span>拉代码</span><br><span class="line">git pull origin dev</span><br><span class="line"><span class="meta">#</span>继续开发</span><br><span class="line"><span class="meta">#</span>提交代码</span><br><span class="line"></span><br><span class="line">git add .</span><br><span class="line">git commit -m 'xx'</span><br><span class="line">git push origin dev</span><br></pre></td></tr></table></figure></li><li><p>开发完毕，要上线</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span>将dev分支合并到master，进行上线</span><br><span class="line">git checkout master</span><br><span class="line">git merge dev</span><br><span class="line">git push origin master</span><br><span class="line"><span class="meta">#</span>把dev分支也推送到远程</span><br><span class="line">git checkout dev</span><br><span class="line">git merge master</span><br><span class="line">git push origin dev</span><br></pre></td></tr></table></figure></li></ul>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git pull origin dev</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>等同于下面的两行代码</span><br><span class="line">git fetch origin dev</span><br><span class="line">git merget origin/dev</span><br></pre></td></tr></table></figure><ul><li><p>保持代码提交整洁(变基）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rebase 分支</span><br></pre></td></tr></table></figure></li><li><p>记录图形展示</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git log --graph --preey=format:"%h %s"</span><br></pre></td></tr></table></figure><h3 id="快速解决冲突"><a href="#快速解决冲突" class="headerlink" title="快速解决冲突"></a>快速解决冲突</h3></li></ul><ol><li><p>安装beyond compare</p></li><li><p>在git中配置</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git config --locla merge.tool bc3  #--local说明只在当前项目中有效</span><br><span class="line">git config --local mergetool.path '/usr/local/bin/bcomp'</span><br><span class="line">git config --local mergetool.keepBackup false</span><br></pre></td></tr></table></figure></li><li><p>应用beyond compare解决冲突</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git mergetool  #启动beyond compare</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;第一阶段-初始化&quot;&gt;&lt;a href=&quot;#第一阶段-初始化&quot; class=&quot;headerlink&quot; title=&quot;第一阶段:初始化&quot;&gt;&lt;/a&gt;第一阶段:初始化&lt;/h2&gt;&lt;p&gt;想要让git对一个目录进行版本控制需要以下步骤：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;进入要管理
      
    
    </summary>
    
      <category term="Git" scheme="http://wanqbin.xyz/categories/Git/"/>
    
    
      <category term="Git" scheme="http://wanqbin.xyz/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>Linux内存管理机制——基本机制</title>
    <link href="http://wanqbin.xyz/2019/08/12/Linux%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%9C%BA%E5%88%B6%E2%80%94%E2%80%94%E5%9F%BA%E6%9C%AC%E6%9C%BA%E5%88%B6/"/>
    <id>http://wanqbin.xyz/2019/08/12/Linux内存管理机制——基本机制/</id>
    <published>2019-08-12T13:54:00.000Z</published>
    <updated>2019-08-12T13:54:49.678Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;内存管理是指应用程序通过软硬件协作来访问内存的内存子系统。它的主要职责为：在进程请求内存时，为其分配可用物理内存页面；在进程释放内存时，回收内存页面；负责跟踪系统中内存的使用状态。</p><p>&emsp;&emsp;最简单的内存管理方式是使运行的进程拥有对所有物理内存1的访问权。如果这样做，进程就必须包含对硬件进行操作的全部代码，必须能找到自己的物理内存地址，而且还必须负责将自身的数据载入内存。这种方式不但给程序开发人员造成了很重的负担，而且还要保证进程可以被加载到可用内存中去。这些苛刻的要求显然对日益复杂化的程序需求来说很不现实，所以要将内存管理这个棘手的任务交给操作系统完成。</p><p>&emsp;&emsp;现在操作系统要求能够使多个程序共享操作系统的资源，同时还要求内存对程序开发者是透明的。在此需求下虚拟内存便应运而生，它支持程序访问比系统物理可用内存大得多的内存空间，而其也使多个程序共享内存变得更容易、更方便。物理内存是在系统中由RAM芯片控制的可用内存，虚拟内存依靠透明地使用磁盘空间以允许程序使用比物理内存更多的内存空间，磁盘空间可作为物理内存的扩充。我们之所以称其为虚拟内存就是因为磁盘空间被当作内存一样使用。</p><p>&emsp;&emsp;使用虚拟内存时，程序数据被分割成可以在磁盘与内存空间来回移动的基本单元。这样程序被使用的部分就可以被置于内存中，以便获得更快的访问速度；而未被使用的部分则被临时存放在磁盘上，从而减轻了物理内存的压力。这些数据单元，或者说虚拟内存块被称为<code>页</code>。同样，物理内存也需要被划分成可容纳页的区，这些区被称为页面。当一个进程请求一个地址时，包含该地址的页将被调入内存中，所有对该页中数据的请求都会产生对页的访问。如果页中没有任何地址被事先访问过，那么该页就尚未被载入内存。当某个地址第一次访问该页时便会产生一个缺页，因为这时内存中并没有该页，因此必须从磁盘请求。当物理页面已全部被占用时，内核必须选择一个页面，然后将其内容写回到磁盘，从而用程序刚刚请求到的页内容来填充它。</p><p>&emsp;&emsp;当一个程序从内存页面中存取数据时，会使用地址来指出需要访问的内存位置。该地址被称作<code>虚拟地址</code>,它们组成了进程的虚拟地址空间。每个进程都有自己独立的虚拟地址空间，这样做的好处是可防止非法读取或写覆盖1其他进程的数据。虚拟内存允许进程“使用”超过可用物理内存的内存空间，于是操作可以给予每个进程自己独立的虚拟线性地址空间。</p><p>&emsp;&emsp;虚拟地址空间的大小取决于体系结构的字长，如果一个处理器的寄存器可容纳32位数据，那么该处理器支持的进程虚拟地址空间大小就是$2^{32}$字节。虚拟内存不仅扩大了可寻址的内存范围，而且也使得物理内存的大小限制对用户空间的开发者透明，比如开发者不需要管理内存中的任何空格键。以32位的系统为例，其虚拟空间的范围为0~4GB，如果系统有2GB的物理内存，那么它的物理内存地址范围为0-2GB。而程序可以有4GB之大，但是只有被装入可用内存中的程序才能运行，因此整个程序将被存放在磁盘上，系统只把所需要运行的程序页载入到内存。</p><p>&emsp;&emsp;这种页从内存到磁盘之间调入调出的机制称为分页机制，分页机制包括程序虚拟地址到物理内存地址的转换。</p><p>&emsp;&emsp;内存管理在操作系统中负责维护虚拟地址和物理地址之间的关系，并且实现分页机制。对内存管理子系统来说，页时内存的基本单元，内存单元MMU是完成实际地址转换工作的硬件部件，内核提供了页表以及相关的地址，MMU在执行地址转换时访问这些地址。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&amp;emsp;&amp;emsp;内存管理是指应用程序通过软硬件协作来访问内存的内存子系统。它的主要职责为：在进程请求内存时，为其分配可用物理内存页面；在进程释放内存时，回收内存页面；负责跟踪系统中内存的使用状态。&lt;/p&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;最简单的内存管理方式是使运行的
      
    
    </summary>
    
      <category term="Linux内核" scheme="http://wanqbin.xyz/categories/Linux%E5%86%85%E6%A0%B8/"/>
    
    
      <category term="内存管理机制" scheme="http://wanqbin.xyz/tags/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%9C%BA%E5%88%B6/"/>
    
      <category term="虚拟地址" scheme="http://wanqbin.xyz/tags/%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80/"/>
    
      <category term="虚拟内存" scheme="http://wanqbin.xyz/tags/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/"/>
    
      <category term="操作系统" scheme="http://wanqbin.xyz/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>Linux模块机制——模块的使用</title>
    <link href="http://wanqbin.xyz/2019/08/12/Linux%E6%A8%A1%E5%9D%97%E6%9C%BA%E5%88%B6%E2%80%94%E2%80%94%E6%A8%A1%E5%9D%97%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>http://wanqbin.xyz/2019/08/12/Linux模块机制——模块的使用/</id>
    <published>2019-08-12T03:22:00.000Z</published>
    <updated>2019-08-12T03:23:40.909Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;由于模块和内核是在同样的地址空间运行的，因此模块编程在一定意义上说也就是内核编程。但是并不不是内核中所有的地方都可以使用模块，一般是在设备驱动程序、文件系统等地方使用模块，而对Linux内核来说极为重要的地方如进程管理和内存管理等是无法通过模块来实现的，必须通过直接对内核进行修改来完成的。</p><h2 id="一、一个简单的内核模块程序"><a href="#一、一个简单的内核模块程序" class="headerlink" title="一、一个简单的内核模块程序"></a>一、一个简单的内核模块程序</h2><p>我们编写一个Hello World的内核模块。内核模块代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> _<span class="function">init <span class="title">hello_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    printk(KERN_ALERT <span class="string">"Hello World2\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> _<span class="function"><span class="built_in">exit</span> <span class="title">hello_exit</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    printk(KERN_ALERT <span class="string">"Goodbye,world2\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(hello_init);</span><br><span class="line">module_exit(hello_init);</span><br><span class="line">MODULE_LICENSE(<span class="string">"GPL"</span>);</span><br><span class="line">MODULE_AUTHOR(<span class="string">"Author"</span>);</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这是一个简单的内核模块，我们对其进行简单的介绍。<code>hello_init()</code>函数是模块的入口点，它通过<code>module_init()</code>函数例程注册到系统中，在模块装载时被调用。模块的初始化函数形式如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> _<span class="function">init <span class="title">my_init</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;由于初始化函数通常并不会被外部函数直接调用，所以不必导出该函数，故它可以被标记为<code>static</code>又由于<code>init</code>函数在模块加载以后，就不会再使用了，因此，我们使用<code>_init</code>宏，这个宏表示在模块初始化完成后，丢弃函数，并释放其所占内存。</p><p>&emsp;&emsp;<code>hello_exit()</code>函数是模块的出口函数，它由<code>module_exit()</code>函数例程注册到系统。在模块从内核卸载时，内核便会调用<code>hello_exit()</code>函数。退出函数可能会在返回前负责清理资源，以保证硬件处于一致状态。模块的退出函数形式如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> _<span class="function"><span class="built_in">exit</span> <span class="title">my_exit</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;与初始化函数的原因一样，也可以标记该函数为<code>static</code>。使用<code>_exit</code>宏，如果上述文件被静态地编译到内核映像中，那么退出函数将不被包含，而且永远都不会被调用。</p><p>&emsp;&emsp;<code>MODULE_LICENSE()</code>宏定义用于指定模块的版权。如果载入非GPL模块到系统内核，则会在内核中设置被污染标识，这个标识只起到记录信息的作用。不过如果开发者提交的bug报告中含有被污染的代码，那么报告的信用无疑会下降。另外非GPL模块不能使用标记为GPL-only的函数和变量。</p><p>&emsp;&emsp;MODULE_AUTHOR()宏指定了代码作者，用于做信息记录。</p><h2 id="二、构建模块"><a href="#二、构建模块" class="headerlink" title="二、构建模块"></a>二、构建模块</h2><p>&emsp;&emsp;在2.6内核中采用了新的<code>kbuild</code>机制来构建内核模块，使得模块的构建更加简单、灵活。在Linux内核中由用户建立的模块可以放在两个位置，一种是将自己构建的模块直接添加到内核源代码中，另外一种就是将该模块放在内核代码外。</p><ol><li><h3 id="在内核源代码中构建内核模块"><a href="#在内核源代码中构建内核模块" class="headerlink" title="在内核源代码中构建内核模块"></a>在内核源代码中构建内核模块</h3><p>&emsp;&emsp;如果想把自己编写的模块添加到内核源代码树中，首先，必须先明确该模块需要放在源代码树的什么位置，在Linux中，所有设备的驱动程序都存放在内核目录<code>drivers</code>下，打开该目录会发现在该目录下存在许多子目录。在这个目录下，系统将不同的驱动程序进行分类存放，如char、block、usb等。当然Linux并没有硬性规定哪些硬件必须放在哪个目录下。</p><p>&emsp;&emsp;下面用一个简单的例子来说明如何将自己编写的模块直接添加到内核源代码树中，现在假设已经编写好了一个字符类型的驱动程序，命名为mymodule，要把该模块添加到内核中，需要完成以下4步工作。</p><p>（1）确定内核模块代码的存放位置。由于模块是一个字符类型的驱动程序，那么需要把该模块放到目录<code>drivers/char</code>下，这里有两种选择，一种是直接将模块放到<code>char</code>目录下，另外一种是在<code>char</code>目录下先建立一个文件夹并命名为<code>mumodule</code>，然后将模块放到这个子目录下。这两种作法对最后所要完成的工作并没有任何影响，只是考虑到当驱动程序是由多个源代码文件组成的时候，如果直接将这些原文件都放在<code>char</code>目录下，会给维护工作带来一定的麻烦。</p><p>（2）修改和创建makefile文件。这里先假设在第一步中<code>char</code>目录下建立一个文件夹<code>mymodule</code>，那么下面需要做的工作就是修改以及创建makefile文件，在<code>char</code>目录下的makefile文件中添加如下代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">obj-m +=mymodule/</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在makefile中添加上述代码的主要作用就是告诉模块构件系统在编译模块的时候需要进入<code>mymodule</code>子目录中。</p><p>&emsp;&emsp;接下来，需要在<code>mymodule</code>子目录下创建一个makefile文件，这个文件用来告诉模块构件系统如何编译该子目录下的模块，makefile文件的内容如下所示：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">obj-m += mymodule.o</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;如果要构件的模块是由多个原文件构成，如file1.c和file2.c，那么可以在<code>mymodule</code>目录下的makefile文件编写如下代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">obj-m :=mymodule.o</span><br><span class="line">mymodule-objs:=file1.o  file2.o</span><br></pre></td></tr></table></figure><p>（3）重新编译修改后的内核代码。在Linux内核编译时，就会在<code>lib/modules/2.6.10/kernel/drivers/char</code>目录下,生成一个名称为<code>mymodule.ko</code>的文件。注意，在2.6内核中，生成的模块拓展名为<code>.ko</code>，而不是以前的<code>.o</code></p><p>（4）安装内核模块。可以使用如下的命令将内核中所有编译好的模块安装到Linux系统内核中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make modules_install</span><br></pre></td></tr></table></figure><p>至此，内核模块的创建就完成了，用户可以在新的内核中使用自己定义的内核模块了。</p></li><li><h3 id="在内核源码外构建内核模块"><a href="#在内核源码外构建内核模块" class="headerlink" title="在内核源码外构建内核模块"></a>在内核源码外构建内核模块</h3><p>&emsp;&emsp;其实将模块放在内核源码外与放在内核源码树内的最大的区别在于构建过程，当用户把自己编写的模块放在内核源码树的外部时，在内核模块编译之前必须构建内核代码树。将内核模块放在内核源代码外的构建过程了如下所示。</p><p>（1）还是假设已经编写好了一个模块文件<code>mymodule.c</code>，现在将该文件放在一个用户自己创建的文件夹中，在这里冷仍然需要创建自己的makefile文件，其形式如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">obj-m += mymodule.o</span><br></pre></td></tr></table></figure><p>（2）执行make命令编译<code>.c</code>文件，其形式如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make -C /lib/modules/kernel-version/uild M=$ PWD</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这个命令是改变文件的目录到用<code>-C</code>选项提供的目录下（就是内核源码目录）。它在那里会发现内核顶层makefile文件。<code>M=</code>选项使makefile在试图创建内核模块前，回到模块源代码所在目录。</p><p>&emsp;&emsp;重复的输入前面的make命令是很麻烦的一件事，为此，我们可以编写内容如下的makefile文件，在每次编译内核模块时，只要输入make命令就可以了。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span>如果已经定义了KERNELRELEASE，则说明是从内核构造系统调用的，因此</span><br><span class="line"><span class="meta">#</span>可以使用其内建语句</span><br><span class="line"><span class="meta">ifneq($</span>(KERNELRELEASE),)</span><br><span class="line">obj-m := hello.o</span><br><span class="line">else</span><br><span class="line">KERNELDIR ?= /lib/modules/$(shell uname -r)/build</span><br><span class="line">PWD := $(shell pwd)</span><br><span class="line">default:</span><br><span class="line"><span class="meta">$</span>(MAKE) -C $(kERNELDIR) M=$(PWD) modules</span><br><span class="line">endif</span><br></pre></td></tr></table></figure><p>（3）最后一步就是把刚才编译好的内核模块<code>mymodule.ko</code>装载到系统中。在Linux中可以有两种方法来载入一个已经编译好的模块，一个是利用<code>insmod</code>，另外一个就是利用命令<code>modprobe</code>。</p><p>&emsp;&emsp;使用<code>insmod</code>命令安装内核模板的命令格式如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">insmod mymodule.ko;</span><br></pre></td></tr></table></figure><p><code>insmod</code>命令将模块的代码和数据装入内核，然后使用内核符号表解析模块中任何未解析的符号，将内核模块映像复制到内存区域，并通过内核符号表解析模块中的内核引用，最后调用模块的初始化函数。</p><p>&emsp;&emsp;这里需要说明的是，<code>insmod</code>命令虽然很简单，但是其功能也同样有限，该命令的作用就是请求内核载入指定的模块，它不会进行任何依赖性分析和错误性检查。</p><p>&emsp;&emsp;<code>modprobe</code>命令与<code>insmod</code>的功能很相似，也是用于将指定的模块装载到内核中，但是它比<code>insmod</code>命令要实用得多，这是因为该命令提供了模块依赖性分析，错误智能检查，错误报告以及许多其他功能和选项。</p><p>&emsp;&emsp;这里以提供的模块依赖性为例来详细分析其优越性，当用<code>modprobe</code>命令来装载某个指定的模块的时候，它会考虑要装载的模块是否引用了一些当前内核中不存在的符号，也就是说该模块所引用的符号没有存放在当前的全局内核符号表中，在这种情况下，该命令会在当前模块搜索路径中查找定义了这些符号的模块，如果找到了这些模块，该命令会自动地将这些模块装载到内核中，而在这种情况下如果使用<code>insmod</code>命令来装载该模块，则会产生错误信息，即模块装载不成功，也就是说<code>modprobe</code>命令不但会加载指定的模块，而且还会自动加载任何它所依赖的有关模块。该命令的使用格式如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">modprobe -i mymodule</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;最后来看如何从内核中卸载已经装载的模块，同样有两个命令来完成该任务，一个就是<code>rmmod</code>命令，另一个就是<code>modprobe</code>命令，它们的使用格式如下：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rmmod mymodule</span><br><span class="line">modprobe -r mymodule</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这里需要说明的一点就是,<code>modprobe</code>与<code>rmmod</code>命令不同1，它不仅会卸载指定的模块，而且如果它发现需要卸载的这个模块所依赖的那些模块没有其他模块依赖于它们，那么该命令也会将这些模块一起从内核中卸载掉。</p></li></ol><h2 id="三、模块参数"><a href="#三、模块参数" class="headerlink" title="三、模块参数"></a>三、模块参数</h2><p>&emsp;&emsp;在装载内核模块时，用户可以向模块传递一些参数，如<code>modprobe modname var=value</code>,否则，<code>var</code>将使用模块内定义的缺省值。</p><p>&emsp;&emsp;2.4内核下,<code>linux/module.h</code>中定义有宏<code>MODULE_PARM(var,type)</code>，用于向模块传递命令行参数。<code>var</code>为接收参数值的变量名，<code>type</code>为采取如下格式的字符串<code>[min[-max]]{b,h,i,l,s}</code>。其中<code>min</code>及<code>max</code>用于表示当参数为数组类型时，允许输入的数组元素的个数范围，<code>b</code>表示<code>byte</code>，<code>h</code>表示<code>short</code>，<code>i</code>表示<code>int</code>，<code>l</code>表示<code>long</code>，<code>s</code>表示<code>string</code>。</p><p>&emsp;&emsp;2.6内核下，宏<code>MODULE_PARM(var,type)</code>不再被支持。在头文件<code>Linux/moduleparam.h</code>定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">module_param(name,type,perm)</span><br><span class="line">module_param_array(name,type,nump,perm)</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;<code>type</code>类型可以是<code>byte,short,ushort,int,uint,long,ulong,charp,bool</code>或<code>invbool</code>，不再采用2.4内核中的字符串形式，而且在模块编译时会将此处声明的<code>type</code>与变量定义的类型进行比较，判断是否一致。</p><p>&emsp;&emsp;<code>perm</code>表示此参数在<code>sysfs</code>文件系统中对应的文件节点的属性。2.6内核使用<code>sysfs</code>文件系统，这是一个奖励在内存中比<code>proc</code>更强大的文件系统。<code>sysfs</code>文件系统可以动态、实时、有组织层次地反应当前系统中的硬件，驱动等状态。当<code>perm</code>为0时，表示此参数在<code>sysfs</code>文件系统下对应的文件节点不存在。模块被加载后，在<code>sys/module</code>目录下1将出现以此模块名命名的目录。如果此模块存在<code>perm</code>不为0的命令行参数，在此模块的目录下将出现<code>paramters</code>目录，包含一系列以参数名命名的文件节点，这些文件的权限值等于<code>perm</code>，文件的内容为参数的值。</p><p>&emsp;&emsp;<code>nump</code>为保存输入的数组元素个数的变量指针。当不需保存实际输入的数组元素个数时，可以设为NULL。</p><h2 id="四、内核导出模块符号表"><a href="#四、内核导出模块符号表" class="headerlink" title="四、内核导出模块符号表"></a>四、内核导出模块符号表</h2><p>&emsp;&emsp;在内核模块被载入后，就会动态连接到内核中。注意，它与用户空间中的动态链接库类似，只有被明确导出的内核函数和变量，才可以被动态库使用。在内核中，导出内核函数需要使用特殊的指令：<code>EXPORT_SYMBOL</code>和<code>EXPORT_SYSBOL_GPL</code>。</p><p>&emsp;&emsp;导出的内核函数可以被其他模块调用，而未导出的诶恶化函数模块则无法被调用。模块代码的链接和调用规则相比核心内核映像中的代码而言，要更为严格。核心代码在内核中可以调用任意非静态接口，因为所有的核心源代码文件被链接成了同一个映像。当然，被导出的符号表所含的函数必然也是非静态的。</p><p>&emsp;&emsp;导出的内核符号表被看做是导出的内核接口，甚至是内核API。导出符号相当简单，如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">EXPORT_SYMBOL(var);<span class="comment">/*导出变量var*/</span></span><br><span class="line">EXPORT_SYMBLO(func);<span class="comment">/*导出函数func*/</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&amp;emsp;&amp;emsp;由于模块和内核是在同样的地址空间运行的，因此模块编程在一定意义上说也就是内核编程。但是并不不是内核中所有的地方都可以使用模块，一般是在设备驱动程序、文件系统等地方使用模块，而对Linux内核来说极为重要的地方如进程管理和内存管理等是无法通过模块来实现
      
    
    </summary>
    
      <category term="Linux内核" scheme="http://wanqbin.xyz/categories/Linux%E5%86%85%E6%A0%B8/"/>
    
    
      <category term="Linux模块" scheme="http://wanqbin.xyz/tags/Linux%E6%A8%A1%E5%9D%97/"/>
    
      <category term="模块的使用" scheme="http://wanqbin.xyz/tags/%E6%A8%A1%E5%9D%97%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    
      <category term="构建内核模块" scheme="http://wanqbin.xyz/tags/%E6%9E%84%E5%BB%BA%E5%86%85%E6%A0%B8%E6%A8%A1%E5%9D%97/"/>
    
      <category term="模块参数" scheme="http://wanqbin.xyz/tags/%E6%A8%A1%E5%9D%97%E5%8F%82%E6%95%B0/"/>
    
      <category term="导出模块符号表" scheme="http://wanqbin.xyz/tags/%E5%AF%BC%E5%87%BA%E6%A8%A1%E5%9D%97%E7%AC%A6%E5%8F%B7%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>Linux模块机制</title>
    <link href="http://wanqbin.xyz/2019/08/12/Linux%E6%A8%A1%E5%9D%97%E6%9C%BA%E5%88%B6/"/>
    <id>http://wanqbin.xyz/2019/08/12/Linux模块机制/</id>
    <published>2019-08-12T03:21:00.000Z</published>
    <updated>2019-08-12T03:22:04.259Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;Linux是单内核的操作系统，也就是整个系统内核都运行于一个单独的保护域中。相比于微内核的操作系统，单内核由于把所有的系统功能模块都集中到一起，系统的性能和速度都非常好，但是可扩展性和维护性就相对较差。为了弥补单内核的这个缺点，Linux操作系统使用了一种全新的机制——可装载内核模块机制(Load Kernel Module,LKM),用户可以根据需要，在不需要对内核重新编译的情况下，将模块动态地载入到内核或从内核中移出。</p><p>&emsp;&emsp;可装载内核模块，简称为模块，它是在内核空间运行的程序，实际上是一种目标对象文件，没有链接，不能独立运行，但是其代码可以在运行时链接到系统中作为内核的一部分运行或从内核中卸载，从而可以动态地扩展内核的功能。这种目标代码他通常由一部分函数和数据结构组成，用来实现一个文件系统、驱动程序或其他内核上层的功能。</p><p>&emsp;&emsp;内核模块与通常所说的运行在用户空间的应用程序有以下区别：</p><p>（1）当用户想从系统中删除某个指定的模块的时候，必须考虑到一些例如资源的释放或者其他的清除工作，Linux中每一个模块都必须包含的两个组成部分，一个用于在初始化该模块时调用，另外一个用于删除该模块的时候调用，这里之所以在模块被删除的时候还要调用一个指定的函数，就是需要这个函数来完成撤销由该模块的初始化函数所做的一切。而一般应用程序在大多数情况下是不用考虑这一点的。</p><p>（2）在Linux的内核模块中，只能调用那些由内核提供的函数，而不可以像其他应用程序那样调用应用程序库函数，这主要是因为模块仅仅被链接到内核，因此它能调用的函数仅仅是那些由内核导出的函数。</p><p>（3）在模块中发生错误的处理方式与在应用程序中发生错误的处理方式是不同的，用户在编写模块的时候必须非常小心，因为模块时链接到内核中的，一个内核模块错误在严重的情况下会导致整个系统崩溃。</p><p>&emsp;&emsp;其实对于Linux而言，几乎系统中的每一个高层组件都可以被作为模块来进行编译，例如文件系统、设备驱动程序等。当然也有些组件是不可以作为模块进行编译的，这些组件要么静态地包含在内核中，要么不编译。</p><p>&emsp;&emsp;Linux引入可加载模块机制有以下优点：</p><p>（1）使得内核更加紧凑和灵活</p><p>（2）修改内核时，不必全部重新编译整个内核，可节省时间。系统中如果需要使用新的功能，只要编译相应的模块，然后使用特定用户空间的程序将模块插入即可。</p><p>（3）模块的目标代码一旦被链接到内核，它的作用和静态链接的内核目标代码完全等价。所以，当调用模块的函数时，无需显式的消息传递。</p><p>但是内核模块的引入也带来了一定的问题。</p><p>（1）由于内核所占用的内存是不会被换出的，所以链接进内核的模块会给整个系统带来一定的性能和内存利用方面的损失。</p><p>（2）装入内核模块就成了内核的一部分，可以修改内核中的其他部分，因此模块的使用可能会导致系统崩溃。</p><p>（3）为了让内核模块能访问所有内核资源，内核必须维护一个符号表，并在装入和卸载模块时修改符号表。</p><p>（4）模块可以利用其他模块的功能，因此内核要维护模块之间的依赖关系。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&amp;emsp;&amp;emsp;Linux是单内核的操作系统，也就是整个系统内核都运行于一个单独的保护域中。相比于微内核的操作系统，单内核由于把所有的系统功能模块都集中到一起，系统的性能和速度都非常好，但是可扩展性和维护性就相对较差。为了弥补单内核的这个缺点，Linux操作系统使用
      
    
    </summary>
    
      <category term="Linux内核" scheme="http://wanqbin.xyz/categories/Linux%E5%86%85%E6%A0%B8/"/>
    
    
      <category term="操作系统" scheme="http://wanqbin.xyz/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="Linux模块机制" scheme="http://wanqbin.xyz/tags/Linux%E6%A8%A1%E5%9D%97%E6%9C%BA%E5%88%B6/"/>
    
      <category term="可装载内核模块机制" scheme="http://wanqbin.xyz/tags/%E5%8F%AF%E8%A3%85%E8%BD%BD%E5%86%85%E6%A0%B8%E6%A8%A1%E5%9D%97%E6%9C%BA%E5%88%B6/"/>
    
      <category term="LKM" scheme="http://wanqbin.xyz/tags/LKM/"/>
    
  </entry>
  
  <entry>
    <title>Linux内核同步机制分析——其他同步机制</title>
    <link href="http://wanqbin.xyz/2019/08/12/Linux%E5%86%85%E6%A0%B8%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6%E5%88%86%E6%9E%90%E2%80%94%E2%80%94%E5%85%B6%E4%BB%96%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6/"/>
    <id>http://wanqbin.xyz/2019/08/12/Linux内核同步机制分析——其他同步机制/</id>
    <published>2019-08-12T03:19:00.000Z</published>
    <updated>2019-08-12T03:20:52.538Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、每个处理器变量"><a href="#一、每个处理器变量" class="headerlink" title="一、每个处理器变量"></a>一、每个处理器变量</h2><p>&emsp;&emsp;最后的同步机制就是不需要同步，因为所有的同步机制不仅需要浪费大量的处理器周期以探测临界区的状态，而且通常导致进程阻塞、系统并发能力下降、系统吞吐量减小。更糟糕的是，在同步机制使用不当的情况下，常常导致系统死锁。</p><p>&emsp;&emsp;在Linux内核中引入的每个处理器变量，是一种特殊的同步机制，用于多处理器系统中，通过为每个CPU创建一个变量副本，使每个CPU都只能使用自己本地的复制件，来避免处理器间的同步。使用每个处理器变量会减少数据加锁操作，它唯一的安全要求就是要禁止内核抢占。总的来说，使用每个处理器变量有以下两个显著的好处。</p><p>（1）按照每个CPU访问每个处理器变量的逻辑——每个CPU只能访问该处理器本身的数据变量，这样在CPU访问每个处理器变量时就不再需要任何锁。这样就避免了因处理器间的同步影响系统的并发能力，即消除了因同步而导致的系统性能损失。</p><p>（2）使用每个处理器变量可以较少缓存失效，进一步提高系统性能。缓存失效发生在处理器试图使它们的缓存保持同步时。如果一个处理器操作某个数据，而该数据又存放在其他处理器缓存中，那么存放该树的那个处理器必须清理或刷新它自己的缓存。持续不断的缓存失效称为缓存抖动，缓存抖动对系统性能影响颇大。使用每个处理器变量将使得缓存失效降至最低，因为理想情况下每个处理器只会访问它们自己的数据。</p><p>&emsp;&emsp;在Linux2.4内核中，系统把每个处理器变量存放到一个数组中，数组中的每一项对应着系统上一个存在的处理器，并使用每个CPU的处理器号作为每个CPU所对应元素的下标。我们可以按照下面的方式来使用每个处理器变量。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> my_percpu[NR_CPUS];<span class="comment">//每个处理器变量的声明</span></span><br><span class="line"><span class="keyword">int</span> cpu;</span><br><span class="line">cpu=get_cpu();<span class="comment">//获得当前处理器，并禁止内核抢占</span></span><br><span class="line">my_percpu[cpu]++;</span><br><span class="line">put_cpu();<span class="comment">//使能内核抢占</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;注意，上面的代码中并没有出现锁。正如上面所言，所操作的变量对当前处理器来说是唯一的，除了当前处理器，没有其他处理器可以接触到这个变量，不存在并发访问问题，所以当前处理器在不用锁的情况下也可以安全地访问它。</p><p>&emsp;&emsp;Linux2.6内核为了方便创建和操作每个处理器变量，引入了新的操作接口，该操作接口归纳了前面的操作行为，并使得每个处理器变量的创建和操作得以简化。操作函数的功能及描述如下：</p><table><thead><tr><th>函数原型</th><th>描述</th></tr></thead><tbody><tr><td>DEFINE_PER_CPU(tyep,name)</td><td>在内核编译时，创建一个类型为type，名字为name的每个处理器变量</td></tr><tr><td>DECLARE_PER_CPU(type,name)</td><td>在内核编译时，声明一个类型为type，名字为name的每个处理器变量</td></tr><tr><td>get_cpu_var(var)</td><td>返回指定变量var在当前处理器上的复制件，并禁止内核抢占</td></tr><tr><td>put_cpu_var(var)</td><td>使能内核抢占</td></tr><tr><td>void* alloc_percpu(type)</td><td>在内核运行过程中，动态地创建一个类型为type的每个处理器变量，并返回指向这个变量的void类型指针</td></tr><tr><td>void *_alloc_percpu(size)</td><td>在系统运行过程中，动态地创建一个大小为size的每个处理器变量，并返回指向这个变量的void类型指针</td></tr><tr><td>free_percpu(ptr)</td><td>释放指针ptr所指向的每个处理器变量</td></tr><tr><td>void *per_cpu_ptr(ptr,cpu)</td><td>返回指针变量在处理器号cpu上的复制件</td></tr></tbody></table><p>&emsp;&emsp;为了保持Linux内核的兼容性，Linux2.4内核中每个处理器变量的使用方式，在Linux2.6内核中也可以使用。但是，由于新的操作接口使用方便，而且在性能上也得到了优化，因此，在内核编程中建议使用新操作接口。</p><h2 id="二、禁止内核抢占"><a href="#二、禁止内核抢占" class="headerlink" title="二、禁止内核抢占"></a>二、禁止内核抢占</h2><p>&emsp;&emsp;在Linux2.6内核中引入了内核抢占机制，这就使得内核中的进程在任何时刻都可能被抢占，让出CPU，以便另一个具有更高优先级的进程运行。这就意味着一个任务与被抢占的任务可能会在同一个临界区运行。为了避免这种情况的发生，临界区代码可以使用自旋锁作为非抢占区域的标记，因为如果临界区持有自旋锁，内核便不能进行抢占。在实际中，某些情况并不需要自旋锁，但是仍然需要禁止内核抢占。出现得最频繁的情况就是对每个处理器变量访问。为此，Linux提供了禁止内核抢占的操作函数<code>preempt_disable()</code>。这里我们对Linux禁止内核抢占机制进行讨论。</p><p>&emsp;&emsp;为了禁止内核抢占以避免因内核抢占导致的内核数据的不一致性，在每个进程的<code>thread_info</code>结构中引入了内核抢占计数器<code>preempt_count</code>。变量<code>preempt_count</code>被划分为3个字段，每个字段的名称及翻译如下：</p><table><thead><tr><th>字段</th><th>位</th><th>描述</th></tr></thead><tbody><tr><td>PREEMPT</td><td>0~7</td><td>系统设置禁止内核抢占的计数</td></tr><tr><td>SOFTIRQ</td><td>8~15</td><td>系统设置禁止执行软中断的计数</td></tr><tr><td>HARDIRQ</td><td>16~27</td><td>系统设置进入中断的计数，即中断嵌套的深度</td></tr></tbody></table><p>&emsp;&emsp;内核中提供了宏定义<code>add_preempt_count()</code>、<code>sub_preempt_count()</code>来方便对每个字段进行加1、减1操作。这两个宏定义具体操作哪个字段，依赖于传递给这两个宏定义的参数。候选参数有<code>PREEMPT_OFFSET</code>（也可以直接使用1代替）、<code>SOFTIRQ_OFFSET</code>、<code>HARDIRQ_OFFSET</code>，这些参数定义在<code>include/linux/hardirq.h</code>中，在默认情况下，<code>PREEMPT_OFFSET</code>的值为0x1，<code>SOFTIRQ_OFFSET</code>的值为0x100、<code>HARDIRQ_OFFSET</code>的值为0x10000。下面我们对这三个字段的用途分别进行介绍。</p><ol><li><h3 id="禁止内核抢占"><a href="#禁止内核抢占" class="headerlink" title="禁止内核抢占"></a>禁止内核抢占</h3><p>&emsp;&emsp;禁止内核抢占由宏定义<code>preempt_disable()</code>完成，该宏定义<code>include/linux/preempt.h</code>中，代码如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> preempt_disable()\</span></span><br><span class="line"><span class="keyword">do</span>&#123;\</span><br><span class="line">inc_preempt_count();\</span><br><span class="line">barrier();\</span><br><span class="line">&#125;<span class="keyword">while</span>(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><p>第3行代码调用<code>inc_preempt_count()</code>函数将变量<code>preempt_count</code>对应<code>PREEMPT</code>字段的部分进行加1操作。</p><p>第4行代码中<code>barrier()</code>函数是一个内存屏障，保障在屏障之前缓存在寄存器中的变量写回到内存中去。</p><p>使能内核抢占函数由宏定义<code>preempt_enable()</code>完成，该宏定义在<code>include/linux/preempt.h</code>中，代码如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> preempt_enable()\</span></span><br><span class="line"><span class="keyword">do</span>&#123;\</span><br><span class="line">preempt_enable_no_resched();\</span><br><span class="line">barrier();\</span><br><span class="line">preempt_check_resched();\</span><br><span class="line">&#125;<span class="keyword">while</span>(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><p>第3行代码调用<code>preempt_enable_no_resched()</code>函数将变量<code>preempt_count</code>对应<code>PREEMPT</code>字段部分进行减1操作，但是并不检查是否有需要被调度的任务。</p><p>第5行代码调用<code>preempt_check_resched()</code>函数检查是否需要被调度的任务，即当前进程是否设置了请求调度标志<code>TIF_NEED_RESCHED</code>,如果设置了该标志，则调用调度器进行内核抢占。</p></li><li><h3 id="禁止执行软中断的计数"><a href="#禁止执行软中断的计数" class="headerlink" title="禁止执行软中断的计数"></a>禁止执行软中断的计数</h3><p>&emsp;&emsp;Linux内核提供了<code>local_bh_disable()</code>用于禁止执行软中断，该函数定义在<code>kernel/softira.c</code>中，代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">local_bh_disable</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    _local_bh_disable((<span class="keyword">unsigned</span> <span class="keyword">long</span>) _builtin_return_address(<span class="number">0</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;该函数实际上是<code>_local_bh_disable()</code>函数的封装。<code>_local_bh_disable()</code>定义在一个文件中，代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> _local_bh_disable(<span class="keyword">unsigned</span> <span class="keyword">long</span> ip)</span><br><span class="line">&#123;</span><br><span class="line">    add_preempt_count(SOFTIRQ_OFFSET);</span><br><span class="line">    barrier();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第3行代码以<code>SOFTIRQ_OFFSET</code>为参数调用<code>add_preempt_count()</code>函数将变量<code>preempt_count</code>对应<code>SOFTIRQ</code>字段部分进行加1操作。</p><p>Linux内核提供了<code>local_bh_enable()</code>用于使能执行软中断，代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">local_bh_enable</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_TRACE_IRQFLAGS</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> flags;</span><br><span class="line">    WARN_ON_ONCE(in_irq());</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    </span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_TRACE_IRQFLAGS</span></span><br><span class="line">    local_irq_save(flags);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(softirq_count()==SOFTIRQ_OFFSET)</span><br><span class="line">        trace_softirqs_on(<span class="keyword">unsigned</span> <span class="keyword">long</span>) _builtin_return_address(<span class="number">0</span>));</span><br><span class="line">    </span><br><span class="line">    sub_preempt_count(SOFTIRQ_OFFSET<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">if</span>(unlikely(!in_interrupt()&amp;&amp;local_softirq_pending()))</span><br><span class="line">        do_softirq();</span><br><span class="line">    </span><br><span class="line">    dec_preempt_count();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_TRACE_IRQFLAGS</span></span><br><span class="line">    local_irq_restore(flags);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    preempt_check_resched();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第12~13行代码判断是否可以允许执行软中断（即变量preempt_count中对应SOFTIRQ字段是否加1），如果是，调用<code>trace_softirq_on()</code>记录软中断使能的统计信息。</p><p>第15行代码以<code>SOFTIRQ_OFFSET-1</code>参数调用<code>sub_preempt_count()</code>函数将变量<code>preempt_count</code>对应<code>SOFTIRQ</code>字段部分进行减1操作，并禁止内核抢占（在PREEMPT对应字段减1）。</p><p>第16~17行代码中<code>in_interrupt()</code>函数用于查看当前是否处于中断上下文或者中断下半部中，<code>local_softirq_pending()</code>函数用于查看当前是否存在被挂起的软中断，<code>do_softirq()</code>函数用于执行当前被挂起的软中断。</p><p>第19行代码调用<code>dec_preempt_count()</code>函数使能内核抢占。</p><p>Linux内核提供了<code>in_softirq()</code>函数查看当前是否禁止了执行软中断，该函数定义在<code>include/linux/hardirq.h</code>中，代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> in_softirq()(softirq_count())</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> softirq_count()(preempt_count()&amp;SOFTIRQ_MASK)</span></span><br></pre></td></tr></table></figure><p>其中，<code>preempt_count()</code>用于获取<code>thread_info</code>结构中成员变量<code>preempt_count</code>,在默认情况下，<code>SOFTIRQ_MASK</code>的值为0xff00。</p></li><li><h3 id="中断计数"><a href="#中断计数" class="headerlink" title="中断计数"></a>中断计数</h3><p>&emsp;&emsp;当内核进入中断时，会调用<code>irq_enter()</code>函数来增加中断的嵌套次数，该函数实际上是<code>_irq_enter()</code>函数的封装。<code>_irq_enter()</code>是一个宏定义，定义在<code>include/linux/hardirq.h</code>中，代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _irq_enter()\</span></span><br><span class="line"><span class="keyword">do</span>&#123;\</span><br><span class="line">account_system_vtime(current);\</span><br><span class="line">add_preempt_count(HARDIRQ_OFFSET);\</span><br><span class="line">trace_harding_enter();\</span><br><span class="line">      &#125;<span class="keyword">while</span>(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><p>第3行代码调用<code>account_system_vtime()</code>函数更新当前进程的虚拟运行时间<code>vtime</code>。</p><p>第4行代码以<code>HARDIRQ_OFFSET</code>参数调用<code>add_preempt_count()</code>函数将变量<code>preempt_count</code>对应的<code>HARDIRQ</code>字段进行加操作。</p><p>第5行代码调用<code>trace_hardirq_enter()</code>函数对当前进程的进入中断上下文的计数器（存放在进程描述符struct中的成员变量hardirq_context)加1操作。</p><p>当内核从一个中断中退出时，会调用<code>irq_exit()</code>函数，减少中断的嵌套次数，该函数实际上是<code>_irq_exit()</code>函数的封装。<code>_irq_exit()</code>是一个宏定义，定义在<code>include/linux/harrdirq.h</code>中，代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _irq_exit()\</span></span><br><span class="line"><span class="keyword">do</span>&#123;\</span><br><span class="line">trace_hardirq_exitt();\</span><br><span class="line">account_system_vtime(current);\</span><br><span class="line">sub_preempt_countt(HARDIRQ_OFFSET);\</span><br><span class="line">      &#125;<span class="keyword">while</span>(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><p>第3行代码调用<code>trace_hardirq_exit()</code>函数对当前进程的退出中断上下文的计数器（存放在进程描述符struct中的成员变量hardirq_context)进行加1操作。</p><p>第5行代码以<code>HARRDIRQ_OFFSET</code>为参数调用<code>sub_preempt_count()</code>函数将变量<code>preempt_count</code>对应的<code>HARDIRQ</code>字段部分进行减1操作。</p><p>Linux内核提供了<code>in_irq()</code>函数用于查看当前是否处于中断上下文中，该函数实际上是对<code>hardirq_count()</code>函数的封装，在<code>include/linux/hardirq.h</code>中，代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> in_irq()(hardirq_count())</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> hardirq_count()(preempt_count()&amp;&amp;HARDIRQ_MASK)</span></span><br></pre></td></tr></table></figure><p>其中，默认情况下，<code>HARDIRQ_MASK</code>的值为0xfff0000。</p><p>内核提供了<code>in_interrupt()</code>函数用于查看当前是否处于中断上下文中或者禁止执行软中断，该函数定义在<code>include/linux/hardirq.h</code>中，代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> in_interrupt()(irq_count())</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> irq_count()(preempt_count()&amp;(HARDIRQ_MASK|SOFTIRQ_MASK))</span></span><br></pre></td></tr></table></figure></li></ol><h2 id="三、BKL"><a href="#三、BKL" class="headerlink" title="三、BKL"></a>三、BKL</h2><p>&emsp;&emsp;BKL(大内核锁)是一个全局自旋锁，在早期的Linux版本中该锁被广泛使用，在Linux2.0版本中，这个锁是一个相对粗粒度的自旋锁，当时该锁是为了确保内核中一个时刻上只存在一个进程运行在内核态。而到了Linux2.2版本后，内核不再依赖于这个单独的自旋锁，而是由专门的自旋锁保护内核中的数据结构，从而允许多个处理器在内核中并发地执行程序。</p><p>&emsp;&emsp;BKL是一个名为<code>kernel_flag</code>的自旋锁，持有该锁的进程仍可以睡眠，因为内核中规定当任务无法调度的时候，该睡眠任务所持有的BKL锁才会被自动释放，该任务被重新调度的时候，该锁又会被重新获取，但是并不提倡让持有该锁的进程去睡眠；另外Linux允许一个进程递归地获取一个BKL锁，也就是说BKL是一种递归锁。代表进程结构的结构体<code>task_struct</code>中有一个成员变量命名为<code>lock_depth</code>，该成员变量就是为了实现让一个进程可以多次获取一个大内核锁而设定的。如果进程不需要获得BKL锁，则将该成员变量<code>lock_depth</code>的值设为-1；该进程每次获得BKL锁，就会使<code>lock_depth</code>加1，<code>lock_depth</code>表示该进程获得了多少次锁，当然，在该进程释放锁的时候，也必须调用同样次数的释放锁的函数，否则，该锁是不会被真正释放的。</p><p>&emsp;&emsp;在内核中不鼓励使用BKL，事实上，在新内核的代码中不再使用BKL，但是这种锁仍然在部分旧代码中被保留下来。BKL操作函数如下：</p><table><thead><tr><th>函数原型</th><th>描述</th></tr></thead><tbody><tr><td>lock_kernel()</td><td>获得大内核锁BKL</td></tr><tr><td>unlock_kernel()</td><td>释放大内核锁BKL</td></tr><tr><td>kernel_locked()</td><td>如果锁被持有返回非0值，否则返回0</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、每个处理器变量&quot;&gt;&lt;a href=&quot;#一、每个处理器变量&quot; class=&quot;headerlink&quot; title=&quot;一、每个处理器变量&quot;&gt;&lt;/a&gt;一、每个处理器变量&lt;/h2&gt;&lt;p&gt;&amp;emsp;&amp;emsp;最后的同步机制就是不需要同步，因为所有的同步机制不仅需要浪费
      
    
    </summary>
    
      <category term="Linux内核" scheme="http://wanqbin.xyz/categories/Linux%E5%86%85%E6%A0%B8/"/>
    
    
      <category term="操作系统" scheme="http://wanqbin.xyz/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="Linux内核同步机制" scheme="http://wanqbin.xyz/tags/Linux%E5%86%85%E6%A0%B8%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6/"/>
    
      <category term="每个处理器变量" scheme="http://wanqbin.xyz/tags/%E6%AF%8F%E4%B8%AA%E5%A4%84%E7%90%86%E5%99%A8%E5%8F%98%E9%87%8F/"/>
    
      <category term="禁止内核中断" scheme="http://wanqbin.xyz/tags/%E7%A6%81%E6%AD%A2%E5%86%85%E6%A0%B8%E4%B8%AD%E6%96%AD/"/>
    
      <category term="BKL" scheme="http://wanqbin.xyz/tags/BKL/"/>
    
  </entry>
  
  <entry>
    <title>Linux内核同步机制分析——RCU同步机制</title>
    <link href="http://wanqbin.xyz/2019/08/11/Linux%E5%86%85%E6%A0%B8%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6%E5%88%86%E6%9E%90%E2%80%94%E2%80%94RCU%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6/"/>
    <id>http://wanqbin.xyz/2019/08/11/Linux内核同步机制分析——RCU同步机制/</id>
    <published>2019-08-11T07:14:00.000Z</published>
    <updated>2019-08-11T07:15:38.356Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;读-复制-更新（Read-Copy-Update，RCU)机制是2.6内核中引入的另外一种新的同步机制。无论是自旋锁机制还是信号量机制都依赖于原子操作完成内核同步工作。但是，随着CPU性能的迅速提高，获得这些锁的开销相对于CPU的速度在成倍地增加，原因很简单——CPU的速度和访问内存的速度差距越来越大，系统的整体性能越来越依赖于高速缓存和流水线的性能；这种依赖于原子操作的不同机制需要使用内存屏障来保障原子操作，而这又会导致处理器流水线停滞和高速缓存的刷新，因此对系统的性能有很大的影响。</p><p>&emsp;&emsp;内核中新引入的RCU机制克服了基于原子操作同步机制的缺点，具有很好的可扩展性。但是，这种锁机制的使用范围比较窄，它只适用于读多写少的情况，如网络路由表的查询更新、设备状态表的维护、数据结构的延迟以及多径I/O设备的维护等。</p><h2 id="一、RCU同步机制原理"><a href="#一、RCU同步机制原理" class="headerlink" title="一、RCU同步机制原理"></a>一、RCU同步机制原理</h2><p>&emsp;&emsp;同步机制的核心思想是将写者的更新过程划分为移除和回收两个独立的步骤；同时要求必须通过指针来引用临界资源。移除步骤首先生成临界资源的一份复制并更新相关的域，然后解除指针对原有临界资源的应用并使之指向新的已经更新的复制件。回收步骤在适当的时机开始完成原有临界资源的回收工作，释放其占用的存储空间。</p><p>&emsp;&emsp;对于被RCU保护的共享数据结构，读者不需要获得任何锁就可以访问它，而写者在访问它时首先复制一个副本，然后对副本进行修改，最后使用回调(callback)机制在适当的时机把指向原来数据的指针重新指向新的被修改的数据。这个时机就是所有引用该数据的CPU都退出对共享数据的操作之时。因此可以把RCU同步机制看成是一种改进的读写自旋锁<code>rwlock</code>。</p><p>&emsp;&emsp;在RCU同步机制中，读者几乎没有什么同步开销，它不需要获得锁，也不使用原子指令，而且在除alpha之外的所有架构上也不需要内存屏障，因此不会导致锁竞争、内存延迟以及流水线停滞，从而大大提高了读者的性能。由于读者不需要获得任何锁，因此死锁问题也就不需要考虑了，这使得RCU同步机制的使用更加简单。RCU同步机制中写者的同步开销比较大，它需要复制被修改的数据结构，也必须使用某种锁机制同步其他并行的写者操作。在RCU同步机制的写者实现时，读者必须提供一个信号给写者以便写者能够确定数据可以被安全地释放或修改的时机。有一个专门的垃圾收集器来探测读者的信号，一旦所有的读者都已经发送信号告知它们都不再使用被RCU保护的数据结构，垃圾收集器就调用回调函数完成最后的数据释放或修改操作。因此RCU写者的同步开销比较大，它比较适用于写操作比较少的同步操作。</p><p>&emsp;&emsp;RCU与rwlock的不同之处是：RCU同步机制既允许多个读者同时访问被保护的数据，又允许多个读者和多个写者同时访问被保护的数据，读者没有任何开销，而写者的同步开销则取决于使用的写者间同步机制。但RCU不能代替rwlock，因为如果写操作比较多时，对读者性能提高不能弥补写者导致的性能损失。</p><h2 id="二、RCU同步机制的实现"><a href="#二、RCU同步机制的实现" class="headerlink" title="二、RCU同步机制的实现"></a>二、RCU同步机制的实现</h2><p>&emsp;&emsp;内核为RCU同步机制提供了一系列的操作函数，下面只讨论5个主要函数的实现，其他的操作函数都是这些函数的封装，可由这些函数组合而成。</p><ol><li><p><code>rcu_read_lock()</code></p><p>&emsp;&emsp;该操作函数由读者任务调用，表明读者任务以只读方式进入了RCU临界区，开始对RCU临界资源进行访问。代码如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rcu_read_lock()\</span></span><br><span class="line"><span class="keyword">do</span>&#123;\</span><br><span class="line">preempt_disable();\</span><br><span class="line">_acquire(RCU);\</span><br><span class="line">rcu_read_acquire();\</span><br><span class="line">&#125;<span class="keyword">while</span>(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><p>其中，<code>_acquire()</code>函数和<code>rcu_read_acquire()</code>函数都是编译器上的选择信息，<code>preempt_disable()</code>禁止内核抢占，即RCU同步机制中获取读锁只禁止当前处理器上的内核抢占，不需要获得任何形式的锁。读者任务进入RCU临界区后，不能进入睡眠状态。</p></li><li><p><code>rcu_read_unlock()</code></p><p>&emsp;&emsp;该操作函数由读者任务调用，表明读者完成了对临界资源的访问，离开了RCU临界区。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rcu_read_unlock()\</span></span><br><span class="line"><span class="keyword">do</span>(\</span><br><span class="line">rcu_read_release();\</span><br><span class="line">_release(RCU);\</span><br><span class="line">preempt_enable();\</span><br><span class="line">)<span class="keyword">while</span>(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><p>该函数与<code>rcu_read_lock()</code>函数类似，主要调用<code>preempt_enable()</code>函数使能当前处理器的内核抢占。</p></li><li><p><code>rcu_dereference()</code></p><p>&emsp;&emsp;该函数由读者任务调用，用于获取指向RCU临界资源的指针，因此RCU机制限制所有的临界资源都应该以指针方式进行间接访问。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rcu_dereference(&#123;\</span></span><br><span class="line">typeof(p) __p1=ACCESS_ONCE(p);\</span><br><span class="line">smp_read_barrier_depends();\</span><br><span class="line">(__p1);\</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>该宏定义实现的功能看似多余，实则不然。这里通过为指针p创建一个新的复制件<code>__p1</code>，使读者任务在通过复制<code>__p1</code>访问RCU资源的同时，不妨碍写者对原有指针变量p的修改。</p></li><li><p><code>rcu_assign_pointer()</code></p><p>&emsp;&emsp;该操作函数由写者任务调用，在读者任务更新临界资源的移除阶段，用于重置RCU临界资源的指针，使之指向新版本的临界资源。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rcu_assign_pointer(p,v)(&#123;\</span></span><br><span class="line">smp_wmb();\</span><br><span class="line">(p)=(v);\</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li><p><code>synchronize_rcu()</code></p><p>&emsp;&emsp;该函数由写者任务调用，在写者任务完成移除工作之后，调用该函数进入睡眠状态，等待所有的读者进程完成对旧版本临界资源的访问。在所有读者任务不再引用旧版本数据之后，内核负责将写者任务唤醒，接下来写者任务完成旧版本临界资源的访问。在所有读者任务不再引用旧版本数据之后，内核负责将写者任务唤醒，接下来写者任务完成旧版本临界资源的回收工作。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">synchronize_rcu</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rcu_synchronize</span> <span class="title">rcu</span>;</span></span><br><span class="line">    init_completion(&amp;rcu.completion);</span><br><span class="line">    call_rcu(&amp;rcu.head,wakeme_after_rcu);</span><br><span class="line">    wait_for_completion(&amp;rcu.completion);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>call_rcu()</code></p><p>&emsp;&emsp;该函数由写者任务调用，在写者任务完成移除工作之后，调用该函数向系统注册一个资源“回收”处理函数，在所有读者任务不再引用旧版本数据之后，内核调用该处理函数完成旧版本临界资源的回收工作。与<code>synchronize_rcu()</code>函数相比，该函数不会阻塞，可用于中断上下文中。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> fastcall <span class="title">call_rcu</span><span class="params">(struct rcu_head *head,<span class="keyword">void</span>(*func)(struct rcu_head *rcu))</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> flags;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rcu_data</span> *<span class="title">rdp</span>;</span></span><br><span class="line">    </span><br><span class="line">    head-&gt;func=func;</span><br><span class="line">    head-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">    local_irq_save(flags);</span><br><span class="line">    rdp=&amp;_get_cpu_var(rcu_data);</span><br><span class="line">    *rdp-&gt;nxtail=head;</span><br><span class="line">    rdp-&gt;nxttail=&amp;head-&gt;next;</span><br><span class="line">    <span class="keyword">if</span>(unlikely(++rdp-&gt;qlen&gt;qhimark))</span><br><span class="line">    &#123;</span><br><span class="line">        rdp-&gt;blimit=INT_MAX;</span><br><span class="line">        force_quiescent_state(rdp,&amp;rcu_ctrlblk);</span><br><span class="line">    &#125;</span><br><span class="line">    local_irq_restore(flags);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&amp;emsp;&amp;emsp;读-复制-更新（Read-Copy-Update，RCU)机制是2.6内核中引入的另外一种新的同步机制。无论是自旋锁机制还是信号量机制都依赖于原子操作完成内核同步工作。但是，随着CPU性能的迅速提高，获得这些锁的开销相对于CPU的速度在成倍地增加，原
      
    
    </summary>
    
      <category term="Linux内核" scheme="http://wanqbin.xyz/categories/Linux%E5%86%85%E6%A0%B8/"/>
    
    
      <category term="操作系统" scheme="http://wanqbin.xyz/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="Linux内核同步" scheme="http://wanqbin.xyz/tags/Linux%E5%86%85%E6%A0%B8%E5%90%8C%E6%AD%A5/"/>
    
      <category term="RCU同步机制" scheme="http://wanqbin.xyz/tags/RCU%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6/"/>
    
      <category term="读-复制-更新" scheme="http://wanqbin.xyz/tags/%E8%AF%BB-%E5%A4%8D%E5%88%B6-%E6%9B%B4%E6%96%B0/"/>
    
  </entry>
  
  <entry>
    <title>Linux内核同步机制分析——信号量机制</title>
    <link href="http://wanqbin.xyz/2019/08/11/Linux%E5%86%85%E6%A0%B8%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6%E5%88%86%E6%9E%90%E2%80%94%E2%80%94%E4%BF%A1%E5%8F%B7%E9%87%8F%E6%9C%BA%E5%88%B6/"/>
    <id>http://wanqbin.xyz/2019/08/11/Linux内核同步机制分析——信号量机制/</id>
    <published>2019-08-11T04:50:00.000Z</published>
    <updated>2019-08-11T04:50:54.793Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;自旋锁同步机制是一种“忙-等待”机制，在临界资源被锁定的时间很短的情况下非常有效。但是在临界资源被持有时间很长或不确定的情况下，忙-等待机制则会浪费宝贵的CPU时间。针对这种情况，Linux中提供了另外一种实现同步的机制——信号量。实际上在Linux提供了两种信号量，即内核信号量（供内核代码使用）和System V IPC信号量（供用户进程间通信使用）。下面我们讨论内核信号量。</p><p>&emsp;&emsp;信号量与自旋锁最大的不同点在于，当一个任务试图去获取一个已经被占用的信号量的时候，该任务不会像在自旋锁机制中那样，不断地进行“自旋”直到获得该锁，相反在信号量机制中，如果该任务发现它申请的信号量正在被占用，也就是它发现它现在不可以获取该信号量，那么该任务会被添加到一个等待队列中去睡眠，当持有信号量的进程释放信号量以后，处于等待队列中的那个任务将被唤醒，并获得该信号量。因此，也称Linux中的内核信号量是一种睡眠锁。这也就是说持有信号量的函数可能会睡眠，这就要求只有可以睡眠的函数才可以使用信号量，这也就意味着不可以在中断处理程序中使用信号量，因为它是不可以睡眠的。</p><p>&emsp;&emsp;信号量与自旋锁还有一点区别就是信号量允许被多个任务持有，而自旋锁在同一时刻只允许一个任务持有它。根据信号量是否可以被多个任务所持有，可以将信号量分为互斥信号量和计数信号量。互斥信号量表示，在任意时刻至多允许一个任务持有，通常用于多个任务互斥地访问某一临界资源时。而计数信号量允许在一个时刻至多有count个任务持有，count为信号到来时计数器的初始值，其取值在信号量初始化时确定。计数信号量用于对特定代码加以限制，内核中使用它的机会不多，内核中使用的信号量基本上都是互斥信号量。</p><h2 id="一、普通信号量"><a href="#一、普通信号量" class="headerlink" title="一、普通信号量"></a>一、普通信号量</h2><p>&emsp;&emsp;信号量同步机制由DijKstra提出，之后它逐渐成为了一种常用的锁机制。在长期且广泛的应用中，信号量机制又得到了很大的发展，出现了基于该思想的各种变体。现在信号量机制广泛应用于各种操作系统之中。除了初始化之外，信号量只能通过两个原子操作P()和V()访问。前者是测试操作，后者是增加操作。后来的系统把这两种操作分别叫做<code>down()</code>和<code>up()</code>，Linux也遵循这种叫法。</p><p>&emsp;&emsp;<code>down()</code>操作通过对信号量计数器减1来请求获得一个信号量。如果结果是0或大于0，获得信号量锁，任务就可以进入临界区；如果结果是负数，任务就会被放入等待队列中，处理器执行其他任务。相反，当临界区中的操作完成后，可以调用<code>up()</code>操作来释放信号量，它会增加信号量的计数器。如果在该信号量上的等待队列不为空，那么处于队列中等待的任务在被唤醒的同时会获得该信号量。</p><p>&emsp;&emsp;信号量机制的实现与体系结构有关，下面主要讨论在32位的x86体系结构下信号量的实现。普通信号量的数据结构使用<code>struct semaphore</code>来表示，该结构定义在<code>include/asm-x86/semaphore_32.h</code>中，结构如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">semaphore</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">atomic_t</span> count;</span><br><span class="line">    <span class="keyword">int</span> sleepers;</span><br><span class="line">    <span class="keyword">wait_queue_head_t</span> wait;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>count</code>：成员变量时信号量的计数器，该变量定义为<code>atomic_t</code>结构，从而保证了对该变量的操作为原子操作。当<code>count</code>大于0时，表示该信号量此时是空闲的，可以使用；当<code>count</code>等于0时，表示该信号量现在不可以用，但是并没有其他进程在等待这个信号量被释放；当<code>count</code>小于0时，表示该信号量现在不可以用，并且至少有一个任务也在等待该信号量被释放。</p><p>&emsp;&emsp;信号量与自旋锁的不同点的第二条就是它可以同时允许任意数量的锁持有者，而这正是通过设置该成员变量的值来实现的，当初始化一个信号量的时候，可以用<code>count</code>的值来指定有多少个任务可以同时持有该信号量。</p><p>&emsp;&emsp;<code>sleepers</code>：该成员变量用来存放一个标志，表示是否有任务在该信号量的等待队列上睡眠，当没有任务在该信号量的等待队列上睡眠的时候被设置为0，否则设置为1.</p><p>&emsp;&emsp;<code>wait</code>：该成员变量是一个链表头，用来将所有等待该信号量的睡眠进程组织成一个链表结构。</p><p>&emsp;&emsp;Linux内核为普通信号量同步机制提供了一系列的操作函数，操作函数原型及其描述如下：</p><table><thead><tr><th>函数原型</th><th>描述</th></tr></thead><tbody><tr><td>sema_init(struct semaphore *sem,int val)</td><td>初始化执行的信号量sem的计数器初始值为val，并初始化信号量的其他两个成员变量</td></tr><tr><td>init_MUTEX(struct semaphore *sem)</td><td>初始化指定的信号量sem为一个互斥信号量</td></tr><tr><td>int_MUTEX_LOCKED(struct semaphore *)</td><td>初始化指定的信号量sem为一个互斥信号量，同时将count的值赋为0，即该信号量初始状态为加锁状态</td></tr><tr><td>down(struct semaphore *sem)</td><td>试图去获取指定的信号量sem，如果发现该信号量当前不可以获取，则进入不可中断睡眠状态</td></tr><tr><td>down_interruptible(struct semaphore*)</td><td>试图获取指定的信号量sem，如果发现该信号量当前不可以获取，则进入可中断睡眠状态</td></tr><tr><td>down_trylock(struct semaphore * sem)</td><td>试图获取指定的信号量sem，如果发现该信号量当前不可以获取，则立即返回一个非0值</td></tr><tr><td>up(struct semaphore *sem)</td><td>释放指定的信号量sem，同时如果该信号量的等待队列不为空的话，就唤醒其中的一个等待进程</td></tr></tbody></table><p>&emsp;&emsp;信号量的获取和释放过程分别由函数<code>down()</code>和<code>up()</code>完成。</p><ol><li><h3 id="获取信号量的处理过程"><a href="#获取信号量的处理过程" class="headerlink" title="获取信号量的处理过程"></a>获取信号量的处理过程</h3><p>&emsp;&emsp;普通信号量的获取是由函数<code>down()</code>完成的，该函数定义在<code>include/asm-x86/semaphore_32.h</code>中，代码如下:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">down</span><span class="params">(struct sempahore *sem)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    might_sleep();</span><br><span class="line">    _asm__volatile_(</span><br><span class="line">    <span class="string">"# atomic down operation\n\t"</span></span><br><span class="line">    LOCK_PREFIX<span class="string">"decl %0\n\t"</span>/</span><br><span class="line">    <span class="string">"jns 2f/n"</span></span><br><span class="line">    <span class="string">"\tlea %0,%%eax\n\t"</span></span><br><span class="line">    <span class="string">"call_down_failed\n"</span></span><br><span class="line">    <span class="string">"2:"</span></span><br><span class="line">    :<span class="string">"+m"</span>(sem-&gt;count)</span><br><span class="line">    :</span><br><span class="line">    :<span class="string">"memory"</span>,<span class="string">"ax"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第3行代码中的<code>might_sleep()</code>函数检查是否需要重新调度。如果是，则调用<code>schedule()</code>函数进行重新调度。</p><p>将第5~10行内嵌汇编代码展开后，对应的汇编代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#atomic down operation</span><br><span class="line">LOCK_PREFIX decl %0</span><br><span class="line">jns 2f</span><br><span class="line">lea %0,%%eax</span><br><span class="line">call_down_failed</span><br><span class="line">2:</span><br></pre></td></tr></table></figure><p>第2~3行以原子的方式从信号量计数器count上减1，然后判断运算结果是否为负值。如果结果不为负，跳转到标号名称为2的位置，即第105行，从该函数中退出；当结构为负值时，表示该信号量不可用，则执行第4-5行代码。</p><p>第4~5行代码首先使用<code>lea</code>汇编指令将信号量<code>sem</code>的地址保存到寄存器<code>%eax</code>中（结构的第一个成员变量的地址就是该结构的地址），然后调用<code>_down_failed()</code>函数进行处理，当该函数返回时，任务也就获得了信号量的使用权。</p><p>原代码中第11~13行为内嵌汇编代码的输入、输出列表以及破坏性描述部分。</p><p><code>_down_failed()</code>函数在获取信号量失败时被调用，负责将任务插入到信号量<code>sem</code>的等待队列中，然后调用调度器，释放处理器的使用权。该函数定义在<code>arch/x86/lib/semaphore_32.S</code>中，代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">ENTRY(_down_failed)</span><br><span class="line">    CFI_STARTPROC</span><br><span class="line">    FRAME</span><br><span class="line">    push %edx</span><br><span class="line">    CFI_ADJUST_CFA_OFFSET 4</span><br><span class="line">    CFI_REL_OFFSET edx,0</span><br><span class="line">    pushl %ecx</span><br><span class="line">    CFI_ADJUST_CFA_OFFSET 4</span><br><span class="line">    CFI_REL_OFFSET ecx,0</span><br><span class="line">    call _down</span><br><span class="line">    popl %ecx</span><br><span class="line">    CFI_ADJUST_CFA_OFFSET -4</span><br><span class="line">    CFI_RESTORE ecx</span><br><span class="line">    popl %edx</span><br><span class="line">    CFI_ADJUST_CFA_OFFSET -4</span><br><span class="line">    CFI_RESTORE ecx</span><br><span class="line">    popl %edx</span><br><span class="line">    CFI_ADJUST_CFA_OFFSET -4</span><br><span class="line">    CFI_RESTORE edx</span><br><span class="line">    ENDFRAME</span><br><span class="line">    ret</span><br><span class="line">    CFI_ENDPROC</span><br><span class="line">END(_down_failed)</span><br></pre></td></tr></table></figure><p>在第2、3、5、6、8、9、12、13、15、16、18~20、22行代码用于记录Linux系统内核的调试信息。</p><p>第4、7、11、14、17行代码保存寄存器<code>%edx</code>,<code>%ecx</code>的值，然后调用<code>_down()</code>函数完成在获取信号量失败时的具体1处理过程，最后恢复寄存器<code>%edx</code>,<code>%ecx</code>的值。</p><p>从对<code>_down_failed()</code>函数的汇编代码分析可知，<code>_down_failed()</code>函数实际上是<code>_down()</code>函数的封装，获取信号量失败时，由<code>_down()</code>函数完成具体的处理过程，<code>_down()</code>函数定义在<code>lib/semaphore-sleepers.c</code>中，代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">fastcall <span class="keyword">void</span> _sched_down(struct semaphore *sem)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">tsk</span>=<span class="title">currrent</span>;</span></span><br><span class="line">    DECLARE_WAITQUEUE(wait,tsk);</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> flags;</span><br><span class="line">    </span><br><span class="line">    tsk-&gt;state=TASK_UNINTERRUPTIBLE;</span><br><span class="line">    spin_lock_irqsave(&amp;sem-&gt;wait.lock,flags);</span><br><span class="line">    add_wait_queue_exclusive_locked(&amp;sem-&gt;wait,&amp;wait);</span><br><span class="line">    </span><br><span class="line">    sem-&gt;sleepers++;</span><br><span class="line">    <span class="keyword">for</span>(;;)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> sleepers=sem-&gt;sleepers;</span><br><span class="line">        <span class="keyword">if</span>(!atomic_add_negative(sleepers<span class="number">-1</span>,&amp;sem-&gt;count))</span><br><span class="line">        &#123;</span><br><span class="line">            sem-&gt;sleepers=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        sem-&gt;sleepers=<span class="number">1</span>;</span><br><span class="line">        spin_unlock_irqrestore(&amp;sem-&gt;wait.lock,flags);</span><br><span class="line">        schedule();</span><br><span class="line">        spin_lock_irqsave(&amp;sem-&gt;wait.lock,flags);</span><br><span class="line">        tsk-&gt;state=TASK_UNINTERRUPTIBLE;</span><br><span class="line">    &#125;</span><br><span class="line">    remove_wait_queue_locked(&amp;sem-&gt;wait,&amp;wait);</span><br><span class="line">    wake_up_locked(&amp;sem-&gt;wait);</span><br><span class="line">    spin_unlock_irqstore(&amp;sem-&gt;wait.lock,flags);</span><br><span class="line">    tsk-&gt;state=TASK_RUNNING;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第3~5行代码声明了该函数中将要使用的局部变量。其中，指针变量<code>tsk</code>被初始化为当前任务的进程描述符；而第4行使用宏定义<code>DECLARE_WAITQUEUE()</code>声明了一个名称为<code>wait</code>的等待队列节点。</p><p>第7~9行代码用于将上述几行代码构建的等待队列节点<code>wait</code>插入到信号量<code>sem</code>对应的等待队列队尾。其中，第7行代码设置当前任务的状态为不可中断睡眠状态(<code>TASK_UNINTERRUPTIBLE</code>);第8行代码调用<code>spin_lock_irqqseve()</code>函数获得等待队列所包含的自旋锁，禁止中断响应并将处理器标志寄存器<code>EFLAGS</code>的值保存到<code>flags</code>中，其逆操作在第23行和第28行；第9行代码将等待队列节点<code>wait</code>插入到信号量<code>sem</code>对应的等待队列队尾。</p><p>在第12~25行构成一个for循环，在任务无法获得信号量的情况下，将会一直睡眠在相应的等待队列上。该任务在阻塞过程中可能被唤醒，当该任务被唤醒后，通过第15行代码判断是否成功获得信号量的使用权。在成功获得信号量时，执行break语句跳出for循环，并执行第26-29行代码；否则，再次调用调度<code>schedule()</code>函数，释放处理器的使用权，并将任务的当前执行状态设置为不可中断睡眠状态。</p><p>第26~29行代码在任务被唤醒且获得信号量之后执行。其中，第26行将等待队列节点<code>wait</code>从等待队列中移出，第28行释放对等待队列锁包含的自旋锁，恢复处理器的标志寄存器<code>EFLAGS</code>，第29行代码设置当前任务为运行状态。</p></li><li><h3 id="释放信号量的处理过程"><a href="#释放信号量的处理过程" class="headerlink" title="释放信号量的处理过程"></a>释放信号量的处理过程</h3><p>&emsp;&emsp;普通信号量的释放由<code>up()</code>函数完成，该函数负责将信号量计数器<code>count</code>的值加1，表示信号量被释放，在有任务阻塞在该信号量的情况下，唤醒等待队列中睡眠的任务.<code>up()</code>函数定义在<code>include/asm-x86/semaphore_32.h</code>中，代码如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">up</span><span class="params">(struct semaphore *sem)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    _asm__volatile_(</span><br><span class="line">    <span class="string">"#atomic up operation\n\t"</span></span><br><span class="line">    LOCK_PREFIX<span class="string">"incl %0\n\t"</span></span><br><span class="line">    <span class="string">"jg 1f\n\t"</span></span><br><span class="line">    <span class="string">"lea %0,%%eax\n\t"</span></span><br><span class="line">    <span class="string">"call _up_wakeup\n"</span></span><br><span class="line">    <span class="string">"1:"</span></span><br><span class="line">    :<span class="string">"+m"</span>(sem-&gt;count)</span><br><span class="line">    :</span><br><span class="line">    :<span class="string">"memory"</span>,<span class="string">"ax"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;第5~6行代码执行<code>down()</code>函数的逆操作，两者的语句内容和格式也非常类似。第5行代码负责以原子方式将信号量计数器<code>count</code>的值加1.第6行代码判断是否有任务阻塞在该信号量上，如果没有，则跳转到标号名称为1的位置，从函数中退出；否则，执行第7-8行代码。</p><p>&emsp;&emsp;第7~8行的代码首先将信号量的地址保存到寄存器<code>%eax</code>中，该参数在函数调用的过程中，作为参数被传递给<code>_up_wakeup()</code>函数，由<code>_up_wakeup()</code>函数负责进一步的处理。</p><p>&emsp;&emsp;<code>_up_wakeup()</code>函数与<code>_down_failed()</code>函数相似，<code>_up_wakeup()</code>函数定义在<code>arch/x86/lib/semaphore_32.S</code>中，该函数实际上是<code>_up()</code>函数的封装，<code>_up()</code>函数定义在<code>lib/semaphore-sleepers.c</code>中，它直接调用<code>wake_up()</code>函数完成等待队列上任务的唤醒工作。</p><p>&emsp;&emsp;通过对普通信号量的获取和释放函数的分析可知，普通信号量基于原子变量和等待队列这两个变量来完成同步工作，其中的原子变量用于计数器，记录信号量的当前状态；而等待队列用于组织阻塞在该信号量上的睡眠任务。</p></li></ol><h2 id="二、读写信号量"><a href="#二、读写信号量" class="headerlink" title="二、读写信号量"></a>二、读写信号量</h2><p>&emsp;&emsp;读写信号量是在Linux2.4内核中引入的一种机制，它与自旋锁类似，将信号量也区分为读和写两种类型。读写信号量的引入提高了内核的并发度，对整个系统的性能提高有一定的帮助。</p><p>&emsp;&emsp;读写信号量在内核中是由结构体<code>rw_semophore</code>来表示的，该结构体定义在文件<code>include/asm-x86/rwsem.h</code>中，形式如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rw_semphore</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">signed</span> <span class="keyword">long</span> count;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RWSEM_UNLOCKED_VALUE 0X00000000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RWSEM_ACTIVE_BIAS 0X00000001</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RWSEM_ACTIVE_MASK 0x0000ffff</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RWSEM_WAITINT_BIAS (-0x00010000)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RWSEM_ACTIVE_READ_BAS RWSEM_ACTIVE_BIAS</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RWSEM_ACTIVE_WRITE_BIAS (RWSEM_WAITING_BIAS+RWSEM_ACTIVE_BIAS)</span></span><br><span class="line">    <span class="keyword">spinlock_t</span> wait_lock;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">wait_list</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_DEBUG_LOCK_ALLLOC</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">lockdep_map</span> <span class="title">dep_map</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>count</code>：该成员变量用于存放两个16位的计数器</p><p><code>wait_lock</code>:该成员变量是一个自旋锁，用于保护等待队列和<code>rw_semaphore</code>结构体本身。</p><p><code>wait_list</code>:该成员变量指向等待队列的链表，该链表中的每一个元素都是一个<code>rwsem_waiter</code>结构体，该结构体中包含三个成员变量，一个是指向睡眠进程的描述符的指针，另外一个是用来标识该进程是为读需要的信号量还是为写需要信号量的标志。最后一个就是用来将这些结构体连接成为一个链表结构的链表结构体。</p><p>内核同样提供了一些与读写信号量相对应的操作函数，这些操作函数的原型和描述如下：</p><table><thead><tr><th>函数原型</th><th>描述</th></tr></thead><tbody><tr><td>init_rwsem(sem)</td><td>初始化指定的读写信号量sem</td></tr><tr><td>down_read(struct rw_semaphore *sem)</td><td>用于获取指定的读锁sem，如果成功获得，直接返回，否则读者进入睡眠状态</td></tr><tr><td>up_read(struct rw_semaphore *sem)</td><td>释放持有的读锁sem</td></tr><tr><td>down_read_trylock(struct rw_semaphore *sem)</td><td>试图获得锁定的读锁sem，如果不成功，立即返回，返回值为0，否则锁定成功，返回值为1</td></tr><tr><td>down_write(struct rw_semaphore *sem)</td><td>用于获得指定的写锁sem，如果锁定成功，直接返回，否则，写者进入睡眠状态</td></tr><tr><td>up_write(struct rw_semaphore *sem)</td><td>释放指定的写锁sem</td></tr><tr><td>dwon_write_trylock(struct rw_semaphore *sem)</td><td>试图获得指定的写锁sem，如果不成功，立即返回，返回值为0，否则锁定成功，返回值为1</td></tr></tbody></table><p>&emsp;&emsp;关于读写信号量最后还需要注意的是，内核是按照先进先出(FIFO)的顺序来处理等待读写信号量的任务，Linux中是这样规定的，如果一个任务去试图获取一个信号量时，它发现该信号量现在是不可获取的，于是该任务就被添加到信号量等待队列的末尾，当信号量被释放的时候，内核会首先检查等待队列中的第一个任务，并且唤醒任务，此时，如果被唤醒的任务是一个写者任务，那么该任务获得写信号量，同时其他任务继续在等待队列中睡眠；而如果被唤醒的任务是一个读者任务，那么紧跟在该任务之后的所有读者任务都会被唤醒并获得读锁，不过该操作时不可以跳跃进行的，也就是说在写者任务之后排队的任务即使是读者任务，也不会被唤醒并拥有锁。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&amp;emsp;&amp;emsp;自旋锁同步机制是一种“忙-等待”机制，在临界资源被锁定的时间很短的情况下非常有效。但是在临界资源被持有时间很长或不确定的情况下，忙-等待机制则会浪费宝贵的CPU时间。针对这种情况，Linux中提供了另外一种实现同步的机制——信号量。实际上在Linux
      
    
    </summary>
    
      <category term="Linux内核" scheme="http://wanqbin.xyz/categories/Linux%E5%86%85%E6%A0%B8/"/>
    
    
      <category term="操作系统" scheme="http://wanqbin.xyz/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="Linux内核同步" scheme="http://wanqbin.xyz/tags/Linux%E5%86%85%E6%A0%B8%E5%90%8C%E6%AD%A5/"/>
    
      <category term="信号量" scheme="http://wanqbin.xyz/tags/%E4%BF%A1%E5%8F%B7%E9%87%8F/"/>
    
      <category term="普通信号量" scheme="http://wanqbin.xyz/tags/%E6%99%AE%E9%80%9A%E4%BF%A1%E5%8F%B7%E9%87%8F/"/>
    
      <category term="读写信号量" scheme="http://wanqbin.xyz/tags/%E8%AF%BB%E5%86%99%E4%BF%A1%E5%8F%B7%E9%87%8F/"/>
    
  </entry>
  
  <entry>
    <title>Linux内核同步机制分析——读写自旋锁</title>
    <link href="http://wanqbin.xyz/2019/08/10/Linux%E5%86%85%E6%A0%B8%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6%E5%88%86%E6%9E%90%E2%80%94%E2%80%94%E8%AF%BB%E5%86%99%E8%87%AA%E6%97%8B%E9%94%81/"/>
    <id>http://wanqbin.xyz/2019/08/10/Linux内核同步机制分析——读写自旋锁/</id>
    <published>2019-08-10T06:58:00.000Z</published>
    <updated>2019-08-10T06:59:34.856Z</updated>
    
    <content type="html"><![CDATA[<h2 id="二、读写自旋锁"><a href="#二、读写自旋锁" class="headerlink" title="二、读写自旋锁"></a>二、读写自旋锁</h2><p>&emsp;&emsp;在某些情况下，对临界资源的访问在逻辑上可以分为只读和只更新两种不同的操作。通常允许多个读者在同一时间段内访问临界资源，而只允许唯一的写者更新临界资源。这种情况下的同步问题即为操作系统中”读者/写者“问题。</p><p>&emsp;&emsp;针对这种“读者/写者”问题，Linux内核提供了一个自旋锁的变种——读写自旋锁，用于优化对此类临界资源的访问。对比普通自旋锁，读写自旋锁允许多个读者任务同时进入临界区，交错访问同一个临界资源，提高了系统同的并发能力，提升了系统的吞吐量。</p><p>&emsp;&emsp;在Linux内核中，读写自旋锁为读者和写者分别提供了不同的锁。一个或多个读者任务可以并发地持有“读锁”，而“写锁”最多只能被一个写者任务持有，并且此时不可以有并发的读操作。也就是说，“写”操作要求完全的互斥。</p><p>&emsp;&emsp;读写自旋锁变量由数据结构<code>rwlock_t</code>表示，该数据结构定义在<code>include/linux/spinlock_types.h</code>中，代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span>  <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">raw_rwlock_t</span> raw_lock;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">if</span> defined(CONFIG_PREEMPT)&amp;&amp;defined(CONFIG_SMP)</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> break_lock;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_DEGBUG_SPINLOCK</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> magic,owner_cpu;</span><br><span class="line">    <span class="keyword">void</span> *owner;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_DEBUG_LOCK_ALLOC</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">lockdep_map</span> <span class="title">dep_map</span>;</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;<span class="keyword">rwlock_t</span>;</span><br></pre></td></tr></table></figure><p><code>raw_lock</code>：该成员变量是读写自旋锁的数据结构的核心，具体的锁定过程与该成员变量密切相关。此数据结构是一个空结构体，其数据类型<code>raw_rwlock_t</code>依赖于未定义内核选项<code>CONFIG_SMP</code>的情况下，此时读写自旋锁的锁定、释放的过程分别退化为禁止、使能内核抢占。</p><p>&emsp;&emsp;<code>break_lock</code>：该无符号整型变量<code>break_lock</code>用于指示当前自旋锁是否被多个内核线程同时竞争、访问。同时依赖于内核选项<code>CONFIG_PREEMPT</code>和<code>CONFIG_SMP</code>。</p><p>&emsp;&emsp;内核在<code>include/linux/spin_lock.h</code>中提供了一系列关于读写自旋锁的操作函数接口。下表是关于读写自旋锁的操作函数。</p><table><thead><tr><th>函数原型</th><th>描述</th></tr></thead><tbody><tr><td>rwlock_init(lock)</td><td>声明一个读写自旋锁lock，将其初始化成未锁定状态</td></tr><tr><td>read_lock(lock)</td><td>用于获得指定的读锁lock，如果锁定完成，直接返回；否则循环的等待直到获得读锁</td></tr><tr><td>read_unlock(lock)</td><td>释放持有的读锁lock</td></tr><tr><td>read_lock_irq(lock)</td><td>禁止本地中断，并获取指定的读锁lock</td></tr><tr><td>read_unlock_irq(lock)</td><td>释放持有的读锁lock，并激活本地中断</td></tr><tr><td>read_lock_irqsave(lock)</td><td>保存本地中断的当前状态，禁止本地中断，并获得指定的读锁lock</td></tr><tr><td>read_unlock_irqrestore(lock,flags)</td><td>释放持有的读锁lock，并让本地中断恢复到以前的状态</td></tr><tr><td>read_trylock(lock)</td><td>试图获得指定的读锁lock，如果不成功，立即返回，返回值为0，否则锁定成功，返回值为1</td></tr><tr><td>write_lock(lock)</td><td>用于获得指定的写锁lock，如果锁定成功，直接返回，否则循环等待直到获得写锁</td></tr><tr><td>write_unlock(lock)</td><td>释放指定的写锁lock</td></tr><tr><td>write_lock_irq(lock)</td><td>禁止本地中断，并获取指定的写锁lock</td></tr><tr><td>write_lock_irqsave(lock,flags)</td><td>保存本地中断的当前状态，禁止本地终端，并获取指定的写锁lock</td></tr><tr><td>write_unlock_irqrestore(lock,flags)</td><td>释放持有的写锁lock，并让本地中断恢复到以前的状态</td></tr><tr><td>write_trylock(lock)</td><td>试图获得指定的写锁lock，如果不成功，立即返回，返回值为0，否则锁定成功，返回值为1</td></tr></tbody></table><p>&emsp;&emsp;读写自旋锁的具体实现方式和自旋锁类似，依赖于内核选项<code>CONFIG_SMP</code>。在单处理器系统中，即在未定义内核选项<code>CONFIG_SMP</code>的情况下，读写自旋锁的获得、释放过程同样退化为禁止内核抢占和使能内核抢占，其处理过程和普通自旋锁在单处理器系统的处理过程基本相同。</p><p>&emsp;&emsp;在定义了内核选项<code>CONFIG_SMP</code>的多处理器系统中，<code>raw_rwlock_t</code>结构定义在<code>include/asm-x86/spinlock_types.h</code>中，定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> lock;</span><br><span class="line">&#125; <span class="keyword">raw_rwlock_t</span>;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;从其定义可以看出，它与普通自旋锁的数据结构<code>raw_spinlock_t</code>形式一样，都只声明了一个无符号内存变量，但是使用方法却有很大的差别，正是这些差别才造就了读写自旋锁的性质。</p><p>&emsp;&emsp;读写自旋锁的获取过程分为读锁获取和写锁获取。两者的关键区别在于加锁过程从结构<code>raw_rwlock_t</code>的成员变量<code>lock</code>上减去的数值不同：每次读锁加锁过程减去1，每次写锁加锁过程减去一个常量<code>RW_lOCK_BIAS</code>(其值大小为0x01000000),即224个读者进程。读写自旋锁的释放过程与获取过程正好相反。</p><p>&emsp;&emsp;下面我们以读写自旋锁的加锁函数和释放函数为例，对读写自旋锁的实现机制进行分析。读写自旋锁又分为读锁的加锁函数与释放函数、写锁的加锁函数与释放函数。</p><ol><li><h3 id="读锁的获取与释放过程"><a href="#读锁的获取与释放过程" class="headerlink" title="读锁的获取与释放过程"></a>读锁的获取与释放过程</h3><p>&emsp;&emsp;读锁的加锁过程由宏定义<code>read_lock()</code>来完成，该宏定义在<code>include/linux/spinlock.h</code>中，代码如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> read_lock(lock)_read_lock(lock)</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;从上述代码中可以看出，宏定义<code>read_lock()</code>是由<code>_read_lock()</code>函数进行了简单的封装。在定义了内核选项<code>CONFIG_SMP</code>时，<code>_read_lock()</code>函数定义在<code>kernel/spinlock.c</code>中，代码如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> _lockfunc _read_lock(<span class="keyword">rwlock_t</span> *lock)</span><br><span class="line">&#123;</span><br><span class="line">    preempt_disable();</span><br><span class="line">    rwlock_acquire_read(&amp;lock-&gt;dep_map,<span class="number">0</span>,<span class="number">0</span>,_RET_IP_);</span><br><span class="line">    LOCK_CONTENDED(lock,_raw_read_trylock,_raw_read_lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这个函数的实现与普通自旋锁的<code>_spin_lock()</code>函数实现方式相似，都是先禁止内核抢占，然后调用<code>_raw_read_lock()</code>函数完成加锁过程。<code>_raw_read_lock()</code>函数时一个宏定义，定义在<code>include/linux/spinlock.h</code>中，代码如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _raw_read_lock(rwlock)_raw_read_lock(&amp;(rwlock)-&gt;raw_lock)</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;其中，<code>_raw_read_lock()</code>仿函数的实现与系统的体系结构有关，在32位的x86体系结构下，该函数定义在<code>include/asm-x86/spinlock_32.h</code>中，代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> _raw_read_lock(<span class="keyword">raw_rwlock_t</span> *rw)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">asm</span> <span class="title">volatile</span><span class="params">(LOCK_PREFIX<span class="string">" subl $1,(%0)\n\t</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">                    "</span>jns <span class="number">1f</span>\n<span class="string">"</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">                    "</span>call _read_lock_failed\n\t<span class="string">"</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">                    "</span><span class="number">1</span>:\n<span class="string">"</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">                    ::"</span>a<span class="string">"(rw)::"</span>memory<span class="string">");</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">&#125;</span></span></span></span><br></pre></td></tr></table></figure><p>第3~6行内嵌汇编代码展开后，对应的汇编代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">LOCK_PREFIX subl $1 ,(%0)</span><br><span class="line">jns 1f</span><br><span class="line">call _read_lock_failed</span><br><span class="line">1:</span><br></pre></td></tr></table></figure><p>第1行代码以原子方式对读写自旋锁进行减1操作。</p><p>第2~4行代码首先检查是否加锁成功（运算结果为负），如果加锁成功，直接跳转到标号名称为1的位置处，直接从函数返回；否则，调用<code>_read_lock_failed()</code>函数，重新尝试加锁操作。</p><p>定义中第7行代码是内嵌汇编代码的输入、输出列表以及破坏性描述部分。这里输入列表为空，输出列表中包含唯一的变量，即读写自旋锁的计数器，修饰该变量的限定符a表示将该变量与寄存器<code>%eax</code>相关联；破坏性描述部分这里声明了内存会被这段代码修改。</p><p>&emsp;&emsp;在32位的x86体系结构下，<code>_read_lock_failed()</code>函数定义在<code>arch/x86/lib/semaphore_32.S</code>中，代码如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">ENTRY(_read_lock_failed)</span><br><span class="line">CFI_STARTPROC</span><br><span class="line">FRAME</span><br><span class="line">2:LOCK_PREFIX</span><br><span class="line">incl(%eax)</span><br><span class="line">1:rep:nop</span><br><span class="line">cmpl $1,(%eax)</span><br><span class="line">js 1b</span><br><span class="line">LOCK_PREFIX</span><br><span class="line">decl(%eax)</span><br><span class="line">js 2b</span><br><span class="line">ENDFRAME</span><br><span class="line">ret</span><br><span class="line">CFI_ENDPROC</span><br><span class="line">END(_read_lock_failed)</span><br></pre></td></tr></table></figure><p>第2、3、12、14行代码用于记录Linux系统内核的调试信息。</p><p>第4~5行代码用于将读写自旋锁计数器的值加1.其目的是用于补偿当尝试读锁加锁但是不成功时，在读写自旋锁计数器上减去1的错误。</p><p>第6~8行代码构成了一个循环，该循环首先执行一条空指令，然后测试读写计数器当前值是否大于1.如果不大于1，继续循环等待、测试，直到计数器的值大于1.然后执行第9-14行代码。</p><p>&emsp;&emsp;第9~14行代码尝试再次以读方式锁定自旋锁，第9-10行以原子的方式从读写自旋锁的计数器上减1。第11行检查是否加锁成功，在不成功的情况下，跳转到这段代码的起始位置，重新尝试加锁；在加锁成功的情况下，顺序执行到第14行，通过<code>ret</code>指令进行函数调用的返回。</p><p>&emsp;&emsp;读写自旋锁中读锁的释放是通过宏定义<code>read_unlock()</code>来完成的。宏<code>read_unlock()</code>定义在<code>include/linux/spinlock.h</code>中，代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> read_unlock(lock)_read_unlock(lock)</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在定义了内核选项<code>CONFIG_SMP</code>时，<code>_read_unlock()</code>函数定义在<code>kernel/spinlock.c</code>中的，代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> _lockfunc _read_unlock(<span class="keyword">rwlock_t</span> *lock)</span><br><span class="line">&#123;</span><br><span class="line">    rwlock_release(&amp;lock-&gt;dep_map,<span class="number">1</span>,_RET_IP_);</span><br><span class="line">    _raw_read_unlock(lock);</span><br><span class="line">    preempt_enable();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这个函数的实现与普通自旋锁的<code>_spin_unlock()</code>函数实现方式相似，主要是通过调用<code>_raw_read_unlock()</code>函数来完成读锁的释放工作。<code>_raw_read_unlock()</code>函数定义在<code>include/linux/spinlock.h</code>中，代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _raw_read_unlock(rwlock)_raw_read_unlock(&amp;(rwlock)-&gt;raw_lock)</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;其中<code>_raw_read_unlock()</code>函数的实现与系统的体系结构相关，在32位的x86体系结构下，该函数定义在<code>include/asm-x86/spinlock_32.h</code>中，代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> _raw_read_unlock(raw_rwlock *rw)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">asm</span> <span class="title">volatile</span><span class="params">(LOCK_PREFIX <span class="string">"incl %0"</span>:<span class="string">"+m"</span>(rw-&gt;lock)::<span class="string">"memory"</span>)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;该函数的实现使用了简单的内嵌汇编代码，直接对读写自旋锁的计数器进行加1操作。</p></li><li><h3 id="写锁的加锁与释放过程"><a href="#写锁的加锁与释放过程" class="headerlink" title="写锁的加锁与释放过程"></a>写锁的加锁与释放过程</h3><p>&emsp;&emsp;写锁的加锁过程由宏定义<code>write_lock()</code>来完成，该宏定义在<code>include/linux/spinlock.h</code>中，代码如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> write_lock(lock)_write_Lock(lock)</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;从上述代码中可以看出，宏定义<code>write_lock()</code>是由<code>_write_lock()</code>函数进行了简单的封装。在定义了内核选项<code>CONFIG_SMP</code>时，<code>_write_lock()</code>函数定义在<code>kernel/spinlock.c</code>中，代码如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> _lockfunc _write_lock(<span class="keyword">rwlock_t</span> *lock)</span><br><span class="line">&#123;</span><br><span class="line">    preempt_disable();</span><br><span class="line">    rwlock_acquire(&amp;lock-&gt;dep_map,<span class="number">0</span>,<span class="number">0</span>,_RET_IP_);</span><br><span class="line">    LOCK_CONTENDED(lock,_raw_write_trylock,_raw_write_Lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这个函数的实现与普通自旋锁的<code>_spin_lock()</code>函数实现方式相似，都是先禁止内核抢占，然后调用<code>_raw_write_lock()</code>函数完成加锁过程。<code>_raw_write_lock()</code>函数时一个宏定义，定义在<code>include/linux/spinlock.h</code>中，代码如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _raw_write_lock(rwlock)_raw_write_lock(&amp;(rwlock)-&gt;raw_lock)</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;其中，<code>_raw_write_lock()</code>函数的实现与系统的体系结构相关，在32位的x86体系结构下，该函数定义在<code>include/asm-x86/spinlock_32.h</code>中，代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> _raw_write_lock(<span class="keyword">raw_rwlock_t</span> *rw)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">asm</span> <span class="title">volatile</span><span class="params">(LOCK_PREFIX<span class="string">" subl $ "</span> RW_LOCK_BIAS_STR<span class="string">",(%0)\n\t"</span></span></span></span><br><span class="line"><span class="function"><span class="params">                    <span class="string">"jz 1f\n"</span></span></span></span><br><span class="line"><span class="function"><span class="params">                    <span class="string">"call  _write_lock_failed\n\t"</span></span></span></span><br><span class="line"><span class="function"><span class="params">                   <span class="string">""</span> <span class="number">1</span>:\n<span class="string">"</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">                    ::"</span>a<span class="string">"(rw):"</span>memory<span class="string">");</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">&#125;</span></span></span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;第3~6行内嵌汇编代码展开后，对应的汇编代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">LOCK_PREFIX subl $ RW_LOCK_BIAS_STR,(%0)</span><br><span class="line">jz 1f</span><br><span class="line">call __write_lock_failed</span><br><span class="line">1:</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;第1行代码中的常量字符串<code>RW_LOCK_BIAS_STR</code>定义在<code>include/asm-x86/rwlock.h</code>中，常量字符串的值为0x01000000。该行代码的含义是以原子方式从读写自旋锁计数器中减去一个常量0x01000000.</p><p>&emsp;&emsp;第2~3行代码首先检查是否加锁成功（运算结果为负），如果加锁成功，直接跳转到标号名称为1的位置处，直接从函数返回，否则调用<code>_write_lock_failed()</code>函数，重新尝试进行加锁操作。</p><p>&emsp;&emsp;第4行代码是内嵌汇编代码的输入、输出列表以及破坏性描述部分。在这里输入列表为空，输出列表中包含唯一的变量，即读写自旋锁的计数器，修饰该变量的限定符a表示将该变量与寄存器<code>%eax</code>相关联；破坏性描述符部分在这里声明了内存会被这段代码修改。</p><p>&emsp;&emsp;在32位的x86体系结构下，<code>_write_lock_failed()</code>函数定义为<code>arch/x86/lib/semaphore_32.S</code>中，代码如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">ENTRY(_write_lock_failed)</span><br><span class="line">CFI_STARTPROC simple</span><br><span class="line">FRAME</span><br><span class="line">2:LOCK_PREFIX</span><br><span class="line">addl $ RW_LOCK_BIAS,(%eax)</span><br><span class="line">1:rep:nop</span><br><span class="line">cmpl $ RW_LOCK_BIAS,(%eax)</span><br><span class="line">jne 1b</span><br><span class="line">LOCK_PREFIX</span><br><span class="line">subl $ RW_LOCK_BIAS,(%eax)</span><br><span class="line">jnz 2b</span><br><span class="line">ENDFRAME</span><br><span class="line">ret</span><br><span class="line">CFI_ENDPROC</span><br><span class="line">END(_write_lock_failed)</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;第2、3、12、14行代码用于记录Linux系统内核的调试信息。</p><p>&emsp;&emsp;第4~5行代码用于将读写自旋锁计数器的值加一个常量<code>RW_LOCK_BIAS</code>。其目的是：用于补偿当尝试加锁但不成功时，在读写自旋锁计数器上减去常量<code>RW_LOCK_BIAS</code>的错误。</p><p>&emsp;&emsp;第6~8行代码构成一个循环，该循环首先执行一条空指令，然后测试读写计数器当前值是否等于常量<code>RW_LOCK_BIAS</code>，在相等的情况下，继续循环等待、测试，直到计数器的值等于常量<code>RW_LOCK_BIAS</code>，然后执行9-13行的代码。</p><p>&emsp;&emsp;第9~13行代码尝试再次以写的方式锁定自旋锁。第9-10行以原子的方式从读写自旋锁的计数器上减去一个常量<code>RW_LOCK_BIAS</code>。第11行检查是否加锁成功，在不成功的情况下，跳转到这段代码的起始位置，重新尝试加锁；在成功的情况下，顺序执行到第13行，通过指令<code>ret</code>进行函数调用的返回。</p><p>&emsp;&emsp;读写自旋锁中写锁的释放是通过宏定义<code>write_unlock()</code>来完成的。宏<code>write_unlock()</code>定义在<code>include/linux/spinlock.h</code>中，代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> write_unlock(lock)_write_unlock(lock)</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在定义了内核选项<code>CONFIG_SMP</code>时，<code>_write_unlock()</code>函数定义在<code>kernel/spinlock.c</code>中，代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> _lockfunc _write_unlock(<span class="keyword">rwlock_t</span> *lock)</span><br><span class="line">&#123;</span><br><span class="line">    rwlock_release(&amp;lock-&gt;dep_map,<span class="number">1</span>,_RET_IP_);</span><br><span class="line">    _raw_write_unlock(lock);</span><br><span class="line">    preempt_enable();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这个函数的实现与普通自旋锁的<code>_spin_unlock()</code>函数实现方式相似，主要是通过调用<code>_raw_write_unlock()</code>函数来完成读锁的释放工作。<code>_raw_write_unlock()</code>函数定义在<code>include/linux/spinlock.h</code>中，代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _raw_write_unlock(rwlock)_raw_write_unlock(&amp;(rwlock)-&gt;raw_lock)</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;其中 <code>_raw_write_unlock()</code>函数的实现与系统的体系结构相关，在32位的x86体系结构下，该函数定义在<code>include/asm-x86/spinlock_32.h</code>中，代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> _raw_write_unlock(<span class="keyword">raw_rwlock_t</span> *rw)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">asm</span> <span class="title">volatile</span><span class="params">(LOCK_PREFIX<span class="string">" addl $ "</span>RW_LOCK_BIAS_STR<span class="string">"，%0</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">                    :"</span>+m<span class="string">"(rw-&gt;lock)::"</span>memory<span class="string">");</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">&#125;</span></span></span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;该函数的实现使用了很简单的内嵌汇编代码，直接对读写自旋锁的计数器加上一个常量0x01000000操作1.</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;二、读写自旋锁&quot;&gt;&lt;a href=&quot;#二、读写自旋锁&quot; class=&quot;headerlink&quot; title=&quot;二、读写自旋锁&quot;&gt;&lt;/a&gt;二、读写自旋锁&lt;/h2&gt;&lt;p&gt;&amp;emsp;&amp;emsp;在某些情况下，对临界资源的访问在逻辑上可以分为只读和只更新两种不同的操作。通
      
    
    </summary>
    
      <category term="Linux内核" scheme="http://wanqbin.xyz/categories/Linux%E5%86%85%E6%A0%B8/"/>
    
    
      <category term="操作系统" scheme="http://wanqbin.xyz/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="Linux内核同步" scheme="http://wanqbin.xyz/tags/Linux%E5%86%85%E6%A0%B8%E5%90%8C%E6%AD%A5/"/>
    
      <category term="Linux内核" scheme="http://wanqbin.xyz/tags/Linux%E5%86%85%E6%A0%B8/"/>
    
      <category term="读写自旋锁" scheme="http://wanqbin.xyz/tags/%E8%AF%BB%E5%86%99%E8%87%AA%E6%97%8B%E9%94%81/"/>
    
  </entry>
  
  <entry>
    <title>Linux内核同步机制分析——普通自旋锁</title>
    <link href="http://wanqbin.xyz/2019/08/10/Linux%E5%86%85%E6%A0%B8%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6%E2%80%94%E2%80%94%E6%99%AE%E9%80%9A%E8%87%AA%E6%97%8B%E9%94%81/"/>
    <id>http://wanqbin.xyz/2019/08/10/Linux内核同步机制——普通自旋锁/</id>
    <published>2019-08-10T04:54:00.000Z</published>
    <updated>2019-08-10T04:55:08.325Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;在Linux中还提供了一种称为“加锁”的机制来避免竞争条件的出现。之所以引入锁机制是因为在真正的Linux内核编程过程中简单的原子操作时不能满足系统需要的，例如当一个临界区跨越了多个函数的时候，这时原子操作就显得无能为力了。</p><p>&emsp;&emsp;首先我们来看自旋锁（spin lock），在前面我们将Linux中提供的锁机制做了一个比喻，我们将临界区比作放在一个房间内的资源，而任何人（线程）如果想使用这些资源则必须首先进入该房间，也就是通过该房间唯一的一道门进入房间后才可以使用这些资源，在这里自旋锁就相当于这个房间的门钥匙，正常情况这把钥匙会挂在门旁边的一个地方，任何人（线程）想进入该房间必须首先拥有这个房间的房门钥匙才可以打开房门进入房间，而之所以称为“自旋锁”也是根据它的实现机制来命名的，该锁规定当一个人（线程）到达房间门口后，发现房门已经锁上，并且钥匙不在门旁边挂着，也就是说明现在房间里有人，那么该人（线程）就会在门外一直等待，直到房间里面的人出来了，该等待的人（线程）就会拿起钥匙，然后进入房间。而对于线程来说，在“门外一直等待”也就是说让线程一直忙循环。</p><p>&emsp;&emsp;这样Linux就利用自旋锁机制保证了任意时刻，只有一个执行线程进入临界区，也就避免了竞争条件的出现。</p><h2 id="一、普通自旋锁"><a href="#一、普通自旋锁" class="headerlink" title="一、普通自旋锁"></a>一、普通自旋锁</h2><ul><li>自旋锁机制让后来的线程一直进行忙循环，这对系统的性能不会有影响吗？其实内核这样做确实会对系统的性能有一些影响，这也就要求用户在实际编程的过程中需要注意，自旋锁不应该被长时间持有，自旋锁适用于短时间内进行轻量级加锁。</li><li>自旋锁是绝对不可以递归使用的。这是因为如果一个线程试图去获得一个它已经持有的自旋锁的时候，它首先会进入忙等待，而当该进程进入忙循环状态的时候，它也就是没有机会去释放现在已经持有的自旋锁，也就是说该进程等待的自旋锁永远也不可能获取到，于是该线程就会被自己锁死了。</li></ul><p>&emsp;&emsp;总体来说，一个自旋锁是一个互斥实体，只能被一个执行路径拥有，它有且只有两个状态：加锁、解锁。通常由一个整数变量的取值来表示。如果内核代码需要访问和修改一个自旋锁变量保护的资源，该内核代码就需要去获得相应的自旋锁，如果获取成功，则进入临界区，对临界资源进行操作；如果没有成功获得，则内核代码就反复检查这个锁的状态，直到获得这个自旋锁。</p><p>&emsp;&emsp;自旋锁变量的数据类型由数据结构<code>spinlock_t</code>表示，该是数据结构定义在<code>include/linx/spinloc_types.h</code>中，结构如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">raw_spinlock_t</span> raw_lock;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">if</span> defined(CONFIG_PREEMPT)&amp;&amp;defined(CONFID_SMP)</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> break_lock;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_DEBUG_SPINLOCK</span></span><br><span class="line">    <span class="keyword">unsigned</span> ing magic,owner_cpu;</span><br><span class="line">    <span class="keyword">void</span> *owner;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_DEBUG_LOCK_ALLOC</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">lockdep_map</span> <span class="title">dep_map</span>;</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;<span class="keyword">spinlock_t</span>;</span><br></pre></td></tr></table></figure><p><code>raw_Lock</code>：该成员变量是自旋锁数据类型的核心，具体的锁定过程与该成员变量密切相关，该成员变量的类型<code>raw_spinlock_t</code>与内核选项<code>CONFIG_SMP</code>有关。</p><p><code>break_lock</code>：该无符号整型成员变量同时依赖于内核选项<code>CONFIG_PREEMPT</code>和<code>CONFIG_SMP</code>。在同时选中了这两个选项的情况下，该成员变量用于指示当前自旋锁是否被多个内核代码同时竞争、访问。</p><p>&emsp;&emsp;内核在<code>include/linux/spin_lock.h</code>中提供了一系列关于自旋锁的操作函数接口，而在<code>spin_lock.h</code>文件所引用的头文件中，有如下代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_SMP</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;asm/spinlock.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span> </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;linux/spinlock_up.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;从上述代码可以看出，关于自旋锁操作函数接口的具体实现方式和完成的工作依赖于内核选项<code>CONFIG_SMP</code>。关于自旋锁的操作函数如下表所示：</p><table><thead><tr><th>函数原型</th><th>描述</th></tr></thead><tbody><tr><td>spin_lock_init(lock)</td><td>声明一个个自旋锁lock，将其初始化成未锁定状态</td></tr><tr><td>spin_lockl(lock)</td><td>用于获得指定的自旋锁lock，如果锁定成功，直接返回，否则，循环等待直到获得自旋锁</td></tr><tr><td>spin_unlock(lock)</td><td>释放持有的自旋锁lock</td></tr><tr><td>spin_can_lock(lock)</td><td>判断指定的自旋锁是否可以锁定即是否处于可用状态，如果可以，返回1，否则返回0</td></tr><tr><td>spin_is_locked(lock)</td><td>检测指定的自旋锁lock是否处于锁定状态，如果是，则返回1，否则返回0</td></tr><tr><td>spin_trylock(lock)</td><td>试图获得指定的自旋锁lock，如果不成功，立即返回，返回值为0，否则锁定成功，返回1</td></tr><tr><td>spin_lock_irq(lock)</td><td>获取指定的自旋锁lock，并禁止本地中断</td></tr><tr><td>spin_unlock_irq(lock)</td><td>释放持有的自旋锁lock，并激活本地中断</td></tr><tr><td>spin_lock_irqsave(lock,flags)</td><td>保存本地中断的当前状态，禁止本地中断，并获得指定的自旋锁lock</td></tr><tr><td>spin_unlock_irqrestore(lock,flags)</td><td>释放持有的自旋锁lock，并让本地中断恢复到以前的状态</td></tr></tbody></table><ol><li><h3 id="单处理器系统下自旋锁的实现"><a href="#单处理器系统下自旋锁的实现" class="headerlink" title="单处理器系统下自旋锁的实现"></a>单处理器系统下自旋锁的实现</h3><p>&emsp;从文件<code>spin_lock.h</code>所引用的头文件可以看出，在单处理器系统（也即是在没有定义内核选项<code>CONFIG_SMP</code>的情况下）中，自旋锁操作函数接口的实现定义在<code>include/linux/spinlock_up.h</code>中。</p><p>&emsp;&emsp;<code>raw_spinlock_t</code>结构在单处理器系统下退化为一个空的结构体，其定义在<code>include/spin_lock_types_up.h</code>中，代码如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span> &#125; <span class="keyword">raw_spinlock_t</span>;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;自旋锁的加锁函数<code>spin_lock()</code>是一个宏定义，该宏定义在<code>include/linux/spinlock.h</code>中，它不依赖于任何选项，定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> spin_lock(lock)    _spin_lock(lock)</span></span><br></pre></td></tr></table></figure><p><code>_spin_lock(lock)</code>在没有定义内核选项<code>CONFIG_SMP</code>时，定义在<code>include/linux/spinlock_api_up.h</code>中，定义如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _spin_lock(lock)  _LOCK(lock)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _LOCK(lock)\</span></span><br><span class="line"><span class="keyword">do</span>&#123;preempt_disable(); _acquire(lock);(<span class="keyword">void</span>)(lock);&#125;<span class="keyword">while</span>(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;其中<code>preempt_disable()</code>函数用于禁止内核抢占，它与<code>preempt_enable()</code>函数配对使用。<code>_acquire(lock)</code>函数与<code>_release(lock)</code>配对使用，用做内核编译过程中静态检查自旋锁的加锁操作与释放操作是否成对匹配。<code>void(lock)</code>不做任何处理，只是为了引用一下变量<code>lock</code>，避免编译器对未使用变量的警告。</p><p>&emsp;&emsp;通过对<code>_spin_lock()</code>函数的分析可知，在单处理器系统中，自旋锁的锁定过程并没有真正的加锁操作，只是用来禁止内核抢占。</p><p>&emsp;&emsp;自旋锁的释放函数<code>spin_unlock()</code>是一个宏定义，在没有定义内核选项<code>CONFIG_SMP</code>时，该宏定义在<code>include/linux/spinlock.h</code>中，代码如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> spin_unlock(lock)_spin_unlock(lock)</span></span><br></pre></td></tr></table></figure><p><code>_spin_unlock()</code>宏定义在没有内核选项<code>CONFIG_SMP</code>时，定义在<code>include/linux/spinlock.h</code>中，代码如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _spin_unlock(lock) _UNLOCK(lock)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _UNLOCK(lock)\</span></span><br><span class="line"><span class="keyword">do</span>(preempt_enable();  _release(lock); (<span class="keyword">void</span>)(lock);&#125; <span class="keyword">while</span>(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;该宏定义的具体处理过程与加锁函数<code>_LOCK(lock)</code>宏定义非常相似。</p></li><li><h3 id="多处理器系统下自旋锁的实现"><a href="#多处理器系统下自旋锁的实现" class="headerlink" title="多处理器系统下自旋锁的实现"></a>多处理器系统下自旋锁的实现</h3><p>&emsp;&emsp;在定义了内核选项<code>CONFIG_SMP</code>的多处理器系统中，<code>raw_spinlock_t</code>结构定义在<code>include/asm-x86/spinlock_types.h</code>中，定义如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> slock;</span><br><span class="line">&#125;<span class="keyword">raw_spinlock_t</span>;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;从其定义可以看出，<code>raw_spinlock_t</code>数据结构与原子变量数据结构的定义类似，都声明了一个内存佰利联，用于计数工作。当<code>slock</code>的值为1时，表示自旋锁处于非锁定状态；否则，表示处于锁定状态。</p><p>&emsp;&emsp;虽然自旋锁的加锁函数<code>spin_lock()</code>和单处理器的加锁函数使用同一宏定义，但是实现该宏定义的实现函数<code>_spin_lock(lock)</code>却不相同。在多处理器系统中，<code>_spin_lock()</code>函数定义在<code>kernel/spinlock.c</code>中，定义如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> _lockfunc _spin_lock(<span class="keyword">spinlock_t</span> *lock)</span><br><span class="line">&#123;</span><br><span class="line">    preempt_disable();</span><br><span class="line">            spin_acquire(&amp;lock-&gt;dep_map,<span class="number">0</span>,<span class="number">0</span>,_RET_IP_);</span><br><span class="line">    LOCK_CONTENDED(lock,_raw_spin_trylock,_raw_spin_lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第3行函数<code>preempt_disable()</code>表示禁止内核抢占。</p><p>第4行函数<code>spin_acquire()</code>在定义内核选项<code>CONFIG_DEGBUG_LOCK_ALLOC</code>的情况下用于获得锁定自旋锁lock时的依赖信息，用于内核调试。如果没有这个内核选项，则该函数是一个空函数，什么也不做。</p><p>第5行函数<code>LOCK_CONTENDED()</code>是一个关联函数，定义在<code>include/linux/lockdep.h</code>中，在没有定义内核选项<code>CONFIG_LOCK_STAT</code>的情况下，代码如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCK_CONTENDED(_lock,try,lock)\</span></span><br><span class="line">lock(_lock)</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;从该函数定义可知，调用函数<code>LOCK_CONTENDED(lock,_raw_spin_trylock,_raw_spin_lock)</code>与直接调用<code>_raw_spin_lock(lock)</code>函数是等价的，宏定义<code>_raw_spin_lock()</code>完成具体的加锁过程。</p><p><code>_raw_spin_lock(lock)</code>宏定义在<code>include/linux/spinlock.h</code>中，代码如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _raw_spin_lock(lock)_raw_spin_lock(&amp;(Lock)-&gt;raw_lock)</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;该宏定义以自选项的计数<code>raw_lock</code>为参数，调用<code>_raw_spin_lock()</code>函数来完成自旋锁的实际加锁过程，<code>_raw_spin_lock()</code>函数的实现与体系结构有关。在x86体系结构下，函数定义在<code>include/asm-x86/spinlock_32.h</code>中，代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> _raw_spin_lock(<span class="keyword">raw_spinlock_t</span> *lock)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">asm</span> <span class="title">volatile</span><span class="params">(<span class="string">"\n1:\t"</span></span></span></span><br><span class="line"><span class="function"><span class="params">                     LOCK_PREFIX<span class="string">";decb %0\n\t"</span></span></span></span><br><span class="line"><span class="function"><span class="params">                     <span class="string">"jns 3f\n"</span></span></span></span><br><span class="line"><span class="function"><span class="params">                     <span class="string">"2:\t"</span></span></span></span><br><span class="line"><span class="function"><span class="params">                     <span class="string">"rep:nop\n\t"</span></span></span></span><br><span class="line"><span class="function"><span class="params">                     <span class="string">"cmpb $0,%0\n\t"</span></span></span></span><br><span class="line"><span class="function"><span class="params">                     <span class="string">"jle 2b\n\t"</span></span></span></span><br><span class="line"><span class="function"><span class="params">                     <span class="string">"jmp 1b\n"</span></span></span></span><br><span class="line"><span class="function"><span class="params">                     <span class="string">"3:\n\t"</span></span></span></span><br><span class="line"><span class="function"><span class="params">                     :<span class="string">"+m"</span>(lock-&gt;slock)::<span class="string">"memory"</span>)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第3~11行内嵌汇编代码展开后，对应的汇编代码如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1：LOCK_PREFIX;deb %0</span><br><span class="line">        jns 3f</span><br><span class="line">2：rep;nop</span><br><span class="line">       cmpb $0,%0</span><br><span class="line">       jle 2b</span><br><span class="line">       jmp 1b</span><br><span class="line"> 3:</span><br></pre></td></tr></table></figure><p>第1行代码首先声明一个名称为1的标号，然后使用汇编指令<code>decb</code>对占位符<code>%0</code>进行减1操作。注意，这里使用了前缀<code>LOCK_PREFIX</code>，用于在SMP系统中保证<code>decb</code>汇编指令操作的原子性。</p><p>第2行代码中的汇编指令<code>jns(jump if not sign)</code>判断第1行的操作是否导致了状态寄存器<code>EFLAGS</code>中的SF状态位，如果置位，说明在执行第1行指令时占位符<code>%0</code>对应变量的值小于等于0，即自旋锁已被其他内核代码锁定，此时顺序执行；否则跳转到名称为3的标号处，此时说明已经成功获得了自旋锁。</p><p>第3~5行代码首先重新执行空指令<code>nop</code>，然后判断占位符<code>%0</code>的值时候小于等于0.在小于等于0的情况下，说明占位符<code>%0</code>对应的自旋锁处于锁定状态，此时跳回到名称为2的标号处继续顺序执行，否则，说明在上面的循环过程中，占位符<code>%0</code>对应的自旋锁被释放了，此时顺序执行到第6行处的跳转指令。</p><p>第6行代码是一个跳转指令，直接跳转到名称为1的标号处，尝试对自旋锁进行新的加锁过程。</p><p>在<code>_raw_spin_lock()</code>定义的第12行代码中，<code>“+m”(lock-&gt;slock)</code>表示把<code>raw_spinlock_t</code>数据类型变量<code>lock</code>的成员<code>slock</code>作为内嵌汇编代码的输入输出的内存变量，其对应的占位符为<code>%0</code>。<code>memory</code>表示该内嵌汇编代码会破坏内存，确保内存变量不会被优化、缓存到寄存器，从而使每次访问时，必须到对应的地址中去，避免了因优化导致的程序错误。</p><p>&emsp;&emsp;从对<code>_raw_spin_lock()</code>函数代码1的分析可知，该函数实现了在SMP系统中对自旋锁<code>lock</code>的加锁操作。如果加锁成功，则直接返回，否则，进行重复的尝试直到加锁成功。</p><p>&emsp;&emsp;自旋锁的加锁函数<code>spin_lock()</code>和单处理器的加锁函数使用同一个宏定义，但是实现该宏定义的实现函数<code>_spin_lock(lock)</code>却不相同。在多处理器系统中，<code>_spin_lock()</code>函数定义在<code>kernel/spinlock.c</code>中，定义如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> _lockfunc _spin_unlock(<span class="keyword">spinlock_t</span> *lock)</span><br><span class="line">&#123;</span><br><span class="line">    spin_release(&amp;lock-&gt;dep_map,<span class="number">1</span>,_RET_IP_);</span><br><span class="line">    _raw_spin_unlock(lock);</span><br><span class="line">    preempt_enable();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第3行中的函数<code>spin_release()</code>定义在内核选项<code>CONFIG_DEGBUG_LOCK_ALLOC</code>的情况下用于获得释放自旋锁lock时的依赖信息，主要用于内核的调试。如果没有这个内核选项，则该函数时一个空函数，什么也不做。</p><p>第4行代码调用<code>_raw_spin_unlock()</code>函数完成自旋锁的释放。</p><p>第5行代码调用<code>preempt_enable()</code>函数使内核能被抢占。</p><p><code>_raw_spin_unlock()</code>是一个宏定义，其定义在<code>include/linux/spinlock.h</code>中，代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _raw_spin_unlock(lock)  _raw_spin_unlock(&amp;(lock)-&gt;raw_lock)</span></span><br></pre></td></tr></table></figure><p><code>_raw_spin_unlock()</code>函数完成释放自旋锁的具体工作，该函数的实现与体系结构有关，在x86体系结构下，该函数定义在<code>include/asm-x86/spinlock_32.h</code>中，代码如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> _raw_spin_unlock(<span class="keyword">raw_spinlock_t</span> *lock)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">asm</span> <span class="title">volatile</span><span class="params">(<span class="string">"mov $1,%0"</span>:<span class="string">"=m"</span>(lock-&gt;slock)::<span class="string">"memory"</span>)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这段内嵌汇编代码将<code>raw_spinlock_t</code>结构类型的变量<code>lock</code>的成员<code>slock</code>设置为1，表示自旋锁变为可用状态。</p><p>&emsp;&emsp;从自旋锁的实现机制分析可知，自旋锁的工作原理如下：当系统是单处理器系统时，自旋锁的加锁、释放过程分别退化为禁止内核抢占、使能内核抢占。在SMP系统中，当锁定一个自旋锁时，需要首先禁止内核抢占，然后尝试锁定自旋锁，在锁定失败时，需要首先禁止内核抢占，然后尝试锁定自旋锁，在锁定失败时执行一个死循环等待自旋锁被释放；当释放一个自旋锁时，首先释放当前自旋锁，然后使能内核抢占。</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&amp;emsp;&amp;emsp;在Linux中还提供了一种称为“加锁”的机制来避免竞争条件的出现。之所以引入锁机制是因为在真正的Linux内核编程过程中简单的原子操作时不能满足系统需要的，例如当一个临界区跨越了多个函数的时候，这时原子操作就显得无能为力了。&lt;/p&gt;
&lt;p&gt;&amp;emsp
      
    
    </summary>
    
      <category term="Linux内核" scheme="http://wanqbin.xyz/categories/Linux%E5%86%85%E6%A0%B8/"/>
    
    
      <category term="操作系统" scheme="http://wanqbin.xyz/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="Linux内核" scheme="http://wanqbin.xyz/tags/Linux%E5%86%85%E6%A0%B8/"/>
    
      <category term="自旋锁" scheme="http://wanqbin.xyz/tags/%E8%87%AA%E6%97%8B%E9%94%81/"/>
    
      <category term="普通自旋锁" scheme="http://wanqbin.xyz/tags/%E6%99%AE%E9%80%9A%E8%87%AA%E6%97%8B%E9%94%81/"/>
    
      <category term="内核同步" scheme="http://wanqbin.xyz/tags/%E5%86%85%E6%A0%B8%E5%90%8C%E6%AD%A5/"/>
    
  </entry>
  
  <entry>
    <title>Linux内核同步机制分析——原子操作</title>
    <link href="http://wanqbin.xyz/2019/08/09/inux%E5%86%85%E6%A0%B8%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6%E5%88%86%E6%9E%90%E2%80%94%E2%80%94%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C/"/>
    <id>http://wanqbin.xyz/2019/08/09/inux内核同步机制分析——原子操作/</id>
    <published>2019-08-09T14:27:00.000Z</published>
    <updated>2019-08-09T14:28:33.018Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;原子操作是Linux中提供的一种实现同步的方法。所谓原子操作就是指某一操作在执行过程中是不可以被打断的，它要么全部执行完毕，要么就一点也不执行。原子原本指的是不可分割的微粒，所以原子操作也就是不可分割的指令。也就是说原子操作是绝对不会出现该操作执行了一半，内核又去执行其他操作了的情况。</p><p>&emsp;&emsp;内核提供了两组原子操作接口：一组是针对整数的原子操作，另一组是针对单独的位进行操作。在Linux支持的所有体系结构上都实现了两组原子接口。而且大多数体系结构要么原本就支持简单的原子操作，要么就为单步执行提供了锁内存总线的指令（这就确保其他操作不能同时发生）。而有些体系结构本身就不太支持原子操作，比如<code>SPARC</code>，我们则可以通过加锁的方式来实现。</p><h2 id="一、原子整数操作"><a href="#一、原子整数操作" class="headerlink" title="一、原子整数操作"></a>一、原子整数操作</h2><p>&emsp;&emsp;原子整数操作需要硬件的支持，因此它是与体系结构有关的，x86提供给用户的接口和原子类型都定义在<code>include/asm-x86/atomic.h</code>文件中，使用宏来实现。</p><p>&emsp;&emsp;原子整数操作主要用于实现资源计数，很多引用计数都是通过原子操作实现的。原子结构类型定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span><span class="keyword">int</span> counter;&#125; <span class="keyword">atomic_t</span>;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;原子整数操作，顾名思义，这是一组针对整数进行的操作，但是，该操作有几点需要特别注意的地方</p><ul><li>在Linux中的原子整数操作只能对<code>atomic_t</code>类型的数据进行操作，而不能对在C语言中用到的整数类型<code>int</code>进行操作</li><li>使用<code>atomic_t</code>的代码只能将该数据当做24位来使用。</li></ul><p>&emsp;&emsp;现在来看一下产生这两个特别的地方的原因。</p><p>&emsp;&emsp;首先是第一个，为什么Linux中给该操作定义了一个特殊的数据类型，这主要可以有如下几种原因:<br>（1）可以确保原子操作只与这种规定的特殊类型的数据一起使用，这也就保证了该类型的数据不会被传递到其他非原子操作的函数中，</p><p>（2）使用<code>atomic_t</code>类型确保了编译器不会对定义的该类型的数据进行访问，这也就是保证了原子操作最终接收到一个正确的内存地址而不是一个别名，该别名也保存了相同的值。</p><p>（3）重新定义了一个数据类型<code>atomic_t</code>，可以屏蔽到在不同体系结构上实现原子操作的差异。</p><p>&emsp;&emsp;其次，是第二个特别的地方的原因，主要是在<code>SPARC</code>体系结构上，原子操作的实现不同于其他体系结构，该体系结构上32位<code>int</code>型的低8位中设置了一个锁，这主要是由于<code>SPARC</code>体系结构对原子操作缺乏指令级的支持，所以只能利用锁来避免对原子类型数据的并发访问。</p><table><thead><tr><th>函数原型</th><th>描述</th></tr></thead><tbody><tr><td>ATOMIC_INIT(i)</td><td>用于初始化一个原子变量的值为i，并1返回这个atomic_t结构</td></tr><tr><td>atomic_read(v)</td><td>返回原子变量v的当前值</td></tr><tr><td>atomic_set(&amp;v,1)</td><td>设置原子变量v的值为i</td></tr><tr><td>atomic_add(int i,atomic_t *v)</td><td>将原子变量v的值加i</td></tr><tr><td>atomic_sub(int i,atomic_t*v)</td><td>将原子变量v的值减i</td></tr><tr><td>atomic_sub_and_test(int i.atomic_t *v)</td><td>将原子变量v的值减i，并将原子变量运算后结果为0的情况下，返回1，否则返回0</td></tr><tr><td>atomic_inc(atomic_t *v)</td><td>将原子变量v的值加1</td></tr><tr><td>atomic_dec(atomic_t *v)</td><td>将原子变量v的值减1</td></tr><tr><td>atomic_dec_and_test(atomic_t *v)</td><td>将原子变量v的值减1，并将原子运算后结果为0的情况下，返回1，否则返回0</td></tr><tr><td>atomic_inc_and_test(atomic_t *v)</td><td>将原子变量v的值加1，并将原子变量运算后结果为0的情况下返回1，否则返回0</td></tr><tr><td>atomic_add_negative(int i,atomic_t *v)</td><td>将原子变量v的值加i，并在原子变量运算结果后结果为负值的情况下返回1，否则返回0</td></tr><tr><td>atomic_add_return(int i,atomic_t *v)</td><td>将原子变量v的值加i，并返回运算后原子变量的值</td></tr><tr><td>atomic_sub_return(int i,atomic_t *v</td><td>将原子变量v的值减i，并返回运算后原子变量的值</td></tr></tbody></table><h2 id="二、原子位操作"><a href="#二、原子位操作" class="headerlink" title="二、原子位操作"></a>二、原子位操作</h2><p>&emsp;&emsp;原子位操作，就是针对数据的每一位进行操作，当然它的实现也是与体系结构相关的。其定义在<code>include/x86/bitops_32.h</code>中。</p><p>&emsp;&emsp;在这里需要注意的是原子位操作与原子整数操作不同，它不需要定义一个与该操作相对应的数据结构，因为原值位操作只是针对普通的指针进行操作的，我们可以对任何指针指向的数据进行原子位操作。Linux内核1提供了一系列原值位操作的函数。</p><table><thead><tr><th>函数原型</th><th>描述</th></tr></thead><tbody><tr><td>set_bit(int nr,volatile unsigned long *addr)</td><td>原子地设置add所指对象的第nr位</td></tr><tr><td>clear_bit(int nr,volatile unsigned long *addr)</td><td>原子地清空add所指对象的第nr位</td></tr><tr><td>change_bit(int nr,volatile unsigned long *addr)</td><td>原子地翻转add所指对象的第nr位</td></tr><tr><td>test_and_set_bit(int nr ,volatile unsigned long *addr)</td><td>原子地设置addr所指对象的第nr位，并返回原来的值</td></tr><tr><td>test_and _clear_bit(int nr ,volatile unsigned long * addr)</td><td>原子地清空addr所指对象的第nr位，并返回原来的值</td></tr><tr><td>test_and _change_bit(int nr ,volatile unsigned long * addr)</td><td>原子地翻转addr所指对象的第nr位，并返回原来的值</td></tr><tr><td>test_bit(nr,addr)</td><td>原子地返回addr所指对象的第nr位</td></tr></tbody></table><p>&emsp;&emsp;下面通过说明一个典型的操作函数<code>set_bit(int nr,volatile unsigned long *addr)</code>来分析原子位操作的具体处理过程。该函数以原子方式设置在addr所指对应的第nr位，即保证操作过程不会被打断。代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">set_bit</span><span class="params">(<span class="keyword">int</span> nr,<span class="keyword">volatile</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> *addr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    _asm__volatile_(LOCK_PREFIX</span><br><span class="line">                       <span class="string">"btsl%1,%0</span></span><br><span class="line"><span class="string">                        :"</span>+m<span class="string">"(ADDR)</span></span><br><span class="line"><span class="string">                        :"</span>Ir(nr));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第4行声明了内嵌汇编所使用的汇编指令<code>btsl</code>，用于设置占位符1%对应操作数的第%1位，然后将结果保存到占位符%0对应的变量；这里的占位符%0、%1分别对应变量<code>addr</code>和<code>nr</code>。</p><p>第5行代码声明了内嵌汇编所使用的输出变量列表。这里声明的输出变量为内存地址指针<code>addr</code>，其限定符<code>+m</code>说明该变量是一个读写类型的内存变量，即该变量既是输入变量，也是输出变量。</p><p>第6行代码声明了内嵌汇编所使用的输入变量列表。这里声明的输入变量是：代表位移的参数<code>nr</code>，其限定符<code>Ir</code>表示该变量是一个0~31的立即数，且要求编译器将该变量与处理器的某个寄存器相关联。</p><p>&emsp;&emsp;在Linux中还定义了一组与这些原子位操作相对应的非原子位操作，这些函数与原子位操作的函数所完成的功能是相同的，只是这些非原子位操作不能保证操作的原子性，其命名就是在原子位操作的函数的前面加上两个喜爱划线，如与<code>set_bit()</code>函数相对应的非原值为操作就是<code>_set_bit()</code>，其余的函数的命名方式与它完成相同。非原子位操作要比原子位操作执行速度快一些，若代码已经避免了竞争条件，那么就可以在代码中使用这些非原子位操作以提高程序的执行速度。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&amp;emsp;&amp;emsp;原子操作是Linux中提供的一种实现同步的方法。所谓原子操作就是指某一操作在执行过程中是不可以被打断的，它要么全部执行完毕，要么就一点也不执行。原子原本指的是不可分割的微粒，所以原子操作也就是不可分割的指令。也就是说原子操作是绝对不会出现该操作执行了
      
    
    </summary>
    
      <category term="Linux内核" scheme="http://wanqbin.xyz/categories/Linux%E5%86%85%E6%A0%B8/"/>
    
    
      <category term="操作系统" scheme="http://wanqbin.xyz/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="Linux内核" scheme="http://wanqbin.xyz/tags/Linux%E5%86%85%E6%A0%B8/"/>
    
      <category term="原子操作" scheme="http://wanqbin.xyz/tags/%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C/"/>
    
      <category term="原子整数操作" scheme="http://wanqbin.xyz/tags/%E5%8E%9F%E5%AD%90%E6%95%B4%E6%95%B0%E6%93%8D%E4%BD%9C/"/>
    
      <category term="原子位操作" scheme="http://wanqbin.xyz/tags/%E5%8E%9F%E5%AD%90%E4%BD%8D%E6%93%8D%E4%BD%9C/"/>
    
  </entry>
  
  <entry>
    <title>Linux内核同步机制分析——临界区与竞争条件</title>
    <link href="http://wanqbin.xyz/2019/08/09/ux%E5%86%85%E6%A0%B8%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6%E5%88%86%E6%9E%90%E2%80%94%E2%80%94%E4%B8%B4%E7%95%8C%E5%8C%BA%E4%B8%8E%E7%AB%9E%E4%BA%89%E6%9D%A1%E4%BB%B6/"/>
    <id>http://wanqbin.xyz/2019/08/09/ux内核同步机制分析——临界区与竞争条件/</id>
    <published>2019-08-09T14:26:00.000Z</published>
    <updated>2019-08-09T14:29:21.863Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;所谓临界区就是访问和操作共享数据的代码段。多个内核任务并发访问同一个资源通常是不安全的。为了避免对临界区进行并发访问，编程者必须保证临界区代码段被原子地执行，也就是说，代码段在执行期间不可被打断，就如同整个临界区是一个不可分割的指令一样。如果两个内核任务可能处于同一临界区，这可能会导致临界资源出现不一致的状态。如果确实发生了这种情况，就称它为竞争状态。</p><h2 id="一、临界区举例"><a href="#一、临界区举例" class="headerlink" title="一、临界区举例"></a>一、临界区举例</h2><p>&emsp;&emsp;为了进一步了解竞争状态，首先要明白临界区无处不在。考虑一个非常简单的、共享资源的例子：一个全局整型变量和一个简单的临界区，其中的操作仅仅是将整型变量的值增加1，即<code>i++</code>，该操作可以转化成下卖弄的机器指令序列。</p><p>（1）得到当前变量i的值并将它复制到一个寄存器中</p><p>（2）将寄存器中的值加1</p><p>（3）把i的新值写回到内存中</p><p>这三条指令形成一个临界区。现在假定有两个执行线程同时进入这个临界区，如果i的初始值是1，那么期望的结果应该如下所示：</p><table><thead><tr><th>线程1</th><th>线程2</th></tr></thead><tbody><tr><td>获得i（1）</td><td>—</td></tr><tr><td>增加i（1-&gt;2)</td><td>—</td></tr><tr><td>写回i(2)</td><td>—</td></tr><tr><td></td><td>获得i(2)</td></tr><tr><td></td><td>增加i(2-&gt;3)</td></tr><tr><td></td><td>写回i(3)</td></tr></tbody></table><p>正如期望的那样，i被两个线程分别加1变成3。但是实际的执行序列却可能如下所示：</p><table><thead><tr><th>线程1</th><th>线程2</th></tr></thead><tbody><tr><td>获得i（1）</td><td>—</td></tr><tr><td>—</td><td>获得i（1）</td></tr><tr><td>增加i(1-&gt;2)</td><td>—</td></tr><tr><td>—</td><td>增加i(1-&gt;2)</td></tr><tr><td>写回i(2)</td><td>—</td></tr><tr><td>_</td><td>写回i（2）</td></tr></tbody></table><p>&emsp;&emsp;如果两个执行线程都在变量i值增加前读取它的初值，进而又分别增加变量i的值，最后再保存该值，那么变量i的值就变成了2，而变量i的值本该是3的。这是最简单的临界区例子，幸好对这种简单竞争条件的解决办法也同样简单——我们仅仅需要将这些指令作为一个不可分割的整个来执行就可以了。多数处理器都提供了指令来原子地读变量、增加变量然后再写回变量，使用这样的指令就能解决问题。Linux内核也提供了一组实现这些原子操作的接口。</p><h2 id="二、共享队列和加锁"><a href="#二、共享队列和加锁" class="headerlink" title="二、共享队列和加锁"></a>二、共享队列和加锁</h2><p>&emsp;&emsp;下面讨论一个更为复杂的竞争状态。假定有一个需要处理的请求队列，这里假定该队列是一个链表，链表中的每个节点逻辑上代表一个“请求”。有两个函数可以用来操作此队列，一个函数将新请求添加到队列尾部，另一个函数从队列中删除请求，然后进行处理。内核各部分都会调用这两个函数，所以内核会频繁地在队列中加入请求、从队列中删除请求并对其进行处理。对请求队列的操作无疑要用到多条指令。如果一个线程试图读取队列，而这时另一个线程正在处理该队列，那么读取线程就会发现队列此刻正处于不一致状态。很明显，如果允许并发访问队列，聚会产生意想不到的错误。当共享资源是一个复杂的数据结构时，竞争状态往往会使该结构遭到破坏。</p><p>&emsp;&emsp;对于这种情况，锁机制可以避免竞争状态。这种锁就如同一把门锁，门内的房间可想象成一个临界区。在一个指定时刻，房间里只能有一个内核线程存在，当一个内核线程进入房间后，它就会锁住身后的房间；当它结束对共享数据的操作后，就会打开门锁，走出房间。如果另一个线程在房门上锁时到达，那么它必须等待房间内的线程打开门锁出来后，才能进入房间。</p><p>&emsp;&emsp;对于前面提到的请求队列，可以使用一个单独的锁进行保护。每当有一个新请求要加入队列，线程会首先占住锁，然后就可以安全地将请求加入到队列中，结束操作后再释放该锁；同样，当一个线程想从请求队列中删除一个请求时，也需要占住锁，然后才能从队列中读取和删除请求，而且在完成操作后必须释放锁。任何要访问队列的其他线程也类似，必须占住锁之后才能进行操作。因为在一个时刻只能有一个线程持有锁，所以在任何一个时刻只有一个线程可以操作队列。由此可见，锁机制可以防止并发执行，并且保护队列不受竞争状态影响。</p><p>&emsp;&emsp;任何要访问队列的代码都需要首先占住相应的锁，这样该锁就能阻止来自其他内核线程的并发访问，形式如下所示：</p><table><thead><tr><th>线程1</th><th>线程2</th></tr></thead><tbody><tr><td>试图锁定队列</td><td>试图锁定队列</td></tr><tr><td>成功，获得锁</td><td>失败：等待……</td></tr><tr><td>访问队列……</td><td>等待……</td></tr><tr><td>为队列解除锁</td><td>等待……</td></tr><tr><td>……</td><td>成功:获得锁</td></tr><tr><td>……</td><td>访问队列……</td></tr><tr><td>……</td><td>为队列解除锁</td></tr></tbody></table><p>&emsp;&emsp;注意锁的使用是自愿的、非强制性的，它完全属于一种编程者自选的编程手段。没有什么1可以强制编程者在操作虚拟队列时必须使用锁。当然，如果不这么做，无疑会造成竞争状态而破坏队列。</p><p>&emsp;&emsp;锁有多种形式，而且加锁的粒度范围也各不相同，Linux自身实现了几种不同的锁机制。各种锁机制直接的区别主要在于当锁被持有时的行为表现，一些锁持有时会不断进行循环，等待锁重新可用，而有些锁会使当前任务睡眠，直到锁可用为止。</p><h2 id="三、确定保护对象"><a href="#三、确定保护对象" class="headerlink" title="三、确定保护对象"></a>三、确定保护对象</h2><p>&emsp;&emsp;找出哪些数据需要保护是内核同步实现的关键所在。由于任何可能被并发访问的代码都需要保护，所以寻找哪些代码不需要保护反而更容易些。内核任务的局部数据仅仅被自身访问，显然不需要保护，比如，局部自动变量不需要任何形式的锁，因为它们独立存在于内核线程的栈中。类似，如果数据只会被特定的进程访问，那么也不需要加锁。</p><p>&emsp;&emsp;到底什么数据需要加锁呢？答案是大多数内核数据结构都需要加锁。有一条很好的经验可以帮助人们进行判断：如果有其他内核线程可以访问这些数据，那么就给这些数据局加上某种形式的锁；如果有任何其他东西能看到它，那么就要锁定它。</p><h2 id="四、并发执行的原因"><a href="#四、并发执行的原因" class="headerlink" title="四、并发执行的原因"></a>四、并发执行的原因</h2><p>&emsp;&emsp;内核空间之所以需要同步，是因为内核程序会被抢占和重新调度。由于处于内核态的进程可能会在任何时刻被抢占，从而使调度程序完全可能会选择另一个高优先级的进程到处理器执行，所以就有可能在一个进程进入临界区时就被非自愿地抢占了，如果新被调度的进程随后也进入同一个临界区，前后两个进程之间就会产生竞争。这种类型的并发操作并不是同时发生，它们只是相互交叉进行，所以也称为伪并发。</p><p>&emsp;&emsp;如果在对称多处理器的机器上，那么两个进程就可以真正地在临界区中同时执行。这种类型被称为真并发。虽然真并发和伪并发的原因和含义不同，但它们都同样会造成竞争状态，而且同样也需要保护。</p><p>&emsp;&emsp;那么，内核中造成并发执行的原因有哪些？简单来说有以下几种。</p><p>（1）中断：中断几乎可以在任何时刻异步发生，即可能随时打断当前正在执行的代码。</p><p>（2）内核抢占：如果内核具有抢占性，那么内核中的任务可能会被另一个任务抢占。</p><p>（3）软中断和<code>tasklet</code>：内核能在任何时刻唤醒或调度软中断和<code>tasklet</code>，打断当前正在执行的代码。</p><p>（4）睡眠：在内核执行的进程可能会睡眠，这就会唤醒调度程序，从而导致调度一个新的进程执行。</p><p>（5）对称多处理器：两个或多个处理器可以同时执行代码。</p><p>&emsp;&emsp;对于内核开发者来说，必须理解上述并发执行的原因1，并且事先为它们做好准备工作。如果在一段内核代码访问某资源的时候系统产生了一个中断，而该中断的处理程序居然还要访问这一资源，这就是一个bug；类似地，如果一段代码在访问一个共享资源期间被抢占，这也是一个bug；还有，如果内核代码在临界区里睡眠，那就是毫无原则地等待竞争状态的到来。最后还要注意，两个处理器绝对不能访问同一个共享资源。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&amp;emsp;&amp;emsp;所谓临界区就是访问和操作共享数据的代码段。多个内核任务并发访问同一个资源通常是不安全的。为了避免对临界区进行并发访问，编程者必须保证临界区代码段被原子地执行，也就是说，代码段在执行期间不可被打断，就如同整个临界区是一个不可分割的指令一样。如果两个内核
      
    
    </summary>
    
      <category term="Linux内核" scheme="http://wanqbin.xyz/categories/Linux%E5%86%85%E6%A0%B8/"/>
    
    
      <category term="Linux内核同步" scheme="http://wanqbin.xyz/tags/Linux%E5%86%85%E6%A0%B8%E5%90%8C%E6%AD%A5/"/>
    
      <category term="临界区" scheme="http://wanqbin.xyz/tags/%E4%B8%B4%E7%95%8C%E5%8C%BA/"/>
    
      <category term="竞争条件" scheme="http://wanqbin.xyz/tags/%E7%AB%9E%E4%BA%89%E6%9D%A1%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>92.反转链表II</title>
    <link href="http://wanqbin.xyz/2019/08/09/92-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8II/"/>
    <id>http://wanqbin.xyz/2019/08/09/92-反转链表II/</id>
    <published>2019-08-09T04:35:00.000Z</published>
    <updated>2019-08-09T06:29:38.978Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h2><p>反转从位置 m 到 n 的链表。请使用一趟扫描完成反转。</p><p>说明:<br>1 ≤ m ≤ n ≤ 链表长度。</p><p>示例:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL, m = 2, n = 4</span><br><span class="line">输出: 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;NULL</span><br></pre></td></tr></table></figure><h2 id="二、分析"><a href="#二、分析" class="headerlink" title="二、分析"></a>二、分析</h2><p>对于题目要求，画图如下：</p><p><img src="/2019/08/09/92-反转链表II/1.PNG" alt="题目要求"></p><p>在该题中需要实现对指定范围内的链表的反转。<code>m</code>和<code>n</code>代表范围区间。我们可以知道，<code>n-m+1</code>即为需要反转的链表的长度。在一开始，我们需要知道该从什么地方开始反转，<code>m</code>代表链表中的第<code>m</code>个结点。即从第<code>m</code>个结点开始对<code>n-m+1</code>长度的链表进行反转。</p><p><img src="/2019/08/09/92-反转链表II/2.PNG" alt="思路分析"></p><p>对反转步骤分析如下：</p><p>步骤一：找到开始逆置的结点，记录该结点以及该结点的前驱。</p><p><img src="/2019/08/09/92-反转链表II/3.PNG" alt="步骤一"></p><p>步骤二：从<code>head</code>开始，逆置<code>change_len=n-m+1</code>个结点</p><p><img src="/2019/08/09/92-反转链表II/4.PNG" alt="步骤二"></p><p>步骤三：将<code>pre_head</code>与<code>new_head</code>连接，<code>modify_list_tail</code>与<code>head</code>连接。</p><p><img src="/2019/08/09/92-反转链表II/5.PNG" alt="步骤三"></p><h2 id="三、实现"><a href="#三、实现" class="headerlink" title="三、实现"></a>三、实现</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> val;</span><br><span class="line">ListNode* next;</span><br><span class="line">ListNode(<span class="keyword">int</span> x) : val(x), next(<span class="literal">NULL</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function">ListNode* <span class="title">reverseBetween</span><span class="params">(ListNode* head, <span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> change_len = n - m + <span class="number">1</span>;<span class="comment">//需逆序的节点个数</span></span><br><span class="line">ListNode* pre_head = <span class="literal">NULL</span>;<span class="comment">//头节点的前一个节点</span></span><br><span class="line">ListNode* result = head;<span class="comment">//返回结果</span></span><br><span class="line"><span class="keyword">while</span> (head &amp;&amp; --m)</span><br><span class="line">&#123;</span><br><span class="line">pre_head = head;</span><br><span class="line">head = head-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">ListNode* modify_list_tail = head;</span><br><span class="line">ListNode* newHead = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">while</span> (head &amp;&amp; change_len)</span><br><span class="line">&#123;</span><br><span class="line">ListNode* next = head-&gt;next;</span><br><span class="line">head-&gt;next = newHead;</span><br><span class="line">newHead = head;</span><br><span class="line">head = next;</span><br><span class="line">change_len--;</span><br><span class="line">&#125;</span><br><span class="line">modify_list_tail-&gt;next = head;<span class="comment">//链接逆置的链表尾与逆置段的后一个节点</span></span><br><span class="line"><span class="keyword">if</span> (pre_head)<span class="comment">//pre_head不为空，说明不是从第一个节点开始逆置的</span></span><br><span class="line">&#123;</span><br><span class="line">pre_head-&gt;next = newHead;<span class="comment">//将逆置链表开始的前趋与逆置后的头结点链接</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">result = newHead;<span class="comment">//说明从第一个节点开始逆置，结果即为逆置后的头结点</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="测试函数："><a href="#测试函数：" class="headerlink" title="测试函数："></a>测试函数：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">ListNode <span class="title">a</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line"><span class="function">ListNode <span class="title">b</span><span class="params">(<span class="number">2</span>)</span></span>;</span><br><span class="line"><span class="function">ListNode <span class="title">c</span><span class="params">(<span class="number">3</span>)</span></span>;</span><br><span class="line"><span class="function">ListNode <span class="title">d</span><span class="params">(<span class="number">4</span>)</span></span>;</span><br><span class="line"><span class="function">ListNode <span class="title">e</span><span class="params">(<span class="number">5</span>)</span></span>;</span><br><span class="line"><span class="function">ListNode <span class="title">f</span><span class="params">(<span class="number">15</span>)</span></span>;</span><br><span class="line">a.next = &amp;b;</span><br><span class="line">b.next = &amp;c;</span><br><span class="line">c.next = &amp;d;</span><br><span class="line">d.next = &amp;e;</span><br><span class="line">e.next = &amp;f;</span><br><span class="line">Solution sol;</span><br><span class="line">ListNode* newhead = sol.reverseBetween(&amp;a, <span class="number">2</span>, <span class="number">5</span>);</span><br><span class="line"><span class="keyword">while</span> (newhead)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; newhead-&gt;val &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">newhead = newhead-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="执行结果："><a href="#执行结果：" class="headerlink" title="执行结果："></a>执行结果：</h3><p><img src="/2019/08/09/92-反转链表II/%E6%89%A7%E8%A1%8C%E7%BB%93%E6%9E%9C.PNG" alt="执行结果"></p><h2 id="三、源码地址"><a href="#三、源码地址" class="headerlink" title="三、源码地址"></a>三、源码地址</h2><p>​        <a href="https://github.com/Aoki-Wang/CheckStation/tree/master/LeetCode/92.ReverseList2" target="_blank" rel="noopener">反转链表的实现</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、题目描述&quot;&gt;&lt;a href=&quot;#一、题目描述&quot; class=&quot;headerlink&quot; title=&quot;一、题目描述&quot;&gt;&lt;/a&gt;一、题目描述&lt;/h2&gt;&lt;p&gt;反转从位置 m 到 n 的链表。请使用一趟扫描完成反转。&lt;/p&gt;
&lt;p&gt;说明:&lt;br&gt;1 ≤ m ≤ n ≤
      
    
    </summary>
    
      <category term="LeetCode" scheme="http://wanqbin.xyz/categories/LeetCode/"/>
    
      <category term="算法" scheme="http://wanqbin.xyz/categories/LeetCode/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="LeetCode" scheme="http://wanqbin.xyz/tags/LeetCode/"/>
    
      <category term="反转链表" scheme="http://wanqbin.xyz/tags/%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/"/>
    
      <category term="算法" scheme="http://wanqbin.xyz/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>206.反转链表</title>
    <link href="http://wanqbin.xyz/2019/08/09/206-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/"/>
    <id>http://wanqbin.xyz/2019/08/09/206-反转链表/</id>
    <published>2019-08-09T04:32:00.000Z</published>
    <updated>2019-08-09T06:36:42.194Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h2><p>反转一个单链表。</p><p><strong>示例:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL</span><br><span class="line">输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL</span><br></pre></td></tr></table></figure><h2 id="二、分析"><a href="#二、分析" class="headerlink" title="二、分析"></a>二、分析</h2><p>整个链表的反转比较简单，大致的实现思路是依次遍历链表节点，每遍历一个节点便逆置一个节点。</p><p><img src="/2019/08/09/206-反转链表/1.PNG" alt="思路分析"></p><h2 id="三、实现"><a href="#三、实现" class="headerlink" title="三、实现"></a>三、实现</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> val;</span><br><span class="line">ListNode* next;</span><br><span class="line">ListNode(<span class="keyword">int</span> x) : val(x), next(<span class="literal">NULL</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">ListNode* currHead = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">while</span> (head != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">ListNode* next = head-&gt;next;</span><br><span class="line">head-&gt;next = currHead;</span><br><span class="line">currHead = head;</span><br><span class="line">head = next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> currHead;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="测试函数："><a href="#测试函数：" class="headerlink" title="测试函数："></a>测试函数：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">ListNode <span class="title">a</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line"><span class="function">ListNode <span class="title">b</span><span class="params">(<span class="number">2</span>)</span></span>;</span><br><span class="line"><span class="function">ListNode <span class="title">c</span><span class="params">(<span class="number">3</span>)</span></span>;</span><br><span class="line"><span class="function">ListNode <span class="title">d</span><span class="params">(<span class="number">4</span>)</span></span>;</span><br><span class="line"><span class="function">ListNode <span class="title">e</span><span class="params">(<span class="number">5</span>)</span></span>;</span><br><span class="line">a.next = &amp;b;</span><br><span class="line">b.next = &amp;c;</span><br><span class="line">c.next = &amp;d;</span><br><span class="line">d.next = &amp;e;</span><br><span class="line">Solution solu;</span><br><span class="line">ListNode* newHead = solu.reverseList(&amp;a);</span><br><span class="line"><span class="keyword">while</span> (newHead != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; newHead-&gt;val &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">newHead = newHead-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="执行结果："><a href="#执行结果：" class="headerlink" title="执行结果："></a>执行结果：</h3><p><img src="/2019/08/09/206-反转链表/%E6%89%A7%E8%A1%8C%E7%BB%93%E6%9E%9C.PNG" alt="执行结果"></p><h2 id="四、源码地址"><a href="#四、源码地址" class="headerlink" title="四、源码地址"></a>四、源码地址</h2><p>​        <a href="https://github.com/Aoki-Wang/CheckStation/tree/master/LeetCode/206.ReverseList" target="_blank" rel="noopener">反转链表的实现</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、题目描述&quot;&gt;&lt;a href=&quot;#一、题目描述&quot; class=&quot;headerlink&quot; title=&quot;一、题目描述&quot;&gt;&lt;/a&gt;一、题目描述&lt;/h2&gt;&lt;p&gt;反转一个单链表。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例:&lt;/strong&gt;&lt;/p&gt;
&lt;figure class
      
    
    </summary>
    
      <category term="LeetCode" scheme="http://wanqbin.xyz/categories/LeetCode/"/>
    
      <category term="算法" scheme="http://wanqbin.xyz/categories/LeetCode/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="LeetCode" scheme="http://wanqbin.xyz/tags/LeetCode/"/>
    
      <category term="反转链表" scheme="http://wanqbin.xyz/tags/%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>203.移出链表元素</title>
    <link href="http://wanqbin.xyz/2019/08/09/203-%E7%A7%BB%E5%87%BA%E9%93%BE%E8%A1%A8%E5%85%83%E7%B4%A0/"/>
    <id>http://wanqbin.xyz/2019/08/09/203-移出链表元素/</id>
    <published>2019-08-09T04:28:00.000Z</published>
    <updated>2019-08-09T06:43:44.191Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h2><p>删除链表中等于给定值 <strong>val</strong> 的所有节点。</p><p><strong>示例:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: 1-&gt;2-&gt;6-&gt;3-&gt;4-&gt;5-&gt;6, val = 6</span><br><span class="line">输出: 1-&gt;2-&gt;3-&gt;4-&gt;5</span><br></pre></td></tr></table></figure><h2 id="二、分析"><a href="#二、分析" class="headerlink" title="二、分析"></a>二、分析</h2><p>在本题中，需要从链表中将某个指定的元素删除。需要实现的操作也比较简单，只是将某个匹配的结点删除。而在本题中，需要注意的是将删除结点的操作分为三类：一是删除头结点，二是删除中间的任意一个结点，三是删除尾结点。这三类删除操作的实现方法不同。</p><ul><li>对于删除头结点的操作来说，只需要将头结点指向头结点的下一个结点即可；</li><li>对于删除中间结点的操作来说，与普通的删除操作没有什么差别；</li><li>对于删除尾结点的操作来说，我们需要找到尾结点的前一个结点，此时尾节点的前一个结点的下一个结点是尾节点，我们需要做的是让尾节点的前一个结点不再指向尾节点，而是指向<code>NULL</code>；</li></ul><h2 id="三、实现"><a href="#三、实现" class="headerlink" title="三、实现"></a>三、实现</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> val;</span><br><span class="line">ListNode* next;</span><br><span class="line">ListNode(<span class="keyword">int</span> x) : val(x), next(<span class="literal">NULL</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function">ListNode* <span class="title">removeElements</span><span class="params">(ListNode* head, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">ListNode* p = head;</span><br><span class="line">ListNode* pre_p = head;</span><br><span class="line"><span class="keyword">while</span>(p)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (p == head &amp;&amp; p-&gt;val == val)<span class="comment">//头节点</span></span><br><span class="line">&#123;</span><br><span class="line">head = p-&gt;next;</span><br><span class="line">p = head;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(p-&gt;val==val)<span class="comment">//中间结点</span></span><br><span class="line">&#123;</span><br><span class="line">pre_p-&gt;next = p-&gt;next;</span><br><span class="line">p = pre_p-&gt;next;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (p-&gt;next == <span class="literal">NULL</span> &amp;&amp; p-&gt;val == val)<span class="comment">//尾结点</span></span><br><span class="line">&#123;</span><br><span class="line">pre_p = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line">pre_p = p;</span><br><span class="line">p = p-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="测试函数："><a href="#测试函数：" class="headerlink" title="测试函数："></a>测试函数：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">ListNode <span class="title">head</span><span class="params">(<span class="number">15</span>)</span></span>;</span><br><span class="line">ListNode* p = &amp;head;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">ListNode* a = <span class="keyword">new</span> ListNode(i);</span><br><span class="line">p-&gt;next = a;</span><br><span class="line">p = p-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">p-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">Solution sol;</span><br><span class="line">ListNode* newHead = sol.removeElements(&amp;head, <span class="number">4</span>);</span><br><span class="line"><span class="keyword">while</span> (newHead)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; newHead-&gt;val &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">newHead = newHead-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="执行结果："><a href="#执行结果：" class="headerlink" title="执行结果："></a>执行结果：</h3><p><img src="/2019/08/09/203-移出链表元素/%E6%89%A7%E8%A1%8C%E7%BB%93%E6%9E%9C.PNG" alt="执行结果"></p><h2 id="四、源码地址"><a href="#四、源码地址" class="headerlink" title="四、源码地址"></a>四、源码地址</h2><p>​            <a href="https://github.com/Aoki-Wang/CheckStation/tree/master/LeetCode/203.RemoveElements" target="_blank" rel="noopener">移出链表元素的实现</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、题目描述&quot;&gt;&lt;a href=&quot;#一、题目描述&quot; class=&quot;headerlink&quot; title=&quot;一、题目描述&quot;&gt;&lt;/a&gt;一、题目描述&lt;/h2&gt;&lt;p&gt;删除链表中等于给定值 &lt;strong&gt;val&lt;/strong&gt; 的所有节点。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;
      
    
    </summary>
    
      <category term="LeetCode" scheme="http://wanqbin.xyz/categories/LeetCode/"/>
    
      <category term="算法" scheme="http://wanqbin.xyz/categories/LeetCode/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="移出链表元素" scheme="http://wanqbin.xyz/tags/%E7%A7%BB%E5%87%BA%E9%93%BE%E8%A1%A8%E5%85%83%E7%B4%A0/"/>
    
      <category term="LeetCode" scheme="http://wanqbin.xyz/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>gdb调试</title>
    <link href="http://wanqbin.xyz/2019/08/08/gdb%E8%B0%83%E8%AF%95/"/>
    <id>http://wanqbin.xyz/2019/08/08/gdb调试/</id>
    <published>2019-08-08T14:24:20.000Z</published>
    <updated>2019-08-09T08:40:10.955Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>静态库和动态库的制作</title>
    <link href="http://wanqbin.xyz/2019/08/08/%E9%9D%99%E6%80%81%E5%BA%93%E5%92%8C%E5%8A%A8%E6%80%81%E5%BA%93%E7%9A%84%E5%88%B6%E4%BD%9C/"/>
    <id>http://wanqbin.xyz/2019/08/08/静态库和动态库的制作/</id>
    <published>2019-08-08T14:23:00.000Z</published>
    <updated>2019-08-09T08:39:49.908Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、静态库和动态库"><a href="#一、静态库和动态库" class="headerlink" title="一、静态库和动态库"></a>一、静态库和动态库</h2><ol><li><h3 id="静态库"><a href="#静态库" class="headerlink" title="静态库"></a>静态库</h3><p>&emsp;&emsp;静态库是指在我们的应用中，有一些公共代码是需要反复所使用的，就把这些代码编译为“库文件”；在连接步骤中，链接器将从库文件取得所需的代码，复制到生成的可执行文件中。</p><p>&emsp;&emsp;程序编译一般需要经过预处理、编译、汇编和链接几个步骤。静态库的特点是可执行文件中包含了库代码的一份完整拷贝。</p><p>&emsp;&emsp;优点：只需保证在开发者的计算机有正确的库文件，在以二进制发布时不需考虑在用户的计算机上库文件是否存在及版本问题，可避免DLL地狱等问题。</p><p>&emsp;&emsp;缺点：生成的可执行文件体积较大。</p></li><li><h3 id="动态库"><a href="#动态库" class="headerlink" title="动态库"></a>动态库</h3><p>&emsp;&emsp;动态库又称动态链接库（Dynamic Link Library,DLL),DLL是一个包含可由多个程序同时使用的代码和数据的库，DLL不是可执行文件。动态链接提供了一种方法，使进程可以调用不属于可执行代码的函数。函数的可执行代码位于一个DLL中，该DLL包含一个或多个已被编译、链接并与它们的进程分开存储的函数。DLL还有助于共享数据和资源。多个应用程序可同时访问内存中单个DLL副本的内容。DLL是一个包含可由多个程序同时使用的代码和数据的库。Windows下动态库为<code>.dll</code>后缀，在Linux下为<code>.so</code>后缀。</p></li><li><h3 id="静态库和动态库的区别"><a href="#静态库和动态库的区别" class="headerlink" title="静态库和动态库的区别"></a>静态库和动态库的区别</h3><p>&emsp;&emsp;静态库和动态库两者的不同点在于代码被载入的时刻不同。静态库的代码在编译过程中已经被载入可执行程序，因此体积比较大。动态库（共享库）的代码在可执行程序运行时才载入内存，在编译过程中仅简单地引用，因此体积比较小。</p><p>&emsp;&emsp;不同的应用程序如果调用相同的库，那么在内存中只需要有一份该动态库的实例。静态库1和动态库的最大区别，静态情况下，把库直接加载到程序中，而动态链接的时候，它只是保留接口，将动态库与程序代码独立，这样就可以提高代码的可复用度，降低程序的耦合度。</p><p>&emsp;&emsp;动态库在程序编译时并不会被链接到目标代码中，而是在程序运行时才被载入，因此在程序运行时还需要动态库的存在。</p></li></ol><h2 id="二、静态库的制作"><a href="#二、静态库的制作" class="headerlink" title="二、静态库的制作"></a>二、静态库的制作</h2><ul><li>静态库的文件命名：<code>libxxx.a</code></li><li>制作步骤：<ul><li>编译为<code>.o</code>文件</li><li>将<code>.o</code>文件打包，<code>ar rcs libxxxx.a file1.o file2.o……</code>。其中，<code>libxxxx.a</code>为静态库名，<code>file1.o</code>等文件都是需要打包的文件</li></ul></li><li>使用：编译时需要加静态库名 ，<code>-L</code>用来指明包含的库路径,<code>-l</code>指定库名(通常为libxx.so或者libxxx.a)</li></ul><p>首先我们将需要打包的文件编译为<code>.o</code>文件</p><p><img src="/2019/08/08/静态库和动态库的制作/6.PNG" alt="静态库制作"></p><p>接下来，将所有需要打包的<code>.o</code>文件打包</p><p><img src="/2019/08/08/静态库和动态库的制作/7.PNG" alt="静态库的制作"></p><p>接下来，使用刚制作的静态库对<code>main.cpp</code>进行编译。在这之前，将制作的静态库移到<code>/lib</code>目录下。</p><p><img src="/2019/08/08/静态库和动态库的制作/8.PNG" alt="静态库的制作"></p><p>执行结果如下：</p><p><img src="/2019/08/08/静态库和动态库的制作/9.PNG" alt="执行结果"></p><h2 id="三、动态库的制作"><a href="#三、动态库的制作" class="headerlink" title="三、动态库的制作"></a>三、动态库的制作</h2><ul><li>制作步骤：<ul><li>编译与位置无关的代码，生成<code>.o</code>文件，关键参数<code>-fPIC</code></li><li>将<code>.o</code>文件打包：关键参数<code>-shared</code></li><li>将库与头文件一起发布</li></ul></li></ul><p>我们利用之前的<code>.cpp</code>文件来制作动态库，首先，将之前制作静态库时用到的文件全部删除。删除结果如下：</p><p><img src="/2019/08/08/静态库和动态库的制作/10.PNG" alt="动态库的制作"></p><p>下面我们编译与位置无关的代码，生成<code>.o</code>文件，结果如下。</p><p><img src="/2019/08/08/静态库和动态库的制作/11.PNG" alt="动态库的制作"></p><p>下面，我们使用动态库的参数<code>-shared</code>打包<code>.o</code>文件。</p><p><img src="/2019/08/08/静态库和动态库的制作/12.PNG" alt="动态库的制作"></p><p>接下来，要做的就是使用动态库。这里，我们先将生成的动态库移动到<code>/lib</code>下面。</p><p><img src="/2019/08/08/静态库和动态库的制作/13.PNG" alt="动态库的制作"></p><p>执行结果如下：</p><p><img src="/2019/08/08/静态库和动态库的制作/14.PNG" alt="动态库的制作"></p><p>我们可以看到，这里并没有执行成功。它没有像静态库一样直接打开可执行文件就可以运行。</p><h2 id="四、解决不能加载动态库的问题"><a href="#四、解决不能加载动态库的问题" class="headerlink" title="四、解决不能加载动态库的问题"></a>四、解决不能加载动态库的问题</h2><p>对于动态库无法加载的问题，这里有三种解决办法</p><ul><li>将动态库拷贝到<code>/lib</code>下，当然这种方式不太好，可能会出现一些问题</li><li>将库路径增加到环境变量<code>LD_LIBRARY_PATH</code>中，这种方式也不是特别推荐</li><li>配置<code>/etc/ld.so.conf</code>，增加动态库的绝对路径，然后执行<code>sudo ldconfig -v</code></li></ul><p>首先，我们使用 <code>pwd</code>命令查看动态库的路径。</p><p><img src="/2019/08/08/静态库和动态库的制作/15.PNG" alt="动态库的制作"></p><p>我们在<code>/etc/ld.so.conf</code>文件中添加该动态库的路径</p><p><img src="/2019/08/08/静态库和动态库的制作/16.PNG" alt="动态库的制作"></p><p>接下来执行<code>sudo ldconfig -v</code>命令，得到下面的结果</p><p><img src="/2019/08/08/静态库和动态库的制作/17.PNG" alt="动态库的制作"></p><p>在<code>sudo ldconfig -v</code>命令中，<code>-v</code>选项表示显示加载过程。</p><p>通过<code>ldd</code>命令，我们可以看到该程序所需要的动态链接库。最后是运行结果。</p><p><img src="/2019/08/08/静态库和动态库的制作/18.PNG" alt="执行结果"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、静态库和动态库&quot;&gt;&lt;a href=&quot;#一、静态库和动态库&quot; class=&quot;headerlink&quot; title=&quot;一、静态库和动态库&quot;&gt;&lt;/a&gt;一、静态库和动态库&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;h3 id=&quot;静态库&quot;&gt;&lt;a href=&quot;#静态库&quot; class=&quot;h
      
    
    </summary>
    
      <category term="Linux命令" scheme="http://wanqbin.xyz/categories/Linux%E5%91%BD%E4%BB%A4/"/>
    
    
      <category term="静态库制作" scheme="http://wanqbin.xyz/tags/%E9%9D%99%E6%80%81%E5%BA%93%E5%88%B6%E4%BD%9C/"/>
    
      <category term="动态库制作" scheme="http://wanqbin.xyz/tags/%E5%8A%A8%E6%80%81%E5%BA%93%E5%88%B6%E4%BD%9C/"/>
    
      <category term="动态库加载" scheme="http://wanqbin.xyz/tags/%E5%8A%A8%E6%80%81%E5%BA%93%E5%8A%A0%E8%BD%BD/"/>
    
  </entry>
  
  <entry>
    <title>gcc编译流程</title>
    <link href="http://wanqbin.xyz/2019/08/08/gcc%E7%BC%96%E8%AF%91%E6%B5%81%E7%A8%8B/"/>
    <id>http://wanqbin.xyz/2019/08/08/gcc编译流程/</id>
    <published>2019-08-08T14:08:00.000Z</published>
    <updated>2019-08-09T07:07:04.707Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、gcc工作流程"><a href="#一、gcc工作流程" class="headerlink" title="一、gcc工作流程"></a>一、gcc工作流程</h2><p>gcc编译流程如下：</p><ul><li><code>gcc -E</code>预处理、头文件展开、宏替换，生成<code>hello.i</code></li><li><code>gcc -S</code>生成汇编代码，生成<code>hello.s</code></li><li><code>gcc -c</code>将汇编文件编译成二进制文件，生成<code>hello.o</code></li><li><code>ld</code>链接，生成可执行文件<code>a.out</code></li></ul><p><img src="/2019/08/08/gcc编译流程/1.PNG" alt="gcc编译流程"></p><h2 id="二、gcc相关参数"><a href="#二、gcc相关参数" class="headerlink" title="二、gcc相关参数"></a>二、gcc相关参数</h2><ul><li><code>-L</code>用来指明包含的库路径</li><li><code>-l</code>指定库名(通常为libxx.so或者libxxx.a)</li><li><code>-g</code>用于gdb调试，不加此选项不能进行gdb调试</li><li><code>-Wall</code>显示更多的警告</li><li><code>-lstdc++</code>编译C++代码</li><li><code>-O</code>优化选项，1—3，数字越大，优先级越高</li><li><code>-D</code>用来指定要执行的宏</li><li><code>-o</code>用来指定编译后文件名</li></ul><p>在当前目录下，有如下图所示的<code>.cpp</code>文件。</p><p><img src="/2019/08/08/gcc编译流程/2.PNG" alt="gcc编译流程"></p><p>我们可以使用gcc的相关参数对这些文件进行编译。下图所示为各个<code>.cpp</code>文件的内容。</p><p><img src="/2019/08/08/gcc编译流程/3.PNG" alt="gcc相关参数"></p><p>我们可以看到在每一个<code>.cpp</code>文件中，都有一个头文件，在对这些<code>.cpp</code>文件进行编译时，我们需要知道该头文件的路径。</p><p><img src="/2019/08/08/gcc编译流程/4.PNG" alt="头文件"></p><p>下面，我们对这些<code>.cpp</code>文件进行编译执行，结果如下图。</p><p><img src="/2019/08/08/gcc编译流程/5.PNG" alt="编译执行结果"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、gcc工作流程&quot;&gt;&lt;a href=&quot;#一、gcc工作流程&quot; class=&quot;headerlink&quot; title=&quot;一、gcc工作流程&quot;&gt;&lt;/a&gt;一、gcc工作流程&lt;/h2&gt;&lt;p&gt;gcc编译流程如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;gcc -E&lt;/code
      
    
    </summary>
    
      <category term="Linux命令" scheme="http://wanqbin.xyz/categories/Linux%E5%91%BD%E4%BB%A4/"/>
    
    
      <category term="Ubuntu" scheme="http://wanqbin.xyz/tags/Ubuntu/"/>
    
      <category term="gcc" scheme="http://wanqbin.xyz/tags/gcc/"/>
    
      <category term="gcc编译" scheme="http://wanqbin.xyz/tags/gcc%E7%BC%96%E8%AF%91/"/>
    
  </entry>
  
  <entry>
    <title>Linux添加系统调用</title>
    <link href="http://wanqbin.xyz/2019/08/08/Linux%E6%B7%BB%E5%8A%A0%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/"/>
    <id>http://wanqbin.xyz/2019/08/08/Linux添加系统调用/</id>
    <published>2019-08-08T11:59:00.000Z</published>
    <updated>2019-08-08T12:00:54.923Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;在Linux中为系统添加一个系统调用并不是很难的事情，首先需要编写自己的系统调用，然后再把编写好的系统调用注册进内核使它成为一个正式的系统调用即可。系统调用函数可以静态添加，也可以动态添加，静态方式就是把系统掉用那个直接加入到内核中，这需要重新编译内核；动态方式是以模块的方式添加系统调用，这种方式下，不需要重新编译内核。</p><ol><li><h3 id="编写系统调用函数"><a href="#编写系统调用函数" class="headerlink" title="编写系统调用函数"></a>编写系统调用函数</h3><p>&emsp;&emsp;编写自己的系统调用前，必须首先清楚该系统调用所要实现的功能是什么，在Linux中，尽量不要用一个系统调用来实现多个功能。系统调用接口应该尽量简洁，参数尽量少，当然还要考虑到系统调用的通用性，即系统调用是否可移植等因素。</p><p>&emsp;&emsp;内核执行系统调用的时候处于进程上下文中，因此可以睡眠，也可以被抢占，这样系统调用可以使用内核提供的绝大多数函数。系统调用函数的一般形式如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">asmlinkage <span class="keyword">long</span> sys_ <span class="title">xxx</span><span class="params">(type1 arg1,type2 arg2……）</span></span></span><br></pre></td></tr></table></figure></li><li><h3 id="把系统调用添加到系统调用表中"><a href="#把系统调用添加到系统调用表中" class="headerlink" title="把系统调用添加到系统调用表中"></a>把系统调用添加到系统调用表中</h3><p>&emsp;&emsp;把编写好的系统调用添加到系统表的最后，对于支持该系统调用的所有硬件体系结构都必须做这样的工作。从0开始算起，系统调用在该表中的位置就是它的系统调用号。每种体系结构下对应的系统调用号不一定相同。</p></li><li><h3 id="添加系统调用号"><a href="#添加系统调用号" class="headerlink" title="添加系统调用号"></a>添加系统调用号</h3><p>&emsp;&emsp;对于系统调用所支持的各种体系结构，把由上一步得到的系统调用号添加到文件<code>unistd.h</code>中，并修改总的系统调用个数<code>NR_syscalls</code>的值。</p></li><li><h3 id="添加系统调用函数"><a href="#添加系统调用函数" class="headerlink" title="添加系统调用函数"></a>添加系统调用函数</h3><p>&emsp;&emsp;最后把编写好的系统调用函数添加到内核中时，要保证系统必须被编译进内核映像（而不是被编译成模块）。</p></li><li><h3 id="重新编译内核"><a href="#重新编译内核" class="headerlink" title="重新编译内核"></a>重新编译内核</h3><p>&emsp;&emsp;编译修改过的Linux内核，再次系统选择启动新内核，这样就可以使用刚才写好的系统调用了。</p></li><li><h3 id="从用户空间使用系统调用"><a href="#从用户空间使用系统调用" class="headerlink" title="从用户空间使用系统调用"></a>从用户空间使用系统调用</h3><p>&emsp;&emsp;通常，系统调用靠C库的支持，用户程序通过包含标准头文件并和C库链接，就可以使用系统调用了。但是如果仅仅写出系统调用，glibc库恐怕并提供支持。在2.6.20之后，出于安全的考虑，Linux删除了<code>_syscalln</code>的一组宏，这样就只有使用内核为用户程序提供的另外一个函数<code>syscall</code>。该函数的形式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">syscall(_NR_mysyscall,arg1,arg2……）;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&amp;emsp;&amp;emsp;在Linux中为系统添加一个系统调用并不是很难的事情，首先需要编写自己的系统调用，然后再把编写好的系统调用注册进内核使它成为一个正式的系统调用即可。系统调用函数可以静态添加，也可以动态添加，静态方式就是把系统掉用那个直接加入到内核中，这需要重新编译内
      
    
    </summary>
    
      <category term="Linux内核" scheme="http://wanqbin.xyz/categories/Linux%E5%86%85%E6%A0%B8/"/>
    
    
      <category term="操作系统" scheme="http://wanqbin.xyz/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="Linux内核" scheme="http://wanqbin.xyz/tags/Linux%E5%86%85%E6%A0%B8/"/>
    
      <category term="Linux系统调用" scheme="http://wanqbin.xyz/tags/Linux%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/"/>
    
      <category term="Linux添加系统调用" scheme="http://wanqbin.xyz/tags/Linux%E6%B7%BB%E5%8A%A0%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/"/>
    
  </entry>
  
  <entry>
    <title>Linux系统调用实现分析</title>
    <link href="http://wanqbin.xyz/2019/08/08/Linux%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E5%AE%9E%E7%8E%B0%E5%88%86%E6%9E%90/"/>
    <id>http://wanqbin.xyz/2019/08/08/Linux系统调用实现分析/</id>
    <published>2019-08-08T11:33:00.000Z</published>
    <updated>2019-08-08T11:33:37.412Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、C程序库和系统调用"><a href="#一、C程序库和系统调用" class="headerlink" title="一、C程序库和系统调用"></a>一、C程序库和系统调用</h2><p>&emsp;&emsp;系统调用视为了编程人员提供内核服务的一组函数，而C程序库通过软中断陷入内核，实现内核服务。</p><p>&emsp;&emsp;系统调用时系统内核向用户程序提供支持的接口，通过这些接口应用程序向系统内核服务，控制转向系统内核，而系统内核在完成服务之后，将控制和结果返回给用户程序。系统调用是用户程序与系统内核的边界，通过系统调用，进程可由用户模式转入内核模式，在内核模式下完成一定的服务请求后再返回用户模式。系统调用只是提供一个基本功能集，而通过对这些操作的引用和封装，可以形成丰富而且强大的系统调用库。这里体现了Linux的机制与策略相分离的编程思想——系统调用只是提供访问核心的基本机制，而策略是通过系统调用库来实现的。</p><p>&emsp;&emsp;在Linux中，系统调用库实体通过C程序来实现的，又称为C程序库。C程序库主要是为编程人员提供应用程序编程接口（API），即为编程人员提供与内核进行交互的一组法术。一般情况下，应用程序使用的这种编程接口实际上并不需要和内核提供的系统调用对应。一个API的功能可以通过一个系统调用来实现，也可以通过多个系统调用来实现，也可以完全不使用系统调用。实际上，API可以在各种操作系统上实现，给应用程序提供完全相同的接口，而它们自身在这些系统同上的实现可能不同。</p><p>&emsp;&emsp;从程序员的角度来看，系统调用无关紧要；他们只需要跟C库的API打交道就可以。相反的，内核只跟系统调用打交道；库函数及应用程序怎么使用系统调用并不是内核所关心的。只是内核必须时刻牢记系统调用所有潜在的用途并保证它们有良好的通用性和灵活性。</p><h2 id="二、系统调用实现分析"><a href="#二、系统调用实现分析" class="headerlink" title="二、系统调用实现分析"></a>二、系统调用实现分析</h2><p>&emsp;&emsp;在Linux系统中系统调用时用户空间访问内核的一种方式，系统调用执行大致过程如下：</p><p>（1）在应用程序中调用用户空间的库函数</p><p>（2）库函数在执行一系列预处理后，取得系统调用号，传递相应的参数并执行软中断指令<code>INT</code>产生中断</p><p>（3）Linux系统进行地址空间的转换和堆栈的切换，执行<code>SAVE_ALL</code>宏定义，从而保存现场</p><p>（4）根据系统调用号从系统调用表找到对应系统调用处理程序的入口地址</p><p>（5）执行系统调用对应的处理程序</p><p>（6）执行<code>RESTORE_ALL</code>宏定义，恢复系统调用前的任务现场并返回用户模式</p><p>不同的平台，系统调用的实现也不同。下面是在x86体系结构中系统调用的实现。</p><ol><li><h4 id="系统调用的初始化"><a href="#系统调用的初始化" class="headerlink" title="系统调用的初始化"></a>系统调用的初始化</h4><p>&emsp;&emsp;在应用程序调用系统调用时，应该以某种方式从用户态陷入到内核态，在Linux中可以通过软中断（这里的软中断是相对于外部的硬件中断来说的）来实现陷入，在x86平台上，这条指令是<code>init 0x80</code>。也就是说在Linux中，向系统调用的接口是一个中断处理函数的特例。这样，就需要在系统启动时，对系统调用中断进行初始化。</p><p>&emsp;&emsp;Linux内核在初始化期间会调用<code>arch/i386/kernel/traps.c</code>文件中的<code>trap_init()</code>函数来设置中断描述符表。在这个函数中，通过调用函数<code>set_system_gate(SYSCALL_VECTOR,&amp;SYSTEM_call)</code>来完成该项的设置。其中的<code>SYSTEMCALL_VECTOR</code>就是<code>0x80</code>，而<code>system_call</code>则是一个汇编子函数，它是中断<code>0x80</code>的处理函数，也是系统调用的入口函数。</p></li><li><h4 id="与系统调用相关的数据结构"><a href="#与系统调用相关的数据结构" class="headerlink" title="与系统调用相关的数据结构"></a>与系统调用相关的数据结构</h4><h4 id="（1）系统调用号"><a href="#（1）系统调用号" class="headerlink" title="（1）系统调用号"></a>（1）系统调用号</h4><p>&emsp;&emsp;在Linux中每个系统调用被赋予一个唯一的编号，这个编号被称为系统调用号。这样通过这个独一无二的号就可以关联到相应的系统调用处理处理程序。系统调用号定义在<code>include/asm/unistd.h</code>中，编号的定义方式如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _NR_result_syscall0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _NR_exit   1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _NR_fork  2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _NR_read                         3</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _NR_write  4</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _NR_open5</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _NR_close  6</span></span><br><span class="line"></span><br><span class="line">……</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NR_syscalls  325</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;其中，<code>NR_syscalls</code>表示系统调用的总数，在检查一个系统调用号是否合法时要用到。</p><p>&emsp;&emsp;系统调用号非常关键，当用户空间的进程执行一个系统调用的时候，系统使用系统调用号而不是系统调用的函数名称，来指明到底是要执行那个系统调用。系统调用号一旦分配就不能再有任何变更，否则编译好的应用程序就会崩溃。此外，如果一个系统调用被删除，它所占用的系统调用号也不允许被回收利用，否则，以前编译过的代码在调用这个系统调用时，就会出错。为此，Linux设置了专门的“未实现”系统调用<code>sys_ni_syscall()</code>，它除了返回<code>-ENOSYS</code>外，不做任何其他的事。当系统调用一个被删除的系统调用时，或者无效的系统调用时，这个函数就会被执行。</p><h4 id="（2）系统调用表"><a href="#（2）系统调用表" class="headerlink" title="（2）系统调用表"></a>（2）系统调用表</h4><p>&emsp;&emsp;内核使用系统调用表记录了各个系统调用处理函数的入口地址，以系统同调用号为偏移量能够很容易地在该表中找到对应的处理函数地址。系统调用表存储在<code>sys_call_table</code>中，它与体系结构有关，x86体系结构的系统调用表定义在<code>arch/x86/kernel/syscall_table.S</code>中，其定义方式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ENTER(sys_call_table)</span><br><span class="line">.long sys_restart_syscall</span><br><span class="line">.long sys_exit</span><br><span class="line">.long sys_fork</span><br><span class="line">.long sys_read</span><br><span class="line">……</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;当用户空间程序调用一个系统调用时，系统调用号作为参数传递给中断<code>0x80</code>，而该标号实际上就相当于系统调用表的下标，通过该值可以找到相应的系统调用的处理函数。</p></li><li><h4 id="系统调用入口函数"><a href="#系统调用入口函数" class="headerlink" title="系统调用入口函数"></a>系统调用入口函数</h4><p>&emsp;&emsp;当用户执行了软中断指令后，系统从用户空间进入内核空间，并在内核空间执行系统调用入口函数。系统调用入口函数由<code>arch/x386/kernel/entry_32.S</code>文件中的<code>system_call</code>汇编代码段定义，其主要功能是对系统调用进行预处理，并调用相应的系统调用服务例程。函数的执行过程如下：</p><p>（1）首先将系统调用号（eax的值，因为在save_all中保存的eax寄存器会被调用的返回值覆盖）放入栈中</p><p>（2）调用<code>save_all</code>保存寄存器上下文</p><p>（3）得到进程的<code>thread_info</code>结构指针放到<code>ebp</code>中。检查<code>struct thread_info</code>中的<code>flags</code>标志，看是否有系统管理调用跟踪等，有则跳到<code>syscall_trace_entry</code></p><p>（4）检查系统调用号的有效性，若不小于<code>nr_syscalls</code>则报错并返回<code>-ENOOSYS</code>，否则跳转到该系统调用的处理函数入口。这里以eax作为偏移，在系统调用表<code>sys_call_table</code>中查找处理函数入口地址，并跳转到该入口地址</p><p>（5）将返回值存放在eax中，调用<code>restore_all</code>恢复寄存器上下文。</p></li><li><h4 id="系统调用的参数传递"><a href="#系统调用的参数传递" class="headerlink" title="系统调用的参数传递"></a>系统调用的参数传递</h4><p>&emsp;&emsp;与普通的函数类似，系统调用通常也需要输入/输出参数，这些参数可能是实际的值，也可能是函数的地址及用户态进程地址空间的变量。在系统调用需要传递少量参数的情况下，通常采用处理器中的寄存器完成参数的传递工作。系统调用过程中所需要的参数由寄存器<code>%eax</code>,<code>%ebx</code>,<code>%ecx</code>,<code>%edx</code>,<code>%esi</code>,<code>%edi</code>来传递。</p><p>&emsp;&emsp;事实上，系统调用过程中系统调用号就是通过处理器中的寄存器<code>%eax</code>进行传递的，系统调用入口函数<code>system_call()</code>根据保存在该寄存器中的不同系统调用号，调用相应的系统调用处理函数来完成具体的系统调用。</p><p>&emsp;&emsp;具体的系统调用处理函数所需参数依次由除了<code>%eax</code>外剩余的5个寄存器<code>%ebx</code>,<code>%ecx</code>,<code>%edx</code>,<code>%esi</code>,<code>%edi</code>来传递。在系统调用处理过程中，这些保存在处理器寄存器中的参数被系统调用入口函数<code>system_call()</code>通过调用<code>save_all()</code>函数压入到内核态栈中。具体的系统调用处理函数从内核态栈中取得相应的参数值，完成具体的处理工作。</p><p>&emsp;&emsp;当系统调用需要在用户态和内核态传递大量数据时，处理器中内置的寄存器显然不够使用。通常的做法是，把所传递的参数封装到特定的结构中，此时采用一个指向该结构的指针和该结构的长度值来描述这一参数，再和传递少量数据的情况一样将这两个通过处理器中的参数进行传递。</p><p>&emsp;&emsp;由于在内核中，不可以访问用户态地址空间，Linux提供了<code>copy_from_user()</code>和<code>copy_to_user()</code>两个函数，用于用户态空间和内核态空间的数据交换。</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、C程序库和系统调用&quot;&gt;&lt;a href=&quot;#一、C程序库和系统调用&quot; class=&quot;headerlink&quot; title=&quot;一、C程序库和系统调用&quot;&gt;&lt;/a&gt;一、C程序库和系统调用&lt;/h2&gt;&lt;p&gt;&amp;emsp;&amp;emsp;系统调用视为了编程人员提供内核服务的一组函数
      
    
    </summary>
    
      <category term="Linux内核" scheme="http://wanqbin.xyz/categories/Linux%E5%86%85%E6%A0%B8/"/>
    
    
      <category term="操作系统" scheme="http://wanqbin.xyz/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="Linux系统调用" scheme="http://wanqbin.xyz/tags/Linux%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/"/>
    
      <category term="系统调用" scheme="http://wanqbin.xyz/tags/%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/"/>
    
      <category term="C程序库" scheme="http://wanqbin.xyz/tags/C%E7%A8%8B%E5%BA%8F%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>Linux调度相关系统调用</title>
    <link href="http://wanqbin.xyz/2019/08/08/Linux%E8%B0%83%E5%BA%A6%E7%9B%B8%E5%85%B3%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/"/>
    <id>http://wanqbin.xyz/2019/08/08/Linux调度相关系统调用/</id>
    <published>2019-08-08T09:00:00.000Z</published>
    <updated>2019-08-08T09:00:48.927Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;Linux内核提供的一些系统调用主要用于管理和维护与进程调度相关的参数值，这些系统调用可以用来获取和设置进程的优先级、进程调度策略，以及进程与处理器的亲和力等。</p><table><thead><tr><th>系统调用</th><th>功能简介</th></tr></thead><tbody><tr><td>nice()</td><td>用于设置普通进程的静态优先级，即设置进程的nice值</td></tr><tr><td>getprioprity()</td><td>返回20减去给定进程组中所有进程之中最低nice字段的值，即获得一组普通进程的最大优先级</td></tr><tr><td>setpriority()</td><td>把给定组中所有进程的静态优先级都设置为一个给定的值</td></tr><tr><td>sched_getaffinity()</td><td>获取进程与处理器的亲和力掩码</td></tr><tr><td>sched_setaffinity()</td><td>设置进程与处理器的亲和力掩码</td></tr><tr><td>sched_getscheduler()</td><td>获取进程的调度策略</td></tr><tr><td>sched_setschedule()</td><td>设置一个进程的调度策略和实时优先级</td></tr><tr><td>sched_getparam()</td><td>获取一个进程的实时优先级</td></tr><tr><td>sched_setparam()</td><td>设置一个进程的实时优先级</td></tr><tr><td>sched_yield()</td><td>进程自愿暂时让出CPU</td></tr><tr><td>sched_get_priority_min()</td><td>获取最小的实时静态优先级</td></tr><tr><td>sched_get_priority_max()</td><td>获取最大的实时静态优先级</td></tr><tr><td>sched_rr_get_interval()</td><td>获得时间片轮转策略的时间片值</td></tr></tbody></table><ol><li><p><code>nice()</code>系统调用</p><p>&emsp;&emsp;该函数用于设置普通进程的静态优先级，它可以将给定进程的静态优先级增加一个给定的量，这时我们应该注意，这个给定的量有两种情况，第一种是将给定的进程的静态优先级加上一个正值，其实这相当于降低进程的优先级，第二种是将给定的进程的静态优先级加上一个负值，其实这相当于提高进程的优先级。</p><p>&emsp;&emsp;在Linux中规定，作为一般原则，总是允许用户降低他们进程的优先级，即给定的那个量是一个正值。然而，如果他们想修改属于某一用户进程的优先级，或者如果他们想增加自己进程的优先级，即给定的量是一个负值，那么，他们必须拥有超级用户的特权。</p><p>&emsp;&emsp;<code>nice()</code>函数会调用内核的<code>set_uer_nice()</code>函数，这个函数会设置进程的<code>task_struct</code>中的<code>static_prio</code>和<code>prio</code>的值。</p></li><li><p><code>getprioriity()</code>和<code>setpriority()</code>系统调用</p><p>&emsp;&emsp;<code>nice()</code>系统调用只影响调用它的进程，而另外两个系统调用<code>getpriority()</code>和<code>setpriority()</code>则作用于给定组中所有进程的基本优先级。<code>getpriority()</code>返回20减去给定组中所有进程之中最低<code>nice</code>字段的值，<code>setpriority()</code>把给定组中所有进程的基本优先级都设置为一个给定的值。</p></li><li><p><code>getaffinity()</code>和<code>setaffinity()</code>系统调用</p><p>&emsp;&emsp;Linux调度程序提供强制的处理器绑定机制，即它允许用户强制指定某个进程必须在相应的CPU上运行，所谓亲和力掩码就是用于指定该进程可以在哪个CPU上运行的一个标志位，它保存在进程结构体（<code>task_struct</code>)的<code>cpu_allowed</code>这个位掩码标志中。该掩码1的每一位对应于系统中的一个CPU，在默认情况下一个进程的该掩码所有的位都被设置，即默认情况下一个进程可以在系统中所有可用的CPU上运行。</p></li><li><p><code>sched_getscheduler()</code>和<code>sched_setscheduler()</code>系统调用</p><p>&emsp;&emsp;<code>sched_getscheduler()</code>和<code>sched_setscheduler()</code>分别用于设置和获取进程的调度策略和实时优先级。其主要工作就是读取和设置进程结构体<code>task_struct</code>中的<code>policy</code>和<code>rt_priority</code>域的值。</p><p>&emsp;&emsp;<code>sched_getscheduler()</code>函数查询与给定的pid相对应的进程当前所用的调度策略。如果pid为0，将检索调用该函数的进程的调度策略；如果成功，这个系统调用为进程返回策略。</p><p>&emsp;&emsp;<code>sched_setscheduler()</code>系统调用既可以设置调度策略，也可以设置与给定的pid相对应的进程的相关参数。如果pid为0，调用该函数的进程的调度程序参数将被设置。</p></li><li><p><code>sched_getparam()</code>和<code>sched_setparam()</code>系统调用</p><p>&emsp;&emsp;<code>sched_getparam()</code>和<code>sched_setparam()</code>分别用于设置和获取进程的实时优先级。<code>sched_getparam()</code>系统调用可以获取与给定的pid相对应的进程的实时优先级。如果pid为0，<code>current</code>进程的实时优先级将被检索。它首先找到与pid相关的进程描述符指针，把它的<code>rt_priority</code>字段存放在类型为<code>sched_param</code>的局部变量中，并调用<code>copy_to_user()</code>把它复制到进程地址空间中由<code>param</code>参数指定的地址。<code>sched_setparam()</code>系统调用类似于<code>sched_setscheduler()</code>，它与后者的不同在于不让调用者设置<code>policy</code>字段的值。</p></li><li><p><code>sched_yield()</code>系统调用</p><p>&emsp;&emsp;<code>sched_yield()</code>系统调用提供了一种让进程资源地让出CPU给其他等待执行的进程的方法，这个调用主要由<code>SCHED_FIFO</code>实时进程调用。</p><p>&emsp;&emsp;在Linux中对于实时进程和普通进程在调用该函数后的处理有些不同。当调用该函数的进程是一个普通进程时，内核会把该进程移到进程队列中的过期队列中，这样可以保证该进程在一段时间内不会再次被调度。当调用该函数的进程是一个实时进程时，由于实时进程不会过期，所以内核会将调用该函数的进程放到优先级队列的后面，而不是移到过期队列中。</p></li><li><p><code>sched_get_priority_min()</code>和<code>sched_get_priority_max()</code>系统调用</p><p>&emsp;&emsp;该系统调用主要用于返回给定调度策略的最大和最小优先级。实时调度策略的最大优先级时<code>MAX_USER_RT_PRIO</code>减1，最小优先级是1.当调用该函数时若<code>current</code>是实时进程,<code>sys_sched_get_priority_min()</code>服务例程返回1，否则返回0；<code>sys_sched_get_priority_max()</code>服务例程返回99（最高优先级），否则返回0.</p></li><li><p><code>sched_rr_get_interval()</code>系统调用</p><p><code>sched_rr_get_interval()</code>系统调用把参数pid表示的实时进程的轮转时间片写入用户态地址空间的一个结构中。如果pid等于0，系统调用就写当前进程的时间片。相应的<code>sys_sched_rr_get_interval()</code>服务例程同样带哦用<code>find_process_by_pid()</code>检索与pid相关的进程描述符。然后，把存放在所选中进程的基本时间片转换为秒数和纳秒数，并把它们复制到用户态的结构中，通常，FIFO实时进程的时间片等于0。</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&amp;emsp;&amp;emsp;Linux内核提供的一些系统调用主要用于管理和维护与进程调度相关的参数值，这些系统调用可以用来获取和设置进程的优先级、进程调度策略，以及进程与处理器的亲和力等。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;系统调用&lt;/th&gt;
&lt;th&gt;功
      
    
    </summary>
    
      <category term="Linux内核" scheme="http://wanqbin.xyz/categories/Linux%E5%86%85%E6%A0%B8/"/>
    
    
      <category term="操作系统" scheme="http://wanqbin.xyz/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="Linux内核" scheme="http://wanqbin.xyz/tags/Linux%E5%86%85%E6%A0%B8/"/>
    
      <category term="系统调用" scheme="http://wanqbin.xyz/tags/%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/"/>
    
  </entry>
  
</feed>

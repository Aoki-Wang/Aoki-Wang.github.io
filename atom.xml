<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Aoki&#39;s Blog</title>
  
  <subtitle>“吾生也有涯，而知无涯”</subtitle>
  <link href="/Aoki/atom.xml" rel="self"/>
  
  <link href="http://wanqbin.coding.me/Aoki/"/>
  <updated>2019-06-13T16:14:34.738Z</updated>
  <id>http://wanqbin.coding.me/Aoki/</id>
  
  <author>
    <name>Aoki</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>软件工程的内容和方法</title>
    <link href="http://wanqbin.coding.me/Aoki/2019/06/14/%E4%BB%B6%E5%B7%A5%E7%A8%8B%E7%9A%84%E5%86%85%E5%AE%B9%E5%92%8C%E6%96%B9%E6%B3%95/"/>
    <id>http://wanqbin.coding.me/Aoki/2019/06/14/件工程的内容和方法/</id>
    <published>2019-06-13T16:11:00.000Z</published>
    <updated>2019-06-13T16:14:34.738Z</updated>
    
    <content type="html"><![CDATA[<h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>&emsp;经过一个礼拜的准备，终于结束了软件工程的复习。在复习软件工程的同时也在做信息系统综合设计的课程设计。在做课程设计的过程中，发现了软件工程的重要性和必要性。作为立志成为程序猿的我，软件工程在将来的工作中一定大有用处，故总结如下。</p><h2 id="一、软件、软件工程、软件工程学科体系"><a href="#一、软件、软件工程、软件工程学科体系" class="headerlink" title="一、软件、软件工程、软件工程学科体系"></a>一、软件、软件工程、软件工程学科体系</h2><p>学习软件工程，首先得知道软件是什么。其次，得知道软件工程是做什么的，它研究了什么内容，同时也应该知道软件工程学科体系是什么，与软件工程有什么关系。</p><ol><li><h4 id="软件：最新定义为，软件-知识-程序-数据-文档"><a href="#软件：最新定义为，软件-知识-程序-数据-文档" class="headerlink" title="软件：最新定义为，软件=知识+程序+数据+文档"></a>软件：最新定义为，软件=知识+程序+数据+文档</h4><p>那么这里面的知识，程序，数据，文档又是指什么呢？</p><p>知识，即各种各样的相关领域的专业知识。</p><p>程序，即使对计算机任务的处理对象和处理规则的描述。这里，我们一定要注意，软件并不等于程序，这也是一大误区。</p><p>数据，即程序赖以运行的初始化数据。</p><p>文档，即为了理解程序所需的详细描述性资料。</p></li><li><h4 id="软件工程是什么？"><a href="#软件工程是什么？" class="headerlink" title="软件工程是什么？"></a>软件工程是什么？</h4><p>软件工程是研究软件开发和管理的一门工程学科。</p><p>这个定义很短，但是知识点还是挺多的。一强调开发，毕竟开发是软件工程的主体；二强调管理或过程管理，当然，管理是为了更好的开发；三是强调工程，把软件的开发和维护当成一项工程，用工程的办法去开发，按工程的办法去管理；四是强调学科，时至今日，软件工程不只是一门学科，而是一个学科体系。这里也就引出了软件工程学科体系。</p><blockquote><p>软件工程来源于软件危机。软件工程是为了克服软件危机才产生的。</p></blockquote></li><li><h4 id="软件工程学科体系"><a href="#软件工程学科体系" class="headerlink" title="软件工程学科体系"></a>软件工程学科体系</h4><blockquote><p>软件工程作为一个学科体系，到21世纪才初步形成。2004年ACM和IEEE-CS联合制订了SWEBOK 2004版，它将软件工程学科体系的知识划分为10个知识域。</p></blockquote><p>对于这10个知识域，我的理解是它覆盖了整个软件生命周期。</p><p>1） 软件需求</p><p>2）软件设计</p><p>3）软件构造</p><p>4）软件测试</p><p>5）软件维护</p><p>6）软件配置管理</p><p>7）软件工程管理</p><p>8）软件工程过程</p><p>9）软件工程工具和方法</p><p>10）软件质量</p></li><li><h4 id="软件工程和软件工程学科体系的关系"><a href="#软件工程和软件工程学科体系的关系" class="headerlink" title="软件工程和软件工程学科体系的关系"></a>软件工程和软件工程学科体系的关系</h4><p>总体上来说，软件工程是一个局部问题，而软件工程学科体系是一个整体问题。</p></li><li><h4 id="软件工程研究的内容"><a href="#软件工程研究的内容" class="headerlink" title="软件工程研究的内容"></a>软件工程研究的内容</h4><p>软件工程研究的内容主要有五个方面。</p><p>一是软件生命周期模型</p><p>二是软件开发方法</p><p>三是软件支持过程</p><p>四是软件管理过程</p><p>五是软件工程标准与规范</p></li><li><h4 id="软件工程基本原理"><a href="#软件工程基本原理" class="headerlink" title="软件工程基本原理"></a>软件工程基本原理</h4><p>软件工程的三要素：方法、工具和过程</p><p>有7个基本原理，外加一个二八定律。具体内容见文章末尾的链接。</p></li><li><h4 id="软件工程在行业中的作用"><a href="#软件工程在行业中的作用" class="headerlink" title="软件工程在行业中的作用"></a>软件工程在行业中的作用</h4><p>软件工程作为一门工程管理学科，它对软件行业的作用毋庸置疑。那么，这里会有一个问题，既然已经有软件工程了，那么还会不会出现软件危机呢？我的答案是会的。软件工程的产生是为了克服软件危机，但是它的存在并不会完全消除软件危机。这和现实社会中法律存在的意义是相通的。法律的产生是为了消除犯罪，但是法律的存在并不会完全消除犯罪（至少在当前的社会阶段是不会的）。</p><p>软件工程可以作用到从业者，也可以作用到项目组，作用到软件公司，甚至作用到整个国家的软件产业1发展。</p></li></ol><h2 id="二、软件工程方法论和软件工程实践论"><a href="#二、软件工程方法论和软件工程实践论" class="headerlink" title="二、软件工程方法论和软件工程实践论"></a>二、软件工程方法论和软件工程实践论</h2><h4 id="1-软件工程方法论是什么？"><a href="#1-软件工程方法论是什么？" class="headerlink" title="1.  软件工程方法论是什么？"></a>1.  软件工程方法论是什么？</h4><p>软件工程方法论实质上是软件工程中软件开发方法的集合。</p><p>那么软件工程方法的集合包括哪些元素呢？</p><h4 id="2-软件工程方法集合"><a href="#2-软件工程方法集合" class="headerlink" title="2.  软件工程方法集合"></a>2.  软件工程方法集合</h4><p>软件工程方法集合包括面向过程方法、面向对象方法、面向元数据方法。</p><h4 id="3-为什么说面向对象方法可以描述无穷的信息世界呢？"><a href="#3-为什么说面向对象方法可以描述无穷的信息世界呢？" class="headerlink" title="3.  为什么说面向对象方法可以描述无穷的信息世界呢？"></a>3.  为什么说面向对象方法可以描述无穷的信息世界呢？</h4><p>要搞清楚面向对象为什么可以描述无穷的世界，首先需要知道面向对象方法是什么，其次，需要知道现实世界和软件的普遍联系。</p><p>面向对象方法是什么？是一种运用对象、类、消息传递、继承、封装、聚合、多态性等概念构造软件系统的软件开发方法。</p><p>我记得高中哲学里面听到的一句话，世界是物质的，物质是运动的，运动是有规律的。而对于软件而言，其实质是对现实人工系统的一种映射、优化和替换。通过对现实世界的分析，我们可以知道，世界是由对象组成的，对象之间时存在普遍联系的，而物质运动则说明了对象的功能。</p><p>面向方法是将这现实世界抽象映射为对象的手段。分析设计时由对象抽象出类，程序运行时由类还原到了对象。所以它能够描述无穷的信息世界。</p><h4 id="4-软件工程实践论是什么？"><a href="#4-软件工程实践论是什么？" class="headerlink" title="4.  软件工程实践论是什么？"></a>4.  软件工程实践论是什么？</h4><p>软件工程实践论是研究在开发一个大型软件系统时，到底应该怎样选取合适的开发方法。</p><h2 id="5-软件工程实践论指什么？"><a href="#5-软件工程实践论指什么？" class="headerlink" title="5.  软件工程实践论指什么？"></a>5.  软件工程实践论指什么？</h2><p>“五个面向”实践论，指面向流程分析、面向元数据设计、面向对象实现、面向功能测试、面向过程管理。</p><p>在后面，我们会发现软件工程的“五个面向”实践论在各个软件生命周期模型中都有一定的体现。</p><h2 id="三、软件支持过程、软件管理过程"><a href="#三、软件支持过程、软件管理过程" class="headerlink" title="三、软件支持过程、软件管理过程"></a>三、软件支持过程、软件管理过程</h2><ol><li><h4 id="软件过程是什么？"><a href="#软件过程是什么？" class="headerlink" title="软件过程是什么？"></a>软件过程是什么？</h4><p>软件过程，指软件生命周期中的时间序列</p></li><li><h4 id="软件支持过程是什么？"><a href="#软件支持过程是什么？" class="headerlink" title="软件支持过程是什么？"></a>软件支持过程是什么？</h4><p>软件支持过程，由支持软件生命周期模型各个阶段的生产工具组成。</p></li><li><h4 id="软件生命周期中的生产工具有哪些？"><a href="#软件生命周期中的生产工具有哪些？" class="headerlink" title="软件生命周期中的生产工具有哪些？"></a>软件生命周期中的生产工具有哪些？</h4><p>CASE工具、软件开发环境SDE、软件工程环境SEE</p></li><li><h4 id="软件管理是什么？"><a href="#软件管理是什么？" class="headerlink" title="软件管理是什么？"></a>软件管理是什么？</h4><p>管理过程和支持过程又称为“软件过程工程”。它是软件工程的一部分。</p><p>软件管理实质上是过程管理。</p></li><li><h4 id="软件管理有哪几类？"><a href="#软件管理有哪几类？" class="headerlink" title="软件管理有哪几类？"></a>软件管理有哪几类？</h4><p>ISO 9001质量管理和质量保证体系</p><p>CMMI软件能力成熟度模型</p><p>软件企业文化，包括微软企业文化，IBM企业文化，敏捷文化。</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h2&gt;&lt;p&gt;&amp;emsp;经过一个礼拜的准备，终于结束了软件工程的复习。在复习软件工程的同时也在做信息系统综合设计的课程设计。在做课程设计
      
    
    </summary>
    
    
      <category term="软件工程" scheme="http://wanqbin.coding.me/Aoki/tags/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"/>
    
      <category term="软件工程方法论" scheme="http://wanqbin.coding.me/Aoki/tags/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E6%96%B9%E6%B3%95%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>关于const限定符的一些总结</title>
    <link href="http://wanqbin.coding.me/Aoki/2019/03/11/const%E9%99%90%E5%AE%9A%E7%AC%A6/"/>
    <id>http://wanqbin.coding.me/Aoki/2019/03/11/const限定符/</id>
    <published>2019-03-11T10:31:00.000Z</published>
    <updated>2019-06-11T10:36:12.688Z</updated>
    
    <content type="html"><![CDATA[<blockquote><h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1></blockquote><hr><p>有时候我们希望定义这样一种变量，它的值不能被改变。例如，用一个变量表示缓冲区的大小。使用变量的好处是我们觉得缓冲区不再合适的时候，很容易对其进行调整。另一方面，也应随时警惕，防止程序一不小心修改了这个值。为了满足这一要求，可以用关键词const对变量的类型加以限定。</p><p>在C++中，一个const不必创建内存空间，而在C中，const总是需要一块内存空间。在C++中，是否为const常量分配内存空间依赖于如何使用。一般来说，如果一个const仅仅用来把一个名字用一个值来代替，那么该存储空间就不必创建。</p><p>在存储空间没有分配内存的话，在进行完数据类型检查后，为了代码更加有效，值也许会折叠到代码中。<br>不过取一个const地址，或者把它定义为extern，则会为该const创建内存空间。  </p><p>在C++中，出现在所有函数之外的const作用于整个文件（也就是说它在该文件外部不可见，默认为内部连接，C++中其他标识符一般默认为外部连接。  </p><h2 id><a href="#" class="headerlink" title></a><br></h2><blockquote><h1 id="1-初始化和const"><a href="#1-初始化和const" class="headerlink" title="1.初始化和const"></a>1.初始化和const</h1></blockquote><hr><p><br><br><br>const类型的对象能完成非const类型所能完成的大部分操作，但是对于const类型对象的主要限制就是只能在const类型对的对象上执行不改变其内容的操作。</p><p>在不改变const对象的操作中还有一种是初始化，如果利用一个对象去初始化另外一个对象，则它们是不是const都无关紧要。  </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">12</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> ci = i;<span class="comment">//i的值拷贝给了ci</span></span><br><span class="line"><span class="keyword">int</span> j = ci;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"i="</span> &lt;&lt; i &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"ci="</span> &lt;&lt; ci &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"j="</span> &lt;&lt; j &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>输出结果如下：  ![](https://i.imgur.com/RpcPLLp.png)  <p><br><br></p><hr><blockquote><h1 id="2-const引用"><a href="#2-const引用" class="headerlink" title="2.const引用"></a>2.const引用</h1></blockquote><hr><br>可以把引用绑定到const对象上，就像绑定到其他对象上一样，我们称之为——常量引用。  <p>与普通引用不同的是，对常量的引用不能被用作修改它所绑定的对象。  </p><p>错误示范如下：<br><img src="https://i.imgur.com/ajppGmY.png" alt></p><hr><blockquote><h1 id="3-初始化和对const的引用"><a href="#3-初始化和对const的引用" class="headerlink" title="3.初始化和对const的引用"></a>3.初始化和对const的引用</h1></blockquote><hr><br>引用的类型必须与其所引用对象的类型一致，但是有两个情况例外。第一个例外情况就是在初始化常量引用时，允许用任意表达式作为初始值，只要该表达式的结果能转化成引用的类型即可。  <p>允许一个常量引用绑定非常量的对象、字面值、甚至是一般表达式。  </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">42</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;r1 = i;<span class="comment">//允许将const int &amp;绑定到一个普通int对象上</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;r2 = <span class="number">42</span>;<span class="comment">//r1是一个常量引用</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;r3 = r1 * <span class="number">2</span>;<span class="comment">//r3是一个常量引用</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"i="</span> &lt;&lt; i &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"r1="</span> &lt;&lt; r1 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"r2="</span> &lt;&lt; r2 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"r3="</span> &lt;&lt; r3 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果如下：<br><img src="https://i.imgur.com/MkT10uV.png" alt></p><p><br><br></p><hr><blockquote><h1 id="4-对cons的引用可能引用一个并非const的对象"><a href="#4-对cons的引用可能引用一个并非const的对象" class="headerlink" title="4.对cons的引用可能引用一个并非const的对象"></a>4.对cons的引用可能引用一个并非const的对象</h1></blockquote><hr><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">42</span>;</span><br><span class="line"><span class="keyword">int</span> &amp;r1 = i;<span class="comment">//引用r1绑定对象i</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;r2 = i;<span class="comment">//常量引用r2绑定i，但是r2不能修改i的值</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"i="</span> &lt;&lt; i &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"r1="</span> &lt;&lt; r1 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"r2="</span> &lt;&lt; r2 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">r1 = <span class="number">10</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"i="</span> &lt;&lt; i &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"r1="</span> &lt;&lt; r1 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"r2="</span> &lt;&lt; r2 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//r2 = 5;//此处报错，因为r2是一个常量引用</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果如下：<br><img src="https://i.imgur.com/96S3r6f.png" alt><br><br><br></p><p>对于常量引用来说，一般情况下是没有办法来对它进行修改的，但是可以使用下面的方法来尝试对常量引用进行修改。代码图如下：  </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;ref = <span class="number">10</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"ref="</span> &lt;&lt; ref &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">int</span> *p = (<span class="keyword">int</span> *)&amp;ref;</span><br><span class="line">*p = <span class="number">100</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"ref="</span> &lt;&lt; ref &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果如下：<br><img src="https://i.imgur.com/d4EB8c7.png" alt><br><br><br><br>这里我们使用了一个指针来对常量引用进行修改。首先，我们要知道的是，常量引用不是一个对象，编译器并没有给它分配内存空间。当我们使用指针指向常量引用时，编译器会给常量引用临时开辟一块内存空间。代码示意如下：  </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> tmp=ref;<span class="comment">//tmp有内存</span></span><br><span class="line"><span class="keyword">int</span> *p=(<span class="keyword">int</span> *)&amp;ref;<span class="comment">//*p指向的是那块临时空间，临时空间看不到</span></span><br></pre></td></tr></table></figure><p><br><br></p><hr><blockquote><h1 id="5-指针和const"><a href="#5-指针和const" class="headerlink" title="5.指针和const"></a>5.指针和const</h1></blockquote><hr><br>与引用一样，也可以令指针指向常量或非常量。类似于常量引用，指向常量的指针不能改变其所指对象的值。要想存放常量对象的地址，只能使用指向常量的指针。  实例代码如下：  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> i = <span class="number">10</span>;</span><br><span class="line"><span class="comment">//int *r1 = &amp;i;//报错，r1是一个普通指针，并不能指向一个常量</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> *r2 = &amp;i;<span class="comment">//常量指针指向常量</span></span><br><span class="line"><span class="comment">//常量指针可以指向常量，但是并不能修改常量的值</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"常量i的地址为："</span> &lt;&lt; &amp;i &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"r2指向的地址为："</span> &lt;&lt; r2 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"i="</span> &lt;&lt; i &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"r2="</span> &lt;&lt; *r2 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果如下：<br><img src="https://i.imgur.com/d24xVwj.png" alt><br><br><br></p><hr><blockquote><h1 id="6-const指针"><a href="#6-const指针" class="headerlink" title="6.const指针"></a>6.const指针</h1></blockquote><hr><br>指针是对象而引用不是，就像其他对象类型一样，允许把指针本身定义为常量。常量指针必须初始化，而且一旦初始化完成，则它的值（也就是存放在指针中的那个地址）就不能再修改。把*放在const关键字之前用以说明指针是一个常量。这样书写的意味着，不变的是指针本身的值，而不是指向的那个值。  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> *<span class="keyword">const</span> r1 = &amp;i;<span class="comment">//r1将一直指向i</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> i1 = <span class="number">11</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> *<span class="keyword">const</span> r2 = &amp;i1;<span class="comment">//r2是指向常量的常量指针</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"i=10时地址为："</span> &lt;&lt; &amp;i &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"常量指针r1指向的地址为："</span> &lt;&lt; r1 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">i = <span class="number">100</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"i=100时地址为："</span> &lt;&lt; &amp;i &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"常量指针r1指向的地址为："</span> &lt;&lt; r1 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果如下：<br><img src="https://i.imgur.com/SsAFLUA.png" alt></p><h2 id="-1"><a href="#-1" class="headerlink" title></a><br><br></h2><blockquote><h1 id="7-顶层const"><a href="#7-顶层const" class="headerlink" title="7.顶层const"></a>7.顶层const</h1></blockquote><hr><br>指针本身就是一个对象，它又可以指向1另外一个对象。因此指针本身是不是常量，以及指针指向的对象是不是一个常量是两个独立的问题。  <p>顶层const表示指针本身是一个常量。  </p><p>底层const表示指针所指的对象时一个常量。  </p><p>更一般地，顶层const可以表示任意的对象时常量，这一点对任何数据类型都适用，如算术类型、类、指针等。底层const则与指针和引用等符合类型的基本类型有关。比较特殊的是，指针类型既可以是顶层const，也可以是底层const。  </p><h2 id="-2"><a href="#-2" class="headerlink" title></a><br><br></h2><blockquote><h1 id="8-尽量使用const代替-define"><a href="#8-尽量使用const代替-define" class="headerlink" title="8.尽量使用const代替#define"></a>8.尽量使用const代替#define</h1></blockquote><hr><br>在旧版本的C中，如果想建立一个常量，必须使用预处理器。  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX 1024;</span></span><br></pre></td></tr></table></figure><p>这里我们定义的宏MAX从未被编译器看到过，因为在预处理阶段，所有的MAX已经全部被替换成了1024，于是MAX并没有将其加入符号表中。但是我们使用这个常量获得一个编译错误信息时，可能会带来一些困扰，因为这个信息可能会提到1024，但是并没有提到MAX。如果MAX被定义在一个不是我们自己写的头文件中，我们可能并不知道1024代表着什么，也许解决这个问题需要很长的时间。<br>解决这个问题的办法就是用一个常量来替换掉上面的宏：  </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX=<span class="number">1024</span>；</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> A <span class="comment">//卸载宏常量A</span></span></span><br></pre></td></tr></table></figure><p>###const和#define的区别  </p><ul><li>const有类型，可进行编译器类型安全检查，#define无类型，不可进行类型检查</li><li>const有作用域，而#define不重视作用域，默认定义处到文件末尾，如果定义在指定作用域下有效的常量，那么#define就不能用。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;h1 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h1&gt;&lt;/blockquote&gt;
&lt;hr&gt;
&lt;p&gt;有时候我们希望定义这样一种变量，它的值不能被改变。例如，用一
      
    
    </summary>
    
      <category term="C++" scheme="http://wanqbin.coding.me/Aoki/categories/C/"/>
    
    
      <category term="限定符" scheme="http://wanqbin.coding.me/Aoki/tags/%E9%99%90%E5%AE%9A%E7%AC%A6/"/>
    
  </entry>
  
  <entry>
    <title>C++复合类型</title>
    <link href="http://wanqbin.coding.me/Aoki/2019/03/09/C-%E5%A4%8D%E5%90%88%E7%B1%BB%E5%9E%8B/"/>
    <id>http://wanqbin.coding.me/Aoki/2019/03/09/C-复合类型/</id>
    <published>2019-03-09T00:26:00.000Z</published>
    <updated>2019-06-11T10:40:07.439Z</updated>
    
    <content type="html"><![CDATA[<p>复合类型是指基于其他类型定义的类型。C++有几种复合类型，下面主要是<code>引用</code>和<code>指针</code>。  定义复合类型的变量复杂很多，通用的描述为：一条声明语句由一个<code>基本数据类型</code>和紧随其后的一个<code>声明符</code>列表组成。每个声明符命名了一个变量并指定该变量为与基本数据类型有关的某种类型。  </p><hr><blockquote><h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1></blockquote><hr><p>C++11中新增加了一种引用，为<code>右值引用</code>，主要用于内置类。这里，我们使用<code>引用</code>时，指的是<code>左值引用</code>。  引用为对象起了另外一个名字，引用类型引用另外一种类型。通过将声明符写成<code>&amp;d</code>的形式来定义引用类型，其中d是声明的变量名。<br>引用即别名，并非对象，它只是为一个已经存在的对象所起的另外一个名字。<br>下面是引用的一个例子。  </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> vale = <span class="number">1024</span>;</span><br><span class="line"><span class="keyword">int</span> &amp;vale00 = vale; <span class="comment">//注意：引用必须进行初始化</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"vale的值为："</span> &lt;&lt; vale &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"vale00的值为："</span> &lt;&lt; vale00 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"vale00是vale的引用。"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://i.imgur.com/VPKK9Rk.png" alt><br><br><br>定义了一个引用之后，对其进行的所有操作都是在与之绑定的对象上进行的。<br>为引用赋值，实际上是把值赋给了与引用绑定的对象。获取引用的值，实际上是获取到了与之绑定的对象的值。同理，以引用作为初始值，实际上是以引用绑定的对象作为初始值。  </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">string</span> name = <span class="string">"青木"</span>;</span><br><span class="line"><span class="built_in">string</span> &amp;name_ = name;</span><br><span class="line"><span class="built_in">string</span> name0 = <span class="string">"Aoki"</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"大家好，我的名字是"</span> &lt;&lt; name_ &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"大家好，我是"</span> &lt;&lt; name0 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">name0 = name_;<span class="comment">//为引用赋值</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"大家好，我现在是"</span> &lt;&lt; name0 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果为：<br><img src="https://i.imgur.com/yxB0y8I.png" alt><br><br></p><hr><blockquote><h1 id="引用-1"><a href="#引用-1" class="headerlink" title="引用"></a>引用</h1></blockquote><hr><p><code>指针</code>是指向另外一种类型的复合类型。与引用类似，指针也实现了对其他对象的间接访问，但是指针与引用也有很多不同点，如下：  </p><ul><li>指针本身就是个对象，允许对指针赋值和拷贝，在指针的生命周期内，它可以先后指向几个不同的对象  </li><li>指针无须在定义时赋初值。和其他内置类型一样，在块作用域内定义的指针如果没有定义，也将拥有一个不确定的值。  <br>>## 获取对象的地址</li></ul><p>指针存放某个对象的地址，要向获取该地址，就要使用<code>取地址符</code>（&amp;）。<br>在声明语句中，指针的类型实际上被用于它所指向的对象的类型，所以二者必须匹配。如果指针指向了一个其他类型的对象，对该对象的操作将会发生错误。  </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">string</span> name = <span class="string">"青木"</span>;</span><br><span class="line"><span class="built_in">string</span>* name_=&amp;name;<span class="comment">//name_存放变量name的地址，或者说name_是指向变量name的指针</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"大家好，我的名字是"</span> &lt;&lt; name &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"name的地址为:"</span> &lt;&lt; name_ &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"大家好，我的名字是"</span> &lt;&lt; name_ &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果为：<br><img src="https://i.imgur.com/Rp1QNpE.png" alt><br><br><br><br></p><blockquote><h2 id="指针值"><a href="#指针值" class="headerlink" title="指针值"></a>指针值</h2></blockquote><p>指针的值（即地址）应属于下列4中状态之一：  </p><ol><li>指向一个对象 </li><li>指向紧邻对象所占空间的下一个位置</li><li>空指针，意味着指针没有指向任何值</li><li>无效指针，就是上述状态之外的其他值。</li></ol><p>对于无效指针，试图拷贝或以其他方式访问无效指针的值都将引发错误。  </p><br>>## 利用指针访问对象<p>如果一个指针指向了一个对象，则允许使用<code>解引用符</code>（*）来访问该对象。<br>对指针解引用会得到所指的对象，因此如果给解引用的结果赋值，实际上也就是给指针所指的内容赋值。  </p><blockquote><p>注意：解引用操作仅适用于那些确实指向了某个对象的有效指针。  </p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">string</span> name = <span class="string">"青木"</span>;</span><br><span class="line"><span class="built_in">string</span> name0 = <span class="string">"Aoki"</span>;</span><br><span class="line"><span class="built_in">string</span>* name_=&amp;name;<span class="comment">//name_存放变量name的地址，或者说name_是指向变量name的指针</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"大家好，我的名字是"</span> &lt;&lt; name &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"name的地址为:"</span> &lt;&lt; name_ &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"大家好，我的名字是"</span> &lt;&lt; *name_ &lt;&lt; <span class="built_in">endl</span>;<span class="comment">//指针解引用，获取对象的值</span></span><br><span class="line">*name_ = name0;<span class="comment">//经由指针为name赋值</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"大家好，我的名字是"</span> &lt;&lt; name &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"大家好，我的名字是"</span> &lt;&lt; *name_ &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>![](https://i.imgur.com/lno4Q9r.png)<br><blockquote><h2 id="空指针"><a href="#空指针" class="headerlink" title="空指针"></a>空指针</h2></blockquote><p>空指针不指向任何对象，在试图使用一个指针之前，代码可以首先检查它是否为空。<br>生成空指针的方法：  </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>* p1=<span class="literal">nullptr</span>;<span class="comment">//等价于int* ptr=0</span></span><br><span class="line"><span class="keyword">int</span>* p2=<span class="number">0</span>;<span class="comment">//直接将p2初始化为字面常量0</span></span><br></pre></td></tr></table></figure><p>得到空指针最直接的办法是使用字面值nullptr来初始化指针。nullptr是一种特殊的指针，它可以被转换成任意其他指针类型。<br><br><br><br></p><blockquote><h2 id="赋值和指针"><a href="#赋值和指针" class="headerlink" title="赋值和指针"></a>赋值和指针</h2></blockquote><p>指针额引用都能够提供对其他的对象的间接访问，但是在具体的实现细节上两者有很大不同，其中最主要的又掉了是引用本身并不是一个对象。<br>指针和它存放的地址之间没有这种限制。和其他任何变量一样，给指针赋值就是令它存放一个新地址，从而指向一个新对象。<br>对于指针的赋值，前文已经给出。  </p><blockquote><h2 id="其他指针操作"><a href="#其他指针操作" class="headerlink" title="其他指针操作"></a>其他指针操作</h2></blockquote><p>只要指针拥有一个合法值，就能将它用在条件表达式中。和采用算术值作为条件遵循的规则一样，如果指针的值是0，条件取false。<br>对于两个类型相同的合法指针，可以用相等操作符或不相等操作符来比较它们，比较的结果是布尔类型。<br>两个指针存放的地址值相同（两个指针相等），有三种可能：  </p><ul><li>它们都为空</li><li>都指向同一个对象</li><li>都指向同一个对象的下一个地址</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">string</span> name = <span class="string">"青木"</span>;</span><br><span class="line"><span class="built_in">string</span>* name_=&amp;name;<span class="comment">//name_存放变量name的地址，或者说name_是指向变量name的指针</span></span><br><span class="line"><span class="keyword">int</span>* a = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="keyword">if</span> (name_&amp;&amp;a) <span class="comment">//与运算，一真一假为假</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"大家好，我是指向"</span> &lt;&lt; name &lt;&lt; <span class="string">"的指针，我不为空"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"大家好，我是空指针a，我的地址是"</span> &lt;&lt; &amp;a &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果如下：<br><img src="https://i.imgur.com/VW47tJO.png" alt></p><p><br><br><br>最后是void*指针。</p><blockquote><h2 id="void-指针"><a href="#void-指针" class="headerlink" title="void* 指针"></a>void* 指针</h2></blockquote><p>void* 指针是一种特殊的指针类型，可用于存放任意对象的指针，一个void<em>指针存放着一个地址。<br>利用void</em>指针可以做的事有：  </p><ul><li>拿它和别的指针比较</li><li>作为函数的输入和输出</li><li>赋值给另外一个void*指针</li></ul><p>但是我们不能直接操作void* 指针，因为它的类型未知。以void*的视角来看内存空间也仅仅是内存空间，没办法访问内存空间中所存的对象。  </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span>  a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span>* name_=&amp;a;<span class="comment">//name_存放变量a的地址，或者说name_是指向变量a的指针</span></span><br><span class="line"><span class="keyword">void</span>* names;</span><br><span class="line">names = name_;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"name_指向的值为："</span> &lt;&lt; *name_ &lt;&lt;<span class="string">",地址为："</span>&lt;&lt;name_&lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"names地址为："</span> &lt;&lt; names &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：<br><img src="https://i.imgur.com/UaoQ4BV.png" alt></p><br><br><br><br>对于void* 指针，我还有许多不解的地方，在网上搜索之后发现了一个比较详细解释void* 指针的博文——[void及void指针含义的深刻解析](https://blog.csdn.net/geekcome/article/details/6249151?reload)<br><br><br><br><br>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;复合类型是指基于其他类型定义的类型。C++有几种复合类型，下面主要是&lt;code&gt;引用&lt;/code&gt;和&lt;code&gt;指针&lt;/code&gt;。  
定义复合类型的变量复杂很多，通用的描述为：一条声明语句由一个&lt;code&gt;基本数据类型&lt;/code&gt;和紧随其后的一个&lt;code&gt;声明符&lt;/
      
    
    </summary>
    
      <category term="C++" scheme="http://wanqbin.coding.me/Aoki/categories/C/"/>
    
    
      <category term="引用" scheme="http://wanqbin.coding.me/Aoki/tags/%E5%BC%95%E7%94%A8/"/>
    
      <category term="指针" scheme="http://wanqbin.coding.me/Aoki/tags/%E6%8C%87%E9%92%88/"/>
    
      <category term="复合类型" scheme="http://wanqbin.coding.me/Aoki/tags/%E5%A4%8D%E5%90%88%E7%B1%BB%E5%9E%8B/"/>
    
  </entry>
  
</feed>

<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Aoki&#39;s Blog</title>
  
  <subtitle>“惟将终夜长开眼，报答平生未展眉”</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://wanqbin.xyz/"/>
  <updated>2019-11-24T15:00:45.498Z</updated>
  <id>http://wanqbin.xyz/</id>
  
  <author>
    <name>Aoki</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Adapter模式</title>
    <link href="http://wanqbin.xyz/2019/Adapter%E6%A8%A1%E5%BC%8F/"/>
    <id>http://wanqbin.xyz/2019/Adapter模式/</id>
    <published>2019-11-24T14:58:00.000Z</published>
    <updated>2019-11-24T15:00:45.498Z</updated>
    
    <content type="html"><![CDATA[<p>一、Adapter模式</p><blockquote><p>将一个类的接口转换成客户希望的另外一个接口。Adapter模式使原本由于接口不兼容而不能一起工作的类可以一起工作。</p><p>​                                                                                                                                                                                            ——《设计模式》</p></blockquote><p>即：我们需要一种方式，为一个功能正确但接口不合的对象创建一个新的接口。</p><p>二、学习Adapter模式</p><p>假设客户提出的需求为：</p><ul><li>为都有“显示”(display)行为的点、线、正方形分别创建类；</li><li>客户对象不必知道自己到底拥有点、线还是正方形。他们只需要知道拥有这些形状中的一个。</li></ul><p>也就是说，我想要用一个更高层次的概念将这些具体形状都涵盖进入，这个高层概念可以称为“可显示的形状”。</p><p>也就是说，尽管系统中有点、线以及正方形，但是我希望客户对象认为只有形状。</p><ul><li>这样客户对象可以以相同的方式处理所有对象——无需关注它们的区别。</li><li>这样我未来还可以在客户对象不修改的情况下添加新的形状类型。</li></ul><p>这里将使用多态，也就是说，我的系统中将有许多不同的对象，但我希望对象的客户与它们交互的方式是通用的。</p><p>这里，客户对象只是简单地让点、线或正方形对象进行一些操作，比如“自我显示”或“自我擦除”。然后由每个点、线、正方形负责了解如何按自己的类型完成相应的行为。</p><p>为了实现这一点，我创建了一个Shape类，然后从它派生出表示点、线、正方形的类。如下图所示：</p><p><img src="/2019/Adapter模式/Adapter1.PNG" alt="Point,Line,Square继承自Shape"></p><p>首先，我必须指定Shape对象应提供的具体行为。为此，我在Shape类中为这些行为定义了接口，然后在每个派生类中都相应地实现了这些功能。</p><p>Shape类需要具备以下行为：</p><ul><li>设定一个Shape对象的位置</li><li>获取一个Shape对象的位置</li><li>显示一个Shape对象</li><li>填充一个Shape对象</li><li>设置一个Shape对象的颜色</li><li>擦除一个Shape对象</li></ul><p><img src="/2019/Adapter模式/Adapter显示方法.PNG" alt="显示了方法的Point，Line，Square"></p><p>假设现在客户要求实现一个圆——一种新的Shape。为此，我创建了一个新的类——Circle类来实现，并从Shape类派生出Circle类，这样我仍然可以获得多态行为。</p><p>那么，我必须为Circle类编写display,fill和undisplay方法。但是，我现在找到了一个现有的处理圆形的xxCircle类，但是这个类中的方法命名如下：</p><ul><li>displayIt</li><li>fillIt</li><li>undisplayIt</li></ul><p>这里，我不能直接使用xxCircle类，因为我想保持Shape类的多态行为。这有两个原因：</p><ul><li>名称和参数列表不同</li><li>我无法派生它</li></ul><p>而xxCircle无法修改。</p><p>既然无法改变，那就想办法适配！</p><p>我可以创建一个新类，它就是派生自Shape类，因此实现了Shape的接口，但是又用不着重写xxCircle类中的圆形的实现代码。</p><ul><li>Circle类派生自Shape</li><li>Circle包含xxCircle</li><li>Circle将发给自己的请求传送给xxCircle对象。</li></ul><p><img src="/2019/Adapter模式/Adapter Circle包装了xxCircle类.PNG" alt="Adapter模式：Circle类包装了xxCircle类"></p><p>当Circle对象实例化的时候，它必须实例化一个xxCircle对象。发给Circle对象的任何请求都将转给该xxCircle对象。如果能够总是如此，而且xxCircle对象具有Circle对象所需要的全部功能，Circle对象就可以通过让xxCircle做实际工作来实现自己的行为。</p><p>实现Adapter模式：</p><p>Shape.h</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Shape</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Shape(<span class="keyword">void</span>);</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="keyword">virtual</span> <span class="title">display</span><span class="params">()</span></span>= <span class="number">0</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ~Shape(<span class="keyword">void</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>Shape.cpp</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Shape::Shape(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Shape::~Shape(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> <strong>Circle.h</strong> </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Shape.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"XX_Circle.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span> :</span> <span class="keyword">public</span> Shape</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Circle(XX_Circle *xxCircle);</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ~Circle(<span class="keyword">void</span>);</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    XX_Circle *myXX_Circle;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>Circle.cpp</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Circle.h"</span></span></span><br><span class="line"></span><br><span class="line">Circle::Circle(XX_Circle *xxCircle)</span><br><span class="line">&#123;</span><br><span class="line">    myXX_Circle = xxCircle;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Circle::~Circle(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">delete</span> myXX_Circle;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> Circle::display()</span><br><span class="line">&#123;</span><br><span class="line">    myXX_Circle-&gt;displayIt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>XX_Circle.h</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">XX_Circle</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    XX_Circle(<span class="keyword">void</span>);</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">displayIt</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ~XX_Circle(<span class="keyword">void</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p> <strong>XX_Circle.cpp</strong> </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"XX_Circle.h"</span></span></span><br><span class="line"></span><br><span class="line">XX_Circle::XX_Circle(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">XX_Circle::~XX_Circle(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>三、Adapter模式：关键特征</p><ul><li>意图：使控制范围之外的一个原有对象与某个接口匹配。</li><li>问题：系统的数据和行为都正确，但接口不符。通常用于必须从抽象类派生时。</li><li>解决方案：Adapter模式提供了具有所需接口的包装类。</li><li>参与者与协作者：Adapter改变了Adaptee的接口，使Adaptee与Adapter的基类Target匹配。这样Client就可以使用Adaptee了，好像它是Target类型的。</li><li>效果：Adapter模式使原有对象能够适应新的类结构，不受其接口的限制。</li><li>实现：将原有类包含在另一个类中。让包含类与需要的接口匹配，调用被包容类的方法。</li></ul><p>四、Adapter模式与Facade模式</p><div class="table-container"><table><thead><tr><th></th><th>Facade模式</th><th>Adapter模式</th></tr></thead><tbody><tr><td>是否存在既有的类？</td><td>是</td><td>是</td></tr><tr><td>是否必须按某个接口设计？</td><td>否</td><td>是</td></tr><tr><td>对象需要多态行为吗？</td><td>否</td><td>可能</td></tr><tr><td>需要更简单的接口吗？</td><td>是</td><td>否</td></tr></tbody></table></div><p>从上表中，我们可以看到以下内容：</p><ul><li>在两个模式中，都存在既有的类</li><li>但是在Facade模式中，我无须按某个接口进行设计；而在Adapter模式中，则必须按某个特定的接口设计</li><li>在Facade模式中，我不需要多态行为，而Adapter模式中，多态行为可能是需要的</li><li>Facade模式中的动机是简化接口。而在Adapter模式中，尽管也是越简单越好，但是设计必须遵循一个已有的接口，不能简化任何东西，即使可能存在更简单的接口。</li></ul><p>结论：Facade模式简化了接口，而Adapter模式则将一个已有的接口转换成另一个接口。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;一、Adapter模式&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;将一个类的接口转换成客户希望的另外一个接口。Adapter模式使原本由于接口不兼容而不能一起工作的类可以一起工作。&lt;/p&gt;
&lt;p&gt;​                                       
      
    
    </summary>
    
      <category term="设计模式" scheme="http://wanqbin.xyz/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="Adapter模式" scheme="http://wanqbin.xyz/tags/Adapter%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="适配器模式" scheme="http://wanqbin.xyz/tags/%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Facade模式</title>
    <link href="http://wanqbin.xyz/2019/Facade%E6%A8%A1%E5%BC%8F/"/>
    <id>http://wanqbin.xyz/2019/Facade模式/</id>
    <published>2019-11-24T14:55:00.000Z</published>
    <updated>2019-11-24T14:57:36.450Z</updated>
    
    <content type="html"><![CDATA[<p>一、Facade 模式</p><blockquote><p>为子系统中的一组接口提供一个统一接口。Facade模式定义了一个更高层的接口，使子系统更加容易使用。</p><p>​                                            </p><p>​                                                                                                                                                                                            ——《设计模式》</p></blockquote><p>即：我们需要用一种比原有方式更简单的办法与系统交互，或者说，我们需要以一种特殊的方式使用系统（例如以二维的方式使用一个三维绘图程序）。</p><p>二、Facade 模式：关键特征</p><ul><li><p>意图：希望简化原有系统的使用方式。需要定义自己的接口。</p></li><li><p>问题：只需要使用某个复杂系统的子集，或者，需要以一种特殊的方式与系统交互。</p></li><li><p>解决方案：Facade为原有系统的客户提供了一个新的接口。</p></li><li><p>参与者与协作者：为客户提供一个简单的接口，使系统更容易使用。（接口本身和各个子系统）</p></li><li><p>效果：Facade模式简化了对所需子系统的使用过程。但是，由于Facade并不完整，因此客户可能无法使用某些功能。</p></li><li><p>实现：</p><ul><li><p>注意点：</p><ul><li>降低客户-子系统之间的耦合度。用抽象类实现Facade而它的具体子类对应于不同的子系统实现，这可以进一步降低客户与子系统的耦合度。</li><li>公共子系统与私有子系统。一个子系统与一个类的相似之处是，它们都有接口，并且都封装了一些东西——类封装了状态和操作，而子系统封装了一些类。考虑一个类的公共和私有接口是有益的，我们也可以考虑子系统的公共和私有接口。<ul><li>子系统的公共接口包含所有的客户程序可以访问的类</li><li>私有接口仅用于对子系统进行扩充。</li><li>Facade类是公共接口的一部分，但它不是唯一的部分，子系统的其他部分通常也是公共的。</li></ul></li></ul></li><li><p>定义一个（或多个）具备所需接口的新类。</p></li><li>让新的类使用原有的系统。</li></ul></li></ul><p>三、Facade模式：实践</p><p><img src="/2019/Facade模式/Facade模式使用前.PNG" alt="Facade模式使用前"></p><p>假设Client对象必须处理Database，Model，Element对象。Client必须首先通过Database对象打开数据库，获取Model对象，然后再查询Model对象，获取Element对象，最后请求Element对象的信息。如果能够创建一个可供Client查询的Database Facade，那么，以上过程将容易得多。</p><p><img src="/2019/Facade模式/Facade模式.PNG" alt="Facade模式可以减少客户需要处理的对象数量"></p><p>Facade模式提出了一种通用方法：它为我提供了起点。这个模式的Facade部分实际上就是创建了一种新的接口供客户使用，来替代原有的接口。之所以能够这样做，是因为Client对象并不需要原系统提供的所有功能。</p><p>Facade模式还可以用来隐藏或者封装系统。Facade类能够将系统作为自己的私有成员包含进来。在此情况下，原系统将与Facade类联系起来，但Facade类的客户无需看到。</p><p>封装系统的原因如下：</p><ul><li>跟踪系统的使用情况——通过强制所有系统的访问都必须经过Facade，可以很容易地监视系统地使用情况。</li><li>改换系统——未来可能需要切换系统。通过将原系统作为Facade类地一个私有成员，可以最省力地切换到新的系统。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;一、Facade 模式&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;为子系统中的一组接口提供一个统一接口。Facade模式定义了一个更高层的接口，使子系统更加容易使用。&lt;/p&gt;
&lt;p&gt;​                                            &lt;/
      
    
    </summary>
    
      <category term="设计模式" scheme="http://wanqbin.xyz/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="Facade模式" scheme="http://wanqbin.xyz/tags/Facade%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="外观模式" scheme="http://wanqbin.xyz/tags/%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>UML和类图</title>
    <link href="http://wanqbin.xyz/2019/UML%E5%92%8C%E7%B1%BB%E5%9B%BE/"/>
    <id>http://wanqbin.xyz/2019/UML和类图/</id>
    <published>2019-11-24T09:03:00.000Z</published>
    <updated>2019-11-24T09:09:07.771Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、什么是UML？"><a href="#一、什么是UML？" class="headerlink" title="一、什么是UML？"></a>一、什么是UML？</h2><p>UML是一种用来创建程序模型的图形语言（即带有语义的一种图形记号）。</p><h3 id="1-UML图及其用途"><a href="#1-UML图及其用途" class="headerlink" title="1. UML图及其用途"></a>1. UML图及其用途</h3><div class="table-container"><table><thead><tr><th>当你在……</th><th>所使用的UML图</th></tr></thead><tbody><tr><td>分析阶段</td><td>用例图，所涉及的是与系统之间交互的实体，以及需要实现的功能点</td></tr><tr><td></td><td>活动图，关注的是【问题领域和其他主体工作的实际空间，程序的主题领域】的工作流，而不是程序的逻辑流</td></tr><tr><td>观察对象的交互</td><td>交互图，说明了特定对象如何相互交互。因为它们处理的都是具体情况而不是一般情况，所以在检查需求和设计时都很有用。最常见的一种交互图是顺序图。</td></tr><tr><td>设计阶段</td><td>类图，详细说明了类之间的关系</td></tr><tr><td>观察对象所处状态不同时行为的差异</td><td>状态图，详细描述了对象可能所处的不同状态以及在这些状态之间的转换。</td></tr><tr><td>配置阶段</td><td>部署图，说明如何部署不同模块。</td></tr></tbody></table></div><h3 id="2-为什么使用UML？"><a href="#2-为什么使用UML？" class="headerlink" title="2. 为什么使用UML？"></a>2. 为什么使用UML？</h3><ul><li><p>UML主要是用来交流的。</p></li><li><p>UML提供了一种方法，可以用来确定我对系统的理解是否与其他人相同。因为系统非常复杂，有许多不同种类的信息需要传递，所以UML提供了许多不同的图专门表示不同种类的信息。</p></li></ul><h2 id="二、类图"><a href="#二、类图" class="headerlink" title="二、类图"></a>二、类图</h2><p>类图不仅描述了类，而且说明了类之间的关系。这些关系可能有以下这些类型：</p><ul><li>当一个类是“一种”另一个类时：<code>is-a</code>（是一种/一个）关系</li><li>当两个类之间存在关联时：<ul><li>一个类“包含”另一个类：<code>has-a</code>（拥有一个）关系；</li><li>一个类“使用”另一个类：<code>use-a</code>（使用一个）关系；</li><li>一个类“创建”另一类</li></ul></li></ul><p>这些类型还有一些变体。比如，说“什么东西包含另一个东西”时，我们可能是指：</p><ul><li>被包含者是包含者的一部分（比如汽车中的发动机）</li><li>有一个集合，集合中东西可以独立存在（比如机场上的飞机）</li></ul><p>第一种情况被称为<strong>组合</strong>(composition)，第二种情况被称为<strong>聚集</strong>(aggregation)。</p><p>首先，矩形表示一个类。在UML中，可以表示最多三个方面的类的信息：</p><ul><li>类名</li><li>类的数据成员</li><li>类的方法（函数）</li></ul><p><img src="/2019/UML和类图/类图——三种变体.PNG" alt="类图——三种变体"></p><p>表示类的信息有三种不同方式：</p><ul><li>最左边的矩形只显示了类名。在不需要更详细信息时，可以使用类的这种表示形式。</li><li>中间的举行显示了类名和类的方法。Square类有一个display方法。display前的加号（+）表示此方法是公开的。</li><li>最右边的矩形除显示了前面的信息之外，还显示了类的数据成员。</li></ul><p>表示访问权限的UML记号：</p><ul><li>公开——用一个加号（+）标记。</li><li>保护——用一个井号（#）标记。</li><li>私有——用一个减号（-）标记。</li></ul><p>表示关系的UML记号有如下四种：</p><p><img src="/2019/UML和类图/表示关系的UML记号.PNG" alt="表示关系的UML记号"></p><p>类图还可以表示不同类之间的关系。下图显示了Shape类和它的几个派生类之间的关系。</p><p><img src="/2019/UML和类图/is-a关系.PNG" alt="is-a关系的类图"></p><p>上图说明了几件事：</p><ul><li>首先，Shape类下面的箭头的意思是：指向Shape的那些类派生自Shape类。</li><li>而且，Shape类的名字使用<em>斜体</em>表示的，说明它是一个抽象类。抽象类是用来为其派生类定义接口而且存放这些派生类共哦那个数据和方法的类。</li><li>接口可以看作是没有公共数据和方法的抽象类——它只用来作为一种“为要实现它的那些类的方法进行定义”的方式而已。</li></ul><p>如前所述，有两种<code>has-a</code>关系。</p><ul><li><p>一个对象可以拥有另一个对象，其中被包含的对象是包含对象的一部分——或者不是。</p><ul><li><p>在下图中，Airport“拥有”Aircraft。Aircraft并不是Airport的一部分，但仍然可以说Airport拥有Aircraft，这种关系称为<strong>聚集</strong>或<strong>聚合</strong>。</p><p><img src="/2019/UML和类图/聚合关系.PNG" alt="has-a关系"></p><ul><li>jet表示喷气式飞机，Helicopter表示直升飞机。</li></ul></li></ul></li><li><p>另一种<code>has-a</code>关系是包含，被包含的对象是包含对象的一部分，这种关系称为组合。</p><ul><li><p>在下图中，Car（轿车）拥有Tire（轮胎），后者是Car的一部分。</p></li><li><p>下图还显示Car使用了GasStation（加油站）类，这种使用关系用带箭头的虚线表示，也称为<strong>依赖</strong>。</p><p><img src="/2019/UML和类图/组合关系.PNG" alt="组合&amp;&amp;依赖"></p></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、什么是UML？&quot;&gt;&lt;a href=&quot;#一、什么是UML？&quot; class=&quot;headerlink&quot; title=&quot;一、什么是UML？&quot;&gt;&lt;/a&gt;一、什么是UML？&lt;/h2&gt;&lt;p&gt;UML是一种用来创建程序模型的图形语言（即带有语义的一种图形记号）。&lt;/p&gt;
&lt;h3
      
    
    </summary>
    
      <category term="设计模式" scheme="http://wanqbin.xyz/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="http://wanqbin.xyz/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="UML" scheme="http://wanqbin.xyz/tags/UML/"/>
    
      <category term="类图" scheme="http://wanqbin.xyz/tags/%E7%B1%BB%E5%9B%BE/"/>
    
  </entry>
  
  <entry>
    <title>面向对象泛型</title>
    <link href="http://wanqbin.xyz/2019/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%B3%9B%E5%9E%8B/"/>
    <id>http://wanqbin.xyz/2019/面向对象泛型/</id>
    <published>2019-11-23T09:44:00.000Z</published>
    <updated>2019-11-23T09:45:27.753Z</updated>
    
    <content type="html"><![CDATA[<p>面向对象泛型以对象概念为中心，一切都集中在对象之上，编写代码时是围绕对象而非函数进行组织的。</p><p>使用对象的优点在于，可以定义自己负责自己的事物。对象天生就知道自己的类型。对象中的数据能够告诉它自己的转台如何，而对象中的代码能够使它正确工作。</p><div class="table-container"><table><thead><tr><th>对象</th><th>责任</th></tr></thead><tbody><tr><td>Student</td><td>知道自己所在的教室;知道自己下堂课的教室；从一个教室到下一个教室</td></tr><tr><td>Instructor</td><td>告诉学生到下堂课的教室去</td></tr><tr><td>Classroom</td><td>有明确的地址</td></tr><tr><td>Direction giver</td><td>对于给定的两个教室，指出从一个教室到另一个教室的路线</td></tr></tbody></table></div><p>在这种情况下，对象是通过寻找在问题领域中的实体而被发现的。然后再通过查看这些实体需要做些什么，为每个对象确定责任。这与通过在需求中寻找名词发现对象和通过寻找动词发现方法的技术是一致的。</p><p>理解对象的最佳方式，是将其看成“具有责任的东西”。</p><p>有一条好的设计规则：对象应该自己负责自己，而且应该清楚地定义责任。</p><p>从<strong>软件开发过程中的视角</strong>观察对象：</p><ul><li>在概念层次上，对象是一组责任</li><li>在规约层次上，对象是一组可以被其他对象或对象自己调用的方法</li><li>在实现层次上，对象是代码和数据，以及它们之间的计算交互。</li></ul><p>因为对象具有责任并且自己负责自己，所以必须有方法告诉对象要做什么。对象含有说明自己状态的数据，还有实现必要功能的方法。对象的很多方法都将标识为可被其他对象调用。这些方法的集合就称为对象的公共接口。</p><p>面向对象的相关术语：</p><div class="table-container"><table><thead><tr><th>术语</th><th>描述</th></tr></thead><tbody><tr><td>抽象类（abstract class）</td><td>定义了一组相关类的行为。</td></tr><tr><td>类(class)</td><td>根据对象所具有的责任定义对象的类型。责任可以访问行为和/或状态。这些分别是由方法和/或数据实现的。</td></tr><tr><td>具体类(concrete class)</td><td>实现抽象类某一特定类型行为的类。具体类是一个概念特定、不变的实现。</td></tr><tr><td>封装(encapsulation)</td><td>通常定义为数据隐藏，但最好将它看作任何形式的隐藏（类型、实现和设计等等）</td></tr><tr><td>继承(inheritance)</td><td>一个类继承另一个类，是指它接受了该类的一些或者所有性质。其实类被称为基类、超类、父类或泛化类，而继承类称为派生类、子类或特化类</td></tr><tr><td>实例(instance)</td><td>类的特例（总是一个对象）。类的特殊实例或实体。每个对象都有自己的状态。因此，同一个类型（类）可以有多个对象。</td></tr><tr><td>实例化(instantiation)</td><td>创建类的一个实例的过程。</td></tr><tr><td>接口(interface)</td><td>接口与类类似，但是只为其成员提供规约而不提供实现。它与只含有抽象成员的抽象类很相似。编程的时候，如果需要几个类共享公共基类中没有的一些特性，而且希望确保每个类自己实现这些特定（因为所有成员都是抽象的），就应该使用接口。</td></tr><tr><td>视角(perspective)</td><td>观察对象有三种视角：概念视角、规约视角和实现视角。这三个不同层次的区别在理解抽象类与其派生类之间的关系上用处很大。抽象类定义了如何在概念层次上解决问题，还提供了与任何派生对象通信的规约。每个派生类都按需要提供特定的实现。</td></tr><tr><td>多态(polymorphism)</td><td>能够用一种方式引用一个类的不同派生类，但获得的行为对应于所引用的派生类。</td></tr></tbody></table></div>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;面向对象泛型以对象概念为中心，一切都集中在对象之上，编写代码时是围绕对象而非函数进行组织的。&lt;/p&gt;
&lt;p&gt;使用对象的优点在于，可以定义自己负责自己的事物。对象天生就知道自己的类型。对象中的数据能够告诉它自己的转台如何，而对象中的代码能够使它正确工作。&lt;/p&gt;
&lt;div c
      
    
    </summary>
    
      <category term="设计模式" scheme="http://wanqbin.xyz/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="面向对象泛型" scheme="http://wanqbin.xyz/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%B3%9B%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>面向对象泛型之前：功能分解</title>
    <link href="http://wanqbin.xyz/2019/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%B3%9B%E5%9E%8B%E4%B9%8B%E5%89%8D%EF%BC%9A%E5%8A%9F%E8%83%BD%E5%88%86%E8%A7%A3/"/>
    <id>http://wanqbin.xyz/2019/面向对象泛型之前：功能分解/</id>
    <published>2019-11-23T09:43:00.000Z</published>
    <updated>2019-11-23T09:44:21.098Z</updated>
    
    <content type="html"><![CDATA[<p>功能分解方法的一个问题在于，它通常会导致让一个“主“程序负责控制子程序，这是将功能分解为多个子功能的自然结果。但是主程序所承受的责任太多了：要确保一切正常工作，还要协调各函数并控制它们的先后顺序，因此经常会产生非常复杂的代码。如果让一些子函数负责自己的行为，并且能够告诉主函数执行某些任务，并信任它知道如何执行，这种方式比功能分解的方式要容易得多。这就是所谓的<strong>委托</strong>。</p><p>功能分解的另一个问题是，它在为未来可能出现的变化未雨绸缪方面，在对代码合适地改进方面，都于事无补。变化是无可避免的，经常是因为自己要为已有的主题增加新的变体。例如，我可能不得不处理新的形状，或者需要显示形状的新办法。如果将实现各步骤的所有逻辑代码都放在一个大函数或者大模块中的话，那么这些步骤的任何实质性变化，都必须都这个函数或模块进行修改。</p><p>内聚性指的是”例程中操作之间的紧密程度“。</p><p>耦合性指的是”两个例程之间联系的紧密程度。耦合性与内聚性是相辅相成的关系。内聚性描述的是一个例程内部组成部分之间相互联系的紧密程度，而耦合性描述的是一个例程与其他例程之间联系的紧密程度。软件开发的目标应该是创建这样的例程：内部完成（高内聚），而与其他例程之间的联系则是小巧、直接、可见、灵活的“。</p><blockquote><p>假设你是一个会议的讲师，听课的人课后还要去听其他课，但它们不知道下一堂课的听课地点。你的责任之一，就是确保大家都知道下一堂课去哪里上。</p></blockquote><p>如果按照结构化程序设计的方法，可以这样做:</p><ol><li>获得听课人的名字</li><li>对于名单上的每个人，做以下工作：<ul><li>找到他要听的下一节课</li><li>找到该课的听课地点</li><li>找到从你的教师到下一堂课地点怎么走</li><li>告诉这个人怎样去上下一堂课</li></ul></li></ol><p>为了完成上面的工作，你可能需要编写：</p><ol><li>获得听课人名单的方法</li><li>获得每个人课程表方法</li><li>告诉某个人如何从你的教室到其他教室的程序</li><li>为听课的每个人服务的一个控制程序，它可以为每个人完成所需的步骤</li></ol><p>&gt;<br>&gt;</p><blockquote><p>你可能会把从这个教室到其他教室的路线贴出来，然后告诉课堂上的所有人：”我已经将下一堂课的地点和其他教室的位置都贴在教室后面了。请根据它找到你们下一堂课的教室。“</p><p>可以预期每个人都知道自己的下一堂课是什么，而且他们都能从你提供的列表中查到正确的教室，然后按照指示找到它。</p></blockquote><p>这两种方法的区别何在？</p><ul><li>第一种，直接给没每个人都提供提示，你必须密切关注大量细节，除你之外没有其他人负责。</li><li>第二种，你只给出通用的提示，然后期待每个人会自己弄清怎样完成任务。</li></ul><p><strong>其中最大的区别就是这样责任的转移</strong></p><p>第二种方法有以下三种不同：</p><ul><li>人们对自己的行为负责，而不再由一个中央控制程序负责决定他们的行为。</li><li>控制程序可以与不同类型的人交流，好像他们都一样。</li><li>控制程序不需要知道学生从此教室到彼教室可能采取的任何特殊步骤。</li></ul><p>软件开发过程中的视角</p><div class="table-container"><table><thead><tr><th>视角</th><th>描述</th></tr></thead><tbody><tr><td>概念</td><td>这种视角要回答的问题是：”软件要负责什么？“</td></tr><tr><td>规约</td><td>考虑软件的接口，而不是实现。这个视角要回答的问题是：”怎么使用软件？“</td></tr><tr><td>实现</td><td>这个视角要回答的问题是：”软件怎样履行自己的责任？“</td></tr></tbody></table></div>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;功能分解方法的一个问题在于，它通常会导致让一个“主“程序负责控制子程序，这是将功能分解为多个子功能的自然结果。但是主程序所承受的责任太多了：要确保一切正常工作，还要协调各函数并控制它们的先后顺序，因此经常会产生非常复杂的代码。如果让一些子函数负责自己的行为，并且能够告诉主函
      
    
    </summary>
    
      <category term="设计模式" scheme="http://wanqbin.xyz/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="面向对象" scheme="http://wanqbin.xyz/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
  </entry>
  
  <entry>
    <title>私有docker仓库搭建</title>
    <link href="http://wanqbin.xyz/2019/%E7%A7%81%E6%9C%89docker%E4%BB%93%E5%BA%93%E6%90%AD%E5%BB%BA/"/>
    <id>http://wanqbin.xyz/2019/私有docker仓库搭建/</id>
    <published>2019-11-20T03:06:00.000Z</published>
    <updated>2019-11-20T03:07:49.944Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h2><p>&emsp;&emsp;使用公有仓库，我们可以很方便地分享自己的镜像，也可以使用其他人分享的镜像。但是有时候，公有仓库并不是很适合，比如某些镜像可能只是希望在内部用户间共享，这时可以搭建一个私有的仓库服务器。</p><p>&emsp;&emsp;搭建私有的仓库服务器有两种方式：一是使用容器运行docker-registry，二是本地安装运行docker-registry。</p><p>&emsp;&emsp;docker-registry是一个基于Python的开源项目，为我们提供了私有镜像服务器的功能。</p><h2 id="二、使用容器运行docker-registry"><a href="#二、使用容器运行docker-registry" class="headerlink" title="二、使用容器运行docker-registry"></a>二、使用容器运行docker-registry</h2><ol><li><h3 id="获取官方镜像"><a href="#获取官方镜像" class="headerlink" title="获取官方镜像"></a>获取官方镜像</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull registry</span><br></pre></td></tr></table></figure></li><li><h3 id="运行registry"><a href="#运行registry" class="headerlink" title="运行registry"></a>运行registry</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -p 5000:5000 registry   #-d表示表示后台运行，-p表示端口映射</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;通过上面的命令，我们的私有服务器就以默认参数运行了。我们也可以配合使用<code>-e</code>和<code>-v</code>参数来该该改变服务器的运行参数。一是配置文件的路径，二是仓库的路径。</p><ul><li><h4 id="配置文件的路径：通过类似下面的命令改变："><a href="#配置文件的路径：通过类似下面的命令改变：" class="headerlink" title="配置文件的路径：通过类似下面的命令改变："></a>配置文件的路径：通过类似下面的命令改变：</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -p 5000:5000 -v /home/share/registry-conf:/root/registry-conf -e DOCKER_REGISTRY_CONFIG=/root/registry-conf/config.yaml registry</span><br></pre></td></tr></table></figure><p>在本地目录<code>/home/share/registry-conf</code>下存放着要使用的配置文件，通过<code>-v</code>参数将它映射到容器的<code>/root/registry-conf</code>目录，使用<code>-e</code>用环境变量的方式指定<code>/root/registry-conf/config.yaml</code>为程序的配置文件。</p></li><li><h4 id="配置仓库路径：通过类似下面的命令改变："><a href="#配置仓库路径：通过类似下面的命令改变：" class="headerlink" title="配置仓库路径：通过类似下面的命令改变："></a>配置仓库路径：通过类似下面的命令改变：</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -p 5000:5000 -v /opt/data/registry:/tmp/registry registry</span><br></pre></td></tr></table></figure><p>官方镜像使用的仓库路径是<code>/tmp/registry</code>，我们通过把本地路径映射到<code>/tmp/registry</code>。可以让服务器把镜像保存到我们自定义的路径下。</p></li></ul><p>这里我使用的命令是：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -i -t -p 5000:5000 -v /data/registry:/var/lib/registry  --restart=always --name registry registry:latest</span><br></pre></td></tr></table></figure><ul><li>—restart=always：这是重启策略，加入这个容器异常退出会自动重启容器</li><li>—name registry：创建容器命名为registry</li><li>registry:latest：这是刚刚pull下来的镜像</li></ul></li><li><h3 id="配置-etc-docker-daemon-json"><a href="#配置-etc-docker-daemon-json" class="headerlink" title="配置/etc/docker/daemon.json"></a>配置<code>/etc/docker/daemon.json</code></h3><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"insecure-registries"</span>:[<span class="string">"192.168.43.114:5000"</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里<code>192.168.43.114</code>是私有仓库的IP地址。</p><p>其他机器pull私有仓库镜像的时候，也需要在该文件中添加如上内容。</p></li><li><h3 id="查看镜像仓库中的镜像"><a href="#查看镜像仓库中的镜像" class="headerlink" title="查看镜像仓库中的镜像"></a>查看镜像仓库中的镜像</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl http://127.0.0.1:5000/v2/_catalog</span><br></pre></td></tr></table></figure></li><li><h3 id="为镜像打标签"><a href="#为镜像打标签" class="headerlink" title="为镜像打标签"></a>为镜像打标签</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker tag 镜像名 127.0.0.1:5000/镜像名</span><br></pre></td></tr></table></figure></li><li><h3 id="上传镜像"><a href="#上传镜像" class="headerlink" title="上传镜像"></a>上传镜像</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker push 127.0.0.1:5000/镜像名</span><br></pre></td></tr></table></figure></li><li><h3 id="拉取私有仓库镜像"><a href="#拉取私有仓库镜像" class="headerlink" title="拉取私有仓库镜像"></a>拉取私有仓库镜像</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull 192.168.43.114:5000/镜像名</span><br></pre></td></tr></table></figure></li></ol><h2 id="三、在本地安装运行docker-registry"><a href="#三、在本地安装运行docker-registry" class="headerlink" title="三、在本地安装运行docker-registry"></a>三、在本地安装运行docker-registry</h2><p>&emsp;&emsp;这里使用的CentOS7。</p><ul><li><h3 id="安装相关依赖库"><a href="#安装相关依赖库" class="headerlink" title="安装相关依赖库"></a>安装相关依赖库</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install -y python-devel libevent-devel python-pip gcc xz-devel</span><br></pre></td></tr></table></figure></li><li><h3 id="安装相关python模块"><a href="#安装相关python模块" class="headerlink" title="安装相关python模块"></a>安装相关python模块</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install gunicorn pyyaml flask flask-cors rsa gevent</span><br></pre></td></tr></table></figure></li><li><h3 id="安装docker-registry"><a href="#安装docker-registry" class="headerlink" title="安装docker-registry"></a>安装docker-registry</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python-pip install docker-registry</span><br></pre></td></tr></table></figure></li><li><h3 id="启动服务器"><a href="#启动服务器" class="headerlink" title="启动服务器"></a>启动服务器</h3><p>通过下面的命令，可以启动服务器：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gunicorn --access-logfile /var/log/docker-registry/access.log --error-logfile /var/log/docker-registry/server.log -k gevent --max-requests 100 --graceful-timeout 3600 -t 3600 -b 127.0.0.1:5000 -w 1 docker_registry.wsgi:application</span><br></pre></td></tr></table></figure><p>使用HTTP方式访问本地的5000端口，如果看到类似下面的输出，说明服务器正常运行了。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">curl 127.0.0.1:5000</span><br><span class="line">"\"docker-registry server\""</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、概述&quot;&gt;&lt;a href=&quot;#一、概述&quot; class=&quot;headerlink&quot; title=&quot;一、概述&quot;&gt;&lt;/a&gt;一、概述&lt;/h2&gt;&lt;p&gt;&amp;emsp;&amp;emsp;使用公有仓库，我们可以很方便地分享自己的镜像，也可以使用其他人分享的镜像。但是有时候，公有仓库并不是
      
    
    </summary>
    
      <category term="分布式与云计算" scheme="http://wanqbin.xyz/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%8E%E4%BA%91%E8%AE%A1%E7%AE%97/"/>
    
    
      <category term="docker" scheme="http://wanqbin.xyz/tags/docker/"/>
    
      <category term="私有仓库" scheme="http://wanqbin.xyz/tags/%E7%A7%81%E6%9C%89%E4%BB%93%E5%BA%93/"/>
    
      <category term="registry" scheme="http://wanqbin.xyz/tags/registry/"/>
    
  </entry>
  
  <entry>
    <title>镜像和Dockerfile</title>
    <link href="http://wanqbin.xyz/2019/%E9%95%9C%E5%83%8F%E5%92%8CDockerfile/"/>
    <id>http://wanqbin.xyz/2019/镜像和Dockerfile/</id>
    <published>2019-11-19T17:48:00.000Z</published>
    <updated>2019-11-19T17:49:29.645Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、镜像与容器"><a href="#一、镜像与容器" class="headerlink" title="一、镜像与容器"></a>一、镜像与容器</h2><ul><li>镜像是一个包含程序运行必要依赖环境和代码的只读文件，它采用分层的文件系统，将每一次改变以读写层的形式增加到原来的只读文件上。</li><li>镜像是容器运行的基石。如果将容器理解为一套程序运行的虚拟环境，那么镜像就是用来构建这个环境的模板。</li><li>镜像的最底层必须是一个称为启动文件系统（bootfs）的镜像，用户不会与这一层直接打交道。bootfs的上层镜像叫做根镜像（rootfs），它在通常情况下是一个操作系统。用户的镜像必须构建于根镜像之上。</li><li>镜像的本质是磁盘上的一系列文件的集合。创建新的镜像其实就是对已有经i想文件进行增、删、改、查操作，镜像之间并不是独立的，而是存在单向的文件依赖关系。</li><li>镜像的写时复制机制<ul><li>通过<code>docker run</code>命令指定镜像创建一个容器时，实际上是在该镜像之上创建一个空的可读写文件系统层级。可以将这个文件系统当成一个新的临时镜像，而命令里所指定的镜像称为父镜像。父镜像的内容都是以只读方式挂在进来的，容器会读取父镜像的内容。不过一旦需要修改父镜像文件，便会触发Docker从父镜像中复制这个文件到临时镜像中来，所有的修改均发生在你的文件系统中，而不会对父镜像造成任何影响，这就是Docker镜像的写时复制机制。</li></ul></li></ul><h2 id="二、本地镜像的管理"><a href="#二、本地镜像的管理" class="headerlink" title="二、本地镜像的管理"></a>二、本地镜像的管理</h2><ol><li><h3 id="查看"><a href="#查看" class="headerlink" title="查看"></a>查看</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker images</span><br></pre></td></tr></table></figure><ul><li>REPOSITORY：仓库名称</li><li>TAG：用于区分同一仓库中的不同镜像。如果未指定，默认为latest</li><li>IMAGE ID：每个镜像都有一个字符串类型、长为64位的HashID，用来全网标识一个镜像。</li><li>CREATED：镜像的创建时间。</li><li>VIRTUAL SIZE：镜像所占的虚拟大小，该大小包含所有共享文件的大小。</li></ul></li><li><h3 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker search 镜像名   #在Docker Hub上搜索符合要求的镜像</span><br><span class="line">docker pull 镜像名 #拉取镜像</span><br></pre></td></tr></table></figure></li><li><h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rmi 镜像名/镜像ID</span><br></pre></td></tr></table></figure><p>删除本地所有镜像：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rm $(docker ps -a -q)</span><br></pre></td></tr></table></figure><p>其中，<code>docker ps -a -q</code>命令用来列出所有容器的ID。</p></li></ol><h2 id="三、创建本地镜像"><a href="#三、创建本地镜像" class="headerlink" title="三、创建本地镜像"></a>三、创建本地镜像</h2><ol><li><h3 id="使用commit命令创建本地镜像"><a href="#使用commit命令创建本地镜像" class="headerlink" title="使用commit命令创建本地镜像"></a>使用<code>commit</code>命令创建本地镜像</h3><p>使用镜像创建并运行一个镜像，实际上是在父镜像的基础上构建一个可读写的文件层级。我们在容器中所做的修改，都发生在这个层级上。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker run -i -t centos    #在centos镜像上创建运行一个容器</span><br><span class="line"><span class="meta">#</span>在该容器中安装软件</span><br><span class="line">exit #退出该容器</span><br></pre></td></tr></table></figure><p>在这里，需要注意的是，要保存当前创建的容器的ID。在退出容器后，执行下面的命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker commit -m="Message" --author="Aoki" 容器ID aoki/centos:v1</span><br></pre></td></tr></table></figure><p><code>-m</code>参数是描述本次创建的镜像的信息，<code>--author</code>参数用来指定作者信息，<code>aoki</code>表示仓库名，这里需要注意的是，在命名的过程中，有一定的标准，比如不能使用大写字母，<code>centos</code>表示镜像名，<code>v1</code>标识镜像TAG名。</p></li><li><h3 id="使用Dockerfile创建镜像"><a href="#使用Dockerfile创建镜像" class="headerlink" title="使用Dockerfile创建镜像"></a>使用Dockerfile创建镜像</h3><p>使用Dockerfile创建镜像是是将所有的配置信息都写入到了一个文件中，然后使用<code>docker build</code>命令来创建一个镜像。这种方法可以使镜像的创建变得透明和独立化，并且创建过程可以被重复执行。Dockerfile文件以行为单位，行首为Dockerfile命令，命令都是大写形式，其后紧跟的是命令的参数。</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#version: 1.0.1</span></span><br><span class="line"><span class="comment">#指定父镜像</span></span><br><span class="line"><span class="keyword">FROM</span> ubuntu:latest</span><br><span class="line"></span><br><span class="line"><span class="keyword">MAINTAINER</span> Aoki <span class="string">"aoki3352@163.com"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#设置root用户为后续命令的执行者</span></span><br><span class="line"><span class="keyword">USER</span> root</span><br><span class="line"></span><br><span class="line"><span class="comment">#执行操作</span></span><br><span class="line"><span class="keyword">RUN</span> apt-get update</span><br><span class="line"><span class="keyword">RUN</span> apt-get install -t nginx</span><br><span class="line"></span><br><span class="line"><span class="comment">#使用&amp;&amp;拼接命令</span></span><br><span class="line"><span class="keyword">RUN</span> touch test.txt &amp;&amp; echo "abc" &gt; abc.txt</span><br><span class="line"></span><br><span class="line"><span class="comment">#对外暴露接口</span></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">80</span> <span class="number">8080</span> <span class="number">1038</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#添加文件</span></span><br><span class="line"><span class="keyword">ADD</span> /webapp /opt/webapp  #添加当前文件夹中的/webapp文件到 /opt/webapp目录下</span><br><span class="line"></span><br><span class="line"><span class="comment">#添加网络文件</span></span><br><span class="line"><span class="keyword">ADD</span> https://www.baidu.com/img/xxxx.png /opt #添加网络文件到/opt目录下</span><br><span class="line"></span><br><span class="line"><span class="comment">#设置环境变量</span></span><br><span class="line"><span class="keyword">ENV</span> WEBAPP_PORT=<span class="number">9090</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#设置工作目录</span></span><br><span class="line"><span class="keyword">WORKDIR</span> /opt</span><br><span class="line"></span><br><span class="line"><span class="comment">#设置启动命令</span></span><br><span class="line"><span class="keyword">ENTRYPOINT</span> ["ls"]</span><br><span class="line"></span><br><span class="line"><span class="comment">#设置启动参数</span></span><br><span class="line"><span class="keyword">CMD</span> ["-a","-l"]</span><br><span class="line"></span><br><span class="line"><span class="comment">#设置卷</span></span><br><span class="line"><span class="keyword">VOLUME</span> ["/data","/var/www"]</span><br><span class="line"></span><br><span class="line"><span class="comment">#设置子镜像的触发操作</span></span><br><span class="line"><span class="keyword">ONBUILD</span> <span class="keyword">ADD</span> . /app/src</span><br><span class="line"><span class="keyword">ONBUILD</span> <span class="keyword">RUN</span> echo "on build excuted" &gt;&gt; onbuild.txt</span><br></pre></td></tr></table></figure><p>下面的各个命令的含义：</p><ul><li><code>FROM</code>：指定待扩展的父镜像。除了注释之外，在文件开头必须是一个<code>FROM</code>指令，接下来的指令便在这个父级镜像的环境中运行，直到遇到下一个<code>FROM</code>指令。</li><li><code>MAINTAINER</code>：用来声明创建的镜像的作者信息。分别是 用户名、用户邮箱。这个命令不是必须的。</li><li><code>USER</code>：为容器的运行及接下来指令的运行指定用户或UID。</li><li><code>RUN</code>：用来修改镜像的命令，接下来的指令会在新的镜像上继续执行。</li><li><code>EXPOSE</code>：用来指明容器内进程对外开发的端口，多个端口之间使用空格隔开。运行容器时，通过参数<code>-P</code>即可将<code>EXPOSE</code>里所指定的端口映射到主机上另外的随机端口，其他容器或主机就可以通过映射后的端口与此容器进行通信。同时，也可以使用<code>-p</code>参数将<code>EXPOSE</code>没有列出的端口设置成公开。</li><li><code>ADD</code>：向新镜像中添加文件<ul><li><code>ADD</code>命令的第一个参数用来指定源文件（夹），可以是文件路径、文件夹路径或网络文件的URL地址，但是需要注意的是，如果是文件（夹）路径的话，必须是Dockerfile文件所在目录的相对路径。</li><li>第二个参数是文件需要放置在目标镜像的位置。如果源文件是主机上<code>zip</code>或者<code>tar</code>形式的压缩文件，Docker会先解压缩，然后添加到镜像的指定路径。如果是一个通过URL指定的网络压缩文件，则不会解压。</li></ul></li><li><code>VOLUME</code>：该命令会在镜像里创建一个指定路径的挂载点，这个路径可以来自主机或者其他容器。多个容器可以通过同一个挂载点共享数据，即便其中一个容器已经停止，挂载点也依然可以访问，只有当挂载点的容器引用全部消失时，挂载点才会自动删除。</li><li><code>WORKDIR</code>：为接下来执行的指令指定一个新的工作目录，这个目录可以是绝对路径，也可以是相对路径。</li><li><code>ENV</code>：设置容器运行的环境变量，在运行容器的时候，通过<code>-e</code>参数可以修改这个环境变量值，也可以添加新的环境变量。</li><li><code>CMD</code>：用来设置启动容器时默认运行的命令。</li><li><code>ENTRYPOINT</code>：与<code>CMD</code>类似，用来指定容器启动时默认运行的命令</li><li><code>ONBUILD</code>：触发器指令。构建镜像的时候，Docker的镜像构建器会将所有的<code>ONBUILD</code>指令指定的命令保存到镜像的元数据中，这些命令在当前镜像的构建过程中并不会执行。只有新的镜像使用<code>FROM</code>指令指定该镜像为父镜像时，便会触发执行。</li></ul><h3 id="docker-build命令创建构建镜像："><a href="#docker-build命令创建构建镜像：" class="headerlink" title="docker build命令创建构建镜像："></a><code>docker build</code>命令创建构建镜像：</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -t aoki/xxx:v1 .</span><br></pre></td></tr></table></figure><p><code>-t</code>参数用来指定镜像的命名空间，仓库名和TAG。</p><p>命令最后的<code>.</code>表示Dockerfile文件所在的相对路径，这里是指当前路径。</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、镜像与容器&quot;&gt;&lt;a href=&quot;#一、镜像与容器&quot; class=&quot;headerlink&quot; title=&quot;一、镜像与容器&quot;&gt;&lt;/a&gt;一、镜像与容器&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;镜像是一个包含程序运行必要依赖环境和代码的只读文件，它采用分层的文件系统，将每一次改变以
      
    
    </summary>
    
      <category term="分布式与云计算" scheme="http://wanqbin.xyz/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%8E%E4%BA%91%E8%AE%A1%E7%AE%97/"/>
    
    
      <category term="docker" scheme="http://wanqbin.xyz/tags/docker/"/>
    
      <category term="Dockerfile" scheme="http://wanqbin.xyz/tags/Dockerfile/"/>
    
      <category term="镜像" scheme="http://wanqbin.xyz/tags/%E9%95%9C%E5%83%8F/"/>
    
  </entry>
  
  <entry>
    <title>Docker和容器</title>
    <link href="http://wanqbin.xyz/2019/Docker%E5%92%8C%E5%AE%B9%E5%99%A8/"/>
    <id>http://wanqbin.xyz/2019/Docker和容器/</id>
    <published>2019-11-19T16:25:00.000Z</published>
    <updated>2019-11-19T16:26:14.105Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、Docker是什么？"><a href="#一、Docker是什么？" class="headerlink" title="一、Docker是什么？"></a>一、Docker是什么？</h2><p>Docker是容器的一种，容器是一种轻量级的虚拟技术，和容器对应的更为重量级的虚拟技术是虚拟机。虚拟机是一种基于硬件的虚拟技术，它采用指令级的模拟，完全模拟一整套物理主机。容器是一种基于操作系统的虚拟技术，它运行在操作系统之上的用户空间，所有的容器都共用一个系统内核，甚至是公共库，容器引擎提供进程级别的隔离，让每个容器都像运行在单独的系统之上，但又能共享很多底层资源。</p><h2 id="二、Docker的组件"><a href="#二、Docker的组件" class="headerlink" title="二、Docker的组件"></a>二、Docker的组件</h2><p>Docker采用C/S架构。Docker客户端，即Docker可执行程序，可以通过命令行和API的形式与Docker守候程序进行通信，Docker守候程序提供Docker服务。</p><p>Docker包含三大核心组件——镜像，容器和库。</p><ul><li>镜像：是一个只读的静态模板。它保存着容器需要的环境和应用的执行代码，可以把镜像看成是容器的代码，当代码运行起来后就成了容器。镜像采用分层机制，每个镜像都是只读的，但是可以将写数据的层通过联合文件系统附加在原有的镜像之上。这种增量式修改使得镜像非常容器存储、传输和更新。</li><li>容器：是一个运行时环境，它是一个镜像的运行状态，想到对于静态的镜像而言，容器是镜像执行的动态表现。</li><li>库：Docker采用注册服务器来存储和共享用户的镜像，库是某个特定用户存储镜像的目录。通常，一个用户可以建立多个库来保存自己的镜像。如Docker官方的Docker Hub。</li></ul><h2 id="三、容器的管理操作"><a href="#三、容器的管理操作" class="headerlink" title="三、容器的管理操作"></a>三、容器的管理操作</h2><ol><li><h3 id="创建容器"><a href="#创建容器" class="headerlink" title="创建容器"></a>创建容器</h3><ul><li><p>docker create</p><p> 创建的容器处于停止状态</p></li><li><p>docker run</p><p>不仅创建的容器，而且启动了容器</p></li></ul><p>容器创建后，会返回容器的ID。</p><p>要想让创建的容器立马进入运行态，可以使用<code>docker run</code>命令，该命令相当于下面的两条命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker create</span><br><span class="line">docker start</span><br></pre></td></tr></table></figure><p>使用<code>docker run</code>命令可以创建两种类型的容器——后台型容器和交互型容器。</p><ul><li>交互型容器：运行在前台，通常会指定有交互的控制台，可以给容器输入，也可以得到容器的输出。创建该容器的终端被关闭，在容器内部使用<code>exit</code>命令或者调用了<code>docker stop</code>、<code>docker kill</code>命令后，容器会变成停止状态。</li><li>后台型容器：运行在后台，创建启动之后就与终端无关。即便终端关闭了，该后台容器也依然存在，只有调用<code>docker stop</code>或<code>docker kill</code>命令时才能够使容器变成停止状态。</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -i -t --name=inspect_shell ubuntu /bin/bash</span><br></pre></td></tr></table></figure><p>其中，<code>-i</code>用于打开容器的标准输入(STDIN),<code>-t</code>告诉Docker为容器建立一个命令行终端。</p><p><code>--name</code>为容器指定一个名字，是一个可选项。如果没有这个选项，Docker会为容器创建一个随机名字</p><p><code>ubuntu</code>是镜像名，<code>/bin/bash</code>代表告诉Docker要在容器里面执行命令<code>/bin/bash</code>。</p><p>执行该命令之后，如果本地没有该镜像，Docker会从远程仓库中获取。然后，Docker使用这个镜像创建一个新的容器并将其启动；容器的文件系统是在只读的镜像文件上增加一层可读写的文件层，这样可以保证镜像不变而只记录改变的数据，这对容器的共享和传输都非常有利。接着会配置容器的网络，Docker会为容器分配一个虚拟网络接口，并通过网桥的方式将该网络接口桥接到宿主主机上，然后该虚拟网络接口分配一个IP地址。最后，Docker在新容器中运行指定的命令。</p></li><li><h3 id="查看容器"><a href="#查看容器" class="headerlink" title="查看容器"></a>查看容器</h3><p>查看正在运行的容器：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker ps</span><br></pre></td></tr></table></figure><p>CONTAINER ID：唯一标识容器的ID</p><p>IMAGE：创建容器时使用的镜像</p><p>COMMAND：容器最后运行的命令</p><p>CREATED：创建容器的时间</p><p>STATUS：容器的状态</p><p>PORT：对外开放的接口</p><p>NAMES：容器名。和容器ID一样都可以唯一标识一个容器。</p><p>查看所有的容器：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker ps -a</span><br></pre></td></tr></table></figure><p>列出所有容器，包括运行的和停止的容器。</p></li><li><h3 id="启动容器"><a href="#启动容器" class="headerlink" title="启动容器"></a>启动容器</h3><p>通过<code>docker create</code>命令创建的容器会进入到停止状态，想要运行该容器，可以执行以下命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker start 容器名/容器ID</span><br></pre></td></tr></table></figure></li><li><h3 id="终止容器"><a href="#终止容器" class="headerlink" title="终止容器"></a>终止容器</h3><p>执行命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker stop 容器名/容器ID</span><br></pre></td></tr></table></figure></li><li><h3 id="删除容器"><a href="#删除容器" class="headerlink" title="删除容器"></a>删除容器</h3><p>执行命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rm 容器名</span><br></pre></td></tr></table></figure><p>注意：不可以删除一个运行中的容器，必须先用<code>docker stop</code>或<code>docker kill</code>命令停止它才能删除。当然，也可以使用<code>-f</code>选项强制删除。</p><p>删除所有容器：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rm 'docker ps -a -q'</span><br></pre></td></tr></table></figure><p><code>-a</code>标志列出所有容器，<code>-q</code>标志只列出容器的ID，不包括容器的其他信息。然后将这个列表传给<code>docker rm</code>命令，依次删除容器。</p></li></ol><h2 id="四、容器内信息获取与命令执行"><a href="#四、容器内信息获取与命令执行" class="headerlink" title="四、容器内信息获取与命令执行"></a>四、容器内信息获取与命令执行</h2><ol><li><h3 id="依附容器"><a href="#依附容器" class="headerlink" title="依附容器"></a>依附容器</h3><p>依附操作<code>attach</code>通常用于由<code>docker start</code>或者<code>docker restart</code>启动的交互型容器中。由于<code>docker start</code>启动的交互型容器并没有具体终端可以依附，而容器本身是可以接收用户交互的，这时就需要通过<code>attach</code>命令来将终端依附到容器上。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker attach 容器ID</span><br></pre></td></tr></table></figure></li></ol><ol><li><h3 id="查看容器日志"><a href="#查看容器日志" class="headerlink" title="查看容器日志"></a>查看容器日志</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker logs -f 容器名 </span><br><span class="line">docker logs -f --tails=5 容器名   #控制logs输出的日志行数，只输出最后五行</span><br></pre></td></tr></table></figure></li></ol><ol><li><h3 id="查看容器进程"><a href="#查看容器进程" class="headerlink" title="查看容器进程"></a>查看容器进程</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker top 容器名</span><br></pre></td></tr></table></figure></li><li><h3 id="查看容器信息"><a href="#查看容器信息" class="headerlink" title="查看容器信息"></a>查看容器信息</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker inspect 容器名</span><br></pre></td></tr></table></figure><p>用来查看容器的配置环境，包括容器名，环境变量，运行命令，主机配置，网络配置和数据卷配置等。使用<code>-f</code>或者<code>--format</code>命令格式化标志，可以查看指定部分的信息。</p></li><li><h3 id="容器的导入与导出"><a href="#容器的导入与导出" class="headerlink" title="容器的导入与导出"></a>容器的导入与导出</h3><p>Docker的导入和导出分别由<code>import</code>命令和<code>export</code>命令完成。</p><p>使用<code>docker export</code>命令导出容器：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker export 容器名 &gt; my_container.tar</span><br></pre></td></tr></table></figure><p><code>docker export</code>命令会把容器的文件系统以tar包的格式导出到标准输出。我们将其定位到目标文件<code>name.tar</code>。将容器保存到本地文件也算是持久化方式的一种。将容器保存到本次之后，我们就可以通过网络等方法将tar包分享给他人。</p><p>使用<code>docker import</code>命令导入一个本地的tar包作为镜像：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat my_container.tar | docker import - imported:container</span><br></pre></td></tr></table></figure><p><code>docker import</code>会把打包的容器导入为一个镜像。</p><p><code>import</code>表示从标准输入读取容器内容，我们把<code>name.tar</code>的内容传给标准输入，res和tag代表生成的镜像和标记。</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、Docker是什么？&quot;&gt;&lt;a href=&quot;#一、Docker是什么？&quot; class=&quot;headerlink&quot; title=&quot;一、Docker是什么？&quot;&gt;&lt;/a&gt;一、Docker是什么？&lt;/h2&gt;&lt;p&gt;Docker是容器的一种，容器是一种轻量级的虚拟技术，和容器
      
    
    </summary>
    
      <category term="分布式与云计算" scheme="http://wanqbin.xyz/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%8E%E4%BA%91%E8%AE%A1%E7%AE%97/"/>
    
    
      <category term="Docker" scheme="http://wanqbin.xyz/tags/Docker/"/>
    
      <category term="容器" scheme="http://wanqbin.xyz/tags/%E5%AE%B9%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>Kubernetes集群部署</title>
    <link href="http://wanqbin.xyz/2019/Kubernetes%E9%9B%86%E7%BE%A4%E9%83%A8%E7%BD%B2/"/>
    <id>http://wanqbin.xyz/2019/Kubernetes集群部署/</id>
    <published>2019-11-19T14:05:00.000Z</published>
    <updated>2019-11-19T14:08:22.267Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、环境概述"><a href="#一、环境概述" class="headerlink" title="一、环境概述"></a>一、环境概述</h2><ul><li><h3 id="节点信息"><a href="#节点信息" class="headerlink" title="节点信息"></a>节点信息</h3></li></ul><div class="table-container"><table><thead><tr><th>IP</th><th>角色</th><th>服务器名</th></tr></thead><tbody><tr><td>192.168.43.60</td><td>Master</td><td>Matser</td></tr><tr><td>192.168.43.61</td><td>Node</td><td>Node1</td></tr><tr><td>192.168.43.62</td><td>Node</td><td>Node2</td></tr><tr><td>192.168.43.63</td><td>Node</td><td>Node3</td></tr></tbody></table></div><ul><li><h3 id="服务器配置信息"><a href="#服务器配置信息" class="headerlink" title="服务器配置信息"></a>服务器配置信息</h3><p>Master：虚拟机CentOS7</p><p>Node：虚拟机CentOS7</p></li></ul><ul><li><h3 id="节点分布："><a href="#节点分布：" class="headerlink" title="节点分布："></a>节点分布：</h3><p>利用局域网中的四台电脑中的虚拟机实现K8S集群的部署。</p></li></ul><h2 id="二、部署步骤"><a href="#二、部署步骤" class="headerlink" title="二、部署步骤"></a>二、部署步骤</h2><p>需要说明的是，kubernetes集群部署可以采用二进制文件进行安装，也可以采用kubeadm工具快速安装kubernetes，这里我使用了kubeadm工具。</p><ol><li><h3 id="设置服务器名"><a href="#设置服务器名" class="headerlink" title="设置服务器名"></a>设置服务器名</h3><p>分别设置各个服务器名：</p><p>执行命令：<code>vi /etc/hostname</code></p><p>Master：修改<code>localhost</code>为<code>Master</code></p><p>Node1：修改<code>localhost</code>为<code>Node1</code></p><p>Node2：修改<code>localhost</code>为<code>Node2</code></p><p>Node3：修改<code>localhost</code>为<code>Node3</code></p></li><li><h3 id="设置HOST"><a href="#设置HOST" class="headerlink" title="设置HOST"></a>设置HOST</h3><p>在每个节点中执行命令：<code>vi /etc/hosts</code></p><p>插入如下内容：</p></li></ol>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">192.168.43.60 Master</span><br><span class="line">192.168.43.61 Node1</span><br><span class="line">192.168.43.61 Node2</span><br><span class="line">192.168.43.61 Node3</span><br></pre></td></tr></table></figure><ol><li><h3 id="时间同步"><a href="#时间同步" class="headerlink" title="时间同步"></a>时间同步</h3><p>执行下列命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ntpdate cn.pool.ntp.org</span><br></pre></td></tr></table></figure><p>若提示ntpdate未安装，执行命令：<code>yum install ntpdate</code></p></li><li><h3 id="关闭防火墙-开启特定端口策略"><a href="#关闭防火墙-开启特定端口策略" class="headerlink" title="关闭防火墙/开启特定端口策略"></a>关闭防火墙/开启特定端口策略</h3><p>在各个节点上执行如下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">systemctl disable firewalld</span><br><span class="line">systemctl stop firewalld</span><br></pre></td></tr></table></figure></li></ol><ol><li><h3 id="禁用SELinux，让容器可以读取主机文件系统"><a href="#禁用SELinux，让容器可以读取主机文件系统" class="headerlink" title="禁用SELinux，让容器可以读取主机文件系统"></a>禁用SELinux，让容器可以读取主机文件系统</h3><p>在各个节点上执行如下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setenforce 0</span><br></pre></td></tr></table></figure></li></ol><ol><li><h3 id="配置yum源"><a href="#配置yum源" class="headerlink" title="配置yum源"></a>配置yum源</h3><p>在各个服务器上执行命令： <code>*vi /etc/yum.repos.d/kubernetes.repo*</code></p><p>插入如下内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[kubernetes]</span><br><span class="line">name=Kubernetes Repository</span><br><span class="line">baseurl=https://mirrors.aliyun.com/kubernetes/yum/repos/kubernetes-el7-x86_64/</span><br><span class="line">enabled=1</span><br><span class="line">gpgcheck=0</span><br></pre></td></tr></table></figure></li><li><h3 id="安装kubeadm和相关工具"><a href="#安装kubeadm和相关工具" class="headerlink" title="安装kubeadm和相关工具"></a>安装kubeadm和相关工具</h3><p>执行如下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install -y kubelet kubeadm kubectl --disableexcludes=kubernetes</span><br></pre></td></tr></table></figure></li><li><h3 id="安装docker-ce"><a href="#安装docker-ce" class="headerlink" title="安装docker-ce"></a>安装docker-ce</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install docker-ce</span><br></pre></td></tr></table></figure><p>若报类似于nothing的错误，执行命令：<code>yum update</code></p><p>然后执行<code>yum search docker-ce</code></p><p>之后根据查找结果安装docker-ce</p></li><li><h3 id="启动Docker服务和kubectl服务"><a href="#启动Docker服务和kubectl服务" class="headerlink" title="启动Docker服务和kubectl服务"></a>启动Docker服务和kubectl服务</h3><p>执行下列命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">systemctl enable docker &amp;&amp; systemctl start docker</span><br><span class="line">systemctl enable kubelet &amp;&amp; systemctl start kubelet</span><br></pre></td></tr></table></figure></li><li><h3 id="检测docker服务和kubelet服务"><a href="#检测docker服务和kubelet服务" class="headerlink" title="检测docker服务和kubelet服务"></a>检测docker服务和kubelet服务</h3><p>执行下列命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">systemctl status docker</span><br><span class="line">systemctl status kubelet</span><br></pre></td></tr></table></figure><p>执行结果显示绿色字样的<code>running</code>即为正常状态。</p></li><li><h3 id="通过kubeadm获取初始化配置文件"><a href="#通过kubeadm获取初始化配置文件" class="headerlink" title="通过kubeadm获取初始化配置文件"></a>通过kubeadm获取初始化配置文件</h3><p>执行命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">kubeadm config print init-defaults &gt; init.default.yaml</span><br><span class="line">cp init.default.yaml init-config.yaml</span><br><span class="line">vi init-config.yaml</span><br></pre></td></tr></table></figure><p>修改内容如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">kubeadm.k8s.io/v1beta2</span></span><br><span class="line"><span class="attr">bootstrapTokens:</span></span><br><span class="line"><span class="attr">- groups:</span></span><br><span class="line"><span class="attr">  - system:</span><span class="attr">bootstrappers:kubeadm:default-node-token</span></span><br><span class="line"><span class="attr">  token:</span> <span class="string">lo7fj7.j16rob4ic6mbgs5q</span></span><br><span class="line"><span class="attr">  ttl:</span> <span class="number">24</span><span class="string">h0m0s</span></span><br><span class="line"><span class="attr">  usages:</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">signing</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">authentication</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">InitConfiguration</span></span><br><span class="line"><span class="attr">localAPIEndpoint:</span></span><br><span class="line"><span class="attr">  advertiseAddress:</span> <span class="number">192.168</span><span class="number">.43</span><span class="number">.60</span>   <span class="comment">#master IP</span></span><br><span class="line"><span class="attr">  bindPort:</span> <span class="number">6443</span></span><br><span class="line"><span class="attr">nodeRegistration:</span></span><br><span class="line"><span class="attr">  criSocket:</span> <span class="string">/var/run/dockershim.sock</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">master</span></span><br><span class="line"><span class="attr">  taints:</span></span><br><span class="line"><span class="attr">  - effect:</span> <span class="string">NoSchedule</span></span><br><span class="line"><span class="attr">    key:</span> <span class="string">node-role.kubernetes.io/master</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiServer:</span></span><br><span class="line"><span class="attr">  timeoutForControlPlane:</span> <span class="number">4</span><span class="string">m0s</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">kubeadm.k8s.io/v1beta2</span></span><br><span class="line"><span class="attr">certificatesDir:</span> <span class="string">/etc/kubernetes/pki</span></span><br><span class="line"><span class="attr">clusterName:</span> <span class="string">kubernetes</span></span><br><span class="line"><span class="attr">controllerManager:</span> <span class="string">&#123;&#125;</span></span><br><span class="line"><span class="attr">dns:</span></span><br><span class="line"><span class="attr">  type:</span> <span class="string">CoreDNS</span></span><br><span class="line"><span class="attr">etcd:</span></span><br><span class="line"><span class="attr">  local:</span></span><br><span class="line"><span class="attr">    dataDir:</span> <span class="string">/var/lib/etcd</span></span><br><span class="line"><span class="attr">imageRepository:</span> <span class="string">registry.aliyuncs.com/google_containers</span>  <span class="comment">#镜像源，国内</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ClusterConfiguration</span></span><br><span class="line"><span class="attr">kubernetesVersion:</span> <span class="string">v1.16.0</span></span><br><span class="line"><span class="attr">networking:</span></span><br><span class="line"><span class="attr">  dnsDomain:</span> <span class="string">cluster.local</span></span><br><span class="line"><span class="attr">  podSubnet:</span> <span class="string">"192.168.0.0/16"</span></span><br><span class="line"><span class="attr">  serviceSubnet:</span> <span class="number">10.96</span><span class="number">.0</span><span class="number">.0</span><span class="string">/12</span></span><br><span class="line"><span class="attr">scheduler:</span> <span class="string">&#123;&#125;</span></span><br></pre></td></tr></table></figure></li><li><h3 id="修改docker镜像源"><a href="#修改docker镜像源" class="headerlink" title="修改docker镜像源"></a>修改docker镜像源</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"> &quot;registry-mirrors&quot;:[&quot;https://e384u25y.mirror.aliyuncs.com&quot;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的镜像源是阿里云加速链接，可以注册阿里云账号，然后在镜像服务中找到专属的加速链接</p></li><li><h3 id="下载镜像文件"><a href="#下载镜像文件" class="headerlink" title="下载镜像文件"></a>下载镜像文件</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubeadm config images pull --config=init-config.yaml</span><br></pre></td></tr></table></figure></li></ol><ol><li><h3 id="使用kubeadm-init命令安装Master"><a href="#使用kubeadm-init命令安装Master" class="headerlink" title="使用kubeadm init命令安装Master"></a>使用<code>kubeadm init</code>命令安装Master</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubeadm init --config=init-config.yaml</span><br></pre></td></tr></table></figure><p>在安装的过程中可能会出现比较多的问题。</p><ul><li>如果是镜像源的问题，可以重新启动docker服务，加载修改的镜像源，命令如下：</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">systemctl daemon-reload</span><br><span class="line">systemctl restart docker</span><br></pre></td></tr></table></figure><ul><li><p>如果是提示<code>hostname &quot;master&quot; could not be reached</code>之类的问题，可以修改<code>/etc/hosts</code>文件，见第2步。</p><p>若提示如下问题：</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">running with swap on is not supported. Please disable swap</span><br></pre></td></tr></table></figure><p>执行命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*swapoff -a*</span><br></pre></td></tr></table></figure><ul><li><p>若提示如下问题：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[ERROR FileContent--proc-sys-net-bridge-bridge-nf-call-iptables]: /proc/sys/net/bridge/bridge-nf-call-iptables contents are not set to 1</span><br></pre></td></tr></table></figure><p>执行命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo 1 &gt; /proc/sys/net/ipv4/ip_forward</span><br></pre></td></tr></table></figure></li></ul><p>安装成功后会出现如下提示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Your Kubernetes control-plane has initialized successfully!</span><br></pre></td></tr></table></figure><p>在最下面的提示信息中也会出现token，这用于节点加入集群，不过这个token只有24小时的有效期。我们也可以使用其他命令生成永久的token。</p></li><li><h3 id="准备配置文件，以便系统重启时，自动启动集群"><a href="#准备配置文件，以便系统重启时，自动启动集群" class="headerlink" title="准备配置文件，以便系统重启时，自动启动集群"></a>准备配置文件，以便系统重启时，自动启动集群</h3><p>执行命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p $HOME/.kube</span><br><span class="line">cp -i /etc/kubernetes/admin.conf $HOME/.kube/config</span><br><span class="line">chown $(id -u):$(id -g) $HOME/.kube/config</span><br></pre></td></tr></table></figure></li></ol><ol><li><h3 id="验证安装是否成功"><a href="#验证安装是否成功" class="headerlink" title="验证安装是否成功"></a>验证安装是否成功</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@Master ~]# kubectl get -n kube-system configmap</span><br><span class="line">NAME                                 DATA   AGE</span><br><span class="line">coredns                              1      10d</span><br><span class="line">extension-apiserver-authentication   6      10d</span><br><span class="line">kube-proxy                           2      10d</span><br><span class="line">kubeadm-config                       2      10d</span><br><span class="line">kubelet-config-1.16                  1      10d</span><br></pre></td></tr></table></figure><p>至此，master节点安装完毕。下面安装node节点。</p></li><li><h3 id="安装节点"><a href="#安装节点" class="headerlink" title="安装节点"></a>安装节点</h3><p>在各个节点上重复步骤1~10。</p></li><li><h3 id="通过kubeadm获取join配置文件"><a href="#通过kubeadm获取join配置文件" class="headerlink" title="通过kubeadm获取join配置文件"></a>通过kubeadm获取join配置文件</h3><p>执行命令如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kubeadm config print join-defaults &gt; join-config.yaml</span><br><span class="line">vim join-config.yaml</span><br></pre></td></tr></table></figure><p>然后修改内容如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">kubeadm.k8s.io/v1beta2</span></span><br><span class="line"><span class="attr">caCertPath:</span> <span class="string">/etc/kubernetes/pki/ca.crt</span></span><br><span class="line"><span class="attr">discovery:</span></span><br><span class="line"><span class="attr">  bootstrapToken:</span></span><br><span class="line"><span class="attr">    apiServerEndpoint:</span> <span class="number">192.168</span><span class="number">.43</span><span class="number">.60</span><span class="string">:6443</span>  <span class="comment">#这地方是master节点的IP</span></span><br><span class="line"><span class="attr">    token:</span> <span class="string">lo7fj7.j16rob4ic6mbgs5q</span>   <span class="comment">#这地方是token，一般是初始化的toke，和master节点中的init文件中的token相同</span></span><br><span class="line"><span class="attr">    unsafeSkipCAVerification:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">  timeout:</span> <span class="number">5</span><span class="string">m0s</span></span><br><span class="line"><span class="attr">  tlsBootstrapToken:</span> <span class="string">lo7fj7.j16rob4ic6mbgs5q</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">JoinConfiguration</span></span><br><span class="line"><span class="attr">nodeRegistration:</span></span><br><span class="line"><span class="attr">  criSocket:</span> <span class="string">/var/run/dockershim.sock</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">node1</span>   <span class="comment">#节点名，每个节点的名字必须不同</span></span><br><span class="line"><span class="attr">  taints:</span> <span class="literal">null</span></span><br></pre></td></tr></table></figure></li><li><h3 id="运行kubeadm-join命令加入集群"><a href="#运行kubeadm-join命令加入集群" class="headerlink" title="运行kubeadm join命令加入集群"></a>运行<code>kubeadm join</code>命令加入集群</h3><p>执行命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubeadm join --config=join-config.yaml</span><br></pre></td></tr></table></figure></li></ol><ol><li><h3 id="查看已加入节点"><a href="#查看已加入节点" class="headerlink" title="查看已加入节点"></a>查看已加入节点</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@Master ~]# kubectl get node</span><br><span class="line">NAME     STATUS     ROLES    AGE     VERSION</span><br><span class="line">master   NotReady   master   10d     v1.16.2   </span><br><span class="line">node1    NotReady   &lt;none&gt;   7d12h   v1.16.2</span><br><span class="line">node2    NotReady   &lt;none&gt;   7d12h   v1.16.2</span><br><span class="line">node3    NotReady   &lt;none&gt;   7d12h   v1.16.2</span><br></pre></td></tr></table></figure><p>在节点加入成功后，执行命令的结果如上。这里notready是因为没有安装网络插件。网络插件比较多，比如weave，Flannel等。这里安装weave。</p></li><li><h3 id="安装网络插件"><a href="#安装网络插件" class="headerlink" title="安装网络插件"></a>安装网络插件</h3><p>执行命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl apply -f "https://cloud.weave.works/k8s/net?k8s-version=$(kubectl version | base64 | tr -d '\n')"</span><br></pre></td></tr></table></figure><p>这里可能会因为科学上网的问题而出现ErrImage或者ImagePullback等问题。我的也出现了这个问题，后来不知道什么原因，突然就安装上了。</p></li><li><h3 id="验证Kubernetes集群是否安装完成"><a href="#验证Kubernetes集群是否安装完成" class="headerlink" title="验证Kubernetes集群是否安装完成"></a>验证Kubernetes集群是否安装完成</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">kube-system            coredns-58cc8c89f4-8rxzx                     1/1     Running            13         7d12h</span><br><span class="line">kube-system            coredns-58cc8c89f4-cdwm7                     1/1     Running            15         7d12h</span><br><span class="line">kube-system            etcd-master                                  1/1     Running            26         10d</span><br><span class="line">kube-system            kube-apiserver-master                        1/1     Running            265        10d</span><br><span class="line">kube-system            kube-controller-manager-master               1/1     Running            108        10d</span><br><span class="line">kube-system            kube-proxy-bhdzd                             1/1     Running            9          7d1h</span><br><span class="line">kube-system            kube-proxy-dj4qt                             1/1     Running            14         7d1h</span><br><span class="line">kube-system            kube-scheduler-master                        1/1     Running            96         10d</span><br><span class="line">kube-system            weave-net-6nd4h                              2/2     Running            44         7d12h</span><br><span class="line">kube-system            weave-net-9tzjk                              2/2     Running            41         7d19h</span><br></pre></td></tr></table></figure><p>这里，Kubernetes集群就可以搭建完毕了。</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、环境概述&quot;&gt;&lt;a href=&quot;#一、环境概述&quot; class=&quot;headerlink&quot; title=&quot;一、环境概述&quot;&gt;&lt;/a&gt;一、环境概述&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;h3 id=&quot;节点信息&quot;&gt;&lt;a href=&quot;#节点信息&quot; class=&quot;headerlink&quot;
      
    
    </summary>
    
      <category term="分布式与云计算" scheme="http://wanqbin.xyz/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%8E%E4%BA%91%E8%AE%A1%E7%AE%97/"/>
    
    
      <category term="k8s" scheme="http://wanqbin.xyz/tags/k8s/"/>
    
      <category term="分布式集群" scheme="http://wanqbin.xyz/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E9%9B%86%E7%BE%A4/"/>
    
  </entry>
  
  <entry>
    <title>面向对象设计原则</title>
    <link href="http://wanqbin.xyz/2019/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/"/>
    <id>http://wanqbin.xyz/2019/面向对象设计原则/</id>
    <published>2019-11-18T17:06:00.000Z</published>
    <updated>2019-11-18T17:07:20.490Z</updated>
    
    <content type="html"><![CDATA[<p>面向对象设计，为什么？</p><p>变化是复用的天敌，面向对象设计最大的优势在于：抵御变化。</p><p>重新认识面向对象</p><ul><li>理解隔离变化<ul><li>从宏观层面来看，面向对象的构建方式更能适应软件的变化，能将变化所带来的影响减为最小</li></ul></li><li>各司其职<ul><li>从微观层面来看，面向对象的方式更强调各个类的“责任”</li><li>由于需求变化导致的新增类型不应该影响原来类型的实现——是所谓各司其职。</li></ul></li><li>对象是什么<ul><li>从语言实现层面来看，对象封装了代码和数据</li><li>从规格层面讲，对象是一系列可被使用的公共接口</li><li>从概念层面讲，对象时某种拥有责任的抽象。</li></ul></li></ul><p>面向对象设计原则</p><ul><li><p>依赖倒置原则（DIP)</p><ul><li>高层模块（稳定）不应该依赖于底层模块（变化），二者都应该依赖于抽象（稳定）</li><li>抽象（稳定）不应该依赖于实现细节（变化），实现细节应该依赖于抽象（稳定）。</li></ul></li><li><p>开放封闭原则（OCP)</p><ul><li>对扩展开放，对更改封闭</li><li>类模块应该是可扩展的，但是不可修改</li></ul></li><li><p>单一职责原则</p><ul><li>一个类应该仅有一个引起它变化的原因</li><li>变化的方向隐含着类的责任。</li></ul></li><li><p>Liskov替换原则（LSP）</p><ul><li>子类必须能够替换它们的基类</li><li>继承表达类型抽象</li></ul></li><li><p>接口隔离原则（ISP）</p><ul><li>不应该强迫客户程序依赖它们不用的方法</li><li>接口应该小而完备</li></ul></li><li><p>优先使用对象组合，而不是类继承</p><ul><li>类继承通常为“白箱复用”，对象组合通常为“黑箱复用”</li><li>继承在某种程度上破坏了封装性，子类父类耦合度高</li><li>而对象组合则只要求被组合的对象具有良好定义的接口，耦合度低</li></ul></li><li><p>封装变化点</p><ul><li>使用封装来创建对象之间的分界层，让设计者可以在分界层一侧进行修改，而不会对另一侧产生不良的影响，从而实现层次间的松耦合</li></ul></li><li><p>针对接口编程，而不是针对实现编程</p><ul><li>不将变量类型声明为某个特定的具体类，而是声明为某个接口。</li><li>客户程序无需获知对象的具体类型，只需要知道对象所具有的接口</li><li>减少系统中各部分的依赖关系，从而实现“高内聚，松耦合”的类型设计方案。</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;面向对象设计，为什么？&lt;/p&gt;
&lt;p&gt;变化是复用的天敌，面向对象设计最大的优势在于：抵御变化。&lt;/p&gt;
&lt;p&gt;重新认识面向对象&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;理解隔离变化&lt;ul&gt;
&lt;li&gt;从宏观层面来看，面向对象的构建方式更能适应软件的变化，能将变化所带来的影响减为最小&lt;/li
      
    
    </summary>
    
      <category term="设计模式" scheme="http://wanqbin.xyz/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="http://wanqbin.xyz/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="面向对象设计原则、" scheme="http://wanqbin.xyz/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99%E3%80%81/"/>
    
  </entry>
  
  <entry>
    <title>什么是设计模式？</title>
    <link href="http://wanqbin.xyz/2019/%E4%BB%80%E4%B9%88%E6%98%AF%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%9F/"/>
    <id>http://wanqbin.xyz/2019/什么是设计模式？/</id>
    <published>2019-11-18T17:05:00.000Z</published>
    <updated>2019-11-18T17:06:06.114Z</updated>
    
    <content type="html"><![CDATA[<p>&gt;<br>&gt;</p><blockquote><p>每一个模式描述了一个在我们周围不断重复发生的问题，以及该问题的解决方案的核心。这样，你就能一次又一次地使用该方案而不必做重复劳动。</p><p>​                                                                           ——Christopher Alexander</p></blockquote><p>一般而言，一个模式有四个基本要素：</p><ol><li><p>模式名称。</p><p>一个助记名，它用一两个词来描述模式的问题，解决方案和效果。命名一个新的设计模式增加了我们的设计词汇。设计模式允许我们在较高的抽象层次进行设计。</p></li><li><p>问题。</p><p>描述了应该在何时使用模式。它解释了设计问题和问题存在的前提，它可能描述了特定的设计问题，如怎样用对象表示算法。也可能描述了导致不灵活设计的类或对象结构。</p></li><li><p>解决方案</p><p>描述了设计的组成成分，它们之间的相互关系以及各自的职责和协作方式。因为模式就像是一个模板，可应用于多种不同场合，所以解决方案并不描述一个特定而具体的设计或实现，而是提供设计问题的抽象和怎样用一个具有一般意义的元素组合来解决这个问题。</p></li><li><p>效果。</p><p>描述了模式应用的效果以及使用模式应权衡的问题。尽管我们描述设计决策时，并不总提到设计模式，但它们对于评价设计选择和理解使用模式的代价以及好处具有重要意义。软件效果大多关注对时间和空间的衡量，它们也表述了语言和实现问题。因为复用是面向对象设计的要素之一，所以模式效果包括它对系统灵活性、扩充性或可移动性的影响，显式地列出这些效果对理解和评价这些模式很有帮助。</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&amp;gt;&lt;br&gt;&amp;gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;每一个模式描述了一个在我们周围不断重复发生的问题，以及该问题的解决方案的核心。这样，你就能一次又一次地使用该方案而不必做重复劳动。&lt;/p&gt;
&lt;p&gt;​                              
      
    
    </summary>
    
      <category term="设计模式" scheme="http://wanqbin.xyz/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="http://wanqbin.xyz/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>传输控制协议TCP</title>
    <link href="http://wanqbin.xyz/2019/%E4%BC%A0%E8%BE%93%E6%8E%A7%E5%88%B6%E5%8D%8F%E8%AE%AETCP/"/>
    <id>http://wanqbin.xyz/2019/传输控制协议TCP/</id>
    <published>2019-11-18T17:04:00.000Z</published>
    <updated>2019-11-18T17:04:33.756Z</updated>
    
    <content type="html"><![CDATA[<p>TCP是TCP/IP体系中面向连接的运输层协议，它提供了全双工的和可靠交付的服务。TCP与UDP最大的区别就是：TCP是面向连接的，而UDP是无连接的。TCP比UDP复杂的多，除了具有面向连接和可靠传输的特性外，TCP还在运输层使用流量控制和拥塞控制机制。</p><h2 id="一、TCP的主要特点"><a href="#一、TCP的主要特点" class="headerlink" title="一、TCP的主要特点"></a>一、TCP的主要特点</h2><ul><li>TCP是面向连接的运输层协议。这就是说，应用程序在使用TCP提供的服务传送数据之前，必须先建立TCP连接。建立TCP连接的目的是通信双方为接下来的数据传送做好准备，初始化各种状态变量，分配缓存等资源，在传送数据完毕后，必须释放已建立的TCP连接，即释放相应的资源和变量。</li><li>每一条TCP连接只能有两端点，即每一条TCP连接只能是点对点的（一对一）。TCP连接唯一地被通信两端的端点所确定，而两个端点分别由二元组（IP地址，端口号）唯一标识，即一条TCP连接由两个套接字地址标识。</li><li>TCP是提供可靠服务的。也就是说，通过TCP连接传送的数据无差错，不丢失，不重复，并且按序到达。</li><li>TCP提供全双工通信。TCP允许通信双方的应用进程在任何时候都能发送数据。TCP连接的两端都没有发送缓存和接受缓存，用来临时存放双向通信的数据。在发送时，应用程序在把数据传送给TCP的缓存后，就可以做自己的事，而TCP在合适的时候把数据发送出去。在接收时，TCP把收到的数据放入缓存，上层的应用进程在合适的时候读取缓存中的数据。</li><li>面向字节流。TCP中的流指的是流入到进程或从进程流出的字节序列。面向字节流的含义是：虽然应用程序和TCP的交互时一次一个数据块，但TCP把应用程序交下来的数据看成是一连串的无结构的字节流。TCP不保证接收方应用程序收到的数据块和发送方应用程序所发出的数据块具有对应大小的关系，从TCP接收方缓存中将数据读取完毕。但接受方应用程序收到的字节流必须和发送方应用程序发出的字节流完全一样。</li></ul><p>发送方的应用进程按照自己产生数据的规律，不断地把数据块陆续写入到TCP的发送缓存中。TCP再从发送缓存中取出一定数量的数据，将其组成TCP报文段逐个传递给IP层，然后发送出去。</p><p>接收方从IP层收到TCP报文段后，先把它暂存在接收缓存中，然后等待接收方对应的应用进程从接收缓存中按顺序读取。需要注意的是，接收方应用进程每次从接收缓存中读取数据时，是按应用进程指定的数量读取数据，而不是一次读取接收缓存中的一个完整的报文段或所有数据。只有当接收缓存中的数据量小于应用进程指定的读取量时，才返回给应用进程接收缓冲中所有的数据。当接收缓存中完全没有数据时，根据读取方式的不同，应用进程可能会一直等待，也可能直接返回。由此可见，TCP的接收方应用进程读取的数据块与发送方应用进程发送的数据块边界毫无关系，也就是说，TCP接收方在向上层交付数据时不保证能保持发送方应用进程发送数据块的边界。</p><p>TCP连接时一条虚连接，而不是一条物理连接。也就是说，TCP连接时一种抽象的逻辑连接。</p><p>TCP报文段首先要传送到IP层，加上IP首部后，再传送到数据链路层，再加上数据链路层的首部和尾部后，才离开主机发送到物理链路。另外，TCP连接仅存在于两个端系统同中，而网络核心的中间设备完全不知道该连接的存在。TCP连接的组成主要包括：通信两端主机上的缓存、状态变量，在这两台主机间的路由器和交换机没有为该连接分配任何缓存和变量。</p><p>与UDP的端口队列不同的是，TCP的发送缓存和接受缓存都是分配给一个连接的，而不是一个端口。TCP的一个连接由四元组（源IP地址，源端口号，目的IP地址，目的端口号）标识，即由源/目的套接字地址对标识。也就是说，来自不同源的TCP报文段，即使它们的目的IP地址和面对端口号相同，它们也不可能被交付到同一个TCP接收缓存中，因为它们在不同的TCP管道中传输，到达不同管道出口的缓存。通常一个TCP服务器进程用一个端口号与不同的客户机进程建立多个连接，然后创建多个子进程分别用这些连接与各自的客户机进程进行通信。</p><h2 id="二、TCP报文段的格式"><a href="#二、TCP报文段的格式" class="headerlink" title="二、TCP报文段的格式"></a>二、TCP报文段的格式</h2><p>TCP虽然是面向字节流的，但TCP传送的数据单元却是报文段。TCP报文段分为首部和数据两部分，而TCP的全部功能都体现在它首部各字段的作用。</p><p>TCP报文段首部的前20个字节是固定的，后面有4N个字节是根据需要而增加的选项。因此，TCP首部的最小长度是20字节。</p><p>首部固定部分各字段的意义如下所述：</p><ul><li>源端口和目的端口。各占两个字节。与UDP一样，该字段定义了主机中发送和接受该报文段的应用程序的端口号，用于运输层的复用和分用。</li><li>序号。占4个字节。序号从0开始，到$2^{32}-1$为止。TCP是面向数据流的.TCP传送的报文段可看成连续的数据流。在一个TCP连接中传送的数据流中的每一个字节都是按顺序编号。整个数据的起始序号在连接建立时设置。首部中的序号字段的值则指的是本报文段所含的数据的第一个字节的序号。</li><li>确认号。占4个字节，是期望收到对方的下一个报文段的第一个数据字节的序号。TCP提供的是双向通信，当一端发送数据时同时对接收到的对端数据进行确认。TCP采用的是累积确认。</li><li>数据偏移。占4位，它指出TCP报文段的数据起始处距离TCP报文段的起始处有多远。这实际上就是TCP报文段首部的长度。由于首部长度不固定，因此数据偏移字段是必要的。但应注意的是，“数据偏移”的单位不是字节而是32位字（即以4字节长的字为计算单位）。由于4位二进制数能够表示的最大十进制数字是15，因此数据偏移的最大值是60字节，这也是TCP首部的最大长度。</li><li>保留。占6位，保留为今后使用，但目前应置0.</li><li>紧急URG。当URG=1时，表明紧急指针字段有效。它告诉接收方TCP此报文段中有紧急数据，应尽快交付给应用程序，而不要按序从接收缓存中读取。</li><li>确认ACK。只有当ACK=1时确认号字段才有效。当ACK=0时，确认号无效。</li><li>推送PSH。处于效率的考虑，TCP可能会延迟发送数据或向应用程序延迟交付数据，这样可以一次处理更多的数据。但是当两个应用进程进行交互式通信时，有时在一段的应用进程希望在键入一个命令后立即就能得到对方的响应。在这种情况下，应用程序可以通知TCP使用推送操作。这时发送方TCP把PSH置1，并立即创建一个报文段发送出去，而不需要累积到足够多的数据再发送。。接收TCP收到PSH置1的报文段，就尽快地交付给接收应用进程，而不要等到收到足够多的的数据才向上交付。</li><li>复位RST。当RST=1时，表明TCP连接中出现严重差错，必须释放连接，然后再从新建立运输连接。RST置1还用来拒绝一个非法的报文段或拒绝打开一个连接。RST也可称为重建位或重置位。</li><li>同步SYN。用来建立一个连接。当SYN=1而ACK=0时，表明这是一个连接请求报文段。对方若同意建立连接，则应在响应的报文段中使SYN=1和ACK=1。因此，SYN置1就表示这是一个连接请求或连接接收报文。</li><li>终止FIN。用来释放一个连接。当FIN=1时，表明此报文段的发送方的数据已发送完毕，并要求释放运输连接。</li><li>窗口。占两字节。窗口值指示发送该报文段的接受窗口大小，在0到$2^{16}-1$之间。窗口字段用来控制对方发送的数据量，单位为字节。窗口字段反映了接收方接收缓存的可用空间大小。</li><li>检验和。占两个字节。检验和字段检验的范围包括首部和数据两部分。</li><li>选项。长度可变。这里介绍一个，即最大报文段长度（MSS）。</li></ul><h2 id="三、TCP的可靠传输"><a href="#三、TCP的可靠传输" class="headerlink" title="三、TCP的可靠传输"></a>三、TCP的可靠传输</h2><ul><li><p>数据编号与确认</p><p>TCP是面向字节的。TCP把应用层交下来的长报文看成是一个个字节组成的数据流，并使每一个字节对应于一个序号。注意，GBN协议中是对每个分组进行编号在。在建立连接时，双方TCP要各自确定初始序号。TCP每次发送的报文段的首部中的序号字段数值表示该报文段中紧接着首部后面的第一个数据字节的序号。</p><p>TCP使用累积确认，即确认是对所有按序收到的数据的确认。但请注意，接收方返回的确认号时已按序收到的数据的最高序号加1.也就是说，确认号表示接收方期望下一次收到的数据中的第一个数据直接序号。</p><p>当TCP发送一报文段时，它同时也咋自己的重传队列中存放这个报文段的一个副本。若收到确认，则删除此副本。若在规定时间内没有收到确认，则重传此报文段的副本。TCP的确认并不保证数据已交付给了应用进程，而只是表明在接收方的TCP已按序正确收到了对方所发送的报文段。</p><p>由于TCP连接能提供全双工通信，因此通信中的每一方都不必专门发送确认报文段，而可以在传送数据时顺便把确认信息捎带传送。为此，TCP采用了一种延迟确的机制，即接收方在正确接收到数据时可能要等待一段时间再发送确认。若这段时间内有数据要发送给对方，则可以捎带确认。也有可能在这段时间内又有数据到达，则可以同时对这两次到达的数据进行累计确认。这样做可以减少发送完全不带数据的确认报文段，以提高TCP的传输效率。</p><p>接收方若收到有差错的报文段就丢弃。若收到重复的报文段，也要丢弃，但要立即发回确认信息。</p><p>若收到的报文段无差错，只是未按序号顺序到达，那么应如何处理？在GBN协议中会丢弃所有未按序到达的分组，但是TCP对此未做明确规定，而是让TCP的实现者自行确定。可以像GBN协议一样将不按序到达的报文段丢弃，但多数TCP实现是先将其暂存与接收缓存内，待所缺序号的报文段收齐后再一起上交应用层。在互联网环境中，封装TCP报文段和IP数据报不一定是按序到达的，将失序的报文段先缓存起来可以避免不必要的重传。注意，不论采用哪种方法，接收方都要立即对已按序接收到的数据进行确认。</p><p>TCP发送方每发送一个报文段，就会为这个报文段设置一个计时器。只要计时器设置的重传时间已经到了但还没有收到确认，就要重传这一报文段。我们知道，在GBN协议中，一旦发送方某个分组超时，则会重传窗口内所有已发送的分组。而在TCP中发送方只会重传超时的那一个报文段，如果后序报文段的确认能够在超时之前及时到达，则不会重传那些还没有超时的后续报文段。</p></li><li><p>以字节为单位的滑动窗口</p><p>为了提高报文段的传输效率，TCP采用滑动窗口协议。但与GBN协议不同的是，TCP发送窗口大小的单位是字节，而不是分组数。TCP发送方已发送的未被确认的字节数不能超过发送窗口的大小。</p><p>落入发送窗口内的是允许发送的字节，落在发送窗口外左侧的是已发送并被确认的字节，而落在发送窗口外右侧是是还不能发送的字节。收到确认后，发送窗口向右滑动，直到发送窗口的左沿正好包含确认序号的字节。</p><p>发送缓存用来暂时存放：</p><ul><li>发送应用程序传送给发送方TCP准备发送的数据</li><li>TCP已发送出去但尚未收到确认的数据</li></ul><p>发送窗口通常只是发送缓存的一半部分。已被确认的数据应当才能够发送缓存中删除，因此发送缓存和发送窗口的后沿是重合的。发送应用程序最后写入发送缓存的字节序号减去最后被确认的字节序号，就是还保留在发送缓存的被写入的字节数。如果发送应用程序传送给TCP发送方的速度太快，可能会最终导致发送缓存被填满，这时发送应用程序必须等待，直到有数据从发送缓存中删除。</p><p>接收缓存用来暂时存放：</p><ul><li>按序到达的，但尚未被接受应用程序读取的数据</li><li>未按序到达的，但还不能被接收应用程序读取的数据</li></ul><p>如果收到的分组被检测出有差错，则要丢弃。如果接受应用程序来不及读取收到的数据，接收缓存最终就会被填满，使接收窗口减小到0.反之，如果接受应用程序能够及时从接收缓存中读取收到的数据，接收窗口就会增大，但最大不能超过接收缓存的大小。</p></li><li><p>超时重传时间的选择</p><p>由于TCP的下层是互联网环境，发送的报文段可能只经过一个高速率的局域网，但也可能经过多个低速率的广域网，并且每个IP数据报所选择的路由还可能不同，不同时间网络拥塞情况也有不同。因此往返时间是不断变化的。</p><p>对于运输层来说，其往返时间的方差很大。如果把超时时间设置得太短，则很多报文段就会过早超时，引起很多报文段的不必要的重传，使网络负荷增大。但如果把超时时间设置得过长，则大量丢失的报文段不能被及时重传，降低了传输效率。因此，选择超时重传时间再数据链路层并不困难，但在运输层却不那么简单。</p><p>那么。运输层的超时计时器的超时重传时间究竟应设置为多大呢？<br>显然，超时重传时间应比当前报文段的往返时间要长一些。针对互联网环境中端到端的时延是动态变化的特点，TCP才用了一种自适应算法。该算法记录每个报文段发出的时间，以及收到相应的确认报文段的时间。这两个时间之差就是报文段得到往返时间RTT。在互联网中，实际的RTT测量值变化非常大，因此需要用多个RTT测量值的平均值来估计当前报文段的RTT。由于越近的测量值越能反映网络当前的情况,TCP采用指数加权移动平均的算法对RTT测量值进行加权平均，得出报文段的平均往返时间RTT。</p></li><li><p>快速重传</p><p>超时触发重传存在的一个问题就是超时时间可能相对较长。由于无法精确估计实际的往返时间，超时重传时间RTO往往比实际的往返时间大很多。当一个报文段丢失时，发送方需要等待很长时间才能重传丢失的报文段，因而增加了端到端时延。幸运的是，有时一个报文段的丢失会引起发送方连续收到多个重复的确认，通过收到多个重复的确认可以快速地判断报文段可能已经丢失而不必等待重传计时器超时。快速重传就是基于该方法对超时重传的补充和改进。</p></li><li><p>选择确认</p><p>TCP报文段的确认字段是一种累积确认，就是说，它只通告收到的最后一个按序到达的字节，而没有通告所有收到的失序到达的那些字节，虽然这些字节已经被接收方接收并暂存在接收缓存中。这些没有被确认的字节很可能因为超时而被发送方重传。为了避免这些无意义的重传，一个可选功能选择确认可以解决这个问题。选择确认允许接收方通知发送方所有正确接收了的但是失序的字节块，发送方可以根据这些信息只重传那些接收方还没有收到的字节块。</p></li></ul><h2 id="四、TCP的流量控制"><a href="#四、TCP的流量控制" class="headerlink" title="四、TCP的流量控制"></a>四、TCP的流量控制</h2><p>一条TCP连接的双方主机都为该连接设置了接收缓存。当该TCP连接接收得到按序的字节后，它就将数据放入接收缓存。相关联的应用程序会从该缓存中读取数据，但应用程序不一定能马上将数据取走。事实上，接收方应用也许正忙于其他任务，需要过很长的时间后才能去读取数据。如果应用程序读取数据比较慢，而发送方发送数据很快、很多，则很容易使该连接的接收缓存溢出。</p><p>TCP为应用程序提供了流量控制服务，以解决因发送方发送数据太快而导致接收方来不及接收，使接收方缓存溢出的问题。</p><p>流量控制的基本方法就是接收方根据自己的接收能力控制发送方的发送速率。因此，可以说流量控制是一个速度匹配服务，即发送方的发送速率与接收方应用程序的读速率相匹配。利用滑动窗口机制可以很方便地控制发送方的平均发送速率。TCP采用接收方控制发送方发送窗口大小的方法来实现在TCP连接上的流量控制。在TCP报文段首部的窗口字段写入的数值就是当前给对方设置的发送窗口数值的上限。这种由接收方控制发送方的做法，在计算机网络中经常使用。</p><p>发送窗口在连接建立时由双方商定。但在通信的过程中，接收方根据接收缓存中可用缓存的大小，随时动态地调整对方的发送窗口的上限值。为此，TCP接收方要维持一个接受窗口的变量，其值不能大于可用缓存大小。</p><p>在TCP报文段首部的窗口字段写入的数值就是当前接收方的接收窗口的大小。TCP发送方的发送窗口的大小必须小于该值。</p><p>当接收方的可用接收缓存大小不再为0时，向发送方发送的窗口更新报文段丢失了会出现什么问题？如果接收方一直没有数据要发送给发送方，则发送方将会永远等下去。为防止因为因接收方发送给发送方的窗口变更变文段的丢失所导致的死锁状态，实际上，当窗口变为0时，如果发送方有数据要发送，则会周期性地发送只包含一个字节数据的窗口探测报文段，以便强制接收方发回确认并公告接收窗口大小。如果这时接收窗口大小非零，则会接收这个字节，并对这个字节进行确认，否则会丢弃该字节并对以前数据进行重复确认。</p><h2 id="五、TCP的连接管理"><a href="#五、TCP的连接管理" class="headerlink" title="五、TCP的连接管理"></a>五、TCP的连接管理</h2><p>TCP是面向连接的协议。连接的建立和释放是每一次面向连接的通信中必不可少的过程。因此TCP连接就有三个阶段，即连接建立、数据传送、连接释放。建立连接的目的就是为接下来要进行的通信做好充分的准备，其中最重要的就是分配相应的资源。在通信结束之后显然要释放所占用的资源，即释放连接。注意，TCP的连接时运输层连接，只存在于通信的两个端系统中，而网络核心的路由器完全不知道它的存在。</p><ul><li><p>TCP的连接建立</p><p>在连接建立时要解决以下三个问题：</p><ul><li>要使每一方能够确知对方的存在；</li><li>要允许双方协商一些参数</li><li>能够对运输实体资源进行分配和初始化</li></ul><p>TCP的连接建立采用客户——服务器方式。主动发起连接建立的应用进程叫做客户，而被动等待连接建立的应用进程叫做服务器。</p><p>设主机B运行TCP的服务器进程，它先发出一个被动打开命令，准备接受客户进程的连接请求。然后服务器进程就处于“听”状态，不断检测是否有客户进程要发起连接请求。如有，即做出响应。</p><p>设客户进程运行在主机A中。它先向其TCP发出主动打开命令，表明要向某个IP地址的某个端口建立运输层连接。</p><p>主机A的TCP向主机B的TCP发出连接请求报文段，其首部的同步位SYN应置1，同时选择一个序号<code>seq=x</code>，这表明下一个报文段的第一个数据字节的序号是<code>x+1</code>。</p><p>主机B的TCP收到连接请求报文段后，如同意，则发回连接请求确认。在确认报文段中应把SYN位和ACK位都置1，确认号<code>ack=x+1</code>，同时也为自己选择一个序号<code>seq=y</code>。</p><p>主机A的TCP收到B接受连接请求的确认后，还要向B给出确认，其ACK置1，确认号<code>ack=y+1</code>。而自己的序号<code>seq=x+1</code>。TCP标准规定，SYN=1的报文段不能携带数据，但要消耗一个序号。因此A发送的第二个报文段的序号应当是第一个报文段的序号加1.注意，A发送的第二个报文段中SYN是0而不是1，ACK位必须为1.该报文段是对B的同步报文段的确认，但是一个普通报文段，可携带数据。若该报文段不携带数据，则按照TCP的规定，确认报文段不消耗序号。</p><p>运行客户进程的主机A的TCP通知上层应用进程，连接已经建立。</p><p>当运行服务器进程的主机B的TCP收到主机A的确认后，会通知其上层应用进程，连接已经建立。</p><p>连接建立采用的这种过程叫做三次握手。</p><p>为什么要发送这三个报文段呢？这主要是为了防止已失效的连接请求报文段突然又传送到了主机B，因而导致错误产生。</p></li><li><p>TCP的连接释放</p><p>在数据传输结束后，通信的双方都可以发出释放连接的请求。在连接释放过程中要释放为该连接分配的所有资源。</p><p>设主机A的应用进程先向其TCP发出连接释放请求，并且不再发送数据。TCP通知对方要释放A到B这个方向的链接，把发往主机B的报文段首部的FIN置1，其序号<code>seq=u</code>。由于FIN报文段要消耗一个序号，因此序号u等于A前面已传送过的数据的之后一个字节的序号加1.</p><p>主机B的TCP收到释放连接的通知后即发出确认，确认号<code>ack=u+1</code>，而这个报文段自己的序号假定为v。主机B的TCP这时应通知高层应用进程。这样，从A到B的连接就释放了，连接处于半关闭状态。</p><p>此后，主机B不再接受主机A发来的数据。但若主机B还有一些数据要发往主机A，则可以继续发送。主机A只要正确收到数据，仍应向主机B发送确认。</p><p>若主机B不再向主机A发送数据，其应用进程就通知TCP释放连接。主机B发出的连接释放报文段必须使FIN=1，其序号为w。主机A必须对此发出确认，把ACK置1，确认号<code>ack=w+1</code>，而自己的序号为<code>seq=u+1</code>。这样才把从B到A的反方向连接释放掉。但此时，主机A的TCP并不能马上释放整个连接，还要再等待一个超时时间才能将整个连接释放。因为主机A的确认有可能丢失，这时B会重传FIN报文段。在这段超时时间内，若A又收到B重传的FIN报文段，A需要再次进行确认。收到A的最后确认，B才能将整个连接释放。若等待的这段超时时间内没有收到B的FIN报文段，主机A的TCP则应向其应用进程报告，整个连接已经全部释放。</p><p>上述的连接释放过程是四次握手。</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;TCP是TCP/IP体系中面向连接的运输层协议，它提供了全双工的和可靠交付的服务。TCP与UDP最大的区别就是：TCP是面向连接的，而UDP是无连接的。TCP比UDP复杂的多，除了具有面向连接和可靠传输的特性外，TCP还在运输层使用流量控制和拥塞控制机制。&lt;/p&gt;
&lt;h2 
      
    
    </summary>
    
      <category term="计算机网络" scheme="http://wanqbin.xyz/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="传输控制协议" scheme="http://wanqbin.xyz/tags/%E4%BC%A0%E8%BE%93%E6%8E%A7%E5%88%B6%E5%8D%8F%E8%AE%AE/"/>
    
      <category term="TCP" scheme="http://wanqbin.xyz/tags/TCP/"/>
    
  </entry>
  
  <entry>
    <title>拥塞控制</title>
    <link href="http://wanqbin.xyz/2019/%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6/"/>
    <id>http://wanqbin.xyz/2019/拥塞控制/</id>
    <published>2019-11-18T17:04:00.000Z</published>
    <updated>2019-11-18T17:05:04.673Z</updated>
    
    <content type="html"><![CDATA[<p>当网络中出现太多的分组时，网络的性能开始下降。这种情况称为拥塞。拥塞是分组交换网中一个非常重要的问题。如果网络中的负载，即发送到网络中的数据量超过了网络的容量，即网络中能处理的数据量，那么在网络中就可能发生拥塞。所谓拥塞控制就是放置过多的数据注入到网络中，这样可以使网络中的路由器或链路不至过载。</p><h2 id="一、拥塞的原因及危害"><a href="#一、拥塞的原因及危害" class="headerlink" title="一、拥塞的原因及危害"></a>一、拥塞的原因及危害</h2><p>理想情况下，在吞吐量饱和之前，网络吞吐量应等于输入负载。但当输入负载超过网络容量时，在理想情况下，吞吐量不再增长而保持为水平线，即吞吐量达到饱和。这就表明输入负载中有一部分损失掉了。</p><p>但是，在实际的网络中，若不采取有效的拥塞控制手段，随着输入负载的增大，网络吞吐量的增长速率逐渐减小。特别是当输入负载达到某一数值时，网络的吞吐量反而随负载的增大而下降，这时网络就进入了拥塞状态。当输入负载继续增大时，网络的吞吐量甚至有可能下降到零，即网络已无法工作。这就是所谓的死锁。</p><p>当网络拥塞而丢弃分组时，该分组在其经过路径中所占用的全部资源都被白白浪费掉了。</p><p>既然网络拥塞是因为发送到网络中的数据量超过了网络的容量，要彻底解决分组交换网中的拥塞问题，就要想办法限制输入到网络中的负载，即控制源点的发送速率。</p><h2 id="二、拥塞控制的基本方法"><a href="#二、拥塞控制的基本方法" class="headerlink" title="二、拥塞控制的基本方法"></a>二、拥塞控制的基本方法</h2><p>拥塞控制和流量控制之间的区别是需要注意的，因为它们都需要控制源点的发送速率，因此容易混淆。拥塞控制的任务是防止过多的数据注入到网络中，使网络能够承受现有的网络负载。这是一个全局性的问题，涉及各方面的行为，包括所有的主机，所有的路由器，路由器内部的存储转发处理过程，以及与降低网络传输性能有关的所有因素。</p><p>与此相反，流量控制只与特定点对点通信的发送方和接收方之间的流量有关。它的任务是，确保一个快速的发送方不会持续地以超过接收方接收能力的速率发送数据，以防止接收方来不及处理数据。流量控制通常涉及的做法是，接收方向发送方提供某种直接的反馈，以抑制发送方的发送速率。</p><p>从控制论的角度出发，拥塞控制可以分为开环控制和闭环控制两大类。开环控制方法试图用良好的设计来解决问题，它的本质是从一开始就保证问题不会发生。一旦系统启动并运行起来了，就不需要中途做修正。</p><p>相反，闭环控制是一种基于反馈环路的方法，它包括三个部分：</p><ul><li>监测网络系统以便监测到拥塞在何时、何地发生</li><li>把拥塞发生的信息传送到可以采取行动的地方</li><li>调整网络系统的运行以解决出现的问题</li></ul><p>当网络系统的流量可以准确规定、性能要求可以事先获得时，适于使用开环控制；而当流量特征不能1准确描述或者当系统不提供资源预留时，适于使用闭环控制。由于因特网中不提供资源预留的机制，而且流量的特性不能准确地描述，所以在因特网中拥塞控制主要采用闭环控制方法。</p><p>根据拥塞反馈信息的形式，又可以将闭环拥塞控制算法分为显式反馈算法和隐式反馈算法。在显式反馈算法中，从拥塞点（即路由器）向源点提供关于网络中拥塞状态的显式反馈信息。当因特网中一个路由器被大量的IP是数据报淹没时，它可能会丢弃一些数据报，同时可使用ICMP源站抑制报文通告源主机。源站收到后应降低发送速率。不过当网络拥塞发生时，向网络中注入这些额外的分组可能会”火上浇油“，因此在实际中很少使用。现在，因特网中的拥塞控制任务主要是在运输层上完成的。更好的显式反馈信息的方法是，在路由器转发的分组中保留一个比特或字段，用该比特或字段的值表示网络的拥塞状态，而不是专门发送一个分组。</p><p>在隐式反馈算法中，源端通过对网络行为的观察来推断是否发生了拥塞，无需拥塞点提供显式反馈信息。TCP采用的就是隐式反馈算法。</p><p>需要说明的是，拥塞控制并不仅仅是运输层要考虑的问题。显式反馈算法就必须涉及网络层。虽然一些网络体系结构主要在网路层实现拥塞控制，但因特网主要利用隐式反馈在运输层实现拥塞控制。</p><p>不论采用哪种方法进行拥塞控制都是需要付出代价的。例如，在实施拥塞控制时，可能需要在结点之间交换信息和各种命令，以便选择控制的策略和实施控制。这样会产生额外的开销。有些拥塞控制机制会预留一些资源用于特殊用户或特殊情况，降低了网络资源的共享程度。因此，当网络输入负载1不大时，有拥塞控制的系统吞吐量要低于无拥塞控制的系统吞吐量。但付出一定的代价是值得的，它会保证网络性能的稳定，不会因为输入负载的增长而导致网络性能的恶化甚至出现崩溃。</p><h2 id="三、TCP的拥塞控制"><a href="#三、TCP的拥塞控制" class="headerlink" title="三、TCP的拥塞控制"></a>三、TCP的拥塞控制</h2><p>TCP采用的方法是让每一个发送方根据所感知到的网络拥塞的程度，来限制其向连接发送流量的速率。如果TCP发送方感知从它到目的地之间的路径上没有拥塞，则增加其发送速率；如果发送方感知在该路径上有拥塞，则降低其发送速率。该方法具体要解决以下三个问题：首先，TCP发送方如何限制它的发送速率；其次，TCP发送方如何感知从它到目的地之间的路径上存在拥塞；最后，当发送方感知到端到端的拥塞时，采用什么算法来改变其发送速率。</p><p>TCP的流量控制利用接收方通告给发送方的接收窗口<code>rwnd</code>大小来限制发送窗口的大小。这个窗口大小就是接收方给发送方的TCP报文段首部中的窗口字段的值。实际上TCP的发送方还维持着一个叫做拥塞窗口<code>cwnd</code>的状态变量。拥塞窗口的大小取决于网络的拥塞程度，并且是动态变化的。TCP发送方在确定发送报文段的速率时，既要根据接收方的接收能力，又要从全局考虑不要使网络发生拥塞。因此TCP发送方的发送窗口大小取接收方接收窗口和拥塞窗口的最小值，即应按如下公式确定：</p><p><code>发送窗口的上限值=Min(rwnd,cwnd)</code></p><p>当<code>rwnd&lt;cwnd</code>时，是接收方的接收能力限制发送窗口的最大值。但当<code>cwnd&lt;rwnd</code>时，则是网络的传输能力限制发送窗口的最大值。</p><p>TCP发送方又是如何知道网络发生了拥塞呢？我们知道，当网络发生拥塞时，路由器就要丢弃分组。现在通信线路的传输质量一般都很好，因传输出差错而丢弃分组的概率是很小的。因此检测到分组丢失就可以认为网络出现了故障。在快速重传中，发送方不一定要通过重传计时器超时才能发现分组的丢失，可以通过接收到三个重复确认就能判断有分组的丢失。因此，当重传计时器超时或接收到三个重复确认时，TCP的发送方就认为网络出现了拥塞。</p><p>当发送方感知到端到端的拥塞时，采用什么算法来改变其发送速率呢？慢启动、拥塞避免和快速恢复。</p><ul><li><p>慢启动和拥塞避免</p><p>当主机刚开始发送数据时完全不知道网络的拥塞情况，如果立即把较大的发送窗口中的全部数据字节都注入到网络，那么就有可能引发网络拥塞。经验证明，较好的方法是通过试探发现网络中的可用带宽，即由小到大逐渐增大发送方的拥塞窗口数值，直到发生拥塞。通常在刚刚开始发送报文段时可先将拥塞窗口<code>cwnd</code>设置为一个最大报文段MSS的数值。而在每收到一个对新的报文段的确认后，将拥塞窗口增加至多一个MSS的数值。用这样的方法逐步增大发送方的拥塞窗口<code>cwnd</code>，可以使分组注入到网络的速率更加合理。这就是慢启动算法。</p><p>在慢启动阶段发送速率以指数方式迅速增长，若持续以该速度增长发送速率必然导致网络很快进入到拥塞状态。因此当网络要接近拥塞时应降低发送速率的增长率，以避免网络拥塞。这可以使TCP连接在一段相对长的时间内保持较高的发送速率但又不使网络拥塞。为此，TCP定义了一个状态变量，即慢启动门限<code>ssthresh</code>（即从慢启动阶段进入拥塞避免阶段的门限）。慢启动门限<code>ssthresh</code>的用法如下：</p><ul><li>当<code>cwnd&lt;ssthresh</code>时，使用上述的慢启动算法</li><li>当<code>cwnd&gt;ssthresh</code>时，停止使用慢启动算法而改用拥塞避免算法</li><li>当<code>cwnd=ssthresh</code>时，即可以使用慢启动算法，又可以使用拥塞避免算法</li></ul><p>具体的做法如下所述：</p><p>拥塞避免算法使发送方的拥塞窗口<code>cwnd</code>每经过大约一个往返时间RTT就增加一个MSS的大小。实际的做法是，每收到一个新的确认，将<code>cwnd</code>增加<code>MSS*(MSS/cwnd)</code>。这样，拥塞窗口<code>cwnd</code>按线性规律缓慢增长，比慢启动算法的拥塞窗口增长速率缓慢得多。</p><p>无论在慢启动阶段还是在拥塞避免阶段，只要发送方发现网络拥塞，就立即将拥塞窗口<code>cwnd</code>重新设置为1，并执行慢启动算法。这样做的目的就是要迅速减少主机发送到网络中的分组数，使得发生拥塞的路由器有足够的时间把队列中积压的分组处理完毕。在重新执行慢启动算法的同时，将慢启动门限<code>ssthresh</code>设置为出现拥塞时的发送窗口值的一半。这样设置的考虑是：这一次在该窗口值发生拥塞，则下次很有可能在该窗口值再出现拥塞，因此当下次拥塞窗口又接近该值时，就要降低窗口的增长速率，进入拥塞避免阶段。</p><p>拥塞避免的具体过程：</p><ul><li>当TCP连接进行初始化时，将拥塞窗口置为1.</li><li>执行慢启动算法时，拥塞窗口<code>cwnd</code>的初始值为1。以后发送方每收到一个对新报文段的确认ACK，就将发送方的拥塞窗口加1，然后开始下一次的传输。一个轮次就是把拥塞窗口<code>cwnd</code>所允许发送的报文段都发送出去，并且都收到了对方的确认。“轮次”之间的间隔时间可以近似为一个RTT。因此，拥塞窗口<code>cwnd</code>随着传输轮次按指数规律增长。当拥塞窗口<code>cwnd</code>增长到慢启动门限值<code>ssthresh</code>时，就改为执行拥塞避免算法，拥塞窗口按线性规律增长。</li><li>假定拥塞窗口的数值增长到24时，网络出现拥塞。更新后的<code>ssthresh</code>值变为12，拥塞窗口再重新设置为1，并执行慢启动算法。当<code>cwnd=12</code>时改为执行拥塞避免算法，拥塞窗口按线性规律增长，每经过一个往返时间就增加一个MSS的大小。</li></ul><p>可见，执行拥塞避免算法后，拥塞窗口呈线性增长，发送速率增长比较缓慢，以防止网络过早出现拥塞，并使发送方可以长时间保持一个合理的发送速率。这里要再强调一下，“拥塞避免”并不能避免拥塞，而是说把拥塞窗口控制为按线性规律增长，使网络不容易立即出现拥塞。</p></li><li><p>快速恢复</p><p>实际上TCP检测到分组丢失有两种情况：重传计时器超时和收到连续三个重复的ACK。上面的拥塞控制算法对这两种情况采取了同样的反应，即将拥塞窗口降低为1，然后执行慢启动算法。但实际上这两种情况下网络拥塞情况是不一样的。当发送方收到连续三个重复的ACK时，虽然有可能丢失了一些分组，但这连续的三个重复ACK同样又表明丢失分组以外的另外三个分组已经被接收方接收了。因此，与发生超时事件的情况不同，网络还有一定的分组交付能力，拥塞情况并不严重。既然网络拥塞情况并不严重，将拥塞窗口直接降低为1则反应太过剧烈了，这会导致发送方要经过很长时间才能恢复到正常的传输速率。</p><p>为此，定义了与快速重传配套使用的快速恢复算法，其具体步骤如下：</p><ul><li>当发送方收到连续三个重复的ACK时，就重新设置慢启动门限<code>ssthresh</code>，将其设置为当前发送窗口的一半。这一点和慢启动算法是一样的。</li><li>与慢启动不同之处是拥塞窗口<code>cwnd</code>不是设置为1，而是设置为新设置的慢启动门限<code>ssthresh</code>，然后开始执行拥塞避免算法，使拥塞窗口缓慢地线性增长。</li></ul><p>对于超时事件，由于后续的分组都被丢弃了，一直没有收到它们的确认而导致重传计时器超时，显然网络存在严重的阻塞。对于这种情况重新执行慢启动有助于迅速减少主机发送到网络中的分组数，使发生拥塞的路由器有足够的时间把队列中积压的分组处理完毕。</p><p>采用快速恢复算法的情况下，长时间的TCP连接在稳定的时候通常处于下面描述的不断重复状态。经过慢启动发送方迅速进入拥塞避免阶段，在该阶段，使拥塞窗口呈线性增长，即加性增，发送速率缓慢增长，以防止网络网络过早拥塞。当流量逐渐超过网络可用带宽时会出现拥塞，但由于发送速率增长缓慢，通常仅导致少量分组丢失。这种情况下发送方会超过三个重复ACK并将拥塞窗口减半，即“乘性减”，然后再继续执行“加性增”缓慢增长发送速率，如此重复下去。因此，对于长时间的TCP连接，在稳定时的拥塞窗口大小呈锯齿状变化。在这种“加性增，乘性减“的拥塞控制下，发送方的平均发送速率始终保持在较接近网络可用带宽的位置。</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;当网络中出现太多的分组时，网络的性能开始下降。这种情况称为拥塞。拥塞是分组交换网中一个非常重要的问题。如果网络中的负载，即发送到网络中的数据量超过了网络的容量，即网络中能处理的数据量，那么在网络中就可能发生拥塞。所谓拥塞控制就是放置过多的数据注入到网络中，这样可以使网络中的
      
    
    </summary>
    
      <category term="计算机网络" scheme="http://wanqbin.xyz/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="TCP" scheme="http://wanqbin.xyz/tags/TCP/"/>
    
      <category term="拥塞控制" scheme="http://wanqbin.xyz/tags/%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6/"/>
    
      <category term="计算机网络" scheme="http://wanqbin.xyz/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>用户数据报协议UDP</title>
    <link href="http://wanqbin.xyz/2019/%E7%94%A8%E6%88%B7%E6%95%B0%E6%8D%AE%E6%8A%A5%E5%8D%8F%E8%AE%AEUDP/"/>
    <id>http://wanqbin.xyz/2019/用户数据报协议UDP/</id>
    <published>2019-11-18T17:03:00.000Z</published>
    <updated>2019-11-18T17:03:48.323Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、UDP概述"><a href="#一、UDP概述" class="headerlink" title="一、UDP概述"></a>一、UDP概述</h2><p>用户数据报协议UDP只在IP数据报服务之上增加了有限的功能，这就是端口的功能（有了端口，运输层就能进行复用和分用）和差错检测功能。虽然UDP用户数据报只能提供不可靠的交付，但UDP在某些方面有其特殊的优点，如下：</p><ul><li>UDP是无连接的，即发送数据之前不需要建立连接，因此减少了开销和发送数据之前的时延。</li><li>UDP使用尽最大努力交付，即不保证可靠交付，同时也不使用流量控制和拥塞控制，因此主机不需要维持具有很多参数的、复杂的连接状态表。</li><li>由于UDP没有拥塞控制，因此网络出现的拥塞不会使源主机的发送速率降低。这对某些实时应用时很重要的。</li><li>UDP是面向报文的。这就是说，UDP对应用程序交下来的报文不再划分为若干个分组来发送，也并把收到的若干个报文合并后再交给应用程序。应用程序交给UDP一个报文，UDP就发送这个报文；而UDP收到一个报文，就把它交付给应用程序。因此，应用程序必须选择合适大小的报文。若报文太长，UDP把它交给IP层后，IP层在传送时可能要进行分片，这会降低IP层的效率。反之，若报文太短，UDP就把它交给IP层后，会使IP数据报的首部相对太大，降低了IP层的效率。</li><li>UDP支持一对一，一对多，多对一和多对多的交互通信。</li><li>用户数据报只有8个字节的首部开销，比TCP的20个字节的首部要短得多。</li></ul><h2 id="二、UDP报文的首部格式"><a href="#二、UDP报文的首部格式" class="headerlink" title="二、UDP报文的首部格式"></a>二、UDP报文的首部格式</h2><p>UDP报文有两个字段：数据字段和首部字段。首部字段很简单，只有8个字节，由四个字段组成，每个字段都是两个字节。各字段意义如下：</p><ul><li>源端口：源端口号</li><li>目的端口：目的端口号</li><li>长度：UDP用户数据报的长度</li><li>检验和：差错检验码，防止UDP用户数据报在传输中出错。</li></ul><p>UDP报文首部中最重要的字段就是源端口和目的端口，它们用来标识UDP发送方和接收方。实际上，UDP是通过二元组（目的IP地址，目的端口号）来定位一个接收方应用进程，而用二元组（源IP地址，源端口号）来标识一个发送方进程。二元组（IP地址，端口号）被称为套接字地址。</p><p>一个UDP端口与一个报文队列（缓存）关联，UDP根据目的端口号将到达的报文加到相应的队列。应用进程根据需要的队列中读取整个报文。由于UDP没有流量控制功能，如果报文到达的速度长期大于应用进程从队列中读取报文的速度，则会导致队列溢出和报文丢失。</p><p>如果接收方UDP发现收到的报文中的目的端口号不正确（即不存在对应于该端口号的应用进程），则丢弃该报文，并由网际控制报文协议ICMP发送一个端口不可达的差错报文给对方1.</p><p>UDP用户数据报首部中检验和的计算方法有些特殊。在1计算检验和时，要在UDP用户数据报之前增加12个字节的伪首部。所谓伪首部是因为这种伪首部并不是UDP用户数据报真正的首部。只是在计算检验和时，临时和UDP用户数据报连接在一起，得到一个临时的UDP用户数据报。检验和就是按照这个临时的UDP用户数据报来计算的。伪首部既不向下传送也不向上递交，而仅仅是为了计算检验和，防止报文被意外地交付到错误的目的地。</p><p>UDP计算检验和的方法和计算IP数据报首部检验和的方法相似。但不同的是：IP数据报的检验和只检验IP数据报的首部，但UDP的检验和是把首部和数据部分一起都检验。在发送方，首先是先把全零放入检验和字段。再把伪首部及UDP用户数据报看成是由许多16位的子串接起来。若UDP用户数据报的数据部分不是偶数个字节，则要填入一个全零字节（但此字节不发送）。然后按二进制反码计算出这些16位字的和。将此和的二进制反码写入检验和字段后，发送这样的UDP用户数据报。在接收方，把收到的UDP用户数据报连同伪首部一起，按为二进制反码求这些16位字的和，当无差错时其结果全为1，否则就表明有差错出现，接收方就丢弃这个UDP用户数据报，也可以上交给应用层，但附上出现差错的警告。这种简单的差错检验方法的检错能力并不强，但它的好处是简单，处理起来较快。</p><p>伪首部的第三字段是全零，第四个字段是IP首部中的协议字段的值。对于UDP，此协议字段值为17，第五字段是UDP用户数据报的长度。这样的检验和，既检查了UDP用户数据报的源端口号，目的端口号及UDP用户数据报的数据部分，又检查了IP数据报的源IP地址和目的地址。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、UDP概述&quot;&gt;&lt;a href=&quot;#一、UDP概述&quot; class=&quot;headerlink&quot; title=&quot;一、UDP概述&quot;&gt;&lt;/a&gt;一、UDP概述&lt;/h2&gt;&lt;p&gt;用户数据报协议UDP只在IP数据报服务之上增加了有限的功能，这就是端口的功能（有了端口，运输层就能进
      
    
    </summary>
    
      <category term="计算机网络" scheme="http://wanqbin.xyz/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="计算机网络" scheme="http://wanqbin.xyz/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
      <category term="用户数据报协议" scheme="http://wanqbin.xyz/tags/%E7%94%A8%E6%88%B7%E6%95%B0%E6%8D%AE%E6%8A%A5%E5%8D%8F%E8%AE%AE/"/>
    
      <category term="UDP" scheme="http://wanqbin.xyz/tags/UDP/"/>
    
  </entry>
  
  <entry>
    <title>运输层概述</title>
    <link href="http://wanqbin.xyz/2019/%E8%BF%90%E8%BE%93%E5%B1%82%E6%A6%82%E8%BF%B0/"/>
    <id>http://wanqbin.xyz/2019/运输层概述/</id>
    <published>2019-11-18T17:02:00.000Z</published>
    <updated>2019-11-18T17:02:42.294Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、进程之间的通信"><a href="#一、进程之间的通信" class="headerlink" title="一、进程之间的通信"></a>一、进程之间的通信</h2><p>从通信和信息处理的角度看，运输层向它上面的应用层提供端到端通信服务。它属于面向通信部分的最高层，同时也是用户功能中的最底层。当位于网络边缘部分的两台主机使用网络核心部分的功能进行端到端的通信时，只有主机的协议栈才有运输层，网络核心部分中的路由器在转发分组时都只用到了下三层的功能。</p><p>从IP层看，通信的两端是两个主机。IP数据报的首部明确地标志了这两个主机的IP地址。然而严格地讲，两个主机进行通信实际上就是两个主机中的应用程序互相通信。IP协议虽然能把分组送到目的主机，但是这个分组还停留在主机的网络层而没有交付给主机中的应用程序。从运输层的角度看，通信的真正端点并不是主机而是主机中的进程。因此从运输层来看，端到端的通信是应用进程之间的通信。</p><p>在一个主机中经常有多个应用进程同时分别和另一个主机中的多个应用进程通信。因此，运输层的一个很重要的功能就是复用和分用。这里的复用是指在发送方不同的应用进程都可以使用同一个运输层协议传送数据，而分用是指接收方的运输层在剥去报文的首部后能够把这些数据正确地交付到目的应用进程。</p><p>运输层提供应用进程之间的逻辑通信指的是，运输层之间的通信好像是沿水平方向的传送数据，但事实上这两个传输层之间并没有与一条水平方向的物理连接。</p><p>网络层和运输层有很大的区别：网络层是为主机之间提供逻辑通信，而运输层是为应用进程之间提供端到端的逻辑通信。</p><p>运输层向高层用户屏蔽了下面网络核心的细节，它使应用进程看见的就是好像在两个运输层实体之间有一条端到端的逻辑通信信道，但这条逻辑通信信道对上层的表现却因运输层使用的不同协议而有很大的差别。</p><p>当运输层采用面向连接的TCP协议时，尽管下面的网络是不可靠的，但这种逻辑通信信道就相当于一条全双工的可靠信道。但当运输层采用无连接的UDP协议时，这种逻辑通信信道仍然是一条不可靠信道。</p><p>在网络中，两个进程要进行通信，必须有一个进程要主动发起通信，而另一个进程要事先准备好接受通信请求，这就是客户——服务器通信模式。在术语客户——服务器通信模式中，客户和服务器都是进行通信的应用进程，客户是主动发起通信的进程，而服务器是被动接受通信请求的进程。</p><h2 id="二、因特网的运输层协议"><a href="#二、因特网的运输层协议" class="headerlink" title="二、因特网的运输层协议"></a>二、因特网的运输层协议</h2><p>我们知道，因特网的网络层为主机之间提供的逻辑通信服务是一种尽最大努力交付的数据报服务。也就是说，IP报文在传送过程中有可能出错、丢失或失序。对于像电子邮件、文件传输、万维网以及电子银行等很多应用，数据丢失可能会造成灾难性的后果。因此，需要运输层为这类应用提供可靠的数据传输服务。但对于实时的多媒体应用，如实时音/视频，它们能够承受一定程度的数据丢失。在这些多媒体应用1中，丢失少量的数据会对播放的质量产生一些小的影响，但不会造成致命的损伤。为实现可靠数据传输，运输层协议必须增加很多复杂得多机制，而这些机制非但不能为这些多媒体应用带来明显的好处，而且会带来一些不利因素。总之，单一的运输层服务很难满足所有应用的需求。</p><p>因特网为上层应用提供了两个不同的运输层协议，即：</p><ul><li>用户数据报协议UDP</li><li>传输控制协议TCP</li></ul><p>按照OSI的术语，两个对等运输实体在通信时传送的数据单元叫做运输协议数据单元。但在因特网中，根据使用的协议是TCP还是UDP，分别称为TCP报文段或UDP报文或用户数据报。</p><p>UDP在传送数据之前不需要先建立连接。接收方运输层在收到UDP报文后，不需要给出任何确认。虽然UDP不提供可靠交付，但在某些情况下UDP却是一种最有效的工作方式。</p><p>TCP则提供面向连接的服务。在传送数据之前必须先建立连接，数据传送结束后要释放连接。TCP不提供广播或多播服务。由于TCP要提供可靠的、面向连接的运输服务，因此不可避免地增加了许多开销，如确认、流量控制、计时器及连接管理等。这不仅使协议数据单元的首部增大很多，还要占用许多的处理机资源。</p><h2 id="三、运输层的复用与分用"><a href="#三、运输层的复用与分用" class="headerlink" title="三、运输层的复用与分用"></a>三、运输层的复用与分用</h2><p>应用层所有的应用进程都可以通过运输层再传送到IP层，这就是复用。运输层从IP层收到数据后必须交付给指明的应用进程，这就是分用。运输层要能正确地将数据交付给指定应用继承，就必须给每个应用继承赋予一个明确的标志。在TCP/IP网络中，使用一种与操作系统无关的协议端口号来实现对通信的应用进程的标志。</p><p>端口是应用层与运输层之间接口的抽象，端口号是应用进程的运输层地址。为此，在运输协议数据单元的首部中必须包含两个字段：源端口号和目的端口号。当运输层收到IP层交上来的数据，就要根据其目的端口号来决定应当通过哪一个端口上交给目的应用进程。</p><p>对于不同的计算机，端口的具体实现方法可能有很大的差别，因为这取决于计算机的操作系统。因此端口的基本概念就是：应用层的源进程将报文发送给运输层的某个端口，而应用层的目的进程从端口接收报文。端口用一个16位端口号进行标志，但端口号只有本地意义。在因特网不同计算机中，相同的端口号是没有联系的，并且TCP和UDP端口号之间也没有必然联系。IP协议根据IP数据报中的协议字段定位要交付的运输层协议，而相应的运输层协议需要根据运输层协议数据单元中的目的端口号来确定要交付的引用进程。16位的端口号可以允许有65535个端口号，这个数目对于一个计算机来说是足够用的。</p><p>由此可见，两个计算机中的进程要相互通信，不仅要知道对方的IP地址，而且还要知道对方的端口号。我们知道应用进程间的通信采用的是客户——服务器通信模式，在应用层中的各种不同的服务器进程不断监听它们的端口，以便发现是否有某个客户进程要和它通信。客户在发起通信请求时，必须先找到对方服务器的IP地址和端口号，而服务器总是可以从接收到的报文中获得客户的IP地址和端口号。为此运输层的端口号供分为下面的3类。</p><ul><li>熟知端口，0~1023.这类端口由因特网赋号管理局负责分配给一些常用的应用程序固定使用，因而所有用户进程都知道。当一种新的应用程序出现时要获得一个熟知的端口，必须向因特网赋号管理局申请。</li><li>登记端口：1024~49151.这类端口因特网赋号管理局不分配也不控制，但可以在因特网赋号管理局注册登记，以防止重复使用。</li><li>动态端口：49152~65535.这类端口是留給客户进程选择作为临时端口。当客户进程发起通信前要先为自己选择一个未用的临时端口，通信结束后要释放该端口以便其他客户进程使用。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、进程之间的通信&quot;&gt;&lt;a href=&quot;#一、进程之间的通信&quot; class=&quot;headerlink&quot; title=&quot;一、进程之间的通信&quot;&gt;&lt;/a&gt;一、进程之间的通信&lt;/h2&gt;&lt;p&gt;从通信和信息处理的角度看，运输层向它上面的应用层提供端到端通信服务。它属于面向通信部
      
    
    </summary>
    
      <category term="计算机网络" scheme="http://wanqbin.xyz/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="计算机网络" scheme="http://wanqbin.xyz/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
      <category term="运输层" scheme="http://wanqbin.xyz/tags/%E8%BF%90%E8%BE%93%E5%B1%82/"/>
    
  </entry>
  
  <entry>
    <title>虚拟存储器</title>
    <link href="http://wanqbin.xyz/2019/%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8/"/>
    <id>http://wanqbin.xyz/2019/虚拟存储器/</id>
    <published>2019-11-18T17:00:00.000Z</published>
    <updated>2019-11-18T17:00:52.441Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、虚拟存储器概述"><a href="#一、虚拟存储器概述" class="headerlink" title="一、虚拟存储器概述"></a>一、虚拟存储器概述</h2><p>之前的各种存储器管理方式有一个共同的特点，即它们都要求将一个作业全部装入内存后方能运行，于是出现了下面两种情况：</p><ul><li>有的作业很大，其所要求的内存空间超过了内存总容量，作业不能全部被装入内存，致使该作业无法运行</li><li>有大量作业要求运行，但由于内存容量不足以容纳所有这些作业，只能将少数作业装入内存让它们先运行，而将其他大量的作业留在外存上等待。</li></ul><p>解决方法：</p><ul><li>从物理上增加内存容量</li><li>从逻辑上扩充内存容量，即虚拟存储技术</li></ul><ol><li><h3 id="常规存储管理方式的特征和局部性原理"><a href="#常规存储管理方式的特征和局部性原理" class="headerlink" title="常规存储管理方式的特征和局部性原理"></a>常规存储管理方式的特征和局部性原理</h3><ul><li><p>常规存储器管理方式的特征：</p><ul><li>一次性</li><li>驻留性</li></ul></li><li><p>局部性原理</p><p>程序在执行时将呈现出局部性规律，即在一个较短的时间内，程序的执行仅局限于某个部分，相应地，它所访问的存储空间也局限于某个区域。</p><ul><li>程序执行时，除了少部分的转移和过程调用指令外，大多数情况下是顺序执行的</li><li>过程调用将会使程序的执行轨迹由一部分区域转至另一部分区域</li><li>程序中存在许多循环结构，这些结构虽然由少数指令构成，但是它们将被多次执行</li><li>程序中还包括许多对数据结构方面的处理，如对数组进行操作，这些处理往往都局限于很小的范围内。</li></ul><p>局限性又表现在下述两个方面：</p><ul><li>时间局限性。产生原因是，在程序中存在着大量的循环操作</li><li>空间局限性。典型情况是程序的顺序执行</li></ul></li><li><p>虚拟存储器的基本工作情况</p><p>&emsp;&emsp;基于局部性原理可知，应用程序在运行之前没有·必要将之全部装入内存，而仅须将那些当前要运行的少数页面或段先装入内存便可运行，其余部分暂留在盘上。</p><p>&emsp;&emsp;程序在运行时，如果它所要访问的页（段）已调入内存，便可继续执行下去；但如果程序所要访问的页（段）尚未调入内存（称为缺页或缺段），便发出缺页（段）中断请求，此时OS将利用请求调页（段）功能将它们调入内存，以使进程能继续执行下去</p><p>&emsp;&emsp;如果此时内存已满，无法再装入新的页（段），OS还须再利用页（段）的置换功能，将内存中暂时不用的页（段）调至盘上，腾出足够的内存空间后，再将要访问的页（段）调入内存，使程序继续执行下去。这样，便可使一个大的用户程序在较小的内存空间中运行，也可在内存中同时装入更多的进程，使它们并发执行。</p></li></ul></li><li><h3 id="虚拟存储器的定义和特征"><a href="#虚拟存储器的定义和特征" class="headerlink" title="虚拟存储器的定义和特征"></a>虚拟存储器的定义和特征</h3><ul><li><p>虚拟存储器的定义</p><p>&emsp;&emsp;所谓虚拟存储器是指具有请求调入功能和置换功能，能从逻辑上对内存容量加以扩充的一种存储器系统其逻辑容量由内存容量和外存容量之和决定，其运行速度接近于内存速度，而每位的成本又接近与外存。可见，虚拟存储技术是一种性能非常优越的存储器管理技术，故被广泛地应用于大、中、小型机器和微型机中。</p></li><li><p>虚拟存储器的特征</p><ul><li>多次性</li><li>对换性</li><li>虚拟性</li></ul><p>虚拟性是以多次性和对换性为基础的；而多次新和对换性显然又必须建立在离散分配的基础上。</p></li></ul></li><li><h3 id="虚拟存储器的实现方法"><a href="#虚拟存储器的实现方法" class="headerlink" title="虚拟存储器的实现方法"></a>虚拟存储器的实现方法</h3><p>&emsp;&emsp;虚拟存储器的实现，建立在离散分配存储管理方式的基础上。</p><ul><li><p>分页请求系统</p><p>分页请求系统是在分页系统的基础上增加了请求调页功能和页面置换功能所形成的页式虚拟存储系统。置换时以页面为单位。</p><ul><li><p>硬件支持</p><ul><li>请求分页的页表机制，它是在纯分页的页表机制上增加了若干项而形成的，作为请求分页的数据结构</li><li>缺页中断机构，每当用户程序要访问的页面尚未调入内存时，便产生一缺页中断，以请求OS将所缺页面调入内存</li><li>地址变换机构，它同样是在存分页地址变换机构的基础上发展形成的</li></ul></li><li><p>实现请求分页的软件</p><p>这里包括有用于实现请求调页的软件和实现页面置换的软件。它们在硬件的支持下，将程序正在运行时所需的页面调入内存，再将内存中暂时不用的页面从内存置换到磁盘上。</p></li></ul></li><li><p>请求分段系统</p><p>请求分段系统是在分段系统的基础上，增加了请求调段及分段置换功能后所形成的段式虚拟存储系统。置换时以段为单位进行的。</p><ul><li><p>硬件支持</p><ul><li>请求分段的段表机制。它是在纯分段的段表机制上增加了若干项而形成的，作为请求分段的数据结构</li><li>缺段中断机构。每当用户程序要访问的段尚未调入内存时，便产生一缺段中断，以请求OS将所缺的段调入内存</li><li>地址变换机构，它同样是在纯分段地址变换机构的基础上发展形成的。</li></ul></li><li><p>软件支持</p><p>包括有用于实现请求调段的软件和实现段置换的软件。</p></li></ul><p>目前，有不少虚拟存储器是建立在段页式系统基础上的，通过增加请求调页和页面置换功能形成了段页式虚拟存储器系统，而且把实现虚拟存储器所需支持的硬件集成在处理器芯片上。</p></li></ul></li></ol><h2 id="二、请求分页储存管理方式"><a href="#二、请求分页储存管理方式" class="headerlink" title="二、请求分页储存管理方式"></a>二、请求分页储存管理方式</h2><ol><li><h3 id="请求分页中的硬件支持"><a href="#请求分页中的硬件支持" class="headerlink" title="请求分页中的硬件支持"></a>请求分页中的硬件支持</h3><ul><li><p>请求页表机制</p><p>需要的主要数据结构是请求页表，其基本作用仍是将用户地址空间中的逻辑地址映射为内存空间中的物理地址。为了满足页面换进换出的需要，在请求页表中又增加了四个字段。这样，在请求分页系统这两个的每个页表应含有：</p><ul><li>页号</li><li>物理块号</li><li>状态位P，用于指示该页是否已调入内存</li><li>访问字段A，用于记录本页被访问的词素，或记录本页最近已有多长时间未被访问</li><li>修改位M，标识该页在调入内存后是否被修改过</li><li>外存地址，用于指出该页在外存上的地址，通常是物理块号</li></ul></li><li><p>缺页中断机构</p><p>在请求分页系统中，每当所要访问的页面不在内存时，便产生一缺页中断，请求OS将所缺页面调入内存。缺页中断作为中断，与一般的中断有很明显的区别：</p><ul><li>在指令执行期间产生和处理中断信号</li><li>一条指令在执行期间可能产生多次缺页中断</li></ul></li><li><p>地址变换机构</p><p>&emsp;&emsp;请求分页系统中的地址变换机构是在分页系统地址变换机构的基础上，为实现虚拟存储器，再增加一些功能所形成的，如产生和处理缺页中断，以及从内存中换出一页的功能等等。</p><p>&emsp;&emsp;在进行地址变换时，首先检索快表，试图从中找出所要访问的页。若找到，便修改页表项中的访问位，供置换算法选换出页面时参考。对于写指令，还须将修改位置成“1”，表示该页在调入内存后已被修改。然后利用页表项给出的物理块号和页内地址形成物理地址。地址变换过程到此结束。</p><p>&emsp;&emsp;如果在快表中未找到该页的页表项，则应到内存中去查找页表，再从找到的页表项中的状态位P来了解该页是否已调入内存。若该页已调入内存，这时应将该页的页表项写入快表。当快表已满时，则应先调出按某种算法所确定的页表项，然后再写入该页表项；若该页尚未调入内存，这时应产生缺页中断，请求OS从外存把该页调入内存。</p></li></ul></li><li><h3 id="请求分页中的内存分配"><a href="#请求分页中的内存分配" class="headerlink" title="请求分页中的内存分配"></a>请求分页中的内存分配</h3><p>在为进程分配内存时，将涉及到三个问题：第一，为保证进程能正常运行，所需要的最小物理块数的确定；第二，在为每个进程分配物理块时，应采取什么样的分配策略，即所分配的物理块是固定的，还是可变的；第三，为不同进程所分配的物理块数，是采取平均分配算法，还是根据进程的大小按比例分配。</p><ul><li><p>最小物理块数的确定</p><p>&emsp;&emsp;随着为每个进程所分配的物理块的减少，将使进程在执行中的缺页率上升，从而降低进程的执行速度。</p><p>&emsp;&emsp;最小物理块数是指能保证进程正常运行所需的最小物理块数，当系统为进程分配的物理块数少于此值时，进程将无法运行。</p><p>&emsp;&emsp;进程应获得的最少物理块树，与计算机的硬件结构有关，取决于指令的格式、功能和寻址方式。对于某些简单的机器，若是单地址指令，且采用直接寻址方式，则所需的最少物理块数为。其中，一块是用于存放指令的页面，一块这是用于存放数据的页面。如果该机器运行间接寻址，则至少要求有三个物理块。</p><p>&emsp;&emsp;在缺页中断结构要发生6次中断，那么，至少要为每个进程分配6个物理块，以装入6个页面。</p></li><li><p>内存分配策略</p><p>在请求分页系统中，可采取两种内存分配策略，即固定和可变分配策略。</p><p>在进行置换时，也可采取两种策略，即全局置换和局部置换。</p><ul><li>固定分配局部置换<ul><li>所谓固定分配，是指为每个进程分配一组固定数目的物理块，在进程运行期间不再改变。</li><li>局部置换，是指如果进程在运行中发现缺页，则只能从分配给该进程的n个页面中选出一页换出，然后再调入一页，以保证分配给该进程的内存空间不变。</li><li>采用该策略时，为每个进程分配多少物理块是根据进程类型或根据程序员，程序管理员的建议来确定的</li><li>该策略的困难之处是：应为每个进程分配多少个物理块难以确定。5</li></ul></li><li>可变分配全局置换<ul><li>可变分配，是指事先为每个进程分配一定数目的物理块，在进程运行期间，可根据情况做适当的增加或减少。</li><li>全局置换，是指如果进程在运行中发现缺页，则将OS所保留的空闲物理块取出一块分配给该进程，或者以所有进程的全部物理块为标的，选择一块换出，然后将所缺页面调入。</li><li>采用这种策略时，凡产生缺页的进程，都将获得新的物理块，仅当空闲物理块队列中的物理块用完时，OS才能从内存中选择一页调出。被选择调出的页可能是系统中任何一个进程中的页，因此这个被选中的进程拥有的物理块会减少，这将导致其缺页率增加。</li></ul></li><li>可变分配局部置换<ul><li>该策略同样是基于进程的类型或程序员的要求，为每一个进程分配一定数目的物理块，但当某进程发现缺页时，只允许从该进程在内存中的页面选择一页调出，这样就不会影响其他进程的运行。如果进程在运行中频繁发生缺页中断，则系统须再为该进程分配若干附加物理块，直至该进程的缺页率减少到适当程度为止。反之，若其他进程缺页率高，该进程缺页率低，会适当减少分配给该进程的物理块函数。</li></ul></li></ul></li><li><p>物理块分配算法</p><ul><li>平均分配算法<ul><li>将系统中所有可供分配的物理块平均分配给各个进程。</li><li>但是这种方式不公平，因为未考虑每个进程的页面数。</li></ul></li><li>按比例分配算法<ul><li>根据进程的大小按比例分配物理块。</li></ul></li><li>考虑优先权的分配算法<ul><li>一部分按比例分配给各个进程</li><li>另一部分根据各进程的优先权进行分配。重要的实时系统中，可能是完全按优先权为各个进程分配其物理块的。</li></ul></li></ul></li></ul></li><li><h3 id="页面调入策略"><a href="#页面调入策略" class="headerlink" title="页面调入策略"></a>页面调入策略</h3><p>为使进程能够正常运行，必须事先将要执行的那部分程序和数据所在的页面调入内存，现在的问题是：</p><p>（1）系统应该何时调入所需页面</p><p>（2）系统应从何处调入这些页面</p><p>（3）是如何进行调入的</p><ul><li><p>何时调入页面</p><ul><li>预调页策略<ul><li>以预测为基础的预调页策略，将那些预计在不久以后便会被访问的页面预先调入内存。目前，预调页的成功率仅为50%</li><li>首先可用于在第一将进程调入内存时，此时可将程序员指出的那些页先调入内存。其次是，在采用工作集的系统中，每个进程都具有一张表，表中记录有运行时的工作集，每当程序被调度运行时，将工作集中的所有页调入内存</li></ul></li><li>请求调页策略<ul><li>当进程在运行中需要访问某部分程序和数据时，如偶发现其所在的页面不在内存中，便立即提出请求，由OS将其所需页面调入内存。</li><li>该策略每次仅调入一页，效率低，系统的开销大</li></ul></li></ul></li><li><p>从何处调入页面</p><ul><li>系统拥有足够的对换区空间，这时可以全部从对换区调入所需页面，以提高调页速度。</li><li>系统缺少足够的对换区空间，这是凡是不会被修改的文件，都直接从文件区调入；而当换出这些页面时，由于它们未被修改，则不必再将它们重写到磁盘以后再调入时，仍从文件区直接调入。对于那些可能被修改的部分，在将它们换出时便须调到对换区，以后需要再从对换区调入</li><li>UNIX方式。由于与进程有关的文件都放在文件区，故凡是未运行过的页面，都应从文件区调入。而对于曾经运行过但又被换出的页面，由于是被放在对换区，因此在下次调入时应从对换区调入。由于UNIX系统允许页面共享，因此，某进程所请求的页面有可能已被其他进程调入内存，此时也就无需再从对换区调入。</li></ul></li><li><p>页面调入过程</p><p>&emsp;&emsp;每当程序所要访问的页面未在内存时，便向CPU发出一缺页中断，中断处理程序首先保留CPU环境，分析中断原因后转入缺页中断处理程序。</p><p>&emsp;&emsp;该程序通过查找页表得到该页在外存的物理块后，如果此时内存能容纳新页，则启动磁盘I/O，将所缺页面调入内存，然后修改页表。</p><p>&emsp;&emsp;如果内存已满，则须先按某种置换算法，从内存中选出一页准备换出：如果该页未被修改过，可不必将该页写回磁盘，并修改页表中的相应表项，置其存在位为“1”，并将此页表项写入快表。在缺页调入内存后，利用修改后的页表形成所要访问数据的物理地址，再去访问内存数据，整个页面的调入过程对于用户来说是透明的。</p></li><li><p>缺页率</p><p>在进程运行的过程中，访问页面成功的次数为S，访问页面失败的次数为F，则该进程总的页面访问次数为A=S+F,那么该进程在其运行过程中的缺页率即为：</p><p>​                f=$\frac{F}{A}$</p><p>通常，缺页率受到以下几个因素的影响：</p><ul><li>页面大小，页面划分越大，缺页率越低</li><li>进程所分配物理块数。分配的物理块数越多，缺页率越低</li><li>页面置换算法</li><li>程序固有特性：程序本身的编制方法对缺页中断次数有影响。根据程序执行的局部性原理，程序编制的局部化程度越高，相应地执行时的缺页程度越低。</li></ul></li></ul></li></ol><h2 id="三、页面置换算法"><a href="#三、页面置换算法" class="headerlink" title="三、页面置换算法"></a>三、页面置换算法</h2><p>通常，把选择换出页面的算法称为页面置换算法。置换算法的好好直接影响到系统的性能。</p><p>不适当的算法可能会导致进程发生“抖动”，即刚被换出的页很快又要被访问，需要将它重新调入，此时又需要再选一页调出；而此刚被调出的页很快又被访问，又须将它调入，如此频繁的更换页面，以致一个进程在运行中把大部分时间都花费在了页面置换工作上，我们称该进程发生了“抖动”。好的置换算法应具有较低的页面更换频率。</p><ol><li><h3 id="最佳置换算法"><a href="#最佳置换算法" class="headerlink" title="最佳置换算法"></a>最佳置换算法</h3><p>其选择的被淘汰的页面将使以后永不再使用的，或许是在最长时间内不再被访问的页面。采用最佳置换算法可以获得较低的缺页率，但是无法预知哪个页面是未来最长时间内不再被访问的，因而该算法无法实现。</p></li><li><h3 id="先进先出置换算法（FIFO"><a href="#先进先出置换算法（FIFO" class="headerlink" title="先进先出置换算法（FIFO)"></a>先进先出置换算法（FIFO)</h3><ul><li>总是淘汰最先进入内存的页面，即选择在内存中驻留时间最久的页面予以淘汰。该算法实现简单。</li><li>一个替换指针，指向最老的页面。</li><li>换页频率是最佳置换算法的两倍</li></ul></li><li><h3 id="最近最久未使用置换算法（LRU）"><a href="#最近最久未使用置换算法（LRU）" class="headerlink" title="最近最久未使用置换算法（LRU）"></a>最近最久未使用置换算法（LRU）</h3><ul><li>根据页面调入内存后的使用情况作出决策。</li><li>LRU置换算法是选择最近最久未使用的页面予以淘汰。该算法赋予每个页面一个访问了字段，用来记录一个页面自上次被访问以来经历的时间t。淘汰时i，选择了t最大的淘汰。</li><li>LRU的硬件支持<ul><li>寄存器</li><li>栈</li></ul></li></ul></li><li><h3 id="最少使用置换算法（LFU）"><a href="#最少使用置换算法（LFU）" class="headerlink" title="最少使用置换算法（LFU）"></a>最少使用置换算法（LFU）</h3><ul><li>在内存中为每个页面设置一个移位寄存器，用来记录该页面被访问的频率。选择在最近时期使用最少的页面作为淘汰值。</li><li>采用的是在较大时间间隔来记录对该页的访问</li><li>利用LRU中的硬件，可以实现LFU</li></ul></li><li><h3 id="Clock置换算法"><a href="#Clock置换算法" class="headerlink" title="Clock置换算法"></a>Clock置换算法</h3><ul><li><p>Clock算法是一种LRU近似算法</p></li><li><p>简单的Clock置换算法</p><ul><li>为每页设置一未访问位，再将内存中的所有页面都通过链接指针链接成一个循环队列。</li><li>当某页被访问时，其访问位置1。选择页面淘汰时，只需检查页的访问位，如果是0，换出，若为1，重新将其置0，暂不换出，给予该页面第二次驻留内存的机会。</li><li>再按照FIFO算法检查下一个页面。当检查到队列中最后一个页面时，若其访问位仍是1，则再返回到队首去检查第一个页面。</li><li>又称为最近未用算法（NRU）</li></ul></li><li><p>改进型Clock置换算法</p><ul><li><p>在这个算法中，除了要考虑页面的使用情况外，还须再增加一个因素——置换代价。这样，选择页面换出时，既要是未使用过的页面，又要是未秀爱过的页面。把同时满足这两个条件的页面作为首选淘汰的页面。</p></li><li><p>由访问位A和修改位M可以组合成下面四种类型的页面：</p><ul><li>A=0，M=0：表示该页最最近既没有被访问，也没有被修改，是最佳淘汰页</li><li>A=0，M=1：该页未被访问，已被修改，不是很好的淘汰页</li><li>A=1，M=0，该页已被访问，未被修改，很有可能再次被访问</li><li>A=1，M=1，被访问且被修改，该页可能再次被访问</li></ul><p>执行过程分为三步：</p><ul><li>从指针所指示的当前位置开始，扫描循环队列，寻找A=0且M=0的第一类页面，将所遇到的第一个页面作为选中的淘汰页。在第一次扫描期间不改变访问位A</li><li>第一步失败，开始第二轮扫描，寻找第二类页面，将所遇到的第一个该类页面作为淘汰页。在第二轮扫描期间，将所有扫描过的页面的访问位置0</li><li>第二步失败，将指针返回到最开始的位置，将所有的访问位置0，重复第一步。</li></ul><p>该算法比简单的Clock算法减少了I/O操作次数。但本身开销有所增加。</p></li></ul></li></ul></li><li><h3 id="页面缓冲算法"><a href="#页面缓冲算法" class="headerlink" title="页面缓冲算法"></a>页面缓冲算法</h3><ul><li>影响页面换进换出效率的若干因素<ul><li>页面置换算法</li><li>写回磁盘的速率</li><li>读入内存的频率</li></ul></li><li>页面缓冲算法PBA<ul><li>主要特点：<ul><li>显著降低了页面换进、换出的频率，使磁盘I/O数大为减少</li><li>由于换进换出的开销大幅度减小，才能使其采用一种较简单的置换策略，如FIFO算法，不需要特殊的硬件支持</li></ul></li><li>空闲页面链表<ul><li>实际上该链表是一个空闲物理块链表，是系统掌握的空闲物理块，用于分配给频繁发生缺页的进程，以降低缺页率</li><li>当这样的进程需要读入一个页面时，便可利用空闲物理块链表中的第一个物理块来装入该页</li><li>当有一个未被修改的页要换出时，实际上并不把它换出到外存，而是把它们所在的物理块挂在空闲链表的末尾。</li></ul></li><li>修改页面链表<ul><li>它是由已修改的页面所形成的链表</li><li>设置该链表的目的是为了减少已修改页面换出的次数</li><li>当该进程需要将一个已修改的页面换出时，系统并不立即将它换出到外存上，而是将它所在的物理块挂在修改页面链表的末尾。这样做的目的是：降低将已修改页面写回磁盘的频率，降低将磁盘内容读入内存的频率</li></ul></li></ul></li></ul></li><li><h3 id="访问内存的有效时间"><a href="#访问内存的有效时间" class="headerlink" title="访问内存的有效时间"></a>访问内存的有效时间</h3><ul><li>被访问页在内存中，且其对应的页表项在快表中<ul><li>查找快表时间λ，访问实际物理内存所需的时间t</li><li>EAT=λ+t</li></ul></li><li>被访问页在内存中，且其对应的页表项不在快表中<ul><li>查找快表的时间，修改快表的时间和访问实际物理地址的时间</li><li>EAT=λ+t+λ+t</li></ul></li><li>被访问页不在内存中<ul><li>查找快表的时间、查找页表的时间、处理缺页中断的时间（ε）、更新快表的时间、实际访问物理地址的时间</li><li>EAT=λ+t+ε+λ+t</li></ul></li></ul></li></ol><h2 id="四、“抖动”与工作集"><a href="#四、“抖动”与工作集" class="headerlink" title="四、“抖动”与工作集"></a>四、“抖动”与工作集</h2><ol><li><h3 id="多道程序度与“抖动”"><a href="#多道程序度与“抖动”" class="headerlink" title="多道程序度与“抖动”"></a>多道程序度与“抖动”</h3><ul><li>多道程序度与处理机的利用率<ul><li>由于虚拟存储器系统能从逻辑上扩大内存，这时，只需装入一个进程的部分程序和数据便可开始运行，故人们希望在系统中能运行更多的进程，即增加多道程序度，以提高处理机的利用率</li><li>进程数目增加，处理机利用率剧烈增加；进程再增加，处理机利用率加速下降趋于0，即发生抖动。</li></ul></li><li>产生“抖动”的原因<ul><li>根本原因是，同时在系统中运行的进程太多，由此分配给每一个进程的物理块太少，不能满足进程正常运行的基本要求，致使每个进程在运行时，频繁地出现缺页，必须请求系统将所缺的页面调入内存。</li><li>这会使得系统中排队等待页面调入/调出的进程数目增加，对磁盘的访问时间也随之急剧增加。</li><li>由于“抖动”的发生与系统为进程分配的物理块的多少有关，于是出现了“工作集”</li></ul></li></ul></li><li><h3 id="工作集"><a href="#工作集" class="headerlink" title="工作集"></a>工作集</h3><ul><li>工作集的基本概念<ul><li>基于程序运行时的局部性原理可知，程序在运行期间，对页面的访问时不均匀的，在一段时间内仅局限于较少的页面，在另一段时间内，可能仅局限于另一些较少的页面进行访问。这些页面被称为活跃页面。如果能够预知程序在某段时间间隔要访问哪些页面，并将它们调入内存，将会大大降低缺页率，从而显著地提高处理机的利用率</li></ul></li><li>工作集的定义<ul><li>所谓工作集，是指某段时间间隔A里，进程实际所要访问页面的集合。</li></ul></li></ul></li><li><h3 id="“抖动”的预防方法"><a href="#“抖动”的预防方法" class="headerlink" title="“抖动”的预防方法"></a>“抖动”的预防方法</h3><ul><li>采取局部置换策略<ul><li>在页面分配和置换中，如果采取的是可变分配方式，则为了预防发生“抖动”，可采取局部置换策略。根据这种策略，当某进程发生缺页时，只能在分配給自己的内存空间内进行置换，不允许从其他进程去获得新的物理块。</li><li>该策略将该进程“抖动”所造成的影响限制在较小的范围内。</li><li>该方法虽然简易可行，但效果不是很好，因为在某进程发生“抖动”后，它还会长期处在磁盘I/O的等待队列中，使队列的长度增加，这会延长其他进程缺页中断的处理时间。</li></ul></li><li>把工作集算法融入到处理机调度中<ul><li>在调度算法中融入了工作集算法，则在调度程序从外存调入作业之前，必须先检查每个进程在内存的主流页面是否足够多。如果都已足够多，此时便可以从外存调入新的作业，不会因新作业的调入而导致缺页率的增加，反之，如果有些进程的内存页面不足，则应首先为那些缺页率高的作业增加新的物理块，此时不再调入新的作业。</li></ul></li><li>利用“L=S”准则调节缺页率<ul><li>“L=S”的准则来调节多道程序度，L是缺页之间的平均时间，S是平均缺页服务时间，即用于置换一个页面所需的时间。</li><li>如果是L远大于S，说明很少发生缺页，磁盘的能力尚未得到充分的证明</li><li>如果L比S小，说明频繁发生缺页，缺页的速度已超过磁盘的处理能力</li><li>只有当L与S接近时，磁盘和处理机都可达到它们的最大利用率</li></ul></li><li>选择暂停的进程<ul><li>发生“抖动”，系统必须减少多道程序的数目</li><li>此时，应基于某种原则选择暂停某些当前活动的进程，将它们调出到磁盘上，以便腾出的内存空间分配给缺页率发生偏高的进程</li><li>通常采用与调度程序一致的策略，即首先选择暂停优先级最低的进程</li></ul></li></ul></li></ol><h2 id="五、请求分段存储管理方式"><a href="#五、请求分段存储管理方式" class="headerlink" title="五、请求分段存储管理方式"></a>五、请求分段存储管理方式</h2><p>分段基础上建立的请求分段式虚拟存储器系统，则是以分段为单位进行换入换出的。</p><ol><li><h3 id="请求分段中的硬件支持"><a href="#请求分段中的硬件支持" class="headerlink" title="请求分段中的硬件支持"></a>请求分段中的硬件支持</h3><p>所需的硬件支持有段表机制、缺段中断机构以及地址变换机构</p><ul><li>请求段表机制<ul><li>段名</li><li>段长</li><li>段基址</li><li>存取方式。由于应用程序中的段是信息的逻辑单位，可根据该信息的属性对它实施保护，故在段表中增加存取方式字段，如果该字段为两位，则存取属性是只执行、只读和允许读/写</li><li>访问字段A，记录该段是否被访问</li><li>修改位M，记录该页在进入内存后是否被修改</li><li>存在位P，指示该段是否已调入内存</li><li>增补位，请求分段式管理中所特有的字段，用于表示本段在运行过程中是否做过动态增长</li><li>外存始址，指示本段在外存中的起始地址，即起始盘号</li></ul></li><li>缺段中断机构<ul><li>在请求分段系统中采用的是请求段策略</li><li>所要访问的段未被调入内存时，由中断机构产生一缺段中断信号</li><li>缺段中断机构需要一条指令的执行期间产生执行和处理中断，以及在一条指令执行期间，可能产生多次缺段中断</li><li>由于分段是信息的逻辑单位，因而不可能出现一条指令被分割在两个分段中</li><li>由于段不是定长的，这使对缺段中断的处理比对缺页中断的处理复杂</li></ul></li><li>地址变换机构<ul><li>请求分段系统中的地址变换机构是在分段系统地址变换机构的基础上形成的。因为被访问的段并非全在内存，所以在地址变换后，若发现所要访问的段不在内存分钟，必须先将所缺的段调入内存，并修改段表，然后再利用段表进行地址变换。</li></ul></li></ul></li><li><h3 id="分段的共享与保护"><a href="#分段的共享与保护" class="headerlink" title="分段的共享与保护"></a>分段的共享与保护</h3><ul><li><p>共享段表</p><p>为了实现分段共享，可在系统中配置一张共享段表，所有歌共享段都在共享段表中占有一表项。在表项上记录了共享段的段号、段长、内存始址、状态存在位、外存始址以及共享计数信息。</p><ul><li>共享进程计数count。记录多少进程正在共享该段。系统示范该段时，首先检查count是否为0，为0才可以回收</li><li>存取控制字段。对于一个共享段，应为不同的进程矛不同的存取权限</li><li>段号，对于一个共享段，在不同的进程中可以具有不同的段号，每个进程可用自己进程的段号去访问该共享段。</li></ul></li><li><p>共享段的分配与回收</p><ul><li><p>共享段的分配</p><ul><li>在为共享段分配分配内存时，对第一个请求使用该共享段的进程，由内存分配方法有所不同。在为共享段分配内存时，对第一个请求使用该共享段的进程，由系统为该共享段分配一物理区，再把共享段调入该区，同时将该区的始址填入请求进程的段表的相应项中，还须再共享段表中增加以表项，填写请求使用该共享段的进程名、段号和存取控制等有关数据，把count置为1.</li><li>当又有其他进程需要调用该共享段时，由于该共享段已被调入内存，股此时无须再为该段分配内存，而只需在进程的段表中增加一表项，填写该共享段的物理地址。在共享段的段表中增加一个表项，填上调用进程的进程名、该共享段在本进程中的段号、存取控制等，再自行count=count+1操作，以表明有两个进程共享该段。</li></ul></li><li><p>共享段的回收</p><p>当共享此段的某进程不再需要该段时，应将该段释放，包括撤销在该进程段表中共享段对应的表项，以及执行count=count-1操作。若结果为0，该段由系统管理回收，以及取消在共享段表中该段所对应的表项，表明此时已没有进程使用该段；否则，只是取消调用者进程在共享段表中的有关记录。</p></li></ul></li><li><p>分段保护</p><ul><li><p>越界检查</p></li><li><p>存取控制检查</p><ul><li>只读</li><li>只执行</li><li>读/写</li></ul></li><li><p>环保护机构</p><p>低编号的环具有高优先级</p><ul><li>一个程序可以访问驻留在相同环或较低特权环（外环）的数据</li><li>一个程序可以调用驻留在相同环或高特权环（内环）中的服务</li></ul></li></ul></li></ul></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、虚拟存储器概述&quot;&gt;&lt;a href=&quot;#一、虚拟存储器概述&quot; class=&quot;headerlink&quot; title=&quot;一、虚拟存储器概述&quot;&gt;&lt;/a&gt;一、虚拟存储器概述&lt;/h2&gt;&lt;p&gt;之前的各种存储器管理方式有一个共同的特点，即它们都要求将一个作业全部装入内存后方能运
      
    
    </summary>
    
      <category term="操作系统" scheme="http://wanqbin.xyz/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="操作系统" scheme="http://wanqbin.xyz/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="虚拟存储器" scheme="http://wanqbin.xyz/tags/%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>存储器管理</title>
    <link href="http://wanqbin.xyz/2019/%E5%AD%98%E5%82%A8%E5%99%A8%E7%AE%A1%E7%90%86/"/>
    <id>http://wanqbin.xyz/2019/存储器管理/</id>
    <published>2019-11-18T16:58:00.000Z</published>
    <updated>2019-11-18T16:58:49.897Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、存储器的层次结构"><a href="#一、存储器的层次结构" class="headerlink" title="一、存储器的层次结构"></a>一、存储器的层次结构</h2><ul><li>存储器的多层结构<ul><li>最高层：CPU寄存器</li><li>中间：主存<ul><li>高速缓存</li><li>主存储器</li><li>磁盘缓存</li></ul></li><li>底层：辅存<ul><li>固定磁盘</li><li>可移动存储介质</li></ul></li></ul></li></ul><h2 id="二、连续分配存储管理方式"><a href="#二、连续分配存储管理方式" class="headerlink" title="二、连续分配存储管理方式"></a>二、连续分配存储管理方式</h2><ol><li><p>单一连续分配</p><p>&emsp;&emsp;在单道程序环境下，当时的存储器管理方式是把内存分为系统区和用户区两部分，系统区仅提供给OS使用，它通常是放在内存的低址部分。而在用户区内存中，仅装有一道用户程序，即整个内存的用户空间由该程序独占。这样的存储器分配方式被称为单一连续分配方式。</p></li><li><p>固定分区分配</p><p>&emsp;&emsp;为了能在内存中装入多道程序，且使这些程序之间又不会发生相互干扰，于是将整个用户空间划分为若干个固定大小的区域，使每个分区中只装入一道作业，这样就形成了最早的、也是最简单的一种可运行多道程序的分区式存储管理方式。如果在内存中有四个用户分区，便允许四个程序并发执行。当有一个空闲分区时，便可以再从外存的后备作业队列中选择一个适当大小的作业，装入该分区。当作业结束时，又可再从后备队列中找出另一作业调入该分区。</p></li><li><p>动态分区分配</p><ul><li><p>动态分区分配又称为可变分区分配，它是根据进程的实际需要，动态地为之分配内存空间。</p></li><li><p>动态分区分配中的数据结构</p><ul><li>空闲分区表</li><li>空闲分区链</li></ul></li><li><p>动态分区分配算法</p><p>为把一个新作业装入内存，须按照一定的分配算法，从空闲分区表或空闲分区链中选出一分区分配给该作业。</p></li><li><p>分区分配操作</p><ul><li>分配内存<ul><li>系统应利用某种分配算法，从空闲分区链（表）中找到所需大小的分区。</li></ul></li><li>回收内存<ul><li>当进程运行完毕释放内存时，系统根据回收区的首址，从空闲区链（表）中找到相应的插入点，此时可能出现以下四种情况之一：<ul><li>回收区与插入点的前一个空闲分区$F_1$相邻接。此时应将回收区与插入带来的前一分区合并，不必为回收分区分配新表项，而只修改其前一分区$F_1$的大小</li><li>回收分区与插入点的后一空闲分区$F_2$相邻接。此时也可将两分区合并，形成新的空闲分区，但用回收区的首址作为新空闲区的首址，大小为两者之和。</li><li>回收区同时与插入点的前、后两个分区邻接。此时将三个分区合并，使用$F_1$的表项和$F_1$的首址，取消$F_2$的表项，大小为三者之和。</li><li>回收区既不与$F_1$邻接，又不与$F_2$邻接。这时应为回收区单独建立一个新表项，填写回收区的首址和大小，并根据其首址插入到空闲链中的适当位置。</li></ul></li></ul></li></ul></li></ul></li><li><p>基于顺序搜索的动态分区分配算法</p><ul><li><p>首次适应算法（FF)</p><p>&emsp;&emsp;FF算法要求空闲分区链以地址递增的次序链接。在分配内存时，从链首开始顺序查找，直至找到一个大小能满足要求的空闲分区为止。然后再按照作业的大小，从该分区中划出一块内存空间，分配给请求者，余下的空闲分区仍留在空闲链中。若从链表直至链尾都不能找到一个能满足要求的分区，则表明系统中没有足够大的内存分配给该进程，内存分配失败，返回。</p></li><li><p>循环首次适应算法(NF)</p><p>&emsp;&emsp;为避免低址部分留下许多很小的空闲分区，以减少查找可用空闲分区的开销，循环首次适应算法在为进程分配内存空闲时，不再是每次都从链首开始查找，而是从上次找到的空闲分区的下一个空闲分区开始查找，直至找到一个能满足要求的空闲分区，从中划出一块与请求大小相等的内存空闲分配给作业。</p></li><li><p>最佳适应算法(BF)</p><p>&emsp;&emsp;所谓“最佳”是指，每次为作业分配内存时，总能把满足要求，又是最小的空闲分区分配给作业，避免“大材小用”。为了加速寻找，该算法要求将所有的空闲分区按其容量从小到大的顺序形成一空闲分区链。</p></li><li><p>最坏适应算法(WF)</p><p>&emsp;&emsp;由于最坏适应分配算法选择空闲分区的策略正好与最佳适应算法相反：它在扫描整个空闲分区表或链表时，总是他挑选一个最大的空闲区，从中分割一部分存储空间给作业使用，以至于存储器中缺乏大的空闲分区，故把它称为是最坏适应算法。</p></li></ul></li><li><p>基于索引搜索的动态分区分配算法</p><p>&emsp;&emsp;基于顺序搜索的动态分区分配算法，比较适用于不太大的系统。当系统很大时，系统中的内存分区可能会很多，相应的空闲分区链就可能很长，这时采用顺序搜索分区方法可能会很慢。为了提高搜索空闲分区的速度，在大、中型系统中往往会采用基于索引搜索的动态分区算法。</p><ul><li><p>快速适应算法</p><p>&emsp;&emsp;该算法又称为分类搜索法，是将空闲分区根据其容量大小进行分类，对于每一类具有相同容量的所有空闲分区，单独设立一个空闲分区链表，这样系统中存在多个空闲分区链表。同时，在内存中设立一张管理索引表，其中的每一个索引表项对应了一种空闲分区类型，并记录了该类型空闲分区链表表头的指针。空闲分区的分类是根据进程常用的空间大小进行划分的。</p></li><li><p>伙伴系统</p><p>&emsp;&emsp;该算法规定，无论已分配分区或空闲分区，其大小均为2的k次幂。通常$2^m$是整个可分配内存的大小。假设系统的可利用空间容量为$2^m$个字，则系统开始运行时，整个内存区是一个大小为$2^m$的空闲分区。在系统运行过程中，由于不断地划分，将会形成若干个不连续的空闲分区，将这些空闲分区按分区的大小进行分类。对于具有相同大小的所有空闲分区，单独设立一个空闲分区双向链表，这样，不同大小的空闲分区形成了k个空闲分区链表。</p><p>&emsp;&emsp;当需要为进程分配一个长度为n的存储空间时，首先计算一个i值，使$2^{i-1}$&lt;n&lt;=$2^i$,然后再空闲分区大小为$2^i$的空闲分区链表中查找。若找到，即把该空闲分区分配给进程。否则，表明长度为$2^i$的空闲分区已经耗尽，则在分区大小为$2^{i+1}$的空闲分区链表中寻找。若存在$2^{i+1}$的空闲分区，则把该空闲分区分为相等的两个分区，这两个分区称为一对伙伴，其中的一个分区用于分配，而把另一个加入分区大小为$2^i$的空闲分区链表中。</p><p>&emsp;&emsp;若大小为$2^{i+1}$的空闲分区也不存在，则需要查找大小为$2^{i+2}$的空闲分区，若找到则也对其进行两次分割：第一次，将其分割为大小为$2^{i+1}$的两个分区，一个用于分配，一个加入到大小为$2^{i+1}$的空闲分区链表中；第二次，将第一次用于分配的空闲区分割为$2^i$的两个分区，一个用于分配，另一个加入到大小为$2^i$的空闲链表中。若找不到，则继续查找大小为$2^{i+3}$的空闲分区，依次类推。由此可见，在最坏情况下，可能需要对$2^k$的空闲分区进行k次分割才能得到所需分区。</p><p>&emsp;&emsp;与一次分配可能要进行多次分割一样，一次回收也可能要进行多次合并，如回收大小为$2^i$的空闲分区时，若事先已存在$2^i$的空闲分区，则应将其伙伴分区合并为大小为$2^{i+1}$的空闲分区，若事先已存在$2^{i+1}$的空闲分区，又应继续与其伙伴分区合并为大小为$2^{i+1}$的空闲分区，依次类推。</p></li><li><p>哈希算法</p><p>&emsp;&emsp;哈希算法就是利用哈希快速查找的优点，以及空闲分区在可利用空闲区表中的分布规律，建立哈希函数，构造一张以空闲分区大小为关键字的哈希表，该表的每一表项记录了一个对应的空闲分区链表表头指针。</p><p>&emsp;&emsp;当进行空闲分区分配时，根据所需空闲分区大小，通过哈希函数计算，即得到在哈希表中的位置，从中得到相应的空闲分区链表，实现最佳分配策略。</p></li></ul></li></ol><h2 id="三、对换"><a href="#三、对换" class="headerlink" title="三、对换"></a>三、对换</h2><ol><li><p>对换的类型</p><p>&emsp;&emsp;在每次对换时，都是将一定数量的程序或数据换入或换出内存。根据每次对换时所对换的数量，可以将对换分为如下两类：</p><ul><li>整体对换</li><li>页面（分段）对换</li></ul></li><li><p>对换空间管理的主要目标</p><ul><li><p>对文件区管理的主要目标</p><p>&emsp;&emsp;文件区占用磁盘空间的大部分，用于存放各类文件。由于通常的文件都是较长时间地驻留在外存上，对它访问的频率是较低的，故对文件区管理的主要目标是提高文件存储空间的利用率，然后才是提高对文件的访问速度。因此，对文件区空间的管理采取离散分配方式。</p></li><li><p>对对换空间管理的主要目标</p><p>&emsp;&emsp;对换空间只占用磁盘空间的小部分，用于存放从内存换出的进程。由于这些进程在对换区中驻留的时间是短暂的，而对换操作的频率却较高，故对对换空间管理的主要目标，是提高进程换入和换出的速度，然后才是提高文件存储空间管理的利用率。为此，对对换空间的管理采取连续分配方式，较少考虑外存中的碎片问题。</p></li></ul></li><li><p>对换区空闲盘块管理中的数据结构</p><p>&emsp;&emsp;为了实现对对换区中的空闲盘块的管理，在系统中配置相应的数据结构，用于记录外存对换区中的空闲盘块的使用情况。其数据结构的形式与内存在动态分区分配方式中所用数据结构相似，即同样可以用空闲分区表或空闲分区链。在空闲分区表的每个表目中，应包含两项：对换区的首址及其大小，分别用盘块号和盘快速表示。</p></li><li><p>对换空间的分配与回收</p><ul><li>分配算法可以是首次适应算法、循环首次适应算法、最佳适应算法等</li><li>回收操作分为四种情况：<ul><li>回收分区与插入点的前一空闲分区$F_1$相邻接</li><li>回收分区与插入点的后一个空闲分区$F_2$相邻接</li><li>回收分区同时与插入点的前、后两个分区邻接</li><li>回收分区既不与$F_1$邻接，又不与$F_2$邻接</li></ul></li></ul></li><li><p>进程的换出</p><p>&emsp;&emsp;对换进程在实现进程换出时，是将内存中的某些进程调出至对换区，以便腾出内存空间。换出过程可分为以下两步：</p><ul><li>选择被换出的进程</li><li>进程换出过程<ul><li>申请对换空间，若申请成功，就启动磁盘，将该进程的程序和数据传送到磁盘的对换区上。</li><li>若传送过程未出现错误，便可回收该进程所占用的内存空间，并对该进程的进程控制块和内存分配表等数据结构做相应的修改。</li><li>若此时内存中海油可换出的进程，则继续执行换出过程，直到内存中再无阻塞进程为止。</li></ul></li></ul></li><li><p>进程的换入</p><p>&emsp;&emsp;对换进程将定时执行换入操作，它首先查看PCB集合中所有进程的状态，从中找出“就绪”状态但已换出的进程。当有许多这样的进程时，它将选择其中已换出到磁盘上时间最久的进程作为换入进程，为它申请内存。如果申请成功，可直接将进程从外存调入内存；如果失败，则需先将内存中的某些进程换出，腾出足够的内存空间后，再将进程调入。</p><p>&emsp;&emsp;在对换进程成功地换入一个进程后，若还有可换入的进程，则再继续执行换入换出过程，将其余处于“就绪且换出”状态的进程陆续换入，直到外存中再无“就绪且换出”状态的进程为止，或者已无足够的内存来换入进程，此时对换进程才停止换入。</p></li></ol><h2 id="四、分页存储管理方式"><a href="#四、分页存储管理方式" class="headerlink" title="四、分页存储管理方式"></a>四、分页存储管理方式</h2><ol><li><p>分页存储管理的基本方法</p><ul><li><p>页面和物理块</p><ul><li>页面。分页存储管理将进程的逻辑地址空间分成若干页，并为各页加以编号。相应地，也把内存的物理地址空间分成若干个块，同样也为它们加以编号。在为进程分配内存时，以块为单位，将进程中的若干个页分别装入到多个可以不相邻接的物理块中。由于进程的最后一页经常装不满一块，而形成了不可利用的碎片，称之为“页内碎片”。</li><li>页面大小。页面的大小应选择适中，且页面大小应是2的幂，通常为1KB~8KB。</li></ul></li><li><p>地址结构</p><p>分页地址中的地址结构如下:</p><p>它包含两部分内容：前一部分为页号P，后一部分为位偏移量W，即页内地址。</p></li><li><p>页表</p><ul><li>在分页系统中，允许将进程的各个页离散地存储在内存的任一物理块中，为保证进程仍然能够正确地运行，即能在内存中找到每个页面所对应的物理块，系统又为每个进程建立了一张页面映像表，简称页表。</li></ul></li></ul></li><li><p>地址变换机构</p><p>&emsp;&emsp;为了能将用户空间中的逻辑地址转换为内存空间中的物理地址，在系统中必须设置地址变换机构。该机构的基本任务是实现从逻辑地址到物理地址的转换。由于页内地址和物理地址是一一对应的，因此，地址变换结构的任务实际上只是将逻辑地址中的页号转换为内存中的物理块号。又因为页面映射表的作用就是用于实现从页号到物理块号的变换，因此，地址变换任务是借助页表来完成的。</p></li><li><p>两级页表</p><ul><li>针对难于找到大的连续的内存空间来存放页表的问题，可利用将页表进行分页的方法，使每个页面的大小与内存物理块的大小相同，并为它们进行编号，然后离散地将各个页面分别存放在不同的物理块中。</li><li>同样，也要为离散分配的页表再建立一张页表，称为外层页表，在每个页表项中记录了页表页面的物理块号。</li></ul></li><li><p>反置页表</p><p>&emsp;&emsp;为了减少页表占用的内存空间，引入了反置页表。一般页表的页表项是按页号进行排序的，页表项中的内容是物理块号。而反置页表则是为每个物理块设置一个页表项，并将它们按物理块的编号排序，其中的内容则是页号和其所隶属进程的标识符。</p></li></ol><h2 id="五、分段存储管理方式"><a href="#五、分段存储管理方式" class="headerlink" title="五、分段存储管理方式"></a>五、分段存储管理方式</h2><ol><li><p>分段系统的基本原理</p><p>&emsp;&emsp;在分段存储管理方式中，作业的地址空间被划分为若干个段，每个段定义了一组逻辑信息。为了简单起见，通常可用一个段号来代替段名，每个段都从0开始编址，并采用一段连续的地址空间。段的长度由相应的逻辑信息组的长度决定，因此各段的长度并不相等。整个作业的地址空间由于被分成多个段，所以呈现出二维特性，即每个段既包含了一部分地址空间，又表示了逻辑关系。其逻辑地址由段号和段内地址组成。</p></li></ol><h2 id="六、段页式存储管理方式"><a href="#六、段页式存储管理方式" class="headerlink" title="六、段页式存储管理方式"></a>六、段页式存储管理方式</h2><ol><li><p>基本原理</p><p>&emsp;&emsp;段页式系统的基本原理是分段和分页原理的结合，即先将用户程序分成若干个段，再把每个段分成若干个页，并为每一个段赋予一个段名。在段页式系统中，其地址结构由段号、段内页号及页内地址三部分组成。</p></li><li><p>地址变换过程</p><p>&emsp;&emsp;在段页式系统中，为了便于实现地址变换，需配置一个段表寄存器，其中存放段表始址和段长TL。进行地址变换时，首先利用段号S，将它与段长TL进行比较。若S&lt;TL,表示未越界，于是利用段表始址和段号来求出该段所对应的段表项在段表中的位置，从中得到该段的页表始址，并利用逻辑地址中的段内页号P来获得对应页的页表项位置，从中读出该页所在的物理块号b，再利用块号b和页内地址来构成物理地址。</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、存储器的层次结构&quot;&gt;&lt;a href=&quot;#一、存储器的层次结构&quot; class=&quot;headerlink&quot; title=&quot;一、存储器的层次结构&quot;&gt;&lt;/a&gt;一、存储器的层次结构&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;存储器的多层结构&lt;ul&gt;
&lt;li&gt;最高层：CPU寄存器&lt;/li&gt;
      
    
    </summary>
    
      <category term="操作系统" scheme="http://wanqbin.xyz/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="存储器管理" scheme="http://wanqbin.xyz/tags/%E5%AD%98%E5%82%A8%E5%99%A8%E7%AE%A1%E7%90%86/"/>
    
      <category term="分段存储" scheme="http://wanqbin.xyz/tags/%E5%88%86%E6%AE%B5%E5%AD%98%E5%82%A8/"/>
    
      <category term="分页存储" scheme="http://wanqbin.xyz/tags/%E5%88%86%E9%A1%B5%E5%AD%98%E5%82%A8/"/>
    
      <category term="段页式存储" scheme="http://wanqbin.xyz/tags/%E6%AE%B5%E9%A1%B5%E5%BC%8F%E5%AD%98%E5%82%A8/"/>
    
  </entry>
  
  <entry>
    <title>死锁</title>
    <link href="http://wanqbin.xyz/2019/%E6%AD%BB%E9%94%81/"/>
    <id>http://wanqbin.xyz/2019/死锁/</id>
    <published>2019-11-18T16:57:00.000Z</published>
    <updated>2019-11-18T16:58:00.437Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、资源问题"><a href="#一、资源问题" class="headerlink" title="一、资源问题"></a>一、资源问题</h2><ul><li><p>可重用性资源和消耗性资源</p><ul><li><p>可重用性资源</p><p>一种可供用户重复使用多次的资源</p></li><li><p>消耗性资源</p><p>又称为临时性资源，它是在进程运行期间，由进程动态地创建和消耗的。</p></li></ul></li><li><p>可抢占性资源和不可抢占资源</p><ul><li><p>可抢占性资源</p><p>是指某进程在获得这类资源后，该资源可以再被其他进程或系统抢占。</p></li><li><p>不可抢占性资源</p><p>一旦系统把某资源分配给进程后，就不能将它强行收回，只能在进程用完后自行释放。</p></li></ul></li></ul><h2 id="二、计算机系统中的死锁"><a href="#二、计算机系统中的死锁" class="headerlink" title="二、计算机系统中的死锁"></a>二、计算机系统中的死锁</h2><ul><li>竞争不可抢占性资源引起死锁</li><li>竞争可消耗性资源引起死锁</li><li>进程推进顺序不当引起死锁</li></ul><h2 id="三、死锁的定义、必要条件和处理方法"><a href="#三、死锁的定义、必要条件和处理方法" class="headerlink" title="三、死锁的定义、必要条件和处理方法"></a>三、死锁的定义、必要条件和处理方法</h2><ul><li><p>死锁的定义</p><p>如果一组进程中的每一个进程都在等待仅由该组进程中的其他进程才能引发的事件，那么这组进程是死锁的。</p></li><li><p>产生死锁的必要条件</p><ul><li>互斥条件</li><li>请求和保持条件</li><li>不可抢占条件</li><li>循环等待条件</li></ul></li><li><p>处理死锁的方法</p><ul><li>预防死锁</li><li>避免死锁</li><li>检测死锁</li><li>解除死锁</li></ul></li></ul><h2 id="四、预防死锁"><a href="#四、预防死锁" class="headerlink" title="四、预防死锁"></a>四、预防死锁</h2><ul><li>破坏“请求和保持条件”<ul><li>所有进程在开始运行之前，必须一次性地申请其在整个运行过程中所需的全部资源</li><li>允许一个进程只获得运行初期所需的全部资源后，便开始运行</li></ul></li><li>破坏“不可抢占条件”<ul><li>当一个已经保持了某些不可被抢占资源的进程，提出新的资源请求而不能得到满足时，它必须释放已经保持的所有资源，待以后需要时再从新申请。</li></ul></li><li>破坏“循环等待条件”<ul><li>对系统所有资源类型进行线性排序，并赋予不同的序号。规定每个进程必须按序号递增的顺序请求资源。</li></ul></li></ul><h2 id="五、避免死锁"><a href="#五、避免死锁" class="headerlink" title="五、避免死锁"></a>五、避免死锁</h2><ul><li><p>系统安全状态</p><p>&emsp;&emsp;在死锁避免方法中，把系统的状态分为安全状态和不安全状态。当系统处于安全状态时，可避免发生死锁。反之，当系统处于不安全状态时，则可能进入到死锁状态。</p><ul><li><p>安全状态</p><p>&emsp;&emsp;在该方法中，允许进程动态地申请资源，但系统在进行资源分配之前，应先计算此次资源分配的安全性。若此次分配不会导致系统进入不安全状态，才可将资源分配给进程，否则，令进程等待。</p><p>&emsp;&emsp;所谓安全状态，是指系统能按某种进程推进顺序为每个进程$P_i$分配其所需资源，直至满足每个进程对资源的最大需求，使每个进程都可顺利地完成，此时称($P_1$、$P_2$、……、$P_n$)为安全序列。</p><p>&emsp;&emsp;如果系统无法找到这样一个安全序列，则称系统处于不安全状态。虽然并非所有不安全状态都必然会转为死锁状态，但当系统进入不安全状态后，就有可能进入死锁状态。反之，只要系统处于安全状态，系统便不会进入死锁状态。因此，避免死锁的实质在于，系统在进行资源分配时，应使系统不进入不安全状态。</p></li></ul></li><li><p>利用银行家算法避免死锁</p><ul><li>为实现银行家算法，每一个新进程在进入系统同时，它必须申明在运行过程中，可能需要每种资源类型的最大单元数目，其数目不应超过系统所拥有的资源总量。</li><li>当进程请求一组资源时，系统必须首先确定是否有足够的资源分配给该进程。若有，再进一步计算在将这些资源分配给进程后，是否会使系统处于不安全状态。如果不返回，才将资源分配给它，否则让进程等待。</li></ul></li></ul><h2 id="六、死锁的检测"><a href="#六、死锁的检测" class="headerlink" title="六、死锁的检测"></a>六、死锁的检测</h2><p>&emsp;&emsp;为了能对系统中是否已经发生了死锁进行检测，在系统中必须：①保存有关资源的请求和分配信息；②提供一种算法，它利用这些信息来检测系统是否已进入死锁状态。</p><ul><li>资源分配图</li><li>死锁定理<ul><li>S为死锁状态的充分条件为：当且仅当S状态的资源分配图是不可完全简化的。该充分条件被称为死锁定理。</li></ul></li></ul><h2 id="七、死锁的解除"><a href="#七、死锁的解除" class="headerlink" title="七、死锁的解除"></a>七、死锁的解除</h2><p>常采用解决死锁的两种方法是：</p><ul><li>抢占资源。从一个或多个进程中抢占足够数量的资源，分配给死锁进程，以解除死锁状态。</li><li>终止（或撤销）进程。终止（或撤销）系统中的一个或多个死锁进程，直至打破循环环路，使系统从死锁状态解脱出来。</li></ul><ol><li><p>终止进程的方法</p><ul><li><p>终止所有死锁进程</p><p>终止所有的死锁进程，死锁自然也就解除了，但所付出的代价可能会很大。</p></li><li><p>逐个终止进程</p><p>按某种顺序，逐个地终止进程，直至有足够的资源，以打破循环等待，把系统同从死锁状态解脱出来为止。</p><p>选择被终止进程时应考虑的若干因素：</p><ul><li>进程的优先级</li><li>进程已执行了多少时间，还需要多少时间方能完成？</li><li>进程在运行中已经使用资源的多少，以后还需要多少资源？</li><li>进程的性质是交互式的还是批处理式的？</li></ul></li></ul></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、资源问题&quot;&gt;&lt;a href=&quot;#一、资源问题&quot; class=&quot;headerlink&quot; title=&quot;一、资源问题&quot;&gt;&lt;/a&gt;一、资源问题&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;可重用性资源和消耗性资源&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;可重用性资源&lt;/p&gt;
&lt;p&gt;一种
      
    
    </summary>
    
      <category term="操作系统" scheme="http://wanqbin.xyz/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="操作系统" scheme="http://wanqbin.xyz/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="死锁" scheme="http://wanqbin.xyz/tags/%E6%AD%BB%E9%94%81/"/>
    
  </entry>
  
  <entry>
    <title>处理机调度</title>
    <link href="http://wanqbin.xyz/2019/%E5%A4%84%E7%90%86%E6%9C%BA%E8%B0%83%E5%BA%A6/"/>
    <id>http://wanqbin.xyz/2019/处理机调度/</id>
    <published>2019-11-18T16:56:00.000Z</published>
    <updated>2019-11-18T16:57:19.022Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、处理机调度的层次和调度算法的目标"><a href="#一、处理机调度的层次和调度算法的目标" class="headerlink" title="一、处理机调度的层次和调度算法的目标"></a>一、处理机调度的层次和调度算法的目标</h2><p>&emsp;在多道程序系统中，调度的实质是一种资源分配，处理机调度是对处理机资源进行分配。处理机调度算法实质根据处理机分配策略所规定的处理机分配算法。在多道批处理系统中，一个作业从提交到获得处理机执行，直至作业运行完毕，可能需要经历多级处理机调度。</p><ol><li>处理机调度的层次<ul><li>高级调度：又称长程调度或作业调度，调度对象是作业</li><li>低级调度：又称进程调度或短程调度，调度对象是进程（或内核级线程）</li><li>中级调度：又称内存调度</li></ul></li><li>处理机调度算法的目标<ul><li>资源利用率</li><li>公平性</li><li>平衡性</li><li>策略强制执行</li></ul></li></ol><h2 id="二、作业与作业调度"><a href="#二、作业与作业调度" class="headerlink" title="二、作业与作业调度"></a>二、作业与作业调度</h2><p>&emsp;&emsp;在多道批处理系统中，作业是用户提交给系统的一项相对独立的工作。操作员把用户提交的作业通过相应的输入设备到磁盘存储器，并保存在一个后备作业队列中。再由作业调度程序将其从外存调入内存。</p><ol><li><p>批处理系统中的作业</p><ul><li>在批处理系统中，是以作业为基本单位从外存调入内存的</li><li><p>作业控制块JCB：包含的内容有，作业标识、用户名称、用户账号、作业类型、作业状态、调度信息、资源需求、资源使用情况等。</p></li><li><p>作业运行的三个阶段和三种状态</p><ul><li>收容阶段，对应后备状态</li><li>运行阶段，对应运行状态</li><li>完成阶段，对应完成状态</li></ul></li></ul></li><li><p>先来先服务调度算法（FCFS)</p><ul><li>系统按照作业到达的先后次序来进行调度，或者说它是优先考虑在系统中等待时间最长的作业，而不管作业所需执行时间的长短，从后备作业队列中选择几个最先进入该队列的作业，将它们调入内存，为它们分配资源和创建进程。然后把它放入就绪队列。</li></ul></li><li><p>短作业优先调度算法（SJF）</p><ul><li>由于在实际情况下，短作业占有很大比例，为了能使它们能比长作业优先执行，而产生了短作业优先调度算法。</li><li>SJF算法是以作业的长短来计算优先级，作业越短，其优先级越高。</li></ul></li><li><p>优先级调度算法（PSA）</p><ul><li>基于作业的紧迫程度，由外部赋予作业相应的优先级。调度算法是根据该优先级进行调度的。</li></ul></li><li><p>高响应比优先调度算法（HRRN）</p><ul><li><p>为每个作业引入一个动态优先级，即优先级是可以改变的，令它随等待时间延长而增加，这将使长作业的优先级在等待期间不断地增加，等到足够的时候后，必然有机会获得处理机。该优先级的变化规律可描述为：</p><p>优先权=$\frac{等待时间+要求服务时间}{要求服务时间}$</p></li><li><p>由于等待时间与服务时间之和就是系统对该作业的响应时间，故该优先级又相当于响应比$R_p$。据此，优先又可表示为：<br>$R_P$=$\frac{等待时间+要求服务时间}{要求服务时间}$=$\frac{响应时间}{要求服务时间}$</p></li></ul></li></ol><h2 id="三、进程调度"><a href="#三、进程调度" class="headerlink" title="三、进程调度"></a>三、进程调度</h2><ol><li><p>进程调度的任务</p><ul><li>保存处理机的现场信息</li><li>按某种算法选取进程</li><li>把处理机分配给进程</li></ul></li><li><p>进程调度的机制</p><ul><li>排队器</li><li>分派器</li><li>上下文切换器</li></ul></li><li><p>进程调度的方式</p><ul><li>非抢占方式</li><li>抢占方式<ul><li>优先权原则</li><li>短进程优先原则</li><li>时间片原则</li></ul></li></ul></li><li><p>轮转调度算法（RR）</p><p>&emsp;&emsp;在分时系统中，最简单的也是较常用的是基于时间片的轮转调度算法。该算法采取了非常公平的处理机分配方式，即让就绪队列上的每个进程每次仅运行一个时间片。如果就绪队列上有n个进程，则每个进程每次大约都可以获得$\frac{1}{n}$的处理机时间。</p><ul><li>轮转法的基本原理<ul><li>系统根据FCFS策略，将所有的就绪进程排成一个就绪队列，并可设置每个一定时间间隔即产生一次中断，激活系统中的进程调度程序，完成一次调度，将CPU分配给队首进程，令其自信。当该进程的时间片耗尽或运行完毕时，系统再次将CPU分配给新的队首进程。由此，可保证就绪队列中的所有进程在一个确定的时间段内，都能获得一次CPU执行。</li></ul></li><li>切换时机<ul><li>若一个时间片尚未用完，正在运行的进程便已完成，就立即激活调度程序，将它从就绪队列中删除，再调度就绪队列中队首的进程运行，并启动一个新的时间片。</li><li>在一个时间片用完时，计时器中断处理程序被激活。如果进程尚未运行完毕，调度程序将把它送往就绪队列的末尾。</li></ul></li><li>时间片大小的确定<ul><li>时间片的大小略大于一次典型的交互所需要的时间，使大多数交互式进程能在一个时间片内完成，从而获得很小的响应时间。</li></ul></li></ul></li><li><p>优先级调度算法</p><ul><li>优先级调度算法的类型<ul><li>非抢占式优先级调度算法</li><li>抢占式优先级调度算法</li></ul></li><li>优先级的类型<ul><li>静态优先级<ul><li>进程类型</li><li>进程对资源的需求</li><li>用户要求</li></ul></li><li>动态优先级</li></ul></li></ul></li><li><p>多队列调度算法</p><ul><li>将系统中的进程就绪队列从一个拆分为若干个，将不同类型或性质的进程固定分配在不同的就绪队列，不同的就绪队列采用不同的调度算法，一个就绪队列中的进程可以设置不同的优先级，不同的就绪队列本身也可以设置不同的优先级。</li></ul></li><li><p>多级反馈队列调度算法</p><ul><li>设置多个就绪队列。为每个队列赋予不同的优先级，第一个队列的优先级最高，依次递减。优先级越高，时间片越小。</li><li>每个队列采用FCFS算法</li><li>按队列优先级调度</li></ul></li><li><p>基于公平原则的调度算法</p><ul><li><p>保证调度算法</p><p>如果系统中有n个相同类型的进程同时运行，为公平起见，须保证每个进程都获得相同的处理机时间1/n。</p></li><li><p>公平分享调度算法</p><p>在该算法中，调度的公平性针对用户而言，使所有用户能获得相同的处理机时间，或所要求的时间比例。</p></li></ul></li></ol><h2 id="四、实时调度"><a href="#四、实时调度" class="headerlink" title="四、实时调度"></a>四、实时调度</h2><ol><li><p>实现实时调度的基本条件</p><ul><li>提供必要的信息<ul><li>就绪时间</li><li>开始截止时间和完成截止时间</li><li>处理时间</li><li>资源要求</li><li>优先级</li></ul></li><li>系统处理能力强</li><li>采用抢占式调度机制</li><li>具有快速切换机制<ul><li>对中断的快速响应能力</li><li>快速的任务分派能力</li></ul></li></ul></li><li><p>实时调度算法的分类</p><ul><li>非抢占式调度算法<ul><li>非抢占式轮转调度算法</li><li>非抢占式优先调度算法</li></ul></li><li>抢占式调度算法<ul><li>基于时钟中断的抢占式优先级调度算法</li><li>立即抢占的优先级调度算法</li></ul></li></ul></li><li><p>最早截止时间优先EDF算法</p><ul><li>该算法根据任务的截止时间确定任务的优先级，任务的截止时间越早，其优先级越高，具有最早截止时间的任务排在队列的队首。</li></ul></li><li><p>最低松弛度优先LLF算法</p><ul><li>该算法在确定任务的优先级时，根据的是任务的紧急（或松弛）程度。任务紧急程度越高，赋予该任务的优先级就越高，以使之优先执行。</li></ul></li><li><p>优先级倒置</p><ul><li><p>优先级倒置的形成</p><p>&emsp;&emsp;当前OS广泛采用优先级调度算法和抢占方式，然而在系统中存在着影响进程运行的资源而产生“优先级倒置”现象，即高优先级进程（或线程）被低优先级进程（或线程）延迟或阻塞。</p><p>&emsp;&emsp;例如，假如有三个完全独立的进程$P_1$、$P_2$和$P_3$，$P_1$的优先级最高，$P_2$次之，$P_3$最低。$P_1$和$P_3$通过共享一个临界资源进行交互。假如$P_3$最先执行，进入到临界区，在时刻a，当$P_2$就绪时，因为它比$P_3$的优先级高，$P_2$抢占了$P_3$的处理机而运行，在时刻b，$P_1$就绪，因为它比$P_2$的优先级高，$P_1$抢占了$P_2$的处理机而运行。在时刻c，$P_1$试图进入临界区，但因为相关的临界资源已被$P_3$占用，故$P_1$将被阻塞。由$P_2$继续运行，直到时刻d运行结束。然后由$P_3$接着运行，到时刻e时$P_3$退出临界区，并唤醒$P_1$。因为它比$P_3$的优先级高，故它抢占了$P_3$的处理机而运行。</p></li><li><p>优先级倒置的解决方法</p><ul><li>一种简单的解决办法是规定：加入进程$P_3$在进入临界区后$P_3$所占用的处理机就不允许被抢占。</li><li>一种比较实用的方法是在建立动态优先级继承基础上的。该方法规定，当高优先级进程$P_1$要进入临界区，去使用临界资源R，如果已有一个低优先级进程$P_3$正在使用该资源，此时一方面$P_1$被阻塞，另一方面由$P_3$继承$P_1$的优先级，并一直保持到$P_3$退出临界区。</li></ul></li></ul></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、处理机调度的层次和调度算法的目标&quot;&gt;&lt;a href=&quot;#一、处理机调度的层次和调度算法的目标&quot; class=&quot;headerlink&quot; title=&quot;一、处理机调度的层次和调度算法的目标&quot;&gt;&lt;/a&gt;一、处理机调度的层次和调度算法的目标&lt;/h2&gt;&lt;p&gt;&amp;emsp;
      
    
    </summary>
    
      <category term="操作系统" scheme="http://wanqbin.xyz/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="进程调度" scheme="http://wanqbin.xyz/tags/%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6/"/>
    
      <category term="处理机调度" scheme="http://wanqbin.xyz/tags/%E5%A4%84%E7%90%86%E6%9C%BA%E8%B0%83%E5%BA%A6/"/>
    
  </entry>
  
  <entry>
    <title>进程相关总结</title>
    <link href="http://wanqbin.xyz/2019/%E8%BF%9B%E7%A8%8B%E7%9B%B8%E5%85%B3%E6%80%BB%E7%BB%93/"/>
    <id>http://wanqbin.xyz/2019/进程相关总结/</id>
    <published>2019-11-18T16:55:00.000Z</published>
    <updated>2019-11-18T16:55:57.877Z</updated>
    
    <content type="html"><![CDATA[<p>程序顺序执行的特征：</p><ul><li>顺序性</li><li>封闭性</li><li>可再现性</li></ul><p>程序并发执行的特征：</p><ul><li>间断性</li><li>失去封闭性</li><li>不可再现性</li></ul><h2 id="一、进程的描述"><a href="#一、进程的描述" class="headerlink" title="一、进程的描述"></a>一、进程的描述</h2><ol><li><p>进程的定义：进程是进程实体的运行过程，是系统进行资源分配和调度的一个独立单位。</p></li><li><p>进程的特征：</p><ul><li>动态性</li><li>并发性</li><li>独立性</li><li>异步性</li></ul></li><li><p>进程的三种基本状态：</p><ul><li>就绪状态</li><li>执行状态</li><li>阻塞状态</li></ul></li><li><p>进程控制块PCB：PCB作为进程实体的一部分，记录了操作系统所需的，用于描述进程的当前情况以及管理进程运行的全部信息，是操作系统中最重要的记录型数据结构。</p></li><li><p>PCB的作用是使一个在多道程序环境下不能独立运行的程序（含数据）成为一个能独立运行的基本单位，一个能与其他进程并发执行的过程。</p><ul><li>作为独立运行基本单位的标志</li><li>能实现间断性运行方式</li><li>提供进程管理所需要的信息</li><li>提供进程调度所需要的信息</li><li>实现与其他进程的同步与通信</li></ul></li><li><p>PCB中的信息：</p><ul><li>进程描述符</li><li>处理机状态</li><li>进程调度信息</li><li>进程控制信息</li></ul></li></ol><h2 id="一、进程控制"><a href="#一、进程控制" class="headerlink" title="一、进程控制"></a>一、进程控制</h2><p>&emsp;&emsp;进程控制是进程管理中最基本的功能，主要包括创建新进程、终止已完成的进程、将因发生异常情况而无法继续运行的进程置于阻塞状态、负责进程运行中的状态转换等功能。</p><ol><li>操作系统内核的功能：<ul><li>支撑功能<ul><li>中断处理</li><li>时钟管理</li><li>原语操作</li></ul></li><li>资源管理功能<ul><li>进程管理</li><li>存储器管理</li><li>设备管理</li></ul></li></ul></li><li>引起创建进程的事件<ul><li>用户登录</li><li>作业调度</li><li>提供服务</li><li>应用请求</li></ul></li><li>进程的创建<ul><li>申请空白PCB</li><li>为新进程分配其运行所需的资源</li><li>初始化进程控制块PCB</li><li>如果进程就绪队列能够接纳新进程，便将新进程插入就绪队列</li></ul></li><li>引起进程终止的事件<ul><li>正常结束</li><li>异常结束<ul><li>越界错</li><li>保护错</li><li>非法指令</li><li>特权指令错</li><li>运行超时</li><li>等待超时</li><li>算术运算错</li></ul></li><li>外界干预<ul><li>操作员或操作系统干预</li><li>父进程请求</li><li>父进程终止</li></ul></li></ul></li><li>进程的终止过程<ul><li>根据被终止进程的标识符，从PCB集合中检索出该进程的PCB，从中读出该进程的状态</li><li>若被终止进程正处于执行状态，应立即终止该进程的执行，并置调度标志为真，用于指示该进程被终止后应重新进行调度</li><li>若该进程还有子孙进程，还应将其所有子孙进程也都予以终止，以防它们成为不可控进程</li><li>将被终止进程所拥有的全部资源或者归还给其父进程，或者归还给系统</li><li>将被终止进程从所在队列中移出，等待其他程序来搜集信息</li></ul></li><li>引起进程阻塞和唤醒的事件<ul><li>向系统请求共享资源失败</li><li>等待某种操作的完成</li><li>新数据尚未到达</li><li>等待新任务的到达</li></ul></li></ol><h2 id="二、进程同步"><a href="#二、进程同步" class="headerlink" title="二、进程同步"></a>二、进程同步</h2><ul><li><p>临界区</p><p>&emsp;&emsp;通过对多线程的插混行化来访问公共资源或1一段代码，速度快，适合控制数据访问。</p><ul><li>优点：保证在某一时刻只有一个线程能访问数据的简便方法</li><li>缺点：虽然临界区同步速度很快，但却只能用来同步本进程内的线程，而不可用来同步多个进程中的线程</li></ul></li><li><p>互斥量</p><p>&emsp;&emsp;为协调共同对一个共享资源的单独访问而设计的。互斥量和临界区很相似，比临界区复杂，互斥对象只有一个，只有拥有互斥对象的线程才具有访问资源的权限</p><ul><li>优点：使用互斥不仅仅能够在同一应用程序不同线程中实现资源的安全共享，而且可以在不同应用程序的线程之间实现对资源的安全共享</li><li>缺点：<ul><li>互斥量是可以命名的，也就是说它可以跨越进程使用，所以创建互斥量需要的资源更多，所以如果只为了在进程内部使用的话，使用临界区会带来速度上的优势并能够减少资源占用量，因为互斥量是跨继承的互斥量一旦被创建，就可以通过名字打开它</li><li>通过互斥量可以指定资源被独占的方式使用，但如果有下面一种情况通过互斥量就无法处理。比如现在一位用户购买了一份三个并发访问许可的数据库系统，可以根据用户购买1的访问许可数量来决定有多少个线程/进程能同时进行数据库操作，这时如果利用互斥量就没办法完成这个要求，信号量对象可以说是一种资源计数器</li></ul></li></ul></li><li><p>信号量</p><p>&emsp;&emsp;为控制一个具有有限数量用户资源而设计。它允许多个线程在同一时刻访问同一资源，但是需要限制在同一时刻访问此资源的最大线程数目。</p><ul><li>优点：适用于对Socket程序中线程的同步。</li><li>缺点：<ul><li>信号量机制必须有公共内存，不能用于分布式操作系统，这是它最大的弱点</li><li>信号量机制功能强大，但使用时对信号量的操作分散，而且难以控制，读写和维护都很困难，加重了程序员的编码负担</li><li>核心操作P-V分散在各用户程序的代码中，不易控制和管理，一旦错误，后果严重，且不易发现和纠正。</li></ul></li></ul></li><li><p>事件</p><p>&emsp;&emsp;用来通知线程有一些事件已发生，从而启动后继任务的开始。</p><ul><li><p>优点：</p><p>事件对象通过通知操作的方式来保持线程的同步，并且可以实现不同进程中的线程同步操作。</p></li></ul></li></ul><h2 id="三、进程通信"><a href="#三、进程通信" class="headerlink" title="三、进程通信"></a>三、进程通信</h2><p>&emsp;&emsp;进程通信是指进程之间的信息交换。由于进程的互斥与同步，需要在进程交换一定的信息，故不少学者将它们也归为进程通信，但只能把它们称为低级进程通信。以信号量机制为例，它们低级的原因是：</p><ul><li>效率低</li><li>通信对用户不透明</li></ul><p>&emsp;&emsp;在进程之间要传送大量数据时，应当利用OS提供的高级通信工具，该工具最主要的特点是：</p><ul><li>使用方便</li><li>高效地传送大量数据</li></ul><p>进程通信的类型：</p><ul><li>共享存储器系统：相互通信的进程共享某些数据结构或共享存储区，进程之间能够通过这些空间进行通信。<ul><li>基于共享数据结构的通信方式</li><li>基于共享存储区的通信方式</li></ul></li><li>管道通信系统：所谓“管道”是指用于连接一个读进程和一个写进程以实现它们之间通信的一个共享文件，又名<code>pipe</code>文件。<ul><li>管道机制必须提供一下三方面的协调能力：<ul><li>互斥</li><li>同步</li><li>确定对方是否存在，只有确定了对方已存在时才能进行通信</li></ul></li></ul></li><li>消息传递系统：在该机制中，进程不必借助任何共享存储区或数据结构，而是以格式化的消息为单位，将通信的数据封装在消息中，并利用操作系统提供的一组通信命令，在进程间进行消息传递，完成进程间的数据交换。<ul><li>直接通信方式：是指发送进程利用OS所提供的原语，直接把消息发送给目标进程</li><li>间接通信方式：是指发送和接收进程，都通过共享中间实体的方式进行消息的发送和接收，完成进程间的通信</li></ul></li><li>客户机—服务器系统<ul><li>套接字</li><li>远程过程调用</li><li>远程方法调用</li></ul></li></ul><h2 id="四、线程"><a href="#四、线程" class="headerlink" title="四、线程"></a>四、线程</h2><p>&emsp;&emsp;如果说，在OS中引入进程的目的是为了使多个程序能并发执行，以提高资源利用率和系统吞吐量，那么，在操作系统中再引入线程，则是为了减少程序在并发执行时所付出的时空开销，使OS具有更好的并发性。</p><ol><li><p>线程运行的三种基本状态</p><ul><li>执行状态</li><li>就绪状态</li><li>阻塞状态</li></ul></li><li><p>线程控制块TCB：如同每个进程有一个进程控制块一样，系统也为每个线程配置了一个线程控制块TCB，将用于控制和管理线程的信息记录在线程控制块中。</p><ul><li>线程标识符</li><li>一组寄存器</li><li>线程运行状态</li><li>优先级</li><li>线程专有存储区</li><li>信号屏蔽</li><li>堆栈指针</li></ul></li><li><p>多线程OS中的进程属性</p><p>&emsp;&emsp;通常在多线程OS中的进程都包含了多个线程，并为它们提供资源。OS支持在一个进程中的多个线程能并发执行，但此时的进程就不再作为一个执行的实体。多线程OS中的进程有以下属性：</p><ul><li>进程是一个可拥有资源的基本单位</li><li>多个线程可并发执行</li><li>进程已不是可执行的实体</li></ul></li><li><p>线程的实现方式</p><ul><li><p>内核支持线程KST(Kernel Support Threads)</p><ul><li><p>优点：</p><ul><li>在多处理器系统中，内核能够同时调度同一进程中的多个线程并发执行</li><li>如果进程中的一个线程被阻塞了，内核可以调度该进程中的其他线程占有处理器运行，也可以运行其他进程中的线程</li><li>内核支持线程具有很小的数据结构和堆栈，线程的切换比较快，切换开销小</li><li>内核本身也可以采用多线程技术，可以提高系统的执行速度和效率</li></ul></li><li><p>缺点：</p><p>对于用户的线程切换而言，其模式切换的开销较大，在同一个进程中，从一个线程切换到另一个线程时，需要从用户态转到核心态进行，这是因为用户进程的线程在用户态运行，而线程调度和管理是在内核实现的，系统开销比较大。</p></li></ul></li><li><p>用户级线程ULT(User Level Threads)</p><ul><li>优点：<ul><li>线程切换不需要转换到内核空间</li><li>调度算法可以是进程专用的</li><li>用户级线程的实现与OS平台无关</li></ul></li><li>缺点：<ul><li>系统调用的阻塞问题</li><li>在单纯的用户级线程实现方式中，多线程应用不能利用多处理机进行多重处理的优点，内核每次分配给一个进程的仅有一个CPU，因此，进程中仅有一个线程能执行，在该线程放弃CPU之前，其他线程只能等待</li></ul></li></ul></li></ul></li><li><p>线程的创建和终止</p><ul><li><p>线程的创建</p><p>&emsp;&emsp;应用程序在启动时，通常仅有一个线程在执行，人们把线程称为“初始化线程”，它的主要功能是用于创建新进程。在创建新进程时，需要利用一个线程创建函数，并提供相应的参数，如指向线程主程序的入口指针、堆栈的大小，以及用于调度的优先级等。在线程的创建函数执行完后，将返回一个线程标识符供以后使用。</p></li><li><p>线程的终止</p><p>&emsp;&emsp;当一个线程完成了自己的任务后，或是线程在运行中出现异常情况而须被强行终止时，由终止线程通过调用相应的函数来对它执行终止操作。但有些线程，它们一旦被建立起来之后，便一直运行下去而不被终止。在大多数的OS中，线程被中止后并不立即释放它所占有的资源，只有当进程中的其他线程执行了分离函数后，被终止的线程才与资源分离，此时的资源才能被其他线程利用。</p><p>&emsp;&emsp;虽已被终止但尚未释放资源的线程仍可以被需要它的线程所调用，以使被终止线程重新恢复运行。为此，调用线程须调用一条被称为“等待线程终止”的连接命令来与该线程进行连接。如果在一个调用者线程调用“等待线程终止”的连接命令，试图与指定线程相连接时，若指定线程尚未被终止，则调用连接命令的线程将会阻塞，直至指定线程被终止后，才能实现它与调用者线程的连接并继续执行；若指定线程已被终止，则调用者线程不会被阻塞而是继续执行。</p></li></ul></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;程序顺序执行的特征：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;顺序性&lt;/li&gt;
&lt;li&gt;封闭性&lt;/li&gt;
&lt;li&gt;可再现性&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;程序并发执行的特征：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;间断性&lt;/li&gt;
&lt;li&gt;失去封闭性&lt;/li&gt;
&lt;li&gt;不可再现性&lt;/li&gt;
&lt;/ul&gt;
      
    
    </summary>
    
      <category term="操作系统" scheme="http://wanqbin.xyz/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="操作系统" scheme="http://wanqbin.xyz/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="进程" scheme="http://wanqbin.xyz/tags/%E8%BF%9B%E7%A8%8B/"/>
    
  </entry>
  
</feed>

<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[软件需求分析]]></title>
    <url>%2F2019%2F06%2F15%2F%E8%BD%AF%E4%BB%B6%E9%9C%80%E6%B1%82%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[写在前面&emsp;需求分析的输入是软件的《合同》或《立项建议书》，以及对用户现场的调研、分析和确认，输出是《用户需求报告》。 一、需求分析是什么？&emsp;在对需求分析进行了解之前，得知道需求分析是什么。 &emsp;需求分析的定义如下： 用户解决问题或达到目标所需的条件或能力 系统或系统部件要满足合同、标准、规范或其他正式文档规定所需具有的条件或能力 一种反映1或2所描述的条件或能力的文档说明 &emsp;我对需求分析的定义时理解是，需求分析中的文档说明起到了至关重要的作用。 &emsp;当然对于一个软件系统来说，前期的需求分析是十分重要的，这几乎可以决定软件系统开发的成败。 二、需求获取的三原则&emsp;所谓需求获取，就是开发者与用户共同提取并共同确认需求。“划分、抽象、投影”是需求获取的三要素。 划分，就是捕获问题空间的“整体/部分”关系。 抽象，就是捕获问题空间的“一般/特殊”或“一般/特例”关系。 投影，就是捕获问题空间的多维”视图“。 &emsp;我对这三原则的理解可能欠妥，但这是我在学习过程中的一些想法。首先，划分，就是将整个系统进行划分，将复杂的系统划分为小系统，这样不仅可以简化系统分析的难度，同时，由于对其进行了划分，所以在需求分析的时候，能够对系统的需求细节进行完善。 &emsp;其次是抽象，对于一个软件系统，能够实现功能的复用性是再好不过了，那么就需要对需求中的“特殊”扩展泛华为“一般”，依次来实现复用。 &emsp;最后是投影，程序的实质是对现实世界的投影，是对现实世界中不同角色工作流程或工作业务的抽象处理，而对于一个系统来说，操作它的可能有三种角色，比如，高层领导，中层管理和基层操作人员。而这三种角色的业务流程和工作业务是不同，需要从三维视图进行分析。 三、需求分析的任务是什么？ 画出目标系统的组织结构图，列出各部门的岗位角色表，即组织机构模型。 画出目标系统的业务操作流程图，即业务模型。 画出目标系统的数据流图，即单据和报表的流图，掌握业务规则，获得初步的数据模型 列出目标系统的功能点列表，即功能模型。 列出系统的性能点列表，即性能模型。 确定目标系统的接口列表，即接口模型 确定目标系统的运行环境，即环境模型 目标系统的界面约定，即界面模型 对目标系统的开发工期、费用、开发进度、系统风险等问题进行分析和评估。 四、面向流程分析&emsp;需求分析是面向流程的，而流程是动态的、实时的。系统的功能、性能、接口、界面都是在流程中反映出来的。在所有的流程中，数据流最为很重要，同时也最具代表性。因为在计算机网络系统中，一切流程都表现为数据流。所以，面向流程分析，实质上是面向数据流程分析或面向数据分析。计算机网络只认识数据，其他所有信息必须转化为数据之后才能流动，所以面向流程分析本质上是面向数据流程分析。 五、需求分析的方法有哪些？&emsp;业界存在三种需求分析方法，分别是：面向功能分析、面向对象分析、面向数据分析。 &emsp;面向功能分析，是将软件需求看做一棵倒置的功能树，树根在上，树枝与树叶在下，每个节点都是一项具体的功能，从上到下，功能由粗到细，树根是总功能，树叶是细功能，整棵树就是一个信息系统的全部功能树。功能分析体现了“自顶向下，逐步求精”的思想，适合于“结构化分析、结构化设计、结构化编程、结构化测试、结构化组装、结构化维护”的传统式软件工程思想。 &emsp;面向对象分析，实质上是面向类分析，它也从系统的基本功能入手，或从与系统有关的人和事入手，将所有的功能需求找出来，然后将每一项功能对应一个对象集（类），分析每个对象集的属性、方法和包装方式，最后归并为相同对象集，删除冗余属性，用类与类之间的关联来表示所有的需求。 &emsp;面向数据分析，是面向元数据和中间数据分析。 六、需求分析的描述工具有哪些？ 面向元数据的需求描述工具 实体关系图 面向过程的需求描述工具 数据流图DFD、数据字典DD 面向对象的需求描述工具 用例图、类图、]]></content>
      <categories>
        <category>软件工程</category>
      </categories>
      <tags>
        <tag>需求分析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[软件生命周期模型]]></title>
    <url>%2F2019%2F06%2F15%2F%E8%BD%AF%E4%BB%B6%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E6%A8%A1%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[写在前面&emsp;开发一个软件项目，首先要选择并确定一个适合于该项目的软件生命周期模型，然后按照该软件生命周期模型的开发路线图，进行开发。 软件生命周期模型是指在整个软件生命周期中，软件开发过程应遵循的开发路线图。或者说，软件生命周期模型是软件开发全部过程、活动和任务的结构框架。 软件生命周期的9个阶段1）立项（或签订合同）、下达任务书 2）需求分析 3）概要设计 4）详细设计 5）编码实现 6）软件测试 7）软件发布与实施 8）软件维护 9）版本更新或退役 软件生命周期模型有哪些？瀑布模型、增量模型、原型模型、迭代模型、螺旋模型、喷泉模型、XP模型 瀑布模型是什么？具体的详细定义不再展开。 分为5个阶段：需求、设计、编码、测试、发布。自上而下。 首先，我们需要知道，瀑布模型师最早的软件生命周期模型，时至今日，仍然有强大的生命力，也是唯一被广泛使用的软件开发模型。 项目经理或软件管理人员，只要控制好每级台阶的高度和宽度，在每级台阶处设立里程碑或基线，并组织好对基线的评审，就可以控制好项目的开发成本、进度和质量。 但是，该模型的问题就在于阶梯，瀑布只能向下流，需要向上流的时候就需要付出很大的代价。这就是它的“问题堆积”，错误或发散扩大。 该模型的“问题堆积”并不是不可解决的，只要采用适合的管理方法，就可以控制或避免。比如微软公司采用的严格的里程碑管理制度。 增量模型是什么？增量模型是遵循递增方式来进行软件开发的。 在增量模型中，软件产品被看成了一组增量构件或模块。每次需求分析、设计、实现、集成、测试和交付一块构件。 对于一个复杂的大型系统，采用分解的方式来将大系统分解成小系统，这样虽然可以将大风险分解成多个小风险，并逐步消除小风险。但是，将一个复杂的大型系统进行合理、有效的分解和划分是最难的地方。 同时，对大系统进行有效的分解和划分的前提是，该复杂系统可被分解。若复杂系统的拆卸性和组装性不强，那么，增量模型就不再适合该复杂系统的开发。 原型模型原型模型的本意是在初步需求分析后，立马就向用户展示一个软件产品原型。 原型模型开发的过程中始终是以原型来驱动的，这很适合于那些已经有软件产品积累的公司。 但是，画画之前就已经知道画出来的结果是什么了，那么在画的过程中就很难有创新了。对于软件开发也是，这也是原型模型的主要缺点。 迭代模型迭代模型通过对各个工作流程的多次进行，更好地理解需求，从而可以设计出更为强壮的软件构架，逐步提高开发组织能力。 从宏观上看，迭代模型有4个状态阶段，分别是：先启、精化、构建和产品化。 而它的工作流程共有9个，分别是：1）业务建模 2）需求获取 3）分析设计 4）实施 5）测试 6）部署 7）配置与变更管理 8）项目管理 9）环境 在这9个工作流程中，核心流程是业务建模，因为在迭代模型开发之前一定要有一个初始的业务模型，以便对其进行迭代。 螺旋模型螺旋模型将瀑布模型和原型模型结合起来，特别强调风险分析，特别适用于大型复杂系统。 喷泉模型喷泉模型认为，软件开发过程自上而下的各个阶段是相互重叠和多次反复进行的。 喷泉模型有大量的重叠，所以需要大量的开发人员，不利于项目的管理。 XP模型XP模型即极限编程模型。本是敏捷文化现象。 XP模型通过需求、实现、重构、测试、发布的迭代过程，来实现一种轻量级的软件开发模型。 XP的核心要求是：交流、简单、进取、反馈 XP模型作为一种新的模型，在实际运用中存在较多的问题。同时，它与ISO 9001、CMMI的精神也存在冲突。]]></content>
      <categories>
        <category>软件工程</category>
      </categories>
      <tags>
        <tag>软件生命周期</tag>
        <tag>软件生命周期模型</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[软件工程的内容和方法]]></title>
    <url>%2F2019%2F06%2F14%2F%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E7%9A%84%E5%86%85%E5%AE%B9%E5%92%8C%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[写在前面&emsp;经过一个礼拜的准备，终于结束了软件工程的复习。在复习软件工程的同时也在做信息系统综合设计的课程设计。在做课程设计的过程中，发现了软件工程的重要性和必要性。作为立志成为程序猿的我，软件工程在将来的工作中一定大有用处，故总结如下。 一、软件、软件工程、软件工程学科体系学习软件工程，首先得知道软件是什么。其次，得知道软件工程是做什么的，它研究了什么内容，同时也应该知道软件工程学科体系是什么，与软件工程有什么关系。 软件：最新定义为，软件=知识+程序+数据+文档那么这里面的知识，程序，数据，文档又是指什么呢？ 知识，即各种各样的相关领域的专业知识。 程序，即使对计算机任务的处理对象和处理规则的描述。这里，我们一定要注意，软件并不等于程序，这也是一大误区。 数据，即程序赖以运行的初始化数据。 文档，即为了理解程序所需的详细描述性资料。 软件工程是什么？软件工程是研究软件开发和管理的一门工程学科。 这个定义很短，但是知识点还是挺多的。一强调开发，毕竟开发是软件工程的主体；二强调管理或过程管理，当然，管理是为了更好的开发；三是强调工程，把软件的开发和维护当成一项工程，用工程的办法去开发，按工程的办法去管理；四是强调学科，时至今日，软件工程不只是一门学科，而是一个学科体系。这里也就引出了软件工程学科体系。 软件工程来源于软件危机。软件工程是为了克服软件危机才产生的。 软件工程学科体系 软件工程作为一个学科体系，到21世纪才初步形成。2004年ACM和IEEE-CS联合制订了SWEBOK 2004版，它将软件工程学科体系的知识划分为10个知识域。 对于这10个知识域，我的理解是它覆盖了整个软件生命周期。 1） 软件需求 2）软件设计 3）软件构造 4）软件测试 5）软件维护 6）软件配置管理 7）软件工程管理 8）软件工程过程 9）软件工程工具和方法 10）软件质量 软件工程和软件工程学科体系的关系总体上来说，软件工程是一个局部问题，而软件工程学科体系是一个整体问题。 软件工程研究的内容软件工程研究的内容主要有五个方面。 一是软件生命周期模型 二是软件开发方法 三是软件支持过程 四是软件管理过程 五是软件工程标准与规范 软件工程基本原理软件工程的三要素：方法、工具和过程 有7个基本原理，外加一个二八定律。具体内容见文章末尾的链接。 软件工程在行业中的作用软件工程作为一门工程管理学科，它对软件行业的作用毋庸置疑。那么，这里会有一个问题，既然已经有软件工程了，那么还会不会出现软件危机呢？我的答案是会的。软件工程的产生是为了克服软件危机，但是它的存在并不会完全消除软件危机。这和现实社会中法律存在的意义是相通的。法律的产生是为了消除犯罪，但是法律的存在并不会完全消除犯罪（至少在当前的社会阶段是不会的）。 软件工程可以作用到从业者，也可以作用到项目组，作用到软件公司，甚至作用到整个国家的软件产业1发展。 二、软件工程方法论和软件工程实践论1. 软件工程方法论是什么？软件工程方法论实质上是软件工程中软件开发方法的集合。 那么软件工程方法的集合包括哪些元素呢？ 2. 软件工程方法集合软件工程方法集合包括面向过程方法、面向对象方法、面向元数据方法。 3. 为什么说面向对象方法可以描述无穷的信息世界呢？要搞清楚面向对象为什么可以描述无穷的世界，首先需要知道面向对象方法是什么，其次，需要知道现实世界和软件的普遍联系。 面向对象方法是什么？是一种运用对象、类、消息传递、继承、封装、聚合、多态性等概念构造软件系统的软件开发方法。 我记得高中哲学里面听到的一句话，世界是物质的，物质是运动的，运动是有规律的。而对于软件而言，其实质是对现实人工系统的一种映射、优化和替换。通过对现实世界的分析，我们可以知道，世界是由对象组成的，对象之间时存在普遍联系的，而物质运动则说明了对象的功能。 面向方法是将这现实世界抽象映射为对象的手段。分析设计时由对象抽象出类，程序运行时由类还原到了对象。所以它能够描述无穷的信息世界。 4. 软件工程实践论是什么？软件工程实践论是研究在开发一个大型软件系统时，到底应该怎样选取合适的开发方法。 5. 软件工程实践论指什么？“五个面向”实践论，指面向流程分析、面向元数据设计、面向对象实现、面向功能测试、面向过程管理。 在后面，我们会发现软件工程的“五个面向”实践论在各个软件生命周期模型中都有一定的体现。 三、软件支持过程、软件管理过程 软件过程是什么？软件过程，指软件生命周期中的时间序列 软件支持过程是什么？软件支持过程，由支持软件生命周期模型各个阶段的生产工具组成。 软件生命周期中的生产工具有哪些？CASE工具、软件开发环境SDE、软件工程环境SEE 软件管理是什么？管理过程和支持过程又称为“软件过程工程”。它是软件工程的一部分。 软件管理实质上是过程管理。 软件管理有哪几类？ISO 9001质量管理和质量保证体系 CMMI软件能力成熟度模型 软件企业文化，包括微软企业文化，IBM企业文化，敏捷文化。]]></content>
      <categories>
        <category>软件工程</category>
      </categories>
      <tags>
        <tag>软件工程方法论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[指针，又见指针]]></title>
    <url>%2F2019%2F06%2F10%2F%E9%92%88%EF%BC%8C%E5%8F%88%E8%A7%81%E6%8C%87%E9%92%88-1%2F</url>
    <content type="text"><![CDATA[一、指针简介一般来说，指针是一个其数值为地址的变量（或更一般地说是一个数据对象）。正如char类型的变量用字符作为其数值，而int类型变量的数值是整数，指针变量的数值表示的是地址。 如果你将某个指针变量命名为ptr，就可以使用如下语句： 1ptr=&amp;pooh; //把pooh的地址赋给ptr 对于这个语句，我们称ptr指向pooh。ptr和&amp;pooh的区别在于前者是变量，后者是常量。ptr可以指向任何地方： 1ptr=&amp;bath; //令ptr指向bath 二、间接运算符假定ptr指向bath：ptr=&amp;bath 这时就可以使用间接运算符*（也称取值运算符）来获取bath中存放的数值。 1val=*ptr; //得到ptr指向的值 语句ptr=&amp;bath；以及语句val=*ptr；放在一起等同于下面的语句： 1val=bath; 下面进行举例： 123nurse=22;ptr=&amp;nurse; //指向nurse的指针val=*ptr; //将ptr指向的值赋给val 上述语句实现的功能是把数值22赋给变量val 三、指针声明例如：long和float两种类型的数值可能使用相同大小的存储空间，但是他们的数据存储方式完全不同，指针的声明形式如下： 123int *pi; //pi是指向一个整数变量的指针char *pc; //pc是指向一个字符变量的指针float *pf,*pg; //pf和pg是指向浮点变量的指针 类型标识符表明了被指向变量的类型，而表示该变量是一个指针。声明int * pi;的意思是pi是一个指针，而且pi是int类型的。 *和指针名之间地空格是可选的。通常程序员在声明中用空格，而在指向变量时将其省略。 pc所指向的值（*pc）是char类型的。而pc本身是什么类型的？ 我们将其描述为“指向char的指针”类型。pc的值是一个地址，在大多数系统中，它是由一个无符号整数表示。但是这并不表示可以把指针当做整数类型。一些处理整数的方法不能用来处理指针，反之亦然。例如，可以进行两整数相乘，而指针不能。因此指针的确是一种新的数据类型，而不是整数类型。 四、使用指针在函数间通信在下面的程序中，函数interchange（）只用了指针参数，我们将对该函数进行详细的讨论。 123456789101112131415161718#include&lt;stdio.h&gt;void interchange(int * u, int * v);int main(void)&#123; int x = 5, y = 10; printf("Originally x=%d and y= %d.\n", x, y); interchange(&amp;x, &amp;y); //向函数传送地址 printf("Now x= %d and y=%d.\n", x, y); return 0;&#125;void interchange(int * u, int * v)&#123; int temp; temp = *u;//temp得到u指向的值。 *u = *v; *v = temp;&#125; 下面我们分析以上程序的运行情况。首先，函数调用语句如下： 1interchange(&amp;x, &amp;y); //向函数传送地址 可以看出，函数传递的是x和y的地址而不是他们的值。这就意味着intechange（）函数原型声明和定义中的形式参数u和v将使用地址作为它们的值。因此他们应该声明为指针，由于x和y都是整数，所以u和v是指向整数的指针。其声明如下： 1void interchange(int * u, int * v); 接下来，函数体进行如下声明： 1int temp; 从而提供了所需要的临时变量。为了把x的值存在temp中，需要使用下面语句： 1temp = *u;//temp得到u指向的值。 注意，因为u的值是&amp;x，所以u指向x的地址，这就以意味着*u代表了x的值，而这正是我们需要的数值。 在示例程序中，我们用一个函数实现x和y的数值交换。首先函数使用x和y的地址作为参数，这使得它可以访问x和y变量。通过使用指针和运算符*，函数可以获得相应存储地址的数据，从而就可以改变这些数据。 在ANSI原型中可以省略变量名称。这样，函数原型可以按如下形式进行声明： 1void interchange (int * ,int *); 通常情况下，可以把关于变量的两类信息传递给一个函数，如果函数的调用形式为： 1function1(x); 这时传递的是x的值，但是如果使用下面这种函数调用形式： 1function2(&amp;x); 那么会把x的地址传递给函数。第一种调用形式要求函数定义部分必须包含一个和x具有相同数据类型的形式参数。如下所示： 1int function1(int num); 而第二种形式要求函数定义部分的形式参数必须是指向相应数据类型的指针： 1int function2(int *ptr); 使用函数进行数据计算等操作时，可以使用第一种调用形式。但是如果需要改变调用函数中的多个变量的值时，就需要使用第二种调用形式。 尽管interchange（）只使用局部变量，但是通过使用指针，该函数可以操作main（）中的变量的值。]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>指针</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[软件工程相关名词解释]]></title>
    <url>%2F2019%2F06%2F10%2F%E5%B7%A5%E7%A8%8B%E7%9B%B8%E5%85%B3%E5%90%8D%E8%AF%8D%E8%A7%A3%E9%87%8A-1%2F</url>
    <content type="text"><![CDATA[软件： 一般认为，程序是计算机为完成特定任务而执行的指令的有效集合。站在应用的角度可以通俗地理解为： 面向过程的程序=算法+数据结构 面向对象的程序=对象+消息 面向构件的程序=构件+构架 通常，软件有以下定义： 软件=程序+数据+文档 这里的“程序”，是对计算机任务的处理对象和处理规则的描述；这里的“文档”，是为了理解程序所需的详细描述性资料；这里的“数据”，主要是软件系统赖以运行的初始化数据。 软件的最新定义如下： 软件=知识+程序+数据+文档 定义中增加了“知识”。这里的“知识”,主要指各种各样的相关行业领域的专业知识。实际上，知识只是网络的外在表现，程序，数据，文档才是网络的内在实质。也就是说，知识是通过程序、数据、文档来实现的。 对这一定义的另外一种解释是，软件到底是什么呢？软件就是网络，网络就是知识，知识就是信息。站在网民的角度看，软件就是知识加信息。站在程序员角度看，软件就是程序加数据；站在软件管理者角度看，软件就是数据加文档。 网络是知识的载体，知识是网络的灵魂。 软件工程 软件工程是研究软件开发和管理的一门学科。 这里，以是强调开发。开发是软件工程的主体，开发是在规定的时间、按照规定的成本，开发出符合规定质量要求的软件。二是强调管理或过程管理。当然，开发中有管理，管理是为了更好地开发。所以开发和管理是一个问题的相辅相成的两个方面。许多软件项目的失败，不是在开发技术上出了问题，二是在管理过程上出了问题。所以在某种程度上说，对于一个软件企业，过程管理比开发技术更重要。三十强调工程。要将软件的开发（包括维护）当成一项工程，既要按照工程的办法去开发，又要按照工程的办法去管理。四是强调学科。时至今日，软件工程不止是一门课程，而是一个学科体系，即软件工程知识体系。 软件工程学科体系（swebok2004）： 软件工程作为一个学科体系，到21世纪初才初步形成。2001年4月18日，美国发布了软件工程知识体系指南SWEBOK（guide to the Software Engineering body of Knowledge）0.95版。2004年，软件工程学科体系的内容才基本确立，就在这一年，美国ACM和IEEE-CS联合制订了SWEBOK2004版，它将软件工程学科体系的知识划分为如下10个知识域： （1）软件需求：软件需求是真实世界中的问题而必须展示的特性。软件的需求知识域有7个子域：需求基础、需求过程、需求获取、需求分析、需求规格说明、需求确认、实践考虑。 （2）软件设计：软件设计既是定义一个系统的体系结构，组件，接口和其他特征的过程，又是这个过程的结果，软件设计知识域有6个子域：软件设计基础，软件设计关键问题，软件结构与体系结构，软件设计质量的分析与评价，软件设计符号，软件设计的策略与方法。 （3）软件构造：它指通过编码，验证，单元测试，集成测试和排错的组合，具体创建一个可以工作的，有意义的软件。其知识域有3个子域：软件构造基础，管理构造，实际考虑 （4）软件测试：它由在有限测试用例集合上，根据期望的行为对程序的行为进行的动态验证组成，测试用例是从实际上无限的执行域中适当选择出来的。软件测试知识域有5个子域：软件测试基础和测试级别，测试技术，需求分析，与测试相关的度量，测试过程。 （5）软件维护：软件一旦投入运行，就可能出现异常，运行环境可能发生改变，用户会提出新的需求。生命周期中的软件维护，从软件交付时开始。软件维护的知识域有4个子域：软件维护基础，软件维护的关键问题，维护过程，维护技术。 （6）软件配置管理：软件配置是为了系统地控制配置的变更，维护软件在整个系统生命周期中的完整性及可追踪性，而标志软件在不同时间点上的配置的学科。软件配置管理知识域有6个子域：软件配置管理过程管理，软件配置标志，软件配置控制，软件配置状态统计，软件配置审核，软件发行管理和交付。 （7）软件工程管理：进行软件工程的管理与度量，虽然度量是所有知识域的一个重要方面，但是这里所说的是度量程序的主体。软件工程管理只是域有6个子域：启动和范围定义，软件项目计划，软件项目实施，评审与评价，关闭，软件工程度量。前5个覆盖软件过程工程管理，第6个描述软件度量的程序。 （8）软件工程过程：涉及软件工程过程本身的定义、实现、评定、度量、管理、变更和改进。软件工程过程知识域有4个子域：过程实施与改变、过程定义、过程评定、过程和产品度量。 （9）软件工程工具和方法：它具有软件工程工具、软件工程方法两个子域。 （10）软件质量：处理跨域整个软件生命周期过程的软件质量的考虑，由于软件质量问题在软件工程中无处不在，其他知识领域也涉及到质量问题。软件质量知识域有3个子域：软件质量基础，软件质量过程、时间考虑。 在上述软件工程学科体系中前5个知识域是讲软件开发，后5个知识域是讲软件管理。由此可见，软件工程知识体系包括软件开发和软件管理两大部分，所以软件工程的定义也应该包括软件开发和软件管理两项内容。 软件工程课程 软件工程课程与软件工程学科体系是有区别的：前者是一门或一组课程，后者是一个知识体系；前者是一个局部问题，后者是一个整体问题。 作为一门软件工程客户才能，它研究的内容至今没有统一的说法。可以这么认为，软件工程课程研究的内容应该涵盖“软件生命周期模型、软件开发方法、软件支持过程、软件管理过程、软件工程标准与规范”这5个方面。 序号 研究方向 具体内容 1 软件生命周期模型 如：瀑布模型，增量模型 2 软件开发方法 如：面向过程的方法 3 软件支持过程 如：CASE工具ROSE，北大青鸟系统，Power Designer 4 软件管理过程 如：CMMI，软件企业文化，敏捷（XP）文化现象 5 软件工程标准与规范 如：命名标准与规范，设计标准与规范，编程标准与规范 尽管软件生命周期模型和软件支持过程非常重要，但是现代软件工程研究的重点，仍然是软件开发方法和软件管理过程。在软件管理过程的内容中，除了ISO9001的CMMI之外，还将软件企业文化也列入其中，如微软企业文化，敏捷文化现象和IBM企业文化。 软件工程标准是对软件产品的约束，如软件产品的界面标准，包装标准，文档标准，测试标准，评审标准，鉴定标准等。软件工程规范是对软件开发人员行为的约束，例如命名规范，需求规范，设计规范，编码规范，维护规范等。在软件企业内部，企业管理人员特别重视软件工程的标准与规范。为此，每个大型的软件企业，根据自身的特点，都制订并发布了自己的软件工程标准与规范，在自己企业内部严格执行。 软件工程基本原理 习惯上，人们常常把软件工程方法（开发方法）、工具（支持方法的工具）、过程（管理过程）称为软件工程三要素，而把美国著名的软件工程专家B.W Boehm于1983年提出的7条原理作为软件工程的基本原理。 （1） 用分阶段的生命周期计划严格管理软件开发。阶段划分为计划、分析、设计、编程、测试和运行维护。 （2） 坚持进行阶段评审。若上一阶段评审不通过，则不能进入下一阶段开发 （3） 实行严格的产品版本控制 （4） 采用现代程序设计技术 （5） 结果应能清楚地审查。因此，对文档要有严格的要求 （6） 开发小组的成员要少而精 （7） 要不断地改进软件工程实践的经验和技术，要与时俱进 上述7条原理，虽然是在面向过程设计时代（结构化时代）提出的，但是，直到今天，在面向元数据和面向对象的程序设计新时代，它仍有效。根据“与时俱进”的原则，还有一条基本原理在软件的开发和管理中特别重要，需要补充进去，作为软件工程的第8条基本原理。 （8） 二八定律 在软件工程中，所谓二八定律，就是一般人常常将20%的东西误认为80%的东西，而将80%的东西误认为是20%的东西。 例如，对软件项目进度和工作量的估计：一般人主观上认为已经完成了80%，但实际上只完成了20%；对于程序中存在问题的估计，：一般人不知道80%的问题存在于20%的程序之中；对模块功能的估计：一般人不知道20%的模块，实现了80%的功能；对人力资源的估计：一般人不知道20%的人，解决了程序中80%的问题；对投入资金的估计：一般人不知道信息系统中80%的问题，可以用20%的资金来解决。 研究二八定律的现实意义是，指导软件计划的制订与执行。 软件生命周期模型 软件生命周期模型时指在整个软件生命周期中，软件开发过程应该遵循的开发路线图。或者说，软件生命周期模型是软件开发全部过程、活动和任务的结构框架。 例如：瀑布模型、增量模型、螺旋模型、喷泉模型、XP模型、原型模型和RUP迭代模型，它们都有各自清晰的开发路线图，规定了各自的开发过程、活动和任务的结构框架。 从字面上理解，“软件生命周期”应该涵盖软件产品、项目或系统从产生、投入使用看到被淘汰的全过程。由于早期人们关注的是技术开发活动，还没有考虑到管理活动，因此“软件生命周期模型”主要描述的还是软件开发的过程及其任务。 与人不同的是，软件的生命周期和软件生命周期模型有关：不同的软件生命周期模型，可能对应着不同的生命周期。生命周期不同，该软件的开发阶段划分、评审次数、基线标准都有所不同。软件公司的项目组在开发一个大项目或产品时，首先在技术上必须选择一个软件生命周期模型，使该模型非常适合这个项目或产品的生命周期模型；随后通过对软件生命周期模型的裁剪，给出适用于本项目或产品的软件生命周期定义；以生命周期定义为标准，在需求定义之后，编制详细的软件开发计划；然后项目组按计划进行软件开发，软件工程管理部门按计划进行软件过程跟踪和管理。 软件生命周期模型能清晰、直观地表达软件开发全过程，明确规定了要完成的主要活动和任务，用来作为软件项目工作的基础。一般以时间为序，软件生命周期模型可详细地划分为9个阶段。 序号 周期名称 序号 周期名称 1 立项（或签合同）、下达任务书 6 软件测试 2 需求分析 7 软件发布与实施 3 概要设计 8 软件维护 4 详细设计 9 版本更新或退役 5 编码实现 软件开发方法是指在软件工程开发路线图中，开发人员对软件需求、设计、实现、维护所采用的开发思想开发技术、描述方法、支持工具等。 软件工程中软件开发方法的集合，称为软件工程方法论。 迭代模型及其9个核心流程 针对瀑布模型的缺陷，人们提出了迭代模型。 所谓迭代，是指活动的多次重复。从这个意义法伤来讲，原型不断完善，增量不断产生，都是迭代的过程。因此，快速原型法和增量模型都可以看成局部迭代模型。但这里所讲的迭代模型时RUP推出的一种“逐步求精”的面向对象的软件开发过程模型，被认为是软件界迄今为止最完善、可实现商品化的开发过程模型。 RUP模型的原型图看起来非常简单，其内涵却非常丰富。它表面上是一个二维图，实质上用一张二维图表示了一个多维空间模型。从宏观上看，它是一个大的迭代过程；横坐标表示软件产品所处的4个阶段：先启、精化、构建、产品化（移交），纵坐标表示软件产品在每个阶段的工作流程。从微观上看，任何一个阶段本身，其内部工作流程也是一个小的迭代过程。 为使项目能够顺利地进行，一种较灵活（并且风险更小）的方法是：多次执行各个开发工作流程，从饿了更好地理解需求，设计出更为强壮的软件架构，逐步提高开发组织能力，最终交付一系列逐步完善的实施成果，这就是迭代生命周期模型。每次按顺序完成一系列工作流程就称为一次迭代，每次迭代，均以次要里程碑结束，按照特定的迭代成功标准，对迭代的结果进行评估。每个阶段都可以进一步细分为迭代。迭代是产生可执行的产品发布（内部或外部的）的完整开发循环，所发布的产品是开发过程最终产品的子集，它将通过一次又一次的迭代实现递增成长，最后形成最终的软件系统或产品。 优点： n 在开发的早期或中期，用户需求可以变化； n 在迭代之初，不要求有一个相近的产品原型 n 模型的适用范围很广，几乎适用于所有项目的开发 缺点：传统的组织方法是按顺序（一次且仅一次）完成每个工作流程，即瀑布式生命模型。迭代模型采取循环工作方式，每次循环均使工作产品更靠近目标产品，这要求项目组成员具有很高的水平并掌握先进的开发工具。反之，存在较大的技术和技能风险。 模型的9个核心流程： 迭代声明周期模型包含9个核心流程（需要指出的，采用迭代模型，事先要有一个初始业务模型，以便进行迭代。这就是为什么将“业务建模”作为9个核心流程之首的道理）。 （1） 业务建模：目的是， 了解目标组织的结构和机制；了解目标组织中当前存在的问题，并确定改进的可能性；确保客户、最终用户和开发人员就目标组织达成共识；导出支持目标组织所需的系统需求。通俗地讲，业务建模就是用户业务流程的重新规划与合理改进，即业务流程的优化，目的是使开发出来的系统能反映最优化的业务流程。 （2） 需求获取：目的是，与客户在系统的工作内容方面达成并保持一致；使系统开发人员能够更清楚地了解系统需求；定义系统边界；为计划迭代的内容提供基础；为估算开发系统所需成本和时间提供基础；定义系统的用户界面，重点是用户的需要和目标。 （3） 分析设计：目的是，将需求转换为未来系统的设计；逐步开发强壮的系统构架；使设计适合实施环境，为提高性能而进行设计。 （4） 实施：目的是，对照实施子系统的分层结构定义代码结构；以构件（源文件，二进制文件，可执行文件以及其他文件等）方式实施类和对象；对已开发的构件按单元进行测试；将各实施成员（或团队）完成的结果集成到可执行系统中。 （5） 测试：目的是，核实对象之间的交互；核实软件的所有构件是否正确集成；核实所有需求是否已经正确实施；确定缺陷并确保在部署软件之前将缺陷解决。 （6） 部署：目的是，将构件部署到网络的各个节点上，使最终用户可以使用该软件产品。 （7） 配置与变更管理，目的是，始终保持工作产品的完整性和一致性 （8） 项目管理：目的是，为软件密集型项目的管理提供框架；为项目计划，人员配备，执行和检测提供实用准则；为风险管理提供框架。 （9） 环境：目的是，为软件开发组织提供软件开发环境（流程和工具），该环境将支持开发团队。 XP模型 XP模型，即极限编程模型，它本来是敏捷企业文化现象，但是不少人将它当成一种软件开发模型。 对传统软件开发模型进行重新审视发现，它们太正规、太呆板、太浪费资源，从而提出了省时省力的XP模型。它属于轻量级开发模型，由一组简单规则（需求、实现、重构、测试、发布）组成，它既保持开发人员的自由创造性，又保持对需求变动的适应性，即使在开发的后期，也不怕用户需求的变更。 在需求、实现、重构、测试、发布的迭代过程中，XP模型有4条核心原则：交流、简单、反馈和进取。XP开发小组包括开发人员、管理人员和客户。 优点： l 采用简单策略，不需要长时间计划和复杂管理，开发周期短 l 采用迭代增量开发，反馈修正和反复测试的方法，因而软件质量有保证。 l 适应用户需求变化，因而与用户关系和谐。 缺点： XP模型作为一种新的模型，在实际应用中还存在一些问题，引起了一些争议。它一般适用于小型项目，同时，它与ISO9001、CMMI的精神也存在冲突。 订单软件 与固定的用户签订软件开发合同，由软件公司启动该项目的开发，这类软件被称为“订单软件”，典型的例子有企业资源规划系统ERP和电子商务大型网站。 非订单软件 市场调研之后，认为某产品将会有巨大的市场空间，而软件公司在人力资源、设备资源、抵抗风险、资金和时间上都具备开发该产品的能力，于是决定立项，这类软件被称为“非订单软件”，典型的例子是网上游戏软件 任务书 有一份《任务书》的正文。包括任务下达的对象、内容、要求完成的日期、决定投入的资源、必要时包括任命项目经理（技术经理和产品经理）、其他保证措施、奖惩措施等。《任务书》正文可长可短，若《合同》或《立项建议书》很详细，则正文可短，若《合同》或《立项建议书》很粗很短，则正文应该很长、很详细。 有一份《任务书》的附件。一般情况下，它就是软件《合同》/《立项建议书》，如果是指令性计划，它的格式和内容，也应与《合同》/《立项建议书》基本相同，即附件的内容应覆盖系统的功能点列表、接口列表、资源需求列表、开发进度列表、阶段评审列表等。 《任务书》与《合同》/《立项建议书》一样重要，它是该项目的第二份管理文档。 合同 对于一些大型项目，在签订合同之前，一般有一个招标和投标的过程，只有中标之后才能签订合同。开发“非订单软件”需要“立项”，开发“订单软件”需要签订“合同”。所以“立项”与“合同”是IT企业软件项目（或产品）的两个源头。一旦立项或签订合同，企业领导或软件管理部门就要下达《任务书》，开发部门接到《任务书》后就要组建开发团队，成立项目组。 立项建议书 立项文档就是《立项建议书》，它本身不是软件策划的内容，但是很重要，也很特殊。《立项建议书》的目的，就是在某种程度上代替开发合同或用户需求报告，作为软件策划的基础。《立项建议书》的编制者一般不是软件开发人员，而是软件公司的市场销售人员，因为他们熟悉市场行情及客户需求 需求分析 1997年，IEEE软件工程标准词汇表中定义的需求为： （1） 用户解决问题或达到目标所需的条件或能力 （2） 系统或系统部件要满足合同、标准、规范或其他正式规定文档所具有的条件或能力 （3） 一般反映（1）或（2）所描述的条件或能力的文档说明 一般而言，需求分析阶段位于软件开发的前期，它的基本任务是准确地定义未来系统的目标，确定为了满足用户的需要系统必须做什么。 需求分析分为两个阶段：需求获取阶段和需求规约阶段。需求关系的是系统的目标而不是系统实现。 需求可以分为两类：功能性需求和非功能性需求。前者定义了系统做什么，后者定义了系统工作时的特性。 基线 基线是软件工作产品，它是要经内部和外部评审过的，是下一阶段工作的基础。 审计 审计，是复查评审活动程序的合法性，是否按程序与规范进行等 里程碑 里程碑是一个标记，只需要经过内部评审。一个里程碑是一个检查点，但不一定对应一条基线 定义软件过程 所谓定义软件过程，就是根据选定的生命周期模型，规定软件的开发1模型，以及每一阶段的工作步骤和文档标准等内容。 在项目策划阶段，先要根据项目特性，使用软件生命周期模型，对项目中将要进行的软件工程过程进行描述。根据项目自身的特点，对项目的类型进行详细划分，然后根据软件组织的“生命周期模型裁剪指南”，对标准软件过程进行裁剪，形成项目定义软件过程。再使用项目定义软件过程，指导项目策划活动的进行。 开发计划是对项目定义软件过程的具体描述。软件项目的规模、工作量、成本、进度、质量、人员配置和其他资源等，与项目定义软件过程中的活动紧密相关。由于项目定义软件过程的标准，全部由“生命周期模型裁剪指南”而得到，因此软件项目能共享过程数据，并且吸取软件组织中积累的经验教训。 LOC LOC（line of code），LOC指所有的可执行源代码行数。包括可交付的工作控制语言（job control language，JCL）语句，数据定义，数据类型声明，等价声明，输入/输出格式声明等。一代码行（1LOC）的价值和人月均代码行数可以体现一个软件生产组织的生产能力。组织可以根据对历史项目的审计来核算组织的单行代码价值。 功能模型 （Function Model, FM）。实质上是用户需求模型，用来描述系统能做什么，即对系统的功能，性能，接口和界面进行定义。 业务模型 （Operation Model，OM），实质上是业务逻辑模型，用于描述系统在何时，何地、由何角色、按什么业务规则去做，以及做的步骤或流程，即对系统的操作流程进行定义。 数据模型 （Data Model, DM）,实质上是实体或类的状态关系模型，用于描述系统工作前的数据来自何处，工作中的数据暂存在什么地方，工作后的数据放到何处，以及这些数据的状态以及相互之间的关联，即对系统的数据结构进行定义。 风险分析 软件策划过程，也包括对软件风险进行分析。所谓软件风险分析，指对项目及团队的政策风险、技术风险、技能风险、资源风险等因素，进行逐个分析与分解，将一个大风险分解为若干个小风险，对各个小风险进行排除，最后制订跟踪和监控风险的风险管理计划。软件一般存在5种风险，如下表： 序号 风险名称 风险内容 1 政策风险 IT企业外部和IT企业内部两个方面的政策及政策的变化，将会给项目带来什么风险 2 技术风险 新技术的成熟程度以及难度系数，将会给项目带来什么风险 3 技能风险 项目组成员学习、领会、掌握、运用新技术的能力，将会给项目带来什么风险 4 资源风险 保证项目正常进行所需的各种资源的供应程度，将会给项目带来什么风险 5 其他风险 目前意想不到的风险，即不可预测的风险，如天灾人祸 三层结构设计 三层结构设计通常被划分为表示层、中间层和数据层三层，各个分层之间通过对外接口互相访问。分层的主要目的是，允许各层可以随着需求的变化或技术的变化而独立地升级或替换，如当替换数据库时，只需要变化数据层。 所谓的三层结构，就是在原来两层结构（Client/Server）的客户层和数据层之间，加入一个中间层（也叫业务层），并将应用程序的业务规则、数据访问、合法型校验等工作放到了中间层进行处理，这样就变成了三层结构，也不仅仅有B/S应用才是三层结构，三层是指逻辑上的三层，即使这三层都放置到了一台机器上。当然，这三层也可以放在两台或三台机器上。 （1） 表示层（浏览层） 表示层也称为浏览层，它通常采用图形化用户界面，在客户端PC或工作站上运行。站在“三个模型”建模思想上看，系统内部支持表示层的模型是“功能模型”，尽管“功能模型”中的功能思想组件放在业务层，但是功能组件的表现方式却在表示层上。该层的主要功能是： ​ 1）接受用户请求，将这些请求反馈给业务逻辑层，等待业务逻辑层的应答信息 12） 对业务逻辑层的应答信息，进行显示（不进行任何加工） ​ 3） 有时也会兼做业务逻辑层的一些小功能，比如对用户输入数据的验证，以及操作合法性的检验 （2） 中间层（业务层） 中间层也称业务层，有时又称为应用层，它由许多构建或组件组成，它们完全体现了用户的业务逻辑或业务规则。站在“三个模型”建模思想看，系统内部支持业务层的模型是“业务模型”。尽管Java EE与.NET在实现业务层上的方法略有差异，但是，业务层本质上在表示层与数据层之间起桥梁作用。有时，业务层被划分为两个子层：业务逻辑层和数据访问层。业务层的主要功能是： ​ 1） 接受从表示层传来的用户请求信息 ​ 2） 根据用户的请求信息生成SQL语句 ​ 3） 利用生成的SQL语句从数据层取数据、修改数据、删除数据 ​ 4） 将结果返回给表示层 （3） 数据层 数据层是数据库服务器上的数据库层，它包括数据库管理系统DBMS和数据库DB两部分。站在“三个模型”建模思想看，系统内部支持数据层的模型是“数据模型”，该层的主要功能是： ​ 1）接受业务层数据处理请求的SQL语句或存储过程 ​ 2） 利用SQL语句或存储过程，对数据库服务器上数据库的相关表进行存储或检索 ​ 3） 将存储或检索的结果信息，传递给业务层 构件 所谓构件，就是被标识的且可被复用的软件制品。 构件与部件，组件基本上是一个意思，有时会认为部件和组件的粒度比构件大一些或范围更广一些。上述定义有三个特点：第一个特点是构件要被明确标识，即有一个被调用的名字；第二个特点是应该可服用，不可复用的只能称为模块或子系统，第三个特点是构件是软件制品，在宏观上软件制品可以是项目计划、成本估价、体系结构、需求模型、设计模型、程序代码、窗口界面、文档、数据结构、测试用例等。 中间件 中间件是一个非常大的组件（构件），一般在网络上运行，完成批量数据的传递和通信工作，调用方式是通过一组事先约定的格式与参数进行的。常见的中间件为问价传输中间件，如IBM公司的消息队列中间件MQ，在网络节点之间进行点对点的数据通信和传输。又如城市医疗保险系统中的中间件，它在市医保局节点和全市各家医院节点之间，进行点对点的数据通信和传输，病号每次划价计费，节点之间就交换一次信息。在详细设计说明书中已对新增中间件的功能和算法进行了详述，此处只要将详细设计翻译为源程序即可。 结对编程 在敏捷方法中，成对（或结对）编程时极限编程的实践之一。当进行成对编程时每一个程序员输入代码，另一个在旁边观察代码中是否存在错误，并思考下一步要进行的工作。 优点： 1） 可以提高代码的可读性和可理解性，产生高质量的代码 2） 提高编程效率，使编程速度更快，代码错误更少，后期测试和纠错的工作量就会大大降低 3） 成对编程可以提高开发团队的凝聚力和协作精神 规则： 1） 编码标准 2） 积极参与 3） 非强制性 4） 定期轮换 5） 速度匹配 6） 新老匹配 软件测试 软件测试按照规定的测试规程发现软件缺陷的问题。 为了理解这个定义，有如下解释： 1） 软件测试是一个过程，而且是一个发现软件缺陷，但不包括修复软件缺陷的过程。 2) 软件测试是按照规定的测试规程进行。这些规程包括制定测试计划，搭建测试环境，明确测试任务，规定测试时间、方法和步骤，记录测试数据和产生测试报告 3) 在测试规程中，测试计划最为重要，它指导整个测试计划 4) 在测试计划中，测试需求的定义很重要。如果没有列出明确的测试需求，那么就并不会设计出正确的测试用例，最后必然导致盲目的测试。这样，隐藏的软件缺陷也无法被发现。 5) 软件测试的目的是发现软件缺陷，软件测试的目标是尽可能早地发现软件缺陷，因为缺陷发现越早，其修复成本越低。 软件测试不仅仅局限于测试程序代码，还可以测试软件数据与软件文档。也就是说，软件生命周期中所产生的软件工作产品，都可以作为测试对象，因为它们影响最终软件产品的质量。 软件缺陷 定义如下： 软件未实现产品说明书要求的功能。 软件出现产品说明书指明不应该出现的错误 软件实现了产品说明书未说明的功能 软件未实现产品说明书虽未明确提及但应该实现的目标 软件难以理解，不易使用，运行速度慢，或者软件测员，最终用户认为软件不好。 由于不同的理解方式和中英文翻译问题，软件缺陷的说法很多，如错误、失效、失败等，本书中统称为软件缺陷（bug）。实际测试中，将软件缺陷定义为不同级别，代表不同程度的软件缺陷。 随着软件定义的变化，软件缺陷的定义也应随之更新。软件缺陷不仅仅局限于软件代码，还包括文档缺陷（不符合规范或者不详细，有错误和歧义等）、测试缺陷（测试不充分，或测试方法本身的局限）、过程缺陷（软件生命周期的流程问题造成的产品质量问题）和管理缺陷（由于管理本身不到位导致的产品质量问题）。 软件测试的V模型 早期的软件测试V模型 模型的左侧是开发阶段，右侧是测试阶段。开发阶段从了解并定义软件需求开始，然后要把需求转换到概要设计和详细设计，最后形成程序代码。测试阶段是在代码编写完成之后，先做单元测试，然后做集成测试、系统测试和验收测试。 单元测试：主要检测代码的编写是否符合详细设计中单个模块或组件的要求 集成测试：主要检测此前测试过的单个模块或组件，能否正确地集成到系统，与其他模块一起运行，是否符合概要设计和详细设计说明书的要求。 系统测试：以集成后的完整系统作为测试对象，主要检测其是否符合需求说明书、概要设计说明书和详细设计说明书的要求。 验收测试：主要检测软件产品是否符合用户需求，用户合同和需求说明书中的要求，需要得到用户认可并签字确认。 改进后的V模型： 改进后的V模型，一是加入软件测试分析和测试设计阶段，二是体现“尽早”思想。改进后的V模型，形成了一个没有软件开发过程的、单独的软件测试V模型。它的左边是软件测试需求分析和测试设计，右边是软件测试执行。虽然测试执行过程同样集中在软件编码之后，但是测试需求分析和测试设计已经提前，一直提前到与开发阶段并行开展。一方面可以为后期的测试执行过程做计划和准备，另一方面可以对软件的阶段性产品（软件工作产品）进行测试。前期的软件工作产品主要是文档，如测试需求分析阶段，就是测试软件需求分析过程的工作产品《需求规格说明书》，进而提炼出测试需求。 黑盒测试 黑盒测试又称为不透明盒测试，它给我们的更多启示是它的思考方式，即不考虑（主观上屏蔽）或者不需要（客观条件限制）知道被测对象的内部实现细节，只关心输入输出。在运用黑盒测试方法进行软件测试时，它并不关心软件的内部逻辑结构和实现方法，而是站在使用者的角度，主要测试软件的功能指标，即测试系统的功能模型。黑盒测试的依据是软件的行为描述，是面向功能的穷举输入测试。从理论上讲，只有把所有可能的行为都作为测试用例输入，才能完成黑盒测试工作。黑盒测试的对象可以是软件单元、软件模块、软件组件、软件子系统和软件系统，也可以是发散思维到软件文档，软件管理文档等软件生命周期中的任何可测试对象。 黑盒测试用例设计方法： （1） 等价类划分法 （2） 边界值分析法 （3） 错误推测法 （4） 因果图分析法 （5） 场景分析法 白盒测试 白盒测试又称为透明盒测试，要求测试人员必须清楚被测对象的内部实现细节。白盒测试方法的测定依据是《详细设计说明书》。理论上讲，面向程序执行路径进行穷举代码测试，直至覆盖所有路径，才算完成了白盒测试。白盒测试的测试对象，侧重于软件单元，模块和构件等小规模对象，绝对不适合软件项目或产品的等大规模测试对象。 实用的白盒测试覆盖技术有4种，即语句覆盖，条件覆盖，分支覆盖和组合覆盖。覆盖的主要思想，是从不同角度尽可能提高代码的测试覆盖率。为了减少测试工作量，应该使每一个测试用例满足多个覆盖条件。 等价类 等价类划分的具体做法是：把所有可能的输入数据，即软件的输入域，划分成若干部分（子集），使每部分内的数据都是等效的（对于软件而言，等效可以理解为对数据的处理过程以及处理结果都完全一致），然后从每一个子集中选取少数具有代表性的数据，作为测试用例。 每一个等价类又可以划分为两种不同类别：有效等价类和无效等价类。 边界值 边界值分析方法是对等价类划分方法的补充。 测试工作者已经总结出经验：大量的错误常常发生在输入或输出范围的边界上，因此针对各种边界情况设计测试用例，可以查出更多的错误。 使用边界值分析方法设计测试用例使，首先参考等价类划分法确定边界情况，除了在等价类中选取典型代表数据外，通常还要着重测试边界值情况，应当选取正好等于、刚刚大于、或刚刚小于边界的值作为测试数据。 测试需求 它指软件测试员站在与用户相同角度上理解的需求，主要是确保需求的可测试性。同时找出软件需求和用户需求的偏差，并确保认可的偏差修改后体现在软件需求中，因为测试工作以《软件需求说明书》为基准，测试人员需要尽量保证《软件需求说明书》可以满足测试工作。 Bug 即软件缺陷，如错误，失效，失败等。 CMMI 软件能力成熟度模型CMMI，是由美国卡内基-梅隆大学软件工程研究所退出的评估软件能力与成熟度等级的一套标准。该标准基于众多软件专家的实践经验，侧重于软件开发过程管理能力的提高，是软件生产过程改进的标准和软件企业成熟度等级评估的标准。由于该标准不涉及具体的软件开发方法和技术，所以它具有广泛性、通用性和持久性。 CMMI的作用：概括地讲，过程能力成熟度模型集成CMMI的作用，主要是软件组织的能力评估和过程改进，它的应用领域具体体现在三个方面： 软件组织，用它来不断改进自身的软件过程管理能力 评估机构，用它来评估某软件组织当前软件能力成熟度级别 客户，用它来评价某承包商（软件外包商）的软件能力 CMMI的实质： 为了真正达到持续改进软件过程能力的目的，并以尽量低的成本获得高的效益，首先要弄清楚“过程”、“项目”、“组织”、“度量”等五个基本概念。 以“过程”为核心，抓软件组织的管理，即软件“组织”的过程改进 以“项目”为手段，抓团队开发过程的“活动”，即落实过程改进的措施 以“活动”记录为基础，抓软件过程的“度量”，即“度量”软件组织改进的情况 软件配置管理 软件配置管理SCM，是对软件开发过程中配置项的一组追踪和控制活动，它开始于软件开发之初，结束于软件淘汰之时。软件配置管理在软件过程管理中，占有特殊得到地位，也是项目管理的重要内容。无论是ISO9001、CMMI，还是软件企业文化，都非常强调配置管理。在大中型软件企业内部设置专职的配置管理员，在各个项目组内部设置兼职的配置管理员，引进配置管理电子工具，开展配置管理的日常工作。 CMMI阶段的成熟度等级 阶段模型的5个等级，称为成熟度等级ML，从ML1级到ML5级。 CMMI的等级 PA数目 管理特点 ML1:Initial（初始级） 0 过程不可预测且缺乏控制 ML2：Managed（已管理级） 7 过程为项目服务，即项目级管理 ML3：Defined（以定义级） 11 过程为组织服务，即组织级管理 ML4:Quantitatively Managed(定量管理级) 2 过程已度量和控制，即定量级管理 ML5：Optimizing（优化级） 2 集中于过程改进，即优化级管理 极限编程 极限编程（即XP）是一个周密而严谨的软件开发流程。XP从4个基本方面对软件项目进行改善：交流、简单、反馈和进取。 XP程序员与客户交流、与同事交流； 他们的设计简单而干净； 他们通过测试来得到反馈； 他们根据变化修改代码，并争取尽可能早地将软件交付给客户。 在此基础上，XP程序员能够勇于面对需求变化和技术变化，“船小好调头”，对需求变化和技术变化做出敏捷反应，把那个取得成功，是敏捷文化的特色和本质。 软件质量管理的三大支柱 软件质量保证SQA是一个过程，是CMMI和ISO9001的重要议题，是微软公司和IBM公司的重点课题，同样也是项目管理的重要内容。 软件质量：是供方提供的软件产品满足用户明确和隐含需求的能力特性的总和。 通常，人们将“质量标准”、“配置管理”、“质量测试”作为质量管理的三大支柱。 而将”SQA计划”、“SQA进度”、“SQA评审和审计”作为质量管理三大要素。 软件质量保证是一个质量管理过程，基本思想是“以事先预防为主，以事后纠偏为辅”，采取标本兼治的方法。]]></content>
      <categories>
        <category>软件工程</category>
      </categories>
      <tags>
        <tag>软件工程名词解释</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机网络体系结构]]></title>
    <url>%2F2019%2F06%2F10%2F%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%2F</url>
    <content type="text"><![CDATA[一、计算机网络分层结构两个系统中实体间的通信是一个很复杂的过程，为了降低协议设计和调试过程的复杂性，也为了便于对网络进行研究、实现和维护，促进标准化工作，通常对及时算计网络的体系结构以分层的形式进行建模。 我们将计算机网络的各层及其协议的集合称为网络的体系结构。 网络设计者以分层的方式组织协议以及实现这些协议的网络硬件和软件，每个协议就属于这些层次之一。某层向它的上一层提供服务，即所谓每一层的服务模型。例如，第n层提供的服务可能包括报文从网络的一边到另一边的可靠传送。这可能是通过使用第n-1层的边缘到边缘的不可靠报文传送，加上第n层的检测和重传丢失报文的功能来实现的。 计算机网络的体系结构通常都具有可分层的特性，它将复杂的大系统分为若干个较容易实现的层次。分层的基本原则如下： 每次都实现一种相对独立的功能，降低大系统的复杂度 各层之间界面自然清晰，易于理解，相互交流尽可能少 各层功能的精确定义独立于具体的实现方法，可以采用合适的技术来实现 整个分层结构应该促进标准化工作 在计算机网路的分层结构中，第n层中的活动元素通常被称为n层实体。具体来说，实体指任何可发送或接受信息的硬件或软件进程，通常是一个特定的软件模块。不同机器上的同一层称为对等层，同一层的实体称为对等实体。 在计算机网络体系结构的各个层次中，每个报文都分为两部分：一是数据部分，即SDU；二是控制信息部分，即PCI，它们共同组成PDU。 服务数据单元（SDU）：为完成用户所要求的功能而应传送的是数据。第n层的服务数据单元记为n-SDU。 协议控制信息（PCI）：控制协议操作的信息。第n层的协议控制信息记为n-PCI。 协议数据单元（PDU）：对等层次之间传送的数据单位称为该层的PDU。第n层的协议数据记为n-PDU。在实际的网络中，每层的协议数据单元都有一个通俗的名称，如物理层的PDU称为比特，链路层的PDU称为帧，网络层的PDU称为分组，传输层的PDU称为报文。 在各层间传输数据时，把从第n+1层收到的PDU作为第n层的SDU，加上第n层的PCI，变成了第n层的PDU，交给第n-1层后作为SDU发送，接收方接收时做相反处理。故可知三者的关系是n-SDU+n-PCI=n-PDU=(n-1)-SDU. 二、协议、接口、服务 协议 协议，就是规则的集合。在网络中要做到有条不紊地交换数据，就必须遵循一些事先约定好的规则，这些规则明规定了所交换的数据的格式及有关的同步问题。这些为进行网络中的数据交换而建立的规则、标准或约定称为网络协议。它是控制两个（或多个）对等实体进行通信的规则的集合，是水平的。不对等的实体之间没有协议。 接口 接口是同一结点内相邻两层之间交换信息的连接点，是一个系统内部的规定。每层只能为紧邻的层次之间定义接口，不能跨层定义接口。在典型的接口上，同一结点相邻两层的实体通过服务访问点（SAP）进行交互。服务是通过SAP提供给上层使用的，第n层的SAP就是第n+1层可以访问第n层服务的地方。 服务 服务是指下层为紧邻的上层提供的功能调用，它是垂直的。 上层使用下层所提供的服务时必须与下层交换一些命令，这些命令在OSI中称为服务原语。OSI将原语划分为4类：1）请求：由服务用户发往服务提供者，请求完成某项工作 2）指示：由服务提供者发往服务用户，提示用户做某件事 3）相应：由服务用户发往服务提供者，作为对指示的响应 4）证实：由服务提供者发往服务用户，作为对请求的证实 并非在一层内完成的全部功能都称为服务，只有那些能够被高一层实体“看得见”的功能才称为服务。 计算机网络提供的服务可按以下三种方式分类： （1）面向连接服务于无连接服务 在面向连接服务中，通信前双方必须先建立连接，分配相应的资源，以保证通信能正常进行，传输结束后释放连接和所占用的资源。因此这种服务可分为建立连接、数据传输和释放连接三个阶段。TCP就是一种面向连接服务的协议。 在无连接服务中，通信前双方不需要先建立连接，需要发送数据时可直接发送，把每个带有目的地址的包传送到线路上，由系统选定路线进行传输。这是一种不可靠的服务，这种服务常被描述为“尽最大可能交付”，它不能保证通信的可靠性。例如IP、UDP就是一种无连接服务的协议。 （2）可靠服务与不可靠服务 可靠服务是网络具有检错、纠错、应答机制，能保证数据正确、可靠地传送到目的地。 不可靠服务是指网络只是尽量正确、可靠地传送，而不能保证数据正确、可靠地传送到目的地，是一种尽力而为的服务。 （3）有应答服务和无应答服务 有应答服务是指接收方在收到数据后向发送方给出相应的应答，该应答由传输系统同内部自动实现，而不由用户实现。所发送的应答既可以是可乐定应答，也可以是否定应答，通常在接收到数据有错误时发送否定应答。文件传输服务就是一种有应答服务。 无应答服务是指接收方收到数据后不自动给出应答。若需要应答，则由高层实现。例如，对于WWW服务，客户端收到服务器发送的页面文件不给出应答。 三、ISO/OSI参考模型和TCP/IP模型 OSI参考模型 国际标准化组织（ISO）提出的网络体系结构模型，称为开放系统互联参考模型。通常简称为OSI模型。OSI有7层，自下而上依次是物理层、数据链路层、网络层、传输层、会话层、表示层、应用层。 低三层称为通信子网，它是为了联网而附加的通信设备，完成数据的传输功能；高三层统称为资源子网，它相当于计算机系统，完成数据的处理等功能。 1）物理层 物理层的传输单位是比特，任务是透明的传输比特流，功能是在物理媒体上为数据端设备透明地提供传输原始比特流。 物理层主要定义数据终端设备(DTE)和数据通信设备（DCE）的物理与逻辑连接方法，所以物理层协议也称为物理层接口标准，也称为规程。 2）数据链路层 数据链路层的传输单位是帧，任务是将网络层传来的IP数据报组装成帧。数据链路层的功能可以概括为成帧、差错控制、流量控制和传输管理。 典型的数据链路层协议有SDLC、HDLC、PPP、STP和帧中继等。 3）网络层 网络层的传输单位是数据报，它关心的是通信子网的运行控制，主要任务是把网络层的协议数据单元（分组）从源端传送到目的端，为分组交换网上的不同主机提供通信服务。关键问题是对分组进行路由选择，并实现流量控制、拥塞控制、差错控制和网际互联等功能。 网络层的协议有IP、IPX、ICMP、IGMP、ARP 、RARP、OSPF等 4）传输层 传输层也称为运输层，传输大单位是报文段（TCP）或用户数据报（UDP），传输层负责主机中两个进程之间的通信，功能是为端到端连接提供可靠的传输服务，为端到端连接提供流量控制、差错控制、服务质量、数据传输管理等服务。 数据链路层提供的是点对点的通信，传输层提供的是端到端的通信。 传输层的协议有TCP、UDP 5）会话层 会话层允许不同的主机上的各个进程之间进行通信。会话层利用传输层提供的端到端的服务向表示层提供它的增值服务。这种服务主要为表示层实体或用户进程建立连接并在连接上有序地传输数据，这就是会话，也称为建立同步(SYN)。 会话层负责管理主机间的会话进程，包括建立、管理及终止进程间的会话。会话层可以使用校验点使通信会话在通信失效时从校验点继续恢复通信，实现数据同步。 6）表示层 表示层主要用于处理在两个通信系统中交换信息的表示形式。不同机器采用的编码和表示方法不同，使用的数据结构也不同。为了使不同表示方法的数据和信息之间能互相交流，表示层采用抽象的标准方法定义数据结构，并采用标准的编码形式。数据压缩、加密和解密也是表示层可提供的数据表示交换功能。 7）应用层 应用层是OIS模型的最高层，是用户与网络的界面。应用层为特定类型的网络应用提供访问OSI环境的手段。因为用户的实际应用多种多样，这就要求应用层采用不同的应用协议来解决不同类型的应用要求，因此应用层是最复杂的一层，使用的协议也最多。 典型的应用层协议有用于文件传输的FTP、用于电子邮件的SMTP、用于万维网的HTTP等。 TCP/IP模型 TCP/IP模型从低到高依次是网络接口层（对应OSI参考模型中的物理层和数据链路层）、网际层、传输层和应用层（对应OSI模型的会话层、表示层、应用层）。 1）网络接口层 网络接口层的功能类似于OSI的物理层和数据链路层。它表示与物理网络的接口，但实际上TCP/IP本身并未真正描述这一部分，只是指出主机必须使用某种协议和网络连接，以便在其上传递IP分组。 2）网际层 网际层（主机-主机）是TCP/IP体系结构的关键部分。它和OSI网络层在功能上是非常相似的。网际层将分组发往任何网络，并为之独立地选择合适的路由，但它不保证各个分组有序地到达，各个分组的有序交付由高层负责。 3）传输层 传输层（应用-应用或进程-进程）的功能同样与OSI中的传输层类似，使得发送端和目的端主机的对等实体进行会话。传输层主要使用以下两种协议：（1） 传输控制协议（Transmission Control Protocol，TCP）。它是面向连接的，数据传输的单位是报文段，能够提供可靠的交付。 （2）用户数据报协议（User Datagram Protocol，UDP）。它是无连接的，数据传输的单位是用户数据报，不能保证提供可靠的交付，只能提供“尽最大努力交付”。 4）应用层（用户-用户）包含所有的高层协议。IP协议是因特网中的核心协议；TCP/IP可以为各种各样的应用提供服务，同时TCP/IP也允许在由各种网络构成的互联网上运行。 TCP/IP模型与OSI模型的比较 1）二者都采用分层的体系结构，分层的功能也大体相似 2）二者都基于独立的协议栈概念 3）二者都可以解决异构网络的互联，实现世界上不同厂家生产的计算机之间的通信 4）OSI模型最大的贡献是精确地定义了三个主要的概念：服务，协议和接口，与现代的面向对象程序设计思想非常吻合。而TCP/IP模型在这三个概念上却没有明确区分，不符合软件工程的思想 5）OSI模型产生在协议之前，没有偏向于任何特定的协议，通用性良好。TCP/IP模型产生于协议之后，实际是对协议的描述 6）TCP/IP在设计之初就考虑了多种异构网的互联问题，并将网际协议（IP）作为一个单独的重要层次。OSI模型最初只考虑到用一种标准的公用数据网络将不同的系统互联。OSI模型认识到网际协议IP的重要性后，只好在网络层中划分出一个子层来完成类似于TCP/IP模型中的IP功能 7）OSI模型在网络层支持无连接和面向连接的通信，但在传输层仅有面向连接的通信。而TCP/IP模型认为可靠性是端到端的问题，因此它在网际层仅有一种无连接的通信模式，但传输层支持无连接和面向连接两种模式。]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>网络体系结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[通信基础]]></title>
    <url>%2F2019%2F06%2F10%2F%E9%80%9A%E4%BF%A1%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[写在前面 物理层协议的主要任务就是确定与传输媒体的接口有关的一些特性，如下所述： 机械特性：指明接口所用接线器的形状和尺寸、引脚数目和排列、固定和锁定装置等。 电气特性：指明在接口电缆的各条线上出现的电压范围1. 功能特性：指明某条线上出现的某一电平代表何种意义。 过程特性：指明对于不同功能的各种可能事件的出现顺序。 一、数据通信的模型一个数据通信系统可划分为三大部分，即源系统（或发送端，发送方）、传输系统（或传输网络）和目的系统（或接收方、接收端）。 源系统一般包括两部分： 源点：源点设备产生要传输的数据。 发送器：通常源点生成的数字比特流要通过发送器编码之后才能在传输系统中进行传输。 目的系统一般包括两部分： 接收器：接收传输系统传送过来的信号，并把它转换为能够被目的设备处理的信息。 终点：终点设备从接收器获取传送来的数字比特流，然后进行信息输出。终点又称为目的站或信宿。 在源系统和目的系统之间的传输系统可以是简单的传输线路，也可以是连接在源系统和目的系统之间的复杂网络系统。 通信的目的是传送消息。 数据是消息的实体。 信号是数据的电器或电磁表现。根据信号中代表的消息的参数的取值方式不同，信号可分为两类： 模拟信号（或连续信号）——消息的参数的取值时连续的 数字信号（或离散信号）——消息的参数的取值时离散的。在使用时间域的波形表示数字信号时，代表不同离散数值的基本波形就称为码元。在使用二进制编码时，只有两种不同的码元，一种代表0状态，另一种代表1状态。 速率、波特与带宽 速率也称为数据率，指的是数据的传输速率，表示单位之间内传输的数据量。可以用码元传输速率和信息传输速率表示。 码元传输速率。又称码元速率，波形速率等，它表示单位时间内数字通信系统所传输的码元个数，单位是波特（Baud）。1波特表示数字通信系统每秒传输一个码元。这里的码元可以是多进制的，也可以是二进制的，但码元速率与进制数无关。 信息传输速率。又称信息速率，比特率等。它表示单位时间内数字通信系统传输的二进制码元数（即比特数），单位是比特/秒（b/s). 二、编码与调制 常用编码方式 要利用信道传输数据，必须将数据转换为能在传输媒体媒体上传送的信号。信道可以分为传送模拟信号的模拟信道和传送数字信号的数字信道两大类。 将数字数据转换为数字信号的过程称为编码。 将数字信号转换为模拟信号的过程称为调制。 归零制：正脉冲代表1，负脉冲代表0； 不归零制：正电平代表1，负电平代表0； 曼彻斯特编码：位周期中心的是上跳变代表0，位周期中心的下跳变代表1； 差分曼彻斯特编码：在每一位的中心处始终有跳变。位开始边界有跳变代表0，而位边界没有跳变代表1； 基本的调制方法 矩形脉冲波形的数字信号包含从直流开始的低频分量，被称为基带信号 在数字信道上直接传输基带信号的方法称为基带传输 基带信号往往包含较多的低频成分，甚至直流成分。而许多模拟信道仅能通过某一频率范围的信号，不能直接传输这种基带信号。因此必须对基带信号进行调制，使它能够在模拟信道中传输。 在很多情况下，需要使用载波进行调制，把基带信号的频率范围搬移到较高的频段以便在信道中传输。经过载波调制后的信号称为带通信号，而使用载波的调制称为带通调制。 最基本的带通调制的方法有：1）调幅（AM），即载波的增幅随基带数字信号而变化。 2）调频（FM），即载波的频率随着基带数字信号的变化而变化。 3）调相（PM），即载波的初始相位随基带数字信号而变化。 在数字通信中，调幅、调频和调相相应地称为幅移键控、频移键控和相移键控。实现调制和解调功能的设备称为调制解调器。 三、奈奎斯特定理与香农定理 奈奎斯特定理 奈奎斯特定理又称奈氏准则。它指出在理想低通（没有噪声、带宽有限）的信道中，极限码元速率为2W波特，其中W是理想低通信道的带宽，单位是Hz。若用V表示每个码元离散电平的数目（码元的离散电平数目是指有多少种不同的码元，比如有16种不同的码元，则需要有4位二进制位，因此数据传输率是码元传输率的4倍），则极限速率为 ​ 理想低通信道下的极限数据传输率=$2Wlog_2V$（单位为b/s) 对于奈氏准则，可以得出以下结论： 1）在任何信道中，码元传输的速率是有上限的。若传输速率超过此上限，就会出现严重的码间串扰问题，使得接收端不可能完全正确地识别码元。 2）信道的频带越宽(即通过的信号高频分量越多)，就可用更高的速率进行码元的有效传输。 3）奈氏准则给出了码元传输速率的限制，但是并未对信息传输速率给出限制，即未对一个码元可以对应多少个二进制位给出限制。 由于码元的传输速率受奈氏准则的制约，所以要提高数据的传输速率，就必须设法使每个码元携带更多个比特的信息量，此时就需要多元制的调制方法。 香农定理 香农定理给出了带宽受限且有高斯白噪声干扰的信道的极限数据传输率，当用此速率进行传输时，可以做到不产生误差。香农定理定义为： ​ 信道的极限数据传输率=$Wlog_2(1+S/N)$ 单位为b/s 式中，W为信道带宽，S为信道所传输信号的平均功率，N为信道内部的高斯噪声功率，$S/N$为信噪比，即信号的平均功率与噪声的平均功率之比。 对于香农定理，可以得出以下的结论：1）信道的带宽或信道中的信噪比越大，信息的极限传输速率越高。 2）对一定的传输带宽和一定的信噪比，信息传输速率的上限是确定的。 3）只要信息的传输速率低于信道的极限传输速率，就能找到某种方法来实现无差错的传输。 4）香农定理得出的是极限信息传输速率，实际信道能达到的传输速率比它低不少。 从香农定理可以看出，若信道带宽W或信噪比S/N没有上限，则信道的极限信息传输速率也没有上限。 奈氏准则只考虑了带宽与极限码元速率的关系，而香农定义不仅考虑了带宽，而且考虑到了信噪比。这从另一个侧面表明，一个码元对应的二进制位数是有限的。 四、传输方式 并行传输与串行传输 并行传输，是指一次发送n个比特而不是一个比特，为此，在发送端和接收端之间需要有n条传输线路。 串行传输，是指数据是一个比特一个比特发送的，为此，发送端和接收端之间只需要一条传输线路。 异步传输与同步传输 异步传输以字节为独立的传输单位，字节之间的时间间隔不是固定的，接收端仅在每个字节的起始处对字节内的比特实现同步。为此，通常需要在每个字节前后分别加上起始位和结束位，这里的异步是指在字节级上的异步，但是字节中的每个比特仍然要同步，它们的持续时间是相同的。 采用同步传输方式时，数据块以稳定的比特流形式传输，字节之间没有间隔，也没有起始位和结束位。由于不同设备的时钟频率存在一定差异，为避免在传输大量数据的过程中累积误差所导致的错误，要采取技术使得收发双方的时钟保持同步。实现收发双方时钟同步的方法有两种，即外同步和内同步。 外同步，是在发送端和接收端之间提供一条单独的时钟线，发送端在发送数据信号的同时，另外发送一条时钟同步信号。接收端根据接收到的时钟同步信号来校正时间基准，实现收发双方之间的同步。 内同步，是发送端将时钟同步信号编码到发送数据中一起传输，如曼彻斯特编码与差分曼彻斯特编码都含有时钟编码，具有自同步能力。 单工、半双工、全双工 1）单向通信，又称为单工通信，即只能有一个方向的通信而没有反方向的交互。如广播等。 2）双向交替通信，又称半双工通信，即通信的双方都可以发送信息，但不能双方同时发送。这种通信方式是一方发送另一方接收，过一段时间再反回来。 3）双向同时通信，又称为全双工通信，即通信的双方可以同时发送和接收信息。]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>通信</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机网络概述]]></title>
    <url>%2F2019%2F06%2F10%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%A6%82%E8%BF%B0%2F</url>
    <content type="text"><![CDATA[写在前面一般认为，计算机网路是一个将分散的、具有独立功能的计算机系统，通过通信设备与线路连接在一起，由功能完善的软件实现资源共享和信息传递的系统。简言之，计算机网络就是一些互联的、自治的计算机系统的集合。 一、计算机网络在计算机的不同发展阶段，网络有不同的定义，这些定义反映了当时网络技术的发展水平。分为三类： 广义观点 广义观点认为，只要是能实现远程信息处理的系统或能进一步达到资源共享的系统，，都是计算机网络。 资源共享观点 资源共享观点认为，计算机网络是“以能够相互共享资源的方式互联起来的自治计算机系统的集合”。这个定义符合目前计算机网络的基本特征。 用户透明性观点 这种观点认为，存在一个能为用户自动管理资源的网络操作系统。它能够调用用户所需要的资源，而整个网络就像是一个大的计算机系统一样对用户是透明的。用户透明性观点的定义描述了一个分布式系统，它是网络未来发展追求的目标。 二、计算机网络的组成从不同的角度，可以将计算机网路的组成分为以下几类： 从组成部分上来看，一个完整的计算机网络主要由硬件、软件、协议散发部分组成。硬件主要由主机（端系统）、通信链路（如双绞线、光纤）、交换设备（如交换机、路由器）和通信处理机（如网卡）等组成。软件主要包括各种实现资源共享的软件和方便用户使用的各种工具软件。软件部分多属于应用层。协议是计算机网络的核心。 从工作方式看，计算机网络可分为边缘部分和核心部分。边缘部分由所有连接到因特网上、供用户使用的端系统组成，用来进行通信和资源共享。核心部分由大量的网络和连接这些网络的路由器组成，为边缘部分提供连通性和交换服务。 从功能组成上看，计算机网络由通信子网和资源子网构成。通信子网由各种传输介质、通信设备和相应的网络协议组成，它使网络具有数据传输、交换、控制和存储的能力，实现联网计算机之间的数据通信。资源子网是实现资源共享功能的设备及其软件的集合，向用户提供共享其他其他计算机上的硬件资源、软件资源和数据资源的服务。 三、计算机网络的功能计算机网路的功能很多，现如今的很多应用都与网络有关。主要有下面5个部分。 数据通信 它是计算机网络最基本也是最重要的功能，用来实现联网计算机之间的各种信息的传输，并将分散在不同地理位置的计算机联系起来，进行统一的调配、控制和管理。 资源共享 资源共享可以是软件共享、数据共享，也可以是硬件共享。使计算机网络中的资源互通有无，分工协作，从而极大地提高了硬件资源、软件资源和数据资源的利用率 分布式处理 当计算机网络中的某个计算机负荷过重时，可以将其处理的某个复杂的任务分配给网络中的其他计算机系统，从而利用空闲资源以提高整个系统的利用率 提高可靠性 计算机网络中的各台计算机通过网络互为替代机 负载均衡 将工作任务均衡地分配给计算机网络中的各台计算机。 四、计算机网络的分类 按分布范围分： 1) 广域网（WAN）。任务是提供长距离通信，运送主机所发送的数据。 2）城域网（MAN）。城域网的覆盖范围可以跨越几个街区甚至几个城市，大多采用以太网技术。 3）局域网（LAN）。局域网一般用微机或工作站通过高速线路相连，覆盖范围较小。传统上，局域网使用广播技术，而广域网使用交换技术。 4）个人局域网（PAN）。在个人工作的地方将消费电子设备用无线技术连接起来的网络。 按传输技术分： 1）广播式网络。所有联网计算机都共享一个公共通信信道。当一台计算机利用共享通信信道发送报文分组时，所有其他的计算机都会“收听”到这个分组。接收到该分组的计算机将通过检查目的地址来决定是否接收该分组。 局域网基本上都采用广播式通信技术，广域网中的无线，卫星通信网络也采用广播式通信技术。 2）点对点网络。每条物理线路连接一对计算机。如果通信的两台计算机之间没有直接连接线路，那么它们之间的分组传输就要通过中间结点的接收、存储和转发，直至目的结点。 是否采用分组存储转发与路由选择机制是点对点网络与广播式网络的重要区别，广域网基本都属于点对点网络。 按拓扑结构分: 网络拓扑结构是指由网中结点（路由器、主机等）与通信线路（网线）之间的几何关系表示的网络结构，主要指通信子网的拓扑结构。 按网络的拓扑结构，主要分为星形、总线形、环形和网状形网络等。星形、总线形和环形网络多用于局域网，网状网络多用于广域网。 1）星形网络。每个终端或计算机都以单独的线路与中央设备相连。中央设备早期是计算机，现在一般是交换机或路由器。星形网络便于集中控制和管理，因为端用户之间的通信必须通过中间设备。缺点是成本高，中心节点对故障敏感。 2）总线形网络。用单根传输线将计算机连接起来。总线形网络的优点是建网容易，增减节点方便，节省线路。缺点是重负载时通信效率不高，总线任意一处对故障敏感。 3）环形网络。所有计算机接口设备连接成一个环。环形网络最典型的例子是令牌环局域网。环可以是单环，也可以是双环，环中信号是单向传输的。 4）网状网络。一般情况下，每个结点至少有两条路径与其他节点相连，多用于广域网中。有规则型和非规则型。其优点是可靠性高，缺点是控制复杂，线路成本高。 按使用者分: 1）公用网。指电信公司出资建造的大型网络。 2）专用网。指某个部门为了满足本单位特殊业务的需要而建造的网络，这种网络不对单位以外的人开放。 按交换技术分： 1）电路交换网络。在源结点和目的结点之间建立一条专用的通路用于传送数据，包括建立连接、传输数据和断开连接三个阶段。最典型的电路交换网络是传统电话网络。 该类网络的主要特点是整个报文的比特流连续地从源点直达终点，好像是在一条管道中传送。优点是数据直接传送，时延小。缺点是线路利用率低、不能充分利用线路容量，不便于进行差错控制。 2）报文交换网络。用户数据加上源地址、目的地址、校验码等辅助信息，然后封装成报文。整个报文传送到相邻结点全部存储后，再转发到下一个结点，重复这一过程直到到达目的结点。每个报文可以单独选择到达目的结点的路径。 报文交换网络也称存储-转发网络，主要特点是整个报文先传送到相邻结点，全部存储后查找转发表，转发到下一个结点。优点是可以较为充分的利用线路容量，可以实现不同链路之间不同数据率的转换，可以实现格式转换，可以实现一对多，多对一的访问，可以实现差错控制。缺点是增大了资源开销，增加了缓冲时延，需要额外的控制机制来保证多个报文的顺序不乱序，缓冲区难以管理。 3）分组交换网络。也称包交换网络。其原理是将数据分为较短的固定长度的数据块，在每个数据块中加上目的地址、源地址等辅助信息组成分组（包），以存储-转发方式传输。 其主要特点是单个分组传送到相邻结点，存储后查找转发表，转发到下一个结点。除具备报文交换网络的优点外，分组交换网络还具有自身的优点：缓冲易于管理；包的平均时延更小，网络占用的平均缓冲更少；易于标准化；更适合应用。现在的主流网络基本上都可视为分组交换网络。 按传输介质分： 传输介质可分为有线和无线两大类，故网络可分为有线网络和无线网络。有线网络又分为双绞线网络，同轴电缆网络等。无线网络可分为蓝牙、微波、无线电等。 五、计算机网络的的性能指标性能指标从不同的方面来度量计算机网络的性能。 速率 速率是数据的传送速率，它也称为数据率或比特率。 带宽 本来表示某个信号具有的频带宽度，单位是赫兹（Hz），而在计算机网络分钟，带宽用来表示网络的通信线路所能传送数据的能力，单位是比特/秒（b/s） 吞吐量 也称为吞吐率，表示单位时间内通过某个网络（或信道、接口）的数据量。 时延 时延是指一个数据（一个报文或分组，甚至比特）从网路（或链路）的一端传送到另一端所需要的时间。时延有时称为延迟或迟延。 1）发送时延，是主机或路由器将分组发送到通信线路上所需要的时间。 1发送时延=分组长度/发送速率 2）传播时延，是电磁波在信道中传播需要一定的距离而花费的时间。 1传播时延=信道长度/电磁波在信道上的传播速率 3）处理时延，主机或路由器收到分组时要花费一定的时间进行处理，例如，分析分组的首部、从分组中提取数据部分、进行差错检验或查找适当的路由等，这就产生了处理时延。 4）排队时延，分组在进入路由器后要先在输入队列在排队等待处理。路由器确定转发端口后，还要在输出队列中排队等待转发，这就产生了排队时延。 这样，分组从一个结点转发到另一个结点转发到另一个结点所经历的时延就是以上4种时延之和。 1总时延=发送时延+传播时延+处理时延+排队时延 丢包率 即分组丢失率，是指在一定的时间范围内，分组在传输过程中丢失的分组数量和总的分组数量的比率。 分组丢失的两种情况：一是因为传输过程中出现比特级差错被结点丢弃。二是因为分组交换机队列溢出。 利用率 令D0表示网络空闲时的时延，D表示网络当前时延，那么在适当的假定条件下，利用率可表示为：D=D0/1-U。 信道或网络利用率过高会产生非常大的时延。 时延带宽积 指发送端连续发送数据且发送的第一个比特即将到达终点时，发送端已经发出的比特数，即时延带宽积=传播时延*信道带宽。]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[顺序循环链表的实现]]></title>
    <url>%2F2019%2F03%2F31%2F%E9%A1%BA%E5%BA%8F%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8%E7%9A%84%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[写在前面&emsp;&emsp;队列（Queue)是一种特殊的线性表，是一种只允许在表的一端进行插入操作，在表的另一端进行删除操作的线性表。表中允许进行插入操作的一端称为队尾，允许进行删除操作的一端为队头。队头和队尾分别由队头指示器和队尾指示器指示。队列的插入操作通常称为入队，队列的删除操作通常称为出队。当队列中没有元素时，为空队列。&emsp;&emsp;根据队列的定义，每次进队列的数据元素都放在原来的队尾之后成为新的队尾元素，每次出队列得到数据元素都是原来的队头元素。这样，最先入队的数据元素总是最先出队，所以队列也被称为先进先出表。&emsp;&emsp;对队列的操作主要有：初始化建立队列、入队列、出队列、取队头元素、判断队列是否为空等操作。 1.顺序队列的类定义 123456789101112131415161718192021const int maxsize = 10;template&lt;class T&gt;class Queue&#123;public: Queue();//构造函数 ~Queue() &#123;&#125;;//析构函数 void insert(const T&amp;item);//入队 T delet();//出队列 T readFront() const;//读队头元素 bool empty() const;//判断队列是否为空 void clearQueue();//清空队列 int getsize() const;//获取队列长度 void display() const;//输出队列中的元素private: T data[maxsize]; int front; int rear; int count;&#125;; 2.顺序队列类的实现 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970template&lt;class T&gt;inline Queue&lt;T&gt;::Queue()&#123; front = 0; rear = 0; count = 0;&#125;template&lt;class T&gt;inline void Queue&lt;T&gt;::insert(const T &amp; item)&#123; if (count == maxsize) &#123; cout &lt;&lt; "Queue is full" &lt;&lt; endl; exit(1); &#125; count++; data[rear] = item; rear = ((rear + 1) == maxsize) ? 0 : (rear + 1); &#125;template&lt;class T&gt;inline T Queue&lt;T&gt;::delet()&#123; if (count&lt;=0) &#123; cout &lt;&lt; "Queue is empty" &lt;&lt; endl; &#125; count--; T p = data[front]; front = ((front + 1) == maxsize) ? 0 : (front + 1); return p;&#125;template&lt;class T&gt;inline T Queue&lt;T&gt;::readFront() const&#123; return data[front];&#125;template&lt;class T&gt;inline bool Queue&lt;T&gt;::empty() const&#123; return (count == 0);&#125;template&lt;class T&gt;inline void Queue&lt;T&gt;::clearQueue()&#123; count = 0; front = rear = 0;&#125;template&lt;class T&gt;inline int Queue&lt;T&gt;::getsize() const&#123; return count;&#125;template&lt;class T&gt;inline void Queue&lt;T&gt;::display() const&#123; int i = 0; while (i != count) &#123; cout &lt;&lt; i &lt;&lt; "号元素：" &lt;&lt; data[i] &lt;&lt; endl; i++; &#125;&#125; 3.测试主函数 1234567891011121314151617181920void test()&#123; Queue&lt;int&gt; queue; for (int i = 0; i &lt; 10; i++) &#123; queue.insert(i); &#125; cout &lt;&lt;"队列的长度为："&lt;&lt; queue.getsize() &lt;&lt; endl; queue.display(); cout &lt;&lt;"队头元素为："&lt;&lt; queue.readFront() &lt;&lt; endl; cout &lt;&lt; "元素："&lt;&lt;queue.delet()&lt;&lt;"已删除" &lt;&lt; endl;&#125;int main()&#123; test(); system("pause"); return EXIT_SUCCESS;&#125; 输出结果如下：]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>顺序循环链表</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[链式队列的实现]]></title>
    <url>%2F2019%2F03%2F31%2F%E9%93%BE%E5%BC%8F%E9%98%9F%E5%88%97%E7%9A%84%E5%AE%9E%E7%8E%B0-1%2F</url>
    <content type="text"><![CDATA[写在前面&emsp;&emsp;链式队列是队列的链式存储结构表示。队列是操作受限的表，队列有队头和队尾，插入元素的一端称为队尾，删除元素的一端称为队头。这和一般排队的概念一样，后来的人排在队尾，首先对队头的人进行服务，对队头的人服务后，原当前队头后的人就排在了当前队头。新来的人排在队尾后，原队尾的人就不再是当前队尾了，新来的人就成了当前队尾。&emsp;&emsp;链式队列的队头指针指在队列的当前队头节点位置，队尾指针指在队列的当前队尾节点位置。不带头节点的链式队列，出队列时可直接删除头指针所指的节点，因此，链式队列不带头指针时更加方便。 1.链式队列节点类的定义和实现 12345678910111213141516171819202122template&lt;class T&gt;class LinkQueue;template&lt;class T&gt;class QueueNode&#123; friend class LinkQueue&lt;T&gt;;public: T data; QueueNode&lt;T&gt;(const T&amp; item, QueueNode&lt;T&gt; *ptrNext = NULL); ~QueueNode() &#123;&#125;;private: QueueNode&lt;T&gt; *next;&#125;;template&lt;class T&gt;inline QueueNode&lt;T&gt;::QueueNode(const T &amp; item, QueueNode&lt;T&gt;* ptrNext)&#123; this-&gt;data = item; this-&gt;next = ptrNext;&#125; 2.链式队列类的定义 1234567891011121314151617181920template&lt;class T&gt;class LinkQueue&#123;public: LinkQueue();//构造函数 ~LinkQueue();//析构函数 void insert(const T&amp; item);//入队 T delet();//出队 T readFront() const;//读队头元素 bool empty() const;//判断队列是否为空 void clearQueue();//清空队列 int getSize() const;//取队列长度 void display() const;//输出队列元素private: QueueNode&lt;T&gt; *front;//指向队头的指针 QueueNode&lt;T&gt; *rear;//指向队尾的指针 int size;&#125;; 3.链式队列类的实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990template&lt;class T&gt;inline LinkQueue&lt;T&gt;::LinkQueue()&#123; size = 0; front = rear = NULL;&#125;template&lt;class T&gt;inline LinkQueue&lt;T&gt;::~LinkQueue()&#123; clearQueue(); front = rear = NULL;&#125;template&lt;class T&gt;inline void LinkQueue&lt;T&gt;::insert(const T &amp; item)&#123; QueueNode&lt;T&gt; *new_node = new QueueNode&lt;T&gt;(item); if (rear != NULL) &#123; rear-&gt;next = new_node; &#125; rear = new_node; if (front == NULL) &#123; front = new_node; &#125; size++;&#125;template&lt;class T&gt;inline T LinkQueue&lt;T&gt;::delet()&#123; if (size == 0) &#123; cout &lt;&lt; "Queue is empty" &lt;&lt; endl; exit(1); &#125; T member = front-&gt;data; QueueNode&lt;T&gt; *p = front-&gt;next; delete front; front = p; size--; return member;&#125;template&lt;class T&gt;inline T LinkQueue&lt;T&gt;::readFront() const&#123; return front-&gt;data;&#125;template&lt;class T&gt;inline bool LinkQueue&lt;T&gt;::empty() const&#123; return (size==0);&#125;template&lt;class T&gt;inline void LinkQueue&lt;T&gt;::clearQueue()&#123; QueueNode&lt;T&gt; *p1, *p2; p1 = front; while (p1 != NULL) &#123; p2 = p1; p1 = p1-&gt;next; delete p2; &#125; size = 0;&#125;template&lt;class T&gt;inline int LinkQueue&lt;T&gt;::getSize() const&#123; return size;&#125;template&lt;class T&gt;inline void LinkQueue&lt;T&gt;::display() const&#123; QueueNode&lt;T&gt; *p = front; int i = 0; while (p != NULL) &#123; cout &lt;&lt; "第" &lt;&lt; i &lt;&lt; "号元素为：" &lt;&lt; p-&gt;data &lt;&lt; endl; i++; p = p-&gt;next; &#125;&#125; 4.测试主函数 123456789101112131415161718192021222324252627282930313233343536373839404142434445void test()&#123; LinkQueue&lt;int&gt; queue; for (int i = 0; i &lt; 10; i++) &#123; queue.insert(i * 10); &#125; cout &lt;&lt; "队列长度为：" &lt;&lt; queue.getSize() &lt;&lt; endl; queue.display(); cout &lt;&lt; "栈顶元素为：" &lt;&lt; queue.readFront() &lt;&lt; endl; for (int i = 0; i &lt; 10; i++) &#123; cout &lt;&lt; "元素：" &lt;&lt; queue.delet() &lt;&lt; "被删除" &lt;&lt; endl; &#125; cout &lt;&lt; "队列长度为：" &lt;&lt; queue.getSize() &lt;&lt; endl;&#125;int main()&#123; test(); system("pause"); return EXIT_SUCCESS;&#125;void test()&#123; LinkQueue&lt;int&gt; queue; for (int i = 0; i &lt; 10; i++) &#123; queue.insert(i * 10); &#125; cout &lt;&lt; "队列长度为：" &lt;&lt; queue.getSize() &lt;&lt; endl; queue.display(); cout &lt;&lt; "栈顶元素为：" &lt;&lt; queue.readFront() &lt;&lt; endl; for (int i = 0; i &lt; 10; i++) &#123; cout &lt;&lt; "元素：" &lt;&lt; queue.delet() &lt;&lt; "被删除" &lt;&lt; endl; &#125; cout &lt;&lt; "队列长度为：" &lt;&lt; queue.getSize() &lt;&lt; endl;&#125;int main()&#123; test(); system("pause"); return EXIT_SUCCESS;&#125; 输出结果如下：]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>队列</tag>
        <tag>链式队列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[双向循环链表]]></title>
    <url>%2F2019%2F03%2F28%2F%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[写在前面&emsp;&emsp;双向循环链表（Double Circular Linked List)是每个节点有前趋指针和后继指针，且后继指针和前趋指针各自构成自己的单循环链表的链表。&emsp;&emsp;在单链表中查找当前节点的后继节点并不困难，可以通过当前节点的next指针进行，但要查找当前节点的前趋节点就要从头指针head开始重新进行。对于一个要进行频繁查找当前节点的后继节点和当前节点的前趋节点的应用来说，使用单链表的时间效率是非常低的，双向链表是有效解决这类问题的选择。&emsp;&emsp;在双向链表中，每个节点包括三个域，分别是data,next,prior。其中data为数据域，next为后继节点指针，prior为前趋节点指针。&emsp;&emsp;双向链表通常均为双向循环链表，这是因为读双向循环链表，不论是插入还是删除，对第一个节点、最后一个节点的操作和对链表中间任意一个节点的操作过程是一样的。而双向非循环链表对这些节点的操作是不同的。 1.节点类的定义和实现 1234567891011121314151617181920212223242526template&lt;class T&gt;class DCirlist;template&lt;class T&gt;class DLnode&#123; friend class DCirlist&lt;T&gt;;public: T data; //构造函数，无数据域的头结点 DLnode&lt;T&gt;(DLnode&lt;T&gt; *ptrn = NULL, DLnode&lt;T&gt; *ptrp = NULL)&#123;&#125;; //构造函数，非头节点的节点 DLnode&lt;T&gt;( T item, DLnode&lt;T&gt; *ptrn = NULL, DLnode&lt;T&gt; *ptrp = NULL); //析构函数 ~DLnode() &#123;&#125;;private: DLnode&lt;T&gt; *next; DLnode&lt;T&gt; *prior;&#125;;template&lt;class T&gt;inline DLnode&lt;T&gt;::DLnode(T item, DLnode&lt;T&gt;* ptrn, DLnode&lt;T&gt;* ptrp)&#123; this-&gt;data = item; this-&gt;next = ptrn; this-&gt;prior = ptrp;&#125; &emsp;&emsp;双向循环链表只是在单循环链表的基础上又增加了一个指向前趋节点的指针，而且指向前趋节点指针也构成了自己的单循环链表。双循环链表的定义与单循环链表的定义非常相似。 2.双向循环链表类的定义 1234567891011121314151617181920212223242526272829template &lt;class T&gt;class DCirlist&#123;public: DCirlist();//构造函数 ~DCirlist();//析构函数 int listsize() const;//返回链表长度 bool empty() const;//判断链表是否为空 DLnode&lt;T&gt; *index(int pos) const;//返回指向第pos个节点的指针 void insert(const T &amp;item, int pos);//在第pos个节点插入item T del(int pos);//删除第pos个节点，并返回数据域 T getdata(int pos) const;//返回第pos个节点的值 void clearlist();//清空表 DLnode&lt;T&gt; *reset(int pos = 0); DLnode&lt;T&gt; *next(); DLnode&lt;T&gt; *prior(); bool EndOfList() const;//是否到链表尾 bool nextEndoflist() const;//currPtr-&gt;next是否到链表尾 bool PriorEndoflist() const;//currPtr-&gt;prior是否到链表尾 T deleprior();//删除currPtr节点，新currPtr是原currPtr的前趋，返回数据域private: DLnode&lt;T&gt; *head; DLnode&lt;T&gt; *currPtr; int size;&#125;; 3.双向循环链表类的实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178template&lt;class T&gt;inline DCirlist&lt;T&gt;::DCirlist()&#123; head = new DLnode&lt;T&gt;(); head-&gt;next = head; head-&gt;prior = head; size = 0;&#125;template&lt;class T&gt;inline DCirlist&lt;T&gt;::~DCirlist()&#123; clearlist(); delete head; head = NULL;&#125;template&lt;class T&gt;inline int DCirlist&lt;T&gt;::listsize() const&#123; return size;&#125;template&lt;class T&gt;inline bool DCirlist&lt;T&gt;::empty() const&#123; return (size == 0);&#125;template&lt;class T&gt;inline DLnode&lt;T&gt;* DCirlist&lt;T&gt;::index(int pos) const&#123; if (pos == -1) &#123; return head; &#125; if (pos&lt;0 || pos&gt;size) &#123; cout &lt;&lt; "illegal operator" &lt;&lt; endl; exit(1); &#125; int i = 0; DLnode&lt;T&gt; *p = head-&gt;next; while (i &lt; pos&amp;&amp;p != head) &#123; p = p-&gt;next; i++; &#125; return p;&#125;template&lt;class T&gt;inline void DCirlist&lt;T&gt;::insert(const T &amp; item, int pos)&#123; DLnode&lt;T&gt; *p = index(pos-1); DLnode&lt;T&gt; *new_node = new DLnode&lt;T&gt;(item, NULL, NULL); new_node-&gt;prior = p; p-&gt;next-&gt;prior = new_node; new_node-&gt;next = p-&gt;next; p-&gt;next = new_node; size++;&#125;template&lt;class T&gt;inline T DCirlist&lt;T&gt;::del(int pos)&#123; if (size == 0) &#123; cout &lt;&lt; "list is empty" &lt;&lt; endl; exit(1); &#125; if (pos&lt;0 || pos&gt;size) &#123; cout &lt;&lt; "illegal operator" &lt;&lt; endl; exit(1); &#125; DLnode&lt;T&gt; *p = index(pos); p-&gt;prior-&gt;next = p-&gt;next; p-&gt;next-&gt;prior = p-&gt;prior; T data = p-&gt;data; delete p; size--; return data;&#125;template&lt;class T&gt;inline T DCirlist&lt;T&gt;::getdata(int pos) const&#123; DLnode&lt;T&gt; *p = index(pos); return p-&gt;data;&#125;template&lt;class T&gt;inline void DCirlist&lt;T&gt;::clearlist()&#123; DLnode&lt;T&gt; *p1, *p2; p1 = head-&gt;next; while (p1 != head) &#123; p2 = p1; p1 = p1-&gt;next; delete p2; &#125; size = 0;&#125;template&lt;class T&gt;inline DLnode&lt;T&gt;* DCirlist&lt;T&gt;::reset(int pos)&#123; if (pos == -1) &#123; return head; &#125; if (pos&lt;0 || pos&gt;size) &#123; cout &lt;&lt; "illegal operator" &lt;&lt; endl; exit(1); &#125; int i = 0; currPtr = head-&gt;next; while (i &lt; pos&amp;&amp;currPtr != head) &#123; currPtr = currPtr-&gt;next; i++; &#125; return currPtr;&#125;template&lt;class T&gt;inline DLnode&lt;T&gt;* DCirlist&lt;T&gt;::next()&#123; if (currPtr!= NULL) &#123; currPtr = currPtr-&gt;next; &#125; return currPtr; &#125;template&lt;class T&gt;inline DLnode&lt;T&gt;* DCirlist&lt;T&gt;::prior()&#123; if (currPtr != NULL) &#123; currPtr = currPtr-&gt;prior; &#125; return currPtr;&#125;template&lt;class T&gt;inline bool DCirlist&lt;T&gt;::EndOfList() const&#123; return (currPtr == head);&#125;template&lt;class T&gt;inline bool DCirlist&lt;T&gt;::nextEndoflist() const&#123; return (currPtr-&gt;next == head);&#125;template&lt;class T&gt;inline bool DCirlist&lt;T&gt;::PriorEndoflist() const&#123; return (currPtr-&gt;prior == head);&#125;template&lt;class T&gt;inline T DCirlist&lt;T&gt;::deleprior()&#123;//删除当前节点的前一节点 DLnode&lt;T&gt; *p = currPtr-&gt;prior; currPtr-&gt;prior-&gt;next = currPtr-&gt;next; currPtr-&gt;next-&gt;prior = currPtr-&gt;prior; T data = currPtr-&gt;data; delete currPtr; size--; currPtr = p; return currPtr;&#125; 4.测试主函数 1234567891011121314151617181920212223242526272829303132void test()&#123; DCirlist&lt;int&gt; list; for (int i = 0; i &lt; 10; i++) &#123; list.insert(i * 10, i); &#125; cout &lt;&lt; "list中元素的个数为：" &lt;&lt; list.listsize() &lt;&lt; endl; DLnode&lt;int&gt; *p = list.reset(); while (!list.EndOfList()) &#123; cout &lt;&lt; p-&gt;data &lt;&lt; endl; p = list.next(); &#125; p = list.next(); cout &lt;&lt; list.del(1) &lt;&lt; "已被删除" &lt;&lt; endl; cout &lt;&lt; "list中元素的个数为：" &lt;&lt; list.listsize() &lt;&lt; endl; while (!list.EndOfList()) &#123; cout &lt;&lt; p-&gt;data &lt;&lt; endl; p = list.next(); &#125; cout &lt;&lt; list.getdata(1) &lt;&lt; endl; cout &lt;&lt; list.index(2)-&gt;data &lt;&lt; endl;&#125;int main()&#123; test(); system("pause"); return EXIT_SUCCESS;&#125; 输出结果如下：]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>双向循环链表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[单循环链表]]></title>
    <url>%2F2019%2F03%2F28%2F%E5%8D%95%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[写在前面&emsp;&emsp;单循环链表，简称循环链表（circular linked list)，是表的一种链式存储结构。&emsp;&emsp;设p是指向循环链表的指针，currPtr是当前指向对的循环链表的指针，head是指向循环链表的头指针，与链表判断是否到达链尾相比，循环链表中判断是否到达链表尾的条件是：p!=head或者是currPtr!=head。所以，循环链表类中成员函数的实现与链表类中的成员函数的实现差别不大，只是把p!=null换成了p!=head，把currPtr!=null换成了currptr!=head. 1.节点类的定义和实现 1234567891011121314151617181920212223242526template&lt;class T&gt;class CirList;template&lt;class T&gt;class ListNode&#123; friend class CirList&lt;T&gt;;//声明友元类public: T data;//数据域 ListNode(ListNode&lt;T&gt; *ptrNext = NULL);//构造函数，用于构造头节点，头节点没有data参数 ListNode(const T &amp;item, ListNode&lt;T&gt; *ptrNext = NULL);//构造函数，主要用于构造非头节点的节点 ~ListNode() &#123;&#125;;//析构函数private: ListNode&lt;T&gt; *next;//指向下一节点的指针&#125;;template&lt;class T&gt;inline ListNode&lt;T&gt;::ListNode(ListNode&lt;T&gt;* ptrNext) :next(ptrNext)&#123;&#125;template&lt;class T&gt;inline ListNode&lt;T&gt;::ListNode(const T &amp; item, ListNode&lt;T&gt;* ptrNext)&#123; this-&gt;data = item; this-&gt;next = ptrNext;&#125; 2.循环链表类的定义 12345678910111213141516171819202122232425262728template &lt;class T&gt;class CirList&#123;public: CirList();//构造函数 ~CirList();//析构函数 int listsize();//长度 bool listempty() const;//是否为空 ListNode&lt;T&gt; *index(int pos);//返回指向位置pos的指针 void insert(const T&amp; item, int pos);//在pos节点前插入一个节点 T del(int pos);//删除第pos个节点 T getdata(int pos) const;//返回pos节点的值域 void clearlist();//清空表为初始状态 ListNode&lt;T&gt; *reset();//currptr指向节点pos并返回currptr ListNode&lt;T&gt; *next();//currptr指向下一节点并返回currptr bool EndOfList() const;//判断是否到了尾部 ，currptr==head bool nextEndofList() const;//currptr-&gt;next是否链表尾 T delAfter();//删除currptr-&gt;next所指节点并返回被删除节点的dataprivate: ListNode&lt;T&gt; *head;//表头指针 int size;//链表的节点个数 ListNode&lt;T&gt; *currPtr;//当前节点指针&#125;; 3.循环链表类的实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146template&lt;class T&gt;inline CirList&lt;T&gt;::CirList()&#123; head = new ListNode&lt;T&gt;(); size = 0; head-&gt;next = head;&#125;template&lt;class T&gt;inline CirList&lt;T&gt;::~CirList()&#123; clearlist(); delete head; head = NULL; &#125;template&lt;class T&gt;inline int CirList&lt;T&gt;::listsize()&#123; return size;&#125;template&lt;class T&gt;inline bool CirList&lt;T&gt;::listempty() const&#123; return (size == 0);&#125;template&lt;class T&gt;inline ListNode&lt;T&gt;* CirList&lt;T&gt;::index(int pos)&#123; if (pos == -1) &#123; return head; &#125; if (pos&lt;0 || pos&gt;size) &#123; cout &lt;&lt; "illegal operator" &lt;&lt; endl; exit(1); &#125; currPtr = head-&gt;next; int i = 0; while (currPtr != NULL &amp; i &lt; pos) &#123; currPtr = currPtr-&gt;next; i++; &#125; return currPtr;&#125;template&lt;class T&gt;inline void CirList&lt;T&gt;::insert(const T &amp; item, int pos)&#123; if (pos&lt;0 || pos&gt;size) &#123; cout &lt;&lt; "illegal operator" &lt;&lt; endl; exit(1); &#125; ListNode&lt;T&gt; *p = index(pos - 1); ListNode&lt;T&gt; *newnode = new ListNode&lt;T&gt;(item, p-&gt;next); p-&gt;next = newnode; size++;&#125;template&lt;class T&gt;inline T CirList&lt;T&gt;::del(int pos)&#123; if (pos&lt;0 || pos&gt;size) &#123; cout &lt;&lt; "illegal operator" &lt;&lt; endl; exit(1); &#125; ListNode&lt;T&gt; *p = index(pos-1); ListNode&lt;T&gt; *q; q = p-&gt;next; p-&gt;next = q-&gt;next; T data = q-&gt;data; delete q; size--; return data;&#125;template&lt;class T&gt;inline T CirList&lt;T&gt;::getdata(int pos) const&#123; ListNode&lt;T&gt; *p = index(pos); return p-&gt;data;&#125;template&lt;class T&gt;inline void CirList&lt;T&gt;::clearlist()&#123; ListNode&lt;T&gt; *p, *p1; p = head-&gt;next; while (p != head) &#123; p1 = p; p= p-&gt;next; delete p1; &#125; size = 0;&#125;template&lt;class T&gt;inline ListNode&lt;T&gt;* CirList&lt;T&gt;::reset()&#123; currPtr = head-&gt;next; return currPtr;&#125;template&lt;class T&gt;inline ListNode&lt;T&gt;* CirList&lt;T&gt;::next()&#123; if (currPtr != NULL) &#123; currPtr = currPtr-&gt;next; &#125; return currPtr;&#125;template&lt;class T&gt;inline bool CirList&lt;T&gt;::EndOfList() const&#123; return (currPtr == head);&#125;template&lt;class T&gt;inline bool CirList&lt;T&gt;::nextEndofList() const&#123; return (currPtr-&gt;next == head);&#125;template&lt;class T&gt;inline T CirList&lt;T&gt;::delAfter()&#123;//删除currpter-&gt;next,并返回currptr-&gt;next-&gt;data if (currPtr-&gt;next != NULL) &#123; ListNode&lt;T&gt; *p = currPtr-&gt;next; currPtr-&gt;next = p-&gt;next; T data = p-&gt;data; delete p; size--; return data; &#125;&#125; 4.测试主函数 1234567891011121314151617181920212223242526272829303132void test()&#123; CirList&lt;int&gt; list; cout &lt;&lt; "当前链表中的元素有" &lt;&lt; list.listsize() &lt;&lt; endl; for (int i = 0; i &lt; 10; i++) &#123; list.insert(10 * i, i); &#125; list.insert(100, 0); cout &lt;&lt; "当前链表中的元素有" &lt;&lt; list.listsize() &lt;&lt; endl; ListNode&lt;int&gt; *p = list.reset(); while (!list.EndOfList()) &#123; cout &lt;&lt; p-&gt;data &lt;&lt; endl; p = list.next(); &#125; cout&lt;&lt; list.del(1)&lt;&lt;"已被删除"&lt;&lt;endl; while (!list.EndOfList()) &#123; cout &lt;&lt; p-&gt;data &lt;&lt; endl; p = list.next(); &#125; cout &lt;&lt; list.index(5)-&gt;data &lt;&lt; endl;&#125;int main()&#123; test(); system("pause"); return EXIT_SUCCESS;&#125; 输出结果如下：]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>单循环链表</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[顺序表的简单实现]]></title>
    <url>%2F2019%2F03%2F27%2F%E9%A1%BA%E5%BA%8F%E8%A1%A8%E7%9A%84%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[写在前面 &emsp;&emsp;数据结构是一个数据对象，同时这个对象的实例以及构成实例的元素都存在着联系，而且这些联系是由相关函数来规定的。&emsp;&emsp;研究数据结构，关心的是数据对象（实际上是实例）的描述以及相关函数的具体实现。数据对象描述得好，函数的实现就会高效。&emsp;&emsp;最常用的数据对象以及操作都已经在C++中作为基本数据类型而实现，如整数对象，布尔对象等。其他数据对象均可以用基本数据类型以及由C++的类、数组和指针所提供的组合功能来实现。 1.线性表的数据结构 &emsp;&emsp;线性表（linear list)也称有序表，它的每一个实例都是元素的一个有序集合。&emsp;&emsp;对线性表实施的操作有： 创建一个线性表 撤销一个线性表 确定线性表是否为空 确定线性表的长度 按给定的索引查找一个元素 按一个给定的元素查找其索引 按一个给定的索引删除一个元素 按一个给定的索引插入一个元素 从左至右顺序输出线性表元素 &emsp;&emsp;用顺序存储结构存储的表称为顺序表（sequent list）。顺序表中任意数据元素的存取和访问都可以通过它的位置指针来（即数组下标）进行访问。对顺序表中元素访问的效率是一个比较重要的问题。通常情况下，有序顺序表的访问效率大大高于无序顺序表的访问效率。 2.顺序表的类定义 12345678910111213141516171819typedef int Seqlist_Entry;const int maxsize = 10;class Seqlist&#123;public: Seqlist();//构造函数 ~Seqlist();//析构函数 int listsize()const;//返回元素的个数 bool listempty() const;//判断表是否为空 int find(const Seqlist_Entry &amp;item);//返回元素item在表中的位置 Seqlist_Entry getdata(int pos) const;//返回位置pos的元素 void insert(const Seqlist_Entry &amp;item, int pos);//在位置pos处插入元素item Seqlist_Entry Delete(const int pos);//删除位置pos的元素并返回 void clearlist();//清空表 void showall() const;//输出表private: Seqlist_Entry data[maxsize]; int size;//数据元素的个数&#125;; 3.顺序表的类实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104//构造函数Seqlist::Seqlist()&#123; size = 0;&#125;//析构函数Seqlist::~Seqlist() &#123;&#125;//返回顺序表元素的个数int Seqlist::listsize() const&#123; return size;&#125;//判断顺序表是否为空bool Seqlist::listempty() const&#123; return (size == 0);&#125;//查找item，并返回位置索引int Seqlist::find(const Seqlist_Entry &amp; item)&#123; if (size == 0) &#123; cout &lt;&lt; "list is empty " &lt;&lt; endl; &#125; int i = 0; while (i &lt; size&amp;&amp;item != data[i]) &#123; i++; &#125; if (i &lt; size) return i; else cout &lt;&lt; "illegal operator" &lt;&lt; endl;&#125;//取出pos位置上的元素Seqlist_Entry Seqlist::getdata(int pos) const&#123; if (pos&lt;0 || pos&gt;size - 1) &#123; cout &lt;&lt; "illegal operator" &lt;&lt; endl; exit(1); &#125; return data[pos];&#125;//在pos位置插入元素itemvoid Seqlist::insert(const Seqlist_Entry &amp; item, int pos)&#123; if (size == maxsize) &#123; cout &lt;&lt; "list is full" &lt;&lt; endl; return; &#125; if (pos&lt;0 || pos&gt;size ) &#123; cout &lt;&lt; "illegal operator" &lt;&lt; endl; return; &#125; for (int i = size; i &gt; pos; i--) &#123; data[i] = data[i - 1]; &#125; data[pos] = item; size++;&#125;//删除pos位置的元素Seqlist_Entry Seqlist::Delete(const int pos)&#123; Seqlist_Entry tmp=data[pos]; if (size == 0) &#123; cout &lt;&lt; "list is empty" &lt;&lt; endl; exit(1); &#125; if (pos&lt;0 || pos&gt;size - 1) &#123; cout &lt;&lt; "illegal operator" &lt;&lt; endl; exit(1); &#125; for (int i = pos; i &lt; size-1; i++) &#123; data[i] = data[i + 1]; &#125; size--; return tmp;&#125;//置顺序表为空void Seqlist::clearlist()&#123; size = 0; cout &lt;&lt; "已清空" &lt;&lt; endl;&#125;//输出顺序表中所有元素void Seqlist::showall() const&#123; if (size == 0) &#123; cout &lt;&lt; "list is empty" &lt;&lt; endl; &#125; for (int i = 0; i &lt; size; i++) &#123; cout &lt;&lt;i&lt;&lt;"号元素:"&lt;&lt; data[i] &lt;&lt; endl; &#125;&#125; 4.测试主函数 123456789101112131415161718192021222324void test()&#123; Seqlist list; for (int i = 0; i &lt; 10; i++) &#123; list.insert(i * 12, i); &#125; for (int i = 0; i &lt; 10; i++) &#123; cout &lt;&lt; list.getdata(i) &lt;&lt; endl; &#125; int tmp = list.Delete(2); cout &lt;&lt; "元素" &lt;&lt; tmp &lt;&lt; "已经被删除了" &lt;&lt; endl; list.showall(); cout&lt;&lt;"84在顺序表的"&lt;&lt;list.find(84)&lt;&lt;"号位置"&lt;&lt;endl; list.clearlist(); list.showall();&#125;int main()&#123; test();&#125; 输出结果如下图：]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>顺序表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[栈的实现]]></title>
    <url>%2F2019%2F03%2F27%2F%E6%A0%88%E7%9A%84%E5%AE%9E%E7%8E%B0-1%2F</url>
    <content type="text"><![CDATA[写在前面&emsp;栈（Stack)是一种特殊的线性表，是一种只允许在表的一端进行插入和删除操作的线性表。栈中允许进行插入和删除操作的一端称为栈顶，另一端为栈底。栈顶的当前位置是动态的，标识栈顶当前位置的称为栈顶指示器（或栈顶指针）。栈的插入和删除操作通常称为入栈或进栈，栈的删除操作称为出栈或退栈。当栈中没有数据元素时称为空栈。&emsp;&emsp;根据栈的定义，每次进栈的数据元素都放在原当前栈顶元素之前而成为新的栈顶元素，每次退栈的数据元素都是当前栈顶元素，这样，最后进入堆栈的数据元素总是最先出栈，因此栈也被成为后进先出表。 1.栈的基本运算 初始化栈 销毁栈 判断栈是否为空 进栈 出栈 取栈顶元素 2.顺序栈四要素 栈空条件： top==-1 栈满条件： top==max_stack - 1 item进栈操作：top++,将item放在top处 退栈操作：从top处取出元素item，top– 3.类说明 &emsp;对于顺序栈Stack的实现，应创建一个数组来存放栈中的元素，并用一个始终指向栈顶的变量top来表示栈顶的位置。类定义如下： 12345678910111213141516171819202122232425typedef int Stack_Entry;const int max_stack = 10;class Stack&#123;public: Stack(); //构造函数 ~Stack() &#123;&#125;; //析构函数 bool empty() const; //判断栈是否为空 Stack_Entry pop(); //出栈数据元素 Stack_Entry Top(Stack_Entry &amp;item) const; //返回栈顶元素 void push(const Stack_Entry &amp;item); //数据元素item进栈 int getsize() const; //获取栈中元素的个数 void clearstack(); //清空栈private: int top;//栈顶位置指示器 Stack_Entry entry[max_stack];//Stack_Entry类型的数组&#125;; 4.具体实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748Stack::Stack()&#123; top=-1;&#125;bool Stack::empty() const&#123; return (top==-1);&#125;Stack_Entry Stack::pop()&#123; if (top==-1) &#123; cout &lt;&lt; "Stack is empty" &lt;&lt; endl; &#125; return entry[top--]; &#125;Stack_Entry Stack::Top(Stack_Entry &amp; item) const&#123; if (top == -1) &#123; cout &lt;&lt; "Stack is empty" &lt;&lt; endl; &#125; return entry[top];&#125;void Stack::push(const Stack_Entry &amp; item)&#123; if (top == max_stack - 1) &#123; cout &lt;&lt; "Stack is full" &lt;&lt; endl; &#125; top++; entry[top] = item;&#125;int Stack::getsize() const&#123; return top+1;&#125;void Stack::clearstack()&#123; top = -1;&#125; 5.主函数 12345678910111213141516171819202122232425262728293031void test()&#123; Stack stack; for (int i = 0; i &lt; 10; i++) &#123; stack.push(i+10*i); &#125; cout &lt;&lt; "当前栈中元素数为：" &lt;&lt; stack.getsize() &lt;&lt; endl; for (int i = 0; i &lt; 10; i++) &#123; Stack_Entry tmp; tmp = stack.pop(); cout &lt;&lt; "我是" &lt;&lt; i &lt;&lt; "号元素:"&lt;&lt;tmp &lt;&lt; endl; &#125; cout &lt;&lt; "当前栈中元素数为：" &lt;&lt; stack.getsize() &lt;&lt; endl; if (stack.empty()) &#123; cout &lt;&lt; "Stack is empty" &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; "Stack is not empty" &lt;&lt; endl; &#125;&#125;int main()&#123; test(); system("pause"); return EXIT_SUCCESS;&#125; 输出结果如下图：]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[单链表的实现]]></title>
    <url>%2F2019%2F03%2F27%2F%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[写在前面&emsp;链式存储结构是计算机中另一种最基本和最主要的数据存储结构。和顺序存储结构不同，初始化时链式存储结构为空链，每当有新的元素需要存储时用户向系统动态申请所需的存储空间插入链中。所有高级程序设计语言都为用户提供了向系统动态申请和动态释放存储空间的办法。C++提供了new和delete运算符，分别用于向系统动态申请所需存储空间和动态释放用new申请的存储空间。new能自动计算要分配的类型大小并自动返回正确的指针类型。delete能自动释放由new分配的存储空间。&emsp;&emsp;在顺序存储结构中，用户向系统申请一块地址连续的有限空间用于存储数据元素，这样任意两个在逻辑上相邻的数据元素在物理上也必然相邻。但在链式存储结构中，由于它在初始化时为空链，每当有新的数据元素需要存储时用户才向系统动态申请所需的存储空间插入链中，而这些在不同时刻向系统动态申请的存储空间在内存上很可能是不连续的。因此，在链式存储结构中，任意两个在逻辑上相邻的数据元素在物理上不一定相邻，数据元素的逻辑次序是通过链中的指针连接实现的。 &emsp;&emsp;链式存储结构存储线性结构数据元素集合的方法是用节点（Node)构造链。线性结构数据元素的特点是：除第一个和最后一个元素外，每个元素只有一个唯一的前驱和一个唯一的后继。链式结构中每个节点除数据域外，还有一个或两个以上的指针域，数据域用来存放数据元素，指针域用来构造数据元素之间的关系。 1.单链表 &emsp;单链表简称链表（linked list)，是表数据元素的单链结构存储。链表使用一个一个的节点链接构成的。&emsp;&emsp;表要求允许在任意位置进行插入和删除。当选用带头节点的单链表时，在第一个位置插入节点和在其他位置插入节点一样不会改变头指针head的值，此时改变的是head-&gt;next的值。&emsp;在第一个位置删除节点和在其他位置删除节点一样也不会改变头指针head的值，此时改变的也是head-&gt;next的值。 2.节点类的定义和实现 &emsp;在单链表中，每个节点构成包括数据域和指针域两部分。每个节点的基本操作包括构造一个节点对象、建立一个新节点、给出当前节点的下一个节点指针等。 1234567891011121314151617181920212223template&lt;class T&gt;class ListNode&#123; friend class LinList&lt;T&gt;;//声明友元类public: T data;//数据域 ListNode(ListNode&lt;T&gt; *ptrNext = NULL);//构造函数，用于构造头节点，头节点没有data参数 ListNode(const T &amp;item, ListNode&lt;T&gt; *ptrNext = NULL);//构造函数，主要用于构造非头节点的节点 ~ListNode() &#123;&#125;;//析构函数private: ListNode&lt;T&gt; *next;//指向下一节点的指针&#125;;template&lt;class T&gt;inline ListNode&lt;T&gt;::ListNode(ListNode&lt;T&gt;* ptrNext):next(ptrNext)&#123;&#125;//构造函数，用于构造头节点，头节点没有值template&lt;class T&gt;inline ListNode&lt;T&gt;::ListNode(const T &amp; item, ListNode&lt;T&gt;* ptrNext)&#123;//构造函数，用于构造非头节点的节点 data = item; next = ptrNext;&#125; &emsp;节点类的成员有data域和next域。data域中存放了该节点的数据值，由于应用问题中需要使用链表中的data值，所以定义为公有数据成员方便使用；next域定义为私有数据成员。节点类的成员函数由两个不同参数的构造函数和空的析构函数。析构函数为空是因为节点类中没有用new函数向系统申请空间，而节点对象本身分配的空间，系统可自动识别释放。 3.单链表类的定义 12345678910111213141516171819202122232425template&lt;class T&gt;class LinList&#123;public: LinList();//构造函数 ~LinList();//析构函数 //表操作成员函数 int listsize() const;//返回链表中元素的个数 bool listempty() const;//链表是否为空 ListNode&lt;T&gt; *index(int pos);//返回指向第pos个节点的指针 void insert(const T&amp; item, int pos);//在pos节点前插入一个data域为item的元素 T Delete(int pos);//删除第pos个节点并返回被删除节点的data域 T getdata(int pos);//返回第pos个节点的data值 void clearlist();//清空表为初始化状态 //遍历链表的成员函数 ListNode&lt;T&gt; *Reset(int pos = 0);//currPtr指向节点pos并返回currPtr ListNode&lt;T&gt; *Next();//currPtr指向下一个节点并返回currPtr bool endOfList() const;//currPtr==head？private: ListNode&lt;T&gt; *head;//指向头节点的指针 ListNode&lt;T&gt; *currPtr;//当前指针 int size;//单链表中元素的个数&#125;; &emsp;单链表类的数据成员有头指针、元素个数和当前节点指针。头指针指向头结点，任何对单链表中节点的操作都要从头指针进入。初始化状态下，节点个数为0.当前节点指针是遍历链表成员函数使用的数据成员，遍历链表成员函数通过控制当前节点指针来遍历链表。&emsp;&emsp;单链表类的成员函数由三组：构造函数和析构函数、表操作的成员函数和遍历链表的成员函数。由于单链表类中的节点是通过new函数向系统申请的，在释放单链表类对象的时候，系统无法自行释放这些空间，所以析构函数不能为空，析构函数必须用delete函数逐个释放这些空间。表操作成员函数时对表操作的基本成员函数，这与顺序表类中对表进行操作的成员函数意义相同，但是实现方法不同。链表的遍历操作是每次寻找当前节点的下一个节点，由于每次对链表类中节点的操作都要从头指针进入后寻找到相应的节点后才可完成，这样的单链表类遍历操作的时间复杂度返回大大增加，在单链表中增加一组遍历链表的成员函数可使单链表遍历操作的时间复杂度不增加。 4.单链表类的实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141template&lt;class T&gt;inline LinList&lt;T&gt;::LinList()&#123; head = new ListNode&lt;T&gt;();//头指针指向头结点 size = 0;&#125;template&lt;class T&gt;inline LinList&lt;T&gt;::~LinList()&#123; clearlist(); delete head; head = NULL;&#125;template&lt;class T&gt;inline int LinList&lt;T&gt;::listsize() const//返回单链表中元素的个数&#123; return size;&#125;template&lt;class T&gt;inline bool LinList&lt;T&gt;::listempty() const&#123; return size == 0;&#125;template&lt;class T&gt;inline ListNode&lt;T&gt;* LinList&lt;T&gt;::index(int pos)&#123; if (pos == -1) return head; if (pos&lt;0 || pos&gt;size) &#123; cout &lt;&lt; "illegal operator" &lt;&lt; endl; exit(1); &#125; ListNode&lt;T&gt; *p = head-&gt;next;//p指向第一个节点 int i = 0; while (p != NULL &amp;&amp; i &lt; pos) &#123; p = p-&gt;next; i++; &#125; return p;&#125;template&lt;class T&gt;inline void LinList&lt;T&gt;::insert(const T &amp; item, int pos)&#123; ListNode&lt;T&gt; *p = index(pos - 1); ListNode&lt;T&gt; *newnode = new ListNode&lt;T&gt;(item, p-&gt;next); p-&gt;next = newnode; size++;&#125;template&lt;class T&gt;inline T LinList&lt;T&gt;::Delete(int pos)&#123; if (size == 0) &#123; cout &lt;&lt; "list is empty" &lt;&lt; endl; exit(1); &#125; ListNode&lt;T&gt;*q, *p = index(pos - 1);//p为指向第pos-1个节点的指针 q = p-&gt;next;//q指向要删除节点 p-&gt;next = p-&gt;next-&gt;next;//p指向要删除节点的后一节点 T data = q-&gt;data; //data保存要删除节点值 delete q; size--; return data;&#125;template&lt;class T&gt;inline T LinList&lt;T&gt;::getdata(int pos)&#123; ListNode&lt;T&gt; *p = index(pos);//指针p指向第pos个节点 return p-&gt;data;&#125;template&lt;class T&gt;inline void LinList&lt;T&gt;::clearlist()&#123; ListNode&lt;T&gt; *p, *p1; p = head-&gt;next; while (p != NULL) &#123;//delete所有new出来的空间 p1 = p; p = p-&gt;next; delete p1; &#125; size = 0;&#125;template&lt;class T&gt;inline ListNode&lt;T&gt;* LinList&lt;T&gt;::Reset(int pos)&#123; if (head == NULL) return NULL; if (pos &lt; -1 || pos&gt;size) &#123; cout &lt;&lt; "mistake" &lt;&lt; endl; exit(1); &#125; if (pos == -1) return head; if (pos == 0) &#123; currPtr = head-&gt;next; &#125; else &#123; currPtr = head-&gt;next; ListNode&lt;T&gt; prevPtr = head; for (int i = 0; i &lt; pos; i++) &#123; prevPtr = currPtr; currPtr = currPtr-&gt;next; &#125; &#125; return currPtr;&#125;template&lt;class T&gt;inline ListNode&lt;T&gt;* LinList&lt;T&gt;::Next()&#123; if (currPtr != NULL) &#123; currPtr = currPtr-&gt;next; &#125; return currPtr;&#125;template&lt;class T&gt;inline bool LinList&lt;T&gt;::endOfList() const&#123; return currPtr == NULL;&#125; &emsp;&emsp;这些成员函数基本上实现了单链表所需的基本操作。 5.主函数测试 测试主函数如下： 123456789101112131415161718192021222324252627void test()&#123; LinList&lt;int&gt; list; cout &lt;&lt; "单链表中的元素个数为："&lt;&lt;list.listsize() &lt;&lt; endl; for (int i = 0; i &lt; 10; i++) &#123; list.insert(15 * i, i); &#125; cout &lt;&lt; "单链表中的元素个数为：" &lt;&lt; list.listsize() &lt;&lt; endl; cout &lt;&lt; "5号为：" &lt;&lt; list.getdata(5) &lt;&lt; endl; cout&lt;&lt;list.Delete(5)&lt;&lt;"已被删除"&lt;&lt;endl; cout &lt;&lt; "5号为：" &lt;&lt; list.getdata(5) &lt;&lt; endl; ListNode&lt;int&gt; *p = list.Reset(); while (!list.endOfList()) &#123; cout &lt;&lt; p-&gt;data &lt;&lt; endl; p = list.Next(); &#125;&#125;int main()&#123; test(); system("pause"); return EXIT_SUCCESS;&#125; 输出结果如下：]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>单链表</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[运算符重载（2）]]></title>
    <url>%2F2019%2F03%2F24%2F%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD%EF%BC%882%EF%BC%89%2F</url>
    <content type="text"><![CDATA[5.左移(输出）运算符重载 &emsp;&emsp;如我们所知，IO标准库分别使用&gt;&gt;和&lt;&lt;执行输入输出操作。对于这两个运算符来说，IO库定义了其用读写内置类型的版本，但是类则需自定义适合其对象的新版本支持IO操作。&emsp;&emsp;通过情况下左移运算符的第一形参是一个非常量ostream的引用。而ostream是非常量的原因是向流写入内容会改变其状态。而该形参是引用，是因为我们无法直接复制一个ostream对象。&emsp;&emsp;第二个形参一般来说是一个常量的引用，该常量是我们想要打印的类类型。第二个形参是引用的原因是我们希望避免复制实参，而形参为常量是因为打印对象不会改变对象的内容。举例如下： 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;iostream&gt;#include&lt;string&gt;using namespace std;class Person&#123; friend ostream &amp;operator&lt;&lt;(ostream &amp;cout, const Person &amp;p);public: Person(string name, int age);private: string m_name; int m_age;&#125;;Person::Person(string name, int age)&#123; this-&gt;m_name = name; this-&gt;m_age = age;&#125;ostream &amp;operator&lt;&lt;(ostream &amp;cout, const Person &amp;p)&#123; cout &lt;&lt; p.m_name &lt;&lt; "的年龄为：" &lt;&lt; p.m_age &lt;&lt; endl; return cout;&#125;void test()&#123; Person p("Aoki", 20); cout &lt;&lt; p; cout &lt;&lt; "Hello world" &lt;&lt; endl;&#125;int main()&#123; test(); system("pause"); return EXIT_SUCCESS;&#125; 输出结果如下： 6.右移（输入）运算符重载 &emsp;&emsp;通常情况下，输入运算符的第一个形参是运算符简要读取的流的引用，第二个形参是将要读入的非常量对象的引用。该运算符通常会返回某个给定流的引用。第二个形参之所以必须是个非常量是因为输入运算符本身的目的就是将数据读入到这个对象中。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include &lt;iostream&gt;#include&lt;string&gt;using namespace std;class Person&#123; friend istream &amp;operator&gt;&gt;(istream &amp;cin, Person &amp;p);public: Person ()&#123;&#125; Person(string name, int age); void Show();private: string m_name; int m_age;&#125;;Person::Person(string name, int age)&#123; this-&gt;m_name = name; this-&gt;m_age = age;&#125;istream &amp; operator&gt;&gt;(istream &amp; cin, Person &amp; p)&#123; string name; int age; cin &gt;&gt; name &gt;&gt; age; if (cin) &#123; p.m_name = name; p.m_age = age; &#125; else &#123; p = Person();//如果输入失败，对象被赋予默认状态 &#125; return cin;&#125;void Person::Show()&#123; cout &lt;&lt; this-&gt;m_name &lt;&lt; "的年龄是：" &lt;&lt; this-&gt;m_age &lt;&lt; endl;&#125;void test()&#123; Person p1; cin &gt;&gt; p1; p1.Show();&#125;int main()&#123; test(); system("pause"); return EXIT_SUCCESS;&#125; 输出结果如下：&emsp;&emsp;可以注意到，在输入运算符重载中，有输入失败的处理。那么输入时可能会发生什么错误呢？ 当流含有错误类型的数据时读取操作可能失败 当读取操作到达文件末尾或遇到输入流的其他错误时也会失败 &emsp;&emsp;在程序中我们没有逐个检查每个读取操作，而是等读取了所有数据之后赶在使用这些数据前面进行了一次性的检查。&emsp;&emsp;如果在发生错误之前对象已经有一部分改变，则适时地将对象置为合法状态显得异常重要。&emsp;&emsp;通过将对象置为合法状态，我们能保护使用者免受到输入错误的影响。此时的对象处于可用状态，即它的成员都是被正确定义的。而且该对象也不会产生误导性结果，因为它的数据本质上是一致的。 7.指针运算符重载 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879#include &lt;iostream&gt;#include&lt;string&gt;using namespace std;class Person&#123;public: Person(string name, int age); void Display();private: string m_name; int m_age;&#125;;class SmartPointer&#123;public: SmartPointer(Person *person); Person* operator-&gt;(); Person&amp; operator*(); ~SmartPointer();public: Person *pPerson;&#125;;Person::Person(string name, int age)&#123; this-&gt;m_name = name; this-&gt;m_age = age;&#125;void Person::Display()&#123; cout &lt;&lt; this-&gt;m_name &lt;&lt; "的年龄是：" &lt;&lt; this-&gt;m_age &lt;&lt; endl;&#125;SmartPointer::SmartPointer(Person * person)&#123; this-&gt;pPerson = person;&#125;Person * SmartPointer::operator-&gt;()&#123; //重载指针的-&gt;运算符 return pPerson;&#125;Person &amp; SmartPointer::operator*()&#123; //重载指针的*运算符 return *pPerson;&#125;SmartPointer::~SmartPointer()&#123; if (pPerson != NULL) &#123; delete pPerson; &#125;&#125;void test()&#123; Person *person = new Person("Aoki", 20); //如果忘记释放，那么就会造成内存泄漏 SmartPointer poiner(new Person("Aoki", 20)); poiner-&gt;Display();&#125;int main()&#123; test(); system("pause"); return EXIT_SUCCESS;&#125; 输出结果如下： 8.赋值运算符重载 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#define _CRT_SECURE_NO_WARNINGS#include &lt;iostream&gt;#include&lt;string&gt;using namespace std;class Person&#123;public: Person(const char *name); Person&amp; operator=(const Person &amp;p); ~Person();public: char *name;&#125;;Person::Person(const char * name)&#123; this-&gt;name = new char[strlen(name) + 1]; strcpy(this-&gt;name, name);&#125;Person &amp; Person::operator=(const Person &amp; p)&#123; if (this-&gt;name != NULL) &#123;//判断原来堆区中是否有内容，如果有，先释放 delete[] this-&gt;name; this-&gt;name = NULL; &#125; this-&gt;name = new char[strlen(p.name) + 1]; strcpy(this-&gt;name, p.name); return *this;&#125;Person::~Person()&#123; if (this-&gt;name != NULL) &#123; delete[] this-&gt;name; this-&gt;name = NULL; &#125;&#125;void test()&#123; Person p1("Aoki"); Person p2("青木"); p1 = p2; cout &lt;&lt; p1.name &lt;&lt; endl; cout &lt;&lt; p2.name &lt;&lt; endl;&#125;int main()&#123; test(); system("pause"); return EXIT_SUCCESS;&#125; 输出结果如下：]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>运算符重载</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[运算符的重载（1）]]></title>
    <url>%2F2019%2F03%2F24%2F%E8%BF%90%E7%AE%97%E7%AC%A6%E7%9A%84%E9%87%8D%E8%BD%BD%EF%BC%881%EF%BC%89%2F</url>
    <content type="text"><![CDATA[写在前面 &emsp;&emsp;运算符重载，就是对已有的运算符重新进行定义，赋予其另一种功能，以适应不同的数据类型。&emsp;&emsp;运算符重载（operator overloading)只是一种“语法上的方便”,也就它只是另一种函数调用的方式。&emsp;&emsp;在C++中，可以定义一个处理类的新运算符。这种定义很像一个普通的函数定义，只是函数的名字由关键字operator及其紧跟的运算符组成。差别仅此而已。它像任何其他函数一样也是一个函数，当编译器遇到适当的模式时，就会调用这个函数。&emsp;&emsp;重载运算符的参数数量与该运算符作用的对象数量一样多。一元运算符有一个参数，二元运算符有两个参数。对于二元运算符来说，左侧运算符对象传递给第一个参数，而右侧运算符对象传递给第二个参数。除了重载的函数调用运算符operator()之外，其他重载运算符不能含有默认实参。&emsp;&emsp;如果一个重载运算符函数时成员函数，则它的第一个（左侧）运算符对象绑定到隐式地this指针上，因此，成员运算符函数的（显式）参数数量比运算符的运算对象总数少一个。 1.关系运算符重载 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include &lt;iostream&gt;#include&lt;string&gt;using namespace std;class Person&#123;public: Person(string name, int age); bool operator==(Person &amp;p);//==运算符重载 bool operator!=(Person &amp;p);//！=运算符重载 private: string m_Name; int m_Age;&#125;;Person::Person(string name, int age)&#123; this-&gt;m_Name = name; this-&gt;m_Age = age;&#125;bool Person::operator==(Person &amp; p)&#123; if (this-&gt;m_Name == p.m_Name&amp;&amp;this-&gt;m_Age == p.m_Age) &#123; return true; &#125; return false;&#125;bool Person::operator!=(Person &amp; p)&#123; if (this-&gt;m_Name == p.m_Name&amp;&amp;this-&gt;m_Age == p.m_Age) &#123; return false; &#125; return true;&#125;void test()&#123; Person p1("Aoki", 22); Person p2("Aoki", 22); Person p3("Aoki", 20); if (p1 == p2) &#123; cout &lt;&lt; "p1和p2相等" &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; "p1和p2不相等" &lt;&lt; endl; &#125; if (p1 != p3) &#123; cout &lt;&lt; "p1和p3不相等" &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; "p1和p3相等" &lt;&lt; endl; &#125;&#125;int main()&#123; test();&#125; 输出结果如下： 2.自增自减运算符重载 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#include &lt;iostream&gt;#include&lt;string&gt;using namespace std;class Person&#123;public: Person()&#123;&#125; Person(string name, int age); Person operator++();//前置++运算符 Person operator--();//前置--运算符重载 Person operator++(int);//后置++运算符重载 Person operator--(int);//后置--运算符重载 void show();private: string m_Name; int m_Age;&#125;;Person::Person(string name, int age)&#123; this-&gt;m_Name = name; this-&gt;m_Age = age;&#125;Person Person::operator++()&#123; m_Age++; return *this;&#125;Person Person::operator--()&#123; m_Age--; return *this;&#125;Person Person::operator++(int)&#123; Person tmp; tmp.m_Age = this-&gt;m_Age; m_Age++; return tmp;&#125;Person Person::operator--(int)&#123; Person tmp; tmp.m_Age = this-&gt;m_Age; m_Age--; return tmp;&#125;void Person::show()&#123; cout &lt;&lt; this-&gt;m_Name &lt;&lt; "的年龄为" &lt;&lt; this-&gt;m_Age &lt;&lt; endl;&#125;void test()&#123; Person p1("Aoki",22); p1++; p1.show(); p1--; p1.show(); --p1; p1.show(); ++p1; p1.show();&#125;int main()&#123; test(); return 0;&#125; 输出结果如下：优先使用++和–的标准形式，优先调用前置++&emsp;&emsp;如果定义了++c，也要定义c++，递增操作符比较麻烦，因为他们都有前缀和后缀形式，而两种语义略有不同。重载123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&amp;emsp;&amp;emsp;对于++和--而言，后置形式是先返回，然后对象++或--，返回的是对象的原值。前置形式，对象先++或--，然后返回当前对象，返回的是新对象。 &amp;emsp;&amp;emsp;调用代码的时候，要优先使用前缀形式，除非确实需要后缀形式返回的原值，，前缀和后缀形式语义上是等价的，输入工作量也相当，只是效率经常会略高一些，由于前缀形式少创建了一个临时对象。 &lt;br /&gt;&lt;br /&gt;&gt; # 3.加号运算符重载 &lt;br /&gt;```c++#include &lt;iostream&gt;#include&lt;string&gt;using namespace std;class Person&#123;public: Person() &#123;&#125;; Person(string a, int b) :m_name(a), m_age(b) &#123;&#125; Person operator+(Person &amp;p);public: string m_name; int m_age;&#125;;Person Person::operator+(Person &amp; p)&#123; Person tmp; tmp.m_age = this-&gt;m_age + p.m_age; tmp.m_name = this-&gt;m_name + p.m_name; return tmp;&#125;void test()&#123; Person p1(&quot;Ao&quot;, 20); Person p2(&quot;ki&quot;,10); Person p3 = p1 + p2; cout &lt;&lt; &quot;p3的名字为：&quot; &lt;&lt; p3.m_name &lt;&lt; &quot;,p3的年龄为&quot; &lt;&lt; p3.m_age &lt;&lt; endl;&#125;int main()&#123; test(); return 0;&#125; 输出结果如下： 下面也是加号运算符重载的一些方法： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include &lt;iostream&gt;#include&lt;string&gt;using namespace std;class Person&#123;public: Person() &#123;&#125;; Person(string a, int b) :m_name(a), m_age(b) &#123;&#125; //Person operator+(Person &amp;p);public: string m_name; int m_age;&#125;;////Person Person::operator+(Person &amp; p)//&#123;// Person tmp;// tmp.m_age = this-&gt;m_age + p.m_age;// tmp.m_name = this-&gt;m_name + p.m_name;// return tmp;//&#125;Person operator+(Person &amp;p1, Person &amp;p2)&#123; Person tmp; tmp.m_age = p1.m_age + p2.m_age; tmp.m_name = p1.m_name + p2.m_name; return tmp;&#125;Person operator+(Person &amp;p1, int a)&#123; Person tmp; tmp.m_age = p1.m_age + a; tmp.m_name = p1.m_name; return tmp;&#125;void test()&#123; Person p1("Ao", 20); Person p2("ki",10); Person p3 = p1 + p2; Person p4 = p2 + 10; cout &lt;&lt; "p3的名字为：" &lt;&lt; p3.m_name &lt;&lt; ",p3的年龄为" &lt;&lt; p3.m_age &lt;&lt; endl; cout &lt;&lt; "p4的名字为：" &lt;&lt; p4.m_name &lt;&lt; ",p4的年龄为" &lt;&lt; p4.m_age &lt;&lt; endl;&#125;int main()&#123; test(); return 0;&#125; 输出结果如下： 4.减号运算符重载 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include &lt;iostream&gt;#include&lt;string&gt;using namespace std;class Person&#123;public: Person() &#123;&#125;; Person(string a, int b) :m_name(a), m_age(b) &#123;&#125; //Person operator+(Person &amp;p);public: string m_name; int m_age;&#125;;//Person Person::operator+(Person &amp; p)//&#123;// Person tmp;// tmp.m_age = this-&gt;m_age + p.m_age;// tmp.m_name = this-&gt;m_name + p.m_name;// return tmp;//&#125;Person operator-(Person &amp;p1, Person &amp;p2)&#123; Person tmp; tmp.m_age = p1.m_age - p2.m_age; tmp.m_name = p1.m_name + p2.m_name; return tmp;&#125;Person operator-(Person &amp;p1, int a)&#123; Person tmp; tmp.m_age = p1.m_age - a; tmp.m_name = p1.m_name; return tmp;&#125;void test()&#123; Person p1("Ao", 20); Person p2("ki",10); Person p3 = p1 - p2; Person p4 = p2 -1; cout &lt;&lt; "p3的名字为：" &lt;&lt; p3.m_name &lt;&lt; ",p3的年龄为" &lt;&lt; p3.m_age &lt;&lt; endl; cout &lt;&lt; "p4的名字为：" &lt;&lt; p4.m_name &lt;&lt; ",p4的年龄为" &lt;&lt; p4.m_age &lt;&lt; endl;&#125;int main()&#123; test(); return 0;&#125; 输出结果如下:]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>运算符重载</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[友元]]></title>
    <url>%2F2019%2F03%2F23%2F%E5%8F%8B%E5%85%83%2F</url>
    <content type="text"><![CDATA[写在前面 &emsp;&emsp;类的主要特点之一就是数据隐藏，即类的私有成员无法在类的外部（作用域之外）访问。但是，有时候需要在类的外部访问类的私有数据成员，怎么办呢？&emsp;&emsp;解决办法是使用友元函数，友元函数时一种特权函数c，C++允许这个特权函数访问私有成员。这一点我们可以用生活中的例子来看：&emsp;&emsp;比如你的家有客厅，有卧室，客厅是public的，所有来的客人都可以进去，但是你的卧室是私有的，也就是说只有你能进去，但是，你可以允许你的好朋友进去。&emsp;&emsp;程序员可以把一个全局函数、某个类中的成员函数、甚至整个类声明为友元。 1.全局函数做友元函数 友元语法 friend关键字只出现在声明处 其他类、类成员函数、全局函数都可以声明为友元 友元函数不是类的成员，不带this指针 1234567891011121314151617181920212223242526272829303132#include &lt;iostream&gt;#include&lt;string&gt;using namespace std;class Home&#123;public: friend void test(Home *home); Home() &#123; this-&gt;bedroom = "卧室"; this-&gt;sittingroom = "客厅"; &#125; string sittingroom;//客厅private: string bedroom;//卧室 &#125;;void test(Home *home)&#123; cout &lt;&lt; "你的好友正在访问" &lt;&lt; home-&gt;sittingroom &lt;&lt; endl; cout &lt;&lt; "你的好友正在访问" &lt;&lt; home-&gt;bedroom &lt;&lt; endl;&#125;int main()&#123; Home *home=new Home; test(home);&#125; 输出结果如下： 从输出结果可以看出，当全局函数作为声明为友元函数之后，全局函数也可以访问类的私有成员。 2.整个类做友元类 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;iostream&gt;#include&lt;string&gt;using namespace std;class Home&#123;public: friend class Good_Friend; Home() &#123; this-&gt;bedroom = "卧室"; this-&gt;sittingroom = "客厅"; &#125; string sittingroom;//客厅private: string bedroom;//卧室 &#125;;class Good_Friend&#123;public: Good_Friend(string name) &#123; this-&gt;name = name; &#125; void visit() &#123; cout &lt;&lt; "好友"&lt;&lt;this-&gt;name&lt;&lt;"正在拜访" &lt;&lt; this-&gt;home.sittingroom &lt;&lt; endl; cout &lt;&lt; "好友"&lt;&lt;this-&gt;name&lt;&lt;"正在拜访" &lt;&lt; this-&gt;home.bedroom &lt;&lt; endl; &#125;private: Home home; string name;&#125;;void test()&#123; Good_Friend frend("Aoki"); frend.visit();&#125;int main()&#123; test();&#125; &emsp;&emsp;输出结果如下：&emsp;&emsp;将好友类声明为友元类之后，好友类的对象可以访问Home类的私有成员。&emsp;&emsp;在友元类中我们应当注意： 友元关系不能被继承 友元关系是单向的 友元关系不具有传递性 C++是纯面向对象的吗？&emsp;&emsp;如果一个类被声明为friend，意味着它不是这个类的成员函数，却可以是修改这个类的私有成员，而且必须列在类的定义中，因此它是一个特权函数。C++不是完全的面向对象语言，而是一个混合产品。增加friend关键字只是用来解决一些实际问题，这也说明这种语言是不纯的。毕竟C++设计的目的是为了实用性，而不是追求理想的抽象。 -———《Think in C++》 3.成员函数做友元函数 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include &lt;iostream&gt;#include&lt;string&gt;using namespace std;class Home;class Good_Friend&#123;public: Good_Friend(string name); void visit(); void visit2();private: Home *home; string name;&#125;;class Home&#123; friend void Good_Friend::visit();public: Home();public: string sittingroom;private: string bedroom;&#125;;Good_Friend::Good_Friend(string name)&#123; home = new Home; this-&gt;name = name;&#125;void Good_Friend::visit()&#123; cout &lt;&lt; "你的好友" &lt;&lt; this-&gt;name &lt;&lt; "正在访问" &lt;&lt; this-&gt;home-&gt;sittingroom &lt;&lt; endl; cout &lt;&lt; "你的好友" &lt;&lt; this-&gt;name &lt;&lt; "正在访问" &lt;&lt; this-&gt;home-&gt;bedroom &lt;&lt; endl;&#125;void Good_Friend::visit2()&#123; cout &lt;&lt; "你的好友"&lt;&lt;this-&gt;name&lt;&lt;"正在访问" &lt;&lt; this-&gt;home-&gt;sittingroom &lt;&lt; endl; //cout &lt;&lt; "你的好友" &lt;&lt; this-&gt;name &lt;&lt; "正在访问" &lt;&lt; this-&gt;home-&gt;bedroom &lt;&lt; endl;&#125;Home::Home()&#123; this-&gt;sittingroom = "客厅"; this-&gt;bedroom = "卧室";&#125;void test()&#123; Good_Friend frien("Aoki"); frien.visit(); frien.visit2();&#125;int main()&#123; test(); return 0;&#125; &emsp;&emsp;当我们试图使用一个没有声明为Home类友元的成员函数去访问Home的私有成员时，编译器报错如下：正确是输出结果如下：&emsp;&emsp;虽然我现在将visit()函数定义为Home类的友元，但是事情并没有这么简单地结束，因为当我第一次定义友元函数时，编译器莫名其妙地报错。那么，编译器报错的原因是什么呢？&emsp;&emsp;当我尝试着把成员函数的声明与定义分开的时候，编译器显示没有错误。这也就告诉我们，在声明成员函数的时候，将声明与定义分开放，编译器会更好地处理。]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>友元函数</tag>
        <tag>友元类</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++对象模型初探]]></title>
    <url>%2F2019%2F03%2F23%2FC-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B%E5%88%9D%E6%8E%A2%2F</url>
    <content type="text"><![CDATA[1.成员变量和函数的存储 在C语言中，分开来声明，也就说，语言本身并没有支持“数据”和“函数”之间的关联性，我们把这种程序方法称为“程序性的”，由一组“分布在各个以功能为导向的函数中的算法驱动，它们处理的是共同的外部数据。C++实现了“封装”，那么数据（成员属性）和操作（成员函数）是什么样的呢？“数据”和“处理数据的操作（函数）”是分开存储的。 C++中的非静态数据成员直接内含在类对象中，就像C struct一样 成员函数（member function）虽然内含正在class声明之内，却不出现在对象中 每一个非内联成员函数只会的诞生一份函数实例 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include &lt;iostream&gt;using namespace std;class Myclass&#123;public: int m_A;&#125;;class Myclass1&#123;public: int m_A; static int m_B;&#125;;class Myclass2&#123;public: void test01() &#123; cout &lt;&lt; "001" &lt;&lt; endl; &#125;public: static int m_A;&#125;;class Myclass3&#123;public: static void test02() &#123; cout &lt;&lt; "002" &lt;&lt; endl; &#125;public: int m_A; static int m_B;&#125;;class Myclass4&#123;public: void test03() &#123; cout &lt;&lt; "003" &lt;&lt; endl; &#125; static void test04() &#123; cout &lt;&lt; "004" &lt;&lt; endl; &#125;public: int m_A; static int m_B;&#125;;int main()&#123; Myclass myclass; Myclass1 myclass1; Myclass2 myclass2; Myclass3 myclass3; Myclass4 myclass4; cout &lt;&lt; "size of myclass:" &lt;&lt; sizeof(myclass) &lt;&lt; endl; cout &lt;&lt; "size of myclass1:" &lt;&lt; sizeof(myclass1) &lt;&lt; endl; cout &lt;&lt; "size of myclass2:" &lt;&lt; sizeof(myclass2) &lt;&lt; endl; cout &lt;&lt; "size of myclass3:" &lt;&lt; sizeof(myclass3) &lt;&lt; endl; cout &lt;&lt; "size of myclass4:" &lt;&lt; sizeof(myclass4) &lt;&lt; endl; return 0;&#125; 输出结果如下：从输出结果我们可以看出，C++中成员变量和成员属性是分开存储的。 而且，只有非静态成员才属于对象身上。 2.this指针 通过上面的例子我们知道，C++的数据和操作时分开存储的，并且每个非内联成员函数只会诞生一份函数实例，也就是说多个同类型的对象会共用一块代码。那么问题是，这块代码是如何区分是哪个对象调用自己的呢？C++通过提供特殊的对象指针，this指针，来解决上述问题。this指针指向被调用的成员函数所属的对象。C++规定，this指针是隐含在对象成员函数内的一种指针。当一个对象被创建后，它的每一个成员函数都含有一个系统自动生成的隐含指针this，用以保存这个对象的地址。也就是说，虽然我们没有写上this指针，编译器在编译的时候也会加上的。因此，this指针也被称为“指向本对象的指针”，this指针不并不是对象的一部分，并不会影响sizeof（对象）对的结果。this指针是C++实现封装的一种机制，它将对象和该对象调用的非成员函数连接在一起，在外部看来，每个对象都拥有自己的成员函数。一般情况下，并不写this，而是让系统进行默认设置。this指针永远指向当前对象。 成员函数通过this指针即可知道操作的是哪个对象的数据。this指针是一种隐含指针，它隐含于每个类的非静态成员函数中，this指针无须定义，直接使用即可。静态成员函数内部没有this指针，静态成员函数不能操作非静态成员变量。 3.this指针的使用 当形参和成员变量同名时，可用this指针区分 在类的非静态成员函数中返回对象本身，可用return *this 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;iostream&gt;#include&lt;string&gt;using namespace std;class Person&#123;public: Person(string name, int age) &#123;//当形参与成员变量名相同时，可以使用this指针来区分 this-&gt;age = age; this-&gt;name = name; &#125; Person Person_Plus(Person &amp;person) &#123; string newname = this-&gt;name + person.name; int newage = this-&gt;age + person.age; Person newperson(newname, newage); return newperson; &#125; void show() &#123; cout &lt;&lt; "Name:" &lt;&lt; name &lt;&lt; ",Age:" &lt;&lt; age &lt;&lt; endl; &#125;public: int age; string name;&#125;;void test()&#123; Person person("Aoki", 20); person.show(); Person p1("Aoki", 20); Person p2("青木", 15); Person p3 = p1.Person_Plus(p2); p3.show();&#125;int main()&#123; test();&#125; 输出结果如下： 4.const修饰成员函数（常函数） 用const修饰成员函数时，const修饰this指针指向的内存区域，成员函数体内不可以修改本类中的任何普通变量 当成员变量类型符前面用mutable修饰时例外 12345678910111213141516171819202122232425262728293031323334#include &lt;iostream&gt;using namespace std;class Person&#123;public: Person() &#123; this-&gt;m_A = 0; this-&gt;m_B = 0; &#125; void showinfor () const &#123; //this-&gt;m_B = 10; this-&gt;m_A=100; cout &lt;&lt; "m_A=" &lt;&lt;m_A&lt;&lt; endl; cout &lt;&lt; "m_B=" &lt;&lt; m_B&lt;&lt;endl; &#125; mutable int m_A;//如果需要使用常函数修改变量，加mutable关键字 int m_B;&#125;;void test()&#123; Person p1; p1.showinfor();&#125;int main()&#123; test();&#125; 当我们试图使用常函数对成员变量进行修改时，编译器会报错。报错结果如下图：由此可知，常函数不能修改this指针指向的值。那么，当我们需要使用常函数对成员变量进行修改时呢？那么，我们可以在变量前面加mutable关键字。输出结果如下： 5.const修饰对象（常对象） 常对象只能调用const的成员函数 常对象可访问const或非const数据成员，但是不能修改，除非成员用mutable修饰 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;iostream&gt;using namespace std;class Person&#123;public: Person() &#123; this-&gt;m_A = 0; this-&gt;m_B = 0; &#125; void showinfor () const &#123; //this-&gt;m_B = 10; this-&gt;m_A = 100; cout &lt;&lt; "m_A=" &lt;&lt;m_A&lt;&lt; endl; cout &lt;&lt; "m_B=" &lt;&lt; m_B&lt;&lt;endl; &#125; void show() &#123; cout &lt;&lt; "m_A=" &lt;&lt; this-&gt;m_A &lt;&lt; endl; cout &lt;&lt; "m_B=" &lt;&lt; this-&gt;m_B &lt;&lt; endl; &#125; mutable int m_A;//如果需要使用常函数修改变量，加mutable关键字 int m_B;&#125;;void test()&#123; const Person p1; Person p2; p2.show(); p2.showinfor(); p1.showinfor(); //p1.m_B = 100; p1.m_A = 20; //p1.show(); cout &lt;&lt; "m_A=" &lt;&lt; p1.m_A &lt;&lt; endl; cout &lt;&lt; "m_B=" &lt;&lt; p1.m_B &lt;&lt; endl;&#125;int main()&#123; test();&#125; 当我试图使用常对象来对成员变量进行修改时，编译器报错如下：常对象不能修改没有关键字mutable修饰的成员变量，也就是说，如果一个变量被关键字mutable修改时，那么常对象可以对其进行修改。当我试图使用常对象来访问普通成员函数时，编译器报错如下：也就说，常对象不能调用普通成员函数，它只能调用常函数。最终输出结果如下所示： 5.常函数与常对象的总结 常函数 常函数格式：返回类型 函数名（）const{} 常函数不能修改this指针指向的值 如果需要修改，就必须用关键字mutable来修饰成员变量 常对象 常对象就是在对象前加上const修饰符，如 const Person p1 常对象不可以调用普通成员函数 常对象可以调用常函数 常对象可以修改用mutable关键字修饰的成员变量]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>this指针</tag>
        <tag>常函数</tag>
        <tag>常对象</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[静态成员]]></title>
    <url>%2F2019%2F03%2F21%2F%E9%9D%99%E6%80%81%E6%88%90%E5%91%98%2F</url>
    <content type="text"><![CDATA[写在前面 在类定义中，它的成员（包括成员变量和成员函数），这些成员可以用关键字static声明为静态的，称为静态成员。不管这个类创建了多少个对象，静态成员只有一个拷贝，这个拷贝被所有属于这个类的对象共享。 1.静态成员变量 在一个类中，若将一个成员变量声明为static，这种成员变量称为静态成员变量。与一般的数据成员不同，无论建立多少个对象，都只有一个静态数据的拷贝。静态成员变量，属于某个类，所有对象共享。静态变量，是在编译阶段就分配空间，对象还没创建，就已经分配空间。 静态成员变量必须在类中声明，在类外定义 静态数据成员不属于某个对象，在为对象分配空间中不包括静态成员所占的空间 静态数据成员可以通过类名或者对象名来引用 123456789101112131415161718192021222324252627282930313233#include &lt;iostream&gt;using namespace std;class Person&#123;public: static int m_Age;private: static int m_other;&#125;;int Person::m_Age = 100;int Person::m_other = 20;void test()&#123; Person p1; p1.m_Age = 10; cout &lt;&lt; "p1=" &lt;&lt; p1.m_Age &lt;&lt; endl; cout &lt;&lt; "p1的地址为：" &lt;&lt; &amp;p1.m_Age &lt;&lt; endl; Person p2; p2.m_Age = 20; cout &lt;&lt; "p1=" &lt;&lt; p1.m_Age &lt;&lt; endl; cout &lt;&lt; "p2=" &lt;&lt; p2.m_Age &lt;&lt; endl; cout &lt;&lt; "p2的地址为：" &lt;&lt; &amp;p2.m_Age &lt;&lt; endl;&#125;int main()&#123; test();&#125; 输出结果如下图：通过输出结果我们可以很清除地看到，静态成员变量是所有对象共享的。任何一个对象都可以改变静态变量的值，但是静态变量不属于任何一个对象。下面我们看一下对象的大小，以此来说明静态数据成员不属于某个对象，在为对象分配的空间中不包括静态成员所占的空间。 12345678910111213141516171819202122232425#include &lt;iostream&gt;using namespace std;class Person&#123;public: static int m_Age;private: static int m_other;&#125;;int Person::m_Age = 100;int Person::m_other = 20;void test()&#123; Person p; cout &lt;&lt; sizeof(p) &lt;&lt; endl; cout &lt;&lt; sizeof(p.m_Age) &lt;&lt; endl;&#125;int main()&#123; test();&#125; 输出结果如下图：我们可以看出，对象的大小为1，而静态成员佰利联的大小为4。当我们尝试去访问m_other时，编译器会报错，因为它是一个私有数据成员，这也说明了静态成员变量是有权限控制机制的。 2.静态成员变量 在类定义中，前面有static说明的成员函数称为静态成员函数。静态成员函数使用方式和静态变量一样，同样在对象没有创建前创建，即可他通过类名调用。静态成员函数主要为了访问静态变量，但是不能访问普通成员变量。静态成员函数的意义，不在于信息共享，数据沟通，而在于管理静态数据成员，完成对静态数据成员的封装。 静态成员函数只能访问静态变量，不能访问普通成员变量 静态成员函数的使用和静态成员变量一样 静态成员函数也有访问权限 普通成员函数可以访问静态成员变量，也可以访问非静态变量 如上图所示，当我们使用静态成员函数试图访问非静态成员变量时，编译器会报错，提示信息如上图所示。在上图中，我试图使用类名来访问私有的静态成员函数，编译器报错，因为静态成员函数也有自己的权限。 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;iostream&gt;using namespace std;class Person&#123;public: static void func()//静态成员函数 &#123; m_Age = 100; //m_A = 20;//作用域 cout &lt;&lt; "静态成员函数调用" &lt;&lt; endl; &#125; static int m_Age; int m_A;private: static int m_other; static void func01() &#123; cout &lt;&lt; "静态成员函数func2调用" &lt;&lt; endl; &#125;&#125;;int Person::m_Age = 100;int Person::m_other = 20;void test()&#123; Person p1; Person p2; p1.func(); p2.func(); Person::func(); //Person::func01();//作用域&#125;int main()&#123; test();&#125; 输出结果如下图： 3.总结 静态成员变量 编译阶段分配内存 所有对象共享数据 通过对象访问，通过类名访问 有权限控制 类内声明，类外初始化 静态成员函数 可以访问静态成员变量，不可以访问普通成员变量 普通成员函数都可以访问 静态成员函数也有权限 可以通过对象访问，也可以通过类名访问]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>静态成员变量</tag>
        <tag>静态成员函数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[拷贝构造函数]]></title>
    <url>%2F2019%2F03%2F21%2F%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[写在前面 默认情况下，C++编译器至少会为我们写的类增加三个函数 默认构造函数（无参，函数体为空） 默认析构函数（无参，函数体为空） 默认拷贝构造函数，对类中非静态成员属性进行简单的值拷贝 如果用户定义了拷贝构造函数，C++不会再提供任何默认的构造函数 如果用户定义了普通构造函数（非拷贝），C++不再提提供默认无参构造，但是会提供默认拷贝构造。 在之前的博文中，我介绍了构造函数和析构函数，这一篇里面，我会对拷贝构造函数单独进行介绍，并介绍深拷贝、浅拷贝等。 1.拷贝构造函数的调用时机 拷贝构造函数的调用时机如下： 用一个对象初始化另一个对象 对象以值传递的方式给函数参数 函数局部对象以值传递的方式从函数返回 下面，我举例说明： 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;iostream&gt;using namespace std;class MyClass&#123;public: MyClass() &#123; cout &lt;&lt; "默认构造函数" &lt;&lt; endl; &#125; MyClass(int a) &#123; cout &lt;&lt; "有参构造函数" &lt;&lt; endl; &#125; MyClass(const MyClass &amp;m) &#123; cout &lt;&lt; "拷贝构造函数调用" &lt;&lt; endl; &#125; ~MyClass() &#123; cout &lt;&lt; "析构函数调用" &lt;&lt; endl; &#125; int ak;&#125;;void test()&#123; MyClass m1; m1.ak = 10; MyClass m2(m1);//用已经创建好的对象来初始化新的对象&#125;int main()&#123; test();&#125; 输出结果如下图:在上面的例子中，我使用了一个已经创建好的对象来初始化一个新的对象。 这也就是拷贝构造函数对的第一个调用时机。下面是第二个调用时机，即对象以值传递的方式给函数参数。 1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;iostream&gt;using namespace std;class MyClass&#123;public: MyClass() &#123; cout &lt;&lt; "默认构造函数" &lt;&lt; endl; &#125; MyClass(int a) &#123; cout &lt;&lt; "有参构造函数" &lt;&lt; endl; &#125; MyClass(const MyClass &amp;m) &#123; cout &lt;&lt; "拷贝构造函数调用" &lt;&lt; endl; &#125; ~MyClass() &#123; cout &lt;&lt; "析构函数调用" &lt;&lt; endl; &#125; int ak;&#125;;void dowork(MyClass m)//以值传递方式给函数传参&#123;&#125;void test()&#123; MyClass m1; m1.ak = 10; dowork(m1);&#125;int main()&#123; test();&#125; 输出结果如下图: 最后，是函数局部对象以值传递的方式从函数返回。 12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;iostream&gt;using namespace std;class MyClass&#123;public: MyClass() &#123; cout &lt;&lt; "默认构造函数" &lt;&lt; endl; &#125; MyClass(int a) &#123; cout &lt;&lt; "有参构造函数" &lt;&lt; endl; &#125; MyClass(const MyClass &amp;m) &#123; cout &lt;&lt; "拷贝构造函数调用" &lt;&lt; endl; &#125; ~MyClass() &#123; cout &lt;&lt; "析构函数调用" &lt;&lt; endl; &#125; int ak;&#125;;MyClass dowork()//函数局部对象以值传递的方式从函数返回&#123; MyClass m1; return m1;&#125;void test()&#123; MyClass m = dowork();&#125;int main()&#123; test();&#125; 输出结果如下： 2.浅拷贝和深拷贝 浅拷贝同一个类型的对象之间可以赋值，使得两个对象的成员变量的值相同，两个对象仍然是独立的两个对象，这种情况被称为浅拷贝。一般情况下，浅拷贝没有任何副作用，但是当类中有指针，并且指针指向动态内存分配的内存空间，析构函数做了动态内存释放的处理，会导致内存问题。 1234567891011121314151617181920212223242526272829303132333435363738394041424344#define _CRT_SECURE_NO_WARNINGS#include &lt;iostream&gt;using namespace std;class Person&#123;public: Person() &#123; &#125; Person(const char *name, int age) &#123; Name = (char*)malloc(strlen(name) + 1); strcpy (Name, name); Age = age; &#125; ~Person() &#123; cout &lt;&lt; "析构函数调用" &lt;&lt; endl; if (Name != NULL) &#123; free(Name); Name = NULL; &#125; &#125;//系统提供默认拷贝构造函数 char *Name; int Age;&#125;;void test()&#123; Person p1("Aoki", 20); Person p2(p1);&#125;int main()&#123; test();&#125; 输出结果如下：我们可以看到，错误提示信息中提到了heap.cpp。此外，输出结果中出现了两次析构函数的调用。下面，我尝试尽可能地解释清楚原因。我们创建了一个对象p1，它有两个属性，一个存放在堆区，一个在栈区，当编译器进行简单的值拷贝时，只是将堆区内容的地址给了新对象p2，接着调用析构函数，释放p1的空间，而存放在堆区的数据也就消失了，紧接着，对象p2也调用析构函数来进行释放。那么，堆区的同一个地址就被释放了两次，引发了异常。图示如下：这时候，我们就要用到深拷贝了。深拷贝当类中有指针，并且此指针有动态分配空间，析构函数做了释放处理，往往需要自定义拷贝构造函数，自行给指针动态分配空间，深拷贝。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#define _CRT_SECURE_NO_WARNINGS#include &lt;iostream&gt;using namespace std;class Person&#123;public: Person() &#123; &#125; Person(const char *name, int age) &#123; Name = (char*)malloc(strlen(name) + 1); strcpy (Name, name); Age = age; &#125; Person(const Person &amp;p)//深拷贝 &#123; Age = p.Age; Name = (char*)malloc(strlen(p.Name) + 1); strcpy(Name, p.Name); &#125; ~Person() &#123; cout &lt;&lt; "析构函数调用" &lt;&lt; endl; if (Name != NULL) &#123; free(Name); Name = NULL; &#125; &#125; char *Name; int Age;&#125;;void test()&#123; Person p1("Aoki", 20); Person p2(p1);&#125;int main()&#123; test();&#125; 输出结果如下：]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>拷贝构造函数</tag>
        <tag>深拷贝</tag>
        <tag>浅拷贝</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[函数重载]]></title>
    <url>%2F2019%2F03%2F21%2F%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD%2F</url>
    <content type="text"><![CDATA[写在前面 如果同一个作用域内的几个函数名字相同，但是形参列表不同，我们称之为重载函数。实现函数重载的条件： 同一个作用域 参数个数不同 参数类型不同 参数顺序不同 函数的名字仅仅是让编译器知道它调用的是哪个函数，而函数重载在一定程度上可以减轻程序员起名字、记名字的负担。 1.定义重载函数 下面是一个函数重载的例子。函数重载使得我们可以定义一组函数，名字都为func。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;iostream&gt;#include&lt;string&gt;using namespace std;namespace A&#123; void func() &#123; cout &lt;&lt; "没有参数" &lt;&lt; endl; &#125; void func(int a) &#123; cout &lt;&lt; "a=" &lt;&lt; a &lt;&lt; endl; &#125; void func(string a) &#123; cout &lt;&lt; "a=" &lt;&lt; a &lt;&lt; endl; &#125; void func(int a, float b) &#123; cout &lt;&lt; "a=" &lt;&lt; a &lt;&lt; " b=" &lt;&lt; b &lt;&lt; endl; &#125; void func(string a, int b) &#123; cout &lt;&lt; "a=" &lt;&lt; a &lt;&lt; " b=" &lt;&lt; b &lt;&lt; endl; &#125;&#125;void test()&#123; A::func(); A::func(15); A::func("Aoki"); A::func(12, 3.12); A::func("Aoki", 15);&#125;int main()&#123; test();&#125; 输出结果如下：虽然我们定义的是五个函数各不相同，但是它们都有同一个名字。编译器根据实参的类型来决定应该调用哪一个函数。对于重载的函数来说，它们应该在形参数量或形参类型上有所不同。对于函数的重载，我们不能以函数的返回值作为重载的条件，这是为什么呢？当编译器能从上下文中确定唯一的函数时，如int ret=func(),这样就不会有问题。但是我们在编写程序的过程中还可以忽略它的返回值，那么这个时候，一个函数为 void fun(int x),另一个为 int func(int x),当我们直接调用func(10)，这时候编译器就不确定该调用哪个函数。所以，在C++中禁止使用返回值作为重载的条件。 对于函数重载，我们还应当注意避免二义性。举例如下： 1234567891011121314151617181920212223242526272829#include &lt;iostream&gt;#include&lt;string&gt;using namespace std;namespace A&#123; void func(string a) &#123; cout &lt;&lt; "a=" &lt;&lt; a &lt;&lt; endl; &#125; void func(string a, int b=10) &#123; cout &lt;&lt; "a=" &lt;&lt; a &lt;&lt; " b=" &lt;&lt; b &lt;&lt; endl; &#125;&#125;void test()&#123; //A::func("Aoki");//出现二义性&#125;int main()&#123; test();&#125; 错误提示如下：在使用函数重载的同时，我们应该注意避免这种情况出现。 2.调用重载的函数 定义了一组重载函数之后，我们需要以合理的实参来调用它们。函数匹配是指一个过程，在这个过程中我们把函数调用与一组重载函数中的某一个关联起来，函数匹配也叫重载确定。编译器首先将调用的实参与重载集合中对的每一个函数的形参进行比较，然后根据比较的结果决定到底调用哪个函数。在很多情况下，我们很容易判断某次调用是不是合法对的，以及当调用合法时该调用哪个函数。通常，重载集中的函数区别明显，它们要不然是参数的数量不同，要不然就是参数类型毫无关系。此时，确定调用哪个函数比较容易。但是在另外一些情况下要想选择函数就比较困难了。比如当两个重载函数参数数量相同，且参数类型可以相互转换。当调用重载函数时有三种可能的结果： 编译器找到一个与实参最佳匹配的函数，并生成了调用该函数的代码。 找不到任何一个函数与调用的实参匹配，此时编译器发出无匹配的错误信息。 有多于一个函数可以匹配，但是每一个都不是明显的最佳选择。此时也发生错误，称为二义性调用。 3.函数重载实现原理 编译器为了实现函数重载，为我们做了一些幕后的工作，编译器用不同的参数类型来修饰不同的函数名，比如 void func();编译器可能会将函数名修饰成—func，当编译器碰到void func(int x)，编译器可能会将函数名修饰为_func_int,当编译器碰到void func(int x,char c)，编译器可能会将函数名修饰为_func_int_char，这里使用可能，是因为编译器如何修饰重载的函数名称并没有一个统一的标准，所以不同的编译器可能会产生不同的内部名。]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>函数重载</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[构造函数和析构函数]]></title>
    <url>%2F2019%2F03%2F20%2F%E5%87%BD%E6%95%B0%E5%92%8C%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[1.初始化和清理 C++中OO思想也是来源于现实，是对现实事物的抽象模拟，具体来说，当我们常见对象的时候，这个对象应该有一个初始状态，当对象销毁之前应该销毁自己创建的一些数据。对象的初始化和清理也是两个非常重要的安全问题，一个对象或者变量没有初始化时，对其使用后果是未知的，同样的使用完一个变量，，没有及时清理，也会造成一定的安全问题。C++为了给我们提供这种问题的解决方案，构造函数和析构函数。这两个函数将会被编译器自动调用，完成对象初始化和对象清理工作。无论我们是否喜欢这种方式，对象的初始化和清理工作是编译器强制我们必须要做的事情，即使我们不提供初始化操作和清理操作，编译器也会给我们增加默认对的操作，只是这个默认初始化操作不会做任何事，所以编写类就应该顺便提供初始化函数。为什么初始化操作时自动调用而不是手动调用？既然是必然操作，那么自动调用会更好，如果靠我们自觉，那么就会存在遗漏初始化的情况出现。 2.构造函数 构造函数主要作用在于创建时为对象的成员属性赋值，构造函数由编译器自动调用，无须手动调用。构造函数语法： 构造函数函数名和类名相同，没有返回值，不能有void，但可以有参数。 ClassName(){} 3.析构函数 析构函数主要用于对象销毁前系统自动调用，执行一些清理工作。析构函数语法： 析构函数函数名是类名前面加”~”组成，没有返回值，不能有void，不能有参数，不能重载。 ~ClassName（）{} 下面我举例说明构造函数与析构函数。 12345678910111213141516171819202122232425#include &lt;iostream&gt;using namespace std;class Person&#123;public: Person() &#123; cout &lt;&lt; "构造函数调用" &lt;&lt; endl; &#125; ~Person() &#123; cout &lt;&lt; "析构函数调用" &lt;&lt; endl; &#125;&#125;;void test()&#123; Person p1;&#125;int main()&#123; test();&#125; 输出结果如下：从输出结果我们可以看出，在创建对象时，构造函数调用。当对象销毁之前，又调用了析构函数。 4.构造函数的分类及调用 按参数类型：分为无参构造函数和有参构造函数 按类型分类：分为普通构造函数和拷贝构造函数（复制构造函数） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;iostream&gt;using namespace std;class Person&#123;public: Person()//默认，无参构造函数 &#123; cout &lt;&lt; "默认构造函数调用" &lt;&lt; endl; &#125; Person(int a)//有参构造函数调用 &#123; cout &lt;&lt; "有参构造函数调用" &lt;&lt; endl; &#125; //拷贝构造函数 Person(const Person&amp; p) &#123; m_age = p.m_age; cout &lt;&lt; "拷贝构造函数调用" &lt;&lt; endl; &#125; ~Person() &#123; cout &lt;&lt; "析构函数调用" &lt;&lt; endl; &#125; long m_age; static int n_age; &#125;;static int n_age = 100;void test()&#123; Person p1(1);//有参拷贝构造函数调用 p1.m_age = 10; cout &lt;&lt; "p1的年龄为：" &lt;&lt; p1.m_age &lt;&lt; endl; Person p2(p1);//拷贝构造函数调用 cout &lt;&lt; "p2的年龄为：" &lt;&lt; p2.m_age &lt;&lt; endl; Person(100);//匿名对象，当本行代码执行完毕就释放对象 Person p3 = 100;//隐式类型转换，相当于调用了Person p7=Person(100) Person p4 = p3;//拷贝构造函数调用，相当于Person p4=Person(p3)&#125;int main()&#123; test(); return 0;&#125; 输出结果如下：这里，我们需要注意的是，析构函数和构造函数必须写在public下才可以调用。同时，对于无参构造函数（默认构造）、有参构造函数在创建对象时的调用应当注意。当我们我们没有定义构造函数时，系统会给我们提供一个空的默认构造函数，但是当我们定义了无参构造函数时，系统使用我们的构造函数。除此之外，当我们定义了一个有参构造函数，但是并没有提供无参构造函数时，在创建对象的时候必须使用有参构造。原因是，当我们声明一个有参构造函数之后，系统不再提供默认构造函数。]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>析构函数</tag>
        <tag>构造函数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于C语言下的封装和C++语言封装的区别]]></title>
    <url>%2F2019%2F03%2F19%2FC%E8%AF%AD%E8%A8%80%E4%B8%8B%E7%9A%84%E5%B0%81%E8%A3%85%E5%92%8CC-%E8%AF%AD%E8%A8%80%E5%B0%81%E8%A3%85%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[1.封装 我们编写程序来解决现实中的问题，而这些问题的是由各种事物组成的。我们解决这个问题的前提就是将事和物抽象得到计算机程序中，也就是用程序语言表示现实的事物。现实世界的事物所具有的共性就是每个事物都具有自身的属性和行为，所以如果我们能把这些事物的属性和行为表示出来，那么就可以抽象出这个事物。属性和行为应该放在一起，一起来表示一个具有属性和行为的对象。为什么需要这样做呢？我稍后解释。假如某对象的某项属性不想被外界获知，比如女孩子的体重，那么对于体重这个属性，就应该是只有女孩自己知道的属性，或者女孩的某些行为，比如暗恋某个男生，不想让外界知道，只能让自己知道，那么在这种情况下，封装应该提供一种机制，能够给属性和行为的访问权限控制住。所以说封装特性包含两方面，一个是属性和变量合成一个整体，一个是给属性和函数增加访问权限。 封装 把变量（属性）和函数（操作）合成一个整体，封装在一个类中。 对变量和函数进行访问控制。 访问权限 在类的内部（作用域范围之内），没有访问权限之分，所有成员可以相互访问。 在类的外部（作用域范围外），访问权限才有意义：public,private,protected 在类的外部，只有public修饰的成员才能被访问，在没有涉及继承和派生时，private和protected是同等级的，外界不可以访问。 访问属性 属性 对象内部 对象外部 public 公有 可访问 可访问 protected 保护 可访问 不可访问 private 私有 可访问 不可访问 其中，potected为保护权限，类内部可以访问，当前类的子类可以访问，类外部不可以。而private是对象的私有数据，子类和类外部都不可以访问。 下面，我们对比以下C语言下的封装和C++语言下封装的区别。 2.C语言下的封装 在C语言中我们可以定义一个结构体来表示一个对象所包含的属性，函数用来表示出来一个事物，在C语言中，结构体中不能定义函数，所以行为和定义方式分开的，也就是说吃饭这个属性不属于某个对象，而属于所有的共同数据。 1234567891011121314151617181920212223242526272829303132333435363738394041424344#define _CRT_SECURE_NO_WARNINGS#include&lt;stdio.h&gt;#include&lt;string.h&gt;#include&lt;stdlib.h&gt;struct person &#123; char name[10]; int age;&#125;;void PersonEat(struct person *p)&#123; printf("%s在吃饭\n", p-&gt;name);&#125;struct Dog&#123; char name[10]; int age;&#125;;void DogEat(struct Dog *d)&#123; printf("%s在狗粮\n", d-&gt;name);&#125;void test01()&#123; struct Dog one; strcpy(one.name, "旺财"); DogEat(&amp;one); struct person two; strcpy(two.name, "Aoki"); DogEat(&amp;two);&#125;void main()&#123; test01(); system("pause");&#125; 输出结果如下：从输出结果我们可以看出，小狗旺财和Aoki这个人正在一块吃狗粮，但是正常情况下，Aoki怎么可能吃狗粮呢？从这里，我们可以看出在C中封装一个对象造成了什么样的后果。那么，在C++中的封装呢？ 123456789101112131415161718192021222324252627282930313233343536373839#define _CRT_SECURE_NO_WARNINGS#include &lt;iostream&gt;using namespace std;struct Person&#123; char name[10]; int age; void PersonEat() &#123; cout &lt;&lt; name &lt;&lt; "在吃饭" &lt;&lt; endl; &#125;&#125;;struct Dog&#123; char name[10]; int age; void DogEat() &#123; cout &lt;&lt; name &lt;&lt; "在吃狗粮" &lt;&lt; endl; &#125;&#125;;void test()&#123; Person one; strcpy(one.name, "Aoki"); one.PersonEat(); //one.DogEat();&#125;int main()&#123; test();&#125; 刚开始，我尝试了使用one这个对象来调用DogEat这个函数，编译器报错，不允许我们使用它，因为DogEat并不是Person的成员函数。编译器报错如下：在注释掉报错语句之后，正确输出结果如下：从上面的例子中，我们可以看到，C++中的封装，有着严格的类型转换检测，C++让属性和行为绑定在一起。属性和行为作为一个整体来表示生活中的事物。]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>封装</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[宏缺陷和内联函数]]></title>
    <url>%2F2019%2F03%2F18%2F%E5%AE%8F%E7%BC%BA%E9%99%B7%E5%92%8C%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[写在前面 C++从C中继承的一个重要特征就是效率。 在C中我们经常把一些短并且执行频繁的计算写成宏，而不是函数，这样做的理由方式为了执行效率，宏可以避免函数调用的开销，这些都由预处理来完成。 但是在C++出现以后，使用宏处理会出现两个问题： 第一个在C中也会出现，宏看起来像是一个函数调用，但是会隐藏一些难以发现的错误。 第二个问题是C++特有的，预处理器不允许访问类的成员，也就是说预处理器宏不能用作类的成员的函数。 为了保持预处理宏的效率又增加安全性，而且能像一般成员函数那样在类里访问自如，C++引入了内联函数。 内联函数为了继承宏函数的效率，没有函数调用的开销，然后又可以像普通函数那样，可以进行参数、返回值类型的安全检查，又可以作为成员函数。 1.预处理宏的缺陷 预处理器宏存在问题的关键是我们可能认为预处理器的行为和编译器时一样的。当然也是由于宏函数调用和函数调用在外表看起来是一样的，因此也容易混淆。但是其中会有一些微妙的问题出现。 例112345678910111213141516171819202122232425262728293031323334353637#include &lt;iostream&gt;using namespace std;#define ADD(x,y) x+yvoid test()&#123; int ret = ADD(10, 10); int ret0 = ADD(10, 10) * 10;//预期结果为200 cout &lt;&lt; "ret=" &lt;&lt; ret &lt;&lt; endl; cout &lt;&lt; "ret0=" &lt;&lt; ret0 &lt;&lt; endl;&#125;int main()&#123; test();&#125; 输出结果如下： 在输出结果里，我们可以看到，实际输出结果为110，并不是我们想要的结果。它实际进行运算时，运算式应该是：10+10*10。 对于这个微小的问题，我们可以通过加括号的方式来解决它。源代码和输出结果如下： 123456789101112131415161718192021222324252627282930313233#include &lt;iostream&gt;using namespace std;#define ADD(x,y) ((x)+(y))void test()&#123; int ret = ADD(10, 10); int ret0 = ADD(10, 10) * 10;//预期结果为200 cout &lt;&lt; "ret=" &lt;&lt; ret &lt;&lt; endl; cout &lt;&lt; "ret0=" &lt;&lt; ret0 &lt;&lt; endl;&#125;int main()&#123; test();&#125; 输出结果如下： 我们可以看到，加括号之后，输出结果和预期相同。 例2为了防止出现例1中的问题，这次，我特意对三目运算符加了括号。代码如下： 1234567891011121314151617181920212223242526272829303132333435#include &lt;iostream&gt;using namespace std;#define compare(a,b) ((a)&lt;(b))?(a):(b)void test()&#123; int a = 10; int b = 20; int ret = compare(a, b); cout &lt;&lt; "ret=" &lt;&lt; ret &lt;&lt; endl; int ret0 = compare(++a, b); cout &lt;&lt; "ret0=" &lt;&lt; ret0 &lt;&lt; endl;&#125;int main()&#123; test();&#125; 输出结果如下: 这次出现的问题让人有点摸不到头脑，因此++运算符表示在进行运算之前加1，但是输出结果中，实际输出为12，相当于加了两次。 除此之外，我们还应当注意的是，预定义宏函数没有作用域概念，无法作为一个类的成员函数，也就是说，预定义宏没办法表示类的范围。 2.内联函数 在C++中，预定义宏额概念是用内联函数来实现的，而内联函数本身也是一个真正的函数。内联函数具有普通函数的所有行为。唯一不同之处在于内联函数会在适当得到地方像预定义宏一样展开，所以不需要函数调用的开销。因此应该不使用宏，使用内联函数。 普通函数（非成员函数）函数前面加上inline关键字使之成为内联函数。但是必须注意函数体和声明结合在一起，否则编译器会把它当成普通函数对待。 1inline void func(int a); 上面的这种写法没有任何效果，仅仅是声明函数，应该像下面这样的方式来定义。 1234567inline void func(int a)&#123; return ++;&#125; 注意：编译器将会检查函数参数列表使用是否正确，并返回值（进行必要的转换）。这些事预处理器是无法完成的。 内联函数的确占用空间，但是内联函数相对于普通函数的优势只是省去了函数调用是否的压栈、跳转、返回的开销。我们可以理解为内联函数是以空间换时间。 内联说明只是向编译器发出一个请求，编译器可以选择忽略这个请求。 一般来说，内联机制用于优化规模较小、流程直接、频繁调用的函数。很多编译器都不支持内联函数递归函数，而且一个75行的函数也不太可能在调用点内联地展开。]]></content>
      <tags>
        <tag>宏缺陷</tag>
        <tag>内联函数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[函数默认参数及占位参数]]></title>
    <url>%2F2019%2F03%2F18%2F%E5%87%BD%E6%95%B0%E9%BB%98%E8%AE%A4%E5%8F%82%E6%95%B0%E5%8F%8A%E5%8D%A0%E4%BD%8D%E5%8F%82%E6%95%B0%2F</url>
    <content type="text"><![CDATA[1.函数默认参数C++在声明函数原型时可为一个或多个参数指定默认（缺省）的参数值，当函数调用的时候如果没有指定这个值，编译器会自动用默认值代替。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;iostream&gt;using namespace std;void func01(int a = 10, int b = 100)&#123; cout &lt;&lt; "a+b=" &lt;&lt; a + b &lt;&lt; endl;&#125;void func02(int a, int b = 12, int c = 11)&#123; cout &lt;&lt; "a=" &lt;&lt; a &lt;&lt; ",b=" &lt;&lt; b &lt;&lt; ",c=" &lt;&lt; c &lt;&lt; endl;&#125;void func03(int a = 0, int b = 0);void func03(int a, int b)&#123; cout &lt;&lt; "a=" &lt;&lt; a &lt;&lt; ",b=" &lt;&lt; b &lt;&lt; endl;&#125;int main()&#123; func01();//使用默认参数 func01(100, 100);//使用现在传入的参数 func01(110);//只传入一个参数，第二个参数使用默认参数 func02(12);//b，c使用默认参数 func03();//没有传参数，使用默认参数 return 0;&#125; 输出结果如下： 注意点： 函数的默认常数函数从左往右，如果一个参数设置了默认参数，那么这个参数之后的参数都必须设置默认参数。 如果函数声明和函数定义分开写，函数声明与函数定义不能同时设置默认参数。 2.函数的占位符 C++在声明函数时，可以使用占位参数。占位参数只有类型声明，而没有参数名声明。一般情况下，在函数体内无法使用占位参数。 12345678910111213141516171819202122232425262728293031323334353637#include &lt;iostream&gt;using namespace std;void func01(int a,int b,int) &#123; //函数内部无法使用占位参数 cout &lt;&lt; a + b &lt;&lt; endl;&#125;void func02(int a, int b, int = 10)&#123; //无法使用占位参数 cout &lt;&lt; a + b &lt;&lt; endl;&#125;int main()&#123; func01(10, 15, 20); func02(10, 25);//占位参数使用默认参数 return 0;&#125; 输出结果如下：]]></content>
      <tags>
        <tag>默认参数</tag>
        <tag>占位参数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++命名空间及using的使用]]></title>
    <url>%2F2019%2F03%2F16%2FC-%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%E5%8F%8Ausing%E7%9A%84%E4%BD%BF%E7%94%A8-1%2F</url>
    <content type="text"><![CDATA[一、C++命名空间&emsp;在C++中，名称（name）可以是符号常量、变量、函数、结构、枚举、类和对象。工程越大，名称相互冲突性的可能性越大。另外，在使用多个厂商的类库时，也可能导致名称冲突。为了避免冲突，在大规模的设计中，以及程序员使用1各种各样的C++库时，这些标识符的命名发生冲突，标准C++引入关键字namesapce（命名空间/名字空间/名称空间），可以更好的控制标识符得到作用域。 12345678910111213141516171819202122232425262728293031323334353637#include &lt;iostream&gt;using namespace std;//创建一个命名空间namespace study&#123; int a = 10;&#125;namespace learn&#123; int a = 20;&#125;int main()&#123; cout &lt;&lt; "命名空间study的a="&lt;&lt;study::a &lt;&lt; endl; cout &lt;&lt;"命名空间learn的a="&lt;&lt; learn::a &lt;&lt; endl;&#125; 运行结果输出： 在命名空间下，可以定义函数，变量、结构体、类；除此之外，对于命名空间的定义还应当注意，它必须定义在全局作用域下。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include &lt;iostream&gt;#include&lt;string&gt;using namespace std;namespace study&#123; int a = 10; namespace A &#123; int a = 100; void sayhi() &#123; cout &lt;&lt; "hi,Aoki" &lt;&lt; endl; &#125; struct Student &#123; string name; &#125;; &#125;&#125;namespace learn&#123; int a = 20;&#125;int main()&#123; //cout &lt;&lt; "命名空间study的a="&lt;&lt;study::a &lt;&lt; endl; //cout &lt;&lt;"命名空间learn的a="&lt;&lt; learn::a &lt;&lt; endl; study::A::sayhi(); cout &lt;&lt; "作用域A下的a=" &lt;&lt; study::A::a &lt;&lt; endl;&#125; 输出结果： 下面是对命名空间错误定义的举例： 对于命名空间，我们还可以定义无名命名空间，意味着命名空间中的标识符只能在本文件中访问，相当于给这个标识符加上了static，使得其可以作为内部连接。 除此之外，还有就是给命名空间起别名，我们为命名空间A起别名为b，源码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;iostream&gt;#include&lt;string&gt;using namespace std;namespace A&#123; int a = 100; void test() &#123; namespace b = A;//给命名空间起别名为b cout &lt;&lt;"A作用域内a="&lt;&lt; b::a &lt;&lt; endl; &#125;&#125;namespace //无名（匿名）命名空间&#123; int c = 15; int d = 16;&#125;int main()&#123; cout &lt;&lt; "c=" &lt;&lt; c &lt;&lt; endl; cout &lt;&lt; "d=" &lt;&lt; d &lt;&lt; endl; A::test();&#125; 运行结果如下图： 下面对命名空间namespace的用法总结如下： 命名空间的用途：解决名称冲突问题 命名空间下可以定义函数、变量、结构、类 命名空间必须定义在全局作用域下 命名空间可以嵌套命名空间 命名空间是开放的，可以随时给原先的命名空间添加内容 定义另个名字相同的命名空间时，两个命名空间会合并，但是不会覆盖 当我们定义了无名空间时，相当于写了static intc=15，static int d=16，只能在当前文件内使用 二、using声明using声明可使得指定的标识符可用 1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;iostream&gt;using namespace std;namespace One&#123; int test = 100;&#125;void test()&#123; int test = 100; using One::test;//using声明 cout &lt;&lt; "test=" &lt;&lt; test &lt;&lt; endl;&#125;int main()&#123; test();&#125; 此处我们使用了using声明，但是编译却发生了错误。因为在test()中我们定义了一个整型数test，并赋予了初值。当我们使用using声明时，编译器有就近原则，它会选择输出test中定义的整型数，但是又发现有using声明，出现二义性问题，编译器不知道怎么处理，所有报错。报错信息如下： 所以，在using声明中，我们应当注意避免二义性问题。 1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;iostream&gt;using namespace std;namespace One&#123; int test = 100;&#125;void test()&#123; int test = 100; //using One::test;//using声明 cout &lt;&lt; "test=" &lt;&lt; test &lt;&lt; endl;&#125;int main()&#123; test();&#125; 输出结果如下图： using声明的一个例子： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include &lt;iostream&gt;using namespace std;namespace One&#123; int test = 100; int a = 99; int b = 30; void func() &#123; cout &lt;&lt; "hi,Aoki!" &lt;&lt; endl; &#125; void func1() &#123; cout &lt;&lt; "hello,Aoki!" &lt;&lt; endl; &#125;&#125;void test()&#123; cout &lt;&lt; "test=" &lt;&lt; One::a &lt;&lt; endl; //using声明 using One::a; using One::func1; using One::func; cout &lt;&lt; "a=" &lt;&lt; a &lt;&lt; endl; func1(); func();&#125;int main()&#123; test();&#125; 运行结果如下图： 下面是using声明遇到函数重载的一个例子： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include &lt;iostream&gt;using namespace std;namespace Two&#123; void func() &#123; cout &lt;&lt; "Nothing!" &lt;&lt; endl; &#125; void func(int x) &#123; cout &lt;&lt; x &lt;&lt; endl; &#125; void func(int x, int y) &#123; cout &lt;&lt; "x=" &lt;&lt; x ; cout &lt;&lt; ",y=" &lt;&lt; y &lt;&lt; endl; &#125;&#125;void test1()&#123; using Two::func; func(); func(15); func(15, 20);&#125;int main()&#123; test1();&#125; 输出结果如下图： 如果命名空间包含一组用相同名字重载的函数，using声明就声明了这个重载函数的所有集合。 三、using编译指令using编译指令使整个命名空间标识符可用。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879#include &lt;iostream&gt;using namespace std;namespace One&#123; int a = 99; int b = 30; void func() &#123; cout &lt;&lt; "hi,Aoki!" &lt;&lt; endl; &#125; void func1() &#123; cout &lt;&lt; "hello,Aoki!" &lt;&lt; endl; &#125;&#125;void test()&#123; using namespace One; cout &lt;&lt; a &lt;&lt; endl; cout &lt;&lt; b &lt;&lt; endl; func(); func1(); int a = 100;//没有产生二义性 cout &lt;&lt; a &lt;&lt; endl;&#125;namespace Two&#123; int a = 1; int b = 2;&#125;;void test1()&#123; //产生二义性 using namespace One; using namespace Two; cout &lt;&lt; a &lt;&lt; endl;&#125; 当我们像上面一样使用using编译指令时，会出现二义性问题，编译器无法通过编译。错误信息如下： 当我们使用using声明或using编译指令时，会增加命名冲突的可能性。也就是说，如果有命名空间，并在代码中使用作用域解析运算符，则不会出现二义性问题。 例子如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091#include &lt;iostream&gt;using namespace std;namespace One&#123; int a = 99; int b = 30; void func() &#123; cout &lt;&lt; "hi,Aoki!" &lt;&lt; endl; &#125; void func1() &#123; cout &lt;&lt; "hello,Aoki!" &lt;&lt; endl; &#125;&#125;void test()&#123; using namespace One; cout &lt;&lt; a &lt;&lt; endl; cout &lt;&lt; b &lt;&lt; endl; func(); func1(); int a = 100; cout &lt;&lt; a &lt;&lt; endl;&#125;namespace Two&#123; int a = 1; int b = 2;&#125;;void test1()&#123; using namespace One; using namespace Two; //cout &lt;&lt; a &lt;&lt; endl;&#125;int main()&#123; test(); test1();&#125; 输出结果如下： 当我们引入一个全局的using编译指令时，就为该文件打开了命名空间，它不会影响其他的文件，所以可以再每一个实现文件中调整对命名空间的控制。比如，如果发现某一个实现文件中有太多using指令而产生命名冲突，就要对该文件做个简单的改变，通过明确限定或者using声明来消除名字冲突，这样不需要修改其他实现文件。]]></content>
      <tags>
        <tag>命名空间</tag>
        <tag>using的使用</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于const限定符的一些总结]]></title>
    <url>%2F2019%2F03%2F11%2Fconst%E9%99%90%E5%AE%9A%E7%AC%A6%2F</url>
    <content type="text"><![CDATA[写在前面 有时候我们希望定义这样一种变量，它的值不能被改变。例如，用一个变量表示缓冲区的大小。使用变量的好处是我们觉得缓冲区不再合适的时候，很容易对其进行调整。另一方面，也应随时警惕，防止程序一不小心修改了这个值。为了满足这一要求，可以用关键词const对变量的类型加以限定。 在C++中，一个const不必创建内存空间，而在C中，const总是需要一块内存空间。在C++中，是否为const常量分配内存空间依赖于如何使用。一般来说，如果一个const仅仅用来把一个名字用一个值来代替，那么该存储空间就不必创建。 在存储空间没有分配内存的话，在进行完数据类型检查后，为了代码更加有效，值也许会折叠到代码中。不过取一个const地址，或者把它定义为extern，则会为该const创建内存空间。 在C++中，出现在所有函数之外的const作用于整个文件（也就是说它在该文件外部不可见，默认为内部连接，C++中其他标识符一般默认为外部连接。 1.初始化和const const类型的对象能完成非const类型所能完成的大部分操作，但是对于const类型对象的主要限制就是只能在const类型对的对象上执行不改变其内容的操作。 在不改变const对象的操作中还有一种是初始化，如果利用一个对象去初始化另外一个对象，则它们是不是const都无关紧要。 123456789101112#include &lt;iostream&gt;using namespace std;int main()&#123; int i = 12; const int ci = i;//i的值拷贝给了ci int j = ci; cout &lt;&lt; "i=" &lt;&lt; i &lt;&lt; endl; cout &lt;&lt; "ci=" &lt;&lt; ci &lt;&lt; endl; cout &lt;&lt; "j=" &lt;&lt; j &lt;&lt; endl;&#125; 输出结果如下： ![](https://i.imgur.com/RpcPLLp.png) 2.const引用 可以把引用绑定到const对象上，就像绑定到其他对象上一样，我们称之为——常量引用。 与普通引用不同的是，对常量的引用不能被用作修改它所绑定的对象。 错误示范如下： 3.初始化和对const的引用 引用的类型必须与其所引用对象的类型一致，但是有两个情况例外。第一个例外情况就是在初始化常量引用时，允许用任意表达式作为初始值，只要该表达式的结果能转化成引用的类型即可。 允许一个常量引用绑定非常量的对象、字面值、甚至是一般表达式。 123456789101112131415#include &lt;iostream&gt;using namespace std;int main()&#123; int i = 42; const int &amp;r1 = i;//允许将const int &amp;绑定到一个普通int对象上 const int &amp;r2 = 42;//r1是一个常量引用 const int &amp;r3 = r1 * 2;//r3是一个常量引用 cout &lt;&lt; "i=" &lt;&lt; i &lt;&lt; endl; cout &lt;&lt; "r1=" &lt;&lt; r1 &lt;&lt; endl; cout &lt;&lt; "r2=" &lt;&lt; r2 &lt;&lt; endl; cout &lt;&lt; "r3=" &lt;&lt; r3 &lt;&lt; endl;&#125; 输出结果如下： 4.对cons的引用可能引用一个并非const的对象 12345678910111213141516171819#include &lt;iostream&gt;using namespace std;int main()&#123; int i = 42; int &amp;r1 = i;//引用r1绑定对象i const int &amp;r2 = i;//常量引用r2绑定i，但是r2不能修改i的值 cout &lt;&lt; "i=" &lt;&lt; i &lt;&lt; endl; cout &lt;&lt; "r1=" &lt;&lt; r1 &lt;&lt; endl; cout &lt;&lt; "r2=" &lt;&lt; r2 &lt;&lt; endl; r1 = 10; cout &lt;&lt; "i=" &lt;&lt; i &lt;&lt; endl; cout &lt;&lt; "r1=" &lt;&lt; r1 &lt;&lt; endl; cout &lt;&lt; "r2=" &lt;&lt; r2 &lt;&lt; endl; //r2 = 5;//此处报错，因为r2是一个常量引用&#125; 输出结果如下： 对于常量引用来说，一般情况下是没有办法来对它进行修改的，但是可以使用下面的方法来尝试对常量引用进行修改。代码图如下： 1234567891011#include &lt;iostream&gt;using namespace std;int main()&#123; const int &amp;ref = 10; cout &lt;&lt; "ref=" &lt;&lt; ref &lt;&lt; endl; int *p = (int *)&amp;ref; *p = 100; cout &lt;&lt; "ref=" &lt;&lt; ref &lt;&lt; endl;&#125; 输出结果如下：这里我们使用了一个指针来对常量引用进行修改。首先，我们要知道的是，常量引用不是一个对象，编译器并没有给它分配内存空间。当我们使用指针指向常量引用时，编译器会给常量引用临时开辟一块内存空间。代码示意如下： 12int tmp=ref;//tmp有内存int *p=(int *)&amp;ref;//*p指向的是那块临时空间，临时空间看不到 5.指针和const 与引用一样，也可以令指针指向常量或非常量。类似于常量引用，指向常量的指针不能改变其所指对象的值。要想存放常量对象的地址，只能使用指向常量的指针。 实例代码如下： 123456789101112131415#include &lt;iostream&gt;using namespace std;int main()&#123; const int i = 10; //int *r1 = &amp;i;//报错，r1是一个普通指针，并不能指向一个常量 const int *r2 = &amp;i;//常量指针指向常量 //常量指针可以指向常量，但是并不能修改常量的值 cout &lt;&lt; "常量i的地址为：" &lt;&lt; &amp;i &lt;&lt; endl; cout &lt;&lt; "r2指向的地址为：" &lt;&lt; r2 &lt;&lt; endl; cout &lt;&lt; "i=" &lt;&lt; i &lt;&lt; endl; cout &lt;&lt; "r2=" &lt;&lt; *r2 &lt;&lt; endl;&#125; 输出结果如下： 6.const指针 指针是对象而引用不是，就像其他对象类型一样，允许把指针本身定义为常量。常量指针必须初始化，而且一旦初始化完成，则它的值（也就是存放在指针中的那个地址）就不能再修改。把*放在const关键字之前用以说明指针是一个常量。这样书写的意味着，不变的是指针本身的值，而不是指向的那个值。 12345678910111213141516#include &lt;iostream&gt;using namespace std;int main()&#123; int i = 10; int *const r1 = &amp;i;//r1将一直指向i const int i1 = 11; const int *const r2 = &amp;i1;//r2是指向常量的常量指针 cout &lt;&lt; "i=10时地址为：" &lt;&lt; &amp;i &lt;&lt; endl; cout &lt;&lt; "常量指针r1指向的地址为：" &lt;&lt; r1 &lt;&lt; endl; i = 100; cout &lt;&lt; "i=100时地址为：" &lt;&lt; &amp;i &lt;&lt; endl; cout &lt;&lt; "常量指针r1指向的地址为：" &lt;&lt; r1 &lt;&lt; endl;&#125; 输出结果如下： 7.顶层const 指针本身就是一个对象，它又可以指向1另外一个对象。因此指针本身是不是常量，以及指针指向的对象是不是一个常量是两个独立的问题。 顶层const表示指针本身是一个常量。 底层const表示指针所指的对象时一个常量。 更一般地，顶层const可以表示任意的对象时常量，这一点对任何数据类型都适用，如算术类型、类、指针等。底层const则与指针和引用等符合类型的基本类型有关。比较特殊的是，指针类型既可以是顶层const，也可以是底层const。 8.尽量使用const代替#define 在旧版本的C中，如果想建立一个常量，必须使用预处理器。 1#define MAX 1024; 这里我们定义的宏MAX从未被编译器看到过，因为在预处理阶段，所有的MAX已经全部被替换成了1024，于是MAX并没有将其加入符号表中。但是我们使用这个常量获得一个编译错误信息时，可能会带来一些困扰，因为这个信息可能会提到1024，但是并没有提到MAX。如果MAX被定义在一个不是我们自己写的头文件中，我们可能并不知道1024代表着什么，也许解决这个问题需要很长的时间。解决这个问题的办法就是用一个常量来替换掉上面的宏： 1const int MAX=1024； 1#undef A //卸载宏常量A ###const和#define的区别 const有类型，可进行编译器类型安全检查，#define无类型，不可进行类型检查 const有作用域，而#define不重视作用域，默认定义处到文件末尾，如果定义在指定作用域下有效的常量，那么#define就不能用。]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>限定符</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++复合类型]]></title>
    <url>%2F2019%2F03%2F09%2FC-%E5%A4%8D%E5%90%88%E7%B1%BB%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[复合类型是指基于其他类型定义的类型。C++有几种复合类型，下面主要是引用和指针。 定义复合类型的变量复杂很多，通用的描述为：一条声明语句由一个基本数据类型和紧随其后的一个声明符列表组成。每个声明符命名了一个变量并指定该变量为与基本数据类型有关的某种类型。 引用 C++11中新增加了一种引用，为右值引用，主要用于内置类。这里，我们使用引用时，指的是左值引用。 引用为对象起了另外一个名字，引用类型引用另外一种类型。通过将声明符写成&amp;d的形式来定义引用类型，其中d是声明的变量名。引用即别名，并非对象，它只是为一个已经存在的对象所起的另外一个名字。下面是引用的一个例子。 123456789101112#include &lt;iostream&gt;using namespace std;int main()&#123; int vale = 1024; int &amp;vale00 = vale; //注意：引用必须进行初始化 cout &lt;&lt; "vale的值为：" &lt;&lt; vale &lt;&lt; endl; cout &lt;&lt; "vale00的值为：" &lt;&lt; vale00 &lt;&lt; endl; cout &lt;&lt; "vale00是vale的引用。" &lt;&lt; endl;&#125; 定义了一个引用之后，对其进行的所有操作都是在与之绑定的对象上进行的。为引用赋值，实际上是把值赋给了与引用绑定的对象。获取引用的值，实际上是获取到了与之绑定的对象的值。同理，以引用作为初始值，实际上是以引用绑定的对象作为初始值。 1234567891011121314#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;int main()&#123; string name = "青木"; string &amp;name_ = name; string name0 = "Aoki"; cout &lt;&lt; "大家好，我的名字是" &lt;&lt; name_ &lt;&lt; endl; cout &lt;&lt; "大家好，我是" &lt;&lt; name0 &lt;&lt; endl; name0 = name_;//为引用赋值 cout &lt;&lt; "大家好，我现在是" &lt;&lt; name0 &lt;&lt; endl;&#125; 输出结果为： 引用 指针是指向另外一种类型的复合类型。与引用类似，指针也实现了对其他对象的间接访问，但是指针与引用也有很多不同点，如下： 指针本身就是个对象，允许对指针赋值和拷贝，在指针的生命周期内，它可以先后指向几个不同的对象 指针无须在定义时赋初值。和其他内置类型一样，在块作用域内定义的指针如果没有定义，也将拥有一个不确定的值。 >## 获取对象的地址 指针存放某个对象的地址，要向获取该地址，就要使用取地址符（&amp;）。在声明语句中，指针的类型实际上被用于它所指向的对象的类型，所以二者必须匹配。如果指针指向了一个其他类型的对象，对该对象的操作将会发生错误。 123456789101112#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;int main()&#123; string name = "青木"; string* name_=&amp;name;//name_存放变量name的地址，或者说name_是指向变量name的指针 cout &lt;&lt; "大家好，我的名字是" &lt;&lt; name &lt;&lt; endl; cout &lt;&lt; "name的地址为:" &lt;&lt; name_ &lt;&lt; endl; cout &lt;&lt; "大家好，我的名字是" &lt;&lt; name_ &lt;&lt; endl;&#125; 输出结果为： 指针值 指针的值（即地址）应属于下列4中状态之一： 指向一个对象 指向紧邻对象所占空间的下一个位置 空指针，意味着指针没有指向任何值 无效指针，就是上述状态之外的其他值。 对于无效指针，试图拷贝或以其他方式访问无效指针的值都将引发错误。 >## 利用指针访问对象 如果一个指针指向了一个对象，则允许使用解引用符（*）来访问该对象。对指针解引用会得到所指的对象，因此如果给解引用的结果赋值，实际上也就是给指针所指的内容赋值。 注意：解引用操作仅适用于那些确实指向了某个对象的有效指针。 12345678910111213141516#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;int main()&#123; string name = "青木"; string name0 = "Aoki"; string* name_=&amp;name;//name_存放变量name的地址，或者说name_是指向变量name的指针 cout &lt;&lt; "大家好，我的名字是" &lt;&lt; name &lt;&lt; endl; cout &lt;&lt; "name的地址为:" &lt;&lt; name_ &lt;&lt; endl; cout &lt;&lt; "大家好，我的名字是" &lt;&lt; *name_ &lt;&lt; endl;//指针解引用，获取对象的值 *name_ = name0;//经由指针为name赋值 cout &lt;&lt; "大家好，我的名字是" &lt;&lt; name &lt;&lt; endl; cout &lt;&lt; "大家好，我的名字是" &lt;&lt; *name_ &lt;&lt; endl;&#125; ![](https://i.imgur.com/lno4Q9r.png) 空指针 空指针不指向任何对象，在试图使用一个指针之前，代码可以首先检查它是否为空。生成空指针的方法： 12int* p1=nullptr;//等价于int* ptr=0int* p2=0;//直接将p2初始化为字面常量0 得到空指针最直接的办法是使用字面值nullptr来初始化指针。nullptr是一种特殊的指针，它可以被转换成任意其他指针类型。 赋值和指针 指针额引用都能够提供对其他的对象的间接访问，但是在具体的实现细节上两者有很大不同，其中最主要的又掉了是引用本身并不是一个对象。指针和它存放的地址之间没有这种限制。和其他任何变量一样，给指针赋值就是令它存放一个新地址，从而指向一个新对象。对于指针的赋值，前文已经给出。 其他指针操作 只要指针拥有一个合法值，就能将它用在条件表达式中。和采用算术值作为条件遵循的规则一样，如果指针的值是0，条件取false。对于两个类型相同的合法指针，可以用相等操作符或不相等操作符来比较它们，比较的结果是布尔类型。两个指针存放的地址值相同（两个指针相等），有三种可能： 它们都为空 都指向同一个对象 都指向同一个对象的下一个地址 1234567891011121314#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;int main()&#123; string name = "青木"; string* name_=&amp;name;//name_存放变量name的地址，或者说name_是指向变量name的指针 int* a = nullptr; if (name_&amp;&amp;a) //与运算，一真一假为假 cout &lt;&lt; "大家好，我是指向" &lt;&lt; name &lt;&lt; "的指针，我不为空" &lt;&lt; endl; else cout &lt;&lt; "大家好，我是空指针a，我的地址是" &lt;&lt; &amp;a &lt;&lt; endl;&#125; 输出结果如下： 最后是void*指针。 void* 指针 void* 指针是一种特殊的指针类型，可用于存放任意对象的指针，一个void指针存放着一个地址。利用void指针可以做的事有： 拿它和别的指针比较 作为函数的输入和输出 赋值给另外一个void*指针 但是我们不能直接操作void* 指针，因为它的类型未知。以void*的视角来看内存空间也仅仅是内存空间，没办法访问内存空间中所存的对象。 12345678910111213#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;int main()&#123; int a = 10; int* name_=&amp;a;//name_存放变量a的地址，或者说name_是指向变量a的指针 void* names; names = name_; cout &lt;&lt; "name_指向的值为：" &lt;&lt; *name_ &lt;&lt;",地址为："&lt;&lt;name_&lt;&lt; endl; cout &lt;&lt; "names地址为：" &lt;&lt; names &lt;&lt; endl;&#125; 输出结果： 对于void* 指针，我还有许多不解的地方，在网上搜索之后发现了一个比较详细解释void* 指针的博文——[void及void指针含义的深刻解析](https://blog.csdn.net/geekcome/article/details/6249151?reload)]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>引用</tag>
        <tag>指针</tag>
        <tag>复合类型</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++变量]]></title>
    <url>%2F2019%2F03%2F08%2F%E5%8F%98%E9%87%8F%2F</url>
    <content type="text"><![CDATA[变量定义 1.初始值不是赋值。初始化的含义是创建变量时赋予其一个初始值。而赋值的含义是把对象当前值擦除，以一个新值来代替。 2.定义可以为分为列表初始化和默认初始化。 变量声明与定义的关系 为了允许把程序拆分成多个逻辑部分来编写，C++语言支持分离式编译机制，该机制允许将程序分隔为若干个文件，每个文件可被独立编译。为了支持分离式编译，C++语言将声明和定义区别开来 声明使得名字为变量所知 定义负责创建与名字关联的实体 123extern int i; //声明i，不是定义 int j;//声明并定义j extern double pi=3.1416;//定义 标识符 C++标识符由字母、数字和下划线组成，其中必须以字母或者下划线开头，标识符的长度没有限制，但是对大小写字母敏感。 以下为变量命名规范： 标识符要能体现实际含义 变量名一般用小写字母，如index 用户自定义类名一般以大写字母开头 如果标识符由多个单词组成，则单词之间要有明显区分 名字的作用域 作用域是程序的一部分，在其中名字有其特定的含义。C++语言中，大多数作用域都以花括号为分隔。 同一个名字在不同的作用域中可能指向不同的实体，名字的有效区域始于名字的声明语句，以声明语句所在的作用域末端为结束。 嵌套的作用域 内层作用域：作用域能彼此包含，被包含的作用域为内层作用域。 外层作用域：包含着别的作用域的作用域。]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>变量</tag>
      </tags>
  </entry>
</search>

<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[交换技术和分组交换的两种方式]]></title>
    <url>%2F2019%2F07%2F01%2F%E4%BA%A4%E6%8D%A2%E6%8A%80%E6%9C%AF%E5%92%8C%E5%88%86%E7%BB%84%E4%BA%A4%E6%8D%A2%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%96%B9%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[一、电路交换 在进行数据传输前，两个结点之间必须建立一条专用（双方独占）的物理通信路径，该路径可能经过许多中间结点。这一路径在整个数据传输期间一直被独占，直到通信结束才被释放。因此，电路交换技术分为三个阶段：连接建立、数据传输、连接释放 从通信资源的分配角度来看，“交换”就是按照某种方式动态地分配传输线路的资源。电路交换的关键点是，在数据传输过程中，用户始终占用端到端的固定传输带宽。 电路交换的优点： 通信时延小。当传输的数据量较大时，这一优点非常明显 有序传输 没有冲突 适用范围广 实用性强 控制简单 电路交换的缺点 建立连接时间长 线路独占 灵活性差 难以规格化 电路建立后，除源结点和目的节点外，电路上的任何结点都采取“直通方式”接收数据和发送数据，即不会存在存储转发所耗费的时间。 二、报文交换 数据交换的单位是报文，报文携带有目标地址、源地址等信息。报文交换在交换结点采用的是存储转发的传输方式 报文交换的优点 无须建立连接 动态分配线路 提高线路可靠性 提高线路利用率 提供多目标服务 报文交换的缺点 由于数据进入交换结点后要经历存储、转发这一过程，因此会引起转发时延 报文交换对报文的大小没有限制，这就要求网络结点需要有较大的缓存空间 三、分组交换 采用存储转发方式，但解决了报文交换中大报文传输的问题。 分组交换限制了每次传送的数据块大小的上限，把大的数据块划分为合理的小的数据块，再加上一些必要的控制信息，构成分组。网络结点根据控制信息把分组送到下一结点，下一结点接收到分组后，暂时保存并排队等待传输，然后根据分组控制信息选择它的下一结点，直到到达目的结点。 分组交换的优点 无建立时延 线路利用率高 简化了存储管理 加速传输 减少了出错概率和重发数据量 分组交换的缺点 存在传输时延 需要传输额外的信息 当分组交换采用数据报服务时，可能会出现失序、丢失或重复分组，分组到达目的结点时，要对分组按编号进行排序等工作，因此很麻烦。若采用虚电路服务，虽无失序问题，但有呼叫建立、数据传输和虚电路释放三个过程。 四、电路交换、分组交换和分组交换 要传送的数据量很大且其传送时间远大于呼叫时间时，采用电路交换较为合适 端到端的通路由多段链路组成时，采用分组交换传送数据较为合适 从提高整个网络的信道利用率上看，报文交换和分组交换优于电路交换，其中分组交换比报文交换的时延小，尤其适合于计算机之间的突发式数据通信。 五、数据报与虚电路 分组交换根据其通信子网向端点系统提供的服务，还可以进一步分为面向连接的虚电路方式和无连接的数据报方式。这两种服务方式都由网络层提供。数据报方式和虚电路方式是分组交换的两种方式。 数据报 作为通信子网用户的端系统发送一个报文时，在端系统中实现的高层协议先把报文拆成若干带有序号的数据单元，并在网络层加上地址等控制信息后形成数据办分组。中间节点存储分组很短一段时间，找到最佳路由后，尽快转发每个分组。不同的分组可以走不同的路径，也可以按不同的顺序到达目的结点。 数据报服务的特点 发送分组前不需要建立连接，发送方可随时发送分组，网络中的结点可随时接收分组 网络尽最大努力交付，传输不保证可靠性，所以可能丢失；为每个分组独立地选择路由，转发的路径可能不同，因而分组不一定按序到达目的结点 发送的分组中要包括发送端和接收端的完整地址，以便可以独立传输 分组在交换结点存储转发时，需要排队等候处理，这会带来一定的时延。通过交换结点的通信量较大或网络发生拥塞时，这种时延会大大增加，交换结点还可根据情况丢弃部分分组 网络具有冗余路径，当某一交换结点或一段链路出现故障时，可相应地更新转发表，寻找另一条路径转发分组，对故障的适应能力强 存储转发的时延一般较小，提高了网络的吞吐量 收发双方不独占某一链路，资源利用率高 虚电路 虚电路方式试图将数据报方式与电路交换方式结合起来，充分发挥两种方法的优点，以达到最佳的数据交换效果。在分组发送之前，要求在发送方和接收方建立一条逻辑上相连的虚电路，并且连接一旦建立，就固定了虚电路所对应的物理路径。与电路交换类似，整个通信过程分为三个阶段：虚电路建立、数据传输与虚电路释放 在虚电路方式中，端系统每次建立虚电路时，选择一个未用过的虚电路号分配给该虚电路以区别于本系统中的ITA虚电路。在传送数据时，每个数据分组不仅要有分组号、校验和等控制信息，还要有它通过的虚电路号，以区别于其他虚电路上的分组。在虚电路网路中的每个结点上都维持一张虚电路表，表中的每项记录了一个打开的虚电路信息，包括在接收链路和发送链路上的虚电路号、前一结点和下一结点的标识。数据传输时双向进行的，上述信息是在建立过程中确定的。 虚电路服务的特点 虚电路通信链路的建立和拆除需要时间开销，对交互式应用和小量的短分组情况显得很浪费，但对长时间、频繁的数据交换效率较高 虚电路的路由选择体现在连接建立阶段，连接建立后，就确定了传输路径 虚电路提供了可靠的通信功能，能保证每个分组正确且有序到达。此外还可以对两个数据端点的流量进行控制，当接收方来不及接收数据时，可以通知发送方暂缓发送 虚电路有一个致命的弱点，即当网络中的某个结点或某条链路出现故障而彻底失效时，所有经过该结点或该链路的虚电路将遭到破坏 分组首部不含目的地址，而包含虚电路标识符，相对数据报方式开销小 虚电路之所以是“虚”的，是因为这条电路不是专用的，每个节点到其他节点之间的链路可能同时有若干虚电路通过，也可能同时与多个结点之间建立虚电路。每天虚电路支持特定的两个端系统之间的数据传输，两个端系统之间也可以有多条虚电路为不同的进程服务，这些虚电路的实际路由可能相同也可能不同。 数据报服务和虚电路服务的比较 数据报服务 虚电路服务 连接的建立 不需要 必须有 目的地址 每个分组都有完整的目的地址 仅在建立连接阶段使用，之后每个分组使用长度较短的虚电路号 路由选择 每个分组独立地进行路由选择和转发 属于同一条虚电路的分组按照同一路由转发 分组顺序 不保证分组的有序到达 保证分组的有序到达 可靠性 不保证可靠通信，可靠性由用户主机来保证 可靠性由网络保证 对网络故障的适应性 出故障的结点丢失分组，其他分组路径选择发生变化时可以正常传输 所有经过故障结点的虚电路均不能正常工作 差错处理和流量控制 由用户主机进行流量控制，不保证数据报的可靠性 可由分组交换网负责，也可由用户主机负责]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>电路交换</tag>
        <tag>报文交换</tag>
        <tag>分组交换</tag>
        <tag>虚电路</tag>
        <tag>数据报</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vector容器]]></title>
    <url>%2F2019%2F06%2F30%2Fvector%E5%AE%B9%E5%99%A8%2F</url>
    <content type="text"><![CDATA[一、序列式容器 所谓序列式容器，其中的元素都是可序的，但未必有序。C++本身体用了一个序列式容器array，STL另外提供了vector,list,deque,stack.priority-queue等序列式容器。 二、vector vector与array的区别 vector的数据安排以及操作方式，与array非常相似，两者的唯一差别在于空间运用的灵活性。 array是静态空间，一旦配置了就不能改变，要更换大一些的空间，就必须执行如下操作： 配置一块新空间 将元素从旧地址一一搬往新地址 把原来的空间释放还给系统 vector是动态空间，随着元素的加入，它的内部机制会自行扩充空间以容纳新元素 vector空间配置 为了降低空间配置时的速度成本，vector实际配置的大小比客户端需求大一些，以备将来可能的扩充。这便是容量（capacity）的概念。换句话说，一个vector的容量永远大于或等于其大小。一旦容量等于大小，便是满载，下次再有新增元素，整个vector就得另觅居所。 所谓动态增加大小，并不是在原空间之后续接新空间，而是一块更大的内存空间，然后将元数据拷贝到新空间，并释放原空间，因此，对vector的任何操作，一旦引起空间的重新配置，指向原vector额度所有迭代器就都失效了。 vector的数据结构 vector所采用的数据结构非常简单：线性连续空间。它以两个迭代器start和finish分别指向配置得来的连续空间中已经使用的范围，并以迭代器end_of_storage指向整块连续空间（含备用空间）的尾端。 123456789template&lt;class T, class Alloc = alloc&gt;class vector &#123; ……protected: iterator start; //表示目前使用空间的头 iterator finish; //表示目前使用空间的尾 iterator end_of_storage; //表示目前可用空间的尾&#125;; push_back操作 12345678910111213void test01()&#123; vector&lt;int&gt;v; cout &lt;&lt; "vector当前使用的空间为：" &lt;&lt; v.size() &lt;&lt; endl; cout &lt;&lt; "vector的容量为：" &lt;&lt; v.capacity() &lt;&lt; endl; for (int i = 0; i &lt; 10; i++) &#123; v.push_back(i); cout &lt;&lt; "vector当前使用的空间为：" &lt;&lt; v.size() &lt;&lt; endl; cout &lt;&lt; "vector的容量为：" &lt;&lt; v.capacity() &lt;&lt; endl; &#125; DisplayVector(v);&#125; 构造一个vector容器 vector中提供的构造函数和拷贝构造函数如下： 12345678910111213vector() :start(0), finish(0), end_of_storage(0) &#123;&#125;vector(size_type n, const T&amp; value)&#123; fill_initialize(n, value);&#125;vector(int n, const T&amp; value)&#123; fill_initialize(n, value);&#125;vector(long n, const T&amp; value)&#123; fill_initialize(n, value);&#125; 下面使用一个vector容器构造另一个vector容器，代码如下： 1234567891011void test02()&#123; vector&lt;int&gt; v1; for (int i = 0; i &lt; 10; i++) &#123; v1.push_back(i); &#125; vector&lt;int&gt; v2(v1.begin(), v1.end()); DisplayVector(v1); DisplayVector(v2);&#125; 输出结果如下图： 使用数组初始化vector 123456void test03()&#123; int array[] = &#123; 1,3,5,7,9,11 &#125;; vector&lt;int&gt;v(array, array + sizeof(array) / sizeof(int)); DisplayVector(v);&#125; 输出结果如下图： 初始化vector容器的一些方式 123456789101112131415161718192021222324void test04()&#123; vector&lt;int&gt;v1(10, 1);//初始化vector容器v为10个1 cout &lt;&lt; "v1:"; DisplayVector(v1); vector&lt;int&gt;v2&#123; 2,4,6,8,10 &#125;;//列表初始化vector容器 cout &lt;&lt; "v2:"; DisplayVector(v2); vector&lt;int&gt;v3; //assign(begin(),end());将[begin,end]区间中的数据拷贝给容器 v3.assign(v1.begin(), v1.end()); cout &lt;&lt; "v3:"; DisplayVector(v3); //assign(n,value);将n个value赋值给容器 v3.assign(10, 100); cout &lt;&lt; "v3:"; DisplayVector(v3); //swap(vector);将vector中的元素与本身的元素交换 v1.swap(v3);//v1与v3的元素进行交换 cout &lt;&lt; "v1:"; DisplayVector(v1); cout &lt;&lt; "v3:"; DisplayVector(v3);&#125; 结果如下图所示： vector的元素操作：insert、push_back、pop_back、erase、clear 对元素操作的说明如下： insert(const_iterator pos, int count,ele);//迭代器指向位置pos 插入count 个元素ele. push_back(ele); //尾部插入元素ele pop_back();//删除最后一个元素 erase(const_iterator start, const_iterator end);//删除迭代器从start 到end 之间的元素 erase(const_iterator pos);//删除迭代器指向的元素 clear();//删除容器中所有元素 size();//返回容器中元素的个数 empty();//判断容器是否为空 resize(int num);//重新指定容器的长度为num，若容器变长，则以默认值填充新位置。如果容器变短，则末尾超出容器长度的元素被删除。 resize(int num, elem);//重新指定容器的长度为num，若容器变长，则以elem 值填充新位置。如果容器变短，则末尾超出容器长&gt;度的元素被删除。 capacity();//容器的容量 reserve(int len);//容器预留len 个元素长度，预留位置不初始化，元素不可访问。 示例如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950void test05()&#123; vector&lt;int&gt;v1&#123; 10,15,16,17,18,19,20 &#125;; if (v1.empty()) &#123; cout &lt;&lt; "v1为空" &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; "v1:"; DisplayVector(v1); cout &lt;&lt; "v1不为空，元素个数为：" &lt;&lt; v1.size() &lt;&lt; endl; &#125; v1.resize(10);//重新指定vector容器的长度 cout &lt;&lt; "v1的元素个数为：" &lt;&lt; v1.size() &lt;&lt; endl; DisplayVector(v1); v1.resize(15, 8888); cout &lt;&lt; "v1的元素个数为：" &lt;&lt; v1.size() &lt;&lt; endl; DisplayVector(v1); v1.resize(4); cout &lt;&lt; "现在v1的元素个数为：" &lt;&lt; v1.size() &lt;&lt; endl; DisplayVector(v1); vector&lt;int&gt;v2; v2.reserve(15);//为v2预留15个元素的长度 for (int i = 0; i &lt; 5; i++) &#123; v2.push_back(i); &#125; DisplayVector(v2); int ret = v1.at(2);//取索引5指向的元素 cout &lt;&lt; "索引为2所指的数据为：" &lt;&lt; ret &lt;&lt; endl; cout &lt;&lt; "v1中的第三个元素为：" &lt;&lt; v1[2] &lt;&lt; endl; cout &lt;&lt; "v1的首元素为：" &lt;&lt; v1.front() &lt;&lt; endl; cout &lt;&lt; "v1的尾元素为：" &lt;&lt; v1.back() &lt;&lt; endl; v1.insert(v1.begin() + 1, 4, 5);//在迭代器v1.begin()+1指向的位置插入4个5 cout &lt;&lt; "v1:"; DisplayVector(v1);//输出 v1.pop_back();//删除v1的尾元素 cout &lt;&lt; "v1:"; DisplayVector(v1); v1.erase(v1.begin());//删除v1的v1.begin指向的元素 cout &lt;&lt; "v1:"; DisplayVector(v1); v1.erase(v1.begin()+1, v1.end());//删除v1.begin()+1,v1.end()之间的元素 cout &lt;&lt; "v1:"; DisplayVector(v1); v1.clear();//清空v1中的元素 cout &lt;&lt; "v1:"; DisplayVector(v1);&#125; 输出结果如下： 使用swap来收缩vector容器的空间 123456789101112131415161718void test06()&#123; vector&lt;int&gt;v; for (int i = 0; i &lt; 10; i++) &#123; v.push_back(i); &#125; cout &lt;&lt; "v的容量为：" &lt;&lt; v.capacity() &lt;&lt; endl; cout &lt;&lt; "v的大小为：" &lt;&lt; v.size() &lt;&lt; endl; v.resize(5); cout &lt;&lt; "调整大小后vector容器的容量和大小如下：" &lt;&lt; endl; cout &lt;&lt; "v的容量为：" &lt;&lt; v.capacity() &lt;&lt; endl; cout &lt;&lt; "v的大小为：" &lt;&lt; v.size() &lt;&lt; endl; cout &lt;&lt; "使用swap收缩vector空间" &lt;&lt; endl; vector&lt;int&gt;(v).swap(v); cout &lt;&lt; "v的容量为：" &lt;&lt; v.capacity() &lt;&lt; endl; cout &lt;&lt; "v的大小为：" &lt;&lt; v.size() &lt;&lt; endl;&#125; 输出结果如下： 源码地址 vector源码示例]]></content>
      <categories>
        <category>STL</category>
      </categories>
      <tags>
        <tag>STL</tag>
        <tag>vector</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[STL概论]]></title>
    <url>%2F2019%2F06%2F30%2FSTL%E6%A6%82%E8%AE%BA%2F</url>
    <content type="text"><![CDATA[长久以来，软件界一直希望建立一种可重复运用的东西，以及一种得以制造出“可重复运用的东西”的方法，让工程师/程序员的心血不致于随时间迁移、人事异动、私心欲念而烟消云散。从子函数、程序、函数、类别、到函数库、类别库、各种组件、从结构化设计、模块化设计、面向对象设计、到模式的归纳整理，无一不是软件工程的慢慢奋斗史。 为的，就是复用性的提升。 ——《STL源码剖析》 为了建立数据结构和算法的一套标准，并且降低他们之间的耦合关系，以提升各自的独立性、弹性、交互操作性、，诞生了STL。 STL（标准模板库），是惠普实验室开发的一系列软件的统称。 STL从广义上分为：容器、算法、迭代器。容器和算法之间通过迭代器进行无缝连接。STL几乎所有的代码都采用了模板类或模板函数，相比于由函数和类组成的库来说提供了更好的代码复用机会。 一、STL六大组件 容器：各种数据结构，如vector,list,deque,set,map，用来存放数据。 算法：各种常用的算法如：sort,search,copy,erase…… 迭代器:扮演了容器和算法之间的胶合剂，是所谓的泛型指针。共有五种类型，以及其他的衍生变化，从实现的角度来看，迭代器是一种将operator*,operator-&gt;,operator++,operator–等指针相关操作予以重载的class template。所有STL容器都附带有自己专属的迭代器，只有容器设计者才知道如何遍历自己的元素。原生指针也是一种迭代器。 仿函数：行为类似函数，可作为算法的某种策略。从实现的角度看，仿函数是一种重载了operator()的class或class template 适配器：一种用来修饰容器或仿函数或得带器接口的东西。 空间配置器：负责空间配置与管理。从实现的角度来看，配置器是一个实现了动态空间配置，空间管理，空间释放的class template。 STL六大组件的交互关系，容器通过空间配置器取得数据存储空间，算法通过迭代器存储容器空间中的内容，仿函数可以协助算法完成不同的策略的变化，适配器可以修饰仿函数 二、STL优点 STL是C++的一部分，因此不用额外安装什么，它被内建在编译器之内 STL的一个重要特性是将数据和操作分离，数据由容器类别加以管理，操作则由可定制的算法定义。迭代器在两者之间充当粘合剂，以使算法可以和容器交互运行。 程序员不用思考STL具体的实现过程，只要能熟练使用STL就可以。这样他们就可以把精力放在程序开发的别的方面 STL具有高复用性、高性能、高移植性、跨平台等优点。 高可重用性：STL中几乎所有的代码都采用了模板类和模板函数的方式实现，这相比于传统的由函数和类组成的库来说提供了更好的代码重用机会。 高性能：如map可以高效地从十万记录里面查找出指定的记录。因为map是采用红黑树的变体实现的 高移植性：如在项目A上用STL编写的模块，可以直接移植到项目B上。 三、STL三大组件介绍 容器 容器，置物之所也。 研究数据的特定排列方式，以利于搜索或排序或其他特殊每亩地，这一门学科就是数据结构。 任何特定的数据结构都是为了实现某种特定的算法。STL容器就是将运用最广泛的一些数据结构实现出来。 常用的数据结构：数组（array），链表（list）、树（tree），栈（stack），队列（queue），集合（set），映射表（map），根据数据在容器这两个排列的特性，这些数据分为序列式容器和关联式容器两种。 序列式容器强调的是值的排序，序列式容器中的每个元素均有固定的位置，除非用删除或插入操作改变这个位置。vector容器，deque容器，list容器 关联式容器是非线性的树结构，更准确的说是二叉树结构，各元素之间没有严格的物理上的顺序关系，也就是说元素在容器中并没有保存元素置入容器时的逻辑顺序。关联式容器另一个显著特点是：在值中选择一个值作为关键字key，这个关键字对值起到了索引的作用，方便查找。set/multiset容器，map/multimap容器 算法 算法，问题之解法也。 以有限的步骤，解决逻辑或数学上的问题，即为算法。 算法分为：质变算法和非质变算法 质变算法：是指在运算过程中会戈恩噶区间内元素的内容，例如拷贝、替换、删除等 非质变算法：是指运算过程中不会更改区间内的元素内容，例如查找、计数、遍历寻找极值等。 迭代器 迭代器（iterator）是一种抽象的设计概念，显示程序语言中并诶呦直接对应于这个概念的实物。设计模式中iterator模式定义如下：提供一种方法，使之能够依序寻访某个容器所含的各个元素，而又无须暴露该容器的内部表示方式。 迭代器的设计思维-STL的关键所在，STL的中心思想在于将容器和算法分开，彼此独立设计，最后再贴胶着剂将他们撮合在一起，从技术角度来看，容器和算法的泛型化并不困难，C++的class template 和function template可分别达到目标，如果设计出这两个之间的良好的胶着剂，才是大难题。 分类 描述 功能 输入迭代器 提供对数据的只读访问 输出迭代器 提供读写操作，并能向前推进迭代器 前向迭代器 提供读写操作，并能向前推进迭代器 读写，支持++，==，~= 双向迭代器 提供读写操作，并能向前和向后操作 读写，只会++，– 随机访问迭代器 提供读写操作，并能以跳跃的方式访问容器的任意数据，是功能最强大的的迭代器 读写，支持++，–，[n],-n,&lt;,&lt;=,&gt;,&gt;=]]></content>
      <categories>
        <category>STL</category>
      </categories>
      <tags>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[软件测试知识点总结]]></title>
    <url>%2F2019%2F06%2F30%2F%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[一、软件测试基本概念 软件测试的定义 使用人工或自动手段来运行或测试某个系统的过程，其目的在于检验它是否满足规定的需求或是否弄清预期结果与实际结果之间的差别。 软件缺陷的定义 软件缺陷，常常被称为bug。所谓软件缺陷，即计算机软件或程序中存在某种破坏正常运行能力的问题、错误，或者隐藏的功能缺陷。缺陷的存在会导致软件产品在某种程度上不能满足用户的需要。 标准定义：从产品内部看，缺陷时软件产品的开发或维护过程中存在的错误、毛病等各种问题；从产品外部看，缺陷是系统所需要实现的某种功能的失效或违背。 软件缺陷的主要类型 (1)软件没有是实现产品说明书中要求的功能模块 (2)软件中出现了产品说明书中指明不应出现的错误 (3)软件实现了产品说明书中没有提到的功能模块 (4)软件没有实现产品说明书中没有明确提到但应该实现的目标 (5)软件难以理解、不易于使用，运行缓慢，或从测试员的角度看，最终用户会认为不好。 软件缺陷的级别 (1)微小的。一些小问题，对功能几乎没有影响，软件产品仍然可以使用 (2)一般的。不太严重的问题，如次要功能模块丧失、提示信息不够准确、用户界面差、操作时间长等 (3)严重的。严重错误，指没有实现功能模块或某个特性，主要功能部分丧失、次要功能全部丧失，或致命的错误声明 (4)致命的。致命的错误，将造成系统崩溃、死机，或造成数据丢失、主要功能完全丧失等 通常情况下，问题越严重，其处理优先级就越高。 软件缺陷的状态 (1)激活状态：问题没有解决，测试人员新报告的缺陷或者验证后的缺陷仍旧存在 (2)已修正状态：已经被开发人员检查、修复过的缺陷，通过单元测试，认为已经解决但还没有被测试人员验证 (3)关闭状态：测试人员经过验证后，确认验证不存在之后的状态 软件缺陷的原因 (1)软件产品说明书 (2)设计方法 (3)编写代码 (4)其他 比例依次减小 软件缺陷修复的代价 依次递增，如下： (1)编制说明书 (2)设计阶段 (3)编写代码 (4)测试 (5)发布 软件测试的分类 (1)按照开发阶段划分 ​ ①单元测试 ​ ②集成测试 ​ ③系统测试 ​ ④验收测试 (2)按测试技术划分 ​ ①白盒测试 ​ ②黑盒测试 ​ ③灰盒测试 (3)按被测软件是否实际运行划分 ​ ①静态测试 ​ ②动态测试 (4)按照测试实施组织划分 ​ ①开发方测试（α测试) ​ ②用户测试（β测试） ​ ③第三方测试 软件测试的原则 （1）完全测试程序是不可能的 （2）软件测试是有风险的 （3）测试无法显示潜伏的软件缺陷 （4）软件缺陷的群集现象 （5）杀虫剂怪事：软件测试越多，其免疫力越强 （6）并非所有的软件缺陷都能被修复 （7）难以描述的软件缺陷 二、黑盒测试用例设计方法 测试用例在软件测试中的作用 （1）推导测试的实施 （2）规划测试数据的准备 （3）编写测试脚本的“设计规格说明书” （4）评估测试结果的度量基准 （5）分析缺陷的标准 设计测试用例的步骤 （1）测试需求分析 （2）业务流程分析 （3）测试用例设计 （4）测试用例评审 （5）测试用例更新完善 等价类划分法 等价类划分法是一种最为常见的黑盒测试方法。 其基本实现是把程序的输入域划分为若干个子集，然后从每个子集中选取少量具有代表性的数据作为测试用例。在该子集合中，各个输入数据对于揭示程序中的错误都是等效的 等价类可以分为两种： （1）有效等价类。指对于程序的规格说明来说，是由合理的、与意义的输入数据构成的集合。主要为了检验程序是否实现了规格说明书中规定的功能和性能 （2）无效等价类。对规格说明书而言，是由无意义的、不合理的输入数据构成的集合。利用无效等价类中的数据，检验程序对错误输入的处理能力。 设计测试用例的步骤 （1）划分等价类 （2）建立等价类表，列出所有划分出的等价类，并为每一个等价类规定一个唯一的编号 （3）从划分出的等价类中按以下原则设计测试用例。设计一个新的测试用例，使其尽可能多地覆盖尚未被覆盖的有效等价类，重复这一步骤，直到所有的有效等价类都被覆盖为止；设计一个新的测试用例，使其仅覆盖一个尚未被覆盖的无效等价类，重复这一步，直到所有的无效等价类都被覆盖为止 边界值分析法 边界值分析法用于考察处于等价划分边界或在边界附近的状态。 通常，软件中边界分为内部边界和外部边界两种。所谓的外部边界是可以在需求规格说明书、设计规格说明书中找到相应的描述的，而内部边界是在程序实现环节存在的、至关重要的界限。 因果图法 等价类划分法和边界值分析方法都着重考虑输入条件，但没有考虑输入条件的各种组合、输入条件之间的相互制约关系。 因果图是一种利用图解法分析输入的各种组合情况，从而设计测试用例的方法，它适合于检查程序输入条件的各种组合情况。 因果图的定义：因果图是一种描述输入和输出之间关系的图，其中出现的基本符号主要有：节点和弧线。 因果图描述的原因和结果之间的关系： （1）恒等 （2）非 （3）或 （4）与 输入条件的约束： （1）E约束（异） （2）I约束（或） （3）O约束（唯一） （4）R约束（要求） 因果图法的基本步骤 （1）分析程序规格说明书中描述的语义内容，找出“原因”和“结果”，将其表示成连接各个原因与结果的“因果图” （2）由于语法或环境限制，有些原因与原因之间或原因与结果之间的组合情况是不可能出现的，可用记号标明约束或限制条件 （3）将因果图转换成判定表 （4）根据判定表中的每一列设计测试用例 决策表法 决策表，也称判定表。在所有的黑盒测试方法中，基于决策表的测试方法被认为是最严格的的，因为决策表具有逻辑严格性。 决策表是分析和表达多逻辑条件下执行不同操作的情况的工具。 决策表的结构 （1）条件桩：列出问题的所有条件 （2）条件项：针对条件桩给出的条件列出所有可能的取值 （3）动作桩：列出问题规定的可能采取的操作 （4）动作项：指出在条件项的各组取值情况下应采取的动作 （5）规则：贯穿条件项和动作项的一列就是一条规则 决策表的化简 初始决策表的条件项的数目很大，若表中有两条以上规则具有相同的动作，并且在条件项之间存在极为相似的关系，便可以将它们合并。合并后的条件项用符号“—”表示，说明执行的动作与该条件的取值无关，称为无关条件。 三、白盒测试用例设计方法 逻辑覆盖测试 白盒测试方法是把测试对象看作一个打开的盒子，测试人员依据程序内部逻辑结构相关信息，设计或选择测试用例，对程序所有逻辑路径进行测试，通过在不同点检查程序的状态，确定实际的状态是否与预期的状态一致。 逻辑覆盖测试是以程序内在逻辑结构为基础的测试，重点关注测试覆盖率。包括以下6种类型：语句覆盖、判定覆盖、条件覆盖、判定/条件覆盖、条件组合覆盖和路径覆盖。 语句覆盖 语句覆盖是指设计若干个测试用例，使程序中的每个可执行语句至少执行一次。在保证每条语句都运行的前提下，测试用例应尽量少。在语句覆盖的基础上可以实现程序覆盖，进而是程序块的覆盖。 语句覆盖是一种较弱的覆盖测试。 判定覆盖 判定覆盖的含义是：设计足够多的测试用例，使程序中的每个判定都至少获得“真值”和“假值”。程序中的判定有：分支判定和循环判定。 为了表示方便，做到理解上的统一，表示某个条件的真假用$T_i$和$F_i$,表示某个判定的真假使用$TD_i$和$FD_i$ 条件覆盖 条件覆盖的含义是:构造一组测试用例，使得每一个判定中每个逻辑条件的可能值至少被满足一次。 判定/条件覆盖 设计足够的测试用例，使得判定中每个条件的所有可能（真/假）至少出现一次，并且每个判定本身的判定结果（真/假）也至少出现一次，即满足判定/条件覆盖的测试用例同时满足条件覆盖和判定覆盖。 组合条件覆盖 组合条件覆盖的含义是：设计足够的测试用例，使得每个判定中条件的各种可能组合都至少出现一次。 显然，满足组合条件覆盖的测试用例是一定满足判定覆盖、条件覆盖和判定/条件覆盖的。 具体的组合策略如下： （1）如果某个条件组合只有一种可能性，则优先确立关系 （2）不可能存在的组合不住要设计测试用例 （3）除了不可能的情况，所有的条件组合都必须至少出现一次 路径覆盖 所谓路径覆盖就是设计足够多的测试用例使每个路径都有可能被执行。 基本路径测试 包括程序控制流图，环形复杂度、独立路径 控制流图 在设计程序时，为了更加突出控制流的结构，可对程序流程图进行简化，简化后的流程图称为控制流图。 控制流图的构成： 控制流线 结点 必须用结点表示的情况： （1）程序流程图中矩形框表示的处理 （2）菱形框表示的两个甚至多个出口判断 （3）多条流线相交的汇合点 环形复杂度 环形复杂度（圈复杂度）是一种为程序逻辑复杂度提供定量尺度的软件度量。也可将该度量用于基本路径测试方法，它可以提供程序基本集的独立路径数量和确保所有语句至少被执行一次的测试数量上界。 计算环形复杂度的方法： （1）流图中区域的数量对应于环形复杂度 （2）给定流图G的环形复杂度为V（G），定义为V(G)=E-N+2,其中，E是流图中边的数量，N是流图中节点的数量 （3）给定流图G的环形复杂度V(G)，定义为V(G)=P+1,P是流图G中判定结点的数量 独立路径 独立路径是指程序中至少引入了一个新的处理语句集合或一个新条件的程序通路，它必须至少包含一条路径在本次定义路径之前不曾用过的边。 程序的环形复杂度是程序基本路径集合中的独立路径条数，这是确定路径中每个可执行语句至少被执行一次所必需的测试用例数目的上界。 代码检查 在实际使用中，静态代码检查比动态测试更有效率，更能快速找到缺陷。 静态测试包括代码检查和静态分析两种途径，它可以由人工进行，充分发挥人的逻辑优势，也可以借助软件工具自动进行。代码检查包括桌面检查、代码审查、代码走查、技术评审等。 主要检查代码的设计是否一致、代码是否遵循标准性和可读性、代码的逻辑表达的正确性，以及代码结构的合理性等。 代码评审也称代码复查，是指通过阅读代码来检查源代码与编码标准的符合性以及代码质量的活动。 代码评审的目的： （1）确保要发布质量可靠的代码，能非常有效地发现所有类型的错误 （2）作为教学工具帮助开发人员学会何时并且如何应用技术来提高代码的质量、一致性和维护性 代码评审是发现缺陷的有效方法。代码评审包括代码审查、代码走查、桌面检查等。 代码审查 代码审查作为质量保证的一部分，是静态测试的主要手段之一。 代码审查的内容： （1）编码规范问题 （2）代码结构问题 （3）工具、框架使用不当 （4）实现问题 （5）测试问题 代码走查 代码走查是以小组为单位进行代码阅读的，同样也是一系列规程和错误检查技术的集合。且代码走查也采用了持续1小时~2小时的不间断会议的形式。 代码走查的任务：就是参与者“使用计算机”。被指定为测试为人员的那个人会带着一些书面的测试用例来参加会议。且在会议期间，每个测试用例都在人们的头脑中进行推演。即把测试数据沿程序的逻辑结构走一遍，并把程序的状态记录以纸上或白板上以供监视。 桌面检查 桌面检查可被视为由担任进行的代码检查或代码走查：由一个人阅读程序，对照错误列表检查程序，对程序推演测试数据。 四、单元测试 单元测试的定义 单元测试又称模块测试，是最小单位的测试，其依据是详细设计规格说明书，对模块内所有重要的控制路径设计测试用例，以便发现模块内部的错误。 单元测试多采用白盒测试技术，系统内多个模块可以并行地进行单元测试 单元测试的对象 一般认为，在结构化程序时代，单元测试所说的单元是指函数，在面向对象编程中，单元测试的单元一般是指类。 但从实践来看，以类作为测试单位，复杂度高、可操作性较差，所以仍然主张以类中的方法作为单元测试的测试单位但可以用一个测试类来组织某个类的所有测试函数 单元测试不应过分强调面向对象，因为局部代码依然是结构化的。单元测试的工作量较大，简单、实用、高效才是硬道理， 单元测试的时间 单元测试当然是越早越好，通常在编码阶段进行。在源程序代码编制完成、经过评审和验证、确定没有语法错误之后，就可以了开始进行单元测试的测试用例设计 单元测试的内容 （1）模块接口测试 （2）模块局部数据结构测试 （3）模块边界条件测试 （4）模块中所有数日执行通路测试 （5）模块的各条错误处理通路测试 模块接口测试是单元测试的基础。只有在数据能正确流入、流出模块的前提下，其他测试才有意义。 单元测试的过程 （1）计划单元测试：确定测试需求，制订测试策略，确定测试所用的资源，创建测试任务的时间表 （2）设计单元测试：根据单元测试计划设计单元测试模型，制订测试方案，确认测试过程，设计具体的测试用例，创建可重用的测试脚本 （3）执行单元测试：根据单元测试的方案、用例对软件单元进行测试，验证测试结果并记录测试过程中出现的缺陷 （4）评估单元测试：对单元测试的结果进行评估，主要从需求覆盖和代码覆盖的角度进行测试完备性的评估 单元测试的模型 在进行单元测试时，如果模块不是独立的程序，需要辅助测试模块，有两种辅助模块： 驱动模块：所测模块的主程序。它接收测试数据，把这些数据传递给所测试模块，最后再输出测试结果。当被测试模块能完成一定功能时，也可以不要驱动模块。 桩模块：用来代替所测模块调用的子模块。被测试模块、驱动模块共同构成了一个测试模型 执行单元测试 （1）设置测试环境 （2）将测试环境初始化，以确保所有构件都处于正确的初始状态 （3）执行测试过程。需要注意的是，测试过程的执行将随着具体情况而变化：测试方式是自动还是人工，以及必需的测试构件是作为驱动程序还是桩模块。自动测试的测试脚本在执行实施测试步骤的过程中创建。而人工测试则是在“构建测试过程”活动中制定的结构化测试过程。 评估单元测试 测试完备性评估 代码覆盖率评估 从覆盖的角度看，。测试应该做到以下覆盖：功能覆盖、输入域覆盖、输出域覆盖、函数交互覆盖和代码执行覆盖 五、集成测试 集成测试的定义 集成测试又称组装测试，是在单元测试的基础上，将所有模块按照设计要求组装成子系统或系统，而进行的测试活动 集成测试的目的是确保各单元组合在一起后能够按照既定意图协作运行，并确保增量的行为正确。 它所测试内容包括单元间的接口以及集成后的功能，通常使用黑盒测试方法测试集成的功能，并且对以前的集成进行回归测试。 集成测试阶段主要检查以下几个方面： （1）在把各个模块连接起来的时候，穿越模块接口的数据是否会丢失 （2）一个模块的功能是否会对另一个模块的功能产生不利的影响 （3）各个子功能组合起来，能否达到预期要求的父功能 （4）全局数据结构是否有问题 （5）单个模块的误差累积起来，是否会被放大，从而达到不能接受的程度 （6）在单元测试的同时可进行集成测试，发现并排除在模块连接中可能出现的问题，最终构成要求的软件系统 集成测试的内容 一个产品的开发过程包括了分层的设计和逐步细化的过程，从最初的产品到最小的单元，由于集成的力度不同，一般可以把集成测试划分为三个级别： （1）模块内集成测试 （2）子系统内集成测试（模块）：先测试子系统内的功能模块（不能单独运行的程序），然后将各个功能模块组合起来确认子系统的功能是否达到预期要求 （3）子系统间集成测试（可执行程序）：测试的单元是子系统之间的接口，这里的子系统是可单独运行的程序或进程。 模块和子系统的区别： 一个完整的软件系统通常包括若干个具有不同功能的子系统。而每个子系统又由多个功能模块组成。 集成测试的原则 （1）要测试所有的公共接口，尤其是那些与系统相关联的外部接口，测试的重点是要检查数据的交换、传递和控制管理过程，还包括处理的次数 （2）必须对关键模块进行充分测试。在集成的过程中应该重点关注一个系统的关键模块。在确定测试需求时，测试人员就要确定系统的关键模块，这些关键模块包含在最希望测试的那些模块中。一般我们将系统中的模块划分成3个等级：高危模块、一般模块、低危模块。一个关键模块应该具有一个或多个下列特性： 和多个软件需求有关，或与关键功能有关 处于程序控制结构的顶层 本身是复杂的或者容易出错的 含有确定性的性能需求 被频繁使用的模块 （3）继承测试应当按一定的层次进行。系统的模块之间是有层次关系的，就像函数之间的相互调用关系。在对系统进行集成时，要按照一定的层次顺序进行集成，避免集成过程中发生错误无法对错误进行定位。 （4）集成测试的策略选择应当综合考虑质量、成本和进度之间的关系。风险分析贯穿整个集成测试过程中，总的原则是花费最小的成本，取得最大的测试效果 （5）集成测试应当尽早开始，并以总体设计为基础 （6）在模块与接口的划分上，测试人员应当和开发人员进行充分沟通 （7）测试执行结果应当被如实记录 集成测试的策略 （1）非增量式集成策略 非增量集成，又称大爆炸式集成，采用一步到位的方法来进行集成，又称一次组装或整体拼装。使用该方法进行集成时，首先分别测试每个模块，即对每个模块都进行独立的单元测试。测试通过后，再把所有模块按设计要求组合在一起构成整体，再对这个整体进行测试。 （2）增量式集成策略 增量式集成方法又被称为渐增式组装，它的集成时逐步实现的。首先对一个个模块进行模块测试，然后按照某种策略，将这些模块逐步组装成较大的系统，在组装的过程中边连接边测试，以发现连接过程中产生的问题。通过增值逐步组装成为满足要求的软件系统。 自顶向下的集成测试 自顶向下增量式集成就是按照模块结构图自上而下进行集成 自底向上的集成测试 自底向上的增量式集成就是按照模块结构图自底向上进行组装，首先从模块结构的底层开始，依次往高层次集成。在集成的过程中，不需要再编写桩模块，只需要为被组装模块编写驱动模块。 混合增量式集成策略 也称“三明治”集成，对软件结构中较上层，使用的是“自顶向下”集成；对软件结构中较下层，使用的是“自底向上”继承，将两种策略的优点结合在一起。 六、功能测试 系统测试 系统测试是通过与系统的需求规格做比较，发现软件与系统需求规格不相符或与之矛盾的地方。它将通过确认测试的软件，作为整个基于计算机系统的一个元素，与计算机硬件、外设、某些支持软件、数据和人员等其他系统元素结合起来，在实际运行（使用）环境下，对软件进行系统测试。 系统测试的依据为需求规格说明书、概要设计说明书和各种规范。通信产品与一般的软件产品不同，其系统测试往往需求依据大量的既定规范；对于海外产品，系统测试依据还包括各个国家自定的规范。 系统测试包括功能测试、性能测试、压力测试、协议一致性测试、容量测试、安全性测试、恢复性测试、备份测试、UI测试、安装和卸载测试、本地化测试、可用性测试等。 功能测试 功能测试又称正确性测试，就是对产品的各项功能进行验证，根据功能测试用例，逐项测试，检查产品是否达到用户要求的功能或者说检查软件的功能是否符合规格说明。由于正确性是软件最重要的质量因素，所以功能测试也非常重要。做功能测试需要首先明确业务和需求。理解了需求和业务，才知道客户想要系统实现什么。然后按照需求来进行测试，不满足要求的都可以被认为是缺陷。 功能测试的策略 测试需求分析 指定测试计划 测试设计和测试用例设计 测试环境搭建 测试实施 缺陷报告 回归测试 功能测试的内容 功能测试包括对用户界面的测试、对各种操作的测试，对不同的数据输入、逻辑思路、数据输出、存储等的测试。不同的应用系统，功能测试的内容差异很大，但一般都可归为界面、数据、操作、逻辑、接口等几个方面，主要包括： （1）程序安装和启动正常，有相应的提示框、适当的错误提示等 （2）每项功能符合实际要求 （3）系统的界面清晰、美观；菜单、按钮操作正常、灵活，能处理一些异常操作 （4）能接受正确的数据输入，对异常数据的输入可以进行提示、容错处理等 （5）数据的输出结果准确、格式清晰，可以保存和读取 （6）功能逻辑清楚，符合使用者习惯 （7）系统的各种状态按照业务流程而变化，并保持稳定 （8）支持各种应用的环境，能配合多种硬件周边设备，与外部应用系统的接口有效 （9）软件升级后，能够继续支持旧版本的数据 七、性能测试 性能测试 性能测试的目的是验证软件系统是否能够达到用户要求的性能指标，同时发现软件系统中出来的性能瓶颈，最后起到优化系统的目的。 性能测试的内容 具体包括以下几个方面： （1）评估系统的能力：测试中得到的负荷和响应时间数据可以用于验证软件系统能力是否符合设计要求 （2）识别系统中的瓶颈：当系统符合被增加到极限水平并继续增加时，可以通过性能指标的变化情况监测系统的瓶颈，从而帮助系统设计者修复系统的瓶颈 （3）系统调优：重复运行测试，验证调整系统的活动得到了预期的结果，从而改进系统性能 （4）验证稳定性与可靠性：在一定的负载压力下执行测试一定时间，是评估系统稳定性和可靠性是否满足要求的有效方法 性能测试的分类 性能测试类型包括负载测试、压力测试、强度测试、容量测试。通常，性能测试通过自动化的测试工具模拟多种正常、峰值以及异常负载条件来对系统的各项性能指标进行测试，负载测试和压力测试都属于性能测试，两者可以结合进行 （1）负载测试，是确定在各种工作负载下系统的性能，目标是测试当负载逐渐增加时，系统各项性能指标的变化情况，例如，吞吐量、响应时间、CPU负载、内存使用等，来确定系统的性能。负载测试是一个分析软件应用程序和支撑架构、模拟真实环境的使用，从而来确定能够接受的性能的过程。 （2）压力测试是通过确定一个系统的瓶颈或者不能接受的性能点，来获得系统能提供的最大服务级别的测试 （3）疲劳测试是采用系统稳定运行情况下，能够支持的最大并发用户数，持续执行一段时间业务，通过综合分析交易执行指标和资源监控指标来确定系统处理最大工作量强度性能的过程。疲劳强度测试可以采用自动化工具进行测试，也可以手工编写程序测试，其中后者占的比例较大 （4）容量测试用于确定系统可处理同时在线的最大用户数 （5）大数据量测试可以分为两种类型：针对某些系统存储、传输、统计、查询等业务进行大数据量的独立数据量测试；与压力性能测试、负载性能测试、疲劳性能测试相结合的综合数据量测试方案。大数据量测试的关键是测试数据的准备，可以依靠工具准备测试数据。 （6）速度测试目前主要针对关键的，有速度要求的业务进行手工测速度，可以在多次测试的基础上求平均值，可以和工具测试得到的响应时间等指标做对比分析。 性能计数器 影响一个系统性能的因素主要有：软件因素，包括系统软件、第三方软件等；硬件因素，如内存、磁盘、CPU、网卡等；网络因素，如网络吞吐量、带宽、网络传输速率等。 性能计数器是描述服务器或操作系统性能的一些数据指标。 （1）内存，内存性能计数器主要检查应用程序是否存在内存泄漏 （2）处理器，监视“处理器”和“系统”对象计数器可以提供关于处理器使用的有价值的信息，帮助测试人员决定是否存在瓶颈 （3）物理磁盘，磁盘性能 性能测试流程 （1）性能测试的计划 （2）性能测试的设计 （3）性能测试的执行 （4）测试结果的分析 八、本地化测试 本地化测试的定义 本地化测试是对软件进行本地化过程中记性的测试 所谓本地化就是将软件版本语言进行就更该。 本地化测试的对象是软件的本地化版本 本地化测试目的是测试待定目标区域设置的软件本地化质量 本地化测试的环境是在本地化的操作系统上安装本地化的软件。 从测试方法上可以分为：基本功能测试、安装或卸载测试、当地区域的软硬件兼容测试。 测试的内容主要包括软件本地化后的界面布局和软件翻译的语言质量，包含软件、文档和在线帮助等部分 本地化测试的目的首先是保证本地化的软件与源语言软件具有相同的功能和性能。其次还要保证本地化的软件在语言、文化、传统观念等方面符合当地用户的习惯。 本地化测试过程中的测试工作集中在： （1）易受本地化影响的方面，如用户界面 （2）区域性或区域设置特定的、语言特定的和地区特定的方面 本地化测试与其他测试的区别 软件本地化测试的测试对象是本地化的软件，需要在本地化的操作系统上进行。虽然本地化的软件是基于源程序软件创建的，但与其他测试的测试内容和重点有很大不同。 不同点 描述 测试顺序 首先要对源程序软件进行测试，然后再创建本地化软件，测试本地化软件 测试内容和重点 源程序软件主要测试功能和性能，结合软件界面的测试；本地化软件的测试，更注重因本地化引起的错误；例如，翻译是否正确，本地化的界面是否美观、本地化后的功能是否与源语言软件保持一致 测试环境 源程序软件测试通常在源语言的操作系统上进行；本地化软件在本地化的操作系统上进行 本地化测试的类型 （1）导航测试，是为了降低软件本地化的风险而进行的一种本地化测试 （2）可接受性测试，也被称为冒烟测试，是指对编译的软件本地化版本的主要特征进行基本测试，从而确定版本是否满足详细测试的条件。 （3）语言质量测试，是软件本地化测试的重要组成部分，贯穿于本地化项目的各个阶段。语言质量测试的主要内容是软件界面和在线帮助等文档的翻译质量，包括正确性，完整性，专业性和一致性。 （4）用户界面测试，也被称为外观测试，主要是对软件的界面文字和控件布局进行测试 （5）功能测试，原始语言开发的软件的功能测试主要测试软件的各项功能是否被实现以及是否正确，而本地化软件的功能测试主要是测试软件经过本地化后，软件的功能是否与源软件一致，是否存在因软件本地化而产生的功能错误 本地化软件缺陷的分类 核心软件缺陷 （1）源语言功能缺陷 （2）源语言国际化缺陷 本地化缺陷 （1）语言质量缺陷 （2）用户界面缺陷 （3）本地化功能缺陷 本地化测试的流程 （1）测试规划 （2）测试设计 （3）测试实施 （4）配置管理 （5）测试管理 本地化测试工程师 基础技能 （1）安装和配置常用操作系统的知识 （2）计算机网络基础知识 （3）通用软件的使用知识 （4）良好的语言技能 专业基础知识 （1）软件本地化或国际化的基本知识 （2）软件本地化工程的基础知识 职业素质 （1）解决问题的专业态度和创新能力 （2）主动迅速学习新知识的能力 （3）执著敬业和团队合作能力 （4）良好的书面和口头交流技能 （5）承受压力的能力 九、软件测试管理 缺陷生命周期 （1）新建：当缺陷被第一次递交的时候，它的状态即为“新建”。这也就是说缺陷未被确认其是否真正是一个缺陷 （2）打开：在测试者提交一个缺陷后，测试组长确认其确实为一个缺陷的时候，会把状态置为“打开” （3）分配：一旦缺陷被测试经理置为“打开”，再把缺陷交给相应的开发人员或开发组。这时缺陷状态变更为“分配” （4）测试：当开发人员修复缺陷后，缺陷提交给测试组进行新一轮的测试，在开发人员公布以修复缺陷的程序之前，缺陷状态被置为“测试”。这时表明缺陷已经被修复并已经提交给了测试组 （5）已确认：当缺陷被修复后就会被置为“测试”，测试员会执行测试。如果缺陷不再出现，这就证明缺陷被修复了的同时其状态被置为“已确认” （6）延期：延期状态被置为“延期”意味着，缺陷将会在下一个版本中被修复 （7）重新打开：如果缺陷被开发人员修复后，问题仍然存在，测试人员会把缺陷状态置为“重新打开”。缺陷即将再次穿越其生命周期 （8）重复：如果同一个缺陷被重复提交或者两个缺陷表明的意思相同，那么这个缺陷状态将会被置为“重复”提交 （9）拒绝：如果开发人员不认为其实一个缺陷，会拒绝此缺陷，缺陷状态被置为“拒绝” （10）关闭：当缺陷被修复后，测试人员会对其进行测试。如果测试人员认为缺陷不存在了，会把缺陷状态置为“关闭”，。这个状态意味着缺陷已被修复，通过了测试并且核实确实如此 缺陷报告的编写 （1）清晰地描述缺陷 （2）使用简洁的语言 （3）重现的步骤和数据 （4）提供参考信息 （5）抓屏截图 团队管理 （1）组织结构 基于技能的组织模式 基于测试流程的组织模式 基于项目的组织模式 （2）素质要求 踏实细心和积极主动 怀疑一切 协作和团队感 自我提高和总结的能力 （3）激励方法 表扬和奖励 信任的力量 提高士气 薪水 职务 工作时间 培训机会 风险管理 （1）需求风险 （2）人员风险 （3）环境风险 （4）回归风险 （5）测试资源 （6）需求变更 （7）用例质量 （8）标准差异 （9）测试工具 过程管理 （1）测试需求分析 测试需求的依据与收集 测试需求的分析 测试需求的优先级 （2）测试计划 （3）测试设计 （4）测试开发 （5）测试执行]]></content>
      <categories>
        <category>软件测试</category>
      </categories>
      <tags>
        <tag>软件测试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机操作系统（第四版）习题四解答]]></title>
    <url>%2F2019%2F06%2F22%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC%E5%9B%9B%E7%89%88%EF%BC%89%E4%B9%A0%E9%A2%98%E5%9B%9B%E8%A7%A3%E7%AD%94%2F</url>
    <content type="text"><![CDATA[为什么要配置层次式存储器？ 设置多个存储器可以使存储器两端的硬件能并行工作； 采用多级存储系统，特别是Cache技术，是减轻存储器带宽对系统性能影响的最佳结构方案； 在微处理机内部设置各种缓冲存储器，减轻对存储器存取的压力 增加CPU中寄存器数量，大大缓解翠存储器压力 可采用哪几种方式将程序装入内存？它们分别适用于何种场合？ 绝对装入方式 只适用于单道程序环境 可重定位装入方式 适用于多道程序环境 动态运行时装入方式 用于多道程序环境 不允许程序运行时在内存中移动位置 何谓静态链接？静态链接时需要解决两个什么问题？ 静态链接是指在程序运行之前，先将各目标模块及它们所需的库函数链接成一个完整的装配模块，以后不再拆开。 需要解决为问题是： 对相对地址进行修改 变换外部调用符号 何谓装入时动态链接？装入时动态链接方式有何优点？ 装入时动态链接是指将用户源程序编译后得到的一组目标模块，在装入内存时，采用边装入边链接的链接方式。 优点： 便于修改和更新 便于实现对目标模块的共享 何谓运行时动态链接？运行时动态链接又何优点？ 运行时动态链接是将对某些模块的链接推迟到程序执行时才运行。 优点： 加快程序的装入过程 节省大量的内存空间 在动态分区分配方式中，应如何将各空闲分区链接成空闲分区链？在每个分区的起始部分设置一些用于控制分区分配的信息，以及用于链接各分区所用的前向指针，在分区尾部则设置一后向指针。通过前、后向链接指针，可将所有的空闲分区链接成一个双向链。 为什么要引入动态重定位？如何实现？ 在程序执行的过程中，每当访问指令或数据时，将要访问的程序或数据的逻辑地址转换成物理地址，所以引入了动态重定位。 实现方法 在系统中增设一个重定位寄存器，用它来存放程序（数据）在内存中的起始地址。程序在执行时，真正访问的内存地址是相对地址与重定位寄存器中的地址相加而形成的。 什么是基于顺序搜索的动态分区分配算法？它可分为哪几种？ 为了实现动态分区分配，通常是将系统中的空闲分区链接成一个链。所谓顺序搜索，是指依次搜索空闲分区链上的空闲分区，去寻找一个其大小能满足要求的分区。 基于顺序搜索的动态分区分配算法可分为： 首次适应算法 循环首次适应算法 最佳适应算法 最坏适应书房 在采用首次适应算法回收内存时，可能出现哪几种情况？应怎样处理？可能会出现四种情况： 回收区与插入点前的一个分区$F_1$相邻接。将回收区与插入点的前一分区合并，不必再为回收分区分配新表项，而只需修改其前一分区$F_1$的大小 回收分区与插入点后的一空闲分区$F_2$相邻接。将两个分区合并，形成新的分区，但用回收区的首址作为新空闲区的首址，大小为两者之和 回收区同时与插入点的前、后两个分区邻接。将三个分区合并，使用$F_1$的表项和$F_1$的首址，取消$F_2$的表项，大小为三者之和。 什么是基于索引搜索的动态分区分配算法？它可分为哪几种？ 基于顺序搜索的动态分区分配算法，比较适用于不太大的系统。当系统很大时，系统中的内存分区可能会很多，相应的空闲分区链就很长，这是采用顺序搜索方法可能会很慢。为了提高搜索空闲分区的速度，在大、中型系统中往往会采用基于索引搜索的动态分区分配算法。 基于索引搜索的动态分区分配算法可分为： 快速适应算法 伙伴系统 哈希算法 令$buddy_k$(x)为大小为$2^k$、地址为x的块的伙伴系统地址，试写出$buddy_k$(x)的通用表达式 分区存储管理中常用哪些分配策略？比较它们的优缺点？ 首次适应算法 保留了高址部分的大空闲区，有利于后来的大型作业分配 地址部分不断被划分，留下很多难以利用的小空闲区，每次查找都从地址开始增加了系统开销 循环首次适应算法 内存空闲分区分布均匀，减少了查找系统开销 缺乏大空闲分区，导致不能装入大型作业 最佳适应算法 每次分配给文件的都是最合适该文件大小的分区，内存中留下了很多难以利用的小空闲区 最坏适应算法 剩下空闲分区不至于太小，产生碎片的可能性最小，对中、小型作业有利 存储器中缺乏大空闲区，对大型文件分区分配不利 查找效率很高 为什么要引入对换？对换可分为哪几种类型？ 在多道程序环境下，一方面，在内存中的某些进程由于某花时间尚未发生而被阻塞运行，但它却占用了大量的内存空间，甚至有时有可能出现在内存中所有进程都被阻塞，而没有可以运行的进程，另一方面，却有着很多作业，因两次了空间不足，一直驻留在外存上，而不能进入内存运行。为了解决这一问题，系统引入了对换。 对换的类型 整体对换 页面（分段）对换 对文件区管理的目标和对对换空间管理的目标有何不同？ 对文件区管理的主要目标： 提高文件存储空间的利用率，然后才是提高对文件的访问速度。因此，对文件区空间的管理采取离散分配方式 对对换空间管理的目标： 提高进程换入和换出的速度，然后才是提高文件存储空间的利用率。为此，对对换空间的管理采取连续分配方式，较少考虑外存中的碎片问题 为实现对换，系统应具备哪几方面的功能？ 对换空间管理 进程换入 进程换出 在以进程为单位进行对换时，每次是否都将整个进程换出？为什么？在以进程为单位进行对换时，并非每次都将整个进程换出，这是因为： 从结构上讲，进程是由程序段、数据段和进程控制块组成的，其中进程控制块中总有部分或全部常驻内存，不被换出 程序段和数据段可能正在被若干进程共享，此时它们也不能换出 基于离散分配时所用的基本单位不同，可将离散分配分为哪几种？ 分页存储管理方式 分段存储管理方式 段页式存储管理方式 什么是页面？什么是物理块？页面的大小应如何确定？ 页面。分页存储管理将进程的逻辑地址空间分为若干个页，并为各页加以编号。 物理块：将内存中的物理地址空间分层若干个块 在分页系统中，若选择过小的页面大小，虽然一方面可以减轻碎片，起到减少内存碎片总空间的作用，有利于内存利用率的提高，但另一方面却会造成每个进程占用较多的页面，从而导致进程的页表过长，占用大量内存。此外，还会降低换进换出的效率。然而，页面选择过大，虽然可以减少页表的长度，提高页面换进换出的速度，但却又会使页内碎片增大。因此，页面的大小应选择适中，且页面大小应是2的幂，通常为1KB-8KB。 什么是页表？页表的作用是什么？ 在分页系统中，允许将进程的各个页面离散地存储在内存的任一地址块中，为了保证进程仍然能够正确地运行，即能在内存中找到每个页面所对应的物理块，系统又为每个进程建立了一张页面映像表，简称页表。 页表的作用是实现从页号到物理块号的地址映射 为实现分页存储管理，需要哪些硬件支持？ 页表寄存器 地址变换机构 联想寄存器 在分页系统中是如何实现地址变换的？&emsp;&emsp;当进程要访问某个逻辑地址中的数据时，分页地址变换机构会自动地将有效地址分为页号和页内地址两部分，再以页号为索引去检索页表。查找操作由硬件执行。在执行检索之前，先将页号与页表长度进行比较，如果页号大于或等于页表长度，则表示本次所访问的地址已超越进程的地址空间。于是，这一错误将被系统发现，并产生一地址越界中断。 &emsp;&emsp;若未出现越界错误，则将页表始址与页号和页表项长度的乘积相加，便得到该表项在页表中的位置，于是可从中得到该页的物理块号，将之装入物理地址寄存器中。与此同时，再将有效地址寄存器中的页内地址送入物理地址寄存器的块内地址字段中。这样便完成了从逻辑地址到物理地址的变换。 具有快表时是如何实现地址变换的？&emsp;&emsp;在CPU给出有效地址后，由地址变换机构自动地将页号P送入高速缓冲寄存器，并将此页号与高速缓存中的所有页号进行比较，若其中有与此相匹配的页号，便表示所要访问的页表项在快表中。于是，可直接从快表中读出该页所对应的物理块号，并送到物理地址寄存器中。 &emsp;&emsp;若在快表中未找到对应的页表项，则还须再访问内存中的页表，找到后，把从页表项中读出的物理块号送往地址寄存器；同时，再将此页表项存入快表的一个寄存器单元中。但如果联想寄存器已满，则OS必须找到一个老的且已被认为是不再需要的页表项，将它换出。 较详细地说明引入分段存储管理是为了满足用户哪几方面的需要。 方便编程。用户通常把自己的作业按照逻辑关系划分为若干段，每段都从0 编址，并有自己名字和长度。因此，希望要访问的逻辑地址是由段名和段内偏移量决定。 信息共享。在实现对程序和数据的共享时，是以信息逻辑单位为基础。分页系统中的页是存放信息的物理单位，无完整意义，不便于共享；段是信息的逻辑单位。为了实现段的共享，希望存储管理能与用户程序分段的组织方式相适应。 信息保护。对信息的逻辑单位进行保护，分段能更有效方便地实现信息保护功能。 动态增长。在实际应用中，有些段特别是数据段，在使用过程中会不断增长，事先又无法确切知道增长多少。分段存储管理方式能较好解决这个问题。 动态链接。运行时先将主程序对应的目标程序装入内存并启动运行，运行过程中又需要调用某段时，才将该段调入内存链接。所以动态链接也要求以段作为管理单位。 在具有快表的段页式存储管理方式中，如何实现地址变换？&emsp;在CPU给出有效地址后，由地址变换机构自动地将页号P送入高速缓冲寄存器，并将此页号与高速缓存中的所有页号进行比较，若其中有与此相匹配的页号，便表示所要访问的页表项在快表中。于是，可直接从快表中读出该页所对应的物理块号，并送到物理地址寄存器中。 &emsp;&emsp;若在快表中未找到对应的页表项，则还须再访问内存中的页表，找到后，把从页表项中读出的物理块号送往地址寄存器；同时，再将此页表项存入快表的一个寄存器单元中。但如果联想寄存器已满，则OS必须找到一个老的且已被认为是不再需要的页表项，将它换出。 为什么说分段系统比分页系统更易于实现信息的共享和保护？ 分页系统的每个页面是分散存储的，为了实现信息共享和保护，页面之间需要一一对应，为此需要建立大量的页表项； 而分段系统的每个段都从0 编址，并采用一段连续的地址空间，在实现共享和保护时，只需为要共享和保护的程序设置一个段表项，将其中的基址与内存地址一一对应就能够实现。 分页和分段存储管理有何区别？ 页是信息的物理单位。采用分页存储管理方式是为了实现离散分配方式，以消减内存的外零头，提高内存的利用率。段则是信息的逻辑单位，它通常包含的是一组意义相对完整的信息。分段的目的主要在于能更好地满足用户的需要。 页的大小固定且由系统决定。在采用分页存储管理方式的系统中，在硬件结构上就把用户程序的逻辑地址划分为页号和页内地址两部分。而段的长度却是不固定的，决定于用户所编写的程序，通常由编译程序在对源程序进行编译时，根据信息的性质来划分 分页的用户程序地址空间是一维的。分页完全是系统的行为，故在分页系统中，用户程序的地址是属于单一的线性地址空间。而段式用户的行为，故在分段系统中，用户程序的地址空间是二维的。 试全面比较连续分配和离散分配方式 连续分配是指为一个用户程序分配一个连续的地址空间，包括单一和分区两种分配方式。单一方式将内存分为系统区和用户区，最简单且只用于单用户单任务操作系统：分区方式分为固定分区和动态分区。 离散分配方式分为分页、分段和段页式存储管理。分页式存储管理旨在提高内存利用率，分段时存储管理旨在满足用户的需要，段页式存储管理则是将两者结合起来，具有分段系统便于实现、可分享、易于保护和动态链接等优点，又能像分页系统一样，很好地解决外部碎片及为各段可离散分配内存等问题，是比较有效的存储管理方式。]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>习题解答</tag>
        <tag>存储器管理</tag>
        <tag>对换</tag>
        <tag>分页存储管理方式</tag>
        <tag>分段存储管理方式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机操作系统（第四版）习题二解答]]></title>
    <url>%2F2019%2F06%2F20%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC%E5%9B%9B%E7%89%88%EF%BC%89%E4%B9%A0%E9%A2%98%E4%BA%8C%E8%A7%A3%E7%AD%94%2F</url>
    <content type="text"><![CDATA[为什么程序并发执行会产生间断性特征？程序在并发执行时，由于它们共享系统管理资源，以及为万分同一项任务而相互合作，致使在这些并发执行的程序之间形成了相互制约的关系，而相互制约将导致程序具有“执行——暂停——执行”这种间断性的活动规律，所以说程序并发执行会产生间断性特征。 程序并发执行时为什么会失去封闭性和可再现性？当系统中存在着多个可以并发执行的程序时，系统中的各种资源将为它们所共享，而这些资源的状态也由这些程序来改变，致使其中任一程序在运行时，其环境都必然会受到其他程序的影响，显然，程序的运行已失去了封闭性。而失去封闭性会导致程序失去可再现性。 在操作系统中为什么要引入进程的概念？它会产生什么样的影响?在多道程序环境下，程序的执行属于并发执行，此时它们失去其封闭性，并且具有间断性，以及其运行结果不可再现。这些决定了通常的程序是不能参与并发执行的，否则，程序的运行也就失去了意义。为了能使程序并发执行，并且可以对并发执行的程序加以描述和控制，才操作系统中引入了进程概念. 试从动态性、并发性和独立性上比较进程和程序进程和程序是两个截然不同的概念。 动态性。进程的实质是进程实体的执行过程，因此，动态性是进程的最基本的特征。表现为“由创建而产生，由调度而执行，由撤销而消亡”，进程具有一定的生命期；而程序则只是一组有序指令的集合，并存放于某种介质上，其本身并不具有活动的含义，是静态实体。 并发性是进程的重要特征，同时也是OS的重要特征；而程序是不能参与并发执行的。 独立性是指进程实体是一个能独立运行、独立获得资源和独立接受调度的基本单位（传统OS中）；而对于未建立PCB的程序来说，它不能作为一个独立单位参与运行。 试说明PCB的作用具体表现在哪几个方面，为什么说PCB是进程存在的唯一标志？PCB作为进程实体的一部分，记录了操作系统所需的，用于描述进程当前情况以及管理进程运行的全部信息，是操作系统中最重要的记录型数据结构。 作用是使一个在多道陈存储环境下不能独立运行的程序（包括数据）成为一个能独立运行的基本单位，一个能与其他进程并发执行的进程。 当一个程序（含数据）配置了PCB后，就表示它已是一个能在多道程序环境下独立运行的、合法的基本单位，也就具有取得OS服务的权利。系统时通过PCB感知进程的存在的，所以，PCB已成为进程存在的唯一标志。 PCB提供了进程管理和进程调度所需要的哪些信息？ 进程标识符 处理机状态 进程调度信息 进程状态 进程优先级 进程调度所需的其他信息 事件 进程控制信息 程序和数据的地址 进程同步和通信机制 资源清单 链接指针 进程控制块的组织方式有哪几种？ 线性方式 链接方式 索引方式 何谓操作系统内核？内核的主要功能是是什么？现代操作系统一般将OS划分为若干层次，再将OS的不同功能分别设置在不同的层次中。 通常将一些与硬件紧密相关的模块、各种常用设备的驱动程序以及运行频率较高的模块，都安排在紧靠硬件的软件层次，让它们常驻内存，即OS内核。 OS内核的功能主要是以下两大方面： 支撑功能 中断处理 时钟管理 原语操作 资源管理功能 进程管理 存储器管理 设备管理 试说明进程在三个基本状态之间转换的典型原因 执行状态$\rightarrow$就绪状态：时间片完 就绪状态$\rightarrow$执行状态：进程调度 执行状态$\rightarrow$阻塞状态：I/O请求 阻塞状态$\rightarrow$就绪状态：I/O完成 为什么要引入挂起状态？该状态有哪些性质？引入挂起的原因，是基于系统和用户的如下需要： 终端用户的需要 父进程请求 负荷调节的需要 操作系统的需求 挂起状态的性质是：放弃CPU调度，不接受调度。引入挂起状态后，进程状态转换图增加了活动阻塞、静止阻塞、活动就绪、静止就绪四个状态，并增加了活动就绪与静止就绪，活动阻塞和静止阻塞之间的相互转换。 在进行进程切换时，所要保存的处理机状态信息有哪些？进程进行切换时，需要保存的处理机状态信息有： 进程当前暂存信息 下一指令地址信息 进程状态信息 过程和系统调用参数及调用地址信息 试说明引起进程创建的主要事件 用户登录 作业调度 提供服务 应用请求 试说明引起进程被撤销的主要事件 正常结束 异常结束 越界错 保护错 非法指令 特权指令错 运行超时 等待超时 算术运算错 I/O故障 外界干预 在创建一个进程时所要完成的主要工作是什么？在系统中每当出现了创建新进程的请求后，OS便调用进程创建原语Create按下述步骤创建一个新进程： 申请空白PCB 为新进程分配运行所需的资源 初始化进程控制块 如果进程就绪队列能够接纳新进程，便将新进程插入就绪队列 在撤销一个进程时所要完成的主要工作是什么？如果系统中发生了要求终止进程的某事件，OS便调用进程终止原语，按下述过程去终止指定的进程： 根据被终止进程的标识符，从PCB集合中检索出该进程的PCB，从中读出该进程的状态 若被终止形成正处于执行状态，应立即终止该进程的执行，并置调度标志为真，用于指示该进程被终止后应重新进行调度 若该进程还有子孙进程，还应将其所有子孙进程也都予以终止，以防它们成为不可控进程 将被终止进程所拥有的全部资源或者归还给其父进程，或者归还给系统 将被终止进程（PCB）从所在队列（或链表）移除，等待其他程序来搜集信息 试说明引起进程阻塞或被唤醒的主要事件是什么？ 向系统请求共享资源失败 等待某种操作完成 新数据尚未到达 等待新任务的到达 为什么要在OS中引入线程？在OS中引入线程，是为了减少程序在并发执行时所付出的时空开销，使OS具有更好的并发性。 试说明线程具有哪些属性？ 轻型进程 调度的基本单位 并发性 拥有资源 独立性 系统开销 支持多处理机系统 试从调度性、并发性、拥有资源及系统开销方面对进程和线程进行比较 调度性 在传统的OS中，进程是作为独立调度和分派的基本单位，因而进程是能独立运行的基本单位。在每次调度时，都需要进行上下文切换，开销较大。 在引入线程的OS中，已把线程作为调度和分派的基本单位，因而线程是能独立运行的基本单位。当线程切换时，仅需要保存和设置少量寄存器内容，切换代价远低于进程。在同一进程中，线程的切换不会引起进程的切换，但从一个进程中的线程切换到另一个进程中的线程时，必然会引起进程的切换 并发性 在引入线程的OS中，不仅进程之间可以并发执行，而且在一个进程的多个线程之间亦可并发执行，甚至允许在一个进程中的所有线程都能并发执行。同样，不同进程中的线程也能并发执行。 拥有资源 进程可以拥有资源，并作为系统中拥有资源的一个基本单位。然而，线程本身并不拥有系统资源，而是仅有一点必不可少的、能保证独立运行的资源 线程除了拥有自己的少量资源外，还云溪多个线程共享该进程拥有的资源。 系统开销 在创建或撤销进程时，系统都要为之分配和回收进程控制块、分配或回收其他资源。OS为此所付出的开销，明显大于线程创建或撤销时所付出的开销。类似地，在进程切换时，涉及到进程上下文的切换，而线程的切换代价也远低于进程的。 线程控制块TCB中包含了哪些内容？ 线程标识符 一组寄存器 线程运行状态 优先级 线程专有存储区 信号屏蔽 堆栈指针 何谓用户级线程和内核支持线程？ 用户级线程：用户级线程是在用户空间中实现的。对线程的创建、撤销、同步与通信等功能，都无需内核的支持，即用户级线程是与内核无关的。 内核支持线程：是在内核的支持下运行的，它们的创建、阻塞、撤销和切换等，都是在内核空间实现的 试说明用户级线程的实现方法用户级线程是在用户空间中的实现的，运行在“运行时系统”与“内核控制线程”的中间系统上。运行时系统用于管理和控制线程的函数的集合。内核控制线程或轻型进程LWP可通过系统调用获得内核提供服务，利用LWP进程作为中间系统。 试说明内核支持线程的实现方法系统在创建一个新进程时，便为它分配一个任务数据区PTDA，其中包括若干个线程控制块TCB空间。在每个TCB中可保存线程标识符、优先级、线程运行的CPU状态信息。每当进程要创建一个线程时，便为新线程分配一个TCB，将相关信息填入该TCB中，并为之分配必要的资源；当PTDA中的所有TCB空间已用完，而进程又要创建新的线程时，只要其所创建的线程数目未超过系统允许值，系统可再为之分配新的TCB空间；在撤销一个线程时，也应回收该线程的所有资源和TCB。 多线程模型有哪几种类型？多对一模型有何优缺点？由于用户级线程和内核级线程连接方式的不同，从而形成了三种不同的模型： 多对一模型 一对一模型 多对多模型 多对一模型的优点： 线程管理的开销小，效率高 多对一模型的缺点： 如果一个线程在访问内核时发生阻塞，则整个进程都会被阻塞 在任一时刻，只有一个线程能访问内核，多个线程不能同时在多个处理机上运行]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>习题解答</tag>
        <tag>线程</tag>
        <tag>进程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ASP.NET Core MVC 视图与控制器传值]]></title>
    <url>%2F2019%2F06%2F17%2F%E8%A7%86%E5%9B%BE%E4%B8%8E%E6%8E%A7%E5%88%B6%E5%99%A8%E4%BC%A0%E5%80%BC%2F</url>
    <content type="text"><![CDATA[一、form表单传值 View页面：GetFormValue.cshtml12345678&lt;h1&gt;GetFormValue&lt;/h1&gt;&lt;form asp-action="Home/GetFormValue" method="post"&gt; &lt;div&gt; &lt;input type="text" name="name" placeholder="名字" /&gt; &lt;/div&gt; &lt;button id="submit" type="submit"&gt;提交&lt;/button&gt;&lt;/form&gt; 在这个form表单中，用asp-action=&quot;Home/GetFormValue&quot;指定了表单中的值需要传到什么地方，其中Home代表控制器，GetFromValue代表Action。 Action: GetFormValue12345678910public IActionResult GetFormValue() &#123; return View(); &#125; [HttpPost] public IActionResult GetFormValue(string name) &#123; return View(); &#125; GetFormValue用来接受从视图传过来的值，这次传的是名字。 页面输入 传值结果 二、JS传值 视图页面：GetJsValue.cshtml12345678910111213141516&lt;h1&gt;GetFormValue&lt;/h1&gt;&lt;div&gt; &lt;input id="testdata" type="text"/&gt; &lt;input id="submitButton" type="button" value="提交" /&gt;&lt;/div&gt;&lt;script &gt; var button = document.getElementById('submitButton'); button.onclick = function () &#123; var data = $('#testdata').val(); $.post("Home/GetJsValue", &#123; name: data &#125;, function () &#123; alert("submit data success!"); &#125;); &#125;&lt;/script&gt; Action：GetJsValue123456789public IActionResult GetJsValue() &#123; return View(); &#125; [HttpPost] public IActionResult GetJsValue(string name) &#123; return View(); &#125; 页面输入 传值结果 三、Jquery AJAX方法传值 视图页面：GetJqueryValue.cshtml123456789101112131415161718192021222324&lt;h1&gt;GetJqueryValue&lt;/h1&gt;&lt;div&gt; &lt;input id="testdata" type="text" /&gt; &lt;input id="submitButton" type="button" value="提交" /&gt;&lt;/div&gt;&lt;script type="text/javascript" src="~/js/jQuery.form.js"&gt;&lt;/script&gt;&lt;script type="text/javascript" src="~/js/jquery-1.12.4.min.js"&gt;&lt;/script&gt;&lt;script&gt; $("#submitButton").click(function () &#123; var name = $("#testdata").val(); $.ajax(&#123; type: 'post', url:'/Home/GetJqueryValue', data: &#123; "name": name &#125;, success: function (data) &#123; alert("submit success"); &#125;, error: function (data) &#123; alert("failed"); &#125; &#125;) &#125;);&lt;/script&gt; 在使用jquery的ajax方法传递数据的时候，会出现not defined错误，网上查了一圈也没有解决，最后用上面的方式解决了。 Action:GetJqueryValue123456789public IActionResult GetJqueryValue() &#123; return View(); &#125; [HttpPost] public IActionResult GetJqueryValue(string name) &#123; return View(); &#125; 页面结果 传值结果 四、模型绑定模型绑定就是将表单中的传递来的数据，创建对应的model并把数据赋给model的属性。我们能看到的就是表单传过来的数据是一个对象。 需要注意的是，传递每一项数据的名称和接受的类的属性名称必须相同。 Aoki类：1234567public class Aoki &#123; [Required(ErrorMessage = &quot;尚有未填写项，请先完善&quot;)] public string name &#123; get; set; &#125; [Required(ErrorMessage = &quot;尚有未填写项，请先完善&quot;)] public string description &#123; get; set; &#125; &#125; 对于Aoki类，我添加了模型验证，Required就是说这个属性不能为空，当表单中这个数据没有填写的时候，是无法提交的。当然，我觉得前端的验证有浏览器完成比较好一些。 视图页面：GetModelValue.cshtml1234567891011&lt;h1&gt;GetModelValue&lt;/h1&gt;&lt;form asp-action="Home/GetModelValue" method="post"&gt; &lt;div&gt; &lt;input type="text" name="name" placeholder="名字" /&gt; &lt;/div&gt; &lt;div&gt; &lt;input type="text" name="description" placeholder="描述" /&gt; &lt;/div&gt; &lt;button id="submit" type="submit"&gt;提交&lt;/button&gt;&lt;/form&gt; 这里要注意的是，name必须和原有对象的属性名相同。 Action:GetModelValue123456789public IActionResult GetModelValue() &#123; return View(); &#125; [HttpPost] public IActionResult GetModelValue(Aoki aoki) &#123; return View(); &#125; 在第二个Action中会收到前端传过来的一个对象，这个对象的属性是和前端页面中表单中填写的数据绑定的。 页面输入： 传值结果： 五、定位标记帮助程序标记帮助程序使服务器端代码可以在Razor文件中参与创建和呈现HTML元素。在下面的代码中，AnchorTagHelper从控制器操作方法和路由ID动态生成HTMLhref特性值。 视图页面：GetNum.cshtml1234567891011121314151617181920&lt;h1&gt;GetNum&lt;/h1&gt;&lt;table border="1"&gt; &lt;tr&gt; &lt;th&gt;名字&lt;/th&gt; &lt;th&gt;描述&lt;/th&gt; &lt;th&gt;操作&lt;/th&gt; &lt;/tr&gt; &lt;tr&gt; &lt;th&gt; Aoki &lt;/th&gt; &lt;th&gt; 试举头，一笑问青天、天无语 &lt;/th&gt; &lt;th&gt; &lt;a asp-action="GetNum" asp-controller="Home" asp-route-ID="1"&gt;查看&lt;/a&gt; &lt;/th&gt; &lt;/tr&gt;&lt;/table&gt; 这里需要注意的是asp-action、asp-controller、asp-route-ID是生成URL。在asp-route-ID中值得注意的是，这里面的ID就是传递的参数，控制器里面的参数名字是什么，这里的ID就换成什么。否则会出错 Action:GetNum1234public IActionResult GetNum(int ID) &#123; return View(); &#125; 页面结果 鼠标悬停在查看按钮上，下方会出现URL。如图所示。 在浏览器中“查看源”，生成的HTML的部分如下如图所示。 传值结果 &emsp;&emsp;获得源码]]></content>
      <categories>
        <category>ASP.NET Core MVC</category>
      </categories>
      <tags>
        <tag>ASP.NET Core</tag>
        <tag>视图与控制器</tag>
        <tag>传值</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ASP.NET Core MVC控制器与视图传值]]></title>
    <url>%2F2019%2F06%2F16%2FASP-NET-Core-MVC%E6%8E%A7%E5%88%B6%E5%99%A8%E4%B8%8E%E8%A7%86%E5%9B%BE%E4%BC%A0%E5%80%BC%2F</url>
    <content type="text"><![CDATA[一、传值方式 弱类型参数传递数据 强类型参数传递数据 二、弱类型参数传递数据 ViewData1）派生自ViewDataDictionary，因此它有可用的字典属性，如，ContainsKey、Add、Remove、Clear &emsp; 2）字典中键是字符串，所以允许有空格 &emsp; 3）任何非string类型均须在试图中进行强制转换才能使用ViewData ViewBag1）派生自DynamicViewData，因此它可使用点表示法（ViewBag.name=name)创建动态属性，且无需强制转换 2) ViewBag的语法使控制器到视图的速度更快 3) ViewBag更易于检查NULL值 3. ViewData的使用1）创建Action：Index 123456public IActionResult Index() &#123; ViewData[&quot;name&quot;] = &quot;Aoki&quot;; ViewData[&quot;description&quot;] = &quot;试举头，一笑问青天、天无语&quot;; return View(); &#125; 2）创建视图：Index.cshtml 1234&lt;div class="text-center"&gt; &lt;h1&gt;@ViewData["name"]&lt;/h1&gt; &lt;p&gt;@ViewData["description"]&lt;/p&gt;&lt;/div&gt; 3）实现结果： 4. ViewBag的使用1）创建Action：Index \ASP-NET-Core-MVC控制器与视图传值 1234567public IActionResult Index() &#123; ViewBag.type = &quot;ViewBag&quot;; ViewBag.name = &quot;Aoki&quot;; ViewBag.description = &quot;试举头，一笑问青天、天无语&quot;; return View(); &#125; 2）创建视图：Index.cshtml 12345&lt;div class="text-center"&gt; &lt;h1&gt;@ViewBag.name&lt;/h1&gt; &lt;p&gt;@ViewBag.description&lt;/p&gt; &lt;h4&gt;Pass the value through @ViewBag.type&lt;/h4&gt;&lt;/div&gt; 3）实现结果 三、强类型参数传递数据 强类型参数说明&emsp;&emsp;视图强类型通常称为ViewModel，可以在return View();时指定参数/对象。并在视图文件（.cshtml）中通过@model语法来指定对应的类型。 强类型参数示例1）创建Aoki类 12345public class Aoki &#123; public string name &#123; get; set; &#125; public string description &#123; get; set; &#125; &#125; 2）创建Action：Index 123456789public IActionResult Index() &#123; var aoki = new Aoki &#123; name = "Aoki", description = "试举头，一笑问青天、天无语" &#125;; return View(aoki); &#125; 3）创建视图：Index.cshtml 1234&lt;div class="text-center"&gt; &lt;h1&gt;@Model.name&lt;/h1&gt; &lt;p&gt;@Model.description&lt;/p&gt;&lt;/div&gt; 4）实现结果]]></content>
      <categories>
        <category>ASP.NET Core MVC</category>
      </categories>
      <tags>
        <tag>ASP.NET Core</tag>
        <tag>MVC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[软件管理]]></title>
    <url>%2F2019%2F06%2F16%2F%E7%AE%A1%E7%90%86%2F</url>
    <content type="text"><![CDATA[一、软件过程改进模型CMMI软件组织的产品质量和服务质量，来自组织内部的过程改进状态。而过程改进是要有模型的，模型是实践、理论、方法、经验和技术的结晶，是软件组织的一种企业文化、工作环境和管理理念；模型能够引导企业从杂乱无章的管理状态到有条不紊的管理状态。 目前为止，IT企业界的过程管理和过程改进模型共有三个类型： ISO 9001 模型 CMMI模型 软件企业文化模型 微软企业文化 IBM企业文化 敏捷文化现象 CMMI是什么软件能力成熟度模型CMMI是由美国卡内基-梅隆大学软件工程研究所推出的评估软件能力与成熟度等级的一套标准。 CMMI的作用是什么 软件组织，用它来不断改进自身的软件过程管理能力 评估机构，用它来评估某软件组织当前软件能力成熟度级别 客户，用它来评估某承包商的软件能力 CMMI的实质 以“过程”为核心，抓软件组织的管理，即软件“组织”的过程改进 以“项目”为手段，抓团队开发过程的“活动”，即落实过程改进的措施 以“活动”记录为基础，抓软件过程的“度量”，即“度量”软件组织改进的情况 CMMI阶段模型的成熟度等级 CMMI等级 PA数目 管理特点 ML1:初始级 0 过程不可预测且缺乏控制 ML2：已管理级 7 过程为项目服务，即项目级管理 ML3：已定义级 11 过程为组织服务，即组织级管理 ML4：定量管理级 2 过程已度量和控制，即定量级管理 ML5：优化级 2 集中于过程改进，即优化管理级 ISO 9001与CMMI的联系和区别&emsp;&emsp;与ISO 9001标准相比，CMMI更为软件产业所看好。原因是CMMI专门针对软件工程控制而设置。它不仅进行软件企业工程能力的评估，更致力于软件开发过程的管理，强调对软件开发过程进行持续改进，引导软件开发过程走向成熟。 &emsp;&emsp;两者的相同点是：CMMI和ISO 9001标准都致力于质量和过程管理，都是为了解决同样的问题。 &emsp;&emsp;两者的不同点是：CMMI是动态的、开放的和持续改进的，它强调“没有最好，只有更好”，强调不断改进，强调人在软件开发方面的主动性，非常适用于软件过程改进；ISO 9001是静态的质量控制，只要达到20个关键指标或过程，就能完成质量控制，它更适用于硬件制造行业和第三产业的质量控制。CMMI与IO 9001的设计思路有差异：CMMI是“专用的”，ISO 9001是“通用”的。ISO 9001不覆盖CMMI，CMMI也不覆盖ISO 9001. 二、软件配置管理软件配置管理SCM是对软件开发过程中配置项的一组追踪和控制活动，它开始于软件开发之初，结束于软件淘汰之时。 三、软件质量保证软件质量保证SQA是一个过程，是CMMI和ISO 9001的重要议题，同样也是项目管理的重要议题。 软件质量，是供方提供的软件产品满足用户明确或隐含需求的能力特性的总和。 质量管理的三大支柱 质量标准 配置管理 测试测量 质量管理的三大要素 SQA计划 SQA进度 SQA评审和审计 四、软件项目管理 什么是项目项目，是一次性的多任务工作，它具有确定的开始日期，结束日期，工作范围，经费预算，质量标准，以及特定的功能、性能和接口要求。 什么是项目管理项目管理，是为了实现项目目标，运用相关知识、技能、方法与工具，对项目的计划、进度、质量、成本、资源进行管理和控制的活动。 项目经理的七项职责 抓需求获取与确认 抓计划制订与执行 抓团队分工与协作 抓后勤供应与保障 抓产品测试和交付 抓开发标准与规范 抓员工考核与奖励 项目经理对程序员的八项要求 团队协作精神的训练和要求 数据库和数据结构分析与设计能力的训练和要求 书写文档习惯的训练和要求 规范化代码编写能力的训练和要求 复用性能力与构件技术的训练和要求 测试习惯的训练和要求 学习和总结能力的训练和要求 引导程序员由“丑小鸭”变成“白天鹅”]]></content>
      <categories>
        <category>软件工程</category>
      </categories>
      <tags>
        <tag>CMMI</tag>
        <tag>软件管理</tag>
        <tag>项目管理</tag>
        <tag>软件质量保证</tag>
        <tag>项目经理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[软件实施与维护]]></title>
    <url>%2F2019%2F06%2F16%2F%E5%AE%9E%E6%96%BD%E4%B8%8E%E7%BB%B4%E6%8A%A4-1%2F</url>
    <content type="text"><![CDATA[一、软件产品 软件企业开发的软件可以分为软件项目和软件产品。 软件产品分为三类分别是： 类别 产品特点 举例 1 不需要客户化的产品 系统软件 2 只需要少量客户化工作的产品 专业性特强的应用软件产品 3 需要重新做业务流程规范和需求规格定义的软件产品 分行业ERP 项目与产品的区别与联系 除了上述三类软件产品外，其他软件一般称为软件项目，不能叫软件产品。 软件项目就是为用户定制的软件系统，它的专业性强，通用性差，从需求分析、设计、编码、测试，到安装、试运行、正式运行，直至验收交付，整个开发流程一步都不能省。 软件项目的特点是，业务领域知识所占比重大，工程性强，因此用CMMI模型实现规范化管理和量化控制比较适合。IT企业做软件项目的目的，一般都是为了将软件项目逐步产品化，如同做财务项目是为了做财务产品一样。一方面，只有产品化了才能赚取最大的利润，另一方面，只有拥有自己的软件产品，才能在投标活动中获得更大更好的项目。 项目和产品既有显著的不同，又有紧密的关系。这种关系是：做软件项目是手段，做软件产品是目的，软件项目做多了，软件项目就慢慢变成了软件产品。 二、软件产品的发布&emsp;&emsp;产品的发布时机，是由市场利润、开发进度、产品的功能与质量、客户可接受程度等多方面因素决定的。 三、软件产品的实施软件产品发布以后，销售中心就会获取各种客户信息，并准备用各种方式为客户服务。在服务中，需要各种销售技术人员的支持，这些技术人员包括售前、售中、售后三部分人员。售前技术人员称为售前工程师，售中技术人员称为实施工程师，售后技术人员称为维护工程师。 四、软件维护的传统方法软件维护，是指软件项目或产品爱安装、运行并交付给用户使用后，在新产品升级之前这段时间里，软件厂商向客户提供的服务工作。 软件维护的分类 序号 维护的种类 维护的内容 1 纠错性维护 产品或项目中存在缺陷或错误，在测试和验收时未发现，到了使用过程中逐渐暴露出来，需要改正。 2 适应性维护 这类维护是为了产品或项目适应变化了的硬件、系统软件的运行环境，如系统升级 3 完善性维护 这类维护是为了给软件系统增加一些新的功能，使产品或项目更加完善与合理，又不至于对系统进行伤筋动骨的改造，这类维护占维护的大部分 4 预防性维护 这类维护是为了提高产品或项目的可靠性和可维护性，有利于系统的进一步改造或升级换代 软件维护的副作用 序号 维护的方式 副作用的表现 1 修改编码 使编码更加混乱，程序结构更不清晰，可读性更差，而且会有连锁反应 2 修改数据结构 数据结构是系统的骨架，修改数据结构是对系统伤筋动骨的大手术，在数据冗余与数据不一致方面，可能顾此失彼 3 修改用户数据 需要与用户协商，一旦有疏忽，可使系统发生意外 4 修改文档 对非结构化维护不适应，对结构化维护要严防程序与文档的不匹配 五、软件维护的最新方法 软件维护的最新分类方法 面向缺陷维护——程序级维护 面向功能维护——设计级维护 软件维护的最新方法 基于两层结构（客户机/服务器）划分软件维护的方法 基于三层结构划分软件维护的方法 基于“三种开发方法”，来划分软件维护的方法 软件维护工作流程 流程步骤 流程内容 1 分类整理用户意见 2 提出维护申请 3 评审、审计、批准维护申请 4 修改需求文档 5 维护需求文档评审 6 维护设计文档 7 维护设计文档评审 8 修改源程序 9 回归测试 10 修改软件版本号 11 交付用户运行 12 收集用户反馈意见，准备进行新一轮维护活动，转向流程第1个步骤]]></content>
      <categories>
        <category>软件工程</category>
      </categories>
      <tags>
        <tag>软件维护</tag>
        <tag>软件产品</tag>
        <tag>软件项目</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[软件设计、实现与测试]]></title>
    <url>%2F2019%2F06%2F15%2F%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E3%80%81%E5%AE%9E%E7%8E%B0%E3%80%81%E6%B5%8B%E8%AF%95%2F</url>
    <content type="text"><![CDATA[一、软件设计 三层结构设计1）表示层：也称浏览层，通常采用图形化界面，在客户端PC或工作站上运行。站在“三个模型”的思想上看，系统内部支持表示层的模型是“功能模型”。 &emsp;表示层的主要功能： &emsp;1)接受用户请求，将这些请求反馈给业务逻辑层，等待业务逻辑层的应答信息。 &emsp;2）对业务逻辑层的应答信息进行显示 &emsp;3）有时会兼做一些业务逻辑层的小功能 2）中间层（业务层）：它由许多构件和组件组成，它们完全体现了用户的业务逻辑或业务规则，站在“三个模型”建模思想上看，系统内部支持业务层的模型是“业务模型”。 &emsp;业务层的主要功能： &emsp;1）接受从表示层传来的用户请求信息 &emsp;2）根据用户的请求信息生成SQL语句 &emsp;3)利用生成的SQL语句从数据层取数据、修改数据、删除数据 &emsp;4）将结果返回表示层 中间层也可以分为两个子层，分别是业务逻辑层和数据访问层。 在这段时间的信息系统设计中我深有体会，将虽然三层结构从一定程度上可以降低系统的耦合度，但是如果数据层出现问题，需要进行调整，那么中间层也要进行大规模的调整，这对系统的实现进度是有害的。如果将中间层划分为两个子层，那么，如果数据层出现问题，进行了大规模调整，那么我们的业务逻辑层是不会受到影响的，只需要对数据访问层进行适当的修改。 3）数据层：是数据库服务器上的数据库层，它包括数据库管理系统DBMS和数据库DB两部分。站在“三个模型”建模思想上看，系统内部支持数据层的模型是“数据模型”。 &emsp;数据层的功能： &emsp;1）接受业务层数据处理请求的SQL语句或存储过程 &emsp;2）利用SQL语句或存储过程，对数据库服务器上数据库的相关表进行存储或检索 &emsp;3）将存储或检索的结果传递给业务层。 软件设计原理软件设计原理，就是各种软件设计方法中都应该遵守的共同基本原理。这些原理包括：抽象、模块化、信息隐藏、模块独立性、封装、接口和实现分离。 1）抽象。 在每个阶段中，抽象的层次逐步降低，在软件结构设计中的模块分层也是由抽象到具体分析和构造出来的。抽象就是将几个有区别的物体的共同性质或特性，形象地抽取出来，独立地进行考虑的过程。 常用的抽象技术有：控制抽象、过程抽象、数据抽象 2）模块化。 模块指程序中的数据说明、可执行语句等程序对象的集合，或单独命名和编程的元素。 模块化，就是解决一个复杂问题时，自顶向下、逐步求精地把软件系统划分为若干模块的过程。为了解决复杂的问题，在软件设计中，必须把整个问题分解来降低复杂性，以减小开发工作量，降低开发成本，提高软件生产率。但是模块并不是越多越好，因为这会增加模块之间的接口量。所以划分模块的层次和数量应该避免过多或过少。 3）信息隐藏。 信息隐藏，指在设计和确定模块时，使一个模块内包含的信息，对于不需要这些信息的其他模块来说是不能访问的。 4）模块独立性。 模块独立性指每个模块只完成系统要求的独立的子功能，并且与其他模块的联系最少，且接口简单。模块独立性是抽象、模块化、信息隐藏的直接产物，在概要设计的过程中，就是要设计出具有良好模块独立性的软件结构。用来衡量软件模块独立性的定性度量标准有：高内聚、低耦合 5）封装。 封装是将信息隐藏在一个实体中，使其内部细节对外不可见。封装是实现“低耦合、高内聚”的技术手段之一。要进行正确的封装，必须遵守的原则是： 实体间相互隐藏内部实现 尽量减少全局的共享数据 6）接口和实现分离 将接口与实现分离，对外只提供接口，隐藏具体的实现。接口与实现的分离，保证了实现的独立变化，降低了模块间的耦合。 二、三种设计方法 面向过程设计1）面向过程概要设计的主要方法有： 功能模块分解方法 功能模块调用方法 功能模块转化方法 数据流图转换为层次结构图方法 2）面向过程设计技术，采用“自顶向下、逐步求精”的设计方法和“单入口、单出口”的控制结构，并且只包含顺序、选择和循环三种结构，设计目标之一是使程序的控制流程线性化，即程序的动态执行顺序符合静态书写结构。 3）详细设计的工具有：程序流程图、N-S图、程序设计语言PDL、PAD图等 面向对象设计面向对象设计描述工具： 1）系统静态建模图（结构图） 类图 部件图 部件图比类图在更高层次上体现了系统中部件、部件接口以及部件之间的关系。 部署图 表示运行时处理元素（节点）的物理配置情况。 界面图 2）系统动态建模（行为图） 用例图 顺序图 &emsp;&emsp;顺序图是系统的动态视图，表示系统基于时间序列的操作。在顺序图中可以包括与系统交互的角色。顺序图以一个二维视图展现交互过程，垂直方向上是时间轴，水平方向上是参与交互的对象或角色。 &emsp;&emsp;顺序图是类图的补充，类图是系统的静态视图，顺序图反映了系统的动态视图。通常先绘制用例图，接着根据用例图中涉及的实体绘制类图，再绘制顺序图来展现用例的交互过程。 状态图 &emsp;&emsp;状态图是状态机图形化的表现，用于描述用例、部件或类的行为。状态图对实体的有限状态、事件和状态间的转换进行建模。 活动图 &emsp;&emsp;活动图描述的是执行某个功能的活动。 面向元数据设计&emsp;&emsp;面向元数据设计，以实体-关系模型为基础，按照一定的规则将概念模型CDM转换成为能被某种数据库管理系统接受的物理数据模型PDM，创建物理上的数据库表、索引和视图，并且用存储过程和触发器来实现各种业务规则。 三、软件实现 构件：就是被标识的且可被复用的软件制品。 中间件：是一个非常大的组件（构件），一般在网络上运行，完成批量数据的传递和通信工作，调用方式是通过一组事先约定的格式与参数进行的。 软件实现原则 尽可能简单。在软件实现过程中，应创建简单、容易阅读的代码；相同功能的代码只写一次；简单的代码易于维护；通过采用一些编码规范和标准，可以有效地降低代码的复杂度。 易于验证。无论是在编码、测试和实际操作中，软件工程师应该很容易发现其中的错误；自动化的单元测试可产生易于验证的代码；写代码时，要限制使用复杂的难以理解的语言结构 适应变化。外部环境、软件需求和软件设计，在整个开发过程中可能会随时发生变化，因此要求软件实现时考虑适应这些变化 遵守某一编程规范。尽量使用了标准库函数和公共函数。不要随意定义全局变量，尽量使用局部变量。使用括号避免二义性。 选择项目组成员最熟悉的工具或语言。 除此之外，除了特殊要求之外，任何程序必须遵守”可读性第一、效率第二“的实现原则。 四、软件测试在另外的一些文章或资料中有所涉及和详细解释。]]></content>
      <categories>
        <category>软件工程</category>
      </categories>
      <tags>
        <tag>软件设计</tag>
        <tag>软件实现</tag>
        <tag>三层结构</tag>
        <tag>软件设计原理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[软件建模]]></title>
    <url>%2F2019%2F06%2F15%2F%E8%BD%AF%E4%BB%B6%E5%BB%BA%E6%A8%A1%2F</url>
    <content type="text"><![CDATA[一、三个模型的建模思想 功能模型功能模型，实质上是用户需求模型，用来描述系统能做什么，即对系统的功能、性能、接口和界面进行定义。 从用户角度来看，功能模型就是系统功能需求列表 从设计者的角度看，功能模型就是系统内部功能模块的有机排列和组合 从Rose的角度上看，功能模型就是系统的用例的集合 从产品的角度看，功能模型就是系统的用户操作手册 从操作界面的角度上看，功能模型就是系统的功能菜单 从B/A/S的角度上看，功能模型就对应在浏览层上建模 业务模型业务模型，实质上是业务逻辑模型，用于描述系统在何时、何地、由何角色、按什么业务规则去做、以及做什么的流程或步骤，即对系统的操作流程进行定义。 业务模型反映了系统的业务行为，是算法设计的主要依据。站在B/A/S的角度上看，业务模型就对应在中间层（业务逻辑层或业务应用层）上建模。 数据模型数据模型实质上是实体或类的状态关系模型，用于描述系统工作前的数据来自何处、工作中的数据暂存在什么地方、工作后的数据放到哪儿、以及这些数据的状态及相互之间的关联，即对系统的数据结构进行定义。 二、数据模型设计 什么是好的数据模型？条件有三： 1）满足功能需求 2）满足性能需求 3）该模型能够长期使用，也就是“以不变应万变 数据库的基本表、代码表、中间表和临时表存放元素数据的表，称为基本表 存放信息代码的表，称为代码表 存放统计信息的表，称为中间表（又称查询表） 存放临时数据的表，称为临时表 基本表的4个特性：1）原子性：基本表中的字段是不可再分解的。 2）原始性：基本表中的记录是原始数据记录。 3）演绎性：由基本表与代码表中的数据可以派生出所有的输出数据。 4）稳定性：基本表的结构是相对稳定的，表中的记录需要长期保存。 数据库设计的步骤：1）将原始单据分类整理，理清原始单据与输出数据之间的数据转换关系和算法，澄清一切不确定的问题。 2）从原始单据出发，划分出各个实体，给实体命名，初步分配属性，标识出主键或外键，理清实体之间的关系。 3）进行数据库概念数据模型设计，画出实体关系图ERD，定义完整性约束 4）进行数据库物理数据模型PDM设计，将概念模型CDM转换为物理数据模型PDM 5）在待定对的数据库管理系统上定义表空间，实现物理建表与建索引 6）定义触发器与存储过程 7）定义视图，说明数据库与应用程序之间的关系 8）数据库加载测试：向基表中追加记录，对数据库的功能、性能进行全面测试 9）数据库性能优化：从数据库系统的参数配置、数据库设计的反规范化两个方面，对数据库的性能进行优化 10）数据库设计评审：从数据库的整体功能和性能两个方面，请同行专家评审评价 三、数据库设计理论与方法 数据库范式理论1NF，关系模式中的关系的每个分量都是不可再分的数据项 2NF，满足1NF，且每一非主属性完全函数依赖于候选键 3NF，消除非主属性对候选键的传递依赖 数据库设计中的“第三者插足”设计模式当两个实体之间存在多对关系时，必须在它们之间插入第三个实体，以化解这种多对多关系。 数据库设计中的“列变行”模式就是将第一个表中的某些列，变为第二个表中的某些行。 数据库设计中的四个原子化理论站在数据库设计者的角度看，只要实现属性原子化、实体原子化、主键原子化、联系原子化，数据的所谓更新异常、插入异常、删除异常、数据冗余现象就从根本上消除了。 属性原子化：实体的属性本身不能再分解 实体原子化：实体本身不能再分解 主键原子化：是指实体的主键本身是一个ID（identifier） 联系原子化：是指实体之间的联系都是一对多联系。]]></content>
      <categories>
        <category>软件工程</category>
      </categories>
      <tags>
        <tag>软件建模</tag>
        <tag>功能模型</tag>
        <tag>数据库设计</tag>
        <tag>范式理论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[软件需求分析]]></title>
    <url>%2F2019%2F06%2F15%2F%E8%BD%AF%E4%BB%B6%E9%9C%80%E6%B1%82%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[写在前面&emsp;需求分析的输入是软件的《合同》或《立项建议书》，以及对用户现场的调研、分析和确认，输出是《用户需求报告》。 一、需求分析是什么？&emsp;在对需求分析进行了解之前，得知道需求分析是什么。 &emsp;需求分析的定义如下： 用户解决问题或达到目标所需的条件或能力 系统或系统部件要满足合同、标准、规范或其他正式文档规定所需具有的条件或能力 一种反映1或2所描述的条件或能力的文档说明 &emsp;我对需求分析的定义时理解是，需求分析中的文档说明起到了至关重要的作用。 &emsp;当然对于一个软件系统来说，前期的需求分析是十分重要的，这几乎可以决定软件系统开发的成败。 二、需求获取的三原则&emsp;所谓需求获取，就是开发者与用户共同提取并共同确认需求。“划分、抽象、投影”是需求获取的三要素。 划分，就是捕获问题空间的“整体/部分”关系。 抽象，就是捕获问题空间的“一般/特殊”或“一般/特例”关系。 投影，就是捕获问题空间的多维”视图“。 &emsp;我对这三原则的理解可能欠妥，但这是我在学习过程中的一些想法。首先，划分，就是将整个系统进行划分，将复杂的系统划分为小系统，这样不仅可以简化系统分析的难度，同时，由于对其进行了划分，所以在需求分析的时候，能够对系统的需求细节进行完善。 &emsp;其次是抽象，对于一个软件系统，能够实现功能的复用性是再好不过了，那么就需要对需求中的“特殊”扩展泛华为“一般”，依次来实现复用。 &emsp;最后是投影，程序的实质是对现实世界的投影，是对现实世界中不同角色工作流程或工作业务的抽象处理，而对于一个系统来说，操作它的可能有三种角色，比如，高层领导，中层管理和基层操作人员。而这三种角色的业务流程和工作业务是不同，需要从三维视图进行分析。 三、需求分析的任务是什么？ 画出目标系统的组织结构图，列出各部门的岗位角色表，即组织机构模型。 画出目标系统的业务操作流程图，即业务模型。 画出目标系统的数据流图，即单据和报表的流图，掌握业务规则，获得初步的数据模型 列出目标系统的功能点列表，即功能模型。 列出系统的性能点列表，即性能模型。 确定目标系统的接口列表，即接口模型 确定目标系统的运行环境，即环境模型 目标系统的界面约定，即界面模型 对目标系统的开发工期、费用、开发进度、系统风险等问题进行分析和评估。 四、面向流程分析&emsp;需求分析是面向流程的，而流程是动态的、实时的。系统的功能、性能、接口、界面都是在流程中反映出来的。在所有的流程中，数据流最为很重要，同时也最具代表性。因为在计算机网络系统中，一切流程都表现为数据流。所以，面向流程分析，实质上是面向数据流程分析或面向数据分析。计算机网络只认识数据，其他所有信息必须转化为数据之后才能流动，所以面向流程分析本质上是面向数据流程分析。 五、需求分析的方法有哪些？&emsp;业界存在三种需求分析方法，分别是：面向功能分析、面向对象分析、面向数据分析。 &emsp;面向功能分析，是将软件需求看做一棵倒置的功能树，树根在上，树枝与树叶在下，每个节点都是一项具体的功能，从上到下，功能由粗到细，树根是总功能，树叶是细功能，整棵树就是一个信息系统的全部功能树。功能分析体现了“自顶向下，逐步求精”的思想，适合于“结构化分析、结构化设计、结构化编程、结构化测试、结构化组装、结构化维护”的传统式软件工程思想。 &emsp;面向对象分析，实质上是面向类分析，它也从系统的基本功能入手，或从与系统有关的人和事入手，将所有的功能需求找出来，然后将每一项功能对应一个对象集（类），分析每个对象集的属性、方法和包装方式，最后归并为相同对象集，删除冗余属性，用类与类之间的关联来表示所有的需求。 &emsp;面向数据分析，是面向元数据和中间数据分析。 六、需求分析的描述工具有哪些？ 面向元数据的需求描述工具 实体关系图 面向过程的需求描述工具 数据流图DFD、数据字典DD 面向对象的需求描述工具 用例图、类图、]]></content>
      <categories>
        <category>软件工程</category>
      </categories>
      <tags>
        <tag>需求分析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[软件生命周期模型]]></title>
    <url>%2F2019%2F06%2F15%2F%E8%BD%AF%E4%BB%B6%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E6%A8%A1%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[写在前面&emsp;开发一个软件项目，首先要选择并确定一个适合于该项目的软件生命周期模型，然后按照该软件生命周期模型的开发路线图，进行开发。 软件生命周期模型是指在整个软件生命周期中，软件开发过程应遵循的开发路线图。或者说，软件生命周期模型是软件开发全部过程、活动和任务的结构框架。 软件生命周期的9个阶段1）立项（或签订合同）、下达任务书 2）需求分析 3）概要设计 4）详细设计 5）编码实现 6）软件测试 7）软件发布与实施 8）软件维护 9）版本更新或退役 软件生命周期模型有哪些？瀑布模型、增量模型、原型模型、迭代模型、螺旋模型、喷泉模型、XP模型 瀑布模型是什么？具体的详细定义不再展开。 分为5个阶段：需求、设计、编码、测试、发布。自上而下。 首先，我们需要知道，瀑布模型师最早的软件生命周期模型，时至今日，仍然有强大的生命力，也是唯一被广泛使用的软件开发模型。 项目经理或软件管理人员，只要控制好每级台阶的高度和宽度，在每级台阶处设立里程碑或基线，并组织好对基线的评审，就可以控制好项目的开发成本、进度和质量。 但是，该模型的问题就在于阶梯，瀑布只能向下流，需要向上流的时候就需要付出很大的代价。这就是它的“问题堆积”，错误或发散扩大。 该模型的“问题堆积”并不是不可解决的，只要采用适合的管理方法，就可以控制或避免。比如微软公司采用的严格的里程碑管理制度。 增量模型是什么？增量模型是遵循递增方式来进行软件开发的。 在增量模型中，软件产品被看成了一组增量构件或模块。每次需求分析、设计、实现、集成、测试和交付一块构件。 对于一个复杂的大型系统，采用分解的方式来将大系统分解成小系统，这样虽然可以将大风险分解成多个小风险，并逐步消除小风险。但是，将一个复杂的大型系统进行合理、有效的分解和划分是最难的地方。 同时，对大系统进行有效的分解和划分的前提是，该复杂系统可被分解。若复杂系统的拆卸性和组装性不强，那么，增量模型就不再适合该复杂系统的开发。 原型模型原型模型的本意是在初步需求分析后，立马就向用户展示一个软件产品原型。 原型模型开发的过程中始终是以原型来驱动的，这很适合于那些已经有软件产品积累的公司。 但是，画画之前就已经知道画出来的结果是什么了，那么在画的过程中就很难有创新了。对于软件开发也是，这也是原型模型的主要缺点。 迭代模型迭代模型通过对各个工作流程的多次进行，更好地理解需求，从而可以设计出更为强壮的软件构架，逐步提高开发组织能力。 从宏观上看，迭代模型有4个状态阶段，分别是：先启、精化、构建和产品化。 而它的工作流程共有9个，分别是：1）业务建模 2）需求获取 3）分析设计 4）实施 5）测试 6）部署 7）配置与变更管理 8）项目管理 9）环境 在这9个工作流程中，核心流程是业务建模，因为在迭代模型开发之前一定要有一个初始的业务模型，以便对其进行迭代。 螺旋模型螺旋模型将瀑布模型和原型模型结合起来，特别强调风险分析，特别适用于大型复杂系统。 喷泉模型喷泉模型认为，软件开发过程自上而下的各个阶段是相互重叠和多次反复进行的。 喷泉模型有大量的重叠，所以需要大量的开发人员，不利于项目的管理。 XP模型XP模型即极限编程模型。本是敏捷文化现象。 XP模型通过需求、实现、重构、测试、发布的迭代过程，来实现一种轻量级的软件开发模型。 XP的核心要求是：交流、简单、进取、反馈 XP模型作为一种新的模型，在实际运用中存在较多的问题。同时，它与ISO 9001、CMMI的精神也存在冲突。]]></content>
      <categories>
        <category>软件工程</category>
      </categories>
      <tags>
        <tag>软件生命周期</tag>
        <tag>软件生命周期模型</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[软件工程的内容和方法]]></title>
    <url>%2F2019%2F06%2F14%2F%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E7%9A%84%E5%86%85%E5%AE%B9%E5%92%8C%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[写在前面&emsp;经过一个礼拜的准备，终于结束了软件工程的复习。在复习软件工程的同时也在做信息系统综合设计的课程设计。在做课程设计的过程中，发现了软件工程的重要性和必要性。作为立志成为程序猿的我，软件工程在将来的工作中一定大有用处，故总结如下。 一、软件、软件工程、软件工程学科体系学习软件工程，首先得知道软件是什么。其次，得知道软件工程是做什么的，它研究了什么内容，同时也应该知道软件工程学科体系是什么，与软件工程有什么关系。 软件：最新定义为，软件=知识+程序+数据+文档那么这里面的知识，程序，数据，文档又是指什么呢？ 知识，即各种各样的相关领域的专业知识。 程序，即使对计算机任务的处理对象和处理规则的描述。这里，我们一定要注意，软件并不等于程序，这也是一大误区。 数据，即程序赖以运行的初始化数据。 文档，即为了理解程序所需的详细描述性资料。 软件工程是什么？软件工程是研究软件开发和管理的一门工程学科。 这个定义很短，但是知识点还是挺多的。一强调开发，毕竟开发是软件工程的主体；二强调管理或过程管理，当然，管理是为了更好的开发；三是强调工程，把软件的开发和维护当成一项工程，用工程的办法去开发，按工程的办法去管理；四是强调学科，时至今日，软件工程不只是一门学科，而是一个学科体系。这里也就引出了软件工程学科体系。 软件工程来源于软件危机。软件工程是为了克服软件危机才产生的。 软件工程学科体系 软件工程作为一个学科体系，到21世纪才初步形成。2004年ACM和IEEE-CS联合制订了SWEBOK 2004版，它将软件工程学科体系的知识划分为10个知识域。 对于这10个知识域，我的理解是它覆盖了整个软件生命周期。 1） 软件需求 2）软件设计 3）软件构造 4）软件测试 5）软件维护 6）软件配置管理 7）软件工程管理 8）软件工程过程 9）软件工程工具和方法 10）软件质量 软件工程和软件工程学科体系的关系总体上来说，软件工程是一个局部问题，而软件工程学科体系是一个整体问题。 软件工程研究的内容软件工程研究的内容主要有五个方面。 一是软件生命周期模型 二是软件开发方法 三是软件支持过程 四是软件管理过程 五是软件工程标准与规范 软件工程基本原理软件工程的三要素：方法、工具和过程 有7个基本原理，外加一个二八定律。具体内容见文章末尾的链接。 软件工程在行业中的作用软件工程作为一门工程管理学科，它对软件行业的作用毋庸置疑。那么，这里会有一个问题，既然已经有软件工程了，那么还会不会出现软件危机呢？我的答案是会的。软件工程的产生是为了克服软件危机，但是它的存在并不会完全消除软件危机。这和现实社会中法律存在的意义是相通的。法律的产生是为了消除犯罪，但是法律的存在并不会完全消除犯罪（至少在当前的社会阶段是不会的）。 软件工程可以作用到从业者，也可以作用到项目组，作用到软件公司，甚至作用到整个国家的软件产业1发展。 二、软件工程方法论和软件工程实践论1. 软件工程方法论是什么？软件工程方法论实质上是软件工程中软件开发方法的集合。 那么软件工程方法的集合包括哪些元素呢？ 2. 软件工程方法集合软件工程方法集合包括面向过程方法、面向对象方法、面向元数据方法。 3. 为什么说面向对象方法可以描述无穷的信息世界呢？要搞清楚面向对象为什么可以描述无穷的世界，首先需要知道面向对象方法是什么，其次，需要知道现实世界和软件的普遍联系。 面向对象方法是什么？是一种运用对象、类、消息传递、继承、封装、聚合、多态性等概念构造软件系统的软件开发方法。 我记得高中哲学里面听到的一句话，世界是物质的，物质是运动的，运动是有规律的。而对于软件而言，其实质是对现实人工系统的一种映射、优化和替换。通过对现实世界的分析，我们可以知道，世界是由对象组成的，对象之间时存在普遍联系的，而物质运动则说明了对象的功能。 面向方法是将这现实世界抽象映射为对象的手段。分析设计时由对象抽象出类，程序运行时由类还原到了对象。所以它能够描述无穷的信息世界。 4. 软件工程实践论是什么？软件工程实践论是研究在开发一个大型软件系统时，到底应该怎样选取合适的开发方法。 5. 软件工程实践论指什么？“五个面向”实践论，指面向流程分析、面向元数据设计、面向对象实现、面向功能测试、面向过程管理。 在后面，我们会发现软件工程的“五个面向”实践论在各个软件生命周期模型中都有一定的体现。 三、软件支持过程、软件管理过程 软件过程是什么？软件过程，指软件生命周期中的时间序列 软件支持过程是什么？软件支持过程，由支持软件生命周期模型各个阶段的生产工具组成。 软件生命周期中的生产工具有哪些？CASE工具、软件开发环境SDE、软件工程环境SEE 软件管理是什么？管理过程和支持过程又称为“软件过程工程”。它是软件工程的一部分。 软件管理实质上是过程管理。 软件管理有哪几类？ISO 9001质量管理和质量保证体系 CMMI软件能力成熟度模型 软件企业文化，包括微软企业文化，IBM企业文化，敏捷文化。]]></content>
      <categories>
        <category>软件工程</category>
      </categories>
      <tags>
        <tag>软件工程方法论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[指针，又见指针]]></title>
    <url>%2F2019%2F06%2F10%2F%E6%8C%87%E9%92%88%EF%BC%8C%E5%8F%88%E8%A7%81%E6%8C%87%E9%92%88%2F</url>
    <content type="text"><![CDATA[一、指针简介一般来说，指针是一个其数值为地址的变量（或更一般地说是一个数据对象）。正如char类型的变量用字符作为其数值，而int类型变量的数值是整数，指针变量的数值表示的是地址。 如果你将某个指针变量命名为ptr，就可以使用如下语句： 1ptr=&amp;pooh; //把pooh的地址赋给ptr 对于这个语句，我们称ptr指向pooh。ptr和&amp;pooh的区别在于前者是变量，后者是常量。ptr可以指向任何地方： 1ptr=&amp;bath; //令ptr指向bath 二、间接运算符假定ptr指向bath：ptr=&amp;bath 这时就可以使用间接运算符*（也称取值运算符）来获取bath中存放的数值。 1val=*ptr; //得到ptr指向的值 语句ptr=&amp;bath；以及语句val=*ptr；放在一起等同于下面的语句： 1val=bath; 下面进行举例： 123nurse=22;ptr=&amp;nurse; //指向nurse的指针val=*ptr; //将ptr指向的值赋给val 上述语句实现的功能是把数值22赋给变量val 三、指针声明例如：long和float两种类型的数值可能使用相同大小的存储空间，但是他们的数据存储方式完全不同，指针的声明形式如下： 123int *pi; //pi是指向一个整数变量的指针char *pc; //pc是指向一个字符变量的指针float *pf,*pg; //pf和pg是指向浮点变量的指针 类型标识符表明了被指向变量的类型，而表示该变量是一个指针。声明int * pi;的意思是pi是一个指针，而且pi是int类型的。 *和指针名之间地空格是可选的。通常程序员在声明中用空格，而在指向变量时将其省略。 pc所指向的值（*pc）是char类型的。而pc本身是什么类型的？ 我们将其描述为“指向char的指针”类型。pc的值是一个地址，在大多数系统中，它是由一个无符号整数表示。但是这并不表示可以把指针当做整数类型。一些处理整数的方法不能用来处理指针，反之亦然。例如，可以进行两整数相乘，而指针不能。因此指针的确是一种新的数据类型，而不是整数类型。 四、使用指针在函数间通信在下面的程序中，函数interchange（）只用了指针参数，我们将对该函数进行详细的讨论。 123456789101112131415161718#include&lt;stdio.h&gt;void interchange(int * u, int * v);int main(void)&#123; int x = 5, y = 10; printf("Originally x=%d and y= %d.\n", x, y); interchange(&amp;x, &amp;y); //向函数传送地址 printf("Now x= %d and y=%d.\n", x, y); return 0;&#125;void interchange(int * u, int * v)&#123; int temp; temp = *u;//temp得到u指向的值。 *u = *v; *v = temp;&#125; 下面我们分析以上程序的运行情况。首先，函数调用语句如下： 1interchange(&amp;x, &amp;y); //向函数传送地址 可以看出，函数传递的是x和y的地址而不是他们的值。这就意味着intechange（）函数原型声明和定义中的形式参数u和v将使用地址作为它们的值。因此他们应该声明为指针，由于x和y都是整数，所以u和v是指向整数的指针。其声明如下： 1void interchange(int * u, int * v); 接下来，函数体进行如下声明： 1int temp; 从而提供了所需要的临时变量。为了把x的值存在temp中，需要使用下面语句： 1temp = *u;//temp得到u指向的值。 注意，因为u的值是&amp;x，所以u指向x的地址，这就以意味着*u代表了x的值，而这正是我们需要的数值。 在示例程序中，我们用一个函数实现x和y的数值交换。首先函数使用x和y的地址作为参数，这使得它可以访问x和y变量。通过使用指针和运算符*，函数可以获得相应存储地址的数据，从而就可以改变这些数据。 在ANSI原型中可以省略变量名称。这样，函数原型可以按如下形式进行声明： 1void interchange (int * ,int *); 通常情况下，可以把关于变量的两类信息传递给一个函数，如果函数的调用形式为： 1function1(x); 这时传递的是x的值，但是如果使用下面这种函数调用形式： 1function2(&amp;x); 那么会把x的地址传递给函数。第一种调用形式要求函数定义部分必须包含一个和x具有相同数据类型的形式参数。如下所示： 1int function1(int num); 而第二种形式要求函数定义部分的形式参数必须是指向相应数据类型的指针： 1int function2(int *ptr); 使用函数进行数据计算等操作时，可以使用第一种调用形式。但是如果需要改变调用函数中的多个变量的值时，就需要使用第二种调用形式。 尽管interchange（）只使用局部变量，但是通过使用指针，该函数可以操作main（）中的变量的值。]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>指针</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[软件工程相关名词解释]]></title>
    <url>%2F2019%2F06%2F10%2F%E5%B7%A5%E7%A8%8B%E7%9B%B8%E5%85%B3%E5%90%8D%E8%AF%8D%E8%A7%A3%E9%87%8A-1%2F</url>
    <content type="text"><![CDATA[软件： 一般认为，程序是计算机为完成特定任务而执行的指令的有效集合。站在应用的角度可以通俗地理解为： 面向过程的程序=算法+数据结构 面向对象的程序=对象+消息 面向构件的程序=构件+构架 通常，软件有以下定义： 软件=程序+数据+文档 这里的“程序”，是对计算机任务的处理对象和处理规则的描述；这里的“文档”，是为了理解程序所需的详细描述性资料；这里的“数据”，主要是软件系统赖以运行的初始化数据。 软件的最新定义如下： 软件=知识+程序+数据+文档 定义中增加了“知识”。这里的“知识”,主要指各种各样的相关行业领域的专业知识。实际上，知识只是网络的外在表现，程序，数据，文档才是网络的内在实质。也就是说，知识是通过程序、数据、文档来实现的。 对这一定义的另外一种解释是，软件到底是什么呢？软件就是网络，网络就是知识，知识就是信息。站在网民的角度看，软件就是知识加信息。站在程序员角度看，软件就是程序加数据；站在软件管理者角度看，软件就是数据加文档。 网络是知识的载体，知识是网络的灵魂。 软件工程 软件工程是研究软件开发和管理的一门学科。 这里，以是强调开发。开发是软件工程的主体，开发是在规定的时间、按照规定的成本，开发出符合规定质量要求的软件。二是强调管理或过程管理。当然，开发中有管理，管理是为了更好地开发。所以开发和管理是一个问题的相辅相成的两个方面。许多软件项目的失败，不是在开发技术上出了问题，二是在管理过程上出了问题。所以在某种程度上说，对于一个软件企业，过程管理比开发技术更重要。三十强调工程。要将软件的开发（包括维护）当成一项工程，既要按照工程的办法去开发，又要按照工程的办法去管理。四是强调学科。时至今日，软件工程不止是一门课程，而是一个学科体系，即软件工程知识体系。 软件工程学科体系（swebok2004）： 软件工程作为一个学科体系，到21世纪初才初步形成。2001年4月18日，美国发布了软件工程知识体系指南SWEBOK（guide to the Software Engineering body of Knowledge）0.95版。2004年，软件工程学科体系的内容才基本确立，就在这一年，美国ACM和IEEE-CS联合制订了SWEBOK2004版，它将软件工程学科体系的知识划分为如下10个知识域： （1）软件需求：软件需求是真实世界中的问题而必须展示的特性。软件的需求知识域有7个子域：需求基础、需求过程、需求获取、需求分析、需求规格说明、需求确认、实践考虑。 （2）软件设计：软件设计既是定义一个系统的体系结构，组件，接口和其他特征的过程，又是这个过程的结果，软件设计知识域有6个子域：软件设计基础，软件设计关键问题，软件结构与体系结构，软件设计质量的分析与评价，软件设计符号，软件设计的策略与方法。 （3）软件构造：它指通过编码，验证，单元测试，集成测试和排错的组合，具体创建一个可以工作的，有意义的软件。其知识域有3个子域：软件构造基础，管理构造，实际考虑 （4）软件测试：它由在有限测试用例集合上，根据期望的行为对程序的行为进行的动态验证组成，测试用例是从实际上无限的执行域中适当选择出来的。软件测试知识域有5个子域：软件测试基础和测试级别，测试技术，需求分析，与测试相关的度量，测试过程。 （5）软件维护：软件一旦投入运行，就可能出现异常，运行环境可能发生改变，用户会提出新的需求。生命周期中的软件维护，从软件交付时开始。软件维护的知识域有4个子域：软件维护基础，软件维护的关键问题，维护过程，维护技术。 （6）软件配置管理：软件配置是为了系统地控制配置的变更，维护软件在整个系统生命周期中的完整性及可追踪性，而标志软件在不同时间点上的配置的学科。软件配置管理知识域有6个子域：软件配置管理过程管理，软件配置标志，软件配置控制，软件配置状态统计，软件配置审核，软件发行管理和交付。 （7）软件工程管理：进行软件工程的管理与度量，虽然度量是所有知识域的一个重要方面，但是这里所说的是度量程序的主体。软件工程管理只是域有6个子域：启动和范围定义，软件项目计划，软件项目实施，评审与评价，关闭，软件工程度量。前5个覆盖软件过程工程管理，第6个描述软件度量的程序。 （8）软件工程过程：涉及软件工程过程本身的定义、实现、评定、度量、管理、变更和改进。软件工程过程知识域有4个子域：过程实施与改变、过程定义、过程评定、过程和产品度量。 （9）软件工程工具和方法：它具有软件工程工具、软件工程方法两个子域。 （10）软件质量：处理跨域整个软件生命周期过程的软件质量的考虑，由于软件质量问题在软件工程中无处不在，其他知识领域也涉及到质量问题。软件质量知识域有3个子域：软件质量基础，软件质量过程、时间考虑。 在上述软件工程学科体系中前5个知识域是讲软件开发，后5个知识域是讲软件管理。由此可见，软件工程知识体系包括软件开发和软件管理两大部分，所以软件工程的定义也应该包括软件开发和软件管理两项内容。 软件工程课程 软件工程课程与软件工程学科体系是有区别的：前者是一门或一组课程，后者是一个知识体系；前者是一个局部问题，后者是一个整体问题。 作为一门软件工程客户才能，它研究的内容至今没有统一的说法。可以这么认为，软件工程课程研究的内容应该涵盖“软件生命周期模型、软件开发方法、软件支持过程、软件管理过程、软件工程标准与规范”这5个方面。 序号 研究方向 具体内容 1 软件生命周期模型 如：瀑布模型，增量模型 2 软件开发方法 如：面向过程的方法 3 软件支持过程 如：CASE工具ROSE，北大青鸟系统，Power Designer 4 软件管理过程 如：CMMI，软件企业文化，敏捷（XP）文化现象 5 软件工程标准与规范 如：命名标准与规范，设计标准与规范，编程标准与规范 尽管软件生命周期模型和软件支持过程非常重要，但是现代软件工程研究的重点，仍然是软件开发方法和软件管理过程。在软件管理过程的内容中，除了ISO9001的CMMI之外，还将软件企业文化也列入其中，如微软企业文化，敏捷文化现象和IBM企业文化。 软件工程标准是对软件产品的约束，如软件产品的界面标准，包装标准，文档标准，测试标准，评审标准，鉴定标准等。软件工程规范是对软件开发人员行为的约束，例如命名规范，需求规范，设计规范，编码规范，维护规范等。在软件企业内部，企业管理人员特别重视软件工程的标准与规范。为此，每个大型的软件企业，根据自身的特点，都制订并发布了自己的软件工程标准与规范，在自己企业内部严格执行。 软件工程基本原理 习惯上，人们常常把软件工程方法（开发方法）、工具（支持方法的工具）、过程（管理过程）称为软件工程三要素，而把美国著名的软件工程专家B.W Boehm于1983年提出的7条原理作为软件工程的基本原理。 （1） 用分阶段的生命周期计划严格管理软件开发。阶段划分为计划、分析、设计、编程、测试和运行维护。 （2） 坚持进行阶段评审。若上一阶段评审不通过，则不能进入下一阶段开发 （3） 实行严格的产品版本控制 （4） 采用现代程序设计技术 （5） 结果应能清楚地审查。因此，对文档要有严格的要求 （6） 开发小组的成员要少而精 （7） 要不断地改进软件工程实践的经验和技术，要与时俱进 上述7条原理，虽然是在面向过程设计时代（结构化时代）提出的，但是，直到今天，在面向元数据和面向对象的程序设计新时代，它仍有效。根据“与时俱进”的原则，还有一条基本原理在软件的开发和管理中特别重要，需要补充进去，作为软件工程的第8条基本原理。 （8） 二八定律 在软件工程中，所谓二八定律，就是一般人常常将20%的东西误认为80%的东西，而将80%的东西误认为是20%的东西。 例如，对软件项目进度和工作量的估计：一般人主观上认为已经完成了80%，但实际上只完成了20%；对于程序中存在问题的估计，：一般人不知道80%的问题存在于20%的程序之中；对模块功能的估计：一般人不知道20%的模块，实现了80%的功能；对人力资源的估计：一般人不知道20%的人，解决了程序中80%的问题；对投入资金的估计：一般人不知道信息系统中80%的问题，可以用20%的资金来解决。 研究二八定律的现实意义是，指导软件计划的制订与执行。 软件生命周期模型 软件生命周期模型时指在整个软件生命周期中，软件开发过程应该遵循的开发路线图。或者说，软件生命周期模型是软件开发全部过程、活动和任务的结构框架。 例如：瀑布模型、增量模型、螺旋模型、喷泉模型、XP模型、原型模型和RUP迭代模型，它们都有各自清晰的开发路线图，规定了各自的开发过程、活动和任务的结构框架。 从字面上理解，“软件生命周期”应该涵盖软件产品、项目或系统从产生、投入使用看到被淘汰的全过程。由于早期人们关注的是技术开发活动，还没有考虑到管理活动，因此“软件生命周期模型”主要描述的还是软件开发的过程及其任务。 与人不同的是，软件的生命周期和软件生命周期模型有关：不同的软件生命周期模型，可能对应着不同的生命周期。生命周期不同，该软件的开发阶段划分、评审次数、基线标准都有所不同。软件公司的项目组在开发一个大项目或产品时，首先在技术上必须选择一个软件生命周期模型，使该模型非常适合这个项目或产品的生命周期模型；随后通过对软件生命周期模型的裁剪，给出适用于本项目或产品的软件生命周期定义；以生命周期定义为标准，在需求定义之后，编制详细的软件开发计划；然后项目组按计划进行软件开发，软件工程管理部门按计划进行软件过程跟踪和管理。 软件生命周期模型能清晰、直观地表达软件开发全过程，明确规定了要完成的主要活动和任务，用来作为软件项目工作的基础。一般以时间为序，软件生命周期模型可详细地划分为9个阶段。 序号 周期名称 序号 周期名称 1 立项（或签合同）、下达任务书 6 软件测试 2 需求分析 7 软件发布与实施 3 概要设计 8 软件维护 4 详细设计 9 版本更新或退役 5 编码实现 软件开发方法是指在软件工程开发路线图中，开发人员对软件需求、设计、实现、维护所采用的开发思想开发技术、描述方法、支持工具等。 软件工程中软件开发方法的集合，称为软件工程方法论。 迭代模型及其9个核心流程 针对瀑布模型的缺陷，人们提出了迭代模型。 所谓迭代，是指活动的多次重复。从这个意义法伤来讲，原型不断完善，增量不断产生，都是迭代的过程。因此，快速原型法和增量模型都可以看成局部迭代模型。但这里所讲的迭代模型时RUP推出的一种“逐步求精”的面向对象的软件开发过程模型，被认为是软件界迄今为止最完善、可实现商品化的开发过程模型。 RUP模型的原型图看起来非常简单，其内涵却非常丰富。它表面上是一个二维图，实质上用一张二维图表示了一个多维空间模型。从宏观上看，它是一个大的迭代过程；横坐标表示软件产品所处的4个阶段：先启、精化、构建、产品化（移交），纵坐标表示软件产品在每个阶段的工作流程。从微观上看，任何一个阶段本身，其内部工作流程也是一个小的迭代过程。 为使项目能够顺利地进行，一种较灵活（并且风险更小）的方法是：多次执行各个开发工作流程，从饿了更好地理解需求，设计出更为强壮的软件架构，逐步提高开发组织能力，最终交付一系列逐步完善的实施成果，这就是迭代生命周期模型。每次按顺序完成一系列工作流程就称为一次迭代，每次迭代，均以次要里程碑结束，按照特定的迭代成功标准，对迭代的结果进行评估。每个阶段都可以进一步细分为迭代。迭代是产生可执行的产品发布（内部或外部的）的完整开发循环，所发布的产品是开发过程最终产品的子集，它将通过一次又一次的迭代实现递增成长，最后形成最终的软件系统或产品。 优点： n 在开发的早期或中期，用户需求可以变化； n 在迭代之初，不要求有一个相近的产品原型 n 模型的适用范围很广，几乎适用于所有项目的开发 缺点：传统的组织方法是按顺序（一次且仅一次）完成每个工作流程，即瀑布式生命模型。迭代模型采取循环工作方式，每次循环均使工作产品更靠近目标产品，这要求项目组成员具有很高的水平并掌握先进的开发工具。反之，存在较大的技术和技能风险。 模型的9个核心流程： 迭代声明周期模型包含9个核心流程（需要指出的，采用迭代模型，事先要有一个初始业务模型，以便进行迭代。这就是为什么将“业务建模”作为9个核心流程之首的道理）。 （1） 业务建模：目的是， 了解目标组织的结构和机制；了解目标组织中当前存在的问题，并确定改进的可能性；确保客户、最终用户和开发人员就目标组织达成共识；导出支持目标组织所需的系统需求。通俗地讲，业务建模就是用户业务流程的重新规划与合理改进，即业务流程的优化，目的是使开发出来的系统能反映最优化的业务流程。 （2） 需求获取：目的是，与客户在系统的工作内容方面达成并保持一致；使系统开发人员能够更清楚地了解系统需求；定义系统边界；为计划迭代的内容提供基础；为估算开发系统所需成本和时间提供基础；定义系统的用户界面，重点是用户的需要和目标。 （3） 分析设计：目的是，将需求转换为未来系统的设计；逐步开发强壮的系统构架；使设计适合实施环境，为提高性能而进行设计。 （4） 实施：目的是，对照实施子系统的分层结构定义代码结构；以构件（源文件，二进制文件，可执行文件以及其他文件等）方式实施类和对象；对已开发的构件按单元进行测试；将各实施成员（或团队）完成的结果集成到可执行系统中。 （5） 测试：目的是，核实对象之间的交互；核实软件的所有构件是否正确集成；核实所有需求是否已经正确实施；确定缺陷并确保在部署软件之前将缺陷解决。 （6） 部署：目的是，将构件部署到网络的各个节点上，使最终用户可以使用该软件产品。 （7） 配置与变更管理，目的是，始终保持工作产品的完整性和一致性 （8） 项目管理：目的是，为软件密集型项目的管理提供框架；为项目计划，人员配备，执行和检测提供实用准则；为风险管理提供框架。 （9） 环境：目的是，为软件开发组织提供软件开发环境（流程和工具），该环境将支持开发团队。 XP模型 XP模型，即极限编程模型，它本来是敏捷企业文化现象，但是不少人将它当成一种软件开发模型。 对传统软件开发模型进行重新审视发现，它们太正规、太呆板、太浪费资源，从而提出了省时省力的XP模型。它属于轻量级开发模型，由一组简单规则（需求、实现、重构、测试、发布）组成，它既保持开发人员的自由创造性，又保持对需求变动的适应性，即使在开发的后期，也不怕用户需求的变更。 在需求、实现、重构、测试、发布的迭代过程中，XP模型有4条核心原则：交流、简单、反馈和进取。XP开发小组包括开发人员、管理人员和客户。 优点： l 采用简单策略，不需要长时间计划和复杂管理，开发周期短 l 采用迭代增量开发，反馈修正和反复测试的方法，因而软件质量有保证。 l 适应用户需求变化，因而与用户关系和谐。 缺点： XP模型作为一种新的模型，在实际应用中还存在一些问题，引起了一些争议。它一般适用于小型项目，同时，它与ISO9001、CMMI的精神也存在冲突。 订单软件 与固定的用户签订软件开发合同，由软件公司启动该项目的开发，这类软件被称为“订单软件”，典型的例子有企业资源规划系统ERP和电子商务大型网站。 非订单软件 市场调研之后，认为某产品将会有巨大的市场空间，而软件公司在人力资源、设备资源、抵抗风险、资金和时间上都具备开发该产品的能力，于是决定立项，这类软件被称为“非订单软件”，典型的例子是网上游戏软件 任务书 有一份《任务书》的正文。包括任务下达的对象、内容、要求完成的日期、决定投入的资源、必要时包括任命项目经理（技术经理和产品经理）、其他保证措施、奖惩措施等。《任务书》正文可长可短，若《合同》或《立项建议书》很详细，则正文可短，若《合同》或《立项建议书》很粗很短，则正文应该很长、很详细。 有一份《任务书》的附件。一般情况下，它就是软件《合同》/《立项建议书》，如果是指令性计划，它的格式和内容，也应与《合同》/《立项建议书》基本相同，即附件的内容应覆盖系统的功能点列表、接口列表、资源需求列表、开发进度列表、阶段评审列表等。 《任务书》与《合同》/《立项建议书》一样重要，它是该项目的第二份管理文档。 合同 对于一些大型项目，在签订合同之前，一般有一个招标和投标的过程，只有中标之后才能签订合同。开发“非订单软件”需要“立项”，开发“订单软件”需要签订“合同”。所以“立项”与“合同”是IT企业软件项目（或产品）的两个源头。一旦立项或签订合同，企业领导或软件管理部门就要下达《任务书》，开发部门接到《任务书》后就要组建开发团队，成立项目组。 立项建议书 立项文档就是《立项建议书》，它本身不是软件策划的内容，但是很重要，也很特殊。《立项建议书》的目的，就是在某种程度上代替开发合同或用户需求报告，作为软件策划的基础。《立项建议书》的编制者一般不是软件开发人员，而是软件公司的市场销售人员，因为他们熟悉市场行情及客户需求 需求分析 1997年，IEEE软件工程标准词汇表中定义的需求为： （1） 用户解决问题或达到目标所需的条件或能力 （2） 系统或系统部件要满足合同、标准、规范或其他正式规定文档所具有的条件或能力 （3） 一般反映（1）或（2）所描述的条件或能力的文档说明 一般而言，需求分析阶段位于软件开发的前期，它的基本任务是准确地定义未来系统的目标，确定为了满足用户的需要系统必须做什么。 需求分析分为两个阶段：需求获取阶段和需求规约阶段。需求关系的是系统的目标而不是系统实现。 需求可以分为两类：功能性需求和非功能性需求。前者定义了系统做什么，后者定义了系统工作时的特性。 基线 基线是软件工作产品，它是要经内部和外部评审过的，是下一阶段工作的基础。 审计 审计，是复查评审活动程序的合法性，是否按程序与规范进行等 里程碑 里程碑是一个标记，只需要经过内部评审。一个里程碑是一个检查点，但不一定对应一条基线 定义软件过程 所谓定义软件过程，就是根据选定的生命周期模型，规定软件的开发1模型，以及每一阶段的工作步骤和文档标准等内容。 在项目策划阶段，先要根据项目特性，使用软件生命周期模型，对项目中将要进行的软件工程过程进行描述。根据项目自身的特点，对项目的类型进行详细划分，然后根据软件组织的“生命周期模型裁剪指南”，对标准软件过程进行裁剪，形成项目定义软件过程。再使用项目定义软件过程，指导项目策划活动的进行。 开发计划是对项目定义软件过程的具体描述。软件项目的规模、工作量、成本、进度、质量、人员配置和其他资源等，与项目定义软件过程中的活动紧密相关。由于项目定义软件过程的标准，全部由“生命周期模型裁剪指南”而得到，因此软件项目能共享过程数据，并且吸取软件组织中积累的经验教训。 LOC LOC（line of code），LOC指所有的可执行源代码行数。包括可交付的工作控制语言（job control language，JCL）语句，数据定义，数据类型声明，等价声明，输入/输出格式声明等。一代码行（1LOC）的价值和人月均代码行数可以体现一个软件生产组织的生产能力。组织可以根据对历史项目的审计来核算组织的单行代码价值。 功能模型 （Function Model, FM）。实质上是用户需求模型，用来描述系统能做什么，即对系统的功能，性能，接口和界面进行定义。 业务模型 （Operation Model，OM），实质上是业务逻辑模型，用于描述系统在何时，何地、由何角色、按什么业务规则去做，以及做的步骤或流程，即对系统的操作流程进行定义。 数据模型 （Data Model, DM）,实质上是实体或类的状态关系模型，用于描述系统工作前的数据来自何处，工作中的数据暂存在什么地方，工作后的数据放到何处，以及这些数据的状态以及相互之间的关联，即对系统的数据结构进行定义。 风险分析 软件策划过程，也包括对软件风险进行分析。所谓软件风险分析，指对项目及团队的政策风险、技术风险、技能风险、资源风险等因素，进行逐个分析与分解，将一个大风险分解为若干个小风险，对各个小风险进行排除，最后制订跟踪和监控风险的风险管理计划。软件一般存在5种风险，如下表： 序号 风险名称 风险内容 1 政策风险 IT企业外部和IT企业内部两个方面的政策及政策的变化，将会给项目带来什么风险 2 技术风险 新技术的成熟程度以及难度系数，将会给项目带来什么风险 3 技能风险 项目组成员学习、领会、掌握、运用新技术的能力，将会给项目带来什么风险 4 资源风险 保证项目正常进行所需的各种资源的供应程度，将会给项目带来什么风险 5 其他风险 目前意想不到的风险，即不可预测的风险，如天灾人祸 三层结构设计 三层结构设计通常被划分为表示层、中间层和数据层三层，各个分层之间通过对外接口互相访问。分层的主要目的是，允许各层可以随着需求的变化或技术的变化而独立地升级或替换，如当替换数据库时，只需要变化数据层。 所谓的三层结构，就是在原来两层结构（Client/Server）的客户层和数据层之间，加入一个中间层（也叫业务层），并将应用程序的业务规则、数据访问、合法型校验等工作放到了中间层进行处理，这样就变成了三层结构，也不仅仅有B/S应用才是三层结构，三层是指逻辑上的三层，即使这三层都放置到了一台机器上。当然，这三层也可以放在两台或三台机器上。 （1） 表示层（浏览层） 表示层也称为浏览层，它通常采用图形化用户界面，在客户端PC或工作站上运行。站在“三个模型”建模思想上看，系统内部支持表示层的模型是“功能模型”，尽管“功能模型”中的功能思想组件放在业务层，但是功能组件的表现方式却在表示层上。该层的主要功能是： ​ 1）接受用户请求，将这些请求反馈给业务逻辑层，等待业务逻辑层的应答信息 12） 对业务逻辑层的应答信息，进行显示（不进行任何加工） ​ 3） 有时也会兼做业务逻辑层的一些小功能，比如对用户输入数据的验证，以及操作合法性的检验 （2） 中间层（业务层） 中间层也称业务层，有时又称为应用层，它由许多构建或组件组成，它们完全体现了用户的业务逻辑或业务规则。站在“三个模型”建模思想看，系统内部支持业务层的模型是“业务模型”。尽管Java EE与.NET在实现业务层上的方法略有差异，但是，业务层本质上在表示层与数据层之间起桥梁作用。有时，业务层被划分为两个子层：业务逻辑层和数据访问层。业务层的主要功能是： ​ 1） 接受从表示层传来的用户请求信息 ​ 2） 根据用户的请求信息生成SQL语句 ​ 3） 利用生成的SQL语句从数据层取数据、修改数据、删除数据 ​ 4） 将结果返回给表示层 （3） 数据层 数据层是数据库服务器上的数据库层，它包括数据库管理系统DBMS和数据库DB两部分。站在“三个模型”建模思想看，系统内部支持数据层的模型是“数据模型”，该层的主要功能是： ​ 1）接受业务层数据处理请求的SQL语句或存储过程 ​ 2） 利用SQL语句或存储过程，对数据库服务器上数据库的相关表进行存储或检索 ​ 3） 将存储或检索的结果信息，传递给业务层 构件 所谓构件，就是被标识的且可被复用的软件制品。 构件与部件，组件基本上是一个意思，有时会认为部件和组件的粒度比构件大一些或范围更广一些。上述定义有三个特点：第一个特点是构件要被明确标识，即有一个被调用的名字；第二个特点是应该可服用，不可复用的只能称为模块或子系统，第三个特点是构件是软件制品，在宏观上软件制品可以是项目计划、成本估价、体系结构、需求模型、设计模型、程序代码、窗口界面、文档、数据结构、测试用例等。 中间件 中间件是一个非常大的组件（构件），一般在网络上运行，完成批量数据的传递和通信工作，调用方式是通过一组事先约定的格式与参数进行的。常见的中间件为问价传输中间件，如IBM公司的消息队列中间件MQ，在网络节点之间进行点对点的数据通信和传输。又如城市医疗保险系统中的中间件，它在市医保局节点和全市各家医院节点之间，进行点对点的数据通信和传输，病号每次划价计费，节点之间就交换一次信息。在详细设计说明书中已对新增中间件的功能和算法进行了详述，此处只要将详细设计翻译为源程序即可。 结对编程 在敏捷方法中，成对（或结对）编程时极限编程的实践之一。当进行成对编程时每一个程序员输入代码，另一个在旁边观察代码中是否存在错误，并思考下一步要进行的工作。 优点： 1） 可以提高代码的可读性和可理解性，产生高质量的代码 2） 提高编程效率，使编程速度更快，代码错误更少，后期测试和纠错的工作量就会大大降低 3） 成对编程可以提高开发团队的凝聚力和协作精神 规则： 1） 编码标准 2） 积极参与 3） 非强制性 4） 定期轮换 5） 速度匹配 6） 新老匹配 软件测试 软件测试按照规定的测试规程发现软件缺陷的问题。 为了理解这个定义，有如下解释： 1） 软件测试是一个过程，而且是一个发现软件缺陷，但不包括修复软件缺陷的过程。 2) 软件测试是按照规定的测试规程进行。这些规程包括制定测试计划，搭建测试环境，明确测试任务，规定测试时间、方法和步骤，记录测试数据和产生测试报告 3) 在测试规程中，测试计划最为重要，它指导整个测试计划 4) 在测试计划中，测试需求的定义很重要。如果没有列出明确的测试需求，那么就并不会设计出正确的测试用例，最后必然导致盲目的测试。这样，隐藏的软件缺陷也无法被发现。 5) 软件测试的目的是发现软件缺陷，软件测试的目标是尽可能早地发现软件缺陷，因为缺陷发现越早，其修复成本越低。 软件测试不仅仅局限于测试程序代码，还可以测试软件数据与软件文档。也就是说，软件生命周期中所产生的软件工作产品，都可以作为测试对象，因为它们影响最终软件产品的质量。 软件缺陷 定义如下： 软件未实现产品说明书要求的功能。 软件出现产品说明书指明不应该出现的错误 软件实现了产品说明书未说明的功能 软件未实现产品说明书虽未明确提及但应该实现的目标 软件难以理解，不易使用，运行速度慢，或者软件测员，最终用户认为软件不好。 由于不同的理解方式和中英文翻译问题，软件缺陷的说法很多，如错误、失效、失败等，本书中统称为软件缺陷（bug）。实际测试中，将软件缺陷定义为不同级别，代表不同程度的软件缺陷。 随着软件定义的变化，软件缺陷的定义也应随之更新。软件缺陷不仅仅局限于软件代码，还包括文档缺陷（不符合规范或者不详细，有错误和歧义等）、测试缺陷（测试不充分，或测试方法本身的局限）、过程缺陷（软件生命周期的流程问题造成的产品质量问题）和管理缺陷（由于管理本身不到位导致的产品质量问题）。 软件测试的V模型 早期的软件测试V模型 模型的左侧是开发阶段，右侧是测试阶段。开发阶段从了解并定义软件需求开始，然后要把需求转换到概要设计和详细设计，最后形成程序代码。测试阶段是在代码编写完成之后，先做单元测试，然后做集成测试、系统测试和验收测试。 单元测试：主要检测代码的编写是否符合详细设计中单个模块或组件的要求 集成测试：主要检测此前测试过的单个模块或组件，能否正确地集成到系统，与其他模块一起运行，是否符合概要设计和详细设计说明书的要求。 系统测试：以集成后的完整系统作为测试对象，主要检测其是否符合需求说明书、概要设计说明书和详细设计说明书的要求。 验收测试：主要检测软件产品是否符合用户需求，用户合同和需求说明书中的要求，需要得到用户认可并签字确认。 改进后的V模型： 改进后的V模型，一是加入软件测试分析和测试设计阶段，二是体现“尽早”思想。改进后的V模型，形成了一个没有软件开发过程的、单独的软件测试V模型。它的左边是软件测试需求分析和测试设计，右边是软件测试执行。虽然测试执行过程同样集中在软件编码之后，但是测试需求分析和测试设计已经提前，一直提前到与开发阶段并行开展。一方面可以为后期的测试执行过程做计划和准备，另一方面可以对软件的阶段性产品（软件工作产品）进行测试。前期的软件工作产品主要是文档，如测试需求分析阶段，就是测试软件需求分析过程的工作产品《需求规格说明书》，进而提炼出测试需求。 黑盒测试 黑盒测试又称为不透明盒测试，它给我们的更多启示是它的思考方式，即不考虑（主观上屏蔽）或者不需要（客观条件限制）知道被测对象的内部实现细节，只关心输入输出。在运用黑盒测试方法进行软件测试时，它并不关心软件的内部逻辑结构和实现方法，而是站在使用者的角度，主要测试软件的功能指标，即测试系统的功能模型。黑盒测试的依据是软件的行为描述，是面向功能的穷举输入测试。从理论上讲，只有把所有可能的行为都作为测试用例输入，才能完成黑盒测试工作。黑盒测试的对象可以是软件单元、软件模块、软件组件、软件子系统和软件系统，也可以是发散思维到软件文档，软件管理文档等软件生命周期中的任何可测试对象。 黑盒测试用例设计方法： （1） 等价类划分法 （2） 边界值分析法 （3） 错误推测法 （4） 因果图分析法 （5） 场景分析法 白盒测试 白盒测试又称为透明盒测试，要求测试人员必须清楚被测对象的内部实现细节。白盒测试方法的测定依据是《详细设计说明书》。理论上讲，面向程序执行路径进行穷举代码测试，直至覆盖所有路径，才算完成了白盒测试。白盒测试的测试对象，侧重于软件单元，模块和构件等小规模对象，绝对不适合软件项目或产品的等大规模测试对象。 实用的白盒测试覆盖技术有4种，即语句覆盖，条件覆盖，分支覆盖和组合覆盖。覆盖的主要思想，是从不同角度尽可能提高代码的测试覆盖率。为了减少测试工作量，应该使每一个测试用例满足多个覆盖条件。 等价类 等价类划分的具体做法是：把所有可能的输入数据，即软件的输入域，划分成若干部分（子集），使每部分内的数据都是等效的（对于软件而言，等效可以理解为对数据的处理过程以及处理结果都完全一致），然后从每一个子集中选取少数具有代表性的数据，作为测试用例。 每一个等价类又可以划分为两种不同类别：有效等价类和无效等价类。 边界值 边界值分析方法是对等价类划分方法的补充。 测试工作者已经总结出经验：大量的错误常常发生在输入或输出范围的边界上，因此针对各种边界情况设计测试用例，可以查出更多的错误。 使用边界值分析方法设计测试用例使，首先参考等价类划分法确定边界情况，除了在等价类中选取典型代表数据外，通常还要着重测试边界值情况，应当选取正好等于、刚刚大于、或刚刚小于边界的值作为测试数据。 测试需求 它指软件测试员站在与用户相同角度上理解的需求，主要是确保需求的可测试性。同时找出软件需求和用户需求的偏差，并确保认可的偏差修改后体现在软件需求中，因为测试工作以《软件需求说明书》为基准，测试人员需要尽量保证《软件需求说明书》可以满足测试工作。 Bug 即软件缺陷，如错误，失效，失败等。 CMMI 软件能力成熟度模型CMMI，是由美国卡内基-梅隆大学软件工程研究所退出的评估软件能力与成熟度等级的一套标准。该标准基于众多软件专家的实践经验，侧重于软件开发过程管理能力的提高，是软件生产过程改进的标准和软件企业成熟度等级评估的标准。由于该标准不涉及具体的软件开发方法和技术，所以它具有广泛性、通用性和持久性。 CMMI的作用：概括地讲，过程能力成熟度模型集成CMMI的作用，主要是软件组织的能力评估和过程改进，它的应用领域具体体现在三个方面： 软件组织，用它来不断改进自身的软件过程管理能力 评估机构，用它来评估某软件组织当前软件能力成熟度级别 客户，用它来评价某承包商（软件外包商）的软件能力 CMMI的实质： 为了真正达到持续改进软件过程能力的目的，并以尽量低的成本获得高的效益，首先要弄清楚“过程”、“项目”、“组织”、“度量”等五个基本概念。 以“过程”为核心，抓软件组织的管理，即软件“组织”的过程改进 以“项目”为手段，抓团队开发过程的“活动”，即落实过程改进的措施 以“活动”记录为基础，抓软件过程的“度量”，即“度量”软件组织改进的情况 软件配置管理 软件配置管理SCM，是对软件开发过程中配置项的一组追踪和控制活动，它开始于软件开发之初，结束于软件淘汰之时。软件配置管理在软件过程管理中，占有特殊得到地位，也是项目管理的重要内容。无论是ISO9001、CMMI，还是软件企业文化，都非常强调配置管理。在大中型软件企业内部设置专职的配置管理员，在各个项目组内部设置兼职的配置管理员，引进配置管理电子工具，开展配置管理的日常工作。 CMMI阶段的成熟度等级 阶段模型的5个等级，称为成熟度等级ML，从ML1级到ML5级。 CMMI的等级 PA数目 管理特点 ML1:Initial（初始级） 0 过程不可预测且缺乏控制 ML2：Managed（已管理级） 7 过程为项目服务，即项目级管理 ML3：Defined（以定义级） 11 过程为组织服务，即组织级管理 ML4:Quantitatively Managed(定量管理级) 2 过程已度量和控制，即定量级管理 ML5：Optimizing（优化级） 2 集中于过程改进，即优化级管理 极限编程 极限编程（即XP）是一个周密而严谨的软件开发流程。XP从4个基本方面对软件项目进行改善：交流、简单、反馈和进取。 XP程序员与客户交流、与同事交流； 他们的设计简单而干净； 他们通过测试来得到反馈； 他们根据变化修改代码，并争取尽可能早地将软件交付给客户。 在此基础上，XP程序员能够勇于面对需求变化和技术变化，“船小好调头”，对需求变化和技术变化做出敏捷反应，把那个取得成功，是敏捷文化的特色和本质。 软件质量管理的三大支柱 软件质量保证SQA是一个过程，是CMMI和ISO9001的重要议题，是微软公司和IBM公司的重点课题，同样也是项目管理的重要内容。 软件质量：是供方提供的软件产品满足用户明确和隐含需求的能力特性的总和。 通常，人们将“质量标准”、“配置管理”、“质量测试”作为质量管理的三大支柱。 而将”SQA计划”、“SQA进度”、“SQA评审和审计”作为质量管理三大要素。 软件质量保证是一个质量管理过程，基本思想是“以事先预防为主，以事后纠偏为辅”，采取标本兼治的方法。]]></content>
      <categories>
        <category>软件工程</category>
      </categories>
      <tags>
        <tag>软件工程名词解释</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机网络体系结构]]></title>
    <url>%2F2019%2F06%2F10%2F%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%2F</url>
    <content type="text"><![CDATA[一、计算机网络分层结构两个系统中实体间的通信是一个很复杂的过程，为了降低协议设计和调试过程的复杂性，也为了便于对网络进行研究、实现和维护，促进标准化工作，通常对及时算计网络的体系结构以分层的形式进行建模。 我们将计算机网络的各层及其协议的集合称为网络的体系结构。 网络设计者以分层的方式组织协议以及实现这些协议的网络硬件和软件，每个协议就属于这些层次之一。某层向它的上一层提供服务，即所谓每一层的服务模型。例如，第n层提供的服务可能包括报文从网络的一边到另一边的可靠传送。这可能是通过使用第n-1层的边缘到边缘的不可靠报文传送，加上第n层的检测和重传丢失报文的功能来实现的。 计算机网络的体系结构通常都具有可分层的特性，它将复杂的大系统分为若干个较容易实现的层次。分层的基本原则如下： 每次都实现一种相对独立的功能，降低大系统的复杂度 各层之间界面自然清晰，易于理解，相互交流尽可能少 各层功能的精确定义独立于具体的实现方法，可以采用合适的技术来实现 整个分层结构应该促进标准化工作 在计算机网路的分层结构中，第n层中的活动元素通常被称为n层实体。具体来说，实体指任何可发送或接受信息的硬件或软件进程，通常是一个特定的软件模块。不同机器上的同一层称为对等层，同一层的实体称为对等实体。 在计算机网络体系结构的各个层次中，每个报文都分为两部分：一是数据部分，即SDU；二是控制信息部分，即PCI，它们共同组成PDU。 服务数据单元（SDU）：为完成用户所要求的功能而应传送的是数据。第n层的服务数据单元记为n-SDU。 协议控制信息（PCI）：控制协议操作的信息。第n层的协议控制信息记为n-PCI。 协议数据单元（PDU）：对等层次之间传送的数据单位称为该层的PDU。第n层的协议数据记为n-PDU。在实际的网络中，每层的协议数据单元都有一个通俗的名称，如物理层的PDU称为比特，链路层的PDU称为帧，网络层的PDU称为分组，传输层的PDU称为报文。 在各层间传输数据时，把从第n+1层收到的PDU作为第n层的SDU，加上第n层的PCI，变成了第n层的PDU，交给第n-1层后作为SDU发送，接收方接收时做相反处理。故可知三者的关系是n-SDU+n-PCI=n-PDU=(n-1)-SDU. 二、协议、接口、服务 协议 协议，就是规则的集合。在网络中要做到有条不紊地交换数据，就必须遵循一些事先约定好的规则，这些规则明规定了所交换的数据的格式及有关的同步问题。这些为进行网络中的数据交换而建立的规则、标准或约定称为网络协议。它是控制两个（或多个）对等实体进行通信的规则的集合，是水平的。不对等的实体之间没有协议。 接口 接口是同一结点内相邻两层之间交换信息的连接点，是一个系统内部的规定。每层只能为紧邻的层次之间定义接口，不能跨层定义接口。在典型的接口上，同一结点相邻两层的实体通过服务访问点（SAP）进行交互。服务是通过SAP提供给上层使用的，第n层的SAP就是第n+1层可以访问第n层服务的地方。 服务 服务是指下层为紧邻的上层提供的功能调用，它是垂直的。 上层使用下层所提供的服务时必须与下层交换一些命令，这些命令在OSI中称为服务原语。OSI将原语划分为4类：1）请求：由服务用户发往服务提供者，请求完成某项工作 2）指示：由服务提供者发往服务用户，提示用户做某件事 3）相应：由服务用户发往服务提供者，作为对指示的响应 4）证实：由服务提供者发往服务用户，作为对请求的证实 并非在一层内完成的全部功能都称为服务，只有那些能够被高一层实体“看得见”的功能才称为服务。 计算机网络提供的服务可按以下三种方式分类： （1）面向连接服务于无连接服务 在面向连接服务中，通信前双方必须先建立连接，分配相应的资源，以保证通信能正常进行，传输结束后释放连接和所占用的资源。因此这种服务可分为建立连接、数据传输和释放连接三个阶段。TCP就是一种面向连接服务的协议。 在无连接服务中，通信前双方不需要先建立连接，需要发送数据时可直接发送，把每个带有目的地址的包传送到线路上，由系统选定路线进行传输。这是一种不可靠的服务，这种服务常被描述为“尽最大可能交付”，它不能保证通信的可靠性。例如IP、UDP就是一种无连接服务的协议。 （2）可靠服务与不可靠服务 可靠服务是网络具有检错、纠错、应答机制，能保证数据正确、可靠地传送到目的地。 不可靠服务是指网络只是尽量正确、可靠地传送，而不能保证数据正确、可靠地传送到目的地，是一种尽力而为的服务。 （3）有应答服务和无应答服务 有应答服务是指接收方在收到数据后向发送方给出相应的应答，该应答由传输系统同内部自动实现，而不由用户实现。所发送的应答既可以是可乐定应答，也可以是否定应答，通常在接收到数据有错误时发送否定应答。文件传输服务就是一种有应答服务。 无应答服务是指接收方收到数据后不自动给出应答。若需要应答，则由高层实现。例如，对于WWW服务，客户端收到服务器发送的页面文件不给出应答。 三、ISO/OSI参考模型和TCP/IP模型 OSI参考模型 国际标准化组织（ISO）提出的网络体系结构模型，称为开放系统互联参考模型。通常简称为OSI模型。OSI有7层，自下而上依次是物理层、数据链路层、网络层、传输层、会话层、表示层、应用层。 低三层称为通信子网，它是为了联网而附加的通信设备，完成数据的传输功能；高三层统称为资源子网，它相当于计算机系统，完成数据的处理等功能。 1）物理层 物理层的传输单位是比特，任务是透明的传输比特流，功能是在物理媒体上为数据端设备透明地提供传输原始比特流。 物理层主要定义数据终端设备(DTE)和数据通信设备（DCE）的物理与逻辑连接方法，所以物理层协议也称为物理层接口标准，也称为规程。 2）数据链路层 数据链路层的传输单位是帧，任务是将网络层传来的IP数据报组装成帧。数据链路层的功能可以概括为成帧、差错控制、流量控制和传输管理。 典型的数据链路层协议有SDLC、HDLC、PPP、STP和帧中继等。 3）网络层 网络层的传输单位是数据报，它关心的是通信子网的运行控制，主要任务是把网络层的协议数据单元（分组）从源端传送到目的端，为分组交换网上的不同主机提供通信服务。关键问题是对分组进行路由选择，并实现流量控制、拥塞控制、差错控制和网际互联等功能。 网络层的协议有IP、IPX、ICMP、IGMP、ARP 、RARP、OSPF等 4）传输层 传输层也称为运输层，传输大单位是报文段（TCP）或用户数据报（UDP），传输层负责主机中两个进程之间的通信，功能是为端到端连接提供可靠的传输服务，为端到端连接提供流量控制、差错控制、服务质量、数据传输管理等服务。 数据链路层提供的是点对点的通信，传输层提供的是端到端的通信。 传输层的协议有TCP、UDP 5）会话层 会话层允许不同的主机上的各个进程之间进行通信。会话层利用传输层提供的端到端的服务向表示层提供它的增值服务。这种服务主要为表示层实体或用户进程建立连接并在连接上有序地传输数据，这就是会话，也称为建立同步(SYN)。 会话层负责管理主机间的会话进程，包括建立、管理及终止进程间的会话。会话层可以使用校验点使通信会话在通信失效时从校验点继续恢复通信，实现数据同步。 6）表示层 表示层主要用于处理在两个通信系统中交换信息的表示形式。不同机器采用的编码和表示方法不同，使用的数据结构也不同。为了使不同表示方法的数据和信息之间能互相交流，表示层采用抽象的标准方法定义数据结构，并采用标准的编码形式。数据压缩、加密和解密也是表示层可提供的数据表示交换功能。 7）应用层 应用层是OIS模型的最高层，是用户与网络的界面。应用层为特定类型的网络应用提供访问OSI环境的手段。因为用户的实际应用多种多样，这就要求应用层采用不同的应用协议来解决不同类型的应用要求，因此应用层是最复杂的一层，使用的协议也最多。 典型的应用层协议有用于文件传输的FTP、用于电子邮件的SMTP、用于万维网的HTTP等。 TCP/IP模型 TCP/IP模型从低到高依次是网络接口层（对应OSI参考模型中的物理层和数据链路层）、网际层、传输层和应用层（对应OSI模型的会话层、表示层、应用层）。 1）网络接口层 网络接口层的功能类似于OSI的物理层和数据链路层。它表示与物理网络的接口，但实际上TCP/IP本身并未真正描述这一部分，只是指出主机必须使用某种协议和网络连接，以便在其上传递IP分组。 2）网际层 网际层（主机-主机）是TCP/IP体系结构的关键部分。它和OSI网络层在功能上是非常相似的。网际层将分组发往任何网络，并为之独立地选择合适的路由，但它不保证各个分组有序地到达，各个分组的有序交付由高层负责。 3）传输层 传输层（应用-应用或进程-进程）的功能同样与OSI中的传输层类似，使得发送端和目的端主机的对等实体进行会话。传输层主要使用以下两种协议：（1） 传输控制协议（Transmission Control Protocol，TCP）。它是面向连接的，数据传输的单位是报文段，能够提供可靠的交付。 （2）用户数据报协议（User Datagram Protocol，UDP）。它是无连接的，数据传输的单位是用户数据报，不能保证提供可靠的交付，只能提供“尽最大努力交付”。 4）应用层（用户-用户）包含所有的高层协议。IP协议是因特网中的核心协议；TCP/IP可以为各种各样的应用提供服务，同时TCP/IP也允许在由各种网络构成的互联网上运行。 TCP/IP模型与OSI模型的比较 1）二者都采用分层的体系结构，分层的功能也大体相似 2）二者都基于独立的协议栈概念 3）二者都可以解决异构网络的互联，实现世界上不同厂家生产的计算机之间的通信 4）OSI模型最大的贡献是精确地定义了三个主要的概念：服务，协议和接口，与现代的面向对象程序设计思想非常吻合。而TCP/IP模型在这三个概念上却没有明确区分，不符合软件工程的思想 5）OSI模型产生在协议之前，没有偏向于任何特定的协议，通用性良好。TCP/IP模型产生于协议之后，实际是对协议的描述 6）TCP/IP在设计之初就考虑了多种异构网的互联问题，并将网际协议（IP）作为一个单独的重要层次。OSI模型最初只考虑到用一种标准的公用数据网络将不同的系统互联。OSI模型认识到网际协议IP的重要性后，只好在网络层中划分出一个子层来完成类似于TCP/IP模型中的IP功能 7）OSI模型在网络层支持无连接和面向连接的通信，但在传输层仅有面向连接的通信。而TCP/IP模型认为可靠性是端到端的问题，因此它在网际层仅有一种无连接的通信模式，但传输层支持无连接和面向连接两种模式。]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>网络体系结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[通信基础]]></title>
    <url>%2F2019%2F06%2F10%2F%E9%80%9A%E4%BF%A1%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[写在前面 物理层协议的主要任务就是确定与传输媒体的接口有关的一些特性，如下所述： 机械特性：指明接口所用接线器的形状和尺寸、引脚数目和排列、固定和锁定装置等。 电气特性：指明在接口电缆的各条线上出现的电压范围1. 功能特性：指明某条线上出现的某一电平代表何种意义。 过程特性：指明对于不同功能的各种可能事件的出现顺序。 一、数据通信的模型一个数据通信系统可划分为三大部分，即源系统（或发送端，发送方）、传输系统（或传输网络）和目的系统（或接收方、接收端）。 源系统一般包括两部分： 源点：源点设备产生要传输的数据。 发送器：通常源点生成的数字比特流要通过发送器编码之后才能在传输系统中进行传输。 目的系统一般包括两部分： 接收器：接收传输系统传送过来的信号，并把它转换为能够被目的设备处理的信息。 终点：终点设备从接收器获取传送来的数字比特流，然后进行信息输出。终点又称为目的站或信宿。 在源系统和目的系统之间的传输系统可以是简单的传输线路，也可以是连接在源系统和目的系统之间的复杂网络系统。 通信的目的是传送消息。 数据是消息的实体。 信号是数据的电器或电磁表现。根据信号中代表的消息的参数的取值方式不同，信号可分为两类： 模拟信号（或连续信号）——消息的参数的取值时连续的 数字信号（或离散信号）——消息的参数的取值时离散的。在使用时间域的波形表示数字信号时，代表不同离散数值的基本波形就称为码元。在使用二进制编码时，只有两种不同的码元，一种代表0状态，另一种代表1状态。 速率、波特与带宽 速率也称为数据率，指的是数据的传输速率，表示单位之间内传输的数据量。可以用码元传输速率和信息传输速率表示。 码元传输速率。又称码元速率，波形速率等，它表示单位时间内数字通信系统所传输的码元个数，单位是波特（Baud）。1波特表示数字通信系统每秒传输一个码元。这里的码元可以是多进制的，也可以是二进制的，但码元速率与进制数无关。 信息传输速率。又称信息速率，比特率等。它表示单位时间内数字通信系统传输的二进制码元数（即比特数），单位是比特/秒（b/s). 二、编码与调制 常用编码方式 要利用信道传输数据，必须将数据转换为能在传输媒体媒体上传送的信号。信道可以分为传送模拟信号的模拟信道和传送数字信号的数字信道两大类。 将数字数据转换为数字信号的过程称为编码。 将数字信号转换为模拟信号的过程称为调制。 归零制：正脉冲代表1，负脉冲代表0； 不归零制：正电平代表1，负电平代表0； 曼彻斯特编码：位周期中心的是上跳变代表0，位周期中心的下跳变代表1； 差分曼彻斯特编码：在每一位的中心处始终有跳变。位开始边界有跳变代表0，而位边界没有跳变代表1； 基本的调制方法 矩形脉冲波形的数字信号包含从直流开始的低频分量，被称为基带信号 在数字信道上直接传输基带信号的方法称为基带传输 基带信号往往包含较多的低频成分，甚至直流成分。而许多模拟信道仅能通过某一频率范围的信号，不能直接传输这种基带信号。因此必须对基带信号进行调制，使它能够在模拟信道中传输。 在很多情况下，需要使用载波进行调制，把基带信号的频率范围搬移到较高的频段以便在信道中传输。经过载波调制后的信号称为带通信号，而使用载波的调制称为带通调制。 最基本的带通调制的方法有：1）调幅（AM），即载波的增幅随基带数字信号而变化。 2）调频（FM），即载波的频率随着基带数字信号的变化而变化。 3）调相（PM），即载波的初始相位随基带数字信号而变化。 在数字通信中，调幅、调频和调相相应地称为幅移键控、频移键控和相移键控。实现调制和解调功能的设备称为调制解调器。 三、奈奎斯特定理与香农定理 奈奎斯特定理 奈奎斯特定理又称奈氏准则。它指出在理想低通（没有噪声、带宽有限）的信道中，极限码元速率为2W波特，其中W是理想低通信道的带宽，单位是Hz。若用V表示每个码元离散电平的数目（码元的离散电平数目是指有多少种不同的码元，比如有16种不同的码元，则需要有4位二进制位，因此数据传输率是码元传输率的4倍），则极限速率为 ​ 理想低通信道下的极限数据传输率=$2Wlog_2V$（单位为b/s) 对于奈氏准则，可以得出以下结论： 1）在任何信道中，码元传输的速率是有上限的。若传输速率超过此上限，就会出现严重的码间串扰问题，使得接收端不可能完全正确地识别码元。 2）信道的频带越宽(即通过的信号高频分量越多)，就可用更高的速率进行码元的有效传输。 3）奈氏准则给出了码元传输速率的限制，但是并未对信息传输速率给出限制，即未对一个码元可以对应多少个二进制位给出限制。 由于码元的传输速率受奈氏准则的制约，所以要提高数据的传输速率，就必须设法使每个码元携带更多个比特的信息量，此时就需要多元制的调制方法。 香农定理 香农定理给出了带宽受限且有高斯白噪声干扰的信道的极限数据传输率，当用此速率进行传输时，可以做到不产生误差。香农定理定义为： ​ 信道的极限数据传输率=$Wlog_2(1+S/N)$ 单位为b/s 式中，W为信道带宽，S为信道所传输信号的平均功率，N为信道内部的高斯噪声功率，$S/N$为信噪比，即信号的平均功率与噪声的平均功率之比。 对于香农定理，可以得出以下的结论：1）信道的带宽或信道中的信噪比越大，信息的极限传输速率越高。 2）对一定的传输带宽和一定的信噪比，信息传输速率的上限是确定的。 3）只要信息的传输速率低于信道的极限传输速率，就能找到某种方法来实现无差错的传输。 4）香农定理得出的是极限信息传输速率，实际信道能达到的传输速率比它低不少。 从香农定理可以看出，若信道带宽W或信噪比S/N没有上限，则信道的极限信息传输速率也没有上限。 奈氏准则只考虑了带宽与极限码元速率的关系，而香农定义不仅考虑了带宽，而且考虑到了信噪比。这从另一个侧面表明，一个码元对应的二进制位数是有限的。 四、传输方式 并行传输与串行传输 并行传输，是指一次发送n个比特而不是一个比特，为此，在发送端和接收端之间需要有n条传输线路。 串行传输，是指数据是一个比特一个比特发送的，为此，发送端和接收端之间只需要一条传输线路。 异步传输与同步传输 异步传输以字节为独立的传输单位，字节之间的时间间隔不是固定的，接收端仅在每个字节的起始处对字节内的比特实现同步。为此，通常需要在每个字节前后分别加上起始位和结束位，这里的异步是指在字节级上的异步，但是字节中的每个比特仍然要同步，它们的持续时间是相同的。 采用同步传输方式时，数据块以稳定的比特流形式传输，字节之间没有间隔，也没有起始位和结束位。由于不同设备的时钟频率存在一定差异，为避免在传输大量数据的过程中累积误差所导致的错误，要采取技术使得收发双方的时钟保持同步。实现收发双方时钟同步的方法有两种，即外同步和内同步。 外同步，是在发送端和接收端之间提供一条单独的时钟线，发送端在发送数据信号的同时，另外发送一条时钟同步信号。接收端根据接收到的时钟同步信号来校正时间基准，实现收发双方之间的同步。 内同步，是发送端将时钟同步信号编码到发送数据中一起传输，如曼彻斯特编码与差分曼彻斯特编码都含有时钟编码，具有自同步能力。 单工、半双工、全双工 1）单向通信，又称为单工通信，即只能有一个方向的通信而没有反方向的交互。如广播等。 2）双向交替通信，又称半双工通信，即通信的双方都可以发送信息，但不能双方同时发送。这种通信方式是一方发送另一方接收，过一段时间再反回来。 3）双向同时通信，又称为全双工通信，即通信的双方可以同时发送和接收信息。]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>通信</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机网络概述]]></title>
    <url>%2F2019%2F06%2F10%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%A6%82%E8%BF%B0%2F</url>
    <content type="text"><![CDATA[写在前面一般认为，计算机网路是一个将分散的、具有独立功能的计算机系统，通过通信设备与线路连接在一起，由功能完善的软件实现资源共享和信息传递的系统。简言之，计算机网络就是一些互联的、自治的计算机系统的集合。 一、计算机网络在计算机的不同发展阶段，网络有不同的定义，这些定义反映了当时网络技术的发展水平。分为三类： 广义观点 广义观点认为，只要是能实现远程信息处理的系统或能进一步达到资源共享的系统，，都是计算机网络。 资源共享观点 资源共享观点认为，计算机网络是“以能够相互共享资源的方式互联起来的自治计算机系统的集合”。这个定义符合目前计算机网络的基本特征。 用户透明性观点 这种观点认为，存在一个能为用户自动管理资源的网络操作系统。它能够调用用户所需要的资源，而整个网络就像是一个大的计算机系统一样对用户是透明的。用户透明性观点的定义描述了一个分布式系统，它是网络未来发展追求的目标。 二、计算机网络的组成从不同的角度，可以将计算机网路的组成分为以下几类： 从组成部分上来看，一个完整的计算机网络主要由硬件、软件、协议散发部分组成。硬件主要由主机（端系统）、通信链路（如双绞线、光纤）、交换设备（如交换机、路由器）和通信处理机（如网卡）等组成。软件主要包括各种实现资源共享的软件和方便用户使用的各种工具软件。软件部分多属于应用层。协议是计算机网络的核心。 从工作方式看，计算机网络可分为边缘部分和核心部分。边缘部分由所有连接到因特网上、供用户使用的端系统组成，用来进行通信和资源共享。核心部分由大量的网络和连接这些网络的路由器组成，为边缘部分提供连通性和交换服务。 从功能组成上看，计算机网络由通信子网和资源子网构成。通信子网由各种传输介质、通信设备和相应的网络协议组成，它使网络具有数据传输、交换、控制和存储的能力，实现联网计算机之间的数据通信。资源子网是实现资源共享功能的设备及其软件的集合，向用户提供共享其他其他计算机上的硬件资源、软件资源和数据资源的服务。 三、计算机网络的功能计算机网路的功能很多，现如今的很多应用都与网络有关。主要有下面5个部分。 数据通信 它是计算机网络最基本也是最重要的功能，用来实现联网计算机之间的各种信息的传输，并将分散在不同地理位置的计算机联系起来，进行统一的调配、控制和管理。 资源共享 资源共享可以是软件共享、数据共享，也可以是硬件共享。使计算机网络中的资源互通有无，分工协作，从而极大地提高了硬件资源、软件资源和数据资源的利用率 分布式处理 当计算机网络中的某个计算机负荷过重时，可以将其处理的某个复杂的任务分配给网络中的其他计算机系统，从而利用空闲资源以提高整个系统的利用率 提高可靠性 计算机网络中的各台计算机通过网络互为替代机 负载均衡 将工作任务均衡地分配给计算机网络中的各台计算机。 四、计算机网络的分类 按分布范围分： 1) 广域网（WAN）。任务是提供长距离通信，运送主机所发送的数据。 2）城域网（MAN）。城域网的覆盖范围可以跨越几个街区甚至几个城市，大多采用以太网技术。 3）局域网（LAN）。局域网一般用微机或工作站通过高速线路相连，覆盖范围较小。传统上，局域网使用广播技术，而广域网使用交换技术。 4）个人局域网（PAN）。在个人工作的地方将消费电子设备用无线技术连接起来的网络。 按传输技术分： 1）广播式网络。所有联网计算机都共享一个公共通信信道。当一台计算机利用共享通信信道发送报文分组时，所有其他的计算机都会“收听”到这个分组。接收到该分组的计算机将通过检查目的地址来决定是否接收该分组。 局域网基本上都采用广播式通信技术，广域网中的无线，卫星通信网络也采用广播式通信技术。 2）点对点网络。每条物理线路连接一对计算机。如果通信的两台计算机之间没有直接连接线路，那么它们之间的分组传输就要通过中间结点的接收、存储和转发，直至目的结点。 是否采用分组存储转发与路由选择机制是点对点网络与广播式网络的重要区别，广域网基本都属于点对点网络。 按拓扑结构分: 网络拓扑结构是指由网中结点（路由器、主机等）与通信线路（网线）之间的几何关系表示的网络结构，主要指通信子网的拓扑结构。 按网络的拓扑结构，主要分为星形、总线形、环形和网状形网络等。星形、总线形和环形网络多用于局域网，网状网络多用于广域网。 1）星形网络。每个终端或计算机都以单独的线路与中央设备相连。中央设备早期是计算机，现在一般是交换机或路由器。星形网络便于集中控制和管理，因为端用户之间的通信必须通过中间设备。缺点是成本高，中心节点对故障敏感。 2）总线形网络。用单根传输线将计算机连接起来。总线形网络的优点是建网容易，增减节点方便，节省线路。缺点是重负载时通信效率不高，总线任意一处对故障敏感。 3）环形网络。所有计算机接口设备连接成一个环。环形网络最典型的例子是令牌环局域网。环可以是单环，也可以是双环，环中信号是单向传输的。 4）网状网络。一般情况下，每个结点至少有两条路径与其他节点相连，多用于广域网中。有规则型和非规则型。其优点是可靠性高，缺点是控制复杂，线路成本高。 按使用者分: 1）公用网。指电信公司出资建造的大型网络。 2）专用网。指某个部门为了满足本单位特殊业务的需要而建造的网络，这种网络不对单位以外的人开放。 按交换技术分： 1）电路交换网络。在源结点和目的结点之间建立一条专用的通路用于传送数据，包括建立连接、传输数据和断开连接三个阶段。最典型的电路交换网络是传统电话网络。 该类网络的主要特点是整个报文的比特流连续地从源点直达终点，好像是在一条管道中传送。优点是数据直接传送，时延小。缺点是线路利用率低、不能充分利用线路容量，不便于进行差错控制。 2）报文交换网络。用户数据加上源地址、目的地址、校验码等辅助信息，然后封装成报文。整个报文传送到相邻结点全部存储后，再转发到下一个结点，重复这一过程直到到达目的结点。每个报文可以单独选择到达目的结点的路径。 报文交换网络也称存储-转发网络，主要特点是整个报文先传送到相邻结点，全部存储后查找转发表，转发到下一个结点。优点是可以较为充分的利用线路容量，可以实现不同链路之间不同数据率的转换，可以实现格式转换，可以实现一对多，多对一的访问，可以实现差错控制。缺点是增大了资源开销，增加了缓冲时延，需要额外的控制机制来保证多个报文的顺序不乱序，缓冲区难以管理。 3）分组交换网络。也称包交换网络。其原理是将数据分为较短的固定长度的数据块，在每个数据块中加上目的地址、源地址等辅助信息组成分组（包），以存储-转发方式传输。 其主要特点是单个分组传送到相邻结点，存储后查找转发表，转发到下一个结点。除具备报文交换网络的优点外，分组交换网络还具有自身的优点：缓冲易于管理；包的平均时延更小，网络占用的平均缓冲更少；易于标准化；更适合应用。现在的主流网络基本上都可视为分组交换网络。 按传输介质分： 传输介质可分为有线和无线两大类，故网络可分为有线网络和无线网络。有线网络又分为双绞线网络，同轴电缆网络等。无线网络可分为蓝牙、微波、无线电等。 五、计算机网络的的性能指标性能指标从不同的方面来度量计算机网络的性能。 速率 速率是数据的传送速率，它也称为数据率或比特率。 带宽 本来表示某个信号具有的频带宽度，单位是赫兹（Hz），而在计算机网络分钟，带宽用来表示网络的通信线路所能传送数据的能力，单位是比特/秒（b/s） 吞吐量 也称为吞吐率，表示单位时间内通过某个网络（或信道、接口）的数据量。 时延 时延是指一个数据（一个报文或分组，甚至比特）从网路（或链路）的一端传送到另一端所需要的时间。时延有时称为延迟或迟延。 1）发送时延，是主机或路由器将分组发送到通信线路上所需要的时间。 1发送时延=分组长度/发送速率 2）传播时延，是电磁波在信道中传播需要一定的距离而花费的时间。 1传播时延=信道长度/电磁波在信道上的传播速率 3）处理时延，主机或路由器收到分组时要花费一定的时间进行处理，例如，分析分组的首部、从分组中提取数据部分、进行差错检验或查找适当的路由等，这就产生了处理时延。 4）排队时延，分组在进入路由器后要先在输入队列在排队等待处理。路由器确定转发端口后，还要在输出队列中排队等待转发，这就产生了排队时延。 这样，分组从一个结点转发到另一个结点转发到另一个结点所经历的时延就是以上4种时延之和。 1总时延=发送时延+传播时延+处理时延+排队时延 丢包率 即分组丢失率，是指在一定的时间范围内，分组在传输过程中丢失的分组数量和总的分组数量的比率。 分组丢失的两种情况：一是因为传输过程中出现比特级差错被结点丢弃。二是因为分组交换机队列溢出。 利用率 令D0表示网络空闲时的时延，D表示网络当前时延，那么在适当的假定条件下，利用率可表示为：D=D0/1-U。 信道或网络利用率过高会产生非常大的时延。 时延带宽积 指发送端连续发送数据且发送的第一个比特即将到达终点时，发送端已经发出的比特数，即时延带宽积=传播时延*信道带宽。]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[顺序循环链表的实现]]></title>
    <url>%2F2019%2F03%2F31%2F%E9%A1%BA%E5%BA%8F%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8%E7%9A%84%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[写在前面&emsp;&emsp;队列（Queue)是一种特殊的线性表，是一种只允许在表的一端进行插入操作，在表的另一端进行删除操作的线性表。表中允许进行插入操作的一端称为队尾，允许进行删除操作的一端为队头。队头和队尾分别由队头指示器和队尾指示器指示。队列的插入操作通常称为入队，队列的删除操作通常称为出队。当队列中没有元素时，为空队列。&emsp;&emsp;根据队列的定义，每次进队列的数据元素都放在原来的队尾之后成为新的队尾元素，每次出队列得到数据元素都是原来的队头元素。这样，最先入队的数据元素总是最先出队，所以队列也被称为先进先出表。&emsp;&emsp;对队列的操作主要有：初始化建立队列、入队列、出队列、取队头元素、判断队列是否为空等操作。 1.顺序队列的类定义 123456789101112131415161718192021const int maxsize = 10;template&lt;class T&gt;class Queue&#123;public: Queue();//构造函数 ~Queue() &#123;&#125;;//析构函数 void insert(const T&amp;item);//入队 T delet();//出队列 T readFront() const;//读队头元素 bool empty() const;//判断队列是否为空 void clearQueue();//清空队列 int getsize() const;//获取队列长度 void display() const;//输出队列中的元素private: T data[maxsize]; int front; int rear; int count;&#125;; 2.顺序队列类的实现 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970template&lt;class T&gt;inline Queue&lt;T&gt;::Queue()&#123; front = 0; rear = 0; count = 0;&#125;template&lt;class T&gt;inline void Queue&lt;T&gt;::insert(const T &amp; item)&#123; if (count == maxsize) &#123; cout &lt;&lt; "Queue is full" &lt;&lt; endl; exit(1); &#125; count++; data[rear] = item; rear = ((rear + 1) == maxsize) ? 0 : (rear + 1); &#125;template&lt;class T&gt;inline T Queue&lt;T&gt;::delet()&#123; if (count&lt;=0) &#123; cout &lt;&lt; "Queue is empty" &lt;&lt; endl; &#125; count--; T p = data[front]; front = ((front + 1) == maxsize) ? 0 : (front + 1); return p;&#125;template&lt;class T&gt;inline T Queue&lt;T&gt;::readFront() const&#123; return data[front];&#125;template&lt;class T&gt;inline bool Queue&lt;T&gt;::empty() const&#123; return (count == 0);&#125;template&lt;class T&gt;inline void Queue&lt;T&gt;::clearQueue()&#123; count = 0; front = rear = 0;&#125;template&lt;class T&gt;inline int Queue&lt;T&gt;::getsize() const&#123; return count;&#125;template&lt;class T&gt;inline void Queue&lt;T&gt;::display() const&#123; int i = 0; while (i != count) &#123; cout &lt;&lt; i &lt;&lt; "号元素：" &lt;&lt; data[i] &lt;&lt; endl; i++; &#125;&#125; 3.测试主函数 1234567891011121314151617181920void test()&#123; Queue&lt;int&gt; queue; for (int i = 0; i &lt; 10; i++) &#123; queue.insert(i); &#125; cout &lt;&lt;"队列的长度为："&lt;&lt; queue.getsize() &lt;&lt; endl; queue.display(); cout &lt;&lt;"队头元素为："&lt;&lt; queue.readFront() &lt;&lt; endl; cout &lt;&lt; "元素："&lt;&lt;queue.delet()&lt;&lt;"已删除" &lt;&lt; endl;&#125;int main()&#123; test(); system("pause"); return EXIT_SUCCESS;&#125; 输出结果如下：]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>顺序循环链表</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[链式队列的实现]]></title>
    <url>%2F2019%2F03%2F31%2F%E9%93%BE%E5%BC%8F%E9%98%9F%E5%88%97%E7%9A%84%E5%AE%9E%E7%8E%B0-1%2F</url>
    <content type="text"><![CDATA[写在前面&emsp;&emsp;链式队列是队列的链式存储结构表示。队列是操作受限的表，队列有队头和队尾，插入元素的一端称为队尾，删除元素的一端称为队头。这和一般排队的概念一样，后来的人排在队尾，首先对队头的人进行服务，对队头的人服务后，原当前队头后的人就排在了当前队头。新来的人排在队尾后，原队尾的人就不再是当前队尾了，新来的人就成了当前队尾。&emsp;&emsp;链式队列的队头指针指在队列的当前队头节点位置，队尾指针指在队列的当前队尾节点位置。不带头节点的链式队列，出队列时可直接删除头指针所指的节点，因此，链式队列不带头指针时更加方便。 1.链式队列节点类的定义和实现 12345678910111213141516171819202122template&lt;class T&gt;class LinkQueue;template&lt;class T&gt;class QueueNode&#123; friend class LinkQueue&lt;T&gt;;public: T data; QueueNode&lt;T&gt;(const T&amp; item, QueueNode&lt;T&gt; *ptrNext = NULL); ~QueueNode() &#123;&#125;;private: QueueNode&lt;T&gt; *next;&#125;;template&lt;class T&gt;inline QueueNode&lt;T&gt;::QueueNode(const T &amp; item, QueueNode&lt;T&gt;* ptrNext)&#123; this-&gt;data = item; this-&gt;next = ptrNext;&#125; 2.链式队列类的定义 1234567891011121314151617181920template&lt;class T&gt;class LinkQueue&#123;public: LinkQueue();//构造函数 ~LinkQueue();//析构函数 void insert(const T&amp; item);//入队 T delet();//出队 T readFront() const;//读队头元素 bool empty() const;//判断队列是否为空 void clearQueue();//清空队列 int getSize() const;//取队列长度 void display() const;//输出队列元素private: QueueNode&lt;T&gt; *front;//指向队头的指针 QueueNode&lt;T&gt; *rear;//指向队尾的指针 int size;&#125;; 3.链式队列类的实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990template&lt;class T&gt;inline LinkQueue&lt;T&gt;::LinkQueue()&#123; size = 0; front = rear = NULL;&#125;template&lt;class T&gt;inline LinkQueue&lt;T&gt;::~LinkQueue()&#123; clearQueue(); front = rear = NULL;&#125;template&lt;class T&gt;inline void LinkQueue&lt;T&gt;::insert(const T &amp; item)&#123; QueueNode&lt;T&gt; *new_node = new QueueNode&lt;T&gt;(item); if (rear != NULL) &#123; rear-&gt;next = new_node; &#125; rear = new_node; if (front == NULL) &#123; front = new_node; &#125; size++;&#125;template&lt;class T&gt;inline T LinkQueue&lt;T&gt;::delet()&#123; if (size == 0) &#123; cout &lt;&lt; "Queue is empty" &lt;&lt; endl; exit(1); &#125; T member = front-&gt;data; QueueNode&lt;T&gt; *p = front-&gt;next; delete front; front = p; size--; return member;&#125;template&lt;class T&gt;inline T LinkQueue&lt;T&gt;::readFront() const&#123; return front-&gt;data;&#125;template&lt;class T&gt;inline bool LinkQueue&lt;T&gt;::empty() const&#123; return (size==0);&#125;template&lt;class T&gt;inline void LinkQueue&lt;T&gt;::clearQueue()&#123; QueueNode&lt;T&gt; *p1, *p2; p1 = front; while (p1 != NULL) &#123; p2 = p1; p1 = p1-&gt;next; delete p2; &#125; size = 0;&#125;template&lt;class T&gt;inline int LinkQueue&lt;T&gt;::getSize() const&#123; return size;&#125;template&lt;class T&gt;inline void LinkQueue&lt;T&gt;::display() const&#123; QueueNode&lt;T&gt; *p = front; int i = 0; while (p != NULL) &#123; cout &lt;&lt; "第" &lt;&lt; i &lt;&lt; "号元素为：" &lt;&lt; p-&gt;data &lt;&lt; endl; i++; p = p-&gt;next; &#125;&#125; 4.测试主函数 123456789101112131415161718192021222324252627282930313233343536373839404142434445void test()&#123; LinkQueue&lt;int&gt; queue; for (int i = 0; i &lt; 10; i++) &#123; queue.insert(i * 10); &#125; cout &lt;&lt; "队列长度为：" &lt;&lt; queue.getSize() &lt;&lt; endl; queue.display(); cout &lt;&lt; "栈顶元素为：" &lt;&lt; queue.readFront() &lt;&lt; endl; for (int i = 0; i &lt; 10; i++) &#123; cout &lt;&lt; "元素：" &lt;&lt; queue.delet() &lt;&lt; "被删除" &lt;&lt; endl; &#125; cout &lt;&lt; "队列长度为：" &lt;&lt; queue.getSize() &lt;&lt; endl;&#125;int main()&#123; test(); system("pause"); return EXIT_SUCCESS;&#125;void test()&#123; LinkQueue&lt;int&gt; queue; for (int i = 0; i &lt; 10; i++) &#123; queue.insert(i * 10); &#125; cout &lt;&lt; "队列长度为：" &lt;&lt; queue.getSize() &lt;&lt; endl; queue.display(); cout &lt;&lt; "栈顶元素为：" &lt;&lt; queue.readFront() &lt;&lt; endl; for (int i = 0; i &lt; 10; i++) &#123; cout &lt;&lt; "元素：" &lt;&lt; queue.delet() &lt;&lt; "被删除" &lt;&lt; endl; &#125; cout &lt;&lt; "队列长度为：" &lt;&lt; queue.getSize() &lt;&lt; endl;&#125;int main()&#123; test(); system("pause"); return EXIT_SUCCESS;&#125; 输出结果如下：]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>队列</tag>
        <tag>链式队列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[双向循环链表]]></title>
    <url>%2F2019%2F03%2F28%2F%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[写在前面&emsp;&emsp;双向循环链表（Double Circular Linked List)是每个节点有前趋指针和后继指针，且后继指针和前趋指针各自构成自己的单循环链表的链表。&emsp;&emsp;在单链表中查找当前节点的后继节点并不困难，可以通过当前节点的next指针进行，但要查找当前节点的前趋节点就要从头指针head开始重新进行。对于一个要进行频繁查找当前节点的后继节点和当前节点的前趋节点的应用来说，使用单链表的时间效率是非常低的，双向链表是有效解决这类问题的选择。&emsp;&emsp;在双向链表中，每个节点包括三个域，分别是data,next,prior。其中data为数据域，next为后继节点指针，prior为前趋节点指针。&emsp;&emsp;双向链表通常均为双向循环链表，这是因为读双向循环链表，不论是插入还是删除，对第一个节点、最后一个节点的操作和对链表中间任意一个节点的操作过程是一样的。而双向非循环链表对这些节点的操作是不同的。 1.节点类的定义和实现 1234567891011121314151617181920212223242526template&lt;class T&gt;class DCirlist;template&lt;class T&gt;class DLnode&#123; friend class DCirlist&lt;T&gt;;public: T data; //构造函数，无数据域的头结点 DLnode&lt;T&gt;(DLnode&lt;T&gt; *ptrn = NULL, DLnode&lt;T&gt; *ptrp = NULL)&#123;&#125;; //构造函数，非头节点的节点 DLnode&lt;T&gt;( T item, DLnode&lt;T&gt; *ptrn = NULL, DLnode&lt;T&gt; *ptrp = NULL); //析构函数 ~DLnode() &#123;&#125;;private: DLnode&lt;T&gt; *next; DLnode&lt;T&gt; *prior;&#125;;template&lt;class T&gt;inline DLnode&lt;T&gt;::DLnode(T item, DLnode&lt;T&gt;* ptrn, DLnode&lt;T&gt;* ptrp)&#123; this-&gt;data = item; this-&gt;next = ptrn; this-&gt;prior = ptrp;&#125; &emsp;&emsp;双向循环链表只是在单循环链表的基础上又增加了一个指向前趋节点的指针，而且指向前趋节点指针也构成了自己的单循环链表。双循环链表的定义与单循环链表的定义非常相似。 2.双向循环链表类的定义 1234567891011121314151617181920212223242526272829template &lt;class T&gt;class DCirlist&#123;public: DCirlist();//构造函数 ~DCirlist();//析构函数 int listsize() const;//返回链表长度 bool empty() const;//判断链表是否为空 DLnode&lt;T&gt; *index(int pos) const;//返回指向第pos个节点的指针 void insert(const T &amp;item, int pos);//在第pos个节点插入item T del(int pos);//删除第pos个节点，并返回数据域 T getdata(int pos) const;//返回第pos个节点的值 void clearlist();//清空表 DLnode&lt;T&gt; *reset(int pos = 0); DLnode&lt;T&gt; *next(); DLnode&lt;T&gt; *prior(); bool EndOfList() const;//是否到链表尾 bool nextEndoflist() const;//currPtr-&gt;next是否到链表尾 bool PriorEndoflist() const;//currPtr-&gt;prior是否到链表尾 T deleprior();//删除currPtr节点，新currPtr是原currPtr的前趋，返回数据域private: DLnode&lt;T&gt; *head; DLnode&lt;T&gt; *currPtr; int size;&#125;; 3.双向循环链表类的实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178template&lt;class T&gt;inline DCirlist&lt;T&gt;::DCirlist()&#123; head = new DLnode&lt;T&gt;(); head-&gt;next = head; head-&gt;prior = head; size = 0;&#125;template&lt;class T&gt;inline DCirlist&lt;T&gt;::~DCirlist()&#123; clearlist(); delete head; head = NULL;&#125;template&lt;class T&gt;inline int DCirlist&lt;T&gt;::listsize() const&#123; return size;&#125;template&lt;class T&gt;inline bool DCirlist&lt;T&gt;::empty() const&#123; return (size == 0);&#125;template&lt;class T&gt;inline DLnode&lt;T&gt;* DCirlist&lt;T&gt;::index(int pos) const&#123; if (pos == -1) &#123; return head; &#125; if (pos&lt;0 || pos&gt;size) &#123; cout &lt;&lt; "illegal operator" &lt;&lt; endl; exit(1); &#125; int i = 0; DLnode&lt;T&gt; *p = head-&gt;next; while (i &lt; pos&amp;&amp;p != head) &#123; p = p-&gt;next; i++; &#125; return p;&#125;template&lt;class T&gt;inline void DCirlist&lt;T&gt;::insert(const T &amp; item, int pos)&#123; DLnode&lt;T&gt; *p = index(pos-1); DLnode&lt;T&gt; *new_node = new DLnode&lt;T&gt;(item, NULL, NULL); new_node-&gt;prior = p; p-&gt;next-&gt;prior = new_node; new_node-&gt;next = p-&gt;next; p-&gt;next = new_node; size++;&#125;template&lt;class T&gt;inline T DCirlist&lt;T&gt;::del(int pos)&#123; if (size == 0) &#123; cout &lt;&lt; "list is empty" &lt;&lt; endl; exit(1); &#125; if (pos&lt;0 || pos&gt;size) &#123; cout &lt;&lt; "illegal operator" &lt;&lt; endl; exit(1); &#125; DLnode&lt;T&gt; *p = index(pos); p-&gt;prior-&gt;next = p-&gt;next; p-&gt;next-&gt;prior = p-&gt;prior; T data = p-&gt;data; delete p; size--; return data;&#125;template&lt;class T&gt;inline T DCirlist&lt;T&gt;::getdata(int pos) const&#123; DLnode&lt;T&gt; *p = index(pos); return p-&gt;data;&#125;template&lt;class T&gt;inline void DCirlist&lt;T&gt;::clearlist()&#123; DLnode&lt;T&gt; *p1, *p2; p1 = head-&gt;next; while (p1 != head) &#123; p2 = p1; p1 = p1-&gt;next; delete p2; &#125; size = 0;&#125;template&lt;class T&gt;inline DLnode&lt;T&gt;* DCirlist&lt;T&gt;::reset(int pos)&#123; if (pos == -1) &#123; return head; &#125; if (pos&lt;0 || pos&gt;size) &#123; cout &lt;&lt; "illegal operator" &lt;&lt; endl; exit(1); &#125; int i = 0; currPtr = head-&gt;next; while (i &lt; pos&amp;&amp;currPtr != head) &#123; currPtr = currPtr-&gt;next; i++; &#125; return currPtr;&#125;template&lt;class T&gt;inline DLnode&lt;T&gt;* DCirlist&lt;T&gt;::next()&#123; if (currPtr!= NULL) &#123; currPtr = currPtr-&gt;next; &#125; return currPtr; &#125;template&lt;class T&gt;inline DLnode&lt;T&gt;* DCirlist&lt;T&gt;::prior()&#123; if (currPtr != NULL) &#123; currPtr = currPtr-&gt;prior; &#125; return currPtr;&#125;template&lt;class T&gt;inline bool DCirlist&lt;T&gt;::EndOfList() const&#123; return (currPtr == head);&#125;template&lt;class T&gt;inline bool DCirlist&lt;T&gt;::nextEndoflist() const&#123; return (currPtr-&gt;next == head);&#125;template&lt;class T&gt;inline bool DCirlist&lt;T&gt;::PriorEndoflist() const&#123; return (currPtr-&gt;prior == head);&#125;template&lt;class T&gt;inline T DCirlist&lt;T&gt;::deleprior()&#123;//删除当前节点的前一节点 DLnode&lt;T&gt; *p = currPtr-&gt;prior; currPtr-&gt;prior-&gt;next = currPtr-&gt;next; currPtr-&gt;next-&gt;prior = currPtr-&gt;prior; T data = currPtr-&gt;data; delete currPtr; size--; currPtr = p; return currPtr;&#125; 4.测试主函数 1234567891011121314151617181920212223242526272829303132void test()&#123; DCirlist&lt;int&gt; list; for (int i = 0; i &lt; 10; i++) &#123; list.insert(i * 10, i); &#125; cout &lt;&lt; "list中元素的个数为：" &lt;&lt; list.listsize() &lt;&lt; endl; DLnode&lt;int&gt; *p = list.reset(); while (!list.EndOfList()) &#123; cout &lt;&lt; p-&gt;data &lt;&lt; endl; p = list.next(); &#125; p = list.next(); cout &lt;&lt; list.del(1) &lt;&lt; "已被删除" &lt;&lt; endl; cout &lt;&lt; "list中元素的个数为：" &lt;&lt; list.listsize() &lt;&lt; endl; while (!list.EndOfList()) &#123; cout &lt;&lt; p-&gt;data &lt;&lt; endl; p = list.next(); &#125; cout &lt;&lt; list.getdata(1) &lt;&lt; endl; cout &lt;&lt; list.index(2)-&gt;data &lt;&lt; endl;&#125;int main()&#123; test(); system("pause"); return EXIT_SUCCESS;&#125; 输出结果如下：]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>双向循环链表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[单循环链表]]></title>
    <url>%2F2019%2F03%2F28%2F%E5%8D%95%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[写在前面&emsp;&emsp;单循环链表，简称循环链表（circular linked list)，是表的一种链式存储结构。&emsp;&emsp;设p是指向循环链表的指针，currPtr是当前指向对的循环链表的指针，head是指向循环链表的头指针，与链表判断是否到达链尾相比，循环链表中判断是否到达链表尾的条件是：p!=head或者是currPtr!=head。所以，循环链表类中成员函数的实现与链表类中的成员函数的实现差别不大，只是把p!=null换成了p!=head，把currPtr!=null换成了currptr!=head. 1.节点类的定义和实现 1234567891011121314151617181920212223242526template&lt;class T&gt;class CirList;template&lt;class T&gt;class ListNode&#123; friend class CirList&lt;T&gt;;//声明友元类public: T data;//数据域 ListNode(ListNode&lt;T&gt; *ptrNext = NULL);//构造函数，用于构造头节点，头节点没有data参数 ListNode(const T &amp;item, ListNode&lt;T&gt; *ptrNext = NULL);//构造函数，主要用于构造非头节点的节点 ~ListNode() &#123;&#125;;//析构函数private: ListNode&lt;T&gt; *next;//指向下一节点的指针&#125;;template&lt;class T&gt;inline ListNode&lt;T&gt;::ListNode(ListNode&lt;T&gt;* ptrNext) :next(ptrNext)&#123;&#125;template&lt;class T&gt;inline ListNode&lt;T&gt;::ListNode(const T &amp; item, ListNode&lt;T&gt;* ptrNext)&#123; this-&gt;data = item; this-&gt;next = ptrNext;&#125; 2.循环链表类的定义 12345678910111213141516171819202122232425262728template &lt;class T&gt;class CirList&#123;public: CirList();//构造函数 ~CirList();//析构函数 int listsize();//长度 bool listempty() const;//是否为空 ListNode&lt;T&gt; *index(int pos);//返回指向位置pos的指针 void insert(const T&amp; item, int pos);//在pos节点前插入一个节点 T del(int pos);//删除第pos个节点 T getdata(int pos) const;//返回pos节点的值域 void clearlist();//清空表为初始状态 ListNode&lt;T&gt; *reset();//currptr指向节点pos并返回currptr ListNode&lt;T&gt; *next();//currptr指向下一节点并返回currptr bool EndOfList() const;//判断是否到了尾部 ，currptr==head bool nextEndofList() const;//currptr-&gt;next是否链表尾 T delAfter();//删除currptr-&gt;next所指节点并返回被删除节点的dataprivate: ListNode&lt;T&gt; *head;//表头指针 int size;//链表的节点个数 ListNode&lt;T&gt; *currPtr;//当前节点指针&#125;; 3.循环链表类的实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146template&lt;class T&gt;inline CirList&lt;T&gt;::CirList()&#123; head = new ListNode&lt;T&gt;(); size = 0; head-&gt;next = head;&#125;template&lt;class T&gt;inline CirList&lt;T&gt;::~CirList()&#123; clearlist(); delete head; head = NULL; &#125;template&lt;class T&gt;inline int CirList&lt;T&gt;::listsize()&#123; return size;&#125;template&lt;class T&gt;inline bool CirList&lt;T&gt;::listempty() const&#123; return (size == 0);&#125;template&lt;class T&gt;inline ListNode&lt;T&gt;* CirList&lt;T&gt;::index(int pos)&#123; if (pos == -1) &#123; return head; &#125; if (pos&lt;0 || pos&gt;size) &#123; cout &lt;&lt; "illegal operator" &lt;&lt; endl; exit(1); &#125; currPtr = head-&gt;next; int i = 0; while (currPtr != NULL &amp; i &lt; pos) &#123; currPtr = currPtr-&gt;next; i++; &#125; return currPtr;&#125;template&lt;class T&gt;inline void CirList&lt;T&gt;::insert(const T &amp; item, int pos)&#123; if (pos&lt;0 || pos&gt;size) &#123; cout &lt;&lt; "illegal operator" &lt;&lt; endl; exit(1); &#125; ListNode&lt;T&gt; *p = index(pos - 1); ListNode&lt;T&gt; *newnode = new ListNode&lt;T&gt;(item, p-&gt;next); p-&gt;next = newnode; size++;&#125;template&lt;class T&gt;inline T CirList&lt;T&gt;::del(int pos)&#123; if (pos&lt;0 || pos&gt;size) &#123; cout &lt;&lt; "illegal operator" &lt;&lt; endl; exit(1); &#125; ListNode&lt;T&gt; *p = index(pos-1); ListNode&lt;T&gt; *q; q = p-&gt;next; p-&gt;next = q-&gt;next; T data = q-&gt;data; delete q; size--; return data;&#125;template&lt;class T&gt;inline T CirList&lt;T&gt;::getdata(int pos) const&#123; ListNode&lt;T&gt; *p = index(pos); return p-&gt;data;&#125;template&lt;class T&gt;inline void CirList&lt;T&gt;::clearlist()&#123; ListNode&lt;T&gt; *p, *p1; p = head-&gt;next; while (p != head) &#123; p1 = p; p= p-&gt;next; delete p1; &#125; size = 0;&#125;template&lt;class T&gt;inline ListNode&lt;T&gt;* CirList&lt;T&gt;::reset()&#123; currPtr = head-&gt;next; return currPtr;&#125;template&lt;class T&gt;inline ListNode&lt;T&gt;* CirList&lt;T&gt;::next()&#123; if (currPtr != NULL) &#123; currPtr = currPtr-&gt;next; &#125; return currPtr;&#125;template&lt;class T&gt;inline bool CirList&lt;T&gt;::EndOfList() const&#123; return (currPtr == head);&#125;template&lt;class T&gt;inline bool CirList&lt;T&gt;::nextEndofList() const&#123; return (currPtr-&gt;next == head);&#125;template&lt;class T&gt;inline T CirList&lt;T&gt;::delAfter()&#123;//删除currpter-&gt;next,并返回currptr-&gt;next-&gt;data if (currPtr-&gt;next != NULL) &#123; ListNode&lt;T&gt; *p = currPtr-&gt;next; currPtr-&gt;next = p-&gt;next; T data = p-&gt;data; delete p; size--; return data; &#125;&#125; 4.测试主函数 1234567891011121314151617181920212223242526272829303132void test()&#123; CirList&lt;int&gt; list; cout &lt;&lt; "当前链表中的元素有" &lt;&lt; list.listsize() &lt;&lt; endl; for (int i = 0; i &lt; 10; i++) &#123; list.insert(10 * i, i); &#125; list.insert(100, 0); cout &lt;&lt; "当前链表中的元素有" &lt;&lt; list.listsize() &lt;&lt; endl; ListNode&lt;int&gt; *p = list.reset(); while (!list.EndOfList()) &#123; cout &lt;&lt; p-&gt;data &lt;&lt; endl; p = list.next(); &#125; cout&lt;&lt; list.del(1)&lt;&lt;"已被删除"&lt;&lt;endl; while (!list.EndOfList()) &#123; cout &lt;&lt; p-&gt;data &lt;&lt; endl; p = list.next(); &#125; cout &lt;&lt; list.index(5)-&gt;data &lt;&lt; endl;&#125;int main()&#123; test(); system("pause"); return EXIT_SUCCESS;&#125; 输出结果如下：]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>单循环链表</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[顺序表的简单实现]]></title>
    <url>%2F2019%2F03%2F27%2F%E9%A1%BA%E5%BA%8F%E8%A1%A8%E7%9A%84%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[写在前面 &emsp;&emsp;数据结构是一个数据对象，同时这个对象的实例以及构成实例的元素都存在着联系，而且这些联系是由相关函数来规定的。&emsp;&emsp;研究数据结构，关心的是数据对象（实际上是实例）的描述以及相关函数的具体实现。数据对象描述得好，函数的实现就会高效。&emsp;&emsp;最常用的数据对象以及操作都已经在C++中作为基本数据类型而实现，如整数对象，布尔对象等。其他数据对象均可以用基本数据类型以及由C++的类、数组和指针所提供的组合功能来实现。 1.线性表的数据结构 &emsp;&emsp;线性表（linear list)也称有序表，它的每一个实例都是元素的一个有序集合。&emsp;&emsp;对线性表实施的操作有： 创建一个线性表 撤销一个线性表 确定线性表是否为空 确定线性表的长度 按给定的索引查找一个元素 按一个给定的元素查找其索引 按一个给定的索引删除一个元素 按一个给定的索引插入一个元素 从左至右顺序输出线性表元素 &emsp;&emsp;用顺序存储结构存储的表称为顺序表（sequent list）。顺序表中任意数据元素的存取和访问都可以通过它的位置指针来（即数组下标）进行访问。对顺序表中元素访问的效率是一个比较重要的问题。通常情况下，有序顺序表的访问效率大大高于无序顺序表的访问效率。 2.顺序表的类定义 12345678910111213141516171819typedef int Seqlist_Entry;const int maxsize = 10;class Seqlist&#123;public: Seqlist();//构造函数 ~Seqlist();//析构函数 int listsize()const;//返回元素的个数 bool listempty() const;//判断表是否为空 int find(const Seqlist_Entry &amp;item);//返回元素item在表中的位置 Seqlist_Entry getdata(int pos) const;//返回位置pos的元素 void insert(const Seqlist_Entry &amp;item, int pos);//在位置pos处插入元素item Seqlist_Entry Delete(const int pos);//删除位置pos的元素并返回 void clearlist();//清空表 void showall() const;//输出表private: Seqlist_Entry data[maxsize]; int size;//数据元素的个数&#125;; 3.顺序表的类实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104//构造函数Seqlist::Seqlist()&#123; size = 0;&#125;//析构函数Seqlist::~Seqlist() &#123;&#125;//返回顺序表元素的个数int Seqlist::listsize() const&#123; return size;&#125;//判断顺序表是否为空bool Seqlist::listempty() const&#123; return (size == 0);&#125;//查找item，并返回位置索引int Seqlist::find(const Seqlist_Entry &amp; item)&#123; if (size == 0) &#123; cout &lt;&lt; "list is empty " &lt;&lt; endl; &#125; int i = 0; while (i &lt; size&amp;&amp;item != data[i]) &#123; i++; &#125; if (i &lt; size) return i; else cout &lt;&lt; "illegal operator" &lt;&lt; endl;&#125;//取出pos位置上的元素Seqlist_Entry Seqlist::getdata(int pos) const&#123; if (pos&lt;0 || pos&gt;size - 1) &#123; cout &lt;&lt; "illegal operator" &lt;&lt; endl; exit(1); &#125; return data[pos];&#125;//在pos位置插入元素itemvoid Seqlist::insert(const Seqlist_Entry &amp; item, int pos)&#123; if (size == maxsize) &#123; cout &lt;&lt; "list is full" &lt;&lt; endl; return; &#125; if (pos&lt;0 || pos&gt;size ) &#123; cout &lt;&lt; "illegal operator" &lt;&lt; endl; return; &#125; for (int i = size; i &gt; pos; i--) &#123; data[i] = data[i - 1]; &#125; data[pos] = item; size++;&#125;//删除pos位置的元素Seqlist_Entry Seqlist::Delete(const int pos)&#123; Seqlist_Entry tmp=data[pos]; if (size == 0) &#123; cout &lt;&lt; "list is empty" &lt;&lt; endl; exit(1); &#125; if (pos&lt;0 || pos&gt;size - 1) &#123; cout &lt;&lt; "illegal operator" &lt;&lt; endl; exit(1); &#125; for (int i = pos; i &lt; size-1; i++) &#123; data[i] = data[i + 1]; &#125; size--; return tmp;&#125;//置顺序表为空void Seqlist::clearlist()&#123; size = 0; cout &lt;&lt; "已清空" &lt;&lt; endl;&#125;//输出顺序表中所有元素void Seqlist::showall() const&#123; if (size == 0) &#123; cout &lt;&lt; "list is empty" &lt;&lt; endl; &#125; for (int i = 0; i &lt; size; i++) &#123; cout &lt;&lt;i&lt;&lt;"号元素:"&lt;&lt; data[i] &lt;&lt; endl; &#125;&#125; 4.测试主函数 123456789101112131415161718192021222324void test()&#123; Seqlist list; for (int i = 0; i &lt; 10; i++) &#123; list.insert(i * 12, i); &#125; for (int i = 0; i &lt; 10; i++) &#123; cout &lt;&lt; list.getdata(i) &lt;&lt; endl; &#125; int tmp = list.Delete(2); cout &lt;&lt; "元素" &lt;&lt; tmp &lt;&lt; "已经被删除了" &lt;&lt; endl; list.showall(); cout&lt;&lt;"84在顺序表的"&lt;&lt;list.find(84)&lt;&lt;"号位置"&lt;&lt;endl; list.clearlist(); list.showall();&#125;int main()&#123; test();&#125; 输出结果如下图：]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>顺序表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[栈的实现]]></title>
    <url>%2F2019%2F03%2F27%2F%E6%A0%88%E7%9A%84%E5%AE%9E%E7%8E%B0-1%2F</url>
    <content type="text"><![CDATA[写在前面&emsp;栈（Stack)是一种特殊的线性表，是一种只允许在表的一端进行插入和删除操作的线性表。栈中允许进行插入和删除操作的一端称为栈顶，另一端为栈底。栈顶的当前位置是动态的，标识栈顶当前位置的称为栈顶指示器（或栈顶指针）。栈的插入和删除操作通常称为入栈或进栈，栈的删除操作称为出栈或退栈。当栈中没有数据元素时称为空栈。&emsp;&emsp;根据栈的定义，每次进栈的数据元素都放在原当前栈顶元素之前而成为新的栈顶元素，每次退栈的数据元素都是当前栈顶元素，这样，最后进入堆栈的数据元素总是最先出栈，因此栈也被成为后进先出表。 1.栈的基本运算 初始化栈 销毁栈 判断栈是否为空 进栈 出栈 取栈顶元素 2.顺序栈四要素 栈空条件： top==-1 栈满条件： top==max_stack - 1 item进栈操作：top++,将item放在top处 退栈操作：从top处取出元素item，top– 3.类说明 &emsp;对于顺序栈Stack的实现，应创建一个数组来存放栈中的元素，并用一个始终指向栈顶的变量top来表示栈顶的位置。类定义如下： 12345678910111213141516171819202122232425typedef int Stack_Entry;const int max_stack = 10;class Stack&#123;public: Stack(); //构造函数 ~Stack() &#123;&#125;; //析构函数 bool empty() const; //判断栈是否为空 Stack_Entry pop(); //出栈数据元素 Stack_Entry Top(Stack_Entry &amp;item) const; //返回栈顶元素 void push(const Stack_Entry &amp;item); //数据元素item进栈 int getsize() const; //获取栈中元素的个数 void clearstack(); //清空栈private: int top;//栈顶位置指示器 Stack_Entry entry[max_stack];//Stack_Entry类型的数组&#125;; 4.具体实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748Stack::Stack()&#123; top=-1;&#125;bool Stack::empty() const&#123; return (top==-1);&#125;Stack_Entry Stack::pop()&#123; if (top==-1) &#123; cout &lt;&lt; "Stack is empty" &lt;&lt; endl; &#125; return entry[top--]; &#125;Stack_Entry Stack::Top(Stack_Entry &amp; item) const&#123; if (top == -1) &#123; cout &lt;&lt; "Stack is empty" &lt;&lt; endl; &#125; return entry[top];&#125;void Stack::push(const Stack_Entry &amp; item)&#123; if (top == max_stack - 1) &#123; cout &lt;&lt; "Stack is full" &lt;&lt; endl; &#125; top++; entry[top] = item;&#125;int Stack::getsize() const&#123; return top+1;&#125;void Stack::clearstack()&#123; top = -1;&#125; 5.主函数 12345678910111213141516171819202122232425262728293031void test()&#123; Stack stack; for (int i = 0; i &lt; 10; i++) &#123; stack.push(i+10*i); &#125; cout &lt;&lt; "当前栈中元素数为：" &lt;&lt; stack.getsize() &lt;&lt; endl; for (int i = 0; i &lt; 10; i++) &#123; Stack_Entry tmp; tmp = stack.pop(); cout &lt;&lt; "我是" &lt;&lt; i &lt;&lt; "号元素:"&lt;&lt;tmp &lt;&lt; endl; &#125; cout &lt;&lt; "当前栈中元素数为：" &lt;&lt; stack.getsize() &lt;&lt; endl; if (stack.empty()) &#123; cout &lt;&lt; "Stack is empty" &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; "Stack is not empty" &lt;&lt; endl; &#125;&#125;int main()&#123; test(); system("pause"); return EXIT_SUCCESS;&#125; 输出结果如下图：]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>栈</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[单链表的实现]]></title>
    <url>%2F2019%2F03%2F27%2F%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[写在前面&emsp;链式存储结构是计算机中另一种最基本和最主要的数据存储结构。和顺序存储结构不同，初始化时链式存储结构为空链，每当有新的元素需要存储时用户向系统动态申请所需的存储空间插入链中。所有高级程序设计语言都为用户提供了向系统动态申请和动态释放存储空间的办法。C++提供了new和delete运算符，分别用于向系统动态申请所需存储空间和动态释放用new申请的存储空间。new能自动计算要分配的类型大小并自动返回正确的指针类型。delete能自动释放由new分配的存储空间。&emsp;&emsp;在顺序存储结构中，用户向系统申请一块地址连续的有限空间用于存储数据元素，这样任意两个在逻辑上相邻的数据元素在物理上也必然相邻。但在链式存储结构中，由于它在初始化时为空链，每当有新的数据元素需要存储时用户才向系统动态申请所需的存储空间插入链中，而这些在不同时刻向系统动态申请的存储空间在内存上很可能是不连续的。因此，在链式存储结构中，任意两个在逻辑上相邻的数据元素在物理上不一定相邻，数据元素的逻辑次序是通过链中的指针连接实现的。 &emsp;&emsp;链式存储结构存储线性结构数据元素集合的方法是用节点（Node)构造链。线性结构数据元素的特点是：除第一个和最后一个元素外，每个元素只有一个唯一的前驱和一个唯一的后继。链式结构中每个节点除数据域外，还有一个或两个以上的指针域，数据域用来存放数据元素，指针域用来构造数据元素之间的关系。 1.单链表 &emsp;单链表简称链表（linked list)，是表数据元素的单链结构存储。链表使用一个一个的节点链接构成的。&emsp;&emsp;表要求允许在任意位置进行插入和删除。当选用带头节点的单链表时，在第一个位置插入节点和在其他位置插入节点一样不会改变头指针head的值，此时改变的是head-&gt;next的值。&emsp;在第一个位置删除节点和在其他位置删除节点一样也不会改变头指针head的值，此时改变的也是head-&gt;next的值。 2.节点类的定义和实现 &emsp;在单链表中，每个节点构成包括数据域和指针域两部分。每个节点的基本操作包括构造一个节点对象、建立一个新节点、给出当前节点的下一个节点指针等。 1234567891011121314151617181920212223template&lt;class T&gt;class ListNode&#123; friend class LinList&lt;T&gt;;//声明友元类public: T data;//数据域 ListNode(ListNode&lt;T&gt; *ptrNext = NULL);//构造函数，用于构造头节点，头节点没有data参数 ListNode(const T &amp;item, ListNode&lt;T&gt; *ptrNext = NULL);//构造函数，主要用于构造非头节点的节点 ~ListNode() &#123;&#125;;//析构函数private: ListNode&lt;T&gt; *next;//指向下一节点的指针&#125;;template&lt;class T&gt;inline ListNode&lt;T&gt;::ListNode(ListNode&lt;T&gt;* ptrNext):next(ptrNext)&#123;&#125;//构造函数，用于构造头节点，头节点没有值template&lt;class T&gt;inline ListNode&lt;T&gt;::ListNode(const T &amp; item, ListNode&lt;T&gt;* ptrNext)&#123;//构造函数，用于构造非头节点的节点 data = item; next = ptrNext;&#125; &emsp;节点类的成员有data域和next域。data域中存放了该节点的数据值，由于应用问题中需要使用链表中的data值，所以定义为公有数据成员方便使用；next域定义为私有数据成员。节点类的成员函数由两个不同参数的构造函数和空的析构函数。析构函数为空是因为节点类中没有用new函数向系统申请空间，而节点对象本身分配的空间，系统可自动识别释放。 3.单链表类的定义 12345678910111213141516171819202122232425template&lt;class T&gt;class LinList&#123;public: LinList();//构造函数 ~LinList();//析构函数 //表操作成员函数 int listsize() const;//返回链表中元素的个数 bool listempty() const;//链表是否为空 ListNode&lt;T&gt; *index(int pos);//返回指向第pos个节点的指针 void insert(const T&amp; item, int pos);//在pos节点前插入一个data域为item的元素 T Delete(int pos);//删除第pos个节点并返回被删除节点的data域 T getdata(int pos);//返回第pos个节点的data值 void clearlist();//清空表为初始化状态 //遍历链表的成员函数 ListNode&lt;T&gt; *Reset(int pos = 0);//currPtr指向节点pos并返回currPtr ListNode&lt;T&gt; *Next();//currPtr指向下一个节点并返回currPtr bool endOfList() const;//currPtr==head？private: ListNode&lt;T&gt; *head;//指向头节点的指针 ListNode&lt;T&gt; *currPtr;//当前指针 int size;//单链表中元素的个数&#125;; &emsp;单链表类的数据成员有头指针、元素个数和当前节点指针。头指针指向头结点，任何对单链表中节点的操作都要从头指针进入。初始化状态下，节点个数为0.当前节点指针是遍历链表成员函数使用的数据成员，遍历链表成员函数通过控制当前节点指针来遍历链表。&emsp;&emsp;单链表类的成员函数由三组：构造函数和析构函数、表操作的成员函数和遍历链表的成员函数。由于单链表类中的节点是通过new函数向系统申请的，在释放单链表类对象的时候，系统无法自行释放这些空间，所以析构函数不能为空，析构函数必须用delete函数逐个释放这些空间。表操作成员函数时对表操作的基本成员函数，这与顺序表类中对表进行操作的成员函数意义相同，但是实现方法不同。链表的遍历操作是每次寻找当前节点的下一个节点，由于每次对链表类中节点的操作都要从头指针进入后寻找到相应的节点后才可完成，这样的单链表类遍历操作的时间复杂度返回大大增加，在单链表中增加一组遍历链表的成员函数可使单链表遍历操作的时间复杂度不增加。 4.单链表类的实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141template&lt;class T&gt;inline LinList&lt;T&gt;::LinList()&#123; head = new ListNode&lt;T&gt;();//头指针指向头结点 size = 0;&#125;template&lt;class T&gt;inline LinList&lt;T&gt;::~LinList()&#123; clearlist(); delete head; head = NULL;&#125;template&lt;class T&gt;inline int LinList&lt;T&gt;::listsize() const//返回单链表中元素的个数&#123; return size;&#125;template&lt;class T&gt;inline bool LinList&lt;T&gt;::listempty() const&#123; return size == 0;&#125;template&lt;class T&gt;inline ListNode&lt;T&gt;* LinList&lt;T&gt;::index(int pos)&#123; if (pos == -1) return head; if (pos&lt;0 || pos&gt;size) &#123; cout &lt;&lt; "illegal operator" &lt;&lt; endl; exit(1); &#125; ListNode&lt;T&gt; *p = head-&gt;next;//p指向第一个节点 int i = 0; while (p != NULL &amp;&amp; i &lt; pos) &#123; p = p-&gt;next; i++; &#125; return p;&#125;template&lt;class T&gt;inline void LinList&lt;T&gt;::insert(const T &amp; item, int pos)&#123; ListNode&lt;T&gt; *p = index(pos - 1); ListNode&lt;T&gt; *newnode = new ListNode&lt;T&gt;(item, p-&gt;next); p-&gt;next = newnode; size++;&#125;template&lt;class T&gt;inline T LinList&lt;T&gt;::Delete(int pos)&#123; if (size == 0) &#123; cout &lt;&lt; "list is empty" &lt;&lt; endl; exit(1); &#125; ListNode&lt;T&gt;*q, *p = index(pos - 1);//p为指向第pos-1个节点的指针 q = p-&gt;next;//q指向要删除节点 p-&gt;next = p-&gt;next-&gt;next;//p指向要删除节点的后一节点 T data = q-&gt;data; //data保存要删除节点值 delete q; size--; return data;&#125;template&lt;class T&gt;inline T LinList&lt;T&gt;::getdata(int pos)&#123; ListNode&lt;T&gt; *p = index(pos);//指针p指向第pos个节点 return p-&gt;data;&#125;template&lt;class T&gt;inline void LinList&lt;T&gt;::clearlist()&#123; ListNode&lt;T&gt; *p, *p1; p = head-&gt;next; while (p != NULL) &#123;//delete所有new出来的空间 p1 = p; p = p-&gt;next; delete p1; &#125; size = 0;&#125;template&lt;class T&gt;inline ListNode&lt;T&gt;* LinList&lt;T&gt;::Reset(int pos)&#123; if (head == NULL) return NULL; if (pos &lt; -1 || pos&gt;size) &#123; cout &lt;&lt; "mistake" &lt;&lt; endl; exit(1); &#125; if (pos == -1) return head; if (pos == 0) &#123; currPtr = head-&gt;next; &#125; else &#123; currPtr = head-&gt;next; ListNode&lt;T&gt; prevPtr = head; for (int i = 0; i &lt; pos; i++) &#123; prevPtr = currPtr; currPtr = currPtr-&gt;next; &#125; &#125; return currPtr;&#125;template&lt;class T&gt;inline ListNode&lt;T&gt;* LinList&lt;T&gt;::Next()&#123; if (currPtr != NULL) &#123; currPtr = currPtr-&gt;next; &#125; return currPtr;&#125;template&lt;class T&gt;inline bool LinList&lt;T&gt;::endOfList() const&#123; return currPtr == NULL;&#125; &emsp;&emsp;这些成员函数基本上实现了单链表所需的基本操作。 5.主函数测试 测试主函数如下： 123456789101112131415161718192021222324252627void test()&#123; LinList&lt;int&gt; list; cout &lt;&lt; "单链表中的元素个数为："&lt;&lt;list.listsize() &lt;&lt; endl; for (int i = 0; i &lt; 10; i++) &#123; list.insert(15 * i, i); &#125; cout &lt;&lt; "单链表中的元素个数为：" &lt;&lt; list.listsize() &lt;&lt; endl; cout &lt;&lt; "5号为：" &lt;&lt; list.getdata(5) &lt;&lt; endl; cout&lt;&lt;list.Delete(5)&lt;&lt;"已被删除"&lt;&lt;endl; cout &lt;&lt; "5号为：" &lt;&lt; list.getdata(5) &lt;&lt; endl; ListNode&lt;int&gt; *p = list.Reset(); while (!list.endOfList()) &#123; cout &lt;&lt; p-&gt;data &lt;&lt; endl; p = list.Next(); &#125;&#125;int main()&#123; test(); system("pause"); return EXIT_SUCCESS;&#125; 输出结果如下：]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>单链表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[运算符重载（2）]]></title>
    <url>%2F2019%2F03%2F24%2F%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD%EF%BC%882%EF%BC%89%2F</url>
    <content type="text"><![CDATA[5.左移(输出）运算符重载 &emsp;&emsp;如我们所知，IO标准库分别使用&gt;&gt;和&lt;&lt;执行输入输出操作。对于这两个运算符来说，IO库定义了其用读写内置类型的版本，但是类则需自定义适合其对象的新版本支持IO操作。&emsp;&emsp;通过情况下左移运算符的第一形参是一个非常量ostream的引用。而ostream是非常量的原因是向流写入内容会改变其状态。而该形参是引用，是因为我们无法直接复制一个ostream对象。&emsp;&emsp;第二个形参一般来说是一个常量的引用，该常量是我们想要打印的类类型。第二个形参是引用的原因是我们希望避免复制实参，而形参为常量是因为打印对象不会改变对象的内容。举例如下： 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;iostream&gt;#include&lt;string&gt;using namespace std;class Person&#123; friend ostream &amp;operator&lt;&lt;(ostream &amp;cout, const Person &amp;p);public: Person(string name, int age);private: string m_name; int m_age;&#125;;Person::Person(string name, int age)&#123; this-&gt;m_name = name; this-&gt;m_age = age;&#125;ostream &amp;operator&lt;&lt;(ostream &amp;cout, const Person &amp;p)&#123; cout &lt;&lt; p.m_name &lt;&lt; "的年龄为：" &lt;&lt; p.m_age &lt;&lt; endl; return cout;&#125;void test()&#123; Person p("Aoki", 20); cout &lt;&lt; p; cout &lt;&lt; "Hello world" &lt;&lt; endl;&#125;int main()&#123; test(); system("pause"); return EXIT_SUCCESS;&#125; 输出结果如下： 6.右移（输入）运算符重载 &emsp;&emsp;通常情况下，输入运算符的第一个形参是运算符简要读取的流的引用，第二个形参是将要读入的非常量对象的引用。该运算符通常会返回某个给定流的引用。第二个形参之所以必须是个非常量是因为输入运算符本身的目的就是将数据读入到这个对象中。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include &lt;iostream&gt;#include&lt;string&gt;using namespace std;class Person&#123; friend istream &amp;operator&gt;&gt;(istream &amp;cin, Person &amp;p);public: Person ()&#123;&#125; Person(string name, int age); void Show();private: string m_name; int m_age;&#125;;Person::Person(string name, int age)&#123; this-&gt;m_name = name; this-&gt;m_age = age;&#125;istream &amp; operator&gt;&gt;(istream &amp; cin, Person &amp; p)&#123; string name; int age; cin &gt;&gt; name &gt;&gt; age; if (cin) &#123; p.m_name = name; p.m_age = age; &#125; else &#123; p = Person();//如果输入失败，对象被赋予默认状态 &#125; return cin;&#125;void Person::Show()&#123; cout &lt;&lt; this-&gt;m_name &lt;&lt; "的年龄是：" &lt;&lt; this-&gt;m_age &lt;&lt; endl;&#125;void test()&#123; Person p1; cin &gt;&gt; p1; p1.Show();&#125;int main()&#123; test(); system("pause"); return EXIT_SUCCESS;&#125; 输出结果如下：&emsp;&emsp;可以注意到，在输入运算符重载中，有输入失败的处理。那么输入时可能会发生什么错误呢？ 当流含有错误类型的数据时读取操作可能失败 当读取操作到达文件末尾或遇到输入流的其他错误时也会失败 &emsp;&emsp;在程序中我们没有逐个检查每个读取操作，而是等读取了所有数据之后赶在使用这些数据前面进行了一次性的检查。&emsp;&emsp;如果在发生错误之前对象已经有一部分改变，则适时地将对象置为合法状态显得异常重要。&emsp;&emsp;通过将对象置为合法状态，我们能保护使用者免受到输入错误的影响。此时的对象处于可用状态，即它的成员都是被正确定义的。而且该对象也不会产生误导性结果，因为它的数据本质上是一致的。 7.指针运算符重载 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879#include &lt;iostream&gt;#include&lt;string&gt;using namespace std;class Person&#123;public: Person(string name, int age); void Display();private: string m_name; int m_age;&#125;;class SmartPointer&#123;public: SmartPointer(Person *person); Person* operator-&gt;(); Person&amp; operator*(); ~SmartPointer();public: Person *pPerson;&#125;;Person::Person(string name, int age)&#123; this-&gt;m_name = name; this-&gt;m_age = age;&#125;void Person::Display()&#123; cout &lt;&lt; this-&gt;m_name &lt;&lt; "的年龄是：" &lt;&lt; this-&gt;m_age &lt;&lt; endl;&#125;SmartPointer::SmartPointer(Person * person)&#123; this-&gt;pPerson = person;&#125;Person * SmartPointer::operator-&gt;()&#123; //重载指针的-&gt;运算符 return pPerson;&#125;Person &amp; SmartPointer::operator*()&#123; //重载指针的*运算符 return *pPerson;&#125;SmartPointer::~SmartPointer()&#123; if (pPerson != NULL) &#123; delete pPerson; &#125;&#125;void test()&#123; Person *person = new Person("Aoki", 20); //如果忘记释放，那么就会造成内存泄漏 SmartPointer poiner(new Person("Aoki", 20)); poiner-&gt;Display();&#125;int main()&#123; test(); system("pause"); return EXIT_SUCCESS;&#125; 输出结果如下： 8.赋值运算符重载 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#define _CRT_SECURE_NO_WARNINGS#include &lt;iostream&gt;#include&lt;string&gt;using namespace std;class Person&#123;public: Person(const char *name); Person&amp; operator=(const Person &amp;p); ~Person();public: char *name;&#125;;Person::Person(const char * name)&#123; this-&gt;name = new char[strlen(name) + 1]; strcpy(this-&gt;name, name);&#125;Person &amp; Person::operator=(const Person &amp; p)&#123; if (this-&gt;name != NULL) &#123;//判断原来堆区中是否有内容，如果有，先释放 delete[] this-&gt;name; this-&gt;name = NULL; &#125; this-&gt;name = new char[strlen(p.name) + 1]; strcpy(this-&gt;name, p.name); return *this;&#125;Person::~Person()&#123; if (this-&gt;name != NULL) &#123; delete[] this-&gt;name; this-&gt;name = NULL; &#125;&#125;void test()&#123; Person p1("Aoki"); Person p2("青木"); p1 = p2; cout &lt;&lt; p1.name &lt;&lt; endl; cout &lt;&lt; p2.name &lt;&lt; endl;&#125;int main()&#123; test(); system("pause"); return EXIT_SUCCESS;&#125; 输出结果如下：]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>运算符重载</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[运算符的重载（1）]]></title>
    <url>%2F2019%2F03%2F24%2F%E8%BF%90%E7%AE%97%E7%AC%A6%E7%9A%84%E9%87%8D%E8%BD%BD%EF%BC%881%EF%BC%89%2F</url>
    <content type="text"><![CDATA[写在前面 &emsp;&emsp;运算符重载，就是对已有的运算符重新进行定义，赋予其另一种功能，以适应不同的数据类型。&emsp;&emsp;运算符重载（operator overloading)只是一种“语法上的方便”,也就它只是另一种函数调用的方式。&emsp;&emsp;在C++中，可以定义一个处理类的新运算符。这种定义很像一个普通的函数定义，只是函数的名字由关键字operator及其紧跟的运算符组成。差别仅此而已。它像任何其他函数一样也是一个函数，当编译器遇到适当的模式时，就会调用这个函数。&emsp;&emsp;重载运算符的参数数量与该运算符作用的对象数量一样多。一元运算符有一个参数，二元运算符有两个参数。对于二元运算符来说，左侧运算符对象传递给第一个参数，而右侧运算符对象传递给第二个参数。除了重载的函数调用运算符operator()之外，其他重载运算符不能含有默认实参。&emsp;&emsp;如果一个重载运算符函数时成员函数，则它的第一个（左侧）运算符对象绑定到隐式地this指针上，因此，成员运算符函数的（显式）参数数量比运算符的运算对象总数少一个。 1.关系运算符重载 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include &lt;iostream&gt;#include&lt;string&gt;using namespace std;class Person&#123;public: Person(string name, int age); bool operator==(Person &amp;p);//==运算符重载 bool operator!=(Person &amp;p);//！=运算符重载 private: string m_Name; int m_Age;&#125;;Person::Person(string name, int age)&#123; this-&gt;m_Name = name; this-&gt;m_Age = age;&#125;bool Person::operator==(Person &amp; p)&#123; if (this-&gt;m_Name == p.m_Name&amp;&amp;this-&gt;m_Age == p.m_Age) &#123; return true; &#125; return false;&#125;bool Person::operator!=(Person &amp; p)&#123; if (this-&gt;m_Name == p.m_Name&amp;&amp;this-&gt;m_Age == p.m_Age) &#123; return false; &#125; return true;&#125;void test()&#123; Person p1("Aoki", 22); Person p2("Aoki", 22); Person p3("Aoki", 20); if (p1 == p2) &#123; cout &lt;&lt; "p1和p2相等" &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; "p1和p2不相等" &lt;&lt; endl; &#125; if (p1 != p3) &#123; cout &lt;&lt; "p1和p3不相等" &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; "p1和p3相等" &lt;&lt; endl; &#125;&#125;int main()&#123; test();&#125; 输出结果如下： 2.自增自减运算符重载 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#include &lt;iostream&gt;#include&lt;string&gt;using namespace std;class Person&#123;public: Person()&#123;&#125; Person(string name, int age); Person operator++();//前置++运算符 Person operator--();//前置--运算符重载 Person operator++(int);//后置++运算符重载 Person operator--(int);//后置--运算符重载 void show();private: string m_Name; int m_Age;&#125;;Person::Person(string name, int age)&#123; this-&gt;m_Name = name; this-&gt;m_Age = age;&#125;Person Person::operator++()&#123; m_Age++; return *this;&#125;Person Person::operator--()&#123; m_Age--; return *this;&#125;Person Person::operator++(int)&#123; Person tmp; tmp.m_Age = this-&gt;m_Age; m_Age++; return tmp;&#125;Person Person::operator--(int)&#123; Person tmp; tmp.m_Age = this-&gt;m_Age; m_Age--; return tmp;&#125;void Person::show()&#123; cout &lt;&lt; this-&gt;m_Name &lt;&lt; "的年龄为" &lt;&lt; this-&gt;m_Age &lt;&lt; endl;&#125;void test()&#123; Person p1("Aoki",22); p1++; p1.show(); p1--; p1.show(); --p1; p1.show(); ++p1; p1.show();&#125;int main()&#123; test(); return 0;&#125; 输出结果如下：优先使用++和–的标准形式，优先调用前置++&emsp;&emsp;如果定义了++c，也要定义c++，递增操作符比较麻烦，因为他们都有前缀和后缀形式，而两种语义略有不同。重载123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&amp;emsp;&amp;emsp;对于++和--而言，后置形式是先返回，然后对象++或--，返回的是对象的原值。前置形式，对象先++或--，然后返回当前对象，返回的是新对象。 &amp;emsp;&amp;emsp;调用代码的时候，要优先使用前缀形式，除非确实需要后缀形式返回的原值，，前缀和后缀形式语义上是等价的，输入工作量也相当，只是效率经常会略高一些，由于前缀形式少创建了一个临时对象。 &lt;br /&gt;&lt;br /&gt;&gt; # 3.加号运算符重载 &lt;br /&gt;```c++#include &lt;iostream&gt;#include&lt;string&gt;using namespace std;class Person&#123;public: Person() &#123;&#125;; Person(string a, int b) :m_name(a), m_age(b) &#123;&#125; Person operator+(Person &amp;p);public: string m_name; int m_age;&#125;;Person Person::operator+(Person &amp; p)&#123; Person tmp; tmp.m_age = this-&gt;m_age + p.m_age; tmp.m_name = this-&gt;m_name + p.m_name; return tmp;&#125;void test()&#123; Person p1(&quot;Ao&quot;, 20); Person p2(&quot;ki&quot;,10); Person p3 = p1 + p2; cout &lt;&lt; &quot;p3的名字为：&quot; &lt;&lt; p3.m_name &lt;&lt; &quot;,p3的年龄为&quot; &lt;&lt; p3.m_age &lt;&lt; endl;&#125;int main()&#123; test(); return 0;&#125; 输出结果如下： 下面也是加号运算符重载的一些方法： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include &lt;iostream&gt;#include&lt;string&gt;using namespace std;class Person&#123;public: Person() &#123;&#125;; Person(string a, int b) :m_name(a), m_age(b) &#123;&#125; //Person operator+(Person &amp;p);public: string m_name; int m_age;&#125;;////Person Person::operator+(Person &amp; p)//&#123;// Person tmp;// tmp.m_age = this-&gt;m_age + p.m_age;// tmp.m_name = this-&gt;m_name + p.m_name;// return tmp;//&#125;Person operator+(Person &amp;p1, Person &amp;p2)&#123; Person tmp; tmp.m_age = p1.m_age + p2.m_age; tmp.m_name = p1.m_name + p2.m_name; return tmp;&#125;Person operator+(Person &amp;p1, int a)&#123; Person tmp; tmp.m_age = p1.m_age + a; tmp.m_name = p1.m_name; return tmp;&#125;void test()&#123; Person p1("Ao", 20); Person p2("ki",10); Person p3 = p1 + p2; Person p4 = p2 + 10; cout &lt;&lt; "p3的名字为：" &lt;&lt; p3.m_name &lt;&lt; ",p3的年龄为" &lt;&lt; p3.m_age &lt;&lt; endl; cout &lt;&lt; "p4的名字为：" &lt;&lt; p4.m_name &lt;&lt; ",p4的年龄为" &lt;&lt; p4.m_age &lt;&lt; endl;&#125;int main()&#123; test(); return 0;&#125; 输出结果如下： 4.减号运算符重载 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include &lt;iostream&gt;#include&lt;string&gt;using namespace std;class Person&#123;public: Person() &#123;&#125;; Person(string a, int b) :m_name(a), m_age(b) &#123;&#125; //Person operator+(Person &amp;p);public: string m_name; int m_age;&#125;;//Person Person::operator+(Person &amp; p)//&#123;// Person tmp;// tmp.m_age = this-&gt;m_age + p.m_age;// tmp.m_name = this-&gt;m_name + p.m_name;// return tmp;//&#125;Person operator-(Person &amp;p1, Person &amp;p2)&#123; Person tmp; tmp.m_age = p1.m_age - p2.m_age; tmp.m_name = p1.m_name + p2.m_name; return tmp;&#125;Person operator-(Person &amp;p1, int a)&#123; Person tmp; tmp.m_age = p1.m_age - a; tmp.m_name = p1.m_name; return tmp;&#125;void test()&#123; Person p1("Ao", 20); Person p2("ki",10); Person p3 = p1 - p2; Person p4 = p2 -1; cout &lt;&lt; "p3的名字为：" &lt;&lt; p3.m_name &lt;&lt; ",p3的年龄为" &lt;&lt; p3.m_age &lt;&lt; endl; cout &lt;&lt; "p4的名字为：" &lt;&lt; p4.m_name &lt;&lt; ",p4的年龄为" &lt;&lt; p4.m_age &lt;&lt; endl;&#125;int main()&#123; test(); return 0;&#125; 输出结果如下:]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>运算符重载</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[友元]]></title>
    <url>%2F2019%2F03%2F23%2F%E5%8F%8B%E5%85%83%2F</url>
    <content type="text"><![CDATA[写在前面 &emsp;&emsp;类的主要特点之一就是数据隐藏，即类的私有成员无法在类的外部（作用域之外）访问。但是，有时候需要在类的外部访问类的私有数据成员，怎么办呢？&emsp;&emsp;解决办法是使用友元函数，友元函数时一种特权函数c，C++允许这个特权函数访问私有成员。这一点我们可以用生活中的例子来看：&emsp;&emsp;比如你的家有客厅，有卧室，客厅是public的，所有来的客人都可以进去，但是你的卧室是私有的，也就是说只有你能进去，但是，你可以允许你的好朋友进去。&emsp;&emsp;程序员可以把一个全局函数、某个类中的成员函数、甚至整个类声明为友元。 1.全局函数做友元函数 友元语法 friend关键字只出现在声明处 其他类、类成员函数、全局函数都可以声明为友元 友元函数不是类的成员，不带this指针 1234567891011121314151617181920212223242526272829303132#include &lt;iostream&gt;#include&lt;string&gt;using namespace std;class Home&#123;public: friend void test(Home *home); Home() &#123; this-&gt;bedroom = "卧室"; this-&gt;sittingroom = "客厅"; &#125; string sittingroom;//客厅private: string bedroom;//卧室 &#125;;void test(Home *home)&#123; cout &lt;&lt; "你的好友正在访问" &lt;&lt; home-&gt;sittingroom &lt;&lt; endl; cout &lt;&lt; "你的好友正在访问" &lt;&lt; home-&gt;bedroom &lt;&lt; endl;&#125;int main()&#123; Home *home=new Home; test(home);&#125; 输出结果如下： 从输出结果可以看出，当全局函数作为声明为友元函数之后，全局函数也可以访问类的私有成员。 2.整个类做友元类 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;iostream&gt;#include&lt;string&gt;using namespace std;class Home&#123;public: friend class Good_Friend; Home() &#123; this-&gt;bedroom = "卧室"; this-&gt;sittingroom = "客厅"; &#125; string sittingroom;//客厅private: string bedroom;//卧室 &#125;;class Good_Friend&#123;public: Good_Friend(string name) &#123; this-&gt;name = name; &#125; void visit() &#123; cout &lt;&lt; "好友"&lt;&lt;this-&gt;name&lt;&lt;"正在拜访" &lt;&lt; this-&gt;home.sittingroom &lt;&lt; endl; cout &lt;&lt; "好友"&lt;&lt;this-&gt;name&lt;&lt;"正在拜访" &lt;&lt; this-&gt;home.bedroom &lt;&lt; endl; &#125;private: Home home; string name;&#125;;void test()&#123; Good_Friend frend("Aoki"); frend.visit();&#125;int main()&#123; test();&#125; &emsp;&emsp;输出结果如下：&emsp;&emsp;将好友类声明为友元类之后，好友类的对象可以访问Home类的私有成员。&emsp;&emsp;在友元类中我们应当注意： 友元关系不能被继承 友元关系是单向的 友元关系不具有传递性 C++是纯面向对象的吗？&emsp;&emsp;如果一个类被声明为friend，意味着它不是这个类的成员函数，却可以是修改这个类的私有成员，而且必须列在类的定义中，因此它是一个特权函数。C++不是完全的面向对象语言，而是一个混合产品。增加friend关键字只是用来解决一些实际问题，这也说明这种语言是不纯的。毕竟C++设计的目的是为了实用性，而不是追求理想的抽象。 -———《Think in C++》 3.成员函数做友元函数 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include &lt;iostream&gt;#include&lt;string&gt;using namespace std;class Home;class Good_Friend&#123;public: Good_Friend(string name); void visit(); void visit2();private: Home *home; string name;&#125;;class Home&#123; friend void Good_Friend::visit();public: Home();public: string sittingroom;private: string bedroom;&#125;;Good_Friend::Good_Friend(string name)&#123; home = new Home; this-&gt;name = name;&#125;void Good_Friend::visit()&#123; cout &lt;&lt; "你的好友" &lt;&lt; this-&gt;name &lt;&lt; "正在访问" &lt;&lt; this-&gt;home-&gt;sittingroom &lt;&lt; endl; cout &lt;&lt; "你的好友" &lt;&lt; this-&gt;name &lt;&lt; "正在访问" &lt;&lt; this-&gt;home-&gt;bedroom &lt;&lt; endl;&#125;void Good_Friend::visit2()&#123; cout &lt;&lt; "你的好友"&lt;&lt;this-&gt;name&lt;&lt;"正在访问" &lt;&lt; this-&gt;home-&gt;sittingroom &lt;&lt; endl; //cout &lt;&lt; "你的好友" &lt;&lt; this-&gt;name &lt;&lt; "正在访问" &lt;&lt; this-&gt;home-&gt;bedroom &lt;&lt; endl;&#125;Home::Home()&#123; this-&gt;sittingroom = "客厅"; this-&gt;bedroom = "卧室";&#125;void test()&#123; Good_Friend frien("Aoki"); frien.visit(); frien.visit2();&#125;int main()&#123; test(); return 0;&#125; &emsp;&emsp;当我们试图使用一个没有声明为Home类友元的成员函数去访问Home的私有成员时，编译器报错如下：正确是输出结果如下：&emsp;&emsp;虽然我现在将visit()函数定义为Home类的友元，但是事情并没有这么简单地结束，因为当我第一次定义友元函数时，编译器莫名其妙地报错。那么，编译器报错的原因是什么呢？&emsp;&emsp;当我尝试着把成员函数的声明与定义分开的时候，编译器显示没有错误。这也就告诉我们，在声明成员函数的时候，将声明与定义分开放，编译器会更好地处理。]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>友元函数</tag>
        <tag>友元类</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++对象模型初探]]></title>
    <url>%2F2019%2F03%2F23%2FC-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B%E5%88%9D%E6%8E%A2%2F</url>
    <content type="text"><![CDATA[1.成员变量和函数的存储 在C语言中，分开来声明，也就说，语言本身并没有支持“数据”和“函数”之间的关联性，我们把这种程序方法称为“程序性的”，由一组“分布在各个以功能为导向的函数中的算法驱动，它们处理的是共同的外部数据。C++实现了“封装”，那么数据（成员属性）和操作（成员函数）是什么样的呢？“数据”和“处理数据的操作（函数）”是分开存储的。 C++中的非静态数据成员直接内含在类对象中，就像C struct一样 成员函数（member function）虽然内含正在class声明之内，却不出现在对象中 每一个非内联成员函数只会的诞生一份函数实例 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include &lt;iostream&gt;using namespace std;class Myclass&#123;public: int m_A;&#125;;class Myclass1&#123;public: int m_A; static int m_B;&#125;;class Myclass2&#123;public: void test01() &#123; cout &lt;&lt; "001" &lt;&lt; endl; &#125;public: static int m_A;&#125;;class Myclass3&#123;public: static void test02() &#123; cout &lt;&lt; "002" &lt;&lt; endl; &#125;public: int m_A; static int m_B;&#125;;class Myclass4&#123;public: void test03() &#123; cout &lt;&lt; "003" &lt;&lt; endl; &#125; static void test04() &#123; cout &lt;&lt; "004" &lt;&lt; endl; &#125;public: int m_A; static int m_B;&#125;;int main()&#123; Myclass myclass; Myclass1 myclass1; Myclass2 myclass2; Myclass3 myclass3; Myclass4 myclass4; cout &lt;&lt; "size of myclass:" &lt;&lt; sizeof(myclass) &lt;&lt; endl; cout &lt;&lt; "size of myclass1:" &lt;&lt; sizeof(myclass1) &lt;&lt; endl; cout &lt;&lt; "size of myclass2:" &lt;&lt; sizeof(myclass2) &lt;&lt; endl; cout &lt;&lt; "size of myclass3:" &lt;&lt; sizeof(myclass3) &lt;&lt; endl; cout &lt;&lt; "size of myclass4:" &lt;&lt; sizeof(myclass4) &lt;&lt; endl; return 0;&#125; 输出结果如下：从输出结果我们可以看出，C++中成员变量和成员属性是分开存储的。 而且，只有非静态成员才属于对象身上。 2.this指针 通过上面的例子我们知道，C++的数据和操作时分开存储的，并且每个非内联成员函数只会诞生一份函数实例，也就是说多个同类型的对象会共用一块代码。那么问题是，这块代码是如何区分是哪个对象调用自己的呢？C++通过提供特殊的对象指针，this指针，来解决上述问题。this指针指向被调用的成员函数所属的对象。C++规定，this指针是隐含在对象成员函数内的一种指针。当一个对象被创建后，它的每一个成员函数都含有一个系统自动生成的隐含指针this，用以保存这个对象的地址。也就是说，虽然我们没有写上this指针，编译器在编译的时候也会加上的。因此，this指针也被称为“指向本对象的指针”，this指针不并不是对象的一部分，并不会影响sizeof（对象）对的结果。this指针是C++实现封装的一种机制，它将对象和该对象调用的非成员函数连接在一起，在外部看来，每个对象都拥有自己的成员函数。一般情况下，并不写this，而是让系统进行默认设置。this指针永远指向当前对象。 成员函数通过this指针即可知道操作的是哪个对象的数据。this指针是一种隐含指针，它隐含于每个类的非静态成员函数中，this指针无须定义，直接使用即可。静态成员函数内部没有this指针，静态成员函数不能操作非静态成员变量。 3.this指针的使用 当形参和成员变量同名时，可用this指针区分 在类的非静态成员函数中返回对象本身，可用return *this 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;iostream&gt;#include&lt;string&gt;using namespace std;class Person&#123;public: Person(string name, int age) &#123;//当形参与成员变量名相同时，可以使用this指针来区分 this-&gt;age = age; this-&gt;name = name; &#125; Person Person_Plus(Person &amp;person) &#123; string newname = this-&gt;name + person.name; int newage = this-&gt;age + person.age; Person newperson(newname, newage); return newperson; &#125; void show() &#123; cout &lt;&lt; "Name:" &lt;&lt; name &lt;&lt; ",Age:" &lt;&lt; age &lt;&lt; endl; &#125;public: int age; string name;&#125;;void test()&#123; Person person("Aoki", 20); person.show(); Person p1("Aoki", 20); Person p2("青木", 15); Person p3 = p1.Person_Plus(p2); p3.show();&#125;int main()&#123; test();&#125; 输出结果如下： 4.const修饰成员函数（常函数） 用const修饰成员函数时，const修饰this指针指向的内存区域，成员函数体内不可以修改本类中的任何普通变量 当成员变量类型符前面用mutable修饰时例外 12345678910111213141516171819202122232425262728293031323334#include &lt;iostream&gt;using namespace std;class Person&#123;public: Person() &#123; this-&gt;m_A = 0; this-&gt;m_B = 0; &#125; void showinfor () const &#123; //this-&gt;m_B = 10; this-&gt;m_A=100; cout &lt;&lt; "m_A=" &lt;&lt;m_A&lt;&lt; endl; cout &lt;&lt; "m_B=" &lt;&lt; m_B&lt;&lt;endl; &#125; mutable int m_A;//如果需要使用常函数修改变量，加mutable关键字 int m_B;&#125;;void test()&#123; Person p1; p1.showinfor();&#125;int main()&#123; test();&#125; 当我们试图使用常函数对成员变量进行修改时，编译器会报错。报错结果如下图：由此可知，常函数不能修改this指针指向的值。那么，当我们需要使用常函数对成员变量进行修改时呢？那么，我们可以在变量前面加mutable关键字。输出结果如下： 5.const修饰对象（常对象） 常对象只能调用const的成员函数 常对象可访问const或非const数据成员，但是不能修改，除非成员用mutable修饰 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;iostream&gt;using namespace std;class Person&#123;public: Person() &#123; this-&gt;m_A = 0; this-&gt;m_B = 0; &#125; void showinfor () const &#123; //this-&gt;m_B = 10; this-&gt;m_A = 100; cout &lt;&lt; "m_A=" &lt;&lt;m_A&lt;&lt; endl; cout &lt;&lt; "m_B=" &lt;&lt; m_B&lt;&lt;endl; &#125; void show() &#123; cout &lt;&lt; "m_A=" &lt;&lt; this-&gt;m_A &lt;&lt; endl; cout &lt;&lt; "m_B=" &lt;&lt; this-&gt;m_B &lt;&lt; endl; &#125; mutable int m_A;//如果需要使用常函数修改变量，加mutable关键字 int m_B;&#125;;void test()&#123; const Person p1; Person p2; p2.show(); p2.showinfor(); p1.showinfor(); //p1.m_B = 100; p1.m_A = 20; //p1.show(); cout &lt;&lt; "m_A=" &lt;&lt; p1.m_A &lt;&lt; endl; cout &lt;&lt; "m_B=" &lt;&lt; p1.m_B &lt;&lt; endl;&#125;int main()&#123; test();&#125; 当我试图使用常对象来对成员变量进行修改时，编译器报错如下：常对象不能修改没有关键字mutable修饰的成员变量，也就是说，如果一个变量被关键字mutable修改时，那么常对象可以对其进行修改。当我试图使用常对象来访问普通成员函数时，编译器报错如下：也就说，常对象不能调用普通成员函数，它只能调用常函数。最终输出结果如下所示： 5.常函数与常对象的总结 常函数 常函数格式：返回类型 函数名（）const{} 常函数不能修改this指针指向的值 如果需要修改，就必须用关键字mutable来修饰成员变量 常对象 常对象就是在对象前加上const修饰符，如 const Person p1 常对象不可以调用普通成员函数 常对象可以调用常函数 常对象可以修改用mutable关键字修饰的成员变量]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>this指针</tag>
        <tag>常函数</tag>
        <tag>常对象</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[静态成员]]></title>
    <url>%2F2019%2F03%2F21%2F%E9%9D%99%E6%80%81%E6%88%90%E5%91%98%2F</url>
    <content type="text"><![CDATA[写在前面 在类定义中，它的成员（包括成员变量和成员函数），这些成员可以用关键字static声明为静态的，称为静态成员。不管这个类创建了多少个对象，静态成员只有一个拷贝，这个拷贝被所有属于这个类的对象共享。 1.静态成员变量 在一个类中，若将一个成员变量声明为static，这种成员变量称为静态成员变量。与一般的数据成员不同，无论建立多少个对象，都只有一个静态数据的拷贝。静态成员变量，属于某个类，所有对象共享。静态变量，是在编译阶段就分配空间，对象还没创建，就已经分配空间。 静态成员变量必须在类中声明，在类外定义 静态数据成员不属于某个对象，在为对象分配空间中不包括静态成员所占的空间 静态数据成员可以通过类名或者对象名来引用 123456789101112131415161718192021222324252627282930313233#include &lt;iostream&gt;using namespace std;class Person&#123;public: static int m_Age;private: static int m_other;&#125;;int Person::m_Age = 100;int Person::m_other = 20;void test()&#123; Person p1; p1.m_Age = 10; cout &lt;&lt; "p1=" &lt;&lt; p1.m_Age &lt;&lt; endl; cout &lt;&lt; "p1的地址为：" &lt;&lt; &amp;p1.m_Age &lt;&lt; endl; Person p2; p2.m_Age = 20; cout &lt;&lt; "p1=" &lt;&lt; p1.m_Age &lt;&lt; endl; cout &lt;&lt; "p2=" &lt;&lt; p2.m_Age &lt;&lt; endl; cout &lt;&lt; "p2的地址为：" &lt;&lt; &amp;p2.m_Age &lt;&lt; endl;&#125;int main()&#123; test();&#125; 输出结果如下图：通过输出结果我们可以很清除地看到，静态成员变量是所有对象共享的。任何一个对象都可以改变静态变量的值，但是静态变量不属于任何一个对象。下面我们看一下对象的大小，以此来说明静态数据成员不属于某个对象，在为对象分配的空间中不包括静态成员所占的空间。 12345678910111213141516171819202122232425#include &lt;iostream&gt;using namespace std;class Person&#123;public: static int m_Age;private: static int m_other;&#125;;int Person::m_Age = 100;int Person::m_other = 20;void test()&#123; Person p; cout &lt;&lt; sizeof(p) &lt;&lt; endl; cout &lt;&lt; sizeof(p.m_Age) &lt;&lt; endl;&#125;int main()&#123; test();&#125; 输出结果如下图：我们可以看出，对象的大小为1，而静态成员佰利联的大小为4。当我们尝试去访问m_other时，编译器会报错，因为它是一个私有数据成员，这也说明了静态成员变量是有权限控制机制的。 2.静态成员变量 在类定义中，前面有static说明的成员函数称为静态成员函数。静态成员函数使用方式和静态变量一样，同样在对象没有创建前创建，即可他通过类名调用。静态成员函数主要为了访问静态变量，但是不能访问普通成员变量。静态成员函数的意义，不在于信息共享，数据沟通，而在于管理静态数据成员，完成对静态数据成员的封装。 静态成员函数只能访问静态变量，不能访问普通成员变量 静态成员函数的使用和静态成员变量一样 静态成员函数也有访问权限 普通成员函数可以访问静态成员变量，也可以访问非静态变量 如上图所示，当我们使用静态成员函数试图访问非静态成员变量时，编译器会报错，提示信息如上图所示。在上图中，我试图使用类名来访问私有的静态成员函数，编译器报错，因为静态成员函数也有自己的权限。 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;iostream&gt;using namespace std;class Person&#123;public: static void func()//静态成员函数 &#123; m_Age = 100; //m_A = 20;//作用域 cout &lt;&lt; "静态成员函数调用" &lt;&lt; endl; &#125; static int m_Age; int m_A;private: static int m_other; static void func01() &#123; cout &lt;&lt; "静态成员函数func2调用" &lt;&lt; endl; &#125;&#125;;int Person::m_Age = 100;int Person::m_other = 20;void test()&#123; Person p1; Person p2; p1.func(); p2.func(); Person::func(); //Person::func01();//作用域&#125;int main()&#123; test();&#125; 输出结果如下图： 3.总结 静态成员变量 编译阶段分配内存 所有对象共享数据 通过对象访问，通过类名访问 有权限控制 类内声明，类外初始化 静态成员函数 可以访问静态成员变量，不可以访问普通成员变量 普通成员函数都可以访问 静态成员函数也有权限 可以通过对象访问，也可以通过类名访问]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>静态成员变量</tag>
        <tag>静态成员函数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[拷贝构造函数]]></title>
    <url>%2F2019%2F03%2F21%2F%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[写在前面 默认情况下，C++编译器至少会为我们写的类增加三个函数 默认构造函数（无参，函数体为空） 默认析构函数（无参，函数体为空） 默认拷贝构造函数，对类中非静态成员属性进行简单的值拷贝 如果用户定义了拷贝构造函数，C++不会再提供任何默认的构造函数 如果用户定义了普通构造函数（非拷贝），C++不再提提供默认无参构造，但是会提供默认拷贝构造。 在之前的博文中，我介绍了构造函数和析构函数，这一篇里面，我会对拷贝构造函数单独进行介绍，并介绍深拷贝、浅拷贝等。 1.拷贝构造函数的调用时机 拷贝构造函数的调用时机如下： 用一个对象初始化另一个对象 对象以值传递的方式给函数参数 函数局部对象以值传递的方式从函数返回 下面，我举例说明： 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;iostream&gt;using namespace std;class MyClass&#123;public: MyClass() &#123; cout &lt;&lt; "默认构造函数" &lt;&lt; endl; &#125; MyClass(int a) &#123; cout &lt;&lt; "有参构造函数" &lt;&lt; endl; &#125; MyClass(const MyClass &amp;m) &#123; cout &lt;&lt; "拷贝构造函数调用" &lt;&lt; endl; &#125; ~MyClass() &#123; cout &lt;&lt; "析构函数调用" &lt;&lt; endl; &#125; int ak;&#125;;void test()&#123; MyClass m1; m1.ak = 10; MyClass m2(m1);//用已经创建好的对象来初始化新的对象&#125;int main()&#123; test();&#125; 输出结果如下图:在上面的例子中，我使用了一个已经创建好的对象来初始化一个新的对象。 这也就是拷贝构造函数对的第一个调用时机。下面是第二个调用时机，即对象以值传递的方式给函数参数。 1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;iostream&gt;using namespace std;class MyClass&#123;public: MyClass() &#123; cout &lt;&lt; "默认构造函数" &lt;&lt; endl; &#125; MyClass(int a) &#123; cout &lt;&lt; "有参构造函数" &lt;&lt; endl; &#125; MyClass(const MyClass &amp;m) &#123; cout &lt;&lt; "拷贝构造函数调用" &lt;&lt; endl; &#125; ~MyClass() &#123; cout &lt;&lt; "析构函数调用" &lt;&lt; endl; &#125; int ak;&#125;;void dowork(MyClass m)//以值传递方式给函数传参&#123;&#125;void test()&#123; MyClass m1; m1.ak = 10; dowork(m1);&#125;int main()&#123; test();&#125; 输出结果如下图: 最后，是函数局部对象以值传递的方式从函数返回。 12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;iostream&gt;using namespace std;class MyClass&#123;public: MyClass() &#123; cout &lt;&lt; "默认构造函数" &lt;&lt; endl; &#125; MyClass(int a) &#123; cout &lt;&lt; "有参构造函数" &lt;&lt; endl; &#125; MyClass(const MyClass &amp;m) &#123; cout &lt;&lt; "拷贝构造函数调用" &lt;&lt; endl; &#125; ~MyClass() &#123; cout &lt;&lt; "析构函数调用" &lt;&lt; endl; &#125; int ak;&#125;;MyClass dowork()//函数局部对象以值传递的方式从函数返回&#123; MyClass m1; return m1;&#125;void test()&#123; MyClass m = dowork();&#125;int main()&#123; test();&#125; 输出结果如下： 2.浅拷贝和深拷贝 浅拷贝同一个类型的对象之间可以赋值，使得两个对象的成员变量的值相同，两个对象仍然是独立的两个对象，这种情况被称为浅拷贝。一般情况下，浅拷贝没有任何副作用，但是当类中有指针，并且指针指向动态内存分配的内存空间，析构函数做了动态内存释放的处理，会导致内存问题。 1234567891011121314151617181920212223242526272829303132333435363738394041424344#define _CRT_SECURE_NO_WARNINGS#include &lt;iostream&gt;using namespace std;class Person&#123;public: Person() &#123; &#125; Person(const char *name, int age) &#123; Name = (char*)malloc(strlen(name) + 1); strcpy (Name, name); Age = age; &#125; ~Person() &#123; cout &lt;&lt; "析构函数调用" &lt;&lt; endl; if (Name != NULL) &#123; free(Name); Name = NULL; &#125; &#125;//系统提供默认拷贝构造函数 char *Name; int Age;&#125;;void test()&#123; Person p1("Aoki", 20); Person p2(p1);&#125;int main()&#123; test();&#125; 输出结果如下：我们可以看到，错误提示信息中提到了heap.cpp。此外，输出结果中出现了两次析构函数的调用。下面，我尝试尽可能地解释清楚原因。我们创建了一个对象p1，它有两个属性，一个存放在堆区，一个在栈区，当编译器进行简单的值拷贝时，只是将堆区内容的地址给了新对象p2，接着调用析构函数，释放p1的空间，而存放在堆区的数据也就消失了，紧接着，对象p2也调用析构函数来进行释放。那么，堆区的同一个地址就被释放了两次，引发了异常。图示如下：这时候，我们就要用到深拷贝了。深拷贝当类中有指针，并且此指针有动态分配空间，析构函数做了释放处理，往往需要自定义拷贝构造函数，自行给指针动态分配空间，深拷贝。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#define _CRT_SECURE_NO_WARNINGS#include &lt;iostream&gt;using namespace std;class Person&#123;public: Person() &#123; &#125; Person(const char *name, int age) &#123; Name = (char*)malloc(strlen(name) + 1); strcpy (Name, name); Age = age; &#125; Person(const Person &amp;p)//深拷贝 &#123; Age = p.Age; Name = (char*)malloc(strlen(p.Name) + 1); strcpy(Name, p.Name); &#125; ~Person() &#123; cout &lt;&lt; "析构函数调用" &lt;&lt; endl; if (Name != NULL) &#123; free(Name); Name = NULL; &#125; &#125; char *Name; int Age;&#125;;void test()&#123; Person p1("Aoki", 20); Person p2(p1);&#125;int main()&#123; test();&#125; 输出结果如下：]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>拷贝构造函数</tag>
        <tag>深拷贝</tag>
        <tag>浅拷贝</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[函数重载]]></title>
    <url>%2F2019%2F03%2F21%2F%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD%2F</url>
    <content type="text"><![CDATA[写在前面 如果同一个作用域内的几个函数名字相同，但是形参列表不同，我们称之为重载函数。实现函数重载的条件： 同一个作用域 参数个数不同 参数类型不同 参数顺序不同 函数的名字仅仅是让编译器知道它调用的是哪个函数，而函数重载在一定程度上可以减轻程序员起名字、记名字的负担。 1.定义重载函数 下面是一个函数重载的例子。函数重载使得我们可以定义一组函数，名字都为func。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;iostream&gt;#include&lt;string&gt;using namespace std;namespace A&#123; void func() &#123; cout &lt;&lt; "没有参数" &lt;&lt; endl; &#125; void func(int a) &#123; cout &lt;&lt; "a=" &lt;&lt; a &lt;&lt; endl; &#125; void func(string a) &#123; cout &lt;&lt; "a=" &lt;&lt; a &lt;&lt; endl; &#125; void func(int a, float b) &#123; cout &lt;&lt; "a=" &lt;&lt; a &lt;&lt; " b=" &lt;&lt; b &lt;&lt; endl; &#125; void func(string a, int b) &#123; cout &lt;&lt; "a=" &lt;&lt; a &lt;&lt; " b=" &lt;&lt; b &lt;&lt; endl; &#125;&#125;void test()&#123; A::func(); A::func(15); A::func("Aoki"); A::func(12, 3.12); A::func("Aoki", 15);&#125;int main()&#123; test();&#125; 输出结果如下：虽然我们定义的是五个函数各不相同，但是它们都有同一个名字。编译器根据实参的类型来决定应该调用哪一个函数。对于重载的函数来说，它们应该在形参数量或形参类型上有所不同。对于函数的重载，我们不能以函数的返回值作为重载的条件，这是为什么呢？当编译器能从上下文中确定唯一的函数时，如int ret=func(),这样就不会有问题。但是我们在编写程序的过程中还可以忽略它的返回值，那么这个时候，一个函数为 void fun(int x),另一个为 int func(int x),当我们直接调用func(10)，这时候编译器就不确定该调用哪个函数。所以，在C++中禁止使用返回值作为重载的条件。 对于函数重载，我们还应当注意避免二义性。举例如下： 1234567891011121314151617181920212223242526272829#include &lt;iostream&gt;#include&lt;string&gt;using namespace std;namespace A&#123; void func(string a) &#123; cout &lt;&lt; "a=" &lt;&lt; a &lt;&lt; endl; &#125; void func(string a, int b=10) &#123; cout &lt;&lt; "a=" &lt;&lt; a &lt;&lt; " b=" &lt;&lt; b &lt;&lt; endl; &#125;&#125;void test()&#123; //A::func("Aoki");//出现二义性&#125;int main()&#123; test();&#125; 错误提示如下：在使用函数重载的同时，我们应该注意避免这种情况出现。 2.调用重载的函数 定义了一组重载函数之后，我们需要以合理的实参来调用它们。函数匹配是指一个过程，在这个过程中我们把函数调用与一组重载函数中的某一个关联起来，函数匹配也叫重载确定。编译器首先将调用的实参与重载集合中对的每一个函数的形参进行比较，然后根据比较的结果决定到底调用哪个函数。在很多情况下，我们很容易判断某次调用是不是合法对的，以及当调用合法时该调用哪个函数。通常，重载集中的函数区别明显，它们要不然是参数的数量不同，要不然就是参数类型毫无关系。此时，确定调用哪个函数比较容易。但是在另外一些情况下要想选择函数就比较困难了。比如当两个重载函数参数数量相同，且参数类型可以相互转换。当调用重载函数时有三种可能的结果： 编译器找到一个与实参最佳匹配的函数，并生成了调用该函数的代码。 找不到任何一个函数与调用的实参匹配，此时编译器发出无匹配的错误信息。 有多于一个函数可以匹配，但是每一个都不是明显的最佳选择。此时也发生错误，称为二义性调用。 3.函数重载实现原理 编译器为了实现函数重载，为我们做了一些幕后的工作，编译器用不同的参数类型来修饰不同的函数名，比如 void func();编译器可能会将函数名修饰成—func，当编译器碰到void func(int x)，编译器可能会将函数名修饰为_func_int,当编译器碰到void func(int x,char c)，编译器可能会将函数名修饰为_func_int_char，这里使用可能，是因为编译器如何修饰重载的函数名称并没有一个统一的标准，所以不同的编译器可能会产生不同的内部名。]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>函数重载</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[构造函数和析构函数]]></title>
    <url>%2F2019%2F03%2F20%2F%E5%87%BD%E6%95%B0%E5%92%8C%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[1.初始化和清理 C++中OO思想也是来源于现实，是对现实事物的抽象模拟，具体来说，当我们常见对象的时候，这个对象应该有一个初始状态，当对象销毁之前应该销毁自己创建的一些数据。对象的初始化和清理也是两个非常重要的安全问题，一个对象或者变量没有初始化时，对其使用后果是未知的，同样的使用完一个变量，，没有及时清理，也会造成一定的安全问题。C++为了给我们提供这种问题的解决方案，构造函数和析构函数。这两个函数将会被编译器自动调用，完成对象初始化和对象清理工作。无论我们是否喜欢这种方式，对象的初始化和清理工作是编译器强制我们必须要做的事情，即使我们不提供初始化操作和清理操作，编译器也会给我们增加默认对的操作，只是这个默认初始化操作不会做任何事，所以编写类就应该顺便提供初始化函数。为什么初始化操作时自动调用而不是手动调用？既然是必然操作，那么自动调用会更好，如果靠我们自觉，那么就会存在遗漏初始化的情况出现。 2.构造函数 构造函数主要作用在于创建时为对象的成员属性赋值，构造函数由编译器自动调用，无须手动调用。构造函数语法： 构造函数函数名和类名相同，没有返回值，不能有void，但可以有参数。 ClassName(){} 3.析构函数 析构函数主要用于对象销毁前系统自动调用，执行一些清理工作。析构函数语法： 析构函数函数名是类名前面加”~”组成，没有返回值，不能有void，不能有参数，不能重载。 ~ClassName（）{} 下面我举例说明构造函数与析构函数。 12345678910111213141516171819202122232425#include &lt;iostream&gt;using namespace std;class Person&#123;public: Person() &#123; cout &lt;&lt; "构造函数调用" &lt;&lt; endl; &#125; ~Person() &#123; cout &lt;&lt; "析构函数调用" &lt;&lt; endl; &#125;&#125;;void test()&#123; Person p1;&#125;int main()&#123; test();&#125; 输出结果如下：从输出结果我们可以看出，在创建对象时，构造函数调用。当对象销毁之前，又调用了析构函数。 4.构造函数的分类及调用 按参数类型：分为无参构造函数和有参构造函数 按类型分类：分为普通构造函数和拷贝构造函数（复制构造函数） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;iostream&gt;using namespace std;class Person&#123;public: Person()//默认，无参构造函数 &#123; cout &lt;&lt; "默认构造函数调用" &lt;&lt; endl; &#125; Person(int a)//有参构造函数调用 &#123; cout &lt;&lt; "有参构造函数调用" &lt;&lt; endl; &#125; //拷贝构造函数 Person(const Person&amp; p) &#123; m_age = p.m_age; cout &lt;&lt; "拷贝构造函数调用" &lt;&lt; endl; &#125; ~Person() &#123; cout &lt;&lt; "析构函数调用" &lt;&lt; endl; &#125; long m_age; static int n_age; &#125;;static int n_age = 100;void test()&#123; Person p1(1);//有参拷贝构造函数调用 p1.m_age = 10; cout &lt;&lt; "p1的年龄为：" &lt;&lt; p1.m_age &lt;&lt; endl; Person p2(p1);//拷贝构造函数调用 cout &lt;&lt; "p2的年龄为：" &lt;&lt; p2.m_age &lt;&lt; endl; Person(100);//匿名对象，当本行代码执行完毕就释放对象 Person p3 = 100;//隐式类型转换，相当于调用了Person p7=Person(100) Person p4 = p3;//拷贝构造函数调用，相当于Person p4=Person(p3)&#125;int main()&#123; test(); return 0;&#125; 输出结果如下：这里，我们需要注意的是，析构函数和构造函数必须写在public下才可以调用。同时，对于无参构造函数（默认构造）、有参构造函数在创建对象时的调用应当注意。当我们我们没有定义构造函数时，系统会给我们提供一个空的默认构造函数，但是当我们定义了无参构造函数时，系统使用我们的构造函数。除此之外，当我们定义了一个有参构造函数，但是并没有提供无参构造函数时，在创建对象的时候必须使用有参构造。原因是，当我们声明一个有参构造函数之后，系统不再提供默认构造函数。]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>析构函数</tag>
        <tag>构造函数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于C语言下的封装和C++语言封装的区别]]></title>
    <url>%2F2019%2F03%2F19%2FC%E8%AF%AD%E8%A8%80%E4%B8%8B%E7%9A%84%E5%B0%81%E8%A3%85%E5%92%8CC-%E8%AF%AD%E8%A8%80%E5%B0%81%E8%A3%85%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[1.封装 我们编写程序来解决现实中的问题，而这些问题的是由各种事物组成的。我们解决这个问题的前提就是将事和物抽象得到计算机程序中，也就是用程序语言表示现实的事物。现实世界的事物所具有的共性就是每个事物都具有自身的属性和行为，所以如果我们能把这些事物的属性和行为表示出来，那么就可以抽象出这个事物。属性和行为应该放在一起，一起来表示一个具有属性和行为的对象。为什么需要这样做呢？我稍后解释。假如某对象的某项属性不想被外界获知，比如女孩子的体重，那么对于体重这个属性，就应该是只有女孩自己知道的属性，或者女孩的某些行为，比如暗恋某个男生，不想让外界知道，只能让自己知道，那么在这种情况下，封装应该提供一种机制，能够给属性和行为的访问权限控制住。所以说封装特性包含两方面，一个是属性和变量合成一个整体，一个是给属性和函数增加访问权限。 封装 把变量（属性）和函数（操作）合成一个整体，封装在一个类中。 对变量和函数进行访问控制。 访问权限 在类的内部（作用域范围之内），没有访问权限之分，所有成员可以相互访问。 在类的外部（作用域范围外），访问权限才有意义：public,private,protected 在类的外部，只有public修饰的成员才能被访问，在没有涉及继承和派生时，private和protected是同等级的，外界不可以访问。 访问属性 属性 对象内部 对象外部 public 公有 可访问 可访问 protected 保护 可访问 不可访问 private 私有 可访问 不可访问 其中，potected为保护权限，类内部可以访问，当前类的子类可以访问，类外部不可以。而private是对象的私有数据，子类和类外部都不可以访问。 下面，我们对比以下C语言下的封装和C++语言下封装的区别。 2.C语言下的封装 在C语言中我们可以定义一个结构体来表示一个对象所包含的属性，函数用来表示出来一个事物，在C语言中，结构体中不能定义函数，所以行为和定义方式分开的，也就是说吃饭这个属性不属于某个对象，而属于所有的共同数据。 1234567891011121314151617181920212223242526272829303132333435363738394041424344#define _CRT_SECURE_NO_WARNINGS#include&lt;stdio.h&gt;#include&lt;string.h&gt;#include&lt;stdlib.h&gt;struct person &#123; char name[10]; int age;&#125;;void PersonEat(struct person *p)&#123; printf("%s在吃饭\n", p-&gt;name);&#125;struct Dog&#123; char name[10]; int age;&#125;;void DogEat(struct Dog *d)&#123; printf("%s在狗粮\n", d-&gt;name);&#125;void test01()&#123; struct Dog one; strcpy(one.name, "旺财"); DogEat(&amp;one); struct person two; strcpy(two.name, "Aoki"); DogEat(&amp;two);&#125;void main()&#123; test01(); system("pause");&#125; 输出结果如下：从输出结果我们可以看出，小狗旺财和Aoki这个人正在一块吃狗粮，但是正常情况下，Aoki怎么可能吃狗粮呢？从这里，我们可以看出在C中封装一个对象造成了什么样的后果。那么，在C++中的封装呢？ 123456789101112131415161718192021222324252627282930313233343536373839#define _CRT_SECURE_NO_WARNINGS#include &lt;iostream&gt;using namespace std;struct Person&#123; char name[10]; int age; void PersonEat() &#123; cout &lt;&lt; name &lt;&lt; "在吃饭" &lt;&lt; endl; &#125;&#125;;struct Dog&#123; char name[10]; int age; void DogEat() &#123; cout &lt;&lt; name &lt;&lt; "在吃狗粮" &lt;&lt; endl; &#125;&#125;;void test()&#123; Person one; strcpy(one.name, "Aoki"); one.PersonEat(); //one.DogEat();&#125;int main()&#123; test();&#125; 刚开始，我尝试了使用one这个对象来调用DogEat这个函数，编译器报错，不允许我们使用它，因为DogEat并不是Person的成员函数。编译器报错如下：在注释掉报错语句之后，正确输出结果如下：从上面的例子中，我们可以看到，C++中的封装，有着严格的类型转换检测，C++让属性和行为绑定在一起。属性和行为作为一个整体来表示生活中的事物。]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>封装</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[宏缺陷和内联函数]]></title>
    <url>%2F2019%2F03%2F18%2F%E5%AE%8F%E7%BC%BA%E9%99%B7%E5%92%8C%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[写在前面 C++从C中继承的一个重要特征就是效率。 在C中我们经常把一些短并且执行频繁的计算写成宏，而不是函数，这样做的理由方式为了执行效率，宏可以避免函数调用的开销，这些都由预处理来完成。 但是在C++出现以后，使用宏处理会出现两个问题： 第一个在C中也会出现，宏看起来像是一个函数调用，但是会隐藏一些难以发现的错误。 第二个问题是C++特有的，预处理器不允许访问类的成员，也就是说预处理器宏不能用作类的成员的函数。 为了保持预处理宏的效率又增加安全性，而且能像一般成员函数那样在类里访问自如，C++引入了内联函数。 内联函数为了继承宏函数的效率，没有函数调用的开销，然后又可以像普通函数那样，可以进行参数、返回值类型的安全检查，又可以作为成员函数。 1.预处理宏的缺陷 预处理器宏存在问题的关键是我们可能认为预处理器的行为和编译器时一样的。当然也是由于宏函数调用和函数调用在外表看起来是一样的，因此也容易混淆。但是其中会有一些微妙的问题出现。 例112345678910111213141516171819202122232425262728293031323334353637#include &lt;iostream&gt;using namespace std;#define ADD(x,y) x+yvoid test()&#123; int ret = ADD(10, 10); int ret0 = ADD(10, 10) * 10;//预期结果为200 cout &lt;&lt; "ret=" &lt;&lt; ret &lt;&lt; endl; cout &lt;&lt; "ret0=" &lt;&lt; ret0 &lt;&lt; endl;&#125;int main()&#123; test();&#125; 输出结果如下： 在输出结果里，我们可以看到，实际输出结果为110，并不是我们想要的结果。它实际进行运算时，运算式应该是：10+10*10。 对于这个微小的问题，我们可以通过加括号的方式来解决它。源代码和输出结果如下： 123456789101112131415161718192021222324252627282930313233#include &lt;iostream&gt;using namespace std;#define ADD(x,y) ((x)+(y))void test()&#123; int ret = ADD(10, 10); int ret0 = ADD(10, 10) * 10;//预期结果为200 cout &lt;&lt; "ret=" &lt;&lt; ret &lt;&lt; endl; cout &lt;&lt; "ret0=" &lt;&lt; ret0 &lt;&lt; endl;&#125;int main()&#123; test();&#125; 输出结果如下： 我们可以看到，加括号之后，输出结果和预期相同。 例2为了防止出现例1中的问题，这次，我特意对三目运算符加了括号。代码如下： 1234567891011121314151617181920212223242526272829303132333435#include &lt;iostream&gt;using namespace std;#define compare(a,b) ((a)&lt;(b))?(a):(b)void test()&#123; int a = 10; int b = 20; int ret = compare(a, b); cout &lt;&lt; "ret=" &lt;&lt; ret &lt;&lt; endl; int ret0 = compare(++a, b); cout &lt;&lt; "ret0=" &lt;&lt; ret0 &lt;&lt; endl;&#125;int main()&#123; test();&#125; 输出结果如下: 这次出现的问题让人有点摸不到头脑，因此++运算符表示在进行运算之前加1，但是输出结果中，实际输出为12，相当于加了两次。 除此之外，我们还应当注意的是，预定义宏函数没有作用域概念，无法作为一个类的成员函数，也就是说，预定义宏没办法表示类的范围。 2.内联函数 在C++中，预定义宏额概念是用内联函数来实现的，而内联函数本身也是一个真正的函数。内联函数具有普通函数的所有行为。唯一不同之处在于内联函数会在适当得到地方像预定义宏一样展开，所以不需要函数调用的开销。因此应该不使用宏，使用内联函数。 普通函数（非成员函数）函数前面加上inline关键字使之成为内联函数。但是必须注意函数体和声明结合在一起，否则编译器会把它当成普通函数对待。 1inline void func(int a); 上面的这种写法没有任何效果，仅仅是声明函数，应该像下面这样的方式来定义。 1234567inline void func(int a)&#123; return ++;&#125; 注意：编译器将会检查函数参数列表使用是否正确，并返回值（进行必要的转换）。这些事预处理器是无法完成的。 内联函数的确占用空间，但是内联函数相对于普通函数的优势只是省去了函数调用是否的压栈、跳转、返回的开销。我们可以理解为内联函数是以空间换时间。 内联说明只是向编译器发出一个请求，编译器可以选择忽略这个请求。 一般来说，内联机制用于优化规模较小、流程直接、频繁调用的函数。很多编译器都不支持内联函数递归函数，而且一个75行的函数也不太可能在调用点内联地展开。]]></content>
      <tags>
        <tag>宏缺陷</tag>
        <tag>内联函数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[函数默认参数及占位参数]]></title>
    <url>%2F2019%2F03%2F18%2F%E5%87%BD%E6%95%B0%E9%BB%98%E8%AE%A4%E5%8F%82%E6%95%B0%E5%8F%8A%E5%8D%A0%E4%BD%8D%E5%8F%82%E6%95%B0%2F</url>
    <content type="text"><![CDATA[1.函数默认参数C++在声明函数原型时可为一个或多个参数指定默认（缺省）的参数值，当函数调用的时候如果没有指定这个值，编译器会自动用默认值代替。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;iostream&gt;using namespace std;void func01(int a = 10, int b = 100)&#123; cout &lt;&lt; "a+b=" &lt;&lt; a + b &lt;&lt; endl;&#125;void func02(int a, int b = 12, int c = 11)&#123; cout &lt;&lt; "a=" &lt;&lt; a &lt;&lt; ",b=" &lt;&lt; b &lt;&lt; ",c=" &lt;&lt; c &lt;&lt; endl;&#125;void func03(int a = 0, int b = 0);void func03(int a, int b)&#123; cout &lt;&lt; "a=" &lt;&lt; a &lt;&lt; ",b=" &lt;&lt; b &lt;&lt; endl;&#125;int main()&#123; func01();//使用默认参数 func01(100, 100);//使用现在传入的参数 func01(110);//只传入一个参数，第二个参数使用默认参数 func02(12);//b，c使用默认参数 func03();//没有传参数，使用默认参数 return 0;&#125; 输出结果如下： 注意点： 函数的默认常数函数从左往右，如果一个参数设置了默认参数，那么这个参数之后的参数都必须设置默认参数。 如果函数声明和函数定义分开写，函数声明与函数定义不能同时设置默认参数。 2.函数的占位符 C++在声明函数时，可以使用占位参数。占位参数只有类型声明，而没有参数名声明。一般情况下，在函数体内无法使用占位参数。 12345678910111213141516171819202122232425262728293031323334353637#include &lt;iostream&gt;using namespace std;void func01(int a,int b,int) &#123; //函数内部无法使用占位参数 cout &lt;&lt; a + b &lt;&lt; endl;&#125;void func02(int a, int b, int = 10)&#123; //无法使用占位参数 cout &lt;&lt; a + b &lt;&lt; endl;&#125;int main()&#123; func01(10, 15, 20); func02(10, 25);//占位参数使用默认参数 return 0;&#125; 输出结果如下：]]></content>
      <tags>
        <tag>默认参数</tag>
        <tag>占位参数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++命名空间及using的使用]]></title>
    <url>%2F2019%2F03%2F16%2FC-%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%E5%8F%8Ausing%E7%9A%84%E4%BD%BF%E7%94%A8-1%2F</url>
    <content type="text"><![CDATA[一、C++命名空间&emsp;在C++中，名称（name）可以是符号常量、变量、函数、结构、枚举、类和对象。工程越大，名称相互冲突性的可能性越大。另外，在使用多个厂商的类库时，也可能导致名称冲突。为了避免冲突，在大规模的设计中，以及程序员使用1各种各样的C++库时，这些标识符的命名发生冲突，标准C++引入关键字namesapce（命名空间/名字空间/名称空间），可以更好的控制标识符得到作用域。 12345678910111213141516171819202122232425262728293031323334353637#include &lt;iostream&gt;using namespace std;//创建一个命名空间namespace study&#123; int a = 10;&#125;namespace learn&#123; int a = 20;&#125;int main()&#123; cout &lt;&lt; "命名空间study的a="&lt;&lt;study::a &lt;&lt; endl; cout &lt;&lt;"命名空间learn的a="&lt;&lt; learn::a &lt;&lt; endl;&#125; 运行结果输出： 在命名空间下，可以定义函数，变量、结构体、类；除此之外，对于命名空间的定义还应当注意，它必须定义在全局作用域下。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include &lt;iostream&gt;#include&lt;string&gt;using namespace std;namespace study&#123; int a = 10; namespace A &#123; int a = 100; void sayhi() &#123; cout &lt;&lt; "hi,Aoki" &lt;&lt; endl; &#125; struct Student &#123; string name; &#125;; &#125;&#125;namespace learn&#123; int a = 20;&#125;int main()&#123; //cout &lt;&lt; "命名空间study的a="&lt;&lt;study::a &lt;&lt; endl; //cout &lt;&lt;"命名空间learn的a="&lt;&lt; learn::a &lt;&lt; endl; study::A::sayhi(); cout &lt;&lt; "作用域A下的a=" &lt;&lt; study::A::a &lt;&lt; endl;&#125; 输出结果： 下面是对命名空间错误定义的举例： 对于命名空间，我们还可以定义无名命名空间，意味着命名空间中的标识符只能在本文件中访问，相当于给这个标识符加上了static，使得其可以作为内部连接。 除此之外，还有就是给命名空间起别名，我们为命名空间A起别名为b，源码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;iostream&gt;#include&lt;string&gt;using namespace std;namespace A&#123; int a = 100; void test() &#123; namespace b = A;//给命名空间起别名为b cout &lt;&lt;"A作用域内a="&lt;&lt; b::a &lt;&lt; endl; &#125;&#125;namespace //无名（匿名）命名空间&#123; int c = 15; int d = 16;&#125;int main()&#123; cout &lt;&lt; "c=" &lt;&lt; c &lt;&lt; endl; cout &lt;&lt; "d=" &lt;&lt; d &lt;&lt; endl; A::test();&#125; 运行结果如下图： 下面对命名空间namespace的用法总结如下： 命名空间的用途：解决名称冲突问题 命名空间下可以定义函数、变量、结构、类 命名空间必须定义在全局作用域下 命名空间可以嵌套命名空间 命名空间是开放的，可以随时给原先的命名空间添加内容 定义另个名字相同的命名空间时，两个命名空间会合并，但是不会覆盖 当我们定义了无名空间时，相当于写了static intc=15，static int d=16，只能在当前文件内使用 二、using声明using声明可使得指定的标识符可用 1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;iostream&gt;using namespace std;namespace One&#123; int test = 100;&#125;void test()&#123; int test = 100; using One::test;//using声明 cout &lt;&lt; "test=" &lt;&lt; test &lt;&lt; endl;&#125;int main()&#123; test();&#125; 此处我们使用了using声明，但是编译却发生了错误。因为在test()中我们定义了一个整型数test，并赋予了初值。当我们使用using声明时，编译器有就近原则，它会选择输出test中定义的整型数，但是又发现有using声明，出现二义性问题，编译器不知道怎么处理，所有报错。报错信息如下： 所以，在using声明中，我们应当注意避免二义性问题。 1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;iostream&gt;using namespace std;namespace One&#123; int test = 100;&#125;void test()&#123; int test = 100; //using One::test;//using声明 cout &lt;&lt; "test=" &lt;&lt; test &lt;&lt; endl;&#125;int main()&#123; test();&#125; 输出结果如下图： using声明的一个例子： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include &lt;iostream&gt;using namespace std;namespace One&#123; int test = 100; int a = 99; int b = 30; void func() &#123; cout &lt;&lt; "hi,Aoki!" &lt;&lt; endl; &#125; void func1() &#123; cout &lt;&lt; "hello,Aoki!" &lt;&lt; endl; &#125;&#125;void test()&#123; cout &lt;&lt; "test=" &lt;&lt; One::a &lt;&lt; endl; //using声明 using One::a; using One::func1; using One::func; cout &lt;&lt; "a=" &lt;&lt; a &lt;&lt; endl; func1(); func();&#125;int main()&#123; test();&#125; 运行结果如下图： 下面是using声明遇到函数重载的一个例子： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include &lt;iostream&gt;using namespace std;namespace Two&#123; void func() &#123; cout &lt;&lt; "Nothing!" &lt;&lt; endl; &#125; void func(int x) &#123; cout &lt;&lt; x &lt;&lt; endl; &#125; void func(int x, int y) &#123; cout &lt;&lt; "x=" &lt;&lt; x ; cout &lt;&lt; ",y=" &lt;&lt; y &lt;&lt; endl; &#125;&#125;void test1()&#123; using Two::func; func(); func(15); func(15, 20);&#125;int main()&#123; test1();&#125; 输出结果如下图： 如果命名空间包含一组用相同名字重载的函数，using声明就声明了这个重载函数的所有集合。 三、using编译指令using编译指令使整个命名空间标识符可用。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879#include &lt;iostream&gt;using namespace std;namespace One&#123; int a = 99; int b = 30; void func() &#123; cout &lt;&lt; "hi,Aoki!" &lt;&lt; endl; &#125; void func1() &#123; cout &lt;&lt; "hello,Aoki!" &lt;&lt; endl; &#125;&#125;void test()&#123; using namespace One; cout &lt;&lt; a &lt;&lt; endl; cout &lt;&lt; b &lt;&lt; endl; func(); func1(); int a = 100;//没有产生二义性 cout &lt;&lt; a &lt;&lt; endl;&#125;namespace Two&#123; int a = 1; int b = 2;&#125;;void test1()&#123; //产生二义性 using namespace One; using namespace Two; cout &lt;&lt; a &lt;&lt; endl;&#125; 当我们像上面一样使用using编译指令时，会出现二义性问题，编译器无法通过编译。错误信息如下： 当我们使用using声明或using编译指令时，会增加命名冲突的可能性。也就是说，如果有命名空间，并在代码中使用作用域解析运算符，则不会出现二义性问题。 例子如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091#include &lt;iostream&gt;using namespace std;namespace One&#123; int a = 99; int b = 30; void func() &#123; cout &lt;&lt; "hi,Aoki!" &lt;&lt; endl; &#125; void func1() &#123; cout &lt;&lt; "hello,Aoki!" &lt;&lt; endl; &#125;&#125;void test()&#123; using namespace One; cout &lt;&lt; a &lt;&lt; endl; cout &lt;&lt; b &lt;&lt; endl; func(); func1(); int a = 100; cout &lt;&lt; a &lt;&lt; endl;&#125;namespace Two&#123; int a = 1; int b = 2;&#125;;void test1()&#123; using namespace One; using namespace Two; //cout &lt;&lt; a &lt;&lt; endl;&#125;int main()&#123; test(); test1();&#125; 输出结果如下： 当我们引入一个全局的using编译指令时，就为该文件打开了命名空间，它不会影响其他的文件，所以可以再每一个实现文件中调整对命名空间的控制。比如，如果发现某一个实现文件中有太多using指令而产生命名冲突，就要对该文件做个简单的改变，通过明确限定或者using声明来消除名字冲突，这样不需要修改其他实现文件。]]></content>
      <tags>
        <tag>命名空间</tag>
        <tag>using的使用</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于const限定符的一些总结]]></title>
    <url>%2F2019%2F03%2F11%2Fconst%E9%99%90%E5%AE%9A%E7%AC%A6%2F</url>
    <content type="text"><![CDATA[写在前面 有时候我们希望定义这样一种变量，它的值不能被改变。例如，用一个变量表示缓冲区的大小。使用变量的好处是我们觉得缓冲区不再合适的时候，很容易对其进行调整。另一方面，也应随时警惕，防止程序一不小心修改了这个值。为了满足这一要求，可以用关键词const对变量的类型加以限定。 在C++中，一个const不必创建内存空间，而在C中，const总是需要一块内存空间。在C++中，是否为const常量分配内存空间依赖于如何使用。一般来说，如果一个const仅仅用来把一个名字用一个值来代替，那么该存储空间就不必创建。 在存储空间没有分配内存的话，在进行完数据类型检查后，为了代码更加有效，值也许会折叠到代码中。不过取一个const地址，或者把它定义为extern，则会为该const创建内存空间。 在C++中，出现在所有函数之外的const作用于整个文件（也就是说它在该文件外部不可见，默认为内部连接，C++中其他标识符一般默认为外部连接。 1.初始化和const const类型的对象能完成非const类型所能完成的大部分操作，但是对于const类型对象的主要限制就是只能在const类型对的对象上执行不改变其内容的操作。 在不改变const对象的操作中还有一种是初始化，如果利用一个对象去初始化另外一个对象，则它们是不是const都无关紧要。 123456789101112#include &lt;iostream&gt;using namespace std;int main()&#123; int i = 12; const int ci = i;//i的值拷贝给了ci int j = ci; cout &lt;&lt; "i=" &lt;&lt; i &lt;&lt; endl; cout &lt;&lt; "ci=" &lt;&lt; ci &lt;&lt; endl; cout &lt;&lt; "j=" &lt;&lt; j &lt;&lt; endl;&#125; 输出结果如下： ![](https://i.imgur.com/RpcPLLp.png) 2.const引用 可以把引用绑定到const对象上，就像绑定到其他对象上一样，我们称之为——常量引用。 与普通引用不同的是，对常量的引用不能被用作修改它所绑定的对象。 错误示范如下： 3.初始化和对const的引用 引用的类型必须与其所引用对象的类型一致，但是有两个情况例外。第一个例外情况就是在初始化常量引用时，允许用任意表达式作为初始值，只要该表达式的结果能转化成引用的类型即可。 允许一个常量引用绑定非常量的对象、字面值、甚至是一般表达式。 123456789101112131415#include &lt;iostream&gt;using namespace std;int main()&#123; int i = 42; const int &amp;r1 = i;//允许将const int &amp;绑定到一个普通int对象上 const int &amp;r2 = 42;//r1是一个常量引用 const int &amp;r3 = r1 * 2;//r3是一个常量引用 cout &lt;&lt; "i=" &lt;&lt; i &lt;&lt; endl; cout &lt;&lt; "r1=" &lt;&lt; r1 &lt;&lt; endl; cout &lt;&lt; "r2=" &lt;&lt; r2 &lt;&lt; endl; cout &lt;&lt; "r3=" &lt;&lt; r3 &lt;&lt; endl;&#125; 输出结果如下： 4.对cons的引用可能引用一个并非const的对象 12345678910111213141516171819#include &lt;iostream&gt;using namespace std;int main()&#123; int i = 42; int &amp;r1 = i;//引用r1绑定对象i const int &amp;r2 = i;//常量引用r2绑定i，但是r2不能修改i的值 cout &lt;&lt; "i=" &lt;&lt; i &lt;&lt; endl; cout &lt;&lt; "r1=" &lt;&lt; r1 &lt;&lt; endl; cout &lt;&lt; "r2=" &lt;&lt; r2 &lt;&lt; endl; r1 = 10; cout &lt;&lt; "i=" &lt;&lt; i &lt;&lt; endl; cout &lt;&lt; "r1=" &lt;&lt; r1 &lt;&lt; endl; cout &lt;&lt; "r2=" &lt;&lt; r2 &lt;&lt; endl; //r2 = 5;//此处报错，因为r2是一个常量引用&#125; 输出结果如下： 对于常量引用来说，一般情况下是没有办法来对它进行修改的，但是可以使用下面的方法来尝试对常量引用进行修改。代码图如下： 1234567891011#include &lt;iostream&gt;using namespace std;int main()&#123; const int &amp;ref = 10; cout &lt;&lt; "ref=" &lt;&lt; ref &lt;&lt; endl; int *p = (int *)&amp;ref; *p = 100; cout &lt;&lt; "ref=" &lt;&lt; ref &lt;&lt; endl;&#125; 输出结果如下：这里我们使用了一个指针来对常量引用进行修改。首先，我们要知道的是，常量引用不是一个对象，编译器并没有给它分配内存空间。当我们使用指针指向常量引用时，编译器会给常量引用临时开辟一块内存空间。代码示意如下： 12int tmp=ref;//tmp有内存int *p=(int *)&amp;ref;//*p指向的是那块临时空间，临时空间看不到 5.指针和const 与引用一样，也可以令指针指向常量或非常量。类似于常量引用，指向常量的指针不能改变其所指对象的值。要想存放常量对象的地址，只能使用指向常量的指针。 实例代码如下： 123456789101112131415#include &lt;iostream&gt;using namespace std;int main()&#123; const int i = 10; //int *r1 = &amp;i;//报错，r1是一个普通指针，并不能指向一个常量 const int *r2 = &amp;i;//常量指针指向常量 //常量指针可以指向常量，但是并不能修改常量的值 cout &lt;&lt; "常量i的地址为：" &lt;&lt; &amp;i &lt;&lt; endl; cout &lt;&lt; "r2指向的地址为：" &lt;&lt; r2 &lt;&lt; endl; cout &lt;&lt; "i=" &lt;&lt; i &lt;&lt; endl; cout &lt;&lt; "r2=" &lt;&lt; *r2 &lt;&lt; endl;&#125; 输出结果如下： 6.const指针 指针是对象而引用不是，就像其他对象类型一样，允许把指针本身定义为常量。常量指针必须初始化，而且一旦初始化完成，则它的值（也就是存放在指针中的那个地址）就不能再修改。把*放在const关键字之前用以说明指针是一个常量。这样书写的意味着，不变的是指针本身的值，而不是指向的那个值。 12345678910111213141516#include &lt;iostream&gt;using namespace std;int main()&#123; int i = 10; int *const r1 = &amp;i;//r1将一直指向i const int i1 = 11; const int *const r2 = &amp;i1;//r2是指向常量的常量指针 cout &lt;&lt; "i=10时地址为：" &lt;&lt; &amp;i &lt;&lt; endl; cout &lt;&lt; "常量指针r1指向的地址为：" &lt;&lt; r1 &lt;&lt; endl; i = 100; cout &lt;&lt; "i=100时地址为：" &lt;&lt; &amp;i &lt;&lt; endl; cout &lt;&lt; "常量指针r1指向的地址为：" &lt;&lt; r1 &lt;&lt; endl;&#125; 输出结果如下： 7.顶层const 指针本身就是一个对象，它又可以指向1另外一个对象。因此指针本身是不是常量，以及指针指向的对象是不是一个常量是两个独立的问题。 顶层const表示指针本身是一个常量。 底层const表示指针所指的对象时一个常量。 更一般地，顶层const可以表示任意的对象时常量，这一点对任何数据类型都适用，如算术类型、类、指针等。底层const则与指针和引用等符合类型的基本类型有关。比较特殊的是，指针类型既可以是顶层const，也可以是底层const。 8.尽量使用const代替#define 在旧版本的C中，如果想建立一个常量，必须使用预处理器。 1#define MAX 1024; 这里我们定义的宏MAX从未被编译器看到过，因为在预处理阶段，所有的MAX已经全部被替换成了1024，于是MAX并没有将其加入符号表中。但是我们使用这个常量获得一个编译错误信息时，可能会带来一些困扰，因为这个信息可能会提到1024，但是并没有提到MAX。如果MAX被定义在一个不是我们自己写的头文件中，我们可能并不知道1024代表着什么，也许解决这个问题需要很长的时间。解决这个问题的办法就是用一个常量来替换掉上面的宏： 1const int MAX=1024； 1#undef A //卸载宏常量A ###const和#define的区别 const有类型，可进行编译器类型安全检查，#define无类型，不可进行类型检查 const有作用域，而#define不重视作用域，默认定义处到文件末尾，如果定义在指定作用域下有效的常量，那么#define就不能用。]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>限定符</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++复合类型]]></title>
    <url>%2F2019%2F03%2F09%2FC-%E5%A4%8D%E5%90%88%E7%B1%BB%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[复合类型是指基于其他类型定义的类型。C++有几种复合类型，下面主要是引用和指针。 定义复合类型的变量复杂很多，通用的描述为：一条声明语句由一个基本数据类型和紧随其后的一个声明符列表组成。每个声明符命名了一个变量并指定该变量为与基本数据类型有关的某种类型。 引用 C++11中新增加了一种引用，为右值引用，主要用于内置类。这里，我们使用引用时，指的是左值引用。 引用为对象起了另外一个名字，引用类型引用另外一种类型。通过将声明符写成&amp;d的形式来定义引用类型，其中d是声明的变量名。引用即别名，并非对象，它只是为一个已经存在的对象所起的另外一个名字。下面是引用的一个例子。 123456789101112#include &lt;iostream&gt;using namespace std;int main()&#123; int vale = 1024; int &amp;vale00 = vale; //注意：引用必须进行初始化 cout &lt;&lt; "vale的值为：" &lt;&lt; vale &lt;&lt; endl; cout &lt;&lt; "vale00的值为：" &lt;&lt; vale00 &lt;&lt; endl; cout &lt;&lt; "vale00是vale的引用。" &lt;&lt; endl;&#125; 定义了一个引用之后，对其进行的所有操作都是在与之绑定的对象上进行的。为引用赋值，实际上是把值赋给了与引用绑定的对象。获取引用的值，实际上是获取到了与之绑定的对象的值。同理，以引用作为初始值，实际上是以引用绑定的对象作为初始值。 1234567891011121314#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;int main()&#123; string name = "青木"; string &amp;name_ = name; string name0 = "Aoki"; cout &lt;&lt; "大家好，我的名字是" &lt;&lt; name_ &lt;&lt; endl; cout &lt;&lt; "大家好，我是" &lt;&lt; name0 &lt;&lt; endl; name0 = name_;//为引用赋值 cout &lt;&lt; "大家好，我现在是" &lt;&lt; name0 &lt;&lt; endl;&#125; 输出结果为： 引用 指针是指向另外一种类型的复合类型。与引用类似，指针也实现了对其他对象的间接访问，但是指针与引用也有很多不同点，如下： 指针本身就是个对象，允许对指针赋值和拷贝，在指针的生命周期内，它可以先后指向几个不同的对象 指针无须在定义时赋初值。和其他内置类型一样，在块作用域内定义的指针如果没有定义，也将拥有一个不确定的值。 >## 获取对象的地址 指针存放某个对象的地址，要向获取该地址，就要使用取地址符（&amp;）。在声明语句中，指针的类型实际上被用于它所指向的对象的类型，所以二者必须匹配。如果指针指向了一个其他类型的对象，对该对象的操作将会发生错误。 123456789101112#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;int main()&#123; string name = "青木"; string* name_=&amp;name;//name_存放变量name的地址，或者说name_是指向变量name的指针 cout &lt;&lt; "大家好，我的名字是" &lt;&lt; name &lt;&lt; endl; cout &lt;&lt; "name的地址为:" &lt;&lt; name_ &lt;&lt; endl; cout &lt;&lt; "大家好，我的名字是" &lt;&lt; name_ &lt;&lt; endl;&#125; 输出结果为： 指针值 指针的值（即地址）应属于下列4中状态之一： 指向一个对象 指向紧邻对象所占空间的下一个位置 空指针，意味着指针没有指向任何值 无效指针，就是上述状态之外的其他值。 对于无效指针，试图拷贝或以其他方式访问无效指针的值都将引发错误。 >## 利用指针访问对象 如果一个指针指向了一个对象，则允许使用解引用符（*）来访问该对象。对指针解引用会得到所指的对象，因此如果给解引用的结果赋值，实际上也就是给指针所指的内容赋值。 注意：解引用操作仅适用于那些确实指向了某个对象的有效指针。 12345678910111213141516#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;int main()&#123; string name = "青木"; string name0 = "Aoki"; string* name_=&amp;name;//name_存放变量name的地址，或者说name_是指向变量name的指针 cout &lt;&lt; "大家好，我的名字是" &lt;&lt; name &lt;&lt; endl; cout &lt;&lt; "name的地址为:" &lt;&lt; name_ &lt;&lt; endl; cout &lt;&lt; "大家好，我的名字是" &lt;&lt; *name_ &lt;&lt; endl;//指针解引用，获取对象的值 *name_ = name0;//经由指针为name赋值 cout &lt;&lt; "大家好，我的名字是" &lt;&lt; name &lt;&lt; endl; cout &lt;&lt; "大家好，我的名字是" &lt;&lt; *name_ &lt;&lt; endl;&#125; ![](https://i.imgur.com/lno4Q9r.png) 空指针 空指针不指向任何对象，在试图使用一个指针之前，代码可以首先检查它是否为空。生成空指针的方法： 12int* p1=nullptr;//等价于int* ptr=0int* p2=0;//直接将p2初始化为字面常量0 得到空指针最直接的办法是使用字面值nullptr来初始化指针。nullptr是一种特殊的指针，它可以被转换成任意其他指针类型。 赋值和指针 指针额引用都能够提供对其他的对象的间接访问，但是在具体的实现细节上两者有很大不同，其中最主要的又掉了是引用本身并不是一个对象。指针和它存放的地址之间没有这种限制。和其他任何变量一样，给指针赋值就是令它存放一个新地址，从而指向一个新对象。对于指针的赋值，前文已经给出。 其他指针操作 只要指针拥有一个合法值，就能将它用在条件表达式中。和采用算术值作为条件遵循的规则一样，如果指针的值是0，条件取false。对于两个类型相同的合法指针，可以用相等操作符或不相等操作符来比较它们，比较的结果是布尔类型。两个指针存放的地址值相同（两个指针相等），有三种可能： 它们都为空 都指向同一个对象 都指向同一个对象的下一个地址 1234567891011121314#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;int main()&#123; string name = "青木"; string* name_=&amp;name;//name_存放变量name的地址，或者说name_是指向变量name的指针 int* a = nullptr; if (name_&amp;&amp;a) //与运算，一真一假为假 cout &lt;&lt; "大家好，我是指向" &lt;&lt; name &lt;&lt; "的指针，我不为空" &lt;&lt; endl; else cout &lt;&lt; "大家好，我是空指针a，我的地址是" &lt;&lt; &amp;a &lt;&lt; endl;&#125; 输出结果如下： 最后是void*指针。 void* 指针 void* 指针是一种特殊的指针类型，可用于存放任意对象的指针，一个void指针存放着一个地址。利用void指针可以做的事有： 拿它和别的指针比较 作为函数的输入和输出 赋值给另外一个void*指针 但是我们不能直接操作void* 指针，因为它的类型未知。以void*的视角来看内存空间也仅仅是内存空间，没办法访问内存空间中所存的对象。 12345678910111213#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;int main()&#123; int a = 10; int* name_=&amp;a;//name_存放变量a的地址，或者说name_是指向变量a的指针 void* names; names = name_; cout &lt;&lt; "name_指向的值为：" &lt;&lt; *name_ &lt;&lt;",地址为："&lt;&lt;name_&lt;&lt; endl; cout &lt;&lt; "names地址为：" &lt;&lt; names &lt;&lt; endl;&#125; 输出结果： 对于void* 指针，我还有许多不解的地方，在网上搜索之后发现了一个比较详细解释void* 指针的博文——[void及void指针含义的深刻解析](https://blog.csdn.net/geekcome/article/details/6249151?reload)]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>引用</tag>
        <tag>指针</tag>
        <tag>复合类型</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++变量]]></title>
    <url>%2F2019%2F03%2F08%2F%E5%8F%98%E9%87%8F%2F</url>
    <content type="text"><![CDATA[变量定义 1.初始值不是赋值。初始化的含义是创建变量时赋予其一个初始值。而赋值的含义是把对象当前值擦除，以一个新值来代替。 2.定义可以为分为列表初始化和默认初始化。 变量声明与定义的关系 为了允许把程序拆分成多个逻辑部分来编写，C++语言支持分离式编译机制，该机制允许将程序分隔为若干个文件，每个文件可被独立编译。为了支持分离式编译，C++语言将声明和定义区别开来 声明使得名字为变量所知 定义负责创建与名字关联的实体 123extern int i; //声明i，不是定义 int j;//声明并定义j extern double pi=3.1416;//定义 标识符 C++标识符由字母、数字和下划线组成，其中必须以字母或者下划线开头，标识符的长度没有限制，但是对大小写字母敏感。 以下为变量命名规范： 标识符要能体现实际含义 变量名一般用小写字母，如index 用户自定义类名一般以大写字母开头 如果标识符由多个单词组成，则单词之间要有明显区分 名字的作用域 作用域是程序的一部分，在其中名字有其特定的含义。C++语言中，大多数作用域都以花括号为分隔。 同一个名字在不同的作用域中可能指向不同的实体，名字的有效区域始于名字的声明语句，以声明语句所在的作用域末端为结束。 嵌套的作用域 内层作用域：作用域能彼此包含，被包含的作用域为内层作用域。 外层作用域：包含着别的作用域的作用域。]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>变量</tag>
      </tags>
  </entry>
</search>

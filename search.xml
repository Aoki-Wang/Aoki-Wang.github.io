<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Bridge模式【一】]]></title>
    <url>%2F2019%2FBridge%E6%A8%A1%E5%BC%8F%E3%80%90%E4%B8%80%E3%80%91%2F</url>
    <content type="text"><![CDATA[一、Bridge模式 将抽象部分与它的实现部分分离，使它们都可以独立地变化。 ​ ——《设计模式》 解耦（decouple）：是指让各种事物互相独立地行事，或者至少明确地声明之间地关系。 抽象（abstraction)：是指不同事物之间概念上地联系方式。 一直以为实现就是实际构建抽象的方式。令我不解的是，怎样才能将抽象与其实现的具体方式分离开呢？ 其实我的迷惑主要是因为误解了实现的含义。这里实现指的是抽象类及其派生类用来实现自己的对象（而不是抽象类的派生类，这些派生类被称为具体类）。 二、案例研究假设我接受了一个任务：编写一个程序，使用两个绘图程序之一绘制矩形。我被告知，实例化矩形的时候，它会知道应该使用绘图程序1（DP1)还是绘图程序2（DP2）。 其中矩形是用两对点来定义的。 绘图程序的区别： DP1 DP2 用于画线 draw_a_line(x1,x2,y1,y2) drawline(x1,x2,y1,y2) 用于画圆 draw_a_circle(x,y,r) drawcircle(x,y,r) 分析师做出规定，绘制矩形的代码并不需要操心自己应该使用那种绘制程序。我想到，因为矩形在实例化的时候会知道使用哪个绘图程序，所以可以有两种不同的矩形对象：一种使用DP1，一种使用DP2。每种矩形对象都有一个绘制方法。 通过引入一个抽象类Rectangle，我可以利用这样一个事实，不同Rectangle之间唯一的差异在于如何实现drawLine方法，V1Rectangle类是通过一个DP1对象的引用，使用该DP1对象的draw_a_line方法实现的。V2Rectangle类是通过一个DP2对象的引用，使用该DP2对象的drawline方法实现的。无论这样，通过实例化正确的Rectangle，我不必再操心这种差异。 Rectangle.h 12345678910111213#pragma onceclass Rectangle&#123;public: Rectangle(double, double, double, double); virtual void drawLine(double, double, double, double)=0; void draw();public: ~Rectangle(void);private: double _x1, _x2, _y1, _y2;&#125;; Rectangle.cpp 123456789101112131415161718#include "Rectangle.h"Rectangle::Rectangle(double x1, double y1, double x2, double y2) &#123; _x1= x1; _y1= y1; _x2= x2; _y2= y2;&#125;Rectangle::~Rectangle(void)&#123;&#125;void Rectangle::draw()&#123; drawLine( _x1, _y1, _x2, _y1); drawLine( _x2, _y1, _x2, _y2); drawLine( _x2, _y2, _x1, _y2); drawLine( _x1, _y2, _x1, _y1);&#125; V1Rectangle.h 1234567891011#pragma once#include "Rectangle.h"class V1Rectangle : public Rectangle&#123;public: V1Rectangle(double, double, double, double); void drawLine( double, double, double, double);public: ~V1Rectangle(void);&#125;; V1Rectangle.cpp 123456789101112131415#include "V1Rectangle.h"#include "DP1.h"V1Rectangle::V1Rectangle(double x1, double y1, double x2, double y2) : Rectangle(x1, y1, x2, y2)&#123;&#125;V1Rectangle::~V1Rectangle(void)&#123;&#125;void V1Rectangle::drawLine( double x1, double y1, double x2, double y2)&#123; DP1::draw_a_line( x1, y1, x2, y2);&#125; V2Rectangle.h 1234567891011#pragma once#include "Rectangle.h"class V2Rectangle : public Rectangle&#123;public: V2Rectangle(double, double, double, double); void drawLine( double, double, double, double);public: ~V2Rectangle(void);&#125;; V2Rectangle.cpp 123456789101112131415#include "V2Rectangle.h"#include "DP2.h"V2Rectangle::V2Rectangle(double x1, double y1, double x2, double y2) : Rectangle(x1, y1, x2, y2)&#123;&#125;V2Rectangle::~V2Rectangle(void)&#123;&#125;void V2Rectangle::drawLine( double x1, double y1, double x2, double y2)&#123; DP2::drawline( x1, y1, x2, y2);&#125; DP1.h 1234567891011#pragma onceclass DP1&#123;public: DP1(void); static void draw_a_line( double, double, double, double); static void draw_a_circle( double, double, double);public: ~DP1(void);&#125;; DP1.cpp 123456789101112131415161718#include "DP1.h"DP1::DP1(void)&#123;&#125;DP1::~DP1(void)&#123;&#125;void DP1::draw_a_line( double x1, double y1, double x2, double y2)&#123; // draw the line&#125;void DP1::draw_a_circle( double x, double y, double r)&#123; // draw the circle&#125; DP2.h 1234567891011#pragma onceclass DP2&#123;public: DP2(void); static void drawline( double, double, double, double); static void drawcircle( double, double, double);public: ~DP2(void);&#125;; DP2.cpp 123456789101112131415161718#include "DP2.h"DP2::DP2(void)&#123;&#125;DP2::~DP2(void)&#123;&#125;void DP2::drawline( double x1, double x2, double y1, double y2)&#123; // draw the line&#125;void DP2::drawcircle( double x, double y, double r)&#123; // draw the circle&#125; 现在，假设在代码完成之后。需求发生了变化。我现在需要支持另一种形状——这次是圆形，但是需求还是要求集合对象无需知道Rectangle和Circle的差异。 我想到可以在类层次中增加一层，就可以在已经使用的方法之上进行扩展了。我需要增加一个名为Shape的新类，并从中派生Rectangle类和Circle类。这样，Client对象可以只引用Shape对象，而不必考虑说给的是哪种形状。 例如，我可以从上面的设计开始，然后对每一种Shape类，都用各自的绘图程序实现，为Rectangle类派生一个DP1版本和一个DP2版本，为Circle类也派生一个DP1版本和一个DP2版本。最终的设计如下： 实现Rectangle类的方法与实现Circle类的方式相同，但是，这一次实现draw方法使用的是drawCircle方法，而不是drawLine方法。 Shape.h 12345678910#pragma onceclass Shape&#123;public: Shape(void); virtual void draw()= 0;public: ~Shape(void);&#125;; Shape.cpp 123456789#include "Shape.h"Shape::Shape(void)&#123;&#125;Shape::~Shape(void)&#123;&#125; Circle.h 12345678910111213141516#pragma once#include "Shape.h"class Circle : public Shape&#123;public: Circle(double, double, double); virtual void draw(); virtual void drawCircle(double, double, double)=0;public: ~Circle(void);protected: double _x, _y, _r;&#125;; Circle.cpp 1234567891011121314151617#include "Circle.h"Circle::Circle(double x, double y, double r)&#123; _x= x; _y= y; _r= r;&#125;Circle::~Circle(void)&#123;&#125;void Circle::draw ()&#123; drawCircle( _x, _y, _r);&#125; Rectangle.h 1234567891011121314#pragma once#include "Shape.h"class Rectangle : public Shape&#123;public: Rectangle(double, double, double, double); virtual void drawLine(double, double, double, double)=0; void draw();public: ~Rectangle(void);private: double _x1, _x2, _y1, _y2;&#125;; Rectangle.cpp 123456789101112131415161718#include "Rectangle.h"Rectangle::Rectangle(double x1, double y1, double x2, double y2) &#123; _x1= x1; _y1= y1; _x2= x2; _y2= y2;&#125;Rectangle::~Rectangle(void)&#123;&#125;void Rectangle::draw()&#123; drawLine( _x1, _y1, _x2, _y1); drawLine( _x2, _y1, _x2, _y2); drawLine( _x2, _y2, _x1, _y2); drawLine( _x1, _y2, _x1, _y1);&#125; V1Circle.h 1234567891011#pragma once#include "Circle.h"class V1Circle : public Circle&#123;public: V1Circle(double, double, double); void drawCircle( double, double, double);public: ~V1Circle(void);&#125;; V1Circle.cpp 123456789101112131415#include "V1Circle.h"#include "DP1.h"V1Circle::V1Circle(double x, double y, double r) : Circle( x, y, r)&#123;&#125;V1Circle::~V1Circle(void)&#123;&#125;void V1Circle::drawCircle ( double x, double y, double r)&#123; DP1::draw_a_circle( x, y, r);&#125; V1Rectangle.h 1234567891011#pragma once#include "Rectangle.h"class V1Rectangle : public Rectangle&#123;public: V1Rectangle(double, double, double, double); void drawLine( double, double, double, double);public: ~V1Rectangle(void);&#125;; V1Rectangle.cpp 123456789101112131415#include "V1Rectangle.h"#include "DP1.h"V1Rectangle::V1Rectangle(double x1, double y1, double x2, double y2) : Rectangle(x1, y1, x2, y2)&#123;&#125;V1Rectangle::~V1Rectangle(void)&#123;&#125;void V1Rectangle::drawLine( double x1, double y1, double x2, double y2)&#123; DP1::draw_a_line( x1, y1, x2, y2);&#125; V2Circle.h 1234567891011#pragma once#include "Circle.h"class V2Circle : public Circle&#123;public: V2Circle(double, double, double); void drawCircle( double, double, double);public: ~V2Circle(void);&#125;; V2Circle.cpp 1234567891011121314#include "V2Circle.h"#include "DP2.h"V2Circle::V2Circle(double x, double y, double r) : Circle( x, y, r)&#123;&#125;V2Circle::~V2Circle(void)&#123;&#125;void V2Circle::drawCircle ( double x, double y, double r)&#123; DP2::drawcircle( x, y, r);&#125; V2Rectangle.h 1234567891011#pragma once#include "Rectangle.h"class V2Rectangle : public Rectangle&#123;public: V2Rectangle(double, double, double, double); void drawLine( double, double, double, double);public: ~V2Rectangle(void);&#125;; V2Rectangle.cpp 123456789101112131415#include "V2Rectangle.h"#include "DP2.h"V2Rectangle::V2Rectangle(double x1, double y1, double x2, double y2) : Rectangle(x1, y1, x2, y2)&#123;&#125;V2Rectangle::~V2Rectangle(void)&#123;&#125;void V2Rectangle::drawLine( double x1, double y1, double x2, double y2)&#123; DP2::drawline( x1, y1, x2, y2);&#125; DP1.h 1234567891011#pragma onceclass DP1&#123;public: DP1(void); static void draw_a_line( double, double, double, double); static void draw_a_circle( double, double, double);public: ~DP1(void);&#125;; DP1.cpp 123456789101112131415161718#include "DP1.h"DP1::DP1(void)&#123;&#125;DP1::~DP1(void)&#123;&#125;void DP1::draw_a_line( double x1, double y1, double x2, double y2)&#123; // draw the line&#125;void DP1::draw_a_circle( double x, double y, double r)&#123; // draw the circle&#125; DP2.h 1234567891011#pragma onceclass DP2&#123;public: DP2(void); static void drawline( double, double, double, double); static void drawcircle( double, double, double);public: ~DP2(void);&#125;; DP2.cpp 123456789101112131415161718#include "DP2.h"DP2::DP2(void)&#123;&#125;DP2::~DP2(void)&#123;&#125;void DP2::drawline( double x1, double x2, double y1, double y2)&#123; // draw the line&#125;void DP2::drawcircle( double x, double y, double r)&#123; // draw the circle&#125; 虽然类图中似乎有很多对象，但实际上，只需要处理三个对象： 使用矩形的Client对象 V1Rectangle对象 绘图程序DP1对象 但是，这个办法带来了新的问题。准确地说，这个办法存在“组合爆炸”问题。 对于类图中V1Rectangle这一行的类，表示的是Shape的4个具体类型。 如果我另外还有一个绘图程序，也就是说实现上又有一种新的变化，会怎么样呢？将会有6种不同类型的Shape（具体类型） 如果我还有另一类型的Shape，也就是说另一种概念上的变化，会怎么样呢？将会有9中不同类型的Shape（3个概念上的Shape，3个绘图程序） 于是，类爆炸性增长的问题出现了，因为这个解决方案中抽象（Shape）与其实现（绘图程序）是紧耦合的。每种形状都必须知道自己用的是哪种绘图程序。需要有一种方式将抽象上的变化和实际上的变化分开，从而使类的数量仅仅是线性的增加。 这正是Bridge模式的意图：将抽象与实现解耦，使它们都可以独立地变化。 问问自己这个设计还有什么毛病？ 看上去是否存在冗余？ 是高内聚还是低内聚？ 是紧耦合还是松耦合？ “为每种变化使用不同的特化”（继承）到“将变化转移到使用或拥有这种变化的对象中”（组合）]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>Bridge模式</tag>
        <tag>桥接模式</tag>
        <tag>对象结构型模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Strategy模式]]></title>
    <url>%2F2019%2FStrategy%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[一、Strategy模式 定义一系列的算法，把它们一个个封装起来，并且使他们可相互替换。Strategy模式使算法可独立于使用它的客户而变化。 ​ ——《设计模式》 Strategy模式以下列几条原则为基础： 对象都具有职责 这些职责不同的具体实现使通过多态的使用完成的 概念上相同的算法具有多个不同的实现，需要进行管理 将问题域中的各个行为互相分离开来——也就是说，将它们解耦，使一个好的设计。这使我们可以修改负责某一行为的类，不会对其他类产生不良影响。 二、电子商务系统案例研究我们考虑这样一个国际电子商务订单处理系统。这个系统必须能够处理许多不同国家的订单。 最初的需求在这个系统的总架构中有一个控制器对象，用于处理销售请求。它能够确认何时有人在请求销售订单，并将请求转发给SalesOrder对象进行订单处理。 SalesOrder对象的功能包括： 允许客户通过GUI填写订单 处理税额的计算 处理订单，打印销售收据 处理新的需求如果此时我收到了一个新需求，需要修改处理税额的办法。如果我必须处理国外的订单税额。我至少需要添加新的税额计算规则。 候选方案： 复制和粘贴 使用switch或if语句，用一个变量指定各种情况 使用函数指针或委托（让另一个代表每一种情况） 继承（让派生类用新的方式处理） 将整个功能委托给新的对象。 这里如果使用switch或if等条件语句，分支的流向将会变得模糊。 C++中的函数指针和C#中的委托都可以用来将代码隐藏在精巧、紧凑、内聚的函数之中，但是，函数指针和委托无法维持每个对象的状态，因此其使用也是受限的。 继承经常被人误用，这使它的名声不佳。其实继承本身并没有什么问题。 当面向对象设计成为主流时，“重用”曾经被吹捧为它的主要优点之一。为了实现“重用”，我们总是强调应该找到已有的东西，用派生类的形式对其进行小幅修改。 在我们的这个例子中，可以试图重用现有的SalesOrder对象。我可以将新缴税规则看成新种类的销售订单，只是缴税规则不同。例如，对于加拿大的订单，可以从SalesOrder派生名为CanadianSalesOrder的新类，改写缴税规则。如下所示： 采用这种方法的苦难指出在于，它这次能奏效，但是无法次次奏效。比如，如果要处理德国的订单，或者应对其他方面发生的变化（比如日期格式，语言和运费规则），我们构建的继承层次将无法轻松地应对。诸如此类地反复特化，要么会使代码变得无法理解，要么产生冗余。人们对面向对象设计进程有一种抱怨：特化技术最终总是会产生太深地继承层次。糟糕的是，继承层次太深，会导致程序难以理解（低内聚）、存在冗余、难以测试而且多个概念耦合在一起。无怪乎许多人认为面向对象有些言过其实——尤其是这一切都是因为遵循了通用的面向对象“重用”要求。 根据这种方法，应该这样做： 寻找变化，并将它封装在一个单独的类中 将这个类包含在另一个类中 在本例中，已经确定缴税规则是变化的。“将它封装”就意味着创建一个抽象类定义入股哦在概念上完成税额计算，然后为每种变化派生具体类。也就是说，可以创建一个CalcTax对象，为完成税额计算这一任务定义接口。然后可以由它派生所需的特定版本。 接下来，应该使用组合取代继承，。这意味着用不着再创建不同版本的销售订单（使用继承），可以用组合来包含变化。也就是说，只有一个SalesOrder类，让它包含处理变化的CalcTax类。如下所示： 实现Strategy模式： TaxController.h 1234567891011#include "CalcTax.h"class TaskController&#123;public: TaskController(void); void process(); CalcTax *getTaxRulesForCountry();public: ~TaskController(void);&#125;; TaxController.cpp 1234567891011121314151617181920212223242526272829303132333435include "TaskController.h"#include "SalesOrder.h"#include "CalcTax.h"#include "USTax.h"TaskController::TaskController(void)&#123;&#125;TaskController::~TaskController(void)&#123;&#125;void TaskController::process ()&#123; // this code is an emulation of a // processing task controller // . . . // figure out which country you are in CalcTax *myTax; myTax= getTaxRulesForCountry(); SalesOrder *mySO= new SalesOrder(); mySO-&gt;process( myTax);&#125;CalcTax *TaskController::getTaxRulesForCountry() &#123; // In real life, get the tax rules based on // country you are in. You may have the // logic here or you may have it in a // configuration file // Here, just return a USTax so this // will compile. return new USTax;&#125; SalesOrder.h 12345678910#include "CalcTax.h"class SalesOrder&#123;public: SalesOrder(void); void process (CalcTax *TaxToUse);public: ~SalesOrder(void);&#125;; SalesOrder.cpp 12345678910111213141516171819202122#include "SalesOrder.h"SalesOrder::SalesOrder(void)&#123;&#125;SalesOrder::~SalesOrder(void)&#123;&#125;void SalesOrder::process (CalcTax *taxToUse)&#123; long itemNumber= 0; double price= 0; // given the tax object to use // . . . // calculate tax double tax= taxToUse-&gt;taxAmount( itemNumber, price);&#125; CalcTax.h 12345678class CalcTax&#123;public: CalcTax(void); double virtual taxAmount( long, double)= 0;public: ~CalcTax(void);&#125;; CalcTax.cpp 123456789#include "CalcTax.h"CalcTax::CalcTax(void)&#123;&#125;CalcTax::~CalcTax(void)&#123;&#125; CanTax.h 1234567891011#include "calctax.h"class CanTax : public CalcTax&#123;public: CanTax(void); double taxAmount( long, double);public: ~CanTax(void);&#125;; CanTax.cpp 1234567891011121314151617#include "CanTax.h"CanTax::CanTax(void)&#123;&#125;CanTax::~CanTax(void)&#123;&#125;double CanTax::taxAmount (long itemSold, double price) &#123; // in real life, figure out tax according to // the rules in Canada and return it // here, return 0 so this will compile return 0.0;&#125; USTax.h 12345678910111213#pragma once#include "calctax.h"class USTax : public CalcTax&#123;public: USTax(void); double taxAmount( long, double);public: ~USTax(void);&#125;; USTax.cpp 1234567891011121314151617#include "USTax.h"USTax::USTax(void)&#123;&#125;USTax::~USTax(void)&#123;&#125;double USTax::taxAmount (long itemSold, double price) &#123; // in real life, figure out tax according to // the rules in the US and return it // here, return 0 so this will compile return 0.0;&#125; 这种方法的一个优点在于提高了内聚度。销售税有专门的类进行处理。还有一个优点是：在有新的缴税需求是，只需从CalcTax类派生一个新类予以实现即可。 最后，这种方法使职责的转移更加容易了。例如，在基于继承的方法中，必须由TaskController决定该使用哪个类型的SalesOrder对象。而在新结构中，SalesOrder对象的类型既可以由TaskController对象来决定，也可以由SalesOrder对象决定。为了由SalesOrder对象决定，需要有一个Configuration（配置）对象，使SalesOrder对象知道应该使用哪个税额计算对象，如下图所示： 这种方法也使用了继承，但是，它使用继承的方式与仅仅从SalesOrder派生CandianSalesOrder是不同的。在严格的继承方法中，是通过在SalesOrder继承来处理变化的，而在设计模式所指导的方法中，使用对象聚集（也就是说，SalesOrder中包含一个引用，指向处理变化的功能也就是税额计算的对象。）从SalesOrder（需要扩展的类）的就角度来看，是用组合代替了继承。至于被包含的类如何处理变化，SalesOrder并不关心。 “这种方法不就是将问题向下推了吗？” 首先，这种说法没错，但是这样能够简化更大，更复杂的程序。 其次，原设计在一个类层次（SalesOrder）中装入了许多独立的变量，而在新的方法中将这些变量都放在自己的类层次中，这样就能够独立地分别扩展它们。 最后，在新的方法中，系统的其他部分可以独立于SalesOrder使用或测试这些更小的操作。 总而言之，模式所提倡的方法伸缩性更强，这是原来直接使用继承的方法所不具备的。 这种方法使业务规则能够独立于自己的SalesOrder对象而发生改变。请注意对于目前和未来可能出现的任何情况，这种方法都行之有效。这种”将算法封装在一个抽象类（CalcTax）中，而且在某一时刻能够互换地使用其中之一“的方法，本质上就是Strategy模式。 三、Strategy模式：关键特征 意图：可以根据所处上下文，使用不同的业务规则或算法。 问题：对所需算法的选择取决于发出请求的客户或者要处理的数据。如果只有一些不会变化的算法，就不需要Strategy模式。 解决方案：将对算法的选择和实现分离。允许根据上下文进行选择。 参与者与协作者： Strategy指定了如何使用不同的算法。 各ConcreteStrategy实现了这些不同的算法。 Context通过类型为Strategy的引用使用具体的ConcreteStrategy。Strategy与Context相互作用以实现所选的算法。Conetext将来自Client的请求转发给Strategy。 效果： Strategy模式定义了一系列的算法。 可以不使用switch语句或者条件语句。 必须以相同的方式调用所有的算法（它们必须拥有相同的接口）。各ConcreteStrategy与Conetxt之间的相互作用可能需要在Context中加入获取状态的方法。 实现：让使用算法的类（Context）包含一个抽象类（Strategy），该抽象类有一个抽象方法指定如何调用算法。每个派生类按需要实现算法。 注意：在原型Strategy模式中，选择所用具体实现的职责由Client对象承担，并转给Strategy模式的Context对象。 ​ 四、使用Strategy模式&emsp;&emsp;从技术角度而言，Strategy模式就是用来封装算法的。但是在实践中，它可以用来封装几乎任何类型的规则。 &emsp;&emsp;Strategy模式要求所封装的算法（业务规则）应处在使用它们的类（Context）之外。这意味着Strategy模式所需信息必须要么传递给它们，要么以某种形式获得。 &emsp;&emsp;Strategy模式还简化了单元测试，因为每个算法都有自己的类，可以通过自己的接口单独测试。如果算法不像Strategy模式中那样移出来，Context和Strategy之间的耦合将使测试非常苦难。例如，在实例化Context对象之前可能还有一些前提条件。或者，Context可能通过保护数据成员提供Strategy所需信息。如果同时存在几个不同系列的算法，测试能够进一步简化。这是因为使用Strategy模式，开发人员不需要操心与Context耦合所带来的各种相互作用。也就是说，我们应该能够独立地测试每个算法，而无需担心可能地所有组合情况。]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>Strategy模式</tag>
        <tag>策略模式</tag>
        <tag>对象行为型模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Adapter模式]]></title>
    <url>%2F2019%2FAdapter%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[一、Adapter模式 将一个类的接口转换成客户希望的另外一个接口。Adapter模式使原本由于接口不兼容而不能一起工作的类可以一起工作。 ​ ——《设计模式》 即：我们需要一种方式，为一个功能正确但接口不合的对象创建一个新的接口。 二、学习Adapter模式 假设客户提出的需求为： 为都有“显示”(display)行为的点、线、正方形分别创建类； 客户对象不必知道自己到底拥有点、线还是正方形。他们只需要知道拥有这些形状中的一个。 也就是说，我想要用一个更高层次的概念将这些具体形状都涵盖进入，这个高层概念可以称为“可显示的形状”。 也就是说，尽管系统中有点、线以及正方形，但是我希望客户对象认为只有形状。 这样客户对象可以以相同的方式处理所有对象——无需关注它们的区别。 这样我未来还可以在客户对象不修改的情况下添加新的形状类型。 这里将使用多态，也就是说，我的系统中将有许多不同的对象，但我希望对象的客户与它们交互的方式是通用的。 这里，客户对象只是简单地让点、线或正方形对象进行一些操作，比如“自我显示”或“自我擦除”。然后由每个点、线、正方形负责了解如何按自己的类型完成相应的行为。 为了实现这一点，我创建了一个Shape类，然后从它派生出表示点、线、正方形的类。如下图所示： 首先，我必须指定Shape对象应提供的具体行为。为此，我在Shape类中为这些行为定义了接口，然后在每个派生类中都相应地实现了这些功能。 Shape类需要具备以下行为： 设定一个Shape对象的位置 获取一个Shape对象的位置 显示一个Shape对象 填充一个Shape对象 设置一个Shape对象的颜色 擦除一个Shape对象 假设现在客户要求实现一个圆——一种新的Shape。为此，我创建了一个新的类——Circle类来实现，并从Shape类派生出Circle类，这样我仍然可以获得多态行为。 那么，我必须为Circle类编写display,fill和undisplay方法。但是，我现在找到了一个现有的处理圆形的xxCircle类，但是这个类中的方法命名如下： displayIt fillIt undisplayIt 这里，我不能直接使用xxCircle类，因为我想保持Shape类的多态行为。这有两个原因： 名称和参数列表不同 我无法派生它 而xxCircle无法修改。 既然无法改变，那就想办法适配！ 我可以创建一个新类，它就是派生自Shape类，因此实现了Shape的接口，但是又用不着重写xxCircle类中的圆形的实现代码。 Circle类派生自Shape Circle包含xxCircle Circle将发给自己的请求传送给xxCircle对象。 ![Adapter模式：Circle类包装了xxCircle类](Adapter Circle包装了xxCircle类.PNG) 当Circle对象实例化的时候，它必须实例化一个xxCircle对象。发给Circle对象的任何请求都将转给该xxCircle对象。如果能够总是如此，而且xxCircle对象具有Circle对象所需要的全部功能，Circle对象就可以通过让xxCircle做实际工作来实现自己的行为。 实现Adapter模式： Shape.h 12345678class Shape&#123;public: Shape(void); void virtual display()= 0;public: ~Shape(void);&#125;; Shape.cpp 1234567Shape::Shape(void)&#123;&#125;Shape::~Shape(void)&#123;&#125; Circle.h 12345678910111213#include "Shape.h"#include "XX_Circle.h"class Circle : public Shape&#123;public: Circle(XX_Circle *xxCircle); void display();public: ~Circle(void);private: XX_Circle *myXX_Circle;&#125;; Circle.cpp 12345678910111213141516#include "Circle.h"Circle::Circle(XX_Circle *xxCircle)&#123; myXX_Circle = xxCircle;&#125;Circle::~Circle(void)&#123; delete myXX_Circle;&#125;void Circle::display()&#123; myXX_Circle-&gt;displayIt();&#125; XX_Circle.h 12345678class XX_Circle&#123;public: XX_Circle(void); void displayIt();public: ~XX_Circle(void);&#125;; XX_Circle.cpp 123456789#include "XX_Circle.h"XX_Circle::XX_Circle(void)&#123;&#125;XX_Circle::~XX_Circle(void)&#123;&#125; 三、Adapter模式：关键特征 意图：使控制范围之外的一个原有对象与某个接口匹配。 问题：系统的数据和行为都正确，但接口不符。通常用于必须从抽象类派生时。 解决方案：Adapter模式提供了具有所需接口的包装类。 参与者与协作者：Adapter改变了Adaptee的接口，使Adaptee与Adapter的基类Target匹配。这样Client就可以使用Adaptee了，好像它是Target类型的。 效果：Adapter模式使原有对象能够适应新的类结构，不受其接口的限制。 实现：将原有类包含在另一个类中。让包含类与需要的接口匹配，调用被包容类的方法。 四、Adapter模式与Facade模式 Facade模式 Adapter模式 是否存在既有的类？ 是 是 是否必须按某个接口设计？ 否 是 对象需要多态行为吗？ 否 可能 需要更简单的接口吗？ 是 否 从上表中，我们可以看到以下内容： 在两个模式中，都存在既有的类 但是在Facade模式中，我无须按某个接口进行设计；而在Adapter模式中，则必须按某个特定的接口设计 在Facade模式中，我不需要多态行为，而Adapter模式中，多态行为可能是需要的 Facade模式中的动机是简化接口。而在Adapter模式中，尽管也是越简单越好，但是设计必须遵循一个已有的接口，不能简化任何东西，即使可能存在更简单的接口。 结论：Facade模式简化了接口，而Adapter模式则将一个已有的接口转换成另一个接口。]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>Adapter模式</tag>
        <tag>适配器模式</tag>
        <tag>类对象结构型模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Facade模式]]></title>
    <url>%2F2019%2FFacade%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[一、Facade 模式 为子系统中的一组接口提供一个统一接口。Facade模式定义了一个更高层的接口，使子系统更加容易使用。 ​ ​ ——《设计模式》 即：我们需要用一种比原有方式更简单的办法与系统交互，或者说，我们需要以一种特殊的方式使用系统（例如以二维的方式使用一个三维绘图程序）。 二、Facade 模式：关键特征 意图：希望简化原有系统的使用方式。需要定义自己的接口。 问题：只需要使用某个复杂系统的子集，或者，需要以一种特殊的方式与系统交互。 解决方案：Facade为原有系统的客户提供了一个新的接口。 参与者与协作者：为客户提供一个简单的接口，使系统更容易使用。（接口本身和各个子系统） 效果：Facade模式简化了对所需子系统的使用过程。但是，由于Facade并不完整，因此客户可能无法使用某些功能。 实现： 注意点： 降低客户-子系统之间的耦合度。用抽象类实现Facade而它的具体子类对应于不同的子系统实现，这可以进一步降低客户与子系统的耦合度。 公共子系统与私有子系统。一个子系统与一个类的相似之处是，它们都有接口，并且都封装了一些东西——类封装了状态和操作，而子系统封装了一些类。考虑一个类的公共和私有接口是有益的，我们也可以考虑子系统的公共和私有接口。 子系统的公共接口包含所有的客户程序可以访问的类 私有接口仅用于对子系统进行扩充。 Facade类是公共接口的一部分，但它不是唯一的部分，子系统的其他部分通常也是公共的。 定义一个（或多个）具备所需接口的新类。 让新的类使用原有的系统。 三、Facade模式：实践 假设Client对象必须处理Database，Model，Element对象。Client必须首先通过Database对象打开数据库，获取Model对象，然后再查询Model对象，获取Element对象，最后请求Element对象的信息。如果能够创建一个可供Client查询的Database Facade，那么，以上过程将容易得多。 Facade模式提出了一种通用方法：它为我提供了起点。这个模式的Facade部分实际上就是创建了一种新的接口供客户使用，来替代原有的接口。之所以能够这样做，是因为Client对象并不需要原系统提供的所有功能。 Facade模式还可以用来隐藏或者封装系统。Facade类能够将系统作为自己的私有成员包含进来。在此情况下，原系统将与Facade类联系起来，但Facade类的客户无需看到。 封装系统的原因如下： 跟踪系统的使用情况——通过强制所有系统的访问都必须经过Facade，可以很容易地监视系统地使用情况。 改换系统——未来可能需要切换系统。通过将原系统作为Facade类地一个私有成员，可以最省力地切换到新的系统。]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>Facade模式</tag>
        <tag>外观模式</tag>
        <tag>对象结构型模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UML和类图]]></title>
    <url>%2F2019%2FUML%E5%92%8C%E7%B1%BB%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[一、什么是UML？UML是一种用来创建程序模型的图形语言（即带有语义的一种图形记号）。 1. UML图及其用途 当你在…… 所使用的UML图 分析阶段 用例图，所涉及的是与系统之间交互的实体，以及需要实现的功能点 活动图，关注的是【问题领域和其他主体工作的实际空间，程序的主题领域】的工作流，而不是程序的逻辑流 观察对象的交互 交互图，说明了特定对象如何相互交互。因为它们处理的都是具体情况而不是一般情况，所以在检查需求和设计时都很有用。最常见的一种交互图是顺序图。 设计阶段 类图，详细说明了类之间的关系 观察对象所处状态不同时行为的差异 状态图，详细描述了对象可能所处的不同状态以及在这些状态之间的转换。 配置阶段 部署图，说明如何部署不同模块。 2. 为什么使用UML？ UML主要是用来交流的。 UML提供了一种方法，可以用来确定我对系统的理解是否与其他人相同。因为系统非常复杂，有许多不同种类的信息需要传递，所以UML提供了许多不同的图专门表示不同种类的信息。 二、类图类图不仅描述了类，而且说明了类之间的关系。这些关系可能有以下这些类型： 当一个类是“一种”另一个类时：is-a（是一种/一个）关系 当两个类之间存在关联时： 一个类“包含”另一个类：has-a（拥有一个）关系； 一个类“使用”另一个类：use-a（使用一个）关系； 一个类“创建”另一类 这些类型还有一些变体。比如，说“什么东西包含另一个东西”时，我们可能是指： 被包含者是包含者的一部分（比如汽车中的发动机） 有一个集合，集合中东西可以独立存在（比如机场上的飞机） 第一种情况被称为组合(composition)，第二种情况被称为聚集(aggregation)。 首先，矩形表示一个类。在UML中，可以表示最多三个方面的类的信息： 类名 类的数据成员 类的方法（函数） 表示类的信息有三种不同方式： 最左边的矩形只显示了类名。在不需要更详细信息时，可以使用类的这种表示形式。 中间的举行显示了类名和类的方法。Square类有一个display方法。display前的加号（+）表示此方法是公开的。 最右边的矩形除显示了前面的信息之外，还显示了类的数据成员。 表示访问权限的UML记号： 公开——用一个加号（+）标记。 保护——用一个井号（#）标记。 私有——用一个减号（-）标记。 表示关系的UML记号有如下四种： 类图还可以表示不同类之间的关系。下图显示了Shape类和它的几个派生类之间的关系。 上图说明了几件事： 首先，Shape类下面的箭头的意思是：指向Shape的那些类派生自Shape类。 而且，Shape类的名字使用斜体表示的，说明它是一个抽象类。抽象类是用来为其派生类定义接口而且存放这些派生类共哦那个数据和方法的类。 接口可以看作是没有公共数据和方法的抽象类——它只用来作为一种“为要实现它的那些类的方法进行定义”的方式而已。 如前所述，有两种has-a关系。 一个对象可以拥有另一个对象，其中被包含的对象是包含对象的一部分——或者不是。 在下图中，Airport“拥有”Aircraft。Aircraft并不是Airport的一部分，但仍然可以说Airport拥有Aircraft，这种关系称为聚集或聚合。 jet表示喷气式飞机，Helicopter表示直升飞机。 另一种has-a关系是包含，被包含的对象是包含对象的一部分，这种关系称为组合。 在下图中，Car（轿车）拥有Tire（轮胎），后者是Car的一部分。 下图还显示Car使用了GasStation（加油站）类，这种使用关系用带箭头的虚线表示，也称为依赖。]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>UML</tag>
        <tag>类图</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面向对象泛型]]></title>
    <url>%2F2019%2F%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%B3%9B%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[面向对象泛型以对象概念为中心，一切都集中在对象之上，编写代码时是围绕对象而非函数进行组织的。 使用对象的优点在于，可以定义自己负责自己的事物。对象天生就知道自己的类型。对象中的数据能够告诉它自己的转台如何，而对象中的代码能够使它正确工作。 对象 责任 Student 知道自己所在的教室;知道自己下堂课的教室；从一个教室到下一个教室 Instructor 告诉学生到下堂课的教室去 Classroom 有明确的地址 Direction giver 对于给定的两个教室，指出从一个教室到另一个教室的路线 在这种情况下，对象是通过寻找在问题领域中的实体而被发现的。然后再通过查看这些实体需要做些什么，为每个对象确定责任。这与通过在需求中寻找名词发现对象和通过寻找动词发现方法的技术是一致的。 理解对象的最佳方式，是将其看成“具有责任的东西”。 有一条好的设计规则：对象应该自己负责自己，而且应该清楚地定义责任。 从软件开发过程中的视角观察对象： 在概念层次上，对象是一组责任 在规约层次上，对象是一组可以被其他对象或对象自己调用的方法 在实现层次上，对象是代码和数据，以及它们之间的计算交互。 因为对象具有责任并且自己负责自己，所以必须有方法告诉对象要做什么。对象含有说明自己状态的数据，还有实现必要功能的方法。对象的很多方法都将标识为可被其他对象调用。这些方法的集合就称为对象的公共接口。 面向对象的相关术语： 术语 描述 抽象类（abstract class） 定义了一组相关类的行为。 类(class) 根据对象所具有的责任定义对象的类型。责任可以访问行为和/或状态。这些分别是由方法和/或数据实现的。 具体类(concrete class) 实现抽象类某一特定类型行为的类。具体类是一个概念特定、不变的实现。 封装(encapsulation) 通常定义为数据隐藏，但最好将它看作任何形式的隐藏（类型、实现和设计等等） 继承(inheritance) 一个类继承另一个类，是指它接受了该类的一些或者所有性质。其实类被称为基类、超类、父类或泛化类，而继承类称为派生类、子类或特化类 实例(instance) 类的特例（总是一个对象）。类的特殊实例或实体。每个对象都有自己的状态。因此，同一个类型（类）可以有多个对象。 实例化(instantiation) 创建类的一个实例的过程。 接口(interface) 接口与类类似，但是只为其成员提供规约而不提供实现。它与只含有抽象成员的抽象类很相似。编程的时候，如果需要几个类共享公共基类中没有的一些特性，而且希望确保每个类自己实现这些特定（因为所有成员都是抽象的），就应该使用接口。 视角(perspective) 观察对象有三种视角：概念视角、规约视角和实现视角。这三个不同层次的区别在理解抽象类与其派生类之间的关系上用处很大。抽象类定义了如何在概念层次上解决问题，还提供了与任何派生对象通信的规约。每个派生类都按需要提供特定的实现。 多态(polymorphism) 能够用一种方式引用一个类的不同派生类，但获得的行为对应于所引用的派生类。]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>面向对象泛型</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面向对象泛型之前：功能分解]]></title>
    <url>%2F2019%2F%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%B3%9B%E5%9E%8B%E4%B9%8B%E5%89%8D%EF%BC%9A%E5%8A%9F%E8%83%BD%E5%88%86%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[功能分解方法的一个问题在于，它通常会导致让一个“主“程序负责控制子程序，这是将功能分解为多个子功能的自然结果。但是主程序所承受的责任太多了：要确保一切正常工作，还要协调各函数并控制它们的先后顺序，因此经常会产生非常复杂的代码。如果让一些子函数负责自己的行为，并且能够告诉主函数执行某些任务，并信任它知道如何执行，这种方式比功能分解的方式要容易得多。这就是所谓的委托。 功能分解的另一个问题是，它在为未来可能出现的变化未雨绸缪方面，在对代码合适地改进方面，都于事无补。变化是无可避免的，经常是因为自己要为已有的主题增加新的变体。例如，我可能不得不处理新的形状，或者需要显示形状的新办法。如果将实现各步骤的所有逻辑代码都放在一个大函数或者大模块中的话，那么这些步骤的任何实质性变化，都必须都这个函数或模块进行修改。 内聚性指的是”例程中操作之间的紧密程度“。 耦合性指的是”两个例程之间联系的紧密程度。耦合性与内聚性是相辅相成的关系。内聚性描述的是一个例程内部组成部分之间相互联系的紧密程度，而耦合性描述的是一个例程与其他例程之间联系的紧密程度。软件开发的目标应该是创建这样的例程：内部完成（高内聚），而与其他例程之间的联系则是小巧、直接、可见、灵活的“。 假设你是一个会议的讲师，听课的人课后还要去听其他课，但它们不知道下一堂课的听课地点。你的责任之一，就是确保大家都知道下一堂课去哪里上。 如果按照结构化程序设计的方法，可以这样做: 获得听课人的名字 对于名单上的每个人，做以下工作： 找到他要听的下一节课 找到该课的听课地点 找到从你的教师到下一堂课地点怎么走 告诉这个人怎样去上下一堂课 为了完成上面的工作，你可能需要编写： 获得听课人名单的方法 获得每个人课程表方法 告诉某个人如何从你的教室到其他教室的程序 为听课的每个人服务的一个控制程序，它可以为每个人完成所需的步骤 你可能会把从这个教室到其他教室的路线贴出来，然后告诉课堂上的所有人：”我已经将下一堂课的地点和其他教室的位置都贴在教室后面了。请根据它找到你们下一堂课的教室。“ 可以预期每个人都知道自己的下一堂课是什么，而且他们都能从你提供的列表中查到正确的教室，然后按照指示找到它。 这两种方法的区别何在？ 第一种，直接给没每个人都提供提示，你必须密切关注大量细节，除你之外没有其他人负责。 第二种，你只给出通用的提示，然后期待每个人会自己弄清怎样完成任务。 其中最大的区别就是这样责任的转移 第二种方法有以下三种不同： 人们对自己的行为负责，而不再由一个中央控制程序负责决定他们的行为。 控制程序可以与不同类型的人交流，好像他们都一样。 控制程序不需要知道学生从此教室到彼教室可能采取的任何特殊步骤。 软件开发过程中的视角 视角 描述 概念 这种视角要回答的问题是：”软件要负责什么？“ 规约 考虑软件的接口，而不是实现。这个视角要回答的问题是：”怎么使用软件？“ 实现 这个视角要回答的问题是：”软件怎样履行自己的责任？“]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>面向对象</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[私有docker仓库搭建]]></title>
    <url>%2F2019%2F%E7%A7%81%E6%9C%89docker%E4%BB%93%E5%BA%93%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[一、概述&emsp;&emsp;使用公有仓库，我们可以很方便地分享自己的镜像，也可以使用其他人分享的镜像。但是有时候，公有仓库并不是很适合，比如某些镜像可能只是希望在内部用户间共享，这时可以搭建一个私有的仓库服务器。 &emsp;&emsp;搭建私有的仓库服务器有两种方式：一是使用容器运行docker-registry，二是本地安装运行docker-registry。 &emsp;&emsp;docker-registry是一个基于Python的开源项目，为我们提供了私有镜像服务器的功能。 二、使用容器运行docker-registry 获取官方镜像1docker pull registry 运行registry1docker run -d -p 5000:5000 registry #-d表示表示后台运行，-p表示端口映射 &emsp;&emsp;通过上面的命令，我们的私有服务器就以默认参数运行了。我们也可以配合使用-e和-v参数来该该改变服务器的运行参数。一是配置文件的路径，二是仓库的路径。 配置文件的路径：通过类似下面的命令改变：1docker run -d -p 5000:5000 -v /home/share/registry-conf:/root/registry-conf -e DOCKER_REGISTRY_CONFIG=/root/registry-conf/config.yaml registry 在本地目录/home/share/registry-conf下存放着要使用的配置文件，通过-v参数将它映射到容器的/root/registry-conf目录，使用-e用环境变量的方式指定/root/registry-conf/config.yaml为程序的配置文件。 配置仓库路径：通过类似下面的命令改变：1docker run -d -p 5000:5000 -v /opt/data/registry:/tmp/registry registry 官方镜像使用的仓库路径是/tmp/registry，我们通过把本地路径映射到/tmp/registry。可以让服务器把镜像保存到我们自定义的路径下。 这里我使用的命令是： 1docker run -i -t -p 5000:5000 -v /data/registry:/var/lib/registry --restart=always --name registry registry:latest –restart=always：这是重启策略，加入这个容器异常退出会自动重启容器 –name registry：创建容器命名为registry registry:latest：这是刚刚pull下来的镜像 配置/etc/docker/daemon.json123&#123; "insecure-registries":["192.168.43.114:5000"]&#125; 这里192.168.43.114是私有仓库的IP地址。 其他机器pull私有仓库镜像的时候，也需要在该文件中添加如上内容。 查看镜像仓库中的镜像1curl http://127.0.0.1:5000/v2/_catalog 为镜像打标签1docker tag 镜像名 127.0.0.1:5000/镜像名 上传镜像1docker push 127.0.0.1:5000/镜像名 拉取私有仓库镜像1docker pull 192.168.43.114:5000/镜像名 三、在本地安装运行docker-registry&emsp;&emsp;这里使用的CentOS7。 安装相关依赖库1yum install -y python-devel libevent-devel python-pip gcc xz-devel 安装相关python模块1pip install gunicorn pyyaml flask flask-cors rsa gevent 安装docker-registry1python-pip install docker-registry 启动服务器通过下面的命令，可以启动服务器： 1gunicorn --access-logfile /var/log/docker-registry/access.log --error-logfile /var/log/docker-registry/server.log -k gevent --max-requests 100 --graceful-timeout 3600 -t 3600 -b 127.0.0.1:5000 -w 1 docker_registry.wsgi:application 使用HTTP方式访问本地的5000端口，如果看到类似下面的输出，说明服务器正常运行了。 12curl 127.0.0.1:5000"\"docker-registry server\""]]></content>
      <categories>
        <category>分布式与云计算</category>
      </categories>
      <tags>
        <tag>docker</tag>
        <tag>私有仓库</tag>
        <tag>registry</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[镜像和Dockerfile]]></title>
    <url>%2F2019%2F%E9%95%9C%E5%83%8F%E5%92%8CDockerfile%2F</url>
    <content type="text"><![CDATA[一、镜像与容器 镜像是一个包含程序运行必要依赖环境和代码的只读文件，它采用分层的文件系统，将每一次改变以读写层的形式增加到原来的只读文件上。 镜像是容器运行的基石。如果将容器理解为一套程序运行的虚拟环境，那么镜像就是用来构建这个环境的模板。 镜像的最底层必须是一个称为启动文件系统（bootfs）的镜像，用户不会与这一层直接打交道。bootfs的上层镜像叫做根镜像（rootfs），它在通常情况下是一个操作系统。用户的镜像必须构建于根镜像之上。 镜像的本质是磁盘上的一系列文件的集合。创建新的镜像其实就是对已有经i想文件进行增、删、改、查操作，镜像之间并不是独立的，而是存在单向的文件依赖关系。 镜像的写时复制机制 通过docker run命令指定镜像创建一个容器时，实际上是在该镜像之上创建一个空的可读写文件系统层级。可以将这个文件系统当成一个新的临时镜像，而命令里所指定的镜像称为父镜像。父镜像的内容都是以只读方式挂在进来的，容器会读取父镜像的内容。不过一旦需要修改父镜像文件，便会触发Docker从父镜像中复制这个文件到临时镜像中来，所有的修改均发生在你的文件系统中，而不会对父镜像造成任何影响，这就是Docker镜像的写时复制机制。 二、本地镜像的管理 查看1docker images REPOSITORY：仓库名称 TAG：用于区分同一仓库中的不同镜像。如果未指定，默认为latest IMAGE ID：每个镜像都有一个字符串类型、长为64位的HashID，用来全网标识一个镜像。 CREATED：镜像的创建时间。 VIRTUAL SIZE：镜像所占的虚拟大小，该大小包含所有共享文件的大小。 下载12docker search 镜像名 #在Docker Hub上搜索符合要求的镜像docker pull 镜像名 #拉取镜像 删除1docker rmi 镜像名/镜像ID 删除本地所有镜像： 1docker rm $(docker ps -a -q) 其中，docker ps -a -q命令用来列出所有容器的ID。 三、创建本地镜像 使用commit命令创建本地镜像使用镜像创建并运行一个镜像，实际上是在父镜像的基础上构建一个可读写的文件层级。我们在容器中所做的修改，都发生在这个层级上。 123docker run -i -t centos #在centos镜像上创建运行一个容器#在该容器中安装软件exit #退出该容器 在这里，需要注意的是，要保存当前创建的容器的ID。在退出容器后，执行下面的命令： 1docker commit -m="Message" --author="Aoki" 容器ID aoki/centos:v1 -m参数是描述本次创建的镜像的信息，--author参数用来指定作者信息，aoki表示仓库名，这里需要注意的是，在命名的过程中，有一定的标准，比如不能使用大写字母，centos表示镜像名，v1标识镜像TAG名。 使用Dockerfile创建镜像使用Dockerfile创建镜像是是将所有的配置信息都写入到了一个文件中，然后使用docker build命令来创建一个镜像。这种方法可以使镜像的创建变得透明和独立化，并且创建过程可以被重复执行。Dockerfile文件以行为单位，行首为Dockerfile命令，命令都是大写形式，其后紧跟的是命令的参数。 12345678910111213141516171819202122232425262728293031323334353637383940414243#version: 1.0.1#指定父镜像FROM ubuntu:latestMAINTAINER Aoki "aoki3352@163.com"#设置root用户为后续命令的执行者USER root#执行操作RUN apt-get updateRUN apt-get install -t nginx#使用&amp;&amp;拼接命令RUN touch test.txt &amp;&amp; echo "abc" &gt; abc.txt#对外暴露接口EXPOSE 80 8080 1038#添加文件ADD /webapp /opt/webapp #添加当前文件夹中的/webapp文件到 /opt/webapp目录下#添加网络文件ADD https://www.baidu.com/img/xxxx.png /opt #添加网络文件到/opt目录下#设置环境变量ENV WEBAPP_PORT=9090#设置工作目录WORKDIR /opt#设置启动命令ENTRYPOINT ["ls"]#设置启动参数CMD ["-a","-l"]#设置卷VOLUME ["/data","/var/www"]#设置子镜像的触发操作ONBUILD ADD . /app/srcONBUILD RUN echo "on build excuted" &gt;&gt; onbuild.txt 下面的各个命令的含义： FROM：指定待扩展的父镜像。除了注释之外，在文件开头必须是一个FROM指令，接下来的指令便在这个父级镜像的环境中运行，直到遇到下一个FROM指令。 MAINTAINER：用来声明创建的镜像的作者信息。分别是 用户名、用户邮箱。这个命令不是必须的。 USER：为容器的运行及接下来指令的运行指定用户或UID。 RUN：用来修改镜像的命令，接下来的指令会在新的镜像上继续执行。 EXPOSE：用来指明容器内进程对外开发的端口，多个端口之间使用空格隔开。运行容器时，通过参数-P即可将EXPOSE里所指定的端口映射到主机上另外的随机端口，其他容器或主机就可以通过映射后的端口与此容器进行通信。同时，也可以使用-p参数将EXPOSE没有列出的端口设置成公开。 ADD：向新镜像中添加文件 ADD命令的第一个参数用来指定源文件（夹），可以是文件路径、文件夹路径或网络文件的URL地址，但是需要注意的是，如果是文件（夹）路径的话，必须是Dockerfile文件所在目录的相对路径。 第二个参数是文件需要放置在目标镜像的位置。如果源文件是主机上zip或者tar形式的压缩文件，Docker会先解压缩，然后添加到镜像的指定路径。如果是一个通过URL指定的网络压缩文件，则不会解压。 VOLUME：该命令会在镜像里创建一个指定路径的挂载点，这个路径可以来自主机或者其他容器。多个容器可以通过同一个挂载点共享数据，即便其中一个容器已经停止，挂载点也依然可以访问，只有当挂载点的容器引用全部消失时，挂载点才会自动删除。 WORKDIR：为接下来执行的指令指定一个新的工作目录，这个目录可以是绝对路径，也可以是相对路径。 ENV：设置容器运行的环境变量，在运行容器的时候，通过-e参数可以修改这个环境变量值，也可以添加新的环境变量。 CMD：用来设置启动容器时默认运行的命令。 ENTRYPOINT：与CMD类似，用来指定容器启动时默认运行的命令 ONBUILD：触发器指令。构建镜像的时候，Docker的镜像构建器会将所有的ONBUILD指令指定的命令保存到镜像的元数据中，这些命令在当前镜像的构建过程中并不会执行。只有新的镜像使用FROM指令指定该镜像为父镜像时，便会触发执行。 docker build命令创建构建镜像：1docker build -t aoki/xxx:v1 . -t参数用来指定镜像的命名空间，仓库名和TAG。 命令最后的.表示Dockerfile文件所在的相对路径，这里是指当前路径。]]></content>
      <categories>
        <category>分布式与云计算</category>
      </categories>
      <tags>
        <tag>docker</tag>
        <tag>Dockerfile</tag>
        <tag>镜像</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Docker和容器]]></title>
    <url>%2F2019%2FDocker%E5%92%8C%E5%AE%B9%E5%99%A8%2F</url>
    <content type="text"><![CDATA[一、Docker是什么？Docker是容器的一种，容器是一种轻量级的虚拟技术，和容器对应的更为重量级的虚拟技术是虚拟机。虚拟机是一种基于硬件的虚拟技术，它采用指令级的模拟，完全模拟一整套物理主机。容器是一种基于操作系统的虚拟技术，它运行在操作系统之上的用户空间，所有的容器都共用一个系统内核，甚至是公共库，容器引擎提供进程级别的隔离，让每个容器都像运行在单独的系统之上，但又能共享很多底层资源。 二、Docker的组件Docker采用C/S架构。Docker客户端，即Docker可执行程序，可以通过命令行和API的形式与Docker守候程序进行通信，Docker守候程序提供Docker服务。 Docker包含三大核心组件——镜像，容器和库。 镜像：是一个只读的静态模板。它保存着容器需要的环境和应用的执行代码，可以把镜像看成是容器的代码，当代码运行起来后就成了容器。镜像采用分层机制，每个镜像都是只读的，但是可以将写数据的层通过联合文件系统附加在原有的镜像之上。这种增量式修改使得镜像非常容器存储、传输和更新。 容器：是一个运行时环境，它是一个镜像的运行状态，想到对于静态的镜像而言，容器是镜像执行的动态表现。 库：Docker采用注册服务器来存储和共享用户的镜像，库是某个特定用户存储镜像的目录。通常，一个用户可以建立多个库来保存自己的镜像。如Docker官方的Docker Hub。 三、容器的管理操作 创建容器 docker create 创建的容器处于停止状态 docker run 不仅创建的容器，而且启动了容器 容器创建后，会返回容器的ID。 要想让创建的容器立马进入运行态，可以使用docker run命令，该命令相当于下面的两条命令： 12docker createdocker start 使用docker run命令可以创建两种类型的容器——后台型容器和交互型容器。 交互型容器：运行在前台，通常会指定有交互的控制台，可以给容器输入，也可以得到容器的输出。创建该容器的终端被关闭，在容器内部使用exit命令或者调用了docker stop、docker kill命令后，容器会变成停止状态。 后台型容器：运行在后台，创建启动之后就与终端无关。即便终端关闭了，该后台容器也依然存在，只有调用docker stop或docker kill命令时才能够使容器变成停止状态。 1docker run -i -t --name=inspect_shell ubuntu /bin/bash 其中，-i用于打开容器的标准输入(STDIN),-t告诉Docker为容器建立一个命令行终端。 --name为容器指定一个名字，是一个可选项。如果没有这个选项，Docker会为容器创建一个随机名字 ubuntu是镜像名，/bin/bash代表告诉Docker要在容器里面执行命令/bin/bash。 执行该命令之后，如果本地没有该镜像，Docker会从远程仓库中获取。然后，Docker使用这个镜像创建一个新的容器并将其启动；容器的文件系统是在只读的镜像文件上增加一层可读写的文件层，这样可以保证镜像不变而只记录改变的数据，这对容器的共享和传输都非常有利。接着会配置容器的网络，Docker会为容器分配一个虚拟网络接口，并通过网桥的方式将该网络接口桥接到宿主主机上，然后该虚拟网络接口分配一个IP地址。最后，Docker在新容器中运行指定的命令。 查看容器查看正在运行的容器： 1docker ps CONTAINER ID：唯一标识容器的ID IMAGE：创建容器时使用的镜像 COMMAND：容器最后运行的命令 CREATED：创建容器的时间 STATUS：容器的状态 PORT：对外开放的接口 NAMES：容器名。和容器ID一样都可以唯一标识一个容器。 查看所有的容器： 1docker ps -a 列出所有容器，包括运行的和停止的容器。 启动容器通过docker create命令创建的容器会进入到停止状态，想要运行该容器，可以执行以下命令： 1docker start 容器名/容器ID 终止容器执行命令： 1docker stop 容器名/容器ID 删除容器执行命令： 1docker rm 容器名 注意：不可以删除一个运行中的容器，必须先用docker stop或docker kill命令停止它才能删除。当然，也可以使用-f选项强制删除。 删除所有容器： 1docker rm 'docker ps -a -q' -a标志列出所有容器，-q标志只列出容器的ID，不包括容器的其他信息。然后将这个列表传给docker rm命令，依次删除容器。 四、容器内信息获取与命令执行 依附容器依附操作attach通常用于由docker start或者docker restart启动的交互型容器中。由于docker start启动的交互型容器并没有具体终端可以依附，而容器本身是可以接收用户交互的，这时就需要通过attach命令来将终端依附到容器上。 1docker attach 容器ID 查看容器日志12docker logs -f 容器名 docker logs -f --tails=5 容器名 #控制logs输出的日志行数，只输出最后五行 查看容器进程1docker top 容器名 查看容器信息1docker inspect 容器名 用来查看容器的配置环境，包括容器名，环境变量，运行命令，主机配置，网络配置和数据卷配置等。使用-f或者--format命令格式化标志，可以查看指定部分的信息。 容器的导入与导出Docker的导入和导出分别由import命令和export命令完成。 使用docker export命令导出容器： 1docker export 容器名 &gt; my_container.tar docker export命令会把容器的文件系统以tar包的格式导出到标准输出。我们将其定位到目标文件name.tar。将容器保存到本地文件也算是持久化方式的一种。将容器保存到本次之后，我们就可以通过网络等方法将tar包分享给他人。 使用docker import命令导入一个本地的tar包作为镜像： 1cat my_container.tar | docker import - imported:container docker import会把打包的容器导入为一个镜像。 import表示从标准输入读取容器内容，我们把name.tar的内容传给标准输入，res和tag代表生成的镜像和标记。]]></content>
      <categories>
        <category>分布式与云计算</category>
      </categories>
      <tags>
        <tag>Docker</tag>
        <tag>容器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Kubernetes集群部署]]></title>
    <url>%2F2019%2FKubernetes%E9%9B%86%E7%BE%A4%E9%83%A8%E7%BD%B2%2F</url>
    <content type="text"><![CDATA[一、环境概述 节点信息 IP 角色 服务器名 192.168.43.60 Master Matser 192.168.43.61 Node Node1 192.168.43.62 Node Node2 192.168.43.63 Node Node3 服务器配置信息Master：虚拟机CentOS7 Node：虚拟机CentOS7 节点分布：利用局域网中的四台电脑中的虚拟机实现K8S集群的部署。 二、部署步骤需要说明的是，kubernetes集群部署可以采用二进制文件进行安装，也可以采用kubeadm工具快速安装kubernetes，这里我使用了kubeadm工具。 设置服务器名分别设置各个服务器名： 执行命令：vi /etc/hostname Master：修改localhost为Master Node1：修改localhost为Node1 Node2：修改localhost为Node2 Node3：修改localhost为Node3 设置HOST在每个节点中执行命令：vi /etc/hosts 插入如下内容： 1234192.168.43.60 Master192.168.43.61 Node1192.168.43.61 Node2192.168.43.61 Node3 时间同步执行下列命令： 1ntpdate cn.pool.ntp.org 若提示ntpdate未安装，执行命令：yum install ntpdate 关闭防火墙/开启特定端口策略在各个节点上执行如下命令： 12systemctl disable firewalldsystemctl stop firewalld 禁用SELinux，让容器可以读取主机文件系统在各个节点上执行如下命令： 1setenforce 0 配置yum源在各个服务器上执行命令： *vi /etc/yum.repos.d/kubernetes.repo* 插入如下内容： 12345[kubernetes]name=Kubernetes Repositorybaseurl=https://mirrors.aliyun.com/kubernetes/yum/repos/kubernetes-el7-x86_64/enabled=1gpgcheck=0 安装kubeadm和相关工具执行如下命令： 1yum install -y kubelet kubeadm kubectl --disableexcludes=kubernetes 安装docker-ce1yum install docker-ce 若报类似于nothing的错误，执行命令：yum update 然后执行yum search docker-ce 之后根据查找结果安装docker-ce 启动Docker服务和kubectl服务执行下列命令： 12systemctl enable docker &amp;&amp; systemctl start dockersystemctl enable kubelet &amp;&amp; systemctl start kubelet 检测docker服务和kubelet服务执行下列命令： 12systemctl status dockersystemctl status kubelet 执行结果显示绿色字样的running即为正常状态。 通过kubeadm获取初始化配置文件执行命令： 123kubeadm config print init-defaults &gt; init.default.yamlcp init.default.yaml init-config.yamlvi init-config.yaml 修改内容如下： 123456789101112131415161718192021222324252627282930313233343536373839apiVersion: kubeadm.k8s.io/v1beta2bootstrapTokens:- groups: - system:bootstrappers:kubeadm:default-node-token token: lo7fj7.j16rob4ic6mbgs5q ttl: 24h0m0s usages: - signing - authenticationkind: InitConfigurationlocalAPIEndpoint: advertiseAddress: 192.168.43.60 #master IP bindPort: 6443nodeRegistration: criSocket: /var/run/dockershim.sock name: master taints: - effect: NoSchedule key: node-role.kubernetes.io/master---apiServer: timeoutForControlPlane: 4m0sapiVersion: kubeadm.k8s.io/v1beta2certificatesDir: /etc/kubernetes/pkiclusterName: kubernetescontrollerManager: &#123;&#125;dns: type: CoreDNSetcd: local: dataDir: /var/lib/etcdimageRepository: registry.aliyuncs.com/google_containers #镜像源，国内kind: ClusterConfigurationkubernetesVersion: v1.16.0networking: dnsDomain: cluster.local podSubnet: "192.168.0.0/16" serviceSubnet: 10.96.0.0/12scheduler: &#123;&#125; 修改docker镜像源123&#123; &quot;registry-mirrors&quot;:[&quot;https://e384u25y.mirror.aliyuncs.com&quot;]&#125; 上面的镜像源是阿里云加速链接，可以注册阿里云账号，然后在镜像服务中找到专属的加速链接 下载镜像文件1kubeadm config images pull --config=init-config.yaml 使用kubeadm init命令安装Master1kubeadm init --config=init-config.yaml 在安装的过程中可能会出现比较多的问题。 如果是镜像源的问题，可以重新启动docker服务，加载修改的镜像源，命令如下： 12systemctl daemon-reloadsystemctl restart docker 如果是提示hostname &quot;master&quot; could not be reached之类的问题，可以修改/etc/hosts文件，见第2步。 若提示如下问题： 1running with swap on is not supported. Please disable swap 执行命令： 1*swapoff -a* 若提示如下问题： 1[ERROR FileContent--proc-sys-net-bridge-bridge-nf-call-iptables]: /proc/sys/net/bridge/bridge-nf-call-iptables contents are not set to 1 执行命令： 1echo 1 &gt; /proc/sys/net/ipv4/ip_forward 安装成功后会出现如下提示： 1Your Kubernetes control-plane has initialized successfully! 在最下面的提示信息中也会出现token，这用于节点加入集群，不过这个token只有24小时的有效期。我们也可以使用其他命令生成永久的token。 准备配置文件，以便系统重启时，自动启动集群执行命令： 123mkdir -p $HOME/.kubecp -i /etc/kubernetes/admin.conf $HOME/.kube/configchown $(id -u):$(id -g) $HOME/.kube/config 验证安装是否成功1234567[root@Master ~]# kubectl get -n kube-system configmapNAME DATA AGEcoredns 1 10dextension-apiserver-authentication 6 10dkube-proxy 2 10dkubeadm-config 2 10dkubelet-config-1.16 1 10d 至此，master节点安装完毕。下面安装node节点。 安装节点在各个节点上重复步骤1~10。 通过kubeadm获取join配置文件执行命令如下： 12kubeadm config print join-defaults &gt; join-config.yamlvim join-config.yaml 然后修改内容如下： 1234567891011121314apiVersion: kubeadm.k8s.io/v1beta2caCertPath: /etc/kubernetes/pki/ca.crtdiscovery: bootstrapToken: apiServerEndpoint: 192.168.43.60:6443 #这地方是master节点的IP token: lo7fj7.j16rob4ic6mbgs5q #这地方是token，一般是初始化的toke，和master节点中的init文件中的token相同 unsafeSkipCAVerification: true timeout: 5m0s tlsBootstrapToken: lo7fj7.j16rob4ic6mbgs5qkind: JoinConfigurationnodeRegistration: criSocket: /var/run/dockershim.sock name: node1 #节点名，每个节点的名字必须不同 taints: null 运行kubeadm join命令加入集群执行命令： 1kubeadm join --config=join-config.yaml 查看已加入节点123456[root@Master ~]# kubectl get nodeNAME STATUS ROLES AGE VERSIONmaster NotReady master 10d v1.16.2 node1 NotReady &lt;none&gt; 7d12h v1.16.2node2 NotReady &lt;none&gt; 7d12h v1.16.2node3 NotReady &lt;none&gt; 7d12h v1.16.2 在节点加入成功后，执行命令的结果如上。这里notready是因为没有安装网络插件。网络插件比较多，比如weave，Flannel等。这里安装weave。 安装网络插件执行命令： 1kubectl apply -f "https://cloud.weave.works/k8s/net?k8s-version=$(kubectl version | base64 | tr -d '\n')" 这里可能会因为科学上网的问题而出现ErrImage或者ImagePullback等问题。我的也出现了这个问题，后来不知道什么原因，突然就安装上了。 验证Kubernetes集群是否安装完成12345678910kube-system coredns-58cc8c89f4-8rxzx 1/1 Running 13 7d12hkube-system coredns-58cc8c89f4-cdwm7 1/1 Running 15 7d12hkube-system etcd-master 1/1 Running 26 10dkube-system kube-apiserver-master 1/1 Running 265 10dkube-system kube-controller-manager-master 1/1 Running 108 10dkube-system kube-proxy-bhdzd 1/1 Running 9 7d1hkube-system kube-proxy-dj4qt 1/1 Running 14 7d1hkube-system kube-scheduler-master 1/1 Running 96 10dkube-system weave-net-6nd4h 2/2 Running 44 7d12hkube-system weave-net-9tzjk 2/2 Running 41 7d19h 这里，Kubernetes集群就可以搭建完毕了。]]></content>
      <categories>
        <category>分布式与云计算</category>
      </categories>
      <tags>
        <tag>k8s</tag>
        <tag>分布式集群</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面向对象设计原则]]></title>
    <url>%2F2019%2F%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99%2F</url>
    <content type="text"><![CDATA[面向对象设计，为什么？ 变化是复用的天敌，面向对象设计最大的优势在于：抵御变化。 重新认识面向对象 理解隔离变化 从宏观层面来看，面向对象的构建方式更能适应软件的变化，能将变化所带来的影响减为最小 各司其职 从微观层面来看，面向对象的方式更强调各个类的“责任” 由于需求变化导致的新增类型不应该影响原来类型的实现——是所谓各司其职。 对象是什么 从语言实现层面来看，对象封装了代码和数据 从规格层面讲，对象是一系列可被使用的公共接口 从概念层面讲，对象时某种拥有责任的抽象。 面向对象设计原则 依赖倒置原则（DIP) 高层模块（稳定）不应该依赖于底层模块（变化），二者都应该依赖于抽象（稳定） 抽象（稳定）不应该依赖于实现细节（变化），实现细节应该依赖于抽象（稳定）。 开放封闭原则（OCP) 对扩展开放，对更改封闭 类模块应该是可扩展的，但是不可修改 单一职责原则 一个类应该仅有一个引起它变化的原因 变化的方向隐含着类的责任。 Liskov替换原则（LSP） 子类必须能够替换它们的基类 继承表达类型抽象 接口隔离原则（ISP） 不应该强迫客户程序依赖它们不用的方法 接口应该小而完备 优先使用对象组合，而不是类继承 类继承通常为“白箱复用”，对象组合通常为“黑箱复用” 继承在某种程度上破坏了封装性，子类父类耦合度高 而对象组合则只要求被组合的对象具有良好定义的接口，耦合度低 封装变化点 使用封装来创建对象之间的分界层，让设计者可以在分界层一侧进行修改，而不会对另一侧产生不良的影响，从而实现层次间的松耦合 针对接口编程，而不是针对实现编程 不将变量类型声明为某个特定的具体类，而是声明为某个接口。 客户程序无需获知对象的具体类型，只需要知道对象所具有的接口 减少系统中各部分的依赖关系，从而实现“高内聚，松耦合”的类型设计方案。]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>面向对象设计原则、</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[什么是设计模式？]]></title>
    <url>%2F2019%2F%E4%BB%80%E4%B9%88%E6%98%AF%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%9F%2F</url>
    <content type="text"><![CDATA[每一个模式描述了一个在我们周围不断重复发生的问题，以及该问题的解决方案的核心。这样，你就能一次又一次地使用该方案而不必做重复劳动。 ​ ——Christopher Alexander 一般而言，一个模式有四个基本要素： 模式名称。 一个助记名，它用一两个词来描述模式的问题，解决方案和效果。命名一个新的设计模式增加了我们的设计词汇。设计模式允许我们在较高的抽象层次进行设计。 问题。 描述了应该在何时使用模式。它解释了设计问题和问题存在的前提，它可能描述了特定的设计问题，如怎样用对象表示算法。也可能描述了导致不灵活设计的类或对象结构。 解决方案 描述了设计的组成成分，它们之间的相互关系以及各自的职责和协作方式。因为模式就像是一个模板，可应用于多种不同场合，所以解决方案并不描述一个特定而具体的设计或实现，而是提供设计问题的抽象和怎样用一个具有一般意义的元素组合来解决这个问题。 效果。 描述了模式应用的效果以及使用模式应权衡的问题。尽管我们描述设计决策时，并不总提到设计模式，但它们对于评价设计选择和理解使用模式的代价以及好处具有重要意义。软件效果大多关注对时间和空间的衡量，它们也表述了语言和实现问题。因为复用是面向对象设计的要素之一，所以模式效果包括它对系统灵活性、扩充性或可移动性的影响，显式地列出这些效果对理解和评价这些模式很有帮助。]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[传输控制协议TCP]]></title>
    <url>%2F2019%2F%E4%BC%A0%E8%BE%93%E6%8E%A7%E5%88%B6%E5%8D%8F%E8%AE%AETCP%2F</url>
    <content type="text"><![CDATA[TCP是TCP/IP体系中面向连接的运输层协议，它提供了全双工的和可靠交付的服务。TCP与UDP最大的区别就是：TCP是面向连接的，而UDP是无连接的。TCP比UDP复杂的多，除了具有面向连接和可靠传输的特性外，TCP还在运输层使用流量控制和拥塞控制机制。 一、TCP的主要特点 TCP是面向连接的运输层协议。这就是说，应用程序在使用TCP提供的服务传送数据之前，必须先建立TCP连接。建立TCP连接的目的是通信双方为接下来的数据传送做好准备，初始化各种状态变量，分配缓存等资源，在传送数据完毕后，必须释放已建立的TCP连接，即释放相应的资源和变量。 每一条TCP连接只能有两端点，即每一条TCP连接只能是点对点的（一对一）。TCP连接唯一地被通信两端的端点所确定，而两个端点分别由二元组（IP地址，端口号）唯一标识，即一条TCP连接由两个套接字地址标识。 TCP是提供可靠服务的。也就是说，通过TCP连接传送的数据无差错，不丢失，不重复，并且按序到达。 TCP提供全双工通信。TCP允许通信双方的应用进程在任何时候都能发送数据。TCP连接的两端都没有发送缓存和接受缓存，用来临时存放双向通信的数据。在发送时，应用程序在把数据传送给TCP的缓存后，就可以做自己的事，而TCP在合适的时候把数据发送出去。在接收时，TCP把收到的数据放入缓存，上层的应用进程在合适的时候读取缓存中的数据。 面向字节流。TCP中的流指的是流入到进程或从进程流出的字节序列。面向字节流的含义是：虽然应用程序和TCP的交互时一次一个数据块，但TCP把应用程序交下来的数据看成是一连串的无结构的字节流。TCP不保证接收方应用程序收到的数据块和发送方应用程序所发出的数据块具有对应大小的关系，从TCP接收方缓存中将数据读取完毕。但接受方应用程序收到的字节流必须和发送方应用程序发出的字节流完全一样。 发送方的应用进程按照自己产生数据的规律，不断地把数据块陆续写入到TCP的发送缓存中。TCP再从发送缓存中取出一定数量的数据，将其组成TCP报文段逐个传递给IP层，然后发送出去。 接收方从IP层收到TCP报文段后，先把它暂存在接收缓存中，然后等待接收方对应的应用进程从接收缓存中按顺序读取。需要注意的是，接收方应用进程每次从接收缓存中读取数据时，是按应用进程指定的数量读取数据，而不是一次读取接收缓存中的一个完整的报文段或所有数据。只有当接收缓存中的数据量小于应用进程指定的读取量时，才返回给应用进程接收缓冲中所有的数据。当接收缓存中完全没有数据时，根据读取方式的不同，应用进程可能会一直等待，也可能直接返回。由此可见，TCP的接收方应用进程读取的数据块与发送方应用进程发送的数据块边界毫无关系，也就是说，TCP接收方在向上层交付数据时不保证能保持发送方应用进程发送数据块的边界。 TCP连接时一条虚连接，而不是一条物理连接。也就是说，TCP连接时一种抽象的逻辑连接。 TCP报文段首先要传送到IP层，加上IP首部后，再传送到数据链路层，再加上数据链路层的首部和尾部后，才离开主机发送到物理链路。另外，TCP连接仅存在于两个端系统同中，而网络核心的中间设备完全不知道该连接的存在。TCP连接的组成主要包括：通信两端主机上的缓存、状态变量，在这两台主机间的路由器和交换机没有为该连接分配任何缓存和变量。 与UDP的端口队列不同的是，TCP的发送缓存和接受缓存都是分配给一个连接的，而不是一个端口。TCP的一个连接由四元组（源IP地址，源端口号，目的IP地址，目的端口号）标识，即由源/目的套接字地址对标识。也就是说，来自不同源的TCP报文段，即使它们的目的IP地址和面对端口号相同，它们也不可能被交付到同一个TCP接收缓存中，因为它们在不同的TCP管道中传输，到达不同管道出口的缓存。通常一个TCP服务器进程用一个端口号与不同的客户机进程建立多个连接，然后创建多个子进程分别用这些连接与各自的客户机进程进行通信。 二、TCP报文段的格式TCP虽然是面向字节流的，但TCP传送的数据单元却是报文段。TCP报文段分为首部和数据两部分，而TCP的全部功能都体现在它首部各字段的作用。 TCP报文段首部的前20个字节是固定的，后面有4N个字节是根据需要而增加的选项。因此，TCP首部的最小长度是20字节。 首部固定部分各字段的意义如下所述： 源端口和目的端口。各占两个字节。与UDP一样，该字段定义了主机中发送和接受该报文段的应用程序的端口号，用于运输层的复用和分用。 序号。占4个字节。序号从0开始，到$2^{32}-1$为止。TCP是面向数据流的.TCP传送的报文段可看成连续的数据流。在一个TCP连接中传送的数据流中的每一个字节都是按顺序编号。整个数据的起始序号在连接建立时设置。首部中的序号字段的值则指的是本报文段所含的数据的第一个字节的序号。 确认号。占4个字节，是期望收到对方的下一个报文段的第一个数据字节的序号。TCP提供的是双向通信，当一端发送数据时同时对接收到的对端数据进行确认。TCP采用的是累积确认。 数据偏移。占4位，它指出TCP报文段的数据起始处距离TCP报文段的起始处有多远。这实际上就是TCP报文段首部的长度。由于首部长度不固定，因此数据偏移字段是必要的。但应注意的是，“数据偏移”的单位不是字节而是32位字（即以4字节长的字为计算单位）。由于4位二进制数能够表示的最大十进制数字是15，因此数据偏移的最大值是60字节，这也是TCP首部的最大长度。 保留。占6位，保留为今后使用，但目前应置0. 紧急URG。当URG=1时，表明紧急指针字段有效。它告诉接收方TCP此报文段中有紧急数据，应尽快交付给应用程序，而不要按序从接收缓存中读取。 确认ACK。只有当ACK=1时确认号字段才有效。当ACK=0时，确认号无效。 推送PSH。处于效率的考虑，TCP可能会延迟发送数据或向应用程序延迟交付数据，这样可以一次处理更多的数据。但是当两个应用进程进行交互式通信时，有时在一段的应用进程希望在键入一个命令后立即就能得到对方的响应。在这种情况下，应用程序可以通知TCP使用推送操作。这时发送方TCP把PSH置1，并立即创建一个报文段发送出去，而不需要累积到足够多的数据再发送。。接收TCP收到PSH置1的报文段，就尽快地交付给接收应用进程，而不要等到收到足够多的的数据才向上交付。 复位RST。当RST=1时，表明TCP连接中出现严重差错，必须释放连接，然后再从新建立运输连接。RST置1还用来拒绝一个非法的报文段或拒绝打开一个连接。RST也可称为重建位或重置位。 同步SYN。用来建立一个连接。当SYN=1而ACK=0时，表明这是一个连接请求报文段。对方若同意建立连接，则应在响应的报文段中使SYN=1和ACK=1。因此，SYN置1就表示这是一个连接请求或连接接收报文。 终止FIN。用来释放一个连接。当FIN=1时，表明此报文段的发送方的数据已发送完毕，并要求释放运输连接。 窗口。占两字节。窗口值指示发送该报文段的接受窗口大小，在0到$2^{16}-1$之间。窗口字段用来控制对方发送的数据量，单位为字节。窗口字段反映了接收方接收缓存的可用空间大小。 检验和。占两个字节。检验和字段检验的范围包括首部和数据两部分。 选项。长度可变。这里介绍一个，即最大报文段长度（MSS）。 三、TCP的可靠传输 数据编号与确认 TCP是面向字节的。TCP把应用层交下来的长报文看成是一个个字节组成的数据流，并使每一个字节对应于一个序号。注意，GBN协议中是对每个分组进行编号在。在建立连接时，双方TCP要各自确定初始序号。TCP每次发送的报文段的首部中的序号字段数值表示该报文段中紧接着首部后面的第一个数据字节的序号。 TCP使用累积确认，即确认是对所有按序收到的数据的确认。但请注意，接收方返回的确认号时已按序收到的数据的最高序号加1.也就是说，确认号表示接收方期望下一次收到的数据中的第一个数据直接序号。 当TCP发送一报文段时，它同时也咋自己的重传队列中存放这个报文段的一个副本。若收到确认，则删除此副本。若在规定时间内没有收到确认，则重传此报文段的副本。TCP的确认并不保证数据已交付给了应用进程，而只是表明在接收方的TCP已按序正确收到了对方所发送的报文段。 由于TCP连接能提供全双工通信，因此通信中的每一方都不必专门发送确认报文段，而可以在传送数据时顺便把确认信息捎带传送。为此，TCP采用了一种延迟确的机制，即接收方在正确接收到数据时可能要等待一段时间再发送确认。若这段时间内有数据要发送给对方，则可以捎带确认。也有可能在这段时间内又有数据到达，则可以同时对这两次到达的数据进行累计确认。这样做可以减少发送完全不带数据的确认报文段，以提高TCP的传输效率。 接收方若收到有差错的报文段就丢弃。若收到重复的报文段，也要丢弃，但要立即发回确认信息。 若收到的报文段无差错，只是未按序号顺序到达，那么应如何处理？在GBN协议中会丢弃所有未按序到达的分组，但是TCP对此未做明确规定，而是让TCP的实现者自行确定。可以像GBN协议一样将不按序到达的报文段丢弃，但多数TCP实现是先将其暂存与接收缓存内，待所缺序号的报文段收齐后再一起上交应用层。在互联网环境中，封装TCP报文段和IP数据报不一定是按序到达的，将失序的报文段先缓存起来可以避免不必要的重传。注意，不论采用哪种方法，接收方都要立即对已按序接收到的数据进行确认。 TCP发送方每发送一个报文段，就会为这个报文段设置一个计时器。只要计时器设置的重传时间已经到了但还没有收到确认，就要重传这一报文段。我们知道，在GBN协议中，一旦发送方某个分组超时，则会重传窗口内所有已发送的分组。而在TCP中发送方只会重传超时的那一个报文段，如果后序报文段的确认能够在超时之前及时到达，则不会重传那些还没有超时的后续报文段。 以字节为单位的滑动窗口 为了提高报文段的传输效率，TCP采用滑动窗口协议。但与GBN协议不同的是，TCP发送窗口大小的单位是字节，而不是分组数。TCP发送方已发送的未被确认的字节数不能超过发送窗口的大小。 落入发送窗口内的是允许发送的字节，落在发送窗口外左侧的是已发送并被确认的字节，而落在发送窗口外右侧是是还不能发送的字节。收到确认后，发送窗口向右滑动，直到发送窗口的左沿正好包含确认序号的字节。 发送缓存用来暂时存放： 发送应用程序传送给发送方TCP准备发送的数据 TCP已发送出去但尚未收到确认的数据 发送窗口通常只是发送缓存的一半部分。已被确认的数据应当才能够发送缓存中删除，因此发送缓存和发送窗口的后沿是重合的。发送应用程序最后写入发送缓存的字节序号减去最后被确认的字节序号，就是还保留在发送缓存的被写入的字节数。如果发送应用程序传送给TCP发送方的速度太快，可能会最终导致发送缓存被填满，这时发送应用程序必须等待，直到有数据从发送缓存中删除。 接收缓存用来暂时存放： 按序到达的，但尚未被接受应用程序读取的数据 未按序到达的，但还不能被接收应用程序读取的数据 如果收到的分组被检测出有差错，则要丢弃。如果接受应用程序来不及读取收到的数据，接收缓存最终就会被填满，使接收窗口减小到0.反之，如果接受应用程序能够及时从接收缓存中读取收到的数据，接收窗口就会增大，但最大不能超过接收缓存的大小。 超时重传时间的选择 由于TCP的下层是互联网环境，发送的报文段可能只经过一个高速率的局域网，但也可能经过多个低速率的广域网，并且每个IP数据报所选择的路由还可能不同，不同时间网络拥塞情况也有不同。因此往返时间是不断变化的。 对于运输层来说，其往返时间的方差很大。如果把超时时间设置得太短，则很多报文段就会过早超时，引起很多报文段的不必要的重传，使网络负荷增大。但如果把超时时间设置得过长，则大量丢失的报文段不能被及时重传，降低了传输效率。因此，选择超时重传时间再数据链路层并不困难，但在运输层却不那么简单。 那么。运输层的超时计时器的超时重传时间究竟应设置为多大呢？显然，超时重传时间应比当前报文段的往返时间要长一些。针对互联网环境中端到端的时延是动态变化的特点，TCP才用了一种自适应算法。该算法记录每个报文段发出的时间，以及收到相应的确认报文段的时间。这两个时间之差就是报文段得到往返时间RTT。在互联网中，实际的RTT测量值变化非常大，因此需要用多个RTT测量值的平均值来估计当前报文段的RTT。由于越近的测量值越能反映网络当前的情况,TCP采用指数加权移动平均的算法对RTT测量值进行加权平均，得出报文段的平均往返时间RTT。 快速重传 超时触发重传存在的一个问题就是超时时间可能相对较长。由于无法精确估计实际的往返时间，超时重传时间RTO往往比实际的往返时间大很多。当一个报文段丢失时，发送方需要等待很长时间才能重传丢失的报文段，因而增加了端到端时延。幸运的是，有时一个报文段的丢失会引起发送方连续收到多个重复的确认，通过收到多个重复的确认可以快速地判断报文段可能已经丢失而不必等待重传计时器超时。快速重传就是基于该方法对超时重传的补充和改进。 选择确认 TCP报文段的确认字段是一种累积确认，就是说，它只通告收到的最后一个按序到达的字节，而没有通告所有收到的失序到达的那些字节，虽然这些字节已经被接收方接收并暂存在接收缓存中。这些没有被确认的字节很可能因为超时而被发送方重传。为了避免这些无意义的重传，一个可选功能选择确认可以解决这个问题。选择确认允许接收方通知发送方所有正确接收了的但是失序的字节块，发送方可以根据这些信息只重传那些接收方还没有收到的字节块。 四、TCP的流量控制一条TCP连接的双方主机都为该连接设置了接收缓存。当该TCP连接接收得到按序的字节后，它就将数据放入接收缓存。相关联的应用程序会从该缓存中读取数据，但应用程序不一定能马上将数据取走。事实上，接收方应用也许正忙于其他任务，需要过很长的时间后才能去读取数据。如果应用程序读取数据比较慢，而发送方发送数据很快、很多，则很容易使该连接的接收缓存溢出。 TCP为应用程序提供了流量控制服务，以解决因发送方发送数据太快而导致接收方来不及接收，使接收方缓存溢出的问题。 流量控制的基本方法就是接收方根据自己的接收能力控制发送方的发送速率。因此，可以说流量控制是一个速度匹配服务，即发送方的发送速率与接收方应用程序的读速率相匹配。利用滑动窗口机制可以很方便地控制发送方的平均发送速率。TCP采用接收方控制发送方发送窗口大小的方法来实现在TCP连接上的流量控制。在TCP报文段首部的窗口字段写入的数值就是当前给对方设置的发送窗口数值的上限。这种由接收方控制发送方的做法，在计算机网络中经常使用。 发送窗口在连接建立时由双方商定。但在通信的过程中，接收方根据接收缓存中可用缓存的大小，随时动态地调整对方的发送窗口的上限值。为此，TCP接收方要维持一个接受窗口的变量，其值不能大于可用缓存大小。 在TCP报文段首部的窗口字段写入的数值就是当前接收方的接收窗口的大小。TCP发送方的发送窗口的大小必须小于该值。 当接收方的可用接收缓存大小不再为0时，向发送方发送的窗口更新报文段丢失了会出现什么问题？如果接收方一直没有数据要发送给发送方，则发送方将会永远等下去。为防止因为因接收方发送给发送方的窗口变更变文段的丢失所导致的死锁状态，实际上，当窗口变为0时，如果发送方有数据要发送，则会周期性地发送只包含一个字节数据的窗口探测报文段，以便强制接收方发回确认并公告接收窗口大小。如果这时接收窗口大小非零，则会接收这个字节，并对这个字节进行确认，否则会丢弃该字节并对以前数据进行重复确认。 五、TCP的连接管理TCP是面向连接的协议。连接的建立和释放是每一次面向连接的通信中必不可少的过程。因此TCP连接就有三个阶段，即连接建立、数据传送、连接释放。建立连接的目的就是为接下来要进行的通信做好充分的准备，其中最重要的就是分配相应的资源。在通信结束之后显然要释放所占用的资源，即释放连接。注意，TCP的连接时运输层连接，只存在于通信的两个端系统中，而网络核心的路由器完全不知道它的存在。 TCP的连接建立 在连接建立时要解决以下三个问题： 要使每一方能够确知对方的存在； 要允许双方协商一些参数 能够对运输实体资源进行分配和初始化 TCP的连接建立采用客户——服务器方式。主动发起连接建立的应用进程叫做客户，而被动等待连接建立的应用进程叫做服务器。 设主机B运行TCP的服务器进程，它先发出一个被动打开命令，准备接受客户进程的连接请求。然后服务器进程就处于“听”状态，不断检测是否有客户进程要发起连接请求。如有，即做出响应。 设客户进程运行在主机A中。它先向其TCP发出主动打开命令，表明要向某个IP地址的某个端口建立运输层连接。 主机A的TCP向主机B的TCP发出连接请求报文段，其首部的同步位SYN应置1，同时选择一个序号seq=x，这表明下一个报文段的第一个数据字节的序号是x+1。 主机B的TCP收到连接请求报文段后，如同意，则发回连接请求确认。在确认报文段中应把SYN位和ACK位都置1，确认号ack=x+1，同时也为自己选择一个序号seq=y。 主机A的TCP收到B接受连接请求的确认后，还要向B给出确认，其ACK置1，确认号ack=y+1。而自己的序号seq=x+1。TCP标准规定，SYN=1的报文段不能携带数据，但要消耗一个序号。因此A发送的第二个报文段的序号应当是第一个报文段的序号加1.注意，A发送的第二个报文段中SYN是0而不是1，ACK位必须为1.该报文段是对B的同步报文段的确认，但是一个普通报文段，可携带数据。若该报文段不携带数据，则按照TCP的规定，确认报文段不消耗序号。 运行客户进程的主机A的TCP通知上层应用进程，连接已经建立。 当运行服务器进程的主机B的TCP收到主机A的确认后，会通知其上层应用进程，连接已经建立。 连接建立采用的这种过程叫做三次握手。 为什么要发送这三个报文段呢？这主要是为了防止已失效的连接请求报文段突然又传送到了主机B，因而导致错误产生。 TCP的连接释放 在数据传输结束后，通信的双方都可以发出释放连接的请求。在连接释放过程中要释放为该连接分配的所有资源。 设主机A的应用进程先向其TCP发出连接释放请求，并且不再发送数据。TCP通知对方要释放A到B这个方向的链接，把发往主机B的报文段首部的FIN置1，其序号seq=u。由于FIN报文段要消耗一个序号，因此序号u等于A前面已传送过的数据的之后一个字节的序号加1. 主机B的TCP收到释放连接的通知后即发出确认，确认号ack=u+1，而这个报文段自己的序号假定为v。主机B的TCP这时应通知高层应用进程。这样，从A到B的连接就释放了，连接处于半关闭状态。 此后，主机B不再接受主机A发来的数据。但若主机B还有一些数据要发往主机A，则可以继续发送。主机A只要正确收到数据，仍应向主机B发送确认。 若主机B不再向主机A发送数据，其应用进程就通知TCP释放连接。主机B发出的连接释放报文段必须使FIN=1，其序号为w。主机A必须对此发出确认，把ACK置1，确认号ack=w+1，而自己的序号为seq=u+1。这样才把从B到A的反方向连接释放掉。但此时，主机A的TCP并不能马上释放整个连接，还要再等待一个超时时间才能将整个连接释放。因为主机A的确认有可能丢失，这时B会重传FIN报文段。在这段超时时间内，若A又收到B重传的FIN报文段，A需要再次进行确认。收到A的最后确认，B才能将整个连接释放。若等待的这段超时时间内没有收到B的FIN报文段，主机A的TCP则应向其应用进程报告，整个连接已经全部释放。 上述的连接释放过程是四次握手。]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>传输控制协议</tag>
        <tag>TCP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[拥塞控制]]></title>
    <url>%2F2019%2F%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%2F</url>
    <content type="text"><![CDATA[当网络中出现太多的分组时，网络的性能开始下降。这种情况称为拥塞。拥塞是分组交换网中一个非常重要的问题。如果网络中的负载，即发送到网络中的数据量超过了网络的容量，即网络中能处理的数据量，那么在网络中就可能发生拥塞。所谓拥塞控制就是放置过多的数据注入到网络中，这样可以使网络中的路由器或链路不至过载。 一、拥塞的原因及危害理想情况下，在吞吐量饱和之前，网络吞吐量应等于输入负载。但当输入负载超过网络容量时，在理想情况下，吞吐量不再增长而保持为水平线，即吞吐量达到饱和。这就表明输入负载中有一部分损失掉了。 但是，在实际的网络中，若不采取有效的拥塞控制手段，随着输入负载的增大，网络吞吐量的增长速率逐渐减小。特别是当输入负载达到某一数值时，网络的吞吐量反而随负载的增大而下降，这时网络就进入了拥塞状态。当输入负载继续增大时，网络的吞吐量甚至有可能下降到零，即网络已无法工作。这就是所谓的死锁。 当网络拥塞而丢弃分组时，该分组在其经过路径中所占用的全部资源都被白白浪费掉了。 既然网络拥塞是因为发送到网络中的数据量超过了网络的容量，要彻底解决分组交换网中的拥塞问题，就要想办法限制输入到网络中的负载，即控制源点的发送速率。 二、拥塞控制的基本方法拥塞控制和流量控制之间的区别是需要注意的，因为它们都需要控制源点的发送速率，因此容易混淆。拥塞控制的任务是防止过多的数据注入到网络中，使网络能够承受现有的网络负载。这是一个全局性的问题，涉及各方面的行为，包括所有的主机，所有的路由器，路由器内部的存储转发处理过程，以及与降低网络传输性能有关的所有因素。 与此相反，流量控制只与特定点对点通信的发送方和接收方之间的流量有关。它的任务是，确保一个快速的发送方不会持续地以超过接收方接收能力的速率发送数据，以防止接收方来不及处理数据。流量控制通常涉及的做法是，接收方向发送方提供某种直接的反馈，以抑制发送方的发送速率。 从控制论的角度出发，拥塞控制可以分为开环控制和闭环控制两大类。开环控制方法试图用良好的设计来解决问题，它的本质是从一开始就保证问题不会发生。一旦系统启动并运行起来了，就不需要中途做修正。 相反，闭环控制是一种基于反馈环路的方法，它包括三个部分： 监测网络系统以便监测到拥塞在何时、何地发生 把拥塞发生的信息传送到可以采取行动的地方 调整网络系统的运行以解决出现的问题 当网络系统的流量可以准确规定、性能要求可以事先获得时，适于使用开环控制；而当流量特征不能1准确描述或者当系统不提供资源预留时，适于使用闭环控制。由于因特网中不提供资源预留的机制，而且流量的特性不能准确地描述，所以在因特网中拥塞控制主要采用闭环控制方法。 根据拥塞反馈信息的形式，又可以将闭环拥塞控制算法分为显式反馈算法和隐式反馈算法。在显式反馈算法中，从拥塞点（即路由器）向源点提供关于网络中拥塞状态的显式反馈信息。当因特网中一个路由器被大量的IP是数据报淹没时，它可能会丢弃一些数据报，同时可使用ICMP源站抑制报文通告源主机。源站收到后应降低发送速率。不过当网络拥塞发生时，向网络中注入这些额外的分组可能会”火上浇油“，因此在实际中很少使用。现在，因特网中的拥塞控制任务主要是在运输层上完成的。更好的显式反馈信息的方法是，在路由器转发的分组中保留一个比特或字段，用该比特或字段的值表示网络的拥塞状态，而不是专门发送一个分组。 在隐式反馈算法中，源端通过对网络行为的观察来推断是否发生了拥塞，无需拥塞点提供显式反馈信息。TCP采用的就是隐式反馈算法。 需要说明的是，拥塞控制并不仅仅是运输层要考虑的问题。显式反馈算法就必须涉及网络层。虽然一些网络体系结构主要在网路层实现拥塞控制，但因特网主要利用隐式反馈在运输层实现拥塞控制。 不论采用哪种方法进行拥塞控制都是需要付出代价的。例如，在实施拥塞控制时，可能需要在结点之间交换信息和各种命令，以便选择控制的策略和实施控制。这样会产生额外的开销。有些拥塞控制机制会预留一些资源用于特殊用户或特殊情况，降低了网络资源的共享程度。因此，当网络输入负载1不大时，有拥塞控制的系统吞吐量要低于无拥塞控制的系统吞吐量。但付出一定的代价是值得的，它会保证网络性能的稳定，不会因为输入负载的增长而导致网络性能的恶化甚至出现崩溃。 三、TCP的拥塞控制TCP采用的方法是让每一个发送方根据所感知到的网络拥塞的程度，来限制其向连接发送流量的速率。如果TCP发送方感知从它到目的地之间的路径上没有拥塞，则增加其发送速率；如果发送方感知在该路径上有拥塞，则降低其发送速率。该方法具体要解决以下三个问题：首先，TCP发送方如何限制它的发送速率；其次，TCP发送方如何感知从它到目的地之间的路径上存在拥塞；最后，当发送方感知到端到端的拥塞时，采用什么算法来改变其发送速率。 TCP的流量控制利用接收方通告给发送方的接收窗口rwnd大小来限制发送窗口的大小。这个窗口大小就是接收方给发送方的TCP报文段首部中的窗口字段的值。实际上TCP的发送方还维持着一个叫做拥塞窗口cwnd的状态变量。拥塞窗口的大小取决于网络的拥塞程度，并且是动态变化的。TCP发送方在确定发送报文段的速率时，既要根据接收方的接收能力，又要从全局考虑不要使网络发生拥塞。因此TCP发送方的发送窗口大小取接收方接收窗口和拥塞窗口的最小值，即应按如下公式确定： 发送窗口的上限值=Min(rwnd,cwnd) 当rwnd&lt;cwnd时，是接收方的接收能力限制发送窗口的最大值。但当cwnd&lt;rwnd时，则是网络的传输能力限制发送窗口的最大值。 TCP发送方又是如何知道网络发生了拥塞呢？我们知道，当网络发生拥塞时，路由器就要丢弃分组。现在通信线路的传输质量一般都很好，因传输出差错而丢弃分组的概率是很小的。因此检测到分组丢失就可以认为网络出现了故障。在快速重传中，发送方不一定要通过重传计时器超时才能发现分组的丢失，可以通过接收到三个重复确认就能判断有分组的丢失。因此，当重传计时器超时或接收到三个重复确认时，TCP的发送方就认为网络出现了拥塞。 当发送方感知到端到端的拥塞时，采用什么算法来改变其发送速率呢？慢启动、拥塞避免和快速恢复。 慢启动和拥塞避免 当主机刚开始发送数据时完全不知道网络的拥塞情况，如果立即把较大的发送窗口中的全部数据字节都注入到网络，那么就有可能引发网络拥塞。经验证明，较好的方法是通过试探发现网络中的可用带宽，即由小到大逐渐增大发送方的拥塞窗口数值，直到发生拥塞。通常在刚刚开始发送报文段时可先将拥塞窗口cwnd设置为一个最大报文段MSS的数值。而在每收到一个对新的报文段的确认后，将拥塞窗口增加至多一个MSS的数值。用这样的方法逐步增大发送方的拥塞窗口cwnd，可以使分组注入到网络的速率更加合理。这就是慢启动算法。 在慢启动阶段发送速率以指数方式迅速增长，若持续以该速度增长发送速率必然导致网络很快进入到拥塞状态。因此当网络要接近拥塞时应降低发送速率的增长率，以避免网络拥塞。这可以使TCP连接在一段相对长的时间内保持较高的发送速率但又不使网络拥塞。为此，TCP定义了一个状态变量，即慢启动门限ssthresh（即从慢启动阶段进入拥塞避免阶段的门限）。慢启动门限ssthresh的用法如下： 当cwnd&lt;ssthresh时，使用上述的慢启动算法 当cwnd&gt;ssthresh时，停止使用慢启动算法而改用拥塞避免算法 当cwnd=ssthresh时，即可以使用慢启动算法，又可以使用拥塞避免算法 具体的做法如下所述： 拥塞避免算法使发送方的拥塞窗口cwnd每经过大约一个往返时间RTT就增加一个MSS的大小。实际的做法是，每收到一个新的确认，将cwnd增加MSS*(MSS/cwnd)。这样，拥塞窗口cwnd按线性规律缓慢增长，比慢启动算法的拥塞窗口增长速率缓慢得多。 无论在慢启动阶段还是在拥塞避免阶段，只要发送方发现网络拥塞，就立即将拥塞窗口cwnd重新设置为1，并执行慢启动算法。这样做的目的就是要迅速减少主机发送到网络中的分组数，使得发生拥塞的路由器有足够的时间把队列中积压的分组处理完毕。在重新执行慢启动算法的同时，将慢启动门限ssthresh设置为出现拥塞时的发送窗口值的一半。这样设置的考虑是：这一次在该窗口值发生拥塞，则下次很有可能在该窗口值再出现拥塞，因此当下次拥塞窗口又接近该值时，就要降低窗口的增长速率，进入拥塞避免阶段。 拥塞避免的具体过程： 当TCP连接进行初始化时，将拥塞窗口置为1. 执行慢启动算法时，拥塞窗口cwnd的初始值为1。以后发送方每收到一个对新报文段的确认ACK，就将发送方的拥塞窗口加1，然后开始下一次的传输。一个轮次就是把拥塞窗口cwnd所允许发送的报文段都发送出去，并且都收到了对方的确认。“轮次”之间的间隔时间可以近似为一个RTT。因此，拥塞窗口cwnd随着传输轮次按指数规律增长。当拥塞窗口cwnd增长到慢启动门限值ssthresh时，就改为执行拥塞避免算法，拥塞窗口按线性规律增长。 假定拥塞窗口的数值增长到24时，网络出现拥塞。更新后的ssthresh值变为12，拥塞窗口再重新设置为1，并执行慢启动算法。当cwnd=12时改为执行拥塞避免算法，拥塞窗口按线性规律增长，每经过一个往返时间就增加一个MSS的大小。 可见，执行拥塞避免算法后，拥塞窗口呈线性增长，发送速率增长比较缓慢，以防止网络过早出现拥塞，并使发送方可以长时间保持一个合理的发送速率。这里要再强调一下，“拥塞避免”并不能避免拥塞，而是说把拥塞窗口控制为按线性规律增长，使网络不容易立即出现拥塞。 快速恢复 实际上TCP检测到分组丢失有两种情况：重传计时器超时和收到连续三个重复的ACK。上面的拥塞控制算法对这两种情况采取了同样的反应，即将拥塞窗口降低为1，然后执行慢启动算法。但实际上这两种情况下网络拥塞情况是不一样的。当发送方收到连续三个重复的ACK时，虽然有可能丢失了一些分组，但这连续的三个重复ACK同样又表明丢失分组以外的另外三个分组已经被接收方接收了。因此，与发生超时事件的情况不同，网络还有一定的分组交付能力，拥塞情况并不严重。既然网络拥塞情况并不严重，将拥塞窗口直接降低为1则反应太过剧烈了，这会导致发送方要经过很长时间才能恢复到正常的传输速率。 为此，定义了与快速重传配套使用的快速恢复算法，其具体步骤如下： 当发送方收到连续三个重复的ACK时，就重新设置慢启动门限ssthresh，将其设置为当前发送窗口的一半。这一点和慢启动算法是一样的。 与慢启动不同之处是拥塞窗口cwnd不是设置为1，而是设置为新设置的慢启动门限ssthresh，然后开始执行拥塞避免算法，使拥塞窗口缓慢地线性增长。 对于超时事件，由于后续的分组都被丢弃了，一直没有收到它们的确认而导致重传计时器超时，显然网络存在严重的阻塞。对于这种情况重新执行慢启动有助于迅速减少主机发送到网络中的分组数，使发生拥塞的路由器有足够的时间把队列中积压的分组处理完毕。 采用快速恢复算法的情况下，长时间的TCP连接在稳定的时候通常处于下面描述的不断重复状态。经过慢启动发送方迅速进入拥塞避免阶段，在该阶段，使拥塞窗口呈线性增长，即加性增，发送速率缓慢增长，以防止网络网络过早拥塞。当流量逐渐超过网络可用带宽时会出现拥塞，但由于发送速率增长缓慢，通常仅导致少量分组丢失。这种情况下发送方会超过三个重复ACK并将拥塞窗口减半，即“乘性减”，然后再继续执行“加性增”缓慢增长发送速率，如此重复下去。因此，对于长时间的TCP连接，在稳定时的拥塞窗口大小呈锯齿状变化。在这种“加性增，乘性减“的拥塞控制下，发送方的平均发送速率始终保持在较接近网络可用带宽的位置。]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>TCP</tag>
        <tag>拥塞控制</tag>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用户数据报协议UDP]]></title>
    <url>%2F2019%2F%E7%94%A8%E6%88%B7%E6%95%B0%E6%8D%AE%E6%8A%A5%E5%8D%8F%E8%AE%AEUDP%2F</url>
    <content type="text"><![CDATA[一、UDP概述用户数据报协议UDP只在IP数据报服务之上增加了有限的功能，这就是端口的功能（有了端口，运输层就能进行复用和分用）和差错检测功能。虽然UDP用户数据报只能提供不可靠的交付，但UDP在某些方面有其特殊的优点，如下： UDP是无连接的，即发送数据之前不需要建立连接，因此减少了开销和发送数据之前的时延。 UDP使用尽最大努力交付，即不保证可靠交付，同时也不使用流量控制和拥塞控制，因此主机不需要维持具有很多参数的、复杂的连接状态表。 由于UDP没有拥塞控制，因此网络出现的拥塞不会使源主机的发送速率降低。这对某些实时应用时很重要的。 UDP是面向报文的。这就是说，UDP对应用程序交下来的报文不再划分为若干个分组来发送，也并把收到的若干个报文合并后再交给应用程序。应用程序交给UDP一个报文，UDP就发送这个报文；而UDP收到一个报文，就把它交付给应用程序。因此，应用程序必须选择合适大小的报文。若报文太长，UDP把它交给IP层后，IP层在传送时可能要进行分片，这会降低IP层的效率。反之，若报文太短，UDP就把它交给IP层后，会使IP数据报的首部相对太大，降低了IP层的效率。 UDP支持一对一，一对多，多对一和多对多的交互通信。 用户数据报只有8个字节的首部开销，比TCP的20个字节的首部要短得多。 二、UDP报文的首部格式UDP报文有两个字段：数据字段和首部字段。首部字段很简单，只有8个字节，由四个字段组成，每个字段都是两个字节。各字段意义如下： 源端口：源端口号 目的端口：目的端口号 长度：UDP用户数据报的长度 检验和：差错检验码，防止UDP用户数据报在传输中出错。 UDP报文首部中最重要的字段就是源端口和目的端口，它们用来标识UDP发送方和接收方。实际上，UDP是通过二元组（目的IP地址，目的端口号）来定位一个接收方应用进程，而用二元组（源IP地址，源端口号）来标识一个发送方进程。二元组（IP地址，端口号）被称为套接字地址。 一个UDP端口与一个报文队列（缓存）关联，UDP根据目的端口号将到达的报文加到相应的队列。应用进程根据需要的队列中读取整个报文。由于UDP没有流量控制功能，如果报文到达的速度长期大于应用进程从队列中读取报文的速度，则会导致队列溢出和报文丢失。 如果接收方UDP发现收到的报文中的目的端口号不正确（即不存在对应于该端口号的应用进程），则丢弃该报文，并由网际控制报文协议ICMP发送一个端口不可达的差错报文给对方1. UDP用户数据报首部中检验和的计算方法有些特殊。在1计算检验和时，要在UDP用户数据报之前增加12个字节的伪首部。所谓伪首部是因为这种伪首部并不是UDP用户数据报真正的首部。只是在计算检验和时，临时和UDP用户数据报连接在一起，得到一个临时的UDP用户数据报。检验和就是按照这个临时的UDP用户数据报来计算的。伪首部既不向下传送也不向上递交，而仅仅是为了计算检验和，防止报文被意外地交付到错误的目的地。 UDP计算检验和的方法和计算IP数据报首部检验和的方法相似。但不同的是：IP数据报的检验和只检验IP数据报的首部，但UDP的检验和是把首部和数据部分一起都检验。在发送方，首先是先把全零放入检验和字段。再把伪首部及UDP用户数据报看成是由许多16位的子串接起来。若UDP用户数据报的数据部分不是偶数个字节，则要填入一个全零字节（但此字节不发送）。然后按二进制反码计算出这些16位字的和。将此和的二进制反码写入检验和字段后，发送这样的UDP用户数据报。在接收方，把收到的UDP用户数据报连同伪首部一起，按为二进制反码求这些16位字的和，当无差错时其结果全为1，否则就表明有差错出现，接收方就丢弃这个UDP用户数据报，也可以上交给应用层，但附上出现差错的警告。这种简单的差错检验方法的检错能力并不强，但它的好处是简单，处理起来较快。 伪首部的第三字段是全零，第四个字段是IP首部中的协议字段的值。对于UDP，此协议字段值为17，第五字段是UDP用户数据报的长度。这样的检验和，既检查了UDP用户数据报的源端口号，目的端口号及UDP用户数据报的数据部分，又检查了IP数据报的源IP地址和目的地址。]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
        <tag>用户数据报协议</tag>
        <tag>UDP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[运输层概述]]></title>
    <url>%2F2019%2F%E8%BF%90%E8%BE%93%E5%B1%82%E6%A6%82%E8%BF%B0%2F</url>
    <content type="text"><![CDATA[一、进程之间的通信从通信和信息处理的角度看，运输层向它上面的应用层提供端到端通信服务。它属于面向通信部分的最高层，同时也是用户功能中的最底层。当位于网络边缘部分的两台主机使用网络核心部分的功能进行端到端的通信时，只有主机的协议栈才有运输层，网络核心部分中的路由器在转发分组时都只用到了下三层的功能。 从IP层看，通信的两端是两个主机。IP数据报的首部明确地标志了这两个主机的IP地址。然而严格地讲，两个主机进行通信实际上就是两个主机中的应用程序互相通信。IP协议虽然能把分组送到目的主机，但是这个分组还停留在主机的网络层而没有交付给主机中的应用程序。从运输层的角度看，通信的真正端点并不是主机而是主机中的进程。因此从运输层来看，端到端的通信是应用进程之间的通信。 在一个主机中经常有多个应用进程同时分别和另一个主机中的多个应用进程通信。因此，运输层的一个很重要的功能就是复用和分用。这里的复用是指在发送方不同的应用进程都可以使用同一个运输层协议传送数据，而分用是指接收方的运输层在剥去报文的首部后能够把这些数据正确地交付到目的应用进程。 运输层提供应用进程之间的逻辑通信指的是，运输层之间的通信好像是沿水平方向的传送数据，但事实上这两个传输层之间并没有与一条水平方向的物理连接。 网络层和运输层有很大的区别：网络层是为主机之间提供逻辑通信，而运输层是为应用进程之间提供端到端的逻辑通信。 运输层向高层用户屏蔽了下面网络核心的细节，它使应用进程看见的就是好像在两个运输层实体之间有一条端到端的逻辑通信信道，但这条逻辑通信信道对上层的表现却因运输层使用的不同协议而有很大的差别。 当运输层采用面向连接的TCP协议时，尽管下面的网络是不可靠的，但这种逻辑通信信道就相当于一条全双工的可靠信道。但当运输层采用无连接的UDP协议时，这种逻辑通信信道仍然是一条不可靠信道。 在网络中，两个进程要进行通信，必须有一个进程要主动发起通信，而另一个进程要事先准备好接受通信请求，这就是客户——服务器通信模式。在术语客户——服务器通信模式中，客户和服务器都是进行通信的应用进程，客户是主动发起通信的进程，而服务器是被动接受通信请求的进程。 二、因特网的运输层协议我们知道，因特网的网络层为主机之间提供的逻辑通信服务是一种尽最大努力交付的数据报服务。也就是说，IP报文在传送过程中有可能出错、丢失或失序。对于像电子邮件、文件传输、万维网以及电子银行等很多应用，数据丢失可能会造成灾难性的后果。因此，需要运输层为这类应用提供可靠的数据传输服务。但对于实时的多媒体应用，如实时音/视频，它们能够承受一定程度的数据丢失。在这些多媒体应用1中，丢失少量的数据会对播放的质量产生一些小的影响，但不会造成致命的损伤。为实现可靠数据传输，运输层协议必须增加很多复杂得多机制，而这些机制非但不能为这些多媒体应用带来明显的好处，而且会带来一些不利因素。总之，单一的运输层服务很难满足所有应用的需求。 因特网为上层应用提供了两个不同的运输层协议，即： 用户数据报协议UDP 传输控制协议TCP 按照OSI的术语，两个对等运输实体在通信时传送的数据单元叫做运输协议数据单元。但在因特网中，根据使用的协议是TCP还是UDP，分别称为TCP报文段或UDP报文或用户数据报。 UDP在传送数据之前不需要先建立连接。接收方运输层在收到UDP报文后，不需要给出任何确认。虽然UDP不提供可靠交付，但在某些情况下UDP却是一种最有效的工作方式。 TCP则提供面向连接的服务。在传送数据之前必须先建立连接，数据传送结束后要释放连接。TCP不提供广播或多播服务。由于TCP要提供可靠的、面向连接的运输服务，因此不可避免地增加了许多开销，如确认、流量控制、计时器及连接管理等。这不仅使协议数据单元的首部增大很多，还要占用许多的处理机资源。 三、运输层的复用与分用应用层所有的应用进程都可以通过运输层再传送到IP层，这就是复用。运输层从IP层收到数据后必须交付给指明的应用进程，这就是分用。运输层要能正确地将数据交付给指定应用继承，就必须给每个应用继承赋予一个明确的标志。在TCP/IP网络中，使用一种与操作系统无关的协议端口号来实现对通信的应用进程的标志。 端口是应用层与运输层之间接口的抽象，端口号是应用进程的运输层地址。为此，在运输协议数据单元的首部中必须包含两个字段：源端口号和目的端口号。当运输层收到IP层交上来的数据，就要根据其目的端口号来决定应当通过哪一个端口上交给目的应用进程。 对于不同的计算机，端口的具体实现方法可能有很大的差别，因为这取决于计算机的操作系统。因此端口的基本概念就是：应用层的源进程将报文发送给运输层的某个端口，而应用层的目的进程从端口接收报文。端口用一个16位端口号进行标志，但端口号只有本地意义。在因特网不同计算机中，相同的端口号是没有联系的，并且TCP和UDP端口号之间也没有必然联系。IP协议根据IP数据报中的协议字段定位要交付的运输层协议，而相应的运输层协议需要根据运输层协议数据单元中的目的端口号来确定要交付的引用进程。16位的端口号可以允许有65535个端口号，这个数目对于一个计算机来说是足够用的。 由此可见，两个计算机中的进程要相互通信，不仅要知道对方的IP地址，而且还要知道对方的端口号。我们知道应用进程间的通信采用的是客户——服务器通信模式，在应用层中的各种不同的服务器进程不断监听它们的端口，以便发现是否有某个客户进程要和它通信。客户在发起通信请求时，必须先找到对方服务器的IP地址和端口号，而服务器总是可以从接收到的报文中获得客户的IP地址和端口号。为此运输层的端口号供分为下面的3类。 熟知端口，0~1023.这类端口由因特网赋号管理局负责分配给一些常用的应用程序固定使用，因而所有用户进程都知道。当一种新的应用程序出现时要获得一个熟知的端口，必须向因特网赋号管理局申请。 登记端口：1024~49151.这类端口因特网赋号管理局不分配也不控制，但可以在因特网赋号管理局注册登记，以防止重复使用。 动态端口：49152~65535.这类端口是留給客户进程选择作为临时端口。当客户进程发起通信前要先为自己选择一个未用的临时端口，通信结束后要释放该端口以便其他客户进程使用。]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
        <tag>运输层</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[虚拟存储器]]></title>
    <url>%2F2019%2F%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8%2F</url>
    <content type="text"><![CDATA[一、虚拟存储器概述之前的各种存储器管理方式有一个共同的特点，即它们都要求将一个作业全部装入内存后方能运行，于是出现了下面两种情况： 有的作业很大，其所要求的内存空间超过了内存总容量，作业不能全部被装入内存，致使该作业无法运行 有大量作业要求运行，但由于内存容量不足以容纳所有这些作业，只能将少数作业装入内存让它们先运行，而将其他大量的作业留在外存上等待。 解决方法： 从物理上增加内存容量 从逻辑上扩充内存容量，即虚拟存储技术 常规存储管理方式的特征和局部性原理 常规存储器管理方式的特征： 一次性 驻留性 局部性原理 程序在执行时将呈现出局部性规律，即在一个较短的时间内，程序的执行仅局限于某个部分，相应地，它所访问的存储空间也局限于某个区域。 程序执行时，除了少部分的转移和过程调用指令外，大多数情况下是顺序执行的 过程调用将会使程序的执行轨迹由一部分区域转至另一部分区域 程序中存在许多循环结构，这些结构虽然由少数指令构成，但是它们将被多次执行 程序中还包括许多对数据结构方面的处理，如对数组进行操作，这些处理往往都局限于很小的范围内。 局限性又表现在下述两个方面： 时间局限性。产生原因是，在程序中存在着大量的循环操作 空间局限性。典型情况是程序的顺序执行 虚拟存储器的基本工作情况 &emsp;&emsp;基于局部性原理可知，应用程序在运行之前没有·必要将之全部装入内存，而仅须将那些当前要运行的少数页面或段先装入内存便可运行，其余部分暂留在盘上。 &emsp;&emsp;程序在运行时，如果它所要访问的页（段）已调入内存，便可继续执行下去；但如果程序所要访问的页（段）尚未调入内存（称为缺页或缺段），便发出缺页（段）中断请求，此时OS将利用请求调页（段）功能将它们调入内存，以使进程能继续执行下去 &emsp;&emsp;如果此时内存已满，无法再装入新的页（段），OS还须再利用页（段）的置换功能，将内存中暂时不用的页（段）调至盘上，腾出足够的内存空间后，再将要访问的页（段）调入内存，使程序继续执行下去。这样，便可使一个大的用户程序在较小的内存空间中运行，也可在内存中同时装入更多的进程，使它们并发执行。 虚拟存储器的定义和特征 虚拟存储器的定义 &emsp;&emsp;所谓虚拟存储器是指具有请求调入功能和置换功能，能从逻辑上对内存容量加以扩充的一种存储器系统其逻辑容量由内存容量和外存容量之和决定，其运行速度接近于内存速度，而每位的成本又接近与外存。可见，虚拟存储技术是一种性能非常优越的存储器管理技术，故被广泛地应用于大、中、小型机器和微型机中。 虚拟存储器的特征 多次性 对换性 虚拟性 虚拟性是以多次性和对换性为基础的；而多次新和对换性显然又必须建立在离散分配的基础上。 虚拟存储器的实现方法&emsp;&emsp;虚拟存储器的实现，建立在离散分配存储管理方式的基础上。 分页请求系统 分页请求系统是在分页系统的基础上增加了请求调页功能和页面置换功能所形成的页式虚拟存储系统。置换时以页面为单位。 硬件支持 请求分页的页表机制，它是在纯分页的页表机制上增加了若干项而形成的，作为请求分页的数据结构 缺页中断机构，每当用户程序要访问的页面尚未调入内存时，便产生一缺页中断，以请求OS将所缺页面调入内存 地址变换机构，它同样是在存分页地址变换机构的基础上发展形成的 实现请求分页的软件 这里包括有用于实现请求调页的软件和实现页面置换的软件。它们在硬件的支持下，将程序正在运行时所需的页面调入内存，再将内存中暂时不用的页面从内存置换到磁盘上。 请求分段系统 请求分段系统是在分段系统的基础上，增加了请求调段及分段置换功能后所形成的段式虚拟存储系统。置换时以段为单位进行的。 硬件支持 请求分段的段表机制。它是在纯分段的段表机制上增加了若干项而形成的，作为请求分段的数据结构 缺段中断机构。每当用户程序要访问的段尚未调入内存时，便产生一缺段中断，以请求OS将所缺的段调入内存 地址变换机构，它同样是在纯分段地址变换机构的基础上发展形成的。 软件支持 包括有用于实现请求调段的软件和实现段置换的软件。 目前，有不少虚拟存储器是建立在段页式系统基础上的，通过增加请求调页和页面置换功能形成了段页式虚拟存储器系统，而且把实现虚拟存储器所需支持的硬件集成在处理器芯片上。 二、请求分页储存管理方式 请求分页中的硬件支持 请求页表机制 需要的主要数据结构是请求页表，其基本作用仍是将用户地址空间中的逻辑地址映射为内存空间中的物理地址。为了满足页面换进换出的需要，在请求页表中又增加了四个字段。这样，在请求分页系统这两个的每个页表应含有： 页号 物理块号 状态位P，用于指示该页是否已调入内存 访问字段A，用于记录本页被访问的词素，或记录本页最近已有多长时间未被访问 修改位M，标识该页在调入内存后是否被修改过 外存地址，用于指出该页在外存上的地址，通常是物理块号 缺页中断机构 在请求分页系统中，每当所要访问的页面不在内存时，便产生一缺页中断，请求OS将所缺页面调入内存。缺页中断作为中断，与一般的中断有很明显的区别： 在指令执行期间产生和处理中断信号 一条指令在执行期间可能产生多次缺页中断 地址变换机构 &emsp;&emsp;请求分页系统中的地址变换机构是在分页系统地址变换机构的基础上，为实现虚拟存储器，再增加一些功能所形成的，如产生和处理缺页中断，以及从内存中换出一页的功能等等。 &emsp;&emsp;在进行地址变换时，首先检索快表，试图从中找出所要访问的页。若找到，便修改页表项中的访问位，供置换算法选换出页面时参考。对于写指令，还须将修改位置成“1”，表示该页在调入内存后已被修改。然后利用页表项给出的物理块号和页内地址形成物理地址。地址变换过程到此结束。 &emsp;&emsp;如果在快表中未找到该页的页表项，则应到内存中去查找页表，再从找到的页表项中的状态位P来了解该页是否已调入内存。若该页已调入内存，这时应将该页的页表项写入快表。当快表已满时，则应先调出按某种算法所确定的页表项，然后再写入该页表项；若该页尚未调入内存，这时应产生缺页中断，请求OS从外存把该页调入内存。 请求分页中的内存分配在为进程分配内存时，将涉及到三个问题：第一，为保证进程能正常运行，所需要的最小物理块数的确定；第二，在为每个进程分配物理块时，应采取什么样的分配策略，即所分配的物理块是固定的，还是可变的；第三，为不同进程所分配的物理块数，是采取平均分配算法，还是根据进程的大小按比例分配。 最小物理块数的确定 &emsp;&emsp;随着为每个进程所分配的物理块的减少，将使进程在执行中的缺页率上升，从而降低进程的执行速度。 &emsp;&emsp;最小物理块数是指能保证进程正常运行所需的最小物理块数，当系统为进程分配的物理块数少于此值时，进程将无法运行。 &emsp;&emsp;进程应获得的最少物理块树，与计算机的硬件结构有关，取决于指令的格式、功能和寻址方式。对于某些简单的机器，若是单地址指令，且采用直接寻址方式，则所需的最少物理块数为。其中，一块是用于存放指令的页面，一块这是用于存放数据的页面。如果该机器运行间接寻址，则至少要求有三个物理块。 &emsp;&emsp;在缺页中断结构要发生6次中断，那么，至少要为每个进程分配6个物理块，以装入6个页面。 内存分配策略 在请求分页系统中，可采取两种内存分配策略，即固定和可变分配策略。 在进行置换时，也可采取两种策略，即全局置换和局部置换。 固定分配局部置换 所谓固定分配，是指为每个进程分配一组固定数目的物理块，在进程运行期间不再改变。 局部置换，是指如果进程在运行中发现缺页，则只能从分配给该进程的n个页面中选出一页换出，然后再调入一页，以保证分配给该进程的内存空间不变。 采用该策略时，为每个进程分配多少物理块是根据进程类型或根据程序员，程序管理员的建议来确定的 该策略的困难之处是：应为每个进程分配多少个物理块难以确定。5 可变分配全局置换 可变分配，是指事先为每个进程分配一定数目的物理块，在进程运行期间，可根据情况做适当的增加或减少。 全局置换，是指如果进程在运行中发现缺页，则将OS所保留的空闲物理块取出一块分配给该进程，或者以所有进程的全部物理块为标的，选择一块换出，然后将所缺页面调入。 采用这种策略时，凡产生缺页的进程，都将获得新的物理块，仅当空闲物理块队列中的物理块用完时，OS才能从内存中选择一页调出。被选择调出的页可能是系统中任何一个进程中的页，因此这个被选中的进程拥有的物理块会减少，这将导致其缺页率增加。 可变分配局部置换 该策略同样是基于进程的类型或程序员的要求，为每一个进程分配一定数目的物理块，但当某进程发现缺页时，只允许从该进程在内存中的页面选择一页调出，这样就不会影响其他进程的运行。如果进程在运行中频繁发生缺页中断，则系统须再为该进程分配若干附加物理块，直至该进程的缺页率减少到适当程度为止。反之，若其他进程缺页率高，该进程缺页率低，会适当减少分配给该进程的物理块函数。 物理块分配算法 平均分配算法 将系统中所有可供分配的物理块平均分配给各个进程。 但是这种方式不公平，因为未考虑每个进程的页面数。 按比例分配算法 根据进程的大小按比例分配物理块。 考虑优先权的分配算法 一部分按比例分配给各个进程 另一部分根据各进程的优先权进行分配。重要的实时系统中，可能是完全按优先权为各个进程分配其物理块的。 页面调入策略为使进程能够正常运行，必须事先将要执行的那部分程序和数据所在的页面调入内存，现在的问题是： （1）系统应该何时调入所需页面 （2）系统应从何处调入这些页面 （3）是如何进行调入的 何时调入页面 预调页策略 以预测为基础的预调页策略，将那些预计在不久以后便会被访问的页面预先调入内存。目前，预调页的成功率仅为50% 首先可用于在第一将进程调入内存时，此时可将程序员指出的那些页先调入内存。其次是，在采用工作集的系统中，每个进程都具有一张表，表中记录有运行时的工作集，每当程序被调度运行时，将工作集中的所有页调入内存 请求调页策略 当进程在运行中需要访问某部分程序和数据时，如偶发现其所在的页面不在内存中，便立即提出请求，由OS将其所需页面调入内存。 该策略每次仅调入一页，效率低，系统的开销大 从何处调入页面 系统拥有足够的对换区空间，这时可以全部从对换区调入所需页面，以提高调页速度。 系统缺少足够的对换区空间，这是凡是不会被修改的文件，都直接从文件区调入；而当换出这些页面时，由于它们未被修改，则不必再将它们重写到磁盘以后再调入时，仍从文件区直接调入。对于那些可能被修改的部分，在将它们换出时便须调到对换区，以后需要再从对换区调入 UNIX方式。由于与进程有关的文件都放在文件区，故凡是未运行过的页面，都应从文件区调入。而对于曾经运行过但又被换出的页面，由于是被放在对换区，因此在下次调入时应从对换区调入。由于UNIX系统允许页面共享，因此，某进程所请求的页面有可能已被其他进程调入内存，此时也就无需再从对换区调入。 页面调入过程 &emsp;&emsp;每当程序所要访问的页面未在内存时，便向CPU发出一缺页中断，中断处理程序首先保留CPU环境，分析中断原因后转入缺页中断处理程序。 &emsp;&emsp;该程序通过查找页表得到该页在外存的物理块后，如果此时内存能容纳新页，则启动磁盘I/O，将所缺页面调入内存，然后修改页表。 &emsp;&emsp;如果内存已满，则须先按某种置换算法，从内存中选出一页准备换出：如果该页未被修改过，可不必将该页写回磁盘，并修改页表中的相应表项，置其存在位为“1”，并将此页表项写入快表。在缺页调入内存后，利用修改后的页表形成所要访问数据的物理地址，再去访问内存数据，整个页面的调入过程对于用户来说是透明的。 缺页率 在进程运行的过程中，访问页面成功的次数为S，访问页面失败的次数为F，则该进程总的页面访问次数为A=S+F,那么该进程在其运行过程中的缺页率即为： ​ f=$\frac{F}{A}$ 通常，缺页率受到以下几个因素的影响： 页面大小，页面划分越大，缺页率越低 进程所分配物理块数。分配的物理块数越多，缺页率越低 页面置换算法 程序固有特性：程序本身的编制方法对缺页中断次数有影响。根据程序执行的局部性原理，程序编制的局部化程度越高，相应地执行时的缺页程度越低。 三、页面置换算法通常，把选择换出页面的算法称为页面置换算法。置换算法的好好直接影响到系统的性能。 不适当的算法可能会导致进程发生“抖动”，即刚被换出的页很快又要被访问，需要将它重新调入，此时又需要再选一页调出；而此刚被调出的页很快又被访问，又须将它调入，如此频繁的更换页面，以致一个进程在运行中把大部分时间都花费在了页面置换工作上，我们称该进程发生了“抖动”。好的置换算法应具有较低的页面更换频率。 最佳置换算法其选择的被淘汰的页面将使以后永不再使用的，或许是在最长时间内不再被访问的页面。采用最佳置换算法可以获得较低的缺页率，但是无法预知哪个页面是未来最长时间内不再被访问的，因而该算法无法实现。 先进先出置换算法（FIFO) 总是淘汰最先进入内存的页面，即选择在内存中驻留时间最久的页面予以淘汰。该算法实现简单。 一个替换指针，指向最老的页面。 换页频率是最佳置换算法的两倍 最近最久未使用置换算法（LRU） 根据页面调入内存后的使用情况作出决策。 LRU置换算法是选择最近最久未使用的页面予以淘汰。该算法赋予每个页面一个访问了字段，用来记录一个页面自上次被访问以来经历的时间t。淘汰时i，选择了t最大的淘汰。 LRU的硬件支持 寄存器 栈 最少使用置换算法（LFU） 在内存中为每个页面设置一个移位寄存器，用来记录该页面被访问的频率。选择在最近时期使用最少的页面作为淘汰值。 采用的是在较大时间间隔来记录对该页的访问 利用LRU中的硬件，可以实现LFU Clock置换算法 Clock算法是一种LRU近似算法 简单的Clock置换算法 为每页设置一未访问位，再将内存中的所有页面都通过链接指针链接成一个循环队列。 当某页被访问时，其访问位置1。选择页面淘汰时，只需检查页的访问位，如果是0，换出，若为1，重新将其置0，暂不换出，给予该页面第二次驻留内存的机会。 再按照FIFO算法检查下一个页面。当检查到队列中最后一个页面时，若其访问位仍是1，则再返回到队首去检查第一个页面。 又称为最近未用算法（NRU） 改进型Clock置换算法 在这个算法中，除了要考虑页面的使用情况外，还须再增加一个因素——置换代价。这样，选择页面换出时，既要是未使用过的页面，又要是未秀爱过的页面。把同时满足这两个条件的页面作为首选淘汰的页面。 由访问位A和修改位M可以组合成下面四种类型的页面： A=0，M=0：表示该页最最近既没有被访问，也没有被修改，是最佳淘汰页 A=0，M=1：该页未被访问，已被修改，不是很好的淘汰页 A=1，M=0，该页已被访问，未被修改，很有可能再次被访问 A=1，M=1，被访问且被修改，该页可能再次被访问 执行过程分为三步： 从指针所指示的当前位置开始，扫描循环队列，寻找A=0且M=0的第一类页面，将所遇到的第一个页面作为选中的淘汰页。在第一次扫描期间不改变访问位A 第一步失败，开始第二轮扫描，寻找第二类页面，将所遇到的第一个该类页面作为淘汰页。在第二轮扫描期间，将所有扫描过的页面的访问位置0 第二步失败，将指针返回到最开始的位置，将所有的访问位置0，重复第一步。 该算法比简单的Clock算法减少了I/O操作次数。但本身开销有所增加。 页面缓冲算法 影响页面换进换出效率的若干因素 页面置换算法 写回磁盘的速率 读入内存的频率 页面缓冲算法PBA 主要特点： 显著降低了页面换进、换出的频率，使磁盘I/O数大为减少 由于换进换出的开销大幅度减小，才能使其采用一种较简单的置换策略，如FIFO算法，不需要特殊的硬件支持 空闲页面链表 实际上该链表是一个空闲物理块链表，是系统掌握的空闲物理块，用于分配给频繁发生缺页的进程，以降低缺页率 当这样的进程需要读入一个页面时，便可利用空闲物理块链表中的第一个物理块来装入该页 当有一个未被修改的页要换出时，实际上并不把它换出到外存，而是把它们所在的物理块挂在空闲链表的末尾。 修改页面链表 它是由已修改的页面所形成的链表 设置该链表的目的是为了减少已修改页面换出的次数 当该进程需要将一个已修改的页面换出时，系统并不立即将它换出到外存上，而是将它所在的物理块挂在修改页面链表的末尾。这样做的目的是：降低将已修改页面写回磁盘的频率，降低将磁盘内容读入内存的频率 访问内存的有效时间 被访问页在内存中，且其对应的页表项在快表中 查找快表时间λ，访问实际物理内存所需的时间t EAT=λ+t 被访问页在内存中，且其对应的页表项不在快表中 查找快表的时间，修改快表的时间和访问实际物理地址的时间 EAT=λ+t+λ+t 被访问页不在内存中 查找快表的时间、查找页表的时间、处理缺页中断的时间（ε）、更新快表的时间、实际访问物理地址的时间 EAT=λ+t+ε+λ+t 四、“抖动”与工作集 多道程序度与“抖动” 多道程序度与处理机的利用率 由于虚拟存储器系统能从逻辑上扩大内存，这时，只需装入一个进程的部分程序和数据便可开始运行，故人们希望在系统中能运行更多的进程，即增加多道程序度，以提高处理机的利用率 进程数目增加，处理机利用率剧烈增加；进程再增加，处理机利用率加速下降趋于0，即发生抖动。 产生“抖动”的原因 根本原因是，同时在系统中运行的进程太多，由此分配给每一个进程的物理块太少，不能满足进程正常运行的基本要求，致使每个进程在运行时，频繁地出现缺页，必须请求系统将所缺的页面调入内存。 这会使得系统中排队等待页面调入/调出的进程数目增加，对磁盘的访问时间也随之急剧增加。 由于“抖动”的发生与系统为进程分配的物理块的多少有关，于是出现了“工作集” 工作集 工作集的基本概念 基于程序运行时的局部性原理可知，程序在运行期间，对页面的访问时不均匀的，在一段时间内仅局限于较少的页面，在另一段时间内，可能仅局限于另一些较少的页面进行访问。这些页面被称为活跃页面。如果能够预知程序在某段时间间隔要访问哪些页面，并将它们调入内存，将会大大降低缺页率，从而显著地提高处理机的利用率 工作集的定义 所谓工作集，是指某段时间间隔A里，进程实际所要访问页面的集合。 “抖动”的预防方法 采取局部置换策略 在页面分配和置换中，如果采取的是可变分配方式，则为了预防发生“抖动”，可采取局部置换策略。根据这种策略，当某进程发生缺页时，只能在分配給自己的内存空间内进行置换，不允许从其他进程去获得新的物理块。 该策略将该进程“抖动”所造成的影响限制在较小的范围内。 该方法虽然简易可行，但效果不是很好，因为在某进程发生“抖动”后，它还会长期处在磁盘I/O的等待队列中，使队列的长度增加，这会延长其他进程缺页中断的处理时间。 把工作集算法融入到处理机调度中 在调度算法中融入了工作集算法，则在调度程序从外存调入作业之前，必须先检查每个进程在内存的主流页面是否足够多。如果都已足够多，此时便可以从外存调入新的作业，不会因新作业的调入而导致缺页率的增加，反之，如果有些进程的内存页面不足，则应首先为那些缺页率高的作业增加新的物理块，此时不再调入新的作业。 利用“L=S”准则调节缺页率 “L=S”的准则来调节多道程序度，L是缺页之间的平均时间，S是平均缺页服务时间，即用于置换一个页面所需的时间。 如果是L远大于S，说明很少发生缺页，磁盘的能力尚未得到充分的证明 如果L比S小，说明频繁发生缺页，缺页的速度已超过磁盘的处理能力 只有当L与S接近时，磁盘和处理机都可达到它们的最大利用率 选择暂停的进程 发生“抖动”，系统必须减少多道程序的数目 此时，应基于某种原则选择暂停某些当前活动的进程，将它们调出到磁盘上，以便腾出的内存空间分配给缺页率发生偏高的进程 通常采用与调度程序一致的策略，即首先选择暂停优先级最低的进程 五、请求分段存储管理方式分段基础上建立的请求分段式虚拟存储器系统，则是以分段为单位进行换入换出的。 请求分段中的硬件支持所需的硬件支持有段表机制、缺段中断机构以及地址变换机构 请求段表机制 段名 段长 段基址 存取方式。由于应用程序中的段是信息的逻辑单位，可根据该信息的属性对它实施保护，故在段表中增加存取方式字段，如果该字段为两位，则存取属性是只执行、只读和允许读/写 访问字段A，记录该段是否被访问 修改位M，记录该页在进入内存后是否被修改 存在位P，指示该段是否已调入内存 增补位，请求分段式管理中所特有的字段，用于表示本段在运行过程中是否做过动态增长 外存始址，指示本段在外存中的起始地址，即起始盘号 缺段中断机构 在请求分段系统中采用的是请求段策略 所要访问的段未被调入内存时，由中断机构产生一缺段中断信号 缺段中断机构需要一条指令的执行期间产生执行和处理中断，以及在一条指令执行期间，可能产生多次缺段中断 由于分段是信息的逻辑单位，因而不可能出现一条指令被分割在两个分段中 由于段不是定长的，这使对缺段中断的处理比对缺页中断的处理复杂 地址变换机构 请求分段系统中的地址变换机构是在分段系统地址变换机构的基础上形成的。因为被访问的段并非全在内存，所以在地址变换后，若发现所要访问的段不在内存分钟，必须先将所缺的段调入内存，并修改段表，然后再利用段表进行地址变换。 分段的共享与保护 共享段表 为了实现分段共享，可在系统中配置一张共享段表，所有歌共享段都在共享段表中占有一表项。在表项上记录了共享段的段号、段长、内存始址、状态存在位、外存始址以及共享计数信息。 共享进程计数count。记录多少进程正在共享该段。系统示范该段时，首先检查count是否为0，为0才可以回收 存取控制字段。对于一个共享段，应为不同的进程矛不同的存取权限 段号，对于一个共享段，在不同的进程中可以具有不同的段号，每个进程可用自己进程的段号去访问该共享段。 共享段的分配与回收 共享段的分配 在为共享段分配分配内存时，对第一个请求使用该共享段的进程，由内存分配方法有所不同。在为共享段分配内存时，对第一个请求使用该共享段的进程，由系统为该共享段分配一物理区，再把共享段调入该区，同时将该区的始址填入请求进程的段表的相应项中，还须再共享段表中增加以表项，填写请求使用该共享段的进程名、段号和存取控制等有关数据，把count置为1. 当又有其他进程需要调用该共享段时，由于该共享段已被调入内存，股此时无须再为该段分配内存，而只需在进程的段表中增加一表项，填写该共享段的物理地址。在共享段的段表中增加一个表项，填上调用进程的进程名、该共享段在本进程中的段号、存取控制等，再自行count=count+1操作，以表明有两个进程共享该段。 共享段的回收 当共享此段的某进程不再需要该段时，应将该段释放，包括撤销在该进程段表中共享段对应的表项，以及执行count=count-1操作。若结果为0，该段由系统管理回收，以及取消在共享段表中该段所对应的表项，表明此时已没有进程使用该段；否则，只是取消调用者进程在共享段表中的有关记录。 分段保护 越界检查 存取控制检查 只读 只执行 读/写 环保护机构 低编号的环具有高优先级 一个程序可以访问驻留在相同环或较低特权环（外环）的数据 一个程序可以调用驻留在相同环或高特权环（内环）中的服务]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
        <tag>虚拟存储器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[存储器管理]]></title>
    <url>%2F2019%2F%E5%AD%98%E5%82%A8%E5%99%A8%E7%AE%A1%E7%90%86%2F</url>
    <content type="text"><![CDATA[一、存储器的层次结构 存储器的多层结构 最高层：CPU寄存器 中间：主存 高速缓存 主存储器 磁盘缓存 底层：辅存 固定磁盘 可移动存储介质 二、连续分配存储管理方式 单一连续分配 &emsp;&emsp;在单道程序环境下，当时的存储器管理方式是把内存分为系统区和用户区两部分，系统区仅提供给OS使用，它通常是放在内存的低址部分。而在用户区内存中，仅装有一道用户程序，即整个内存的用户空间由该程序独占。这样的存储器分配方式被称为单一连续分配方式。 固定分区分配 &emsp;&emsp;为了能在内存中装入多道程序，且使这些程序之间又不会发生相互干扰，于是将整个用户空间划分为若干个固定大小的区域，使每个分区中只装入一道作业，这样就形成了最早的、也是最简单的一种可运行多道程序的分区式存储管理方式。如果在内存中有四个用户分区，便允许四个程序并发执行。当有一个空闲分区时，便可以再从外存的后备作业队列中选择一个适当大小的作业，装入该分区。当作业结束时，又可再从后备队列中找出另一作业调入该分区。 动态分区分配 动态分区分配又称为可变分区分配，它是根据进程的实际需要，动态地为之分配内存空间。 动态分区分配中的数据结构 空闲分区表 空闲分区链 动态分区分配算法 为把一个新作业装入内存，须按照一定的分配算法，从空闲分区表或空闲分区链中选出一分区分配给该作业。 分区分配操作 分配内存 系统应利用某种分配算法，从空闲分区链（表）中找到所需大小的分区。 回收内存 当进程运行完毕释放内存时，系统根据回收区的首址，从空闲区链（表）中找到相应的插入点，此时可能出现以下四种情况之一： 回收区与插入点的前一个空闲分区$F_1$相邻接。此时应将回收区与插入带来的前一分区合并，不必为回收分区分配新表项，而只修改其前一分区$F_1$的大小 回收分区与插入点的后一空闲分区$F_2$相邻接。此时也可将两分区合并，形成新的空闲分区，但用回收区的首址作为新空闲区的首址，大小为两者之和。 回收区同时与插入点的前、后两个分区邻接。此时将三个分区合并，使用$F_1$的表项和$F_1$的首址，取消$F_2$的表项，大小为三者之和。 回收区既不与$F_1$邻接，又不与$F_2$邻接。这时应为回收区单独建立一个新表项，填写回收区的首址和大小，并根据其首址插入到空闲链中的适当位置。 基于顺序搜索的动态分区分配算法 首次适应算法（FF) &emsp;&emsp;FF算法要求空闲分区链以地址递增的次序链接。在分配内存时，从链首开始顺序查找，直至找到一个大小能满足要求的空闲分区为止。然后再按照作业的大小，从该分区中划出一块内存空间，分配给请求者，余下的空闲分区仍留在空闲链中。若从链表直至链尾都不能找到一个能满足要求的分区，则表明系统中没有足够大的内存分配给该进程，内存分配失败，返回。 循环首次适应算法(NF) &emsp;&emsp;为避免低址部分留下许多很小的空闲分区，以减少查找可用空闲分区的开销，循环首次适应算法在为进程分配内存空闲时，不再是每次都从链首开始查找，而是从上次找到的空闲分区的下一个空闲分区开始查找，直至找到一个能满足要求的空闲分区，从中划出一块与请求大小相等的内存空闲分配给作业。 最佳适应算法(BF) &emsp;&emsp;所谓“最佳”是指，每次为作业分配内存时，总能把满足要求，又是最小的空闲分区分配给作业，避免“大材小用”。为了加速寻找，该算法要求将所有的空闲分区按其容量从小到大的顺序形成一空闲分区链。 最坏适应算法(WF) &emsp;&emsp;由于最坏适应分配算法选择空闲分区的策略正好与最佳适应算法相反：它在扫描整个空闲分区表或链表时，总是他挑选一个最大的空闲区，从中分割一部分存储空间给作业使用，以至于存储器中缺乏大的空闲分区，故把它称为是最坏适应算法。 基于索引搜索的动态分区分配算法 &emsp;&emsp;基于顺序搜索的动态分区分配算法，比较适用于不太大的系统。当系统很大时，系统中的内存分区可能会很多，相应的空闲分区链就可能很长，这时采用顺序搜索分区方法可能会很慢。为了提高搜索空闲分区的速度，在大、中型系统中往往会采用基于索引搜索的动态分区算法。 快速适应算法 &emsp;&emsp;该算法又称为分类搜索法，是将空闲分区根据其容量大小进行分类，对于每一类具有相同容量的所有空闲分区，单独设立一个空闲分区链表，这样系统中存在多个空闲分区链表。同时，在内存中设立一张管理索引表，其中的每一个索引表项对应了一种空闲分区类型，并记录了该类型空闲分区链表表头的指针。空闲分区的分类是根据进程常用的空间大小进行划分的。 伙伴系统 &emsp;&emsp;该算法规定，无论已分配分区或空闲分区，其大小均为2的k次幂。通常$2^m$是整个可分配内存的大小。假设系统的可利用空间容量为$2^m$个字，则系统开始运行时，整个内存区是一个大小为$2^m$的空闲分区。在系统运行过程中，由于不断地划分，将会形成若干个不连续的空闲分区，将这些空闲分区按分区的大小进行分类。对于具有相同大小的所有空闲分区，单独设立一个空闲分区双向链表，这样，不同大小的空闲分区形成了k个空闲分区链表。 &emsp;&emsp;当需要为进程分配一个长度为n的存储空间时，首先计算一个i值，使$2^{i-1}$&lt;n&lt;=$2^i$,然后再空闲分区大小为$2^i$的空闲分区链表中查找。若找到，即把该空闲分区分配给进程。否则，表明长度为$2^i$的空闲分区已经耗尽，则在分区大小为$2^{i+1}$的空闲分区链表中寻找。若存在$2^{i+1}$的空闲分区，则把该空闲分区分为相等的两个分区，这两个分区称为一对伙伴，其中的一个分区用于分配，而把另一个加入分区大小为$2^i$的空闲分区链表中。 &emsp;&emsp;若大小为$2^{i+1}$的空闲分区也不存在，则需要查找大小为$2^{i+2}$的空闲分区，若找到则也对其进行两次分割：第一次，将其分割为大小为$2^{i+1}$的两个分区，一个用于分配，一个加入到大小为$2^{i+1}$的空闲分区链表中；第二次，将第一次用于分配的空闲区分割为$2^i$的两个分区，一个用于分配，另一个加入到大小为$2^i$的空闲链表中。若找不到，则继续查找大小为$2^{i+3}$的空闲分区，依次类推。由此可见，在最坏情况下，可能需要对$2^k$的空闲分区进行k次分割才能得到所需分区。 &emsp;&emsp;与一次分配可能要进行多次分割一样，一次回收也可能要进行多次合并，如回收大小为$2^i$的空闲分区时，若事先已存在$2^i$的空闲分区，则应将其伙伴分区合并为大小为$2^{i+1}$的空闲分区，若事先已存在$2^{i+1}$的空闲分区，又应继续与其伙伴分区合并为大小为$2^{i+1}$的空闲分区，依次类推。 哈希算法 &emsp;&emsp;哈希算法就是利用哈希快速查找的优点，以及空闲分区在可利用空闲区表中的分布规律，建立哈希函数，构造一张以空闲分区大小为关键字的哈希表，该表的每一表项记录了一个对应的空闲分区链表表头指针。 &emsp;&emsp;当进行空闲分区分配时，根据所需空闲分区大小，通过哈希函数计算，即得到在哈希表中的位置，从中得到相应的空闲分区链表，实现最佳分配策略。 三、对换 对换的类型 &emsp;&emsp;在每次对换时，都是将一定数量的程序或数据换入或换出内存。根据每次对换时所对换的数量，可以将对换分为如下两类： 整体对换 页面（分段）对换 对换空间管理的主要目标 对文件区管理的主要目标 &emsp;&emsp;文件区占用磁盘空间的大部分，用于存放各类文件。由于通常的文件都是较长时间地驻留在外存上，对它访问的频率是较低的，故对文件区管理的主要目标是提高文件存储空间的利用率，然后才是提高对文件的访问速度。因此，对文件区空间的管理采取离散分配方式。 对对换空间管理的主要目标 &emsp;&emsp;对换空间只占用磁盘空间的小部分，用于存放从内存换出的进程。由于这些进程在对换区中驻留的时间是短暂的，而对换操作的频率却较高，故对对换空间管理的主要目标，是提高进程换入和换出的速度，然后才是提高文件存储空间管理的利用率。为此，对对换空间的管理采取连续分配方式，较少考虑外存中的碎片问题。 对换区空闲盘块管理中的数据结构 &emsp;&emsp;为了实现对对换区中的空闲盘块的管理，在系统中配置相应的数据结构，用于记录外存对换区中的空闲盘块的使用情况。其数据结构的形式与内存在动态分区分配方式中所用数据结构相似，即同样可以用空闲分区表或空闲分区链。在空闲分区表的每个表目中，应包含两项：对换区的首址及其大小，分别用盘块号和盘快速表示。 对换空间的分配与回收 分配算法可以是首次适应算法、循环首次适应算法、最佳适应算法等 回收操作分为四种情况： 回收分区与插入点的前一空闲分区$F_1$相邻接 回收分区与插入点的后一个空闲分区$F_2$相邻接 回收分区同时与插入点的前、后两个分区邻接 回收分区既不与$F_1$邻接，又不与$F_2$邻接 进程的换出 &emsp;&emsp;对换进程在实现进程换出时，是将内存中的某些进程调出至对换区，以便腾出内存空间。换出过程可分为以下两步： 选择被换出的进程 进程换出过程 申请对换空间，若申请成功，就启动磁盘，将该进程的程序和数据传送到磁盘的对换区上。 若传送过程未出现错误，便可回收该进程所占用的内存空间，并对该进程的进程控制块和内存分配表等数据结构做相应的修改。 若此时内存中海油可换出的进程，则继续执行换出过程，直到内存中再无阻塞进程为止。 进程的换入 &emsp;&emsp;对换进程将定时执行换入操作，它首先查看PCB集合中所有进程的状态，从中找出“就绪”状态但已换出的进程。当有许多这样的进程时，它将选择其中已换出到磁盘上时间最久的进程作为换入进程，为它申请内存。如果申请成功，可直接将进程从外存调入内存；如果失败，则需先将内存中的某些进程换出，腾出足够的内存空间后，再将进程调入。 &emsp;&emsp;在对换进程成功地换入一个进程后，若还有可换入的进程，则再继续执行换入换出过程，将其余处于“就绪且换出”状态的进程陆续换入，直到外存中再无“就绪且换出”状态的进程为止，或者已无足够的内存来换入进程，此时对换进程才停止换入。 四、分页存储管理方式 分页存储管理的基本方法 页面和物理块 页面。分页存储管理将进程的逻辑地址空间分成若干页，并为各页加以编号。相应地，也把内存的物理地址空间分成若干个块，同样也为它们加以编号。在为进程分配内存时，以块为单位，将进程中的若干个页分别装入到多个可以不相邻接的物理块中。由于进程的最后一页经常装不满一块，而形成了不可利用的碎片，称之为“页内碎片”。 页面大小。页面的大小应选择适中，且页面大小应是2的幂，通常为1KB~8KB。 地址结构 分页地址中的地址结构如下: 它包含两部分内容：前一部分为页号P，后一部分为位偏移量W，即页内地址。 页表 在分页系统中，允许将进程的各个页离散地存储在内存的任一物理块中，为保证进程仍然能够正确地运行，即能在内存中找到每个页面所对应的物理块，系统又为每个进程建立了一张页面映像表，简称页表。 地址变换机构 &emsp;&emsp;为了能将用户空间中的逻辑地址转换为内存空间中的物理地址，在系统中必须设置地址变换机构。该机构的基本任务是实现从逻辑地址到物理地址的转换。由于页内地址和物理地址是一一对应的，因此，地址变换结构的任务实际上只是将逻辑地址中的页号转换为内存中的物理块号。又因为页面映射表的作用就是用于实现从页号到物理块号的变换，因此，地址变换任务是借助页表来完成的。 两级页表 针对难于找到大的连续的内存空间来存放页表的问题，可利用将页表进行分页的方法，使每个页面的大小与内存物理块的大小相同，并为它们进行编号，然后离散地将各个页面分别存放在不同的物理块中。 同样，也要为离散分配的页表再建立一张页表，称为外层页表，在每个页表项中记录了页表页面的物理块号。 反置页表 &emsp;&emsp;为了减少页表占用的内存空间，引入了反置页表。一般页表的页表项是按页号进行排序的，页表项中的内容是物理块号。而反置页表则是为每个物理块设置一个页表项，并将它们按物理块的编号排序，其中的内容则是页号和其所隶属进程的标识符。 五、分段存储管理方式 分段系统的基本原理 &emsp;&emsp;在分段存储管理方式中，作业的地址空间被划分为若干个段，每个段定义了一组逻辑信息。为了简单起见，通常可用一个段号来代替段名，每个段都从0开始编址，并采用一段连续的地址空间。段的长度由相应的逻辑信息组的长度决定，因此各段的长度并不相等。整个作业的地址空间由于被分成多个段，所以呈现出二维特性，即每个段既包含了一部分地址空间，又表示了逻辑关系。其逻辑地址由段号和段内地址组成。 六、段页式存储管理方式 基本原理 &emsp;&emsp;段页式系统的基本原理是分段和分页原理的结合，即先将用户程序分成若干个段，再把每个段分成若干个页，并为每一个段赋予一个段名。在段页式系统中，其地址结构由段号、段内页号及页内地址三部分组成。 地址变换过程 &emsp;&emsp;在段页式系统中，为了便于实现地址变换，需配置一个段表寄存器，其中存放段表始址和段长TL。进行地址变换时，首先利用段号S，将它与段长TL进行比较。若S&lt;TL,表示未越界，于是利用段表始址和段号来求出该段所对应的段表项在段表中的位置，从中得到该段的页表始址，并利用逻辑地址中的段内页号P来获得对应页的页表项位置，从中读出该页所在的物理块号b，再利用块号b和页内地址来构成物理地址。]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>存储器管理</tag>
        <tag>分段存储</tag>
        <tag>分页存储</tag>
        <tag>段页式存储</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[死锁]]></title>
    <url>%2F2019%2F%E6%AD%BB%E9%94%81%2F</url>
    <content type="text"><![CDATA[一、资源问题 可重用性资源和消耗性资源 可重用性资源 一种可供用户重复使用多次的资源 消耗性资源 又称为临时性资源，它是在进程运行期间，由进程动态地创建和消耗的。 可抢占性资源和不可抢占资源 可抢占性资源 是指某进程在获得这类资源后，该资源可以再被其他进程或系统抢占。 不可抢占性资源 一旦系统把某资源分配给进程后，就不能将它强行收回，只能在进程用完后自行释放。 二、计算机系统中的死锁 竞争不可抢占性资源引起死锁 竞争可消耗性资源引起死锁 进程推进顺序不当引起死锁 三、死锁的定义、必要条件和处理方法 死锁的定义 如果一组进程中的每一个进程都在等待仅由该组进程中的其他进程才能引发的事件，那么这组进程是死锁的。 产生死锁的必要条件 互斥条件 请求和保持条件 不可抢占条件 循环等待条件 处理死锁的方法 预防死锁 避免死锁 检测死锁 解除死锁 四、预防死锁 破坏“请求和保持条件” 所有进程在开始运行之前，必须一次性地申请其在整个运行过程中所需的全部资源 允许一个进程只获得运行初期所需的全部资源后，便开始运行 破坏“不可抢占条件” 当一个已经保持了某些不可被抢占资源的进程，提出新的资源请求而不能得到满足时，它必须释放已经保持的所有资源，待以后需要时再从新申请。 破坏“循环等待条件” 对系统所有资源类型进行线性排序，并赋予不同的序号。规定每个进程必须按序号递增的顺序请求资源。 五、避免死锁 系统安全状态 &emsp;&emsp;在死锁避免方法中，把系统的状态分为安全状态和不安全状态。当系统处于安全状态时，可避免发生死锁。反之，当系统处于不安全状态时，则可能进入到死锁状态。 安全状态 &emsp;&emsp;在该方法中，允许进程动态地申请资源，但系统在进行资源分配之前，应先计算此次资源分配的安全性。若此次分配不会导致系统进入不安全状态，才可将资源分配给进程，否则，令进程等待。 &emsp;&emsp;所谓安全状态，是指系统能按某种进程推进顺序为每个进程$P_i$分配其所需资源，直至满足每个进程对资源的最大需求，使每个进程都可顺利地完成，此时称($P_1$、$P_2$、……、$P_n$)为安全序列。 &emsp;&emsp;如果系统无法找到这样一个安全序列，则称系统处于不安全状态。虽然并非所有不安全状态都必然会转为死锁状态，但当系统进入不安全状态后，就有可能进入死锁状态。反之，只要系统处于安全状态，系统便不会进入死锁状态。因此，避免死锁的实质在于，系统在进行资源分配时，应使系统不进入不安全状态。 利用银行家算法避免死锁 为实现银行家算法，每一个新进程在进入系统同时，它必须申明在运行过程中，可能需要每种资源类型的最大单元数目，其数目不应超过系统所拥有的资源总量。 当进程请求一组资源时，系统必须首先确定是否有足够的资源分配给该进程。若有，再进一步计算在将这些资源分配给进程后，是否会使系统处于不安全状态。如果不返回，才将资源分配给它，否则让进程等待。 六、死锁的检测&emsp;&emsp;为了能对系统中是否已经发生了死锁进行检测，在系统中必须：①保存有关资源的请求和分配信息；②提供一种算法，它利用这些信息来检测系统是否已进入死锁状态。 资源分配图 死锁定理 S为死锁状态的充分条件为：当且仅当S状态的资源分配图是不可完全简化的。该充分条件被称为死锁定理。 七、死锁的解除常采用解决死锁的两种方法是： 抢占资源。从一个或多个进程中抢占足够数量的资源，分配给死锁进程，以解除死锁状态。 终止（或撤销）进程。终止（或撤销）系统中的一个或多个死锁进程，直至打破循环环路，使系统从死锁状态解脱出来。 终止进程的方法 终止所有死锁进程 终止所有的死锁进程，死锁自然也就解除了，但所付出的代价可能会很大。 逐个终止进程 按某种顺序，逐个地终止进程，直至有足够的资源，以打破循环等待，把系统同从死锁状态解脱出来为止。 选择被终止进程时应考虑的若干因素： 进程的优先级 进程已执行了多少时间，还需要多少时间方能完成？ 进程在运行中已经使用资源的多少，以后还需要多少资源？ 进程的性质是交互式的还是批处理式的？]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
        <tag>死锁</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[处理机调度]]></title>
    <url>%2F2019%2F%E5%A4%84%E7%90%86%E6%9C%BA%E8%B0%83%E5%BA%A6%2F</url>
    <content type="text"><![CDATA[一、处理机调度的层次和调度算法的目标&emsp;在多道程序系统中，调度的实质是一种资源分配，处理机调度是对处理机资源进行分配。处理机调度算法实质根据处理机分配策略所规定的处理机分配算法。在多道批处理系统中，一个作业从提交到获得处理机执行，直至作业运行完毕，可能需要经历多级处理机调度。 处理机调度的层次 高级调度：又称长程调度或作业调度，调度对象是作业 低级调度：又称进程调度或短程调度，调度对象是进程（或内核级线程） 中级调度：又称内存调度 处理机调度算法的目标 资源利用率 公平性 平衡性 策略强制执行 二、作业与作业调度&emsp;&emsp;在多道批处理系统中，作业是用户提交给系统的一项相对独立的工作。操作员把用户提交的作业通过相应的输入设备到磁盘存储器，并保存在一个后备作业队列中。再由作业调度程序将其从外存调入内存。 批处理系统中的作业 在批处理系统中，是以作业为基本单位从外存调入内存的 作业控制块JCB：包含的内容有，作业标识、用户名称、用户账号、作业类型、作业状态、调度信息、资源需求、资源使用情况等。 作业运行的三个阶段和三种状态 收容阶段，对应后备状态 运行阶段，对应运行状态 完成阶段，对应完成状态 先来先服务调度算法（FCFS) 系统按照作业到达的先后次序来进行调度，或者说它是优先考虑在系统中等待时间最长的作业，而不管作业所需执行时间的长短，从后备作业队列中选择几个最先进入该队列的作业，将它们调入内存，为它们分配资源和创建进程。然后把它放入就绪队列。 短作业优先调度算法（SJF） 由于在实际情况下，短作业占有很大比例，为了能使它们能比长作业优先执行，而产生了短作业优先调度算法。 SJF算法是以作业的长短来计算优先级，作业越短，其优先级越高。 优先级调度算法（PSA） 基于作业的紧迫程度，由外部赋予作业相应的优先级。调度算法是根据该优先级进行调度的。 高响应比优先调度算法（HRRN） 为每个作业引入一个动态优先级，即优先级是可以改变的，令它随等待时间延长而增加，这将使长作业的优先级在等待期间不断地增加，等到足够的时候后，必然有机会获得处理机。该优先级的变化规律可描述为： 优先权=$\frac{等待时间+要求服务时间}{要求服务时间}$ 由于等待时间与服务时间之和就是系统对该作业的响应时间，故该优先级又相当于响应比$R_p$。据此，优先又可表示为：$R_P$=$\frac{等待时间+要求服务时间}{要求服务时间}$=$\frac{响应时间}{要求服务时间}$ 三、进程调度 进程调度的任务 保存处理机的现场信息 按某种算法选取进程 把处理机分配给进程 进程调度的机制 排队器 分派器 上下文切换器 进程调度的方式 非抢占方式 抢占方式 优先权原则 短进程优先原则 时间片原则 轮转调度算法（RR） &emsp;&emsp;在分时系统中，最简单的也是较常用的是基于时间片的轮转调度算法。该算法采取了非常公平的处理机分配方式，即让就绪队列上的每个进程每次仅运行一个时间片。如果就绪队列上有n个进程，则每个进程每次大约都可以获得$\frac{1}{n}$的处理机时间。 轮转法的基本原理 系统根据FCFS策略，将所有的就绪进程排成一个就绪队列，并可设置每个一定时间间隔即产生一次中断，激活系统中的进程调度程序，完成一次调度，将CPU分配给队首进程，令其自信。当该进程的时间片耗尽或运行完毕时，系统再次将CPU分配给新的队首进程。由此，可保证就绪队列中的所有进程在一个确定的时间段内，都能获得一次CPU执行。 切换时机 若一个时间片尚未用完，正在运行的进程便已完成，就立即激活调度程序，将它从就绪队列中删除，再调度就绪队列中队首的进程运行，并启动一个新的时间片。 在一个时间片用完时，计时器中断处理程序被激活。如果进程尚未运行完毕，调度程序将把它送往就绪队列的末尾。 时间片大小的确定 时间片的大小略大于一次典型的交互所需要的时间，使大多数交互式进程能在一个时间片内完成，从而获得很小的响应时间。 优先级调度算法 优先级调度算法的类型 非抢占式优先级调度算法 抢占式优先级调度算法 优先级的类型 静态优先级 进程类型 进程对资源的需求 用户要求 动态优先级 多队列调度算法 将系统中的进程就绪队列从一个拆分为若干个，将不同类型或性质的进程固定分配在不同的就绪队列，不同的就绪队列采用不同的调度算法，一个就绪队列中的进程可以设置不同的优先级，不同的就绪队列本身也可以设置不同的优先级。 多级反馈队列调度算法 设置多个就绪队列。为每个队列赋予不同的优先级，第一个队列的优先级最高，依次递减。优先级越高，时间片越小。 每个队列采用FCFS算法 按队列优先级调度 基于公平原则的调度算法 保证调度算法 如果系统中有n个相同类型的进程同时运行，为公平起见，须保证每个进程都获得相同的处理机时间1/n。 公平分享调度算法 在该算法中，调度的公平性针对用户而言，使所有用户能获得相同的处理机时间，或所要求的时间比例。 四、实时调度 实现实时调度的基本条件 提供必要的信息 就绪时间 开始截止时间和完成截止时间 处理时间 资源要求 优先级 系统处理能力强 采用抢占式调度机制 具有快速切换机制 对中断的快速响应能力 快速的任务分派能力 实时调度算法的分类 非抢占式调度算法 非抢占式轮转调度算法 非抢占式优先调度算法 抢占式调度算法 基于时钟中断的抢占式优先级调度算法 立即抢占的优先级调度算法 最早截止时间优先EDF算法 该算法根据任务的截止时间确定任务的优先级，任务的截止时间越早，其优先级越高，具有最早截止时间的任务排在队列的队首。 最低松弛度优先LLF算法 该算法在确定任务的优先级时，根据的是任务的紧急（或松弛）程度。任务紧急程度越高，赋予该任务的优先级就越高，以使之优先执行。 优先级倒置 优先级倒置的形成 &emsp;&emsp;当前OS广泛采用优先级调度算法和抢占方式，然而在系统中存在着影响进程运行的资源而产生“优先级倒置”现象，即高优先级进程（或线程）被低优先级进程（或线程）延迟或阻塞。 &emsp;&emsp;例如，假如有三个完全独立的进程$P_1$、$P_2$和$P_3$，$P_1$的优先级最高，$P_2$次之，$P_3$最低。$P_1$和$P_3$通过共享一个临界资源进行交互。假如$P_3$最先执行，进入到临界区，在时刻a，当$P_2$就绪时，因为它比$P_3$的优先级高，$P_2$抢占了$P_3$的处理机而运行，在时刻b，$P_1$就绪，因为它比$P_2$的优先级高，$P_1$抢占了$P_2$的处理机而运行。在时刻c，$P_1$试图进入临界区，但因为相关的临界资源已被$P_3$占用，故$P_1$将被阻塞。由$P_2$继续运行，直到时刻d运行结束。然后由$P_3$接着运行，到时刻e时$P_3$退出临界区，并唤醒$P_1$。因为它比$P_3$的优先级高，故它抢占了$P_3$的处理机而运行。 优先级倒置的解决方法 一种简单的解决办法是规定：加入进程$P_3$在进入临界区后$P_3$所占用的处理机就不允许被抢占。 一种比较实用的方法是在建立动态优先级继承基础上的。该方法规定，当高优先级进程$P_1$要进入临界区，去使用临界资源R，如果已有一个低优先级进程$P_3$正在使用该资源，此时一方面$P_1$被阻塞，另一方面由$P_3$继承$P_1$的优先级，并一直保持到$P_3$退出临界区。]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>进程调度</tag>
        <tag>处理机调度</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[进程相关总结]]></title>
    <url>%2F2019%2F%E8%BF%9B%E7%A8%8B%E7%9B%B8%E5%85%B3%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[程序顺序执行的特征： 顺序性 封闭性 可再现性 程序并发执行的特征： 间断性 失去封闭性 不可再现性 一、进程的描述 进程的定义：进程是进程实体的运行过程，是系统进行资源分配和调度的一个独立单位。 进程的特征： 动态性 并发性 独立性 异步性 进程的三种基本状态： 就绪状态 执行状态 阻塞状态 进程控制块PCB：PCB作为进程实体的一部分，记录了操作系统所需的，用于描述进程的当前情况以及管理进程运行的全部信息，是操作系统中最重要的记录型数据结构。 PCB的作用是使一个在多道程序环境下不能独立运行的程序（含数据）成为一个能独立运行的基本单位，一个能与其他进程并发执行的过程。 作为独立运行基本单位的标志 能实现间断性运行方式 提供进程管理所需要的信息 提供进程调度所需要的信息 实现与其他进程的同步与通信 PCB中的信息： 进程描述符 处理机状态 进程调度信息 进程控制信息 一、进程控制&emsp;&emsp;进程控制是进程管理中最基本的功能，主要包括创建新进程、终止已完成的进程、将因发生异常情况而无法继续运行的进程置于阻塞状态、负责进程运行中的状态转换等功能。 操作系统内核的功能： 支撑功能 中断处理 时钟管理 原语操作 资源管理功能 进程管理 存储器管理 设备管理 引起创建进程的事件 用户登录 作业调度 提供服务 应用请求 进程的创建 申请空白PCB 为新进程分配其运行所需的资源 初始化进程控制块PCB 如果进程就绪队列能够接纳新进程，便将新进程插入就绪队列 引起进程终止的事件 正常结束 异常结束 越界错 保护错 非法指令 特权指令错 运行超时 等待超时 算术运算错 外界干预 操作员或操作系统干预 父进程请求 父进程终止 进程的终止过程 根据被终止进程的标识符，从PCB集合中检索出该进程的PCB，从中读出该进程的状态 若被终止进程正处于执行状态，应立即终止该进程的执行，并置调度标志为真，用于指示该进程被终止后应重新进行调度 若该进程还有子孙进程，还应将其所有子孙进程也都予以终止，以防它们成为不可控进程 将被终止进程所拥有的全部资源或者归还给其父进程，或者归还给系统 将被终止进程从所在队列中移出，等待其他程序来搜集信息 引起进程阻塞和唤醒的事件 向系统请求共享资源失败 等待某种操作的完成 新数据尚未到达 等待新任务的到达 二、进程同步 临界区 &emsp;&emsp;通过对多线程的插混行化来访问公共资源或1一段代码，速度快，适合控制数据访问。 优点：保证在某一时刻只有一个线程能访问数据的简便方法 缺点：虽然临界区同步速度很快，但却只能用来同步本进程内的线程，而不可用来同步多个进程中的线程 互斥量 &emsp;&emsp;为协调共同对一个共享资源的单独访问而设计的。互斥量和临界区很相似，比临界区复杂，互斥对象只有一个，只有拥有互斥对象的线程才具有访问资源的权限 优点：使用互斥不仅仅能够在同一应用程序不同线程中实现资源的安全共享，而且可以在不同应用程序的线程之间实现对资源的安全共享 缺点： 互斥量是可以命名的，也就是说它可以跨越进程使用，所以创建互斥量需要的资源更多，所以如果只为了在进程内部使用的话，使用临界区会带来速度上的优势并能够减少资源占用量，因为互斥量是跨继承的互斥量一旦被创建，就可以通过名字打开它 通过互斥量可以指定资源被独占的方式使用，但如果有下面一种情况通过互斥量就无法处理。比如现在一位用户购买了一份三个并发访问许可的数据库系统，可以根据用户购买1的访问许可数量来决定有多少个线程/进程能同时进行数据库操作，这时如果利用互斥量就没办法完成这个要求，信号量对象可以说是一种资源计数器 信号量 &emsp;&emsp;为控制一个具有有限数量用户资源而设计。它允许多个线程在同一时刻访问同一资源，但是需要限制在同一时刻访问此资源的最大线程数目。 优点：适用于对Socket程序中线程的同步。 缺点： 信号量机制必须有公共内存，不能用于分布式操作系统，这是它最大的弱点 信号量机制功能强大，但使用时对信号量的操作分散，而且难以控制，读写和维护都很困难，加重了程序员的编码负担 核心操作P-V分散在各用户程序的代码中，不易控制和管理，一旦错误，后果严重，且不易发现和纠正。 事件 &emsp;&emsp;用来通知线程有一些事件已发生，从而启动后继任务的开始。 优点： 事件对象通过通知操作的方式来保持线程的同步，并且可以实现不同进程中的线程同步操作。 三、进程通信&emsp;&emsp;进程通信是指进程之间的信息交换。由于进程的互斥与同步，需要在进程交换一定的信息，故不少学者将它们也归为进程通信，但只能把它们称为低级进程通信。以信号量机制为例，它们低级的原因是： 效率低 通信对用户不透明 &emsp;&emsp;在进程之间要传送大量数据时，应当利用OS提供的高级通信工具，该工具最主要的特点是： 使用方便 高效地传送大量数据 进程通信的类型： 共享存储器系统：相互通信的进程共享某些数据结构或共享存储区，进程之间能够通过这些空间进行通信。 基于共享数据结构的通信方式 基于共享存储区的通信方式 管道通信系统：所谓“管道”是指用于连接一个读进程和一个写进程以实现它们之间通信的一个共享文件，又名pipe文件。 管道机制必须提供一下三方面的协调能力： 互斥 同步 确定对方是否存在，只有确定了对方已存在时才能进行通信 消息传递系统：在该机制中，进程不必借助任何共享存储区或数据结构，而是以格式化的消息为单位，将通信的数据封装在消息中，并利用操作系统提供的一组通信命令，在进程间进行消息传递，完成进程间的数据交换。 直接通信方式：是指发送进程利用OS所提供的原语，直接把消息发送给目标进程 间接通信方式：是指发送和接收进程，都通过共享中间实体的方式进行消息的发送和接收，完成进程间的通信 客户机—服务器系统 套接字 远程过程调用 远程方法调用 四、线程&emsp;&emsp;如果说，在OS中引入进程的目的是为了使多个程序能并发执行，以提高资源利用率和系统吞吐量，那么，在操作系统中再引入线程，则是为了减少程序在并发执行时所付出的时空开销，使OS具有更好的并发性。 线程运行的三种基本状态 执行状态 就绪状态 阻塞状态 线程控制块TCB：如同每个进程有一个进程控制块一样，系统也为每个线程配置了一个线程控制块TCB，将用于控制和管理线程的信息记录在线程控制块中。 线程标识符 一组寄存器 线程运行状态 优先级 线程专有存储区 信号屏蔽 堆栈指针 多线程OS中的进程属性 &emsp;&emsp;通常在多线程OS中的进程都包含了多个线程，并为它们提供资源。OS支持在一个进程中的多个线程能并发执行，但此时的进程就不再作为一个执行的实体。多线程OS中的进程有以下属性： 进程是一个可拥有资源的基本单位 多个线程可并发执行 进程已不是可执行的实体 线程的实现方式 内核支持线程KST(Kernel Support Threads) 优点： 在多处理器系统中，内核能够同时调度同一进程中的多个线程并发执行 如果进程中的一个线程被阻塞了，内核可以调度该进程中的其他线程占有处理器运行，也可以运行其他进程中的线程 内核支持线程具有很小的数据结构和堆栈，线程的切换比较快，切换开销小 内核本身也可以采用多线程技术，可以提高系统的执行速度和效率 缺点： 对于用户的线程切换而言，其模式切换的开销较大，在同一个进程中，从一个线程切换到另一个线程时，需要从用户态转到核心态进行，这是因为用户进程的线程在用户态运行，而线程调度和管理是在内核实现的，系统开销比较大。 用户级线程ULT(User Level Threads) 优点： 线程切换不需要转换到内核空间 调度算法可以是进程专用的 用户级线程的实现与OS平台无关 缺点： 系统调用的阻塞问题 在单纯的用户级线程实现方式中，多线程应用不能利用多处理机进行多重处理的优点，内核每次分配给一个进程的仅有一个CPU，因此，进程中仅有一个线程能执行，在该线程放弃CPU之前，其他线程只能等待 线程的创建和终止 线程的创建 &emsp;&emsp;应用程序在启动时，通常仅有一个线程在执行，人们把线程称为“初始化线程”，它的主要功能是用于创建新进程。在创建新进程时，需要利用一个线程创建函数，并提供相应的参数，如指向线程主程序的入口指针、堆栈的大小，以及用于调度的优先级等。在线程的创建函数执行完后，将返回一个线程标识符供以后使用。 线程的终止 &emsp;&emsp;当一个线程完成了自己的任务后，或是线程在运行中出现异常情况而须被强行终止时，由终止线程通过调用相应的函数来对它执行终止操作。但有些线程，它们一旦被建立起来之后，便一直运行下去而不被终止。在大多数的OS中，线程被中止后并不立即释放它所占有的资源，只有当进程中的其他线程执行了分离函数后，被终止的线程才与资源分离，此时的资源才能被其他线程利用。 &emsp;&emsp;虽已被终止但尚未释放资源的线程仍可以被需要它的线程所调用，以使被终止线程重新恢复运行。为此，调用线程须调用一条被称为“等待线程终止”的连接命令来与该线程进行连接。如果在一个调用者线程调用“等待线程终止”的连接命令，试图与指定线程相连接时，若指定线程尚未被终止，则调用连接命令的线程将会阻塞，直至指定线程被终止后，才能实现它与调用者线程的连接并继续执行；若指定线程已被终止，则调用者线程不会被阻塞而是继续执行。]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
        <tag>进程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git的基本操作]]></title>
    <url>%2F2019%2FGit%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[第一阶段:初始化想要让git对一个目录进行版本控制需要以下步骤： 进入要管理的文件夹 执行初始化命令 1git init 管理目录下的文件状态 12git status# 注：新增的文件和修改过后的文件都是红色 管理指定文件（红变绿） 12git add 文件名git add . #添加当前文件夹下的全部文件 个人信息配置：用户名，邮箱【一次即可】 12git config --global user.email "Your Email"git config --global user.name "Your Name" 生成版本 1git commit -m '描述信息' 查看版本记录 1git log 第二阶段：扩展新功能12git add .git commmit -m 'message' 第三阶段：回滚 回滚至之前的版本 12git loggit reset --hard 版本号 回滚至之后的版本 12git refloggit reset --hard 版本号 第四阶段：分支&amp;修改 分支 分支可以给使用者提供多个环境，意味着你可以把你的工作从开发主线上分离开来，以免影响开发主线 修改方案 查看分支 1git branch 创建分支 1git branch 分支名 切换分支 1git checkout 分支名 分支合并（可能产生冲突） 12git merge 要合并的分支#注：切换分支再合并， 删除分支 1git branch -d 分支名称 第五阶段：GitHub 在家里上传代码 12git remote add origin 远程仓库地址 #给远程仓库起名字git push -u origin 分支 #推送代码 到公司新电脑上第一次获取代码 12git clone #远程仓库地址git checkout 分支 #切换分支 在公司进行开发 1234567git checkout dev #切换到dev分支进行开发git merge master #把master分支合并到dev（仅一次）#修改代码#提交代码git add .git commit -m 'xxx'git push origin dev 回家继续写代码 12345678910#切换到dev分支进行开发git checkout dev#拉代码git pull origin dev#继续开发#提交代码git add .git commit -m 'xx'git push origin dev 开发完毕，要上线 12345678#将dev分支合并到master，进行上线git checkout mastergit merge devgit push origin master#把dev分支也推送到远程git checkout devgit merge mastergit push origin dev 12345git pull origin dev#等同于下面的两行代码git fetch origin devgit merget origin/dev 保持代码提交整洁(变基） 1git rebase 分支 记录图形展示 1git log --graph --preey=format:"%h %s" 快速解决冲突 安装beyond compare 在git中配置 123git config --locla merge.tool bc3 #--local说明只在当前项目中有效git config --local mergetool.path '/usr/local/bin/bcomp'git config --local mergetool.keepBackup false 应用beyond compare解决冲突 1git mergetool #启动beyond compare]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux内存管理机制——基本机制]]></title>
    <url>%2F2019%2FLinux%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%9C%BA%E5%88%B6%E2%80%94%E2%80%94%E5%9F%BA%E6%9C%AC%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;内存管理是指应用程序通过软硬件协作来访问内存的内存子系统。它的主要职责为：在进程请求内存时，为其分配可用物理内存页面；在进程释放内存时，回收内存页面；负责跟踪系统中内存的使用状态。 &emsp;&emsp;最简单的内存管理方式是使运行的进程拥有对所有物理内存1的访问权。如果这样做，进程就必须包含对硬件进行操作的全部代码，必须能找到自己的物理内存地址，而且还必须负责将自身的数据载入内存。这种方式不但给程序开发人员造成了很重的负担，而且还要保证进程可以被加载到可用内存中去。这些苛刻的要求显然对日益复杂化的程序需求来说很不现实，所以要将内存管理这个棘手的任务交给操作系统完成。 &emsp;&emsp;现在操作系统要求能够使多个程序共享操作系统的资源，同时还要求内存对程序开发者是透明的。在此需求下虚拟内存便应运而生，它支持程序访问比系统物理可用内存大得多的内存空间，而其也使多个程序共享内存变得更容易、更方便。物理内存是在系统中由RAM芯片控制的可用内存，虚拟内存依靠透明地使用磁盘空间以允许程序使用比物理内存更多的内存空间，磁盘空间可作为物理内存的扩充。我们之所以称其为虚拟内存就是因为磁盘空间被当作内存一样使用。 &emsp;&emsp;使用虚拟内存时，程序数据被分割成可以在磁盘与内存空间来回移动的基本单元。这样程序被使用的部分就可以被置于内存中，以便获得更快的访问速度；而未被使用的部分则被临时存放在磁盘上，从而减轻了物理内存的压力。这些数据单元，或者说虚拟内存块被称为页。同样，物理内存也需要被划分成可容纳页的区，这些区被称为页面。当一个进程请求一个地址时，包含该地址的页将被调入内存中，所有对该页中数据的请求都会产生对页的访问。如果页中没有任何地址被事先访问过，那么该页就尚未被载入内存。当某个地址第一次访问该页时便会产生一个缺页，因为这时内存中并没有该页，因此必须从磁盘请求。当物理页面已全部被占用时，内核必须选择一个页面，然后将其内容写回到磁盘，从而用程序刚刚请求到的页内容来填充它。 &emsp;&emsp;当一个程序从内存页面中存取数据时，会使用地址来指出需要访问的内存位置。该地址被称作虚拟地址,它们组成了进程的虚拟地址空间。每个进程都有自己独立的虚拟地址空间，这样做的好处是可防止非法读取或写覆盖1其他进程的数据。虚拟内存允许进程“使用”超过可用物理内存的内存空间，于是操作可以给予每个进程自己独立的虚拟线性地址空间。 &emsp;&emsp;虚拟地址空间的大小取决于体系结构的字长，如果一个处理器的寄存器可容纳32位数据，那么该处理器支持的进程虚拟地址空间大小就是$2^{32}$字节。虚拟内存不仅扩大了可寻址的内存范围，而且也使得物理内存的大小限制对用户空间的开发者透明，比如开发者不需要管理内存中的任何空格键。以32位的系统为例，其虚拟空间的范围为0~4GB，如果系统有2GB的物理内存，那么它的物理内存地址范围为0-2GB。而程序可以有4GB之大，但是只有被装入可用内存中的程序才能运行，因此整个程序将被存放在磁盘上，系统只把所需要运行的程序页载入到内存。 &emsp;&emsp;这种页从内存到磁盘之间调入调出的机制称为分页机制，分页机制包括程序虚拟地址到物理内存地址的转换。 &emsp;&emsp;内存管理在操作系统中负责维护虚拟地址和物理地址之间的关系，并且实现分页机制。对内存管理子系统来说，页时内存的基本单元，内存单元MMU是完成实际地址转换工作的硬件部件，内核提供了页表以及相关的地址，MMU在执行地址转换时访问这些地址。]]></content>
      <categories>
        <category>Linux内核</category>
      </categories>
      <tags>
        <tag>内存管理机制</tag>
        <tag>虚拟地址</tag>
        <tag>虚拟内存</tag>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux模块机制——模块的使用]]></title>
    <url>%2F2019%2FLinux%E6%A8%A1%E5%9D%97%E6%9C%BA%E5%88%B6%E2%80%94%E2%80%94%E6%A8%A1%E5%9D%97%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;由于模块和内核是在同样的地址空间运行的，因此模块编程在一定意义上说也就是内核编程。但是并不不是内核中所有的地方都可以使用模块，一般是在设备驱动程序、文件系统等地方使用模块，而对Linux内核来说极为重要的地方如进程管理和内存管理等是无法通过模块来实现的，必须通过直接对内核进行修改来完成的。 一、一个简单的内核模块程序我们编写一个Hello World的内核模块。内核模块代码如下： 12345678910111213141516171819#include&lt;linux/module.h&gt;#include&lt;linux/kernel.h&gt;#include&lt;linux/init.h&gt;static int _init hello_init(void)&#123; printk(KERN_ALERT "Hello World2\n"); return 0;&#125;static void _exit hello_exit(void)&#123; printk(KERN_ALERT "Goodbye,world2\n");&#125;module_init(hello_init);module_exit(hello_init);MODULE_LICENSE("GPL");MODULE_AUTHOR("Author"); &emsp;&emsp;这是一个简单的内核模块，我们对其进行简单的介绍。hello_init()函数是模块的入口点，它通过module_init()函数例程注册到系统中，在模块装载时被调用。模块的初始化函数形式如下： 1static int _init my_init(void); &emsp;&emsp;由于初始化函数通常并不会被外部函数直接调用，所以不必导出该函数，故它可以被标记为static又由于init函数在模块加载以后，就不会再使用了，因此，我们使用_init宏，这个宏表示在模块初始化完成后，丢弃函数，并释放其所占内存。 &emsp;&emsp;hello_exit()函数是模块的出口函数，它由module_exit()函数例程注册到系统。在模块从内核卸载时，内核便会调用hello_exit()函数。退出函数可能会在返回前负责清理资源，以保证硬件处于一致状态。模块的退出函数形式如下： 1static void _exit my_exit(void) &emsp;&emsp;与初始化函数的原因一样，也可以标记该函数为static。使用_exit宏，如果上述文件被静态地编译到内核映像中，那么退出函数将不被包含，而且永远都不会被调用。 &emsp;&emsp;MODULE_LICENSE()宏定义用于指定模块的版权。如果载入非GPL模块到系统内核，则会在内核中设置被污染标识，这个标识只起到记录信息的作用。不过如果开发者提交的bug报告中含有被污染的代码，那么报告的信用无疑会下降。另外非GPL模块不能使用标记为GPL-only的函数和变量。 &emsp;&emsp;MODULE_AUTHOR()宏指定了代码作者，用于做信息记录。 二、构建模块&emsp;&emsp;在2.6内核中采用了新的kbuild机制来构建内核模块，使得模块的构建更加简单、灵活。在Linux内核中由用户建立的模块可以放在两个位置，一种是将自己构建的模块直接添加到内核源代码中，另外一种就是将该模块放在内核代码外。 在内核源代码中构建内核模块&emsp;&emsp;如果想把自己编写的模块添加到内核源代码树中，首先，必须先明确该模块需要放在源代码树的什么位置，在Linux中，所有设备的驱动程序都存放在内核目录drivers下，打开该目录会发现在该目录下存在许多子目录。在这个目录下，系统将不同的驱动程序进行分类存放，如char、block、usb等。当然Linux并没有硬性规定哪些硬件必须放在哪个目录下。 &emsp;&emsp;下面用一个简单的例子来说明如何将自己编写的模块直接添加到内核源代码树中，现在假设已经编写好了一个字符类型的驱动程序，命名为mymodule，要把该模块添加到内核中，需要完成以下4步工作。 （1）确定内核模块代码的存放位置。由于模块是一个字符类型的驱动程序，那么需要把该模块放到目录drivers/char下，这里有两种选择，一种是直接将模块放到char目录下，另外一种是在char目录下先建立一个文件夹并命名为mumodule，然后将模块放到这个子目录下。这两种作法对最后所要完成的工作并没有任何影响，只是考虑到当驱动程序是由多个源代码文件组成的时候，如果直接将这些原文件都放在char目录下，会给维护工作带来一定的麻烦。 （2）修改和创建makefile文件。这里先假设在第一步中char目录下建立一个文件夹mymodule，那么下面需要做的工作就是修改以及创建makefile文件，在char目录下的makefile文件中添加如下代码： 1obj-m +=mymodule/ &emsp;&emsp;在makefile中添加上述代码的主要作用就是告诉模块构件系统在编译模块的时候需要进入mymodule子目录中。 &emsp;&emsp;接下来，需要在mymodule子目录下创建一个makefile文件，这个文件用来告诉模块构件系统如何编译该子目录下的模块，makefile文件的内容如下所示： 1obj-m += mymodule.o &emsp;&emsp;如果要构件的模块是由多个原文件构成，如file1.c和file2.c，那么可以在mymodule目录下的makefile文件编写如下代码： 12obj-m :=mymodule.omymodule-objs:=file1.o file2.o （3）重新编译修改后的内核代码。在Linux内核编译时，就会在lib/modules/2.6.10/kernel/drivers/char目录下,生成一个名称为mymodule.ko的文件。注意，在2.6内核中，生成的模块拓展名为.ko，而不是以前的.o （4）安装内核模块。可以使用如下的命令将内核中所有编译好的模块安装到Linux系统内核中 1make modules_install 至此，内核模块的创建就完成了，用户可以在新的内核中使用自己定义的内核模块了。 在内核源码外构建内核模块&emsp;&emsp;其实将模块放在内核源码外与放在内核源码树内的最大的区别在于构建过程，当用户把自己编写的模块放在内核源码树的外部时，在内核模块编译之前必须构建内核代码树。将内核模块放在内核源代码外的构建过程了如下所示。 （1）还是假设已经编写好了一个模块文件mymodule.c，现在将该文件放在一个用户自己创建的文件夹中，在这里冷仍然需要创建自己的makefile文件，其形式如下： 1obj-m += mymodule.o （2）执行make命令编译.c文件，其形式如下： 1make -C /lib/modules/kernel-version/uild M=$ PWD &emsp;&emsp;这个命令是改变文件的目录到用-C选项提供的目录下（就是内核源码目录）。它在那里会发现内核顶层makefile文件。M=选项使makefile在试图创建内核模块前，回到模块源代码所在目录。 &emsp;&emsp;重复的输入前面的make命令是很麻烦的一件事，为此，我们可以编写内容如下的makefile文件，在每次编译内核模块时，只要输入make命令就可以了。 12345678910#如果已经定义了KERNELRELEASE，则说明是从内核构造系统调用的，因此#可以使用其内建语句ifneq($(KERNELRELEASE),)obj-m := hello.oelseKERNELDIR ?= /lib/modules/$(shell uname -r)/buildPWD := $(shell pwd)default:$(MAKE) -C $(kERNELDIR) M=$(PWD) modulesendif （3）最后一步就是把刚才编译好的内核模块mymodule.ko装载到系统中。在Linux中可以有两种方法来载入一个已经编译好的模块，一个是利用insmod，另外一个就是利用命令modprobe。 &emsp;&emsp;使用insmod命令安装内核模板的命令格式如下： 1insmod mymodule.ko; insmod命令将模块的代码和数据装入内核，然后使用内核符号表解析模块中任何未解析的符号，将内核模块映像复制到内存区域，并通过内核符号表解析模块中的内核引用，最后调用模块的初始化函数。 &emsp;&emsp;这里需要说明的是，insmod命令虽然很简单，但是其功能也同样有限，该命令的作用就是请求内核载入指定的模块，它不会进行任何依赖性分析和错误性检查。 &emsp;&emsp;modprobe命令与insmod的功能很相似，也是用于将指定的模块装载到内核中，但是它比insmod命令要实用得多，这是因为该命令提供了模块依赖性分析，错误智能检查，错误报告以及许多其他功能和选项。 &emsp;&emsp;这里以提供的模块依赖性为例来详细分析其优越性，当用modprobe命令来装载某个指定的模块的时候，它会考虑要装载的模块是否引用了一些当前内核中不存在的符号，也就是说该模块所引用的符号没有存放在当前的全局内核符号表中，在这种情况下，该命令会在当前模块搜索路径中查找定义了这些符号的模块，如果找到了这些模块，该命令会自动地将这些模块装载到内核中，而在这种情况下如果使用insmod命令来装载该模块，则会产生错误信息，即模块装载不成功，也就是说modprobe命令不但会加载指定的模块，而且还会自动加载任何它所依赖的有关模块。该命令的使用格式如下： 1modprobe -i mymodule &emsp;&emsp;最后来看如何从内核中卸载已经装载的模块，同样有两个命令来完成该任务，一个就是rmmod命令，另一个就是modprobe命令，它们的使用格式如下： 12rmmod mymodulemodprobe -r mymodule &emsp;&emsp;这里需要说明的一点就是,modprobe与rmmod命令不同1，它不仅会卸载指定的模块，而且如果它发现需要卸载的这个模块所依赖的那些模块没有其他模块依赖于它们，那么该命令也会将这些模块一起从内核中卸载掉。 三、模块参数&emsp;&emsp;在装载内核模块时，用户可以向模块传递一些参数，如modprobe modname var=value,否则，var将使用模块内定义的缺省值。 &emsp;&emsp;2.4内核下,linux/module.h中定义有宏MODULE_PARM(var,type)，用于向模块传递命令行参数。var为接收参数值的变量名，type为采取如下格式的字符串[min[-max]]{b,h,i,l,s}。其中min及max用于表示当参数为数组类型时，允许输入的数组元素的个数范围，b表示byte，h表示short，i表示int，l表示long，s表示string。 &emsp;&emsp;2.6内核下，宏MODULE_PARM(var,type)不再被支持。在头文件Linux/moduleparam.h定义如下： 12module_param(name,type,perm)module_param_array(name,type,nump,perm) &emsp;&emsp;type类型可以是byte,short,ushort,int,uint,long,ulong,charp,bool或invbool，不再采用2.4内核中的字符串形式，而且在模块编译时会将此处声明的type与变量定义的类型进行比较，判断是否一致。 &emsp;&emsp;perm表示此参数在sysfs文件系统中对应的文件节点的属性。2.6内核使用sysfs文件系统，这是一个奖励在内存中比proc更强大的文件系统。sysfs文件系统可以动态、实时、有组织层次地反应当前系统中的硬件，驱动等状态。当perm为0时，表示此参数在sysfs文件系统下对应的文件节点不存在。模块被加载后，在sys/module目录下1将出现以此模块名命名的目录。如果此模块存在perm不为0的命令行参数，在此模块的目录下将出现paramters目录，包含一系列以参数名命名的文件节点，这些文件的权限值等于perm，文件的内容为参数的值。 &emsp;&emsp;nump为保存输入的数组元素个数的变量指针。当不需保存实际输入的数组元素个数时，可以设为NULL。 四、内核导出模块符号表&emsp;&emsp;在内核模块被载入后，就会动态连接到内核中。注意，它与用户空间中的动态链接库类似，只有被明确导出的内核函数和变量，才可以被动态库使用。在内核中，导出内核函数需要使用特殊的指令：EXPORT_SYMBOL和EXPORT_SYSBOL_GPL。 &emsp;&emsp;导出的内核函数可以被其他模块调用，而未导出的诶恶化函数模块则无法被调用。模块代码的链接和调用规则相比核心内核映像中的代码而言，要更为严格。核心代码在内核中可以调用任意非静态接口，因为所有的核心源代码文件被链接成了同一个映像。当然，被导出的符号表所含的函数必然也是非静态的。 &emsp;&emsp;导出的内核符号表被看做是导出的内核接口，甚至是内核API。导出符号相当简单，如下所示： 12EXPORT_SYMBOL(var);/*导出变量var*/EXPORT_SYMBLO(func);/*导出函数func*/]]></content>
      <categories>
        <category>Linux内核</category>
      </categories>
      <tags>
        <tag>Linux模块</tag>
        <tag>模块的使用</tag>
        <tag>构建内核模块</tag>
        <tag>模块参数</tag>
        <tag>导出模块符号表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux模块机制]]></title>
    <url>%2F2019%2FLinux%E6%A8%A1%E5%9D%97%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;Linux是单内核的操作系统，也就是整个系统内核都运行于一个单独的保护域中。相比于微内核的操作系统，单内核由于把所有的系统功能模块都集中到一起，系统的性能和速度都非常好，但是可扩展性和维护性就相对较差。为了弥补单内核的这个缺点，Linux操作系统使用了一种全新的机制——可装载内核模块机制(Load Kernel Module,LKM),用户可以根据需要，在不需要对内核重新编译的情况下，将模块动态地载入到内核或从内核中移出。 &emsp;&emsp;可装载内核模块，简称为模块，它是在内核空间运行的程序，实际上是一种目标对象文件，没有链接，不能独立运行，但是其代码可以在运行时链接到系统中作为内核的一部分运行或从内核中卸载，从而可以动态地扩展内核的功能。这种目标代码他通常由一部分函数和数据结构组成，用来实现一个文件系统、驱动程序或其他内核上层的功能。 &emsp;&emsp;内核模块与通常所说的运行在用户空间的应用程序有以下区别： （1）当用户想从系统中删除某个指定的模块的时候，必须考虑到一些例如资源的释放或者其他的清除工作，Linux中每一个模块都必须包含的两个组成部分，一个用于在初始化该模块时调用，另外一个用于删除该模块的时候调用，这里之所以在模块被删除的时候还要调用一个指定的函数，就是需要这个函数来完成撤销由该模块的初始化函数所做的一切。而一般应用程序在大多数情况下是不用考虑这一点的。 （2）在Linux的内核模块中，只能调用那些由内核提供的函数，而不可以像其他应用程序那样调用应用程序库函数，这主要是因为模块仅仅被链接到内核，因此它能调用的函数仅仅是那些由内核导出的函数。 （3）在模块中发生错误的处理方式与在应用程序中发生错误的处理方式是不同的，用户在编写模块的时候必须非常小心，因为模块时链接到内核中的，一个内核模块错误在严重的情况下会导致整个系统崩溃。 &emsp;&emsp;其实对于Linux而言，几乎系统中的每一个高层组件都可以被作为模块来进行编译，例如文件系统、设备驱动程序等。当然也有些组件是不可以作为模块进行编译的，这些组件要么静态地包含在内核中，要么不编译。 &emsp;&emsp;Linux引入可加载模块机制有以下优点： （1）使得内核更加紧凑和灵活 （2）修改内核时，不必全部重新编译整个内核，可节省时间。系统中如果需要使用新的功能，只要编译相应的模块，然后使用特定用户空间的程序将模块插入即可。 （3）模块的目标代码一旦被链接到内核，它的作用和静态链接的内核目标代码完全等价。所以，当调用模块的函数时，无需显式的消息传递。 但是内核模块的引入也带来了一定的问题。 （1）由于内核所占用的内存是不会被换出的，所以链接进内核的模块会给整个系统带来一定的性能和内存利用方面的损失。 （2）装入内核模块就成了内核的一部分，可以修改内核中的其他部分，因此模块的使用可能会导致系统崩溃。 （3）为了让内核模块能访问所有内核资源，内核必须维护一个符号表，并在装入和卸载模块时修改符号表。 （4）模块可以利用其他模块的功能，因此内核要维护模块之间的依赖关系。]]></content>
      <categories>
        <category>Linux内核</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
        <tag>Linux模块机制</tag>
        <tag>可装载内核模块机制</tag>
        <tag>LKM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux内核同步机制分析——其他同步机制]]></title>
    <url>%2F2019%2FLinux%E5%86%85%E6%A0%B8%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6%E5%88%86%E6%9E%90%E2%80%94%E2%80%94%E5%85%B6%E4%BB%96%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[一、每个处理器变量&emsp;&emsp;最后的同步机制就是不需要同步，因为所有的同步机制不仅需要浪费大量的处理器周期以探测临界区的状态，而且通常导致进程阻塞、系统并发能力下降、系统吞吐量减小。更糟糕的是，在同步机制使用不当的情况下，常常导致系统死锁。 &emsp;&emsp;在Linux内核中引入的每个处理器变量，是一种特殊的同步机制，用于多处理器系统中，通过为每个CPU创建一个变量副本，使每个CPU都只能使用自己本地的复制件，来避免处理器间的同步。使用每个处理器变量会减少数据加锁操作，它唯一的安全要求就是要禁止内核抢占。总的来说，使用每个处理器变量有以下两个显著的好处。 （1）按照每个CPU访问每个处理器变量的逻辑——每个CPU只能访问该处理器本身的数据变量，这样在CPU访问每个处理器变量时就不再需要任何锁。这样就避免了因处理器间的同步影响系统的并发能力，即消除了因同步而导致的系统性能损失。 （2）使用每个处理器变量可以较少缓存失效，进一步提高系统性能。缓存失效发生在处理器试图使它们的缓存保持同步时。如果一个处理器操作某个数据，而该数据又存放在其他处理器缓存中，那么存放该树的那个处理器必须清理或刷新它自己的缓存。持续不断的缓存失效称为缓存抖动，缓存抖动对系统性能影响颇大。使用每个处理器变量将使得缓存失效降至最低，因为理想情况下每个处理器只会访问它们自己的数据。 &emsp;&emsp;在Linux2.4内核中，系统把每个处理器变量存放到一个数组中，数组中的每一项对应着系统上一个存在的处理器，并使用每个CPU的处理器号作为每个CPU所对应元素的下标。我们可以按照下面的方式来使用每个处理器变量。 12345unsigned long my_percpu[NR_CPUS];//每个处理器变量的声明int cpu;cpu=get_cpu();//获得当前处理器，并禁止内核抢占my_percpu[cpu]++;put_cpu();//使能内核抢占 &emsp;&emsp;注意，上面的代码中并没有出现锁。正如上面所言，所操作的变量对当前处理器来说是唯一的，除了当前处理器，没有其他处理器可以接触到这个变量，不存在并发访问问题，所以当前处理器在不用锁的情况下也可以安全地访问它。 &emsp;&emsp;Linux2.6内核为了方便创建和操作每个处理器变量，引入了新的操作接口，该操作接口归纳了前面的操作行为，并使得每个处理器变量的创建和操作得以简化。操作函数的功能及描述如下： 函数原型 描述 DEFINE_PER_CPU(tyep,name) 在内核编译时，创建一个类型为type，名字为name的每个处理器变量 DECLARE_PER_CPU(type,name) 在内核编译时，声明一个类型为type，名字为name的每个处理器变量 get_cpu_var(var) 返回指定变量var在当前处理器上的复制件，并禁止内核抢占 put_cpu_var(var) 使能内核抢占 void* alloc_percpu(type) 在内核运行过程中，动态地创建一个类型为type的每个处理器变量，并返回指向这个变量的void类型指针 void *_alloc_percpu(size) 在系统运行过程中，动态地创建一个大小为size的每个处理器变量，并返回指向这个变量的void类型指针 free_percpu(ptr) 释放指针ptr所指向的每个处理器变量 void *per_cpu_ptr(ptr,cpu) 返回指针变量在处理器号cpu上的复制件 &emsp;&emsp;为了保持Linux内核的兼容性，Linux2.4内核中每个处理器变量的使用方式，在Linux2.6内核中也可以使用。但是，由于新的操作接口使用方便，而且在性能上也得到了优化，因此，在内核编程中建议使用新操作接口。 二、禁止内核抢占&emsp;&emsp;在Linux2.6内核中引入了内核抢占机制，这就使得内核中的进程在任何时刻都可能被抢占，让出CPU，以便另一个具有更高优先级的进程运行。这就意味着一个任务与被抢占的任务可能会在同一个临界区运行。为了避免这种情况的发生，临界区代码可以使用自旋锁作为非抢占区域的标记，因为如果临界区持有自旋锁，内核便不能进行抢占。在实际中，某些情况并不需要自旋锁，但是仍然需要禁止内核抢占。出现得最频繁的情况就是对每个处理器变量访问。为此，Linux提供了禁止内核抢占的操作函数preempt_disable()。这里我们对Linux禁止内核抢占机制进行讨论。 &emsp;&emsp;为了禁止内核抢占以避免因内核抢占导致的内核数据的不一致性，在每个进程的thread_info结构中引入了内核抢占计数器preempt_count。变量preempt_count被划分为3个字段，每个字段的名称及翻译如下： 字段 位 描述 PREEMPT 0~7 系统设置禁止内核抢占的计数 SOFTIRQ 8~15 系统设置禁止执行软中断的计数 HARDIRQ 16~27 系统设置进入中断的计数，即中断嵌套的深度 &emsp;&emsp;内核中提供了宏定义add_preempt_count()、sub_preempt_count()来方便对每个字段进行加1、减1操作。这两个宏定义具体操作哪个字段，依赖于传递给这两个宏定义的参数。候选参数有PREEMPT_OFFSET（也可以直接使用1代替）、SOFTIRQ_OFFSET、HARDIRQ_OFFSET，这些参数定义在include/linux/hardirq.h中，在默认情况下，PREEMPT_OFFSET的值为0x1，SOFTIRQ_OFFSET的值为0x100、HARDIRQ_OFFSET的值为0x10000。下面我们对这三个字段的用途分别进行介绍。 禁止内核抢占&emsp;&emsp;禁止内核抢占由宏定义preempt_disable()完成，该宏定义include/linux/preempt.h中，代码如下所示： 12345#define preempt_disable()\ do&#123;\ inc_preempt_count();\ barrier();\ &#125;while(0) 第3行代码调用inc_preempt_count()函数将变量preempt_count对应PREEMPT字段的部分进行加1操作。 第4行代码中barrier()函数是一个内存屏障，保障在屏障之前缓存在寄存器中的变量写回到内存中去。 使能内核抢占函数由宏定义preempt_enable()完成，该宏定义在include/linux/preempt.h中，代码如下所示： 123456#define preempt_enable()\ do&#123;\ preempt_enable_no_resched();\ barrier();\ preempt_check_resched();\ &#125;while(0) 第3行代码调用preempt_enable_no_resched()函数将变量preempt_count对应PREEMPT字段部分进行减1操作，但是并不检查是否有需要被调度的任务。 第5行代码调用preempt_check_resched()函数检查是否需要被调度的任务，即当前进程是否设置了请求调度标志TIF_NEED_RESCHED,如果设置了该标志，则调用调度器进行内核抢占。 禁止执行软中断的计数&emsp;&emsp;Linux内核提供了local_bh_disable()用于禁止执行软中断，该函数定义在kernel/softira.c中，代码如下： 1234void local_bh_disable()&#123; _local_bh_disable((unsigned long) _builtin_return_address(0));&#125; &emsp;&emsp;该函数实际上是_local_bh_disable()函数的封装。_local_bh_disable()定义在一个文件中，代码如下： 12345static inline void _local_bh_disable(unsigned long ip)&#123; add_preempt_count(SOFTIRQ_OFFSET); barrier();&#125; 第3行代码以SOFTIRQ_OFFSET为参数调用add_preempt_count()函数将变量preempt_count对应SOFTIRQ字段部分进行加1操作。 Linux内核提供了local_bh_enable()用于使能执行软中断，代码如下： 123456789101112131415161718192021222324void local_bh_enable(void)&#123;#ifdef CONFIG_TRACE_IRQFLAGS unsigned long flags; WARN_ON_ONCE(in_irq());#endif #ifdef CONFIG_TRACE_IRQFLAGS local_irq_save(flags);#endif if(softirq_count()==SOFTIRQ_OFFSET) trace_softirqs_on(unsigned long) _builtin_return_address(0)); sub_preempt_count(SOFTIRQ_OFFSET-1); if(unlikely(!in_interrupt()&amp;&amp;local_softirq_pending())) do_softirq(); dec_preempt_count();#ifdef CONFIG_TRACE_IRQFLAGS local_irq_restore(flags);#endif preempt_check_resched();&#125; 第12~13行代码判断是否可以允许执行软中断（即变量preempt_count中对应SOFTIRQ字段是否加1），如果是，调用trace_softirq_on()记录软中断使能的统计信息。 第15行代码以SOFTIRQ_OFFSET-1参数调用sub_preempt_count()函数将变量preempt_count对应SOFTIRQ字段部分进行减1操作，并禁止内核抢占（在PREEMPT对应字段减1）。 第16~17行代码中in_interrupt()函数用于查看当前是否处于中断上下文或者中断下半部中，local_softirq_pending()函数用于查看当前是否存在被挂起的软中断，do_softirq()函数用于执行当前被挂起的软中断。 第19行代码调用dec_preempt_count()函数使能内核抢占。 Linux内核提供了in_softirq()函数查看当前是否禁止了执行软中断，该函数定义在include/linux/hardirq.h中，代码如下： 12#define in_softirq() (softirq_count())#define softirq_count() (preempt_count()&amp;SOFTIRQ_MASK) 其中，preempt_count()用于获取thread_info结构中成员变量preempt_count,在默认情况下，SOFTIRQ_MASK的值为0xff00。 中断计数&emsp;&emsp;当内核进入中断时，会调用irq_enter()函数来增加中断的嵌套次数，该函数实际上是_irq_enter()函数的封装。_irq_enter()是一个宏定义，定义在include/linux/hardirq.h中，代码如下： 123456#define _irq_enter()\ do&#123;\ account_system_vtime(current);\ add_preempt_count(HARDIRQ_OFFSET);\ trace_harding_enter();\ &#125;while(0) 第3行代码调用account_system_vtime()函数更新当前进程的虚拟运行时间vtime。 第4行代码以HARDIRQ_OFFSET参数调用add_preempt_count()函数将变量preempt_count对应的HARDIRQ字段进行加操作。 第5行代码调用trace_hardirq_enter()函数对当前进程的进入中断上下文的计数器（存放在进程描述符struct中的成员变量hardirq_context)加1操作。 当内核从一个中断中退出时，会调用irq_exit()函数，减少中断的嵌套次数，该函数实际上是_irq_exit()函数的封装。_irq_exit()是一个宏定义，定义在include/linux/harrdirq.h中，代码如下： 123456#define _irq_exit()\ do&#123;\ trace_hardirq_exitt();\ account_system_vtime(current);\ sub_preempt_countt(HARDIRQ_OFFSET);\ &#125;while(0) 第3行代码调用trace_hardirq_exit()函数对当前进程的退出中断上下文的计数器（存放在进程描述符struct中的成员变量hardirq_context)进行加1操作。 第5行代码以HARRDIRQ_OFFSET为参数调用sub_preempt_count()函数将变量preempt_count对应的HARDIRQ字段部分进行减1操作。 Linux内核提供了in_irq()函数用于查看当前是否处于中断上下文中，该函数实际上是对hardirq_count()函数的封装，在include/linux/hardirq.h中，代码如下： 12#define in_irq() (hardirq_count())#define hardirq_count() (preempt_count()&amp;&amp;HARDIRQ_MASK) 其中，默认情况下，HARDIRQ_MASK的值为0xfff0000。 内核提供了in_interrupt()函数用于查看当前是否处于中断上下文中或者禁止执行软中断，该函数定义在include/linux/hardirq.h中，代码如下： 12#define in_interrupt() (irq_count())#define irq_count()(preempt_count()&amp;(HARDIRQ_MASK|SOFTIRQ_MASK)) 三、BKL&emsp;&emsp;BKL(大内核锁)是一个全局自旋锁，在早期的Linux版本中该锁被广泛使用，在Linux2.0版本中，这个锁是一个相对粗粒度的自旋锁，当时该锁是为了确保内核中一个时刻上只存在一个进程运行在内核态。而到了Linux2.2版本后，内核不再依赖于这个单独的自旋锁，而是由专门的自旋锁保护内核中的数据结构，从而允许多个处理器在内核中并发地执行程序。 &emsp;&emsp;BKL是一个名为kernel_flag的自旋锁，持有该锁的进程仍可以睡眠，因为内核中规定当任务无法调度的时候，该睡眠任务所持有的BKL锁才会被自动释放，该任务被重新调度的时候，该锁又会被重新获取，但是并不提倡让持有该锁的进程去睡眠；另外Linux允许一个进程递归地获取一个BKL锁，也就是说BKL是一种递归锁。代表进程结构的结构体task_struct中有一个成员变量命名为lock_depth，该成员变量就是为了实现让一个进程可以多次获取一个大内核锁而设定的。如果进程不需要获得BKL锁，则将该成员变量lock_depth的值设为-1；该进程每次获得BKL锁，就会使lock_depth加1，lock_depth表示该进程获得了多少次锁，当然，在该进程释放锁的时候，也必须调用同样次数的释放锁的函数，否则，该锁是不会被真正释放的。 &emsp;&emsp;在内核中不鼓励使用BKL，事实上，在新内核的代码中不再使用BKL，但是这种锁仍然在部分旧代码中被保留下来。BKL操作函数如下： 函数原型 描述 lock_kernel() 获得大内核锁BKL unlock_kernel() 释放大内核锁BKL kernel_locked() 如果锁被持有返回非0值，否则返回0]]></content>
      <categories>
        <category>Linux内核</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
        <tag>Linux内核同步机制</tag>
        <tag>每个处理器变量</tag>
        <tag>禁止内核中断</tag>
        <tag>BKL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux内核同步机制分析——RCU同步机制]]></title>
    <url>%2F2019%2FLinux%E5%86%85%E6%A0%B8%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6%E5%88%86%E6%9E%90%E2%80%94%E2%80%94RCU%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;读-复制-更新（Read-Copy-Update，RCU)机制是2.6内核中引入的另外一种新的同步机制。无论是自旋锁机制还是信号量机制都依赖于原子操作完成内核同步工作。但是，随着CPU性能的迅速提高，获得这些锁的开销相对于CPU的速度在成倍地增加，原因很简单——CPU的速度和访问内存的速度差距越来越大，系统的整体性能越来越依赖于高速缓存和流水线的性能；这种依赖于原子操作的不同机制需要使用内存屏障来保障原子操作，而这又会导致处理器流水线停滞和高速缓存的刷新，因此对系统的性能有很大的影响。 &emsp;&emsp;内核中新引入的RCU机制克服了基于原子操作同步机制的缺点，具有很好的可扩展性。但是，这种锁机制的使用范围比较窄，它只适用于读多写少的情况，如网络路由表的查询更新、设备状态表的维护、数据结构的延迟以及多径I/O设备的维护等。 一、RCU同步机制原理&emsp;&emsp;同步机制的核心思想是将写者的更新过程划分为移除和回收两个独立的步骤；同时要求必须通过指针来引用临界资源。移除步骤首先生成临界资源的一份复制并更新相关的域，然后解除指针对原有临界资源的应用并使之指向新的已经更新的复制件。回收步骤在适当的时机开始完成原有临界资源的回收工作，释放其占用的存储空间。 &emsp;&emsp;对于被RCU保护的共享数据结构，读者不需要获得任何锁就可以访问它，而写者在访问它时首先复制一个副本，然后对副本进行修改，最后使用回调(callback)机制在适当的时机把指向原来数据的指针重新指向新的被修改的数据。这个时机就是所有引用该数据的CPU都退出对共享数据的操作之时。因此可以把RCU同步机制看成是一种改进的读写自旋锁rwlock。 &emsp;&emsp;在RCU同步机制中，读者几乎没有什么同步开销，它不需要获得锁，也不使用原子指令，而且在除alpha之外的所有架构上也不需要内存屏障，因此不会导致锁竞争、内存延迟以及流水线停滞，从而大大提高了读者的性能。由于读者不需要获得任何锁，因此死锁问题也就不需要考虑了，这使得RCU同步机制的使用更加简单。RCU同步机制中写者的同步开销比较大，它需要复制被修改的数据结构，也必须使用某种锁机制同步其他并行的写者操作。在RCU同步机制的写者实现时，读者必须提供一个信号给写者以便写者能够确定数据可以被安全地释放或修改的时机。有一个专门的垃圾收集器来探测读者的信号，一旦所有的读者都已经发送信号告知它们都不再使用被RCU保护的数据结构，垃圾收集器就调用回调函数完成最后的数据释放或修改操作。因此RCU写者的同步开销比较大，它比较适用于写操作比较少的同步操作。 &emsp;&emsp;RCU与rwlock的不同之处是：RCU同步机制既允许多个读者同时访问被保护的数据，又允许多个读者和多个写者同时访问被保护的数据，读者没有任何开销，而写者的同步开销则取决于使用的写者间同步机制。但RCU不能代替rwlock，因为如果写操作比较多时，对读者性能提高不能弥补写者导致的性能损失。 二、RCU同步机制的实现&emsp;&emsp;内核为RCU同步机制提供了一系列的操作函数，下面只讨论5个主要函数的实现，其他的操作函数都是这些函数的封装，可由这些函数组合而成。 rcu_read_lock() &emsp;&emsp;该操作函数由读者任务调用，表明读者任务以只读方式进入了RCU临界区，开始对RCU临界资源进行访问。代码如下所示： 123456#define rcu_read_lock()\ do&#123;\ preempt_disable();\ _acquire(RCU);\ rcu_read_acquire();\ &#125;while(0) 其中，_acquire()函数和rcu_read_acquire()函数都是编译器上的选择信息，preempt_disable()禁止内核抢占，即RCU同步机制中获取读锁只禁止当前处理器上的内核抢占，不需要获得任何形式的锁。读者任务进入RCU临界区后，不能进入睡眠状态。 rcu_read_unlock() &emsp;&emsp;该操作函数由读者任务调用，表明读者完成了对临界资源的访问，离开了RCU临界区。 123456#define rcu_read_unlock()\ do(\ rcu_read_release();\ _release(RCU);\ preempt_enable();\ )while(0) 该函数与rcu_read_lock()函数类似，主要调用preempt_enable()函数使能当前处理器的内核抢占。 rcu_dereference() &emsp;&emsp;该函数由读者任务调用，用于获取指向RCU临界资源的指针，因此RCU机制限制所有的临界资源都应该以指针方式进行间接访问。 12345#define rcu_dereference(&#123;\ typeof(p) __p1=ACCESS_ONCE(p);\ smp_read_barrier_depends();\ (__p1);\&#125;) 该宏定义实现的功能看似多余，实则不然。这里通过为指针p创建一个新的复制件__p1，使读者任务在通过复制__p1访问RCU资源的同时，不妨碍写者对原有指针变量p的修改。 rcu_assign_pointer() &emsp;&emsp;该操作函数由写者任务调用，在读者任务更新临界资源的移除阶段，用于重置RCU临界资源的指针，使之指向新版本的临界资源。 1234#define rcu_assign_pointer(p,v)(&#123;\ smp_wmb();\ (p)=(v);\&#125;) synchronize_rcu() &emsp;&emsp;该函数由写者任务调用，在写者任务完成移除工作之后，调用该函数进入睡眠状态，等待所有的读者进程完成对旧版本临界资源的访问。在所有读者任务不再引用旧版本数据之后，内核负责将写者任务唤醒，接下来写者任务完成旧版本临界资源的访问。在所有读者任务不再引用旧版本数据之后，内核负责将写者任务唤醒，接下来写者任务完成旧版本临界资源的回收工作。 1234567void synchronize_rcu(void)&#123; struct rcu_synchronize rcu; init_completion(&amp;rcu.completion); call_rcu(&amp;rcu.head,wakeme_after_rcu); wait_for_completion(&amp;rcu.completion);&#125; call_rcu() &emsp;&emsp;该函数由写者任务调用，在写者任务完成移除工作之后，调用该函数向系统注册一个资源“回收”处理函数，在所有读者任务不再引用旧版本数据之后，内核调用该处理函数完成旧版本临界资源的回收工作。与synchronize_rcu()函数相比，该函数不会阻塞，可用于中断上下文中。 123456789101112131415161718void fastcall call_rcu(struct rcu_head *head,void(*func)(struct rcu_head *rcu))&#123; unsigned long flags; struct rcu_data *rdp; head-&gt;func=func; head-&gt;next=NULL; local_irq_save(flags); rdp=&amp;_get_cpu_var(rcu_data); *rdp-&gt;nxtail=head; rdp-&gt;nxttail=&amp;head-&gt;next; if(unlikely(++rdp-&gt;qlen&gt;qhimark)) &#123; rdp-&gt;blimit=INT_MAX; force_quiescent_state(rdp,&amp;rcu_ctrlblk); &#125; local_irq_restore(flags);&#125;]]></content>
      <categories>
        <category>Linux内核</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
        <tag>Linux内核同步</tag>
        <tag>RCU同步机制</tag>
        <tag>读-复制-更新</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux内核同步机制分析——信号量机制]]></title>
    <url>%2F2019%2FLinux%E5%86%85%E6%A0%B8%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6%E5%88%86%E6%9E%90%E2%80%94%E2%80%94%E4%BF%A1%E5%8F%B7%E9%87%8F%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;自旋锁同步机制是一种“忙-等待”机制，在临界资源被锁定的时间很短的情况下非常有效。但是在临界资源被持有时间很长或不确定的情况下，忙-等待机制则会浪费宝贵的CPU时间。针对这种情况，Linux中提供了另外一种实现同步的机制——信号量。实际上在Linux提供了两种信号量，即内核信号量（供内核代码使用）和System V IPC信号量（供用户进程间通信使用）。下面我们讨论内核信号量。 &emsp;&emsp;信号量与自旋锁最大的不同点在于，当一个任务试图去获取一个已经被占用的信号量的时候，该任务不会像在自旋锁机制中那样，不断地进行“自旋”直到获得该锁，相反在信号量机制中，如果该任务发现它申请的信号量正在被占用，也就是它发现它现在不可以获取该信号量，那么该任务会被添加到一个等待队列中去睡眠，当持有信号量的进程释放信号量以后，处于等待队列中的那个任务将被唤醒，并获得该信号量。因此，也称Linux中的内核信号量是一种睡眠锁。这也就是说持有信号量的函数可能会睡眠，这就要求只有可以睡眠的函数才可以使用信号量，这也就意味着不可以在中断处理程序中使用信号量，因为它是不可以睡眠的。 &emsp;&emsp;信号量与自旋锁还有一点区别就是信号量允许被多个任务持有，而自旋锁在同一时刻只允许一个任务持有它。根据信号量是否可以被多个任务所持有，可以将信号量分为互斥信号量和计数信号量。互斥信号量表示，在任意时刻至多允许一个任务持有，通常用于多个任务互斥地访问某一临界资源时。而计数信号量允许在一个时刻至多有count个任务持有，count为信号到来时计数器的初始值，其取值在信号量初始化时确定。计数信号量用于对特定代码加以限制，内核中使用它的机会不多，内核中使用的信号量基本上都是互斥信号量。 一、普通信号量&emsp;&emsp;信号量同步机制由DijKstra提出，之后它逐渐成为了一种常用的锁机制。在长期且广泛的应用中，信号量机制又得到了很大的发展，出现了基于该思想的各种变体。现在信号量机制广泛应用于各种操作系统之中。除了初始化之外，信号量只能通过两个原子操作P()和V()访问。前者是测试操作，后者是增加操作。后来的系统把这两种操作分别叫做down()和up()，Linux也遵循这种叫法。 &emsp;&emsp;down()操作通过对信号量计数器减1来请求获得一个信号量。如果结果是0或大于0，获得信号量锁，任务就可以进入临界区；如果结果是负数，任务就会被放入等待队列中，处理器执行其他任务。相反，当临界区中的操作完成后，可以调用up()操作来释放信号量，它会增加信号量的计数器。如果在该信号量上的等待队列不为空，那么处于队列中等待的任务在被唤醒的同时会获得该信号量。 &emsp;&emsp;信号量机制的实现与体系结构有关，下面主要讨论在32位的x86体系结构下信号量的实现。普通信号量的数据结构使用struct semaphore来表示，该结构定义在include/asm-x86/semaphore_32.h中，结构如下： 123456struct semaphore&#123; atomic_t count; int sleepers; wait_queue_head_t wait;&#125; count：成员变量时信号量的计数器，该变量定义为atomic_t结构，从而保证了对该变量的操作为原子操作。当count大于0时，表示该信号量此时是空闲的，可以使用；当count等于0时，表示该信号量现在不可以用，但是并没有其他进程在等待这个信号量被释放；当count小于0时，表示该信号量现在不可以用，并且至少有一个任务也在等待该信号量被释放。 &emsp;&emsp;信号量与自旋锁的不同点的第二条就是它可以同时允许任意数量的锁持有者，而这正是通过设置该成员变量的值来实现的，当初始化一个信号量的时候，可以用count的值来指定有多少个任务可以同时持有该信号量。 &emsp;&emsp;sleepers：该成员变量用来存放一个标志，表示是否有任务在该信号量的等待队列上睡眠，当没有任务在该信号量的等待队列上睡眠的时候被设置为0，否则设置为1. &emsp;&emsp;wait：该成员变量是一个链表头，用来将所有等待该信号量的睡眠进程组织成一个链表结构。 &emsp;&emsp;Linux内核为普通信号量同步机制提供了一系列的操作函数，操作函数原型及其描述如下： 函数原型 描述 sema_init(struct semaphore *sem,int val) 初始化执行的信号量sem的计数器初始值为val，并初始化信号量的其他两个成员变量 init_MUTEX(struct semaphore *sem) 初始化指定的信号量sem为一个互斥信号量 int_MUTEX_LOCKED(struct semaphore *) 初始化指定的信号量sem为一个互斥信号量，同时将count的值赋为0，即该信号量初始状态为加锁状态 down(struct semaphore *sem) 试图去获取指定的信号量sem，如果发现该信号量当前不可以获取，则进入不可中断睡眠状态 down_interruptible(struct semaphore*) 试图获取指定的信号量sem，如果发现该信号量当前不可以获取，则进入可中断睡眠状态 down_trylock(struct semaphore * sem) 试图获取指定的信号量sem，如果发现该信号量当前不可以获取，则立即返回一个非0值 up(struct semaphore *sem) 释放指定的信号量sem，同时如果该信号量的等待队列不为空的话，就唤醒其中的一个等待进程 &emsp;&emsp;信号量的获取和释放过程分别由函数down()和up()完成。 获取信号量的处理过程&emsp;&emsp;普通信号量的获取是由函数down()完成的，该函数定义在include/asm-x86/semaphore_32.h中，代码如下: 1234567891011121314static inline void down(struct sempahore *sem)&#123; might_sleep(); _asm__volatile_( "# atomic down operation\n\t" LOCK_PREFIX"decl %0\n\t"/ "jns 2f/n" "\tlea %0,%%eax\n\t" "call_down_failed\n" "2:" :"+m"(sem-&gt;count) : :"memory","ax");&#125; 第3行代码中的might_sleep()函数检查是否需要重新调度。如果是，则调用schedule()函数进行重新调度。 将第5~10行内嵌汇编代码展开后，对应的汇编代码如下： 123456#atomic down operationLOCK_PREFIX decl %0jns 2flea %0,%%eaxcall_down_failed2: 第2~3行以原子的方式从信号量计数器count上减1，然后判断运算结果是否为负值。如果结果不为负，跳转到标号名称为2的位置，即第105行，从该函数中退出；当结构为负值时，表示该信号量不可用，则执行第4-5行代码。 第4~5行代码首先使用lea汇编指令将信号量sem的地址保存到寄存器%eax中（结构的第一个成员变量的地址就是该结构的地址），然后调用_down_failed()函数进行处理，当该函数返回时，任务也就获得了信号量的使用权。 原代码中第11~13行为内嵌汇编代码的输入、输出列表以及破坏性描述部分。 _down_failed()函数在获取信号量失败时被调用，负责将任务插入到信号量sem的等待队列中，然后调用调度器，释放处理器的使用权。该函数定义在arch/x86/lib/semaphore_32.S中，代码如下： 1234567891011121314151617181920212223ENTRY(_down_failed) CFI_STARTPROC FRAME push %edx CFI_ADJUST_CFA_OFFSET 4 CFI_REL_OFFSET edx,0 pushl %ecx CFI_ADJUST_CFA_OFFSET 4 CFI_REL_OFFSET ecx,0 call _down popl %ecx CFI_ADJUST_CFA_OFFSET -4 CFI_RESTORE ecx popl %edx CFI_ADJUST_CFA_OFFSET -4 CFI_RESTORE ecx popl %edx CFI_ADJUST_CFA_OFFSET -4 CFI_RESTORE edx ENDFRAME ret CFI_ENDPROCEND(_down_failed) 在第2、3、5、6、8、9、12、13、15、16、18~20、22行代码用于记录Linux系统内核的调试信息。 第4、7、11、14、17行代码保存寄存器%edx,%ecx的值，然后调用_down()函数完成在获取信号量失败时的具体1处理过程，最后恢复寄存器%edx,%ecx的值。 从对_down_failed()函数的汇编代码分析可知，_down_failed()函数实际上是_down()函数的封装，获取信号量失败时，由_down()函数完成具体的处理过程，_down()函数定义在lib/semaphore-sleepers.c中，代码如下： 123456789101112131415161718192021222324252627282930fastcall void _sched_down(struct semaphore *sem)&#123; struct task_struct *tsk=currrent; DECLARE_WAITQUEUE(wait,tsk); unsigned long flags; tsk-&gt;state=TASK_UNINTERRUPTIBLE; spin_lock_irqsave(&amp;sem-&gt;wait.lock,flags); add_wait_queue_exclusive_locked(&amp;sem-&gt;wait,&amp;wait); sem-&gt;sleepers++; for(;;) &#123; int sleepers=sem-&gt;sleepers; if(!atomic_add_negative(sleepers-1,&amp;sem-&gt;count)) &#123; sem-&gt;sleepers=0; break; &#125; sem-&gt;sleepers=1; spin_unlock_irqrestore(&amp;sem-&gt;wait.lock,flags); schedule(); spin_lock_irqsave(&amp;sem-&gt;wait.lock,flags); tsk-&gt;state=TASK_UNINTERRUPTIBLE; &#125; remove_wait_queue_locked(&amp;sem-&gt;wait,&amp;wait); wake_up_locked(&amp;sem-&gt;wait); spin_unlock_irqstore(&amp;sem-&gt;wait.lock,flags); tsk-&gt;state=TASK_RUNNING;&#125; 第3~5行代码声明了该函数中将要使用的局部变量。其中，指针变量tsk被初始化为当前任务的进程描述符；而第4行使用宏定义DECLARE_WAITQUEUE()声明了一个名称为wait的等待队列节点。 第7~9行代码用于将上述几行代码构建的等待队列节点wait插入到信号量sem对应的等待队列队尾。其中，第7行代码设置当前任务的状态为不可中断睡眠状态(TASK_UNINTERRUPTIBLE);第8行代码调用spin_lock_irqqseve()函数获得等待队列所包含的自旋锁，禁止中断响应并将处理器标志寄存器EFLAGS的值保存到flags中，其逆操作在第23行和第28行；第9行代码将等待队列节点wait插入到信号量sem对应的等待队列队尾。 在第12~25行构成一个for循环，在任务无法获得信号量的情况下，将会一直睡眠在相应的等待队列上。该任务在阻塞过程中可能被唤醒，当该任务被唤醒后，通过第15行代码判断是否成功获得信号量的使用权。在成功获得信号量时，执行break语句跳出for循环，并执行第26-29行代码；否则，再次调用调度schedule()函数，释放处理器的使用权，并将任务的当前执行状态设置为不可中断睡眠状态。 第26~29行代码在任务被唤醒且获得信号量之后执行。其中，第26行将等待队列节点wait从等待队列中移出，第28行释放对等待队列锁包含的自旋锁，恢复处理器的标志寄存器EFLAGS，第29行代码设置当前任务为运行状态。 释放信号量的处理过程&emsp;&emsp;普通信号量的释放由up()函数完成，该函数负责将信号量计数器count的值加1，表示信号量被释放，在有任务阻塞在该信号量的情况下，唤醒等待队列中睡眠的任务.up()函数定义在include/asm-x86/semaphore_32.h中，代码如下所示： 12345678910111213static inline void up(struct semaphore *sem)&#123; _asm__volatile_( "#atomic up operation\n\t" LOCK_PREFIX"incl %0\n\t" "jg 1f\n\t" "lea %0,%%eax\n\t" "call _up_wakeup\n" "1:" :"+m"(sem-&gt;count) : :"memory","ax");&#125; &emsp;&emsp;第5~6行代码执行down()函数的逆操作，两者的语句内容和格式也非常类似。第5行代码负责以原子方式将信号量计数器count的值加1.第6行代码判断是否有任务阻塞在该信号量上，如果没有，则跳转到标号名称为1的位置，从函数中退出；否则，执行第7-8行代码。 &emsp;&emsp;第7~8行的代码首先将信号量的地址保存到寄存器%eax中，该参数在函数调用的过程中，作为参数被传递给_up_wakeup()函数，由_up_wakeup()函数负责进一步的处理。 &emsp;&emsp;_up_wakeup()函数与_down_failed()函数相似，_up_wakeup()函数定义在arch/x86/lib/semaphore_32.S中，该函数实际上是_up()函数的封装，_up()函数定义在lib/semaphore-sleepers.c中，它直接调用wake_up()函数完成等待队列上任务的唤醒工作。 &emsp;&emsp;通过对普通信号量的获取和释放函数的分析可知，普通信号量基于原子变量和等待队列这两个变量来完成同步工作，其中的原子变量用于计数器，记录信号量的当前状态；而等待队列用于组织阻塞在该信号量上的睡眠任务。 二、读写信号量&emsp;&emsp;读写信号量是在Linux2.4内核中引入的一种机制，它与自旋锁类似，将信号量也区分为读和写两种类型。读写信号量的引入提高了内核的并发度，对整个系统的性能提高有一定的帮助。 &emsp;&emsp;读写信号量在内核中是由结构体rw_semophore来表示的，该结构体定义在文件include/asm-x86/rwsem.h中，形式如下： 123456789101112131415struct rw_semphore&#123; signed long count;#define RWSEM_UNLOCKED_VALUE 0X00000000#define RWSEM_ACTIVE_BIAS 0X00000001#define RWSEM_ACTIVE_MASK 0x0000ffff#define RWSEM_WAITINT_BIAS (-0x00010000)#define RWSEM_ACTIVE_READ_BAS RWSEM_ACTIVE_BIAS#define RWSEM_ACTIVE_WRITE_BIAS (RWSEM_WAITING_BIAS+RWSEM_ACTIVE_BIAS) spinlock_t wait_lock; struct list_head wait_list;#ifdef CONFIG_DEBUG_LOCK_ALLLOC struct lockdep_map dep_map;#endif&#125;; count：该成员变量用于存放两个16位的计数器 wait_lock:该成员变量是一个自旋锁，用于保护等待队列和rw_semaphore结构体本身。 wait_list:该成员变量指向等待队列的链表，该链表中的每一个元素都是一个rwsem_waiter结构体，该结构体中包含三个成员变量，一个是指向睡眠进程的描述符的指针，另外一个是用来标识该进程是为读需要的信号量还是为写需要信号量的标志。最后一个就是用来将这些结构体连接成为一个链表结构的链表结构体。 内核同样提供了一些与读写信号量相对应的操作函数，这些操作函数的原型和描述如下： 函数原型 描述 init_rwsem(sem) 初始化指定的读写信号量sem down_read(struct rw_semaphore *sem) 用于获取指定的读锁sem，如果成功获得，直接返回，否则读者进入睡眠状态 up_read(struct rw_semaphore *sem) 释放持有的读锁sem down_read_trylock(struct rw_semaphore *sem) 试图获得锁定的读锁sem，如果不成功，立即返回，返回值为0，否则锁定成功，返回值为1 down_write(struct rw_semaphore *sem) 用于获得指定的写锁sem，如果锁定成功，直接返回，否则，写者进入睡眠状态 up_write(struct rw_semaphore *sem) 释放指定的写锁sem dwon_write_trylock(struct rw_semaphore *sem) 试图获得指定的写锁sem，如果不成功，立即返回，返回值为0，否则锁定成功，返回值为1 &emsp;&emsp;关于读写信号量最后还需要注意的是，内核是按照先进先出(FIFO)的顺序来处理等待读写信号量的任务，Linux中是这样规定的，如果一个任务去试图获取一个信号量时，它发现该信号量现在是不可获取的，于是该任务就被添加到信号量等待队列的末尾，当信号量被释放的时候，内核会首先检查等待队列中的第一个任务，并且唤醒任务，此时，如果被唤醒的任务是一个写者任务，那么该任务获得写信号量，同时其他任务继续在等待队列中睡眠；而如果被唤醒的任务是一个读者任务，那么紧跟在该任务之后的所有读者任务都会被唤醒并获得读锁，不过该操作时不可以跳跃进行的，也就是说在写者任务之后排队的任务即使是读者任务，也不会被唤醒并拥有锁。]]></content>
      <categories>
        <category>Linux内核</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
        <tag>Linux内核同步</tag>
        <tag>信号量</tag>
        <tag>普通信号量</tag>
        <tag>读写信号量</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux内核同步机制分析——读写自旋锁]]></title>
    <url>%2F2019%2FLinux%E5%86%85%E6%A0%B8%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6%E5%88%86%E6%9E%90%E2%80%94%E2%80%94%E8%AF%BB%E5%86%99%E8%87%AA%E6%97%8B%E9%94%81%2F</url>
    <content type="text"><![CDATA[二、读写自旋锁&emsp;&emsp;在某些情况下，对临界资源的访问在逻辑上可以分为只读和只更新两种不同的操作。通常允许多个读者在同一时间段内访问临界资源，而只允许唯一的写者更新临界资源。这种情况下的同步问题即为操作系统中”读者/写者“问题。 &emsp;&emsp;针对这种“读者/写者”问题，Linux内核提供了一个自旋锁的变种——读写自旋锁，用于优化对此类临界资源的访问。对比普通自旋锁，读写自旋锁允许多个读者任务同时进入临界区，交错访问同一个临界资源，提高了系统同的并发能力，提升了系统的吞吐量。 &emsp;&emsp;在Linux内核中，读写自旋锁为读者和写者分别提供了不同的锁。一个或多个读者任务可以并发地持有“读锁”，而“写锁”最多只能被一个写者任务持有，并且此时不可以有并发的读操作。也就是说，“写”操作要求完全的互斥。 &emsp;&emsp;读写自旋锁变量由数据结构rwlock_t表示，该数据结构定义在include/linux/spinlock_types.h中，代码如下： 1234567891011121314typedef struct&#123; raw_rwlock_t raw_lock; #if defined(CONFIG_PREEMPT)&amp;&amp;defined(CONFIG_SMP) unsigned int break_lock; #endif #ifdef CONFIG_DEGBUG_SPINLOCK unsigned int magic,owner_cpu; void *owner; #endif #ifdef CONFIG_DEBUG_LOCK_ALLOC struct lockdep_map dep_map; #endif&#125;rwlock_t; raw_lock：该成员变量是读写自旋锁的数据结构的核心，具体的锁定过程与该成员变量密切相关。此数据结构是一个空结构体，其数据类型raw_rwlock_t依赖于未定义内核选项CONFIG_SMP的情况下，此时读写自旋锁的锁定、释放的过程分别退化为禁止、使能内核抢占。 &emsp;&emsp;break_lock：该无符号整型变量break_lock用于指示当前自旋锁是否被多个内核线程同时竞争、访问。同时依赖于内核选项CONFIG_PREEMPT和CONFIG_SMP。 &emsp;&emsp;内核在include/linux/spin_lock.h中提供了一系列关于读写自旋锁的操作函数接口。下表是关于读写自旋锁的操作函数。 函数原型 描述 rwlock_init(lock) 声明一个读写自旋锁lock，将其初始化成未锁定状态 read_lock(lock) 用于获得指定的读锁lock，如果锁定完成，直接返回；否则循环的等待直到获得读锁 read_unlock(lock) 释放持有的读锁lock read_lock_irq(lock) 禁止本地中断，并获取指定的读锁lock read_unlock_irq(lock) 释放持有的读锁lock，并激活本地中断 read_lock_irqsave(lock) 保存本地中断的当前状态，禁止本地中断，并获得指定的读锁lock read_unlock_irqrestore(lock,flags) 释放持有的读锁lock，并让本地中断恢复到以前的状态 read_trylock(lock) 试图获得指定的读锁lock，如果不成功，立即返回，返回值为0，否则锁定成功，返回值为1 write_lock(lock) 用于获得指定的写锁lock，如果锁定成功，直接返回，否则循环等待直到获得写锁 write_unlock(lock) 释放指定的写锁lock write_lock_irq(lock) 禁止本地中断，并获取指定的写锁lock write_lock_irqsave(lock,flags) 保存本地中断的当前状态，禁止本地终端，并获取指定的写锁lock write_unlock_irqrestore(lock,flags) 释放持有的写锁lock，并让本地中断恢复到以前的状态 write_trylock(lock) 试图获得指定的写锁lock，如果不成功，立即返回，返回值为0，否则锁定成功，返回值为1 &emsp;&emsp;读写自旋锁的具体实现方式和自旋锁类似，依赖于内核选项CONFIG_SMP。在单处理器系统中，即在未定义内核选项CONFIG_SMP的情况下，读写自旋锁的获得、释放过程同样退化为禁止内核抢占和使能内核抢占，其处理过程和普通自旋锁在单处理器系统的处理过程基本相同。 &emsp;&emsp;在定义了内核选项CONFIG_SMP的多处理器系统中，raw_rwlock_t结构定义在include/asm-x86/spinlock_types.h中，定义如下： 1234typedef struct&#123; unsigned int lock;&#125; raw_rwlock_t; &emsp;&emsp;从其定义可以看出，它与普通自旋锁的数据结构raw_spinlock_t形式一样，都只声明了一个无符号内存变量，但是使用方法却有很大的差别，正是这些差别才造就了读写自旋锁的性质。 &emsp;&emsp;读写自旋锁的获取过程分为读锁获取和写锁获取。两者的关键区别在于加锁过程从结构raw_rwlock_t的成员变量lock上减去的数值不同：每次读锁加锁过程减去1，每次写锁加锁过程减去一个常量RW_lOCK_BIAS(其值大小为0x01000000),即224个读者进程。读写自旋锁的释放过程与获取过程正好相反。 &emsp;&emsp;下面我们以读写自旋锁的加锁函数和释放函数为例，对读写自旋锁的实现机制进行分析。读写自旋锁又分为读锁的加锁函数与释放函数、写锁的加锁函数与释放函数。 读锁的获取与释放过程&emsp;&emsp;读锁的加锁过程由宏定义read_lock()来完成，该宏定义在include/linux/spinlock.h中，代码如下所示： 1#define read_lock(lock) _read_lock(lock) &emsp;&emsp;从上述代码中可以看出，宏定义read_lock()是由_read_lock()函数进行了简单的封装。在定义了内核选项CONFIG_SMP时，_read_lock()函数定义在kernel/spinlock.c中，代码如下所示： 123456void _lockfunc _read_lock(rwlock_t *lock)&#123; preempt_disable(); rwlock_acquire_read(&amp;lock-&gt;dep_map,0,0,_RET_IP_); LOCK_CONTENDED(lock,_raw_read_trylock,_raw_read_lock);&#125; &emsp;&emsp;这个函数的实现与普通自旋锁的_spin_lock()函数实现方式相似，都是先禁止内核抢占，然后调用_raw_read_lock()函数完成加锁过程。_raw_read_lock()函数时一个宏定义，定义在include/linux/spinlock.h中，代码如下所示： 1#define _raw_read_lock(rwlock) _raw_read_lock(&amp;(rwlock)-&gt;raw_lock) &emsp;&emsp;其中，_raw_read_lock()仿函数的实现与系统的体系结构有关，在32位的x86体系结构下，该函数定义在include/asm-x86/spinlock_32.h中，代码如下： 12345678static inline void _raw_read_lock(raw_rwlock_t *rw)&#123; asm volatile(LOCK_PREFIX" subl $1,(%0)\n\t "jns 1f\n" "call _read_lock_failed\n\t" "1:\n" ::"a"(rw)::"memory");&#125; 第3~6行内嵌汇编代码展开后，对应的汇编代码如下： 1234LOCK_PREFIX subl $1 ,(%0) jns 1f call _read_lock_failed1: 第1行代码以原子方式对读写自旋锁进行减1操作。 第2~4行代码首先检查是否加锁成功（运算结果为负），如果加锁成功，直接跳转到标号名称为1的位置处，直接从函数返回；否则，调用_read_lock_failed()函数，重新尝试加锁操作。 定义中第7行代码是内嵌汇编代码的输入、输出列表以及破坏性描述部分。这里输入列表为空，输出列表中包含唯一的变量，即读写自旋锁的计数器，修饰该变量的限定符a表示将该变量与寄存器%eax相关联；破坏性描述部分这里声明了内存会被这段代码修改。 &emsp;&emsp;在32位的x86体系结构下，_read_lock_failed()函数定义在arch/x86/lib/semaphore_32.S中，代码如下所示： 123456789101112131415ENTRY(_read_lock_failed) CFI_STARTPROC FRAME 2:LOCK_PREFIX incl(%eax) 1:rep:nop cmpl $1,(%eax) js 1b LOCK_PREFIX decl(%eax) js 2b ENDFRAME ret CFI_ENDPROCEND(_read_lock_failed) 第2、3、12、14行代码用于记录Linux系统内核的调试信息。 第4~5行代码用于将读写自旋锁计数器的值加1.其目的是用于补偿当尝试读锁加锁但是不成功时，在读写自旋锁计数器上减去1的错误。 第6~8行代码构成了一个循环，该循环首先执行一条空指令，然后测试读写计数器当前值是否大于1.如果不大于1，继续循环等待、测试，直到计数器的值大于1.然后执行第9-14行代码。 &emsp;&emsp;第9~14行代码尝试再次以读方式锁定自旋锁，第9-10行以原子的方式从读写自旋锁的计数器上减1。第11行检查是否加锁成功，在不成功的情况下，跳转到这段代码的起始位置，重新尝试加锁；在加锁成功的情况下，顺序执行到第14行，通过ret指令进行函数调用的返回。 &emsp;&emsp;读写自旋锁中读锁的释放是通过宏定义read_unlock()来完成的。宏read_unlock()定义在include/linux/spinlock.h中，代码如下： 1#define read_unlock(lock) _read_unlock(lock) &emsp;&emsp;在定义了内核选项CONFIG_SMP时，_read_unlock()函数定义在kernel/spinlock.c中的，代码如下： 123456void _lockfunc _read_unlock(rwlock_t *lock)&#123; rwlock_release(&amp;lock-&gt;dep_map,1,_RET_IP_); _raw_read_unlock(lock); preempt_enable();&#125; &emsp;&emsp;这个函数的实现与普通自旋锁的_spin_unlock()函数实现方式相似，主要是通过调用_raw_read_unlock()函数来完成读锁的释放工作。_raw_read_unlock()函数定义在include/linux/spinlock.h中，代码如下： 1#define _raw_read_unlock(rwlock) _raw_read_unlock(&amp;(rwlock)-&gt;raw_lock) &emsp;&emsp;其中_raw_read_unlock()函数的实现与系统的体系结构相关，在32位的x86体系结构下，该函数定义在include/asm-x86/spinlock_32.h中，代码如下： 1234static inline void _raw_read_unlock(raw_rwlock *rw)&#123; asm volatile(LOCK_PREFIX "incl %0":"+m"(rw-&gt;lock)::"memory");&#125; &emsp;&emsp;该函数的实现使用了简单的内嵌汇编代码，直接对读写自旋锁的计数器进行加1操作。 写锁的加锁与释放过程&emsp;&emsp;写锁的加锁过程由宏定义write_lock()来完成，该宏定义在include/linux/spinlock.h中，代码如下所示： 1#define write_lock(lock) _write_Lock(lock) &emsp;&emsp;从上述代码中可以看出，宏定义write_lock()是由_write_lock()函数进行了简单的封装。在定义了内核选项CONFIG_SMP时，_write_lock()函数定义在kernel/spinlock.c中，代码如下所示： 123456void _lockfunc _write_lock(rwlock_t *lock)&#123; preempt_disable(); rwlock_acquire(&amp;lock-&gt;dep_map,0,0,_RET_IP_); LOCK_CONTENDED(lock,_raw_write_trylock,_raw_write_Lock);&#125; &emsp;&emsp;这个函数的实现与普通自旋锁的_spin_lock()函数实现方式相似，都是先禁止内核抢占，然后调用_raw_write_lock()函数完成加锁过程。_raw_write_lock()函数时一个宏定义，定义在include/linux/spinlock.h中，代码如下所示： 1#define _raw_write_lock(rwlock) _raw_write_lock(&amp;(rwlock)-&gt;raw_lock) &emsp;&emsp;其中，_raw_write_lock()函数的实现与系统的体系结构相关，在32位的x86体系结构下，该函数定义在include/asm-x86/spinlock_32.h中，代码如下： 12345678static inline void _raw_write_lock(raw_rwlock_t *rw)&#123; asm volatile(LOCK_PREFIX" subl $ " RW_LOCK_BIAS_STR",(%0)\n\t" "jz 1f\n" "call _write_lock_failed\n\t" "" 1:\n" ::"a"(rw):"memory");&#125; &emsp;&emsp;第3~6行内嵌汇编代码展开后，对应的汇编代码如下： 1234LOCK_PREFIX subl $ RW_LOCK_BIAS_STR,(%0) jz 1f call __write_lock_failed1: &emsp;&emsp;第1行代码中的常量字符串RW_LOCK_BIAS_STR定义在include/asm-x86/rwlock.h中，常量字符串的值为0x01000000。该行代码的含义是以原子方式从读写自旋锁计数器中减去一个常量0x01000000. &emsp;&emsp;第2~3行代码首先检查是否加锁成功（运算结果为负），如果加锁成功，直接跳转到标号名称为1的位置处，直接从函数返回，否则调用_write_lock_failed()函数，重新尝试进行加锁操作。 &emsp;&emsp;第4行代码是内嵌汇编代码的输入、输出列表以及破坏性描述部分。在这里输入列表为空，输出列表中包含唯一的变量，即读写自旋锁的计数器，修饰该变量的限定符a表示将该变量与寄存器%eax相关联；破坏性描述符部分在这里声明了内存会被这段代码修改。 &emsp;&emsp;在32位的x86体系结构下，_write_lock_failed()函数定义为arch/x86/lib/semaphore_32.S中，代码如下所示： 123456789101112131415ENTRY(_write_lock_failed) CFI_STARTPROC simple FRAME 2:LOCK_PREFIX addl $ RW_LOCK_BIAS,(%eax) 1:rep:nop cmpl $ RW_LOCK_BIAS,(%eax) jne 1b LOCK_PREFIX subl $ RW_LOCK_BIAS,(%eax) jnz 2b ENDFRAME ret CFI_ENDPROCEND(_write_lock_failed) &emsp;&emsp;第2、3、12、14行代码用于记录Linux系统内核的调试信息。 &emsp;&emsp;第4~5行代码用于将读写自旋锁计数器的值加一个常量RW_LOCK_BIAS。其目的是：用于补偿当尝试加锁但不成功时，在读写自旋锁计数器上减去常量RW_LOCK_BIAS的错误。 &emsp;&emsp;第6~8行代码构成一个循环，该循环首先执行一条空指令，然后测试读写计数器当前值是否等于常量RW_LOCK_BIAS，在相等的情况下，继续循环等待、测试，直到计数器的值等于常量RW_LOCK_BIAS，然后执行9-13行的代码。 &emsp;&emsp;第9~13行代码尝试再次以写的方式锁定自旋锁。第9-10行以原子的方式从读写自旋锁的计数器上减去一个常量RW_LOCK_BIAS。第11行检查是否加锁成功，在不成功的情况下，跳转到这段代码的起始位置，重新尝试加锁；在成功的情况下，顺序执行到第13行，通过指令ret进行函数调用的返回。 &emsp;&emsp;读写自旋锁中写锁的释放是通过宏定义write_unlock()来完成的。宏write_unlock()定义在include/linux/spinlock.h中，代码如下： 1#define write_unlock(lock) _write_unlock(lock) &emsp;&emsp;在定义了内核选项CONFIG_SMP时，_write_unlock()函数定义在kernel/spinlock.c中，代码如下： 123456void _lockfunc _write_unlock(rwlock_t *lock)&#123; rwlock_release(&amp;lock-&gt;dep_map,1,_RET_IP_); _raw_write_unlock(lock); preempt_enable();&#125; &emsp;&emsp;这个函数的实现与普通自旋锁的_spin_unlock()函数实现方式相似，主要是通过调用_raw_write_unlock()函数来完成读锁的释放工作。_raw_write_unlock()函数定义在include/linux/spinlock.h中，代码如下： 1#define _raw_write_unlock(rwlock) _raw_write_unlock(&amp;(rwlock)-&gt;raw_lock) &emsp;&emsp;其中 _raw_write_unlock()函数的实现与系统的体系结构相关，在32位的x86体系结构下，该函数定义在include/asm-x86/spinlock_32.h中，代码如下： 12345static inline void _raw_write_unlock(raw_rwlock_t *rw)&#123; asm volatile(LOCK_PREFIX" addl $ "RW_LOCK_BIAS_STR"，%0 :"+m"(rw-&gt;lock)::"memory");&#125; &emsp;&emsp;该函数的实现使用了很简单的内嵌汇编代码，直接对读写自旋锁的计数器加上一个常量0x01000000操作1.]]></content>
      <categories>
        <category>Linux内核</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
        <tag>Linux内核</tag>
        <tag>Linux内核同步</tag>
        <tag>读写自旋锁</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux内核同步机制分析——普通自旋锁]]></title>
    <url>%2F2019%2FLinux%E5%86%85%E6%A0%B8%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6%E2%80%94%E2%80%94%E6%99%AE%E9%80%9A%E8%87%AA%E6%97%8B%E9%94%81%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;在Linux中还提供了一种称为“加锁”的机制来避免竞争条件的出现。之所以引入锁机制是因为在真正的Linux内核编程过程中简单的原子操作时不能满足系统需要的，例如当一个临界区跨越了多个函数的时候，这时原子操作就显得无能为力了。 &emsp;&emsp;首先我们来看自旋锁（spin lock），在前面我们将Linux中提供的锁机制做了一个比喻，我们将临界区比作放在一个房间内的资源，而任何人（线程）如果想使用这些资源则必须首先进入该房间，也就是通过该房间唯一的一道门进入房间后才可以使用这些资源，在这里自旋锁就相当于这个房间的门钥匙，正常情况这把钥匙会挂在门旁边的一个地方，任何人（线程）想进入该房间必须首先拥有这个房间的房门钥匙才可以打开房门进入房间，而之所以称为“自旋锁”也是根据它的实现机制来命名的，该锁规定当一个人（线程）到达房间门口后，发现房门已经锁上，并且钥匙不在门旁边挂着，也就是说明现在房间里有人，那么该人（线程）就会在门外一直等待，直到房间里面的人出来了，该等待的人（线程）就会拿起钥匙，然后进入房间。而对于线程来说，在“门外一直等待”也就是说让线程一直忙循环。 &emsp;&emsp;这样Linux就利用自旋锁机制保证了任意时刻，只有一个执行线程进入临界区，也就避免了竞争条件的出现。 一、普通自旋锁 自旋锁机制让后来的线程一直进行忙循环，这对系统的性能不会有影响吗？其实内核这样做确实会对系统的性能有一些影响，这也就要求用户在实际编程的过程中需要注意，自旋锁不应该被长时间持有，自旋锁适用于短时间内进行轻量级加锁。 自旋锁是绝对不可以递归使用的。这是因为如果一个线程试图去获得一个它已经持有的自旋锁的时候，它首先会进入忙等待，而当该进程进入忙循环状态的时候，它也就是没有机会去释放现在已经持有的自旋锁，也就是说该进程等待的自旋锁永远也不可能获取到，于是该线程就会被自己锁死了。 &emsp;&emsp;总体来说，一个自旋锁是一个互斥实体，只能被一个执行路径拥有，它有且只有两个状态：加锁、解锁。通常由一个整数变量的取值来表示。如果内核代码需要访问和修改一个自旋锁变量保护的资源，该内核代码就需要去获得相应的自旋锁，如果获取成功，则进入临界区，对临界资源进行操作；如果没有成功获得，则内核代码就反复检查这个锁的状态，直到获得这个自旋锁。 &emsp;&emsp;自旋锁变量的数据类型由数据结构spinlock_t表示，该是数据结构定义在include/linx/spinloc_types.h中，结构如下所示： 1234567891011121314typedef struct&#123; raw_spinlock_t raw_lock; #if defined(CONFIG_PREEMPT)&amp;&amp;defined(CONFID_SMP) unsigned int break_lock; #endif #ifdef CONFIG_DEBUG_SPINLOCK unsigned ing magic,owner_cpu; void *owner; #endif #ifdef CONFIG_DEBUG_LOCK_ALLOC struct lockdep_map dep_map; #endif&#125;spinlock_t; raw_Lock：该成员变量是自旋锁数据类型的核心，具体的锁定过程与该成员变量密切相关，该成员变量的类型raw_spinlock_t与内核选项CONFIG_SMP有关。 break_lock：该无符号整型成员变量同时依赖于内核选项CONFIG_PREEMPT和CONFIG_SMP。在同时选中了这两个选项的情况下，该成员变量用于指示当前自旋锁是否被多个内核代码同时竞争、访问。 &emsp;&emsp;内核在include/linux/spin_lock.h中提供了一系列关于自旋锁的操作函数接口，而在spin_lock.h文件所引用的头文件中，有如下代码： 12345#ifdef CONFIG_SMP #include&lt;asm/spinlock.h&gt;#else #include&lt;linux/spinlock_up.h&gt;#endif &emsp;&emsp;从上述代码可以看出，关于自旋锁操作函数接口的具体实现方式和完成的工作依赖于内核选项CONFIG_SMP。关于自旋锁的操作函数如下表所示： 函数原型 描述 spin_lock_init(lock) 声明一个个自旋锁lock，将其初始化成未锁定状态 spin_lockl(lock) 用于获得指定的自旋锁lock，如果锁定成功，直接返回，否则，循环等待直到获得自旋锁 spin_unlock(lock) 释放持有的自旋锁lock spin_can_lock(lock) 判断指定的自旋锁是否可以锁定即是否处于可用状态，如果可以，返回1，否则返回0 spin_is_locked(lock) 检测指定的自旋锁lock是否处于锁定状态，如果是，则返回1，否则返回0 spin_trylock(lock) 试图获得指定的自旋锁lock，如果不成功，立即返回，返回值为0，否则锁定成功，返回1 spin_lock_irq(lock) 获取指定的自旋锁lock，并禁止本地中断 spin_unlock_irq(lock) 释放持有的自旋锁lock，并激活本地中断 spin_lock_irqsave(lock,flags) 保存本地中断的当前状态，禁止本地中断，并获得指定的自旋锁lock spin_unlock_irqrestore(lock,flags) 释放持有的自旋锁lock，并让本地中断恢复到以前的状态 单处理器系统下自旋锁的实现&emsp;从文件spin_lock.h所引用的头文件可以看出，在单处理器系统（也即是在没有定义内核选项CONFIG_SMP的情况下）中，自旋锁操作函数接口的实现定义在include/linux/spinlock_up.h中。 &emsp;&emsp;raw_spinlock_t结构在单处理器系统下退化为一个空的结构体，其定义在include/spin_lock_types_up.h中，代码如下所示： 1typedef struct &#123; &#125; raw_spinlock_t; &emsp;&emsp;自旋锁的加锁函数spin_lock()是一个宏定义，该宏定义在include/linux/spinlock.h中，它不依赖于任何选项，定义如下： 1#define spin_lock(lock) _spin_lock(lock) _spin_lock(lock)在没有定义内核选项CONFIG_SMP时，定义在include/linux/spinlock_api_up.h中，定义如下所示： 123#define _spin_lock(lock) _LOCK(lock)#define _LOCK(lock)\ do&#123;preempt_disable(); _acquire(lock);(void)(lock);&#125;while(0) &emsp;&emsp;其中preempt_disable()函数用于禁止内核抢占，它与preempt_enable()函数配对使用。_acquire(lock)函数与_release(lock)配对使用，用做内核编译过程中静态检查自旋锁的加锁操作与释放操作是否成对匹配。void(lock)不做任何处理，只是为了引用一下变量lock，避免编译器对未使用变量的警告。 &emsp;&emsp;通过对_spin_lock()函数的分析可知，在单处理器系统中，自旋锁的锁定过程并没有真正的加锁操作，只是用来禁止内核抢占。 &emsp;&emsp;自旋锁的释放函数spin_unlock()是一个宏定义，在没有定义内核选项CONFIG_SMP时，该宏定义在include/linux/spinlock.h中，代码如下所示： 1#define spin_unlock(lock) _spin_unlock(lock) _spin_unlock()宏定义在没有内核选项CONFIG_SMP时，定义在include/linux/spinlock.h中，代码如下所示： 123#define _spin_unlock(lock) _UNLOCK(lock)#define _UNLOCK(lock)\ do(preempt_enable(); _release(lock); (void)(lock);&#125; while(0) &emsp;&emsp;该宏定义的具体处理过程与加锁函数_LOCK(lock)宏定义非常相似。 多处理器系统下自旋锁的实现&emsp;&emsp;在定义了内核选项CONFIG_SMP的多处理器系统中，raw_spinlock_t结构定义在include/asm-x86/spinlock_types.h中，定义如下所示： 1234typedef struct &#123; unsigned int slock;&#125;raw_spinlock_t; &emsp;&emsp;从其定义可以看出，raw_spinlock_t数据结构与原子变量数据结构的定义类似，都声明了一个内存佰利联，用于计数工作。当slock的值为1时，表示自旋锁处于非锁定状态；否则，表示处于锁定状态。 &emsp;&emsp;虽然自旋锁的加锁函数spin_lock()和单处理器的加锁函数使用同一宏定义，但是实现该宏定义的实现函数_spin_lock(lock)却不相同。在多处理器系统中，_spin_lock()函数定义在kernel/spinlock.c中，定义如下所示： 123456void _lockfunc _spin_lock(spinlock_t *lock)&#123; preempt_disable(); spin_acquire(&amp;lock-&gt;dep_map,0,0,_RET_IP_); LOCK_CONTENDED(lock,_raw_spin_trylock,_raw_spin_lock);&#125; 第3行函数preempt_disable()表示禁止内核抢占。 第4行函数spin_acquire()在定义内核选项CONFIG_DEGBUG_LOCK_ALLOC的情况下用于获得锁定自旋锁lock时的依赖信息，用于内核调试。如果没有这个内核选项，则该函数是一个空函数，什么也不做。 第5行函数LOCK_CONTENDED()是一个关联函数，定义在include/linux/lockdep.h中，在没有定义内核选项CONFIG_LOCK_STAT的情况下，代码如下所示： 12#define LOCK_CONTENDED(_lock,try,lock)\ lock(_lock) &emsp;&emsp;从该函数定义可知，调用函数LOCK_CONTENDED(lock,_raw_spin_trylock,_raw_spin_lock)与直接调用_raw_spin_lock(lock)函数是等价的，宏定义_raw_spin_lock()完成具体的加锁过程。 _raw_spin_lock(lock)宏定义在include/linux/spinlock.h中，代码如下所示： 1#define _raw_spin_lock(lock) _raw_spin_lock(&amp;(Lock)-&gt;raw_lock) &emsp;&emsp;该宏定义以自选项的计数raw_lock为参数，调用_raw_spin_lock()函数来完成自旋锁的实际加锁过程，_raw_spin_lock()函数的实现与体系结构有关。在x86体系结构下，函数定义在include/asm-x86/spinlock_32.h中，代码如下： 12345678910111213static inline void _raw_spin_lock(raw_spinlock_t *lock)&#123; asm volatile("\n1:\t" LOCK_PREFIX";decb %0\n\t" "jns 3f\n" "2:\t" "rep:nop\n\t" "cmpb $0,%0\n\t" "jle 2b\n\t" "jmp 1b\n" "3:\n\t" :"+m"(lock-&gt;slock)::"memory");&#125; 第3~11行内嵌汇编代码展开后，对应的汇编代码如下所示： 12345671：LOCK_PREFIX;deb %0 jns 3f2：rep;nop cmpb $0,%0 jle 2b jmp 1b 3: 第1行代码首先声明一个名称为1的标号，然后使用汇编指令decb对占位符%0进行减1操作。注意，这里使用了前缀LOCK_PREFIX，用于在SMP系统中保证decb汇编指令操作的原子性。 第2行代码中的汇编指令jns(jump if not sign)判断第1行的操作是否导致了状态寄存器EFLAGS中的SF状态位，如果置位，说明在执行第1行指令时占位符%0对应变量的值小于等于0，即自旋锁已被其他内核代码锁定，此时顺序执行；否则跳转到名称为3的标号处，此时说明已经成功获得了自旋锁。 第3~5行代码首先重新执行空指令nop，然后判断占位符%0的值时候小于等于0.在小于等于0的情况下，说明占位符%0对应的自旋锁处于锁定状态，此时跳回到名称为2的标号处继续顺序执行，否则，说明在上面的循环过程中，占位符%0对应的自旋锁被释放了，此时顺序执行到第6行处的跳转指令。 第6行代码是一个跳转指令，直接跳转到名称为1的标号处，尝试对自旋锁进行新的加锁过程。 在_raw_spin_lock()定义的第12行代码中，“+m”(lock-&gt;slock)表示把raw_spinlock_t数据类型变量lock的成员slock作为内嵌汇编代码的输入输出的内存变量，其对应的占位符为%0。memory表示该内嵌汇编代码会破坏内存，确保内存变量不会被优化、缓存到寄存器，从而使每次访问时，必须到对应的地址中去，避免了因优化导致的程序错误。 &emsp;&emsp;从对_raw_spin_lock()函数代码1的分析可知，该函数实现了在SMP系统中对自旋锁lock的加锁操作。如果加锁成功，则直接返回，否则，进行重复的尝试直到加锁成功。 &emsp;&emsp;自旋锁的加锁函数spin_lock()和单处理器的加锁函数使用同一个宏定义，但是实现该宏定义的实现函数_spin_lock(lock)却不相同。在多处理器系统中，_spin_lock()函数定义在kernel/spinlock.c中，定义如下所示： 123456void _lockfunc _spin_unlock(spinlock_t *lock)&#123; spin_release(&amp;lock-&gt;dep_map,1,_RET_IP_); _raw_spin_unlock(lock); preempt_enable();&#125; 第3行中的函数spin_release()定义在内核选项CONFIG_DEGBUG_LOCK_ALLOC的情况下用于获得释放自旋锁lock时的依赖信息，主要用于内核的调试。如果没有这个内核选项，则该函数时一个空函数，什么也不做。 第4行代码调用_raw_spin_unlock()函数完成自旋锁的释放。 第5行代码调用preempt_enable()函数使内核能被抢占。 _raw_spin_unlock()是一个宏定义，其定义在include/linux/spinlock.h中，代码如下： 1#define _raw_spin_unlock(lock) _raw_spin_unlock(&amp;(lock)-&gt;raw_lock) _raw_spin_unlock()函数完成释放自旋锁的具体工作，该函数的实现与体系结构有关，在x86体系结构下，该函数定义在include/asm-x86/spinlock_32.h中，代码如下所示： 1234static inline void _raw_spin_unlock(raw_spinlock_t *lock)&#123; asm volatile("mov $1,%0":"=m"(lock-&gt;slock)::"memory");&#125; &emsp;&emsp;这段内嵌汇编代码将raw_spinlock_t结构类型的变量lock的成员slock设置为1，表示自旋锁变为可用状态。 &emsp;&emsp;从自旋锁的实现机制分析可知，自旋锁的工作原理如下：当系统是单处理器系统时，自旋锁的加锁、释放过程分别退化为禁止内核抢占、使能内核抢占。在SMP系统中，当锁定一个自旋锁时，需要首先禁止内核抢占，然后尝试锁定自旋锁，在锁定失败时，需要首先禁止内核抢占，然后尝试锁定自旋锁，在锁定失败时执行一个死循环等待自旋锁被释放；当释放一个自旋锁时，首先释放当前自旋锁，然后使能内核抢占。]]></content>
      <categories>
        <category>Linux内核</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
        <tag>Linux内核</tag>
        <tag>自旋锁</tag>
        <tag>普通自旋锁</tag>
        <tag>内核同步</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux内核同步机制分析——原子操作]]></title>
    <url>%2F2019%2Finux%E5%86%85%E6%A0%B8%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6%E5%88%86%E6%9E%90%E2%80%94%E2%80%94%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;原子操作是Linux中提供的一种实现同步的方法。所谓原子操作就是指某一操作在执行过程中是不可以被打断的，它要么全部执行完毕，要么就一点也不执行。原子原本指的是不可分割的微粒，所以原子操作也就是不可分割的指令。也就是说原子操作是绝对不会出现该操作执行了一半，内核又去执行其他操作了的情况。 &emsp;&emsp;内核提供了两组原子操作接口：一组是针对整数的原子操作，另一组是针对单独的位进行操作。在Linux支持的所有体系结构上都实现了两组原子接口。而且大多数体系结构要么原本就支持简单的原子操作，要么就为单步执行提供了锁内存总线的指令（这就确保其他操作不能同时发生）。而有些体系结构本身就不太支持原子操作，比如SPARC，我们则可以通过加锁的方式来实现。 一、原子整数操作&emsp;&emsp;原子整数操作需要硬件的支持，因此它是与体系结构有关的，x86提供给用户的接口和原子类型都定义在include/asm-x86/atomic.h文件中，使用宏来实现。 &emsp;&emsp;原子整数操作主要用于实现资源计数，很多引用计数都是通过原子操作实现的。原子结构类型定义如下： 1typedef struct &#123;int counter;&#125; atomic_t; &emsp;&emsp;原子整数操作，顾名思义，这是一组针对整数进行的操作，但是，该操作有几点需要特别注意的地方 在Linux中的原子整数操作只能对atomic_t类型的数据进行操作，而不能对在C语言中用到的整数类型int进行操作 使用atomic_t的代码只能将该数据当做24位来使用。 &emsp;&emsp;现在来看一下产生这两个特别的地方的原因。 &emsp;&emsp;首先是第一个，为什么Linux中给该操作定义了一个特殊的数据类型，这主要可以有如下几种原因:（1）可以确保原子操作只与这种规定的特殊类型的数据一起使用，这也就保证了该类型的数据不会被传递到其他非原子操作的函数中， （2）使用atomic_t类型确保了编译器不会对定义的该类型的数据进行访问，这也就是保证了原子操作最终接收到一个正确的内存地址而不是一个别名，该别名也保存了相同的值。 （3）重新定义了一个数据类型atomic_t，可以屏蔽到在不同体系结构上实现原子操作的差异。 &emsp;&emsp;其次，是第二个特别的地方的原因，主要是在SPARC体系结构上，原子操作的实现不同于其他体系结构，该体系结构上32位int型的低8位中设置了一个锁，这主要是由于SPARC体系结构对原子操作缺乏指令级的支持，所以只能利用锁来避免对原子类型数据的并发访问。 函数原型 描述 ATOMIC_INIT(i) 用于初始化一个原子变量的值为i，并1返回这个atomic_t结构 atomic_read(v) 返回原子变量v的当前值 atomic_set(&amp;v,1) 设置原子变量v的值为i atomic_add(int i,atomic_t *v) 将原子变量v的值加i atomic_sub(int i,atomic_t*v) 将原子变量v的值减i atomic_sub_and_test(int i.atomic_t *v) 将原子变量v的值减i，并将原子变量运算后结果为0的情况下，返回1，否则返回0 atomic_inc(atomic_t *v) 将原子变量v的值加1 atomic_dec(atomic_t *v) 将原子变量v的值减1 atomic_dec_and_test(atomic_t *v) 将原子变量v的值减1，并将原子运算后结果为0的情况下，返回1，否则返回0 atomic_inc_and_test(atomic_t *v) 将原子变量v的值加1，并将原子变量运算后结果为0的情况下返回1，否则返回0 atomic_add_negative(int i,atomic_t *v) 将原子变量v的值加i，并在原子变量运算结果后结果为负值的情况下返回1，否则返回0 atomic_add_return(int i,atomic_t *v) 将原子变量v的值加i，并返回运算后原子变量的值 atomic_sub_return(int i,atomic_t *v 将原子变量v的值减i，并返回运算后原子变量的值 二、原子位操作&emsp;&emsp;原子位操作，就是针对数据的每一位进行操作，当然它的实现也是与体系结构相关的。其定义在include/x86/bitops_32.h中。 &emsp;&emsp;在这里需要注意的是原子位操作与原子整数操作不同，它不需要定义一个与该操作相对应的数据结构，因为原值位操作只是针对普通的指针进行操作的，我们可以对任何指针指向的数据进行原子位操作。Linux内核1提供了一系列原值位操作的函数。 函数原型 描述 set_bit(int nr,volatile unsigned long *addr) 原子地设置add所指对象的第nr位 clear_bit(int nr,volatile unsigned long *addr) 原子地清空add所指对象的第nr位 change_bit(int nr,volatile unsigned long *addr) 原子地翻转add所指对象的第nr位 test_and_set_bit(int nr ,volatile unsigned long *addr) 原子地设置addr所指对象的第nr位，并返回原来的值 test_and _clear_bit(int nr ,volatile unsigned long * addr) 原子地清空addr所指对象的第nr位，并返回原来的值 test_and _change_bit(int nr ,volatile unsigned long * addr) 原子地翻转addr所指对象的第nr位，并返回原来的值 test_bit(nr,addr) 原子地返回addr所指对象的第nr位 &emsp;&emsp;下面通过说明一个典型的操作函数set_bit(int nr,volatile unsigned long *addr)来分析原子位操作的具体处理过程。该函数以原子方式设置在addr所指对应的第nr位，即保证操作过程不会被打断。代码如下： 1234567static inline void set_bit(int nr,volatile unsigned long *addr)&#123; _asm__volatile_(LOCK_PREFIX "btsl%1,%0 :"+m"(ADDR) :"Ir(nr));&#125; 第4行声明了内嵌汇编所使用的汇编指令btsl，用于设置占位符1%对应操作数的第%1位，然后将结果保存到占位符%0对应的变量；这里的占位符%0、%1分别对应变量addr和nr。 第5行代码声明了内嵌汇编所使用的输出变量列表。这里声明的输出变量为内存地址指针addr，其限定符+m说明该变量是一个读写类型的内存变量，即该变量既是输入变量，也是输出变量。 第6行代码声明了内嵌汇编所使用的输入变量列表。这里声明的输入变量是：代表位移的参数nr，其限定符Ir表示该变量是一个0~31的立即数，且要求编译器将该变量与处理器的某个寄存器相关联。 &emsp;&emsp;在Linux中还定义了一组与这些原子位操作相对应的非原子位操作，这些函数与原子位操作的函数所完成的功能是相同的，只是这些非原子位操作不能保证操作的原子性，其命名就是在原子位操作的函数的前面加上两个喜爱划线，如与set_bit()函数相对应的非原值为操作就是_set_bit()，其余的函数的命名方式与它完成相同。非原子位操作要比原子位操作执行速度快一些，若代码已经避免了竞争条件，那么就可以在代码中使用这些非原子位操作以提高程序的执行速度。]]></content>
      <categories>
        <category>Linux内核</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
        <tag>Linux内核</tag>
        <tag>原子操作</tag>
        <tag>原子整数操作</tag>
        <tag>原子位操作</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux内核同步机制分析——临界区与竞争条件]]></title>
    <url>%2F2019%2Fux%E5%86%85%E6%A0%B8%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6%E5%88%86%E6%9E%90%E2%80%94%E2%80%94%E4%B8%B4%E7%95%8C%E5%8C%BA%E4%B8%8E%E7%AB%9E%E4%BA%89%E6%9D%A1%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;所谓临界区就是访问和操作共享数据的代码段。多个内核任务并发访问同一个资源通常是不安全的。为了避免对临界区进行并发访问，编程者必须保证临界区代码段被原子地执行，也就是说，代码段在执行期间不可被打断，就如同整个临界区是一个不可分割的指令一样。如果两个内核任务可能处于同一临界区，这可能会导致临界资源出现不一致的状态。如果确实发生了这种情况，就称它为竞争状态。 一、临界区举例&emsp;&emsp;为了进一步了解竞争状态，首先要明白临界区无处不在。考虑一个非常简单的、共享资源的例子：一个全局整型变量和一个简单的临界区，其中的操作仅仅是将整型变量的值增加1，即i++，该操作可以转化成下卖弄的机器指令序列。 （1）得到当前变量i的值并将它复制到一个寄存器中 （2）将寄存器中的值加1 （3）把i的新值写回到内存中 这三条指令形成一个临界区。现在假定有两个执行线程同时进入这个临界区，如果i的初始值是1，那么期望的结果应该如下所示： 线程1 线程2 获得i（1） — 增加i（1-&gt;2) — 写回i(2) — 获得i(2) 增加i(2-&gt;3) 写回i(3) 正如期望的那样，i被两个线程分别加1变成3。但是实际的执行序列却可能如下所示： 线程1 线程2 获得i（1） — — 获得i（1） 增加i(1-&gt;2) — — 增加i(1-&gt;2) 写回i(2) — _ 写回i（2） &emsp;&emsp;如果两个执行线程都在变量i值增加前读取它的初值，进而又分别增加变量i的值，最后再保存该值，那么变量i的值就变成了2，而变量i的值本该是3的。这是最简单的临界区例子，幸好对这种简单竞争条件的解决办法也同样简单——我们仅仅需要将这些指令作为一个不可分割的整个来执行就可以了。多数处理器都提供了指令来原子地读变量、增加变量然后再写回变量，使用这样的指令就能解决问题。Linux内核也提供了一组实现这些原子操作的接口。 二、共享队列和加锁&emsp;&emsp;下面讨论一个更为复杂的竞争状态。假定有一个需要处理的请求队列，这里假定该队列是一个链表，链表中的每个节点逻辑上代表一个“请求”。有两个函数可以用来操作此队列，一个函数将新请求添加到队列尾部，另一个函数从队列中删除请求，然后进行处理。内核各部分都会调用这两个函数，所以内核会频繁地在队列中加入请求、从队列中删除请求并对其进行处理。对请求队列的操作无疑要用到多条指令。如果一个线程试图读取队列，而这时另一个线程正在处理该队列，那么读取线程就会发现队列此刻正处于不一致状态。很明显，如果允许并发访问队列，聚会产生意想不到的错误。当共享资源是一个复杂的数据结构时，竞争状态往往会使该结构遭到破坏。 &emsp;&emsp;对于这种情况，锁机制可以避免竞争状态。这种锁就如同一把门锁，门内的房间可想象成一个临界区。在一个指定时刻，房间里只能有一个内核线程存在，当一个内核线程进入房间后，它就会锁住身后的房间；当它结束对共享数据的操作后，就会打开门锁，走出房间。如果另一个线程在房门上锁时到达，那么它必须等待房间内的线程打开门锁出来后，才能进入房间。 &emsp;&emsp;对于前面提到的请求队列，可以使用一个单独的锁进行保护。每当有一个新请求要加入队列，线程会首先占住锁，然后就可以安全地将请求加入到队列中，结束操作后再释放该锁；同样，当一个线程想从请求队列中删除一个请求时，也需要占住锁，然后才能从队列中读取和删除请求，而且在完成操作后必须释放锁。任何要访问队列的其他线程也类似，必须占住锁之后才能进行操作。因为在一个时刻只能有一个线程持有锁，所以在任何一个时刻只有一个线程可以操作队列。由此可见，锁机制可以防止并发执行，并且保护队列不受竞争状态影响。 &emsp;&emsp;任何要访问队列的代码都需要首先占住相应的锁，这样该锁就能阻止来自其他内核线程的并发访问，形式如下所示： 线程1 线程2 试图锁定队列 试图锁定队列 成功，获得锁 失败：等待…… 访问队列…… 等待…… 为队列解除锁 等待…… …… 成功:获得锁 …… 访问队列…… …… 为队列解除锁 &emsp;&emsp;注意锁的使用是自愿的、非强制性的，它完全属于一种编程者自选的编程手段。没有什么1可以强制编程者在操作虚拟队列时必须使用锁。当然，如果不这么做，无疑会造成竞争状态而破坏队列。 &emsp;&emsp;锁有多种形式，而且加锁的粒度范围也各不相同，Linux自身实现了几种不同的锁机制。各种锁机制直接的区别主要在于当锁被持有时的行为表现，一些锁持有时会不断进行循环，等待锁重新可用，而有些锁会使当前任务睡眠，直到锁可用为止。 三、确定保护对象&emsp;&emsp;找出哪些数据需要保护是内核同步实现的关键所在。由于任何可能被并发访问的代码都需要保护，所以寻找哪些代码不需要保护反而更容易些。内核任务的局部数据仅仅被自身访问，显然不需要保护，比如，局部自动变量不需要任何形式的锁，因为它们独立存在于内核线程的栈中。类似，如果数据只会被特定的进程访问，那么也不需要加锁。 &emsp;&emsp;到底什么数据需要加锁呢？答案是大多数内核数据结构都需要加锁。有一条很好的经验可以帮助人们进行判断：如果有其他内核线程可以访问这些数据，那么就给这些数据局加上某种形式的锁；如果有任何其他东西能看到它，那么就要锁定它。 四、并发执行的原因&emsp;&emsp;内核空间之所以需要同步，是因为内核程序会被抢占和重新调度。由于处于内核态的进程可能会在任何时刻被抢占，从而使调度程序完全可能会选择另一个高优先级的进程到处理器执行，所以就有可能在一个进程进入临界区时就被非自愿地抢占了，如果新被调度的进程随后也进入同一个临界区，前后两个进程之间就会产生竞争。这种类型的并发操作并不是同时发生，它们只是相互交叉进行，所以也称为伪并发。 &emsp;&emsp;如果在对称多处理器的机器上，那么两个进程就可以真正地在临界区中同时执行。这种类型被称为真并发。虽然真并发和伪并发的原因和含义不同，但它们都同样会造成竞争状态，而且同样也需要保护。 &emsp;&emsp;那么，内核中造成并发执行的原因有哪些？简单来说有以下几种。 （1）中断：中断几乎可以在任何时刻异步发生，即可能随时打断当前正在执行的代码。 （2）内核抢占：如果内核具有抢占性，那么内核中的任务可能会被另一个任务抢占。 （3）软中断和tasklet：内核能在任何时刻唤醒或调度软中断和tasklet，打断当前正在执行的代码。 （4）睡眠：在内核执行的进程可能会睡眠，这就会唤醒调度程序，从而导致调度一个新的进程执行。 （5）对称多处理器：两个或多个处理器可以同时执行代码。 &emsp;&emsp;对于内核开发者来说，必须理解上述并发执行的原因1，并且事先为它们做好准备工作。如果在一段内核代码访问某资源的时候系统产生了一个中断，而该中断的处理程序居然还要访问这一资源，这就是一个bug；类似地，如果一段代码在访问一个共享资源期间被抢占，这也是一个bug；还有，如果内核代码在临界区里睡眠，那就是毫无原则地等待竞争状态的到来。最后还要注意，两个处理器绝对不能访问同一个共享资源。]]></content>
      <categories>
        <category>Linux内核</category>
      </categories>
      <tags>
        <tag>Linux内核同步</tag>
        <tag>临界区</tag>
        <tag>竞争条件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[92.反转链表II]]></title>
    <url>%2F2019%2F92-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8II%2F</url>
    <content type="text"><![CDATA[一、题目描述反转从位置 m 到 n 的链表。请使用一趟扫描完成反转。 说明:1 ≤ m ≤ n ≤ 链表长度。 示例: 12输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL, m = 2, n = 4输出: 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;NULL 二、分析对于题目要求，画图如下： 在该题中需要实现对指定范围内的链表的反转。m和n代表范围区间。我们可以知道，n-m+1即为需要反转的链表的长度。在一开始，我们需要知道该从什么地方开始反转，m代表链表中的第m个结点。即从第m个结点开始对n-m+1长度的链表进行反转。 对反转步骤分析如下： 步骤一：找到开始逆置的结点，记录该结点以及该结点的前驱。 步骤二：从head开始，逆置change_len=n-m+1个结点 步骤三：将pre_head与new_head连接，modify_list_tail与head连接。 三、实现123456789101112131415161718192021222324252627282930313233343536373839struct ListNode &#123; int val; ListNode* next; ListNode(int x) : val(x), next(NULL) &#123;&#125;&#125;;class Solution &#123;public: ListNode* reverseBetween(ListNode* head, int m, int n) &#123; int change_len = n - m + 1;//需逆序的节点个数 ListNode* pre_head = NULL;//头节点的前一个节点 ListNode* result = head;//返回结果 while (head &amp;&amp; --m) &#123; pre_head = head; head = head-&gt;next; &#125; ListNode* modify_list_tail = head; ListNode* newHead = NULL; while (head &amp;&amp; change_len) &#123; ListNode* next = head-&gt;next; head-&gt;next = newHead; newHead = head; head = next; change_len--; &#125; modify_list_tail-&gt;next = head;//链接逆置的链表尾与逆置段的后一个节点 if (pre_head)//pre_head不为空，说明不是从第一个节点开始逆置的 &#123; pre_head-&gt;next = newHead;//将逆置链表开始的前趋与逆置后的头结点链接 &#125; else &#123; result = newHead;//说明从第一个节点开始逆置，结果即为逆置后的头结点 &#125; return result; &#125;&#125;; 测试函数：123456789101112131415161718192021void test()&#123; ListNode a(1); ListNode b(2); ListNode c(3); ListNode d(4); ListNode e(5); ListNode f(15); a.next = &amp;b; b.next = &amp;c; c.next = &amp;d; d.next = &amp;e; e.next = &amp;f; Solution sol; ListNode* newhead = sol.reverseBetween(&amp;a, 2, 5); while (newhead) &#123; cout &lt;&lt; newhead-&gt;val &lt;&lt; endl; newhead = newhead-&gt;next; &#125;&#125; 执行结果： 三、源码地址​ 反转链表的实现]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>反转链表</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[206.反转链表]]></title>
    <url>%2F2019%2F206-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[一、题目描述反转一个单链表。 示例: 12输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL 二、分析整个链表的反转比较简单，大致的实现思路是依次遍历链表节点，每遍历一个节点便逆置一个节点。 三、实现1234567891011121314151617181920struct ListNode &#123; int val; ListNode* next; ListNode(int x) : val(x), next(NULL) &#123;&#125;&#125;;class Solution &#123;public: ListNode* reverseList(ListNode* head) &#123; ListNode* currHead = NULL; while (head != NULL) &#123; ListNode* next = head-&gt;next; head-&gt;next = currHead; currHead = head; head = next; &#125; return currHead; &#125;&#125;; 测试函数：12345678910111213141516171819void test()&#123; ListNode a(1); ListNode b(2); ListNode c(3); ListNode d(4); ListNode e(5); a.next = &amp;b; b.next = &amp;c; c.next = &amp;d; d.next = &amp;e; Solution solu; ListNode* newHead = solu.reverseList(&amp;a); while (newHead != NULL) &#123; cout &lt;&lt; newHead-&gt;val &lt;&lt; endl; newHead = newHead-&gt;next; &#125;&#125; 执行结果： 四、源码地址​ 反转链表的实现]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>反转链表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[203.移出链表元素]]></title>
    <url>%2F2019%2F203-%E7%A7%BB%E5%87%BA%E9%93%BE%E8%A1%A8%E5%85%83%E7%B4%A0%2F</url>
    <content type="text"><![CDATA[一、题目描述删除链表中等于给定值 val 的所有节点。 示例: 12输入: 1-&gt;2-&gt;6-&gt;3-&gt;4-&gt;5-&gt;6, val = 6输出: 1-&gt;2-&gt;3-&gt;4-&gt;5 二、分析在本题中，需要从链表中将某个指定的元素删除。需要实现的操作也比较简单，只是将某个匹配的结点删除。而在本题中，需要注意的是将删除结点的操作分为三类：一是删除头结点，二是删除中间的任意一个结点，三是删除尾结点。这三类删除操作的实现方法不同。 对于删除头结点的操作来说，只需要将头结点指向头结点的下一个结点即可； 对于删除中间结点的操作来说，与普通的删除操作没有什么差别； 对于删除尾结点的操作来说，我们需要找到尾结点的前一个结点，此时尾节点的前一个结点的下一个结点是尾节点，我们需要做的是让尾节点的前一个结点不再指向尾节点，而是指向NULL； 三、实现123456789101112131415161718192021222324252627282930313233343536struct ListNode &#123; int val; ListNode* next; ListNode(int x) : val(x), next(NULL) &#123;&#125;&#125;;class Solution &#123;public: ListNode* removeElements(ListNode* head, int val) &#123; ListNode* p = head; ListNode* pre_p = head; while(p) &#123; if (p == head &amp;&amp; p-&gt;val == val)//头节点 &#123; head = p-&gt;next; p = head; continue; &#125; else if(p-&gt;val==val)//中间结点 &#123; pre_p-&gt;next = p-&gt;next; p = pre_p-&gt;next; continue; &#125; else if (p-&gt;next == NULL &amp;&amp; p-&gt;val == val)//尾结点 &#123; pre_p = NULL; return head; &#125; pre_p = p; p = p-&gt;next; &#125; return head; &#125;&#125;; 测试函数：12345678910111213141516171819void test()&#123; ListNode head(15); ListNode* p = &amp;head; for (int i = 0; i &lt; 5; i++) &#123; ListNode* a = new ListNode(i); p-&gt;next = a; p = p-&gt;next; &#125; p-&gt;next = NULL; Solution sol; ListNode* newHead = sol.removeElements(&amp;head, 4); while (newHead) &#123; cout &lt;&lt; newHead-&gt;val &lt;&lt; endl; newHead = newHead-&gt;next; &#125;&#125; 执行结果： 四、源码地址​ 移出链表元素的实现]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>移出链表元素</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[gdb调试]]></title>
    <url>%2F2019%2Fgdb%E8%B0%83%E8%AF%95%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[静态库和动态库的制作]]></title>
    <url>%2F2019%2F%E9%9D%99%E6%80%81%E5%BA%93%E5%92%8C%E5%8A%A8%E6%80%81%E5%BA%93%E7%9A%84%E5%88%B6%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[一、静态库和动态库 静态库&emsp;&emsp;静态库是指在我们的应用中，有一些公共代码是需要反复所使用的，就把这些代码编译为“库文件”；在连接步骤中，链接器将从库文件取得所需的代码，复制到生成的可执行文件中。 &emsp;&emsp;程序编译一般需要经过预处理、编译、汇编和链接几个步骤。静态库的特点是可执行文件中包含了库代码的一份完整拷贝。 &emsp;&emsp;优点：只需保证在开发者的计算机有正确的库文件，在以二进制发布时不需考虑在用户的计算机上库文件是否存在及版本问题，可避免DLL地狱等问题。 &emsp;&emsp;缺点：生成的可执行文件体积较大。 动态库&emsp;&emsp;动态库又称动态链接库（Dynamic Link Library,DLL),DLL是一个包含可由多个程序同时使用的代码和数据的库，DLL不是可执行文件。动态链接提供了一种方法，使进程可以调用不属于可执行代码的函数。函数的可执行代码位于一个DLL中，该DLL包含一个或多个已被编译、链接并与它们的进程分开存储的函数。DLL还有助于共享数据和资源。多个应用程序可同时访问内存中单个DLL副本的内容。DLL是一个包含可由多个程序同时使用的代码和数据的库。Windows下动态库为.dll后缀，在Linux下为.so后缀。 静态库和动态库的区别&emsp;&emsp;静态库和动态库两者的不同点在于代码被载入的时刻不同。静态库的代码在编译过程中已经被载入可执行程序，因此体积比较大。动态库（共享库）的代码在可执行程序运行时才载入内存，在编译过程中仅简单地引用，因此体积比较小。 &emsp;&emsp;不同的应用程序如果调用相同的库，那么在内存中只需要有一份该动态库的实例。静态库1和动态库的最大区别，静态情况下，把库直接加载到程序中，而动态链接的时候，它只是保留接口，将动态库与程序代码独立，这样就可以提高代码的可复用度，降低程序的耦合度。 &emsp;&emsp;动态库在程序编译时并不会被链接到目标代码中，而是在程序运行时才被载入，因此在程序运行时还需要动态库的存在。 二、静态库的制作 静态库的文件命名：libxxx.a 制作步骤： 编译为.o文件 将.o文件打包，ar rcs libxxxx.a file1.o file2.o……。其中，libxxxx.a为静态库名，file1.o等文件都是需要打包的文件 使用：编译时需要加静态库名 ，-L用来指明包含的库路径,-l指定库名(通常为libxx.so或者libxxx.a) 首先我们将需要打包的文件编译为.o文件 接下来，将所有需要打包的.o文件打包 接下来，使用刚制作的静态库对main.cpp进行编译。在这之前，将制作的静态库移到/lib目录下。 执行结果如下： 三、动态库的制作 制作步骤： 编译与位置无关的代码，生成.o文件，关键参数-fPIC 将.o文件打包：关键参数-shared 将库与头文件一起发布 我们利用之前的.cpp文件来制作动态库，首先，将之前制作静态库时用到的文件全部删除。删除结果如下： 下面我们编译与位置无关的代码，生成.o文件，结果如下。 下面，我们使用动态库的参数-shared打包.o文件。 接下来，要做的就是使用动态库。这里，我们先将生成的动态库移动到/lib下面。 执行结果如下： 我们可以看到，这里并没有执行成功。它没有像静态库一样直接打开可执行文件就可以运行。 四、解决不能加载动态库的问题对于动态库无法加载的问题，这里有三种解决办法 将动态库拷贝到/lib下，当然这种方式不太好，可能会出现一些问题 将库路径增加到环境变量LD_LIBRARY_PATH中，这种方式也不是特别推荐 配置/etc/ld.so.conf，增加动态库的绝对路径，然后执行sudo ldconfig -v 首先，我们使用 pwd命令查看动态库的路径。 我们在/etc/ld.so.conf文件中添加该动态库的路径 接下来执行sudo ldconfig -v命令，得到下面的结果 在sudo ldconfig -v命令中，-v选项表示显示加载过程。 通过ldd命令，我们可以看到该程序所需要的动态链接库。最后是运行结果。]]></content>
      <categories>
        <category>Linux命令</category>
      </categories>
      <tags>
        <tag>静态库制作</tag>
        <tag>动态库制作</tag>
        <tag>动态库加载</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[gcc编译流程]]></title>
    <url>%2F2019%2Fgcc%E7%BC%96%E8%AF%91%E6%B5%81%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[一、gcc工作流程gcc编译流程如下： gcc -E预处理、头文件展开、宏替换，生成hello.i gcc -S生成汇编代码，生成hello.s gcc -c将汇编文件编译成二进制文件，生成hello.o ld链接，生成可执行文件a.out 二、gcc相关参数 -L用来指明包含的库路径 -l指定库名(通常为libxx.so或者libxxx.a) -g用于gdb调试，不加此选项不能进行gdb调试 -Wall显示更多的警告 -lstdc++编译C++代码 -O优化选项，1—3，数字越大，优先级越高 -D用来指定要执行的宏 -o用来指定编译后文件名 在当前目录下，有如下图所示的.cpp文件。 我们可以使用gcc的相关参数对这些文件进行编译。下图所示为各个.cpp文件的内容。 我们可以看到在每一个.cpp文件中，都有一个头文件，在对这些.cpp文件进行编译时，我们需要知道该头文件的路径。 下面，我们对这些.cpp文件进行编译执行，结果如下图。]]></content>
      <categories>
        <category>Linux命令</category>
      </categories>
      <tags>
        <tag>Ubuntu</tag>
        <tag>gcc</tag>
        <tag>gcc编译</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux添加系统调用]]></title>
    <url>%2F2019%2FLinux%E6%B7%BB%E5%8A%A0%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;在Linux中为系统添加一个系统调用并不是很难的事情，首先需要编写自己的系统调用，然后再把编写好的系统调用注册进内核使它成为一个正式的系统调用即可。系统调用函数可以静态添加，也可以动态添加，静态方式就是把系统掉用那个直接加入到内核中，这需要重新编译内核；动态方式是以模块的方式添加系统调用，这种方式下，不需要重新编译内核。 编写系统调用函数&emsp;&emsp;编写自己的系统调用前，必须首先清楚该系统调用所要实现的功能是什么，在Linux中，尽量不要用一个系统调用来实现多个功能。系统调用接口应该尽量简洁，参数尽量少，当然还要考虑到系统调用的通用性，即系统调用是否可移植等因素。 &emsp;&emsp;内核执行系统调用的时候处于进程上下文中，因此可以睡眠，也可以被抢占，这样系统调用可以使用内核提供的绝大多数函数。系统调用函数的一般形式如下： 1asmlinkage long sys_ xxx(type1 arg1,type2 arg2……） 把系统调用添加到系统调用表中&emsp;&emsp;把编写好的系统调用添加到系统表的最后，对于支持该系统调用的所有硬件体系结构都必须做这样的工作。从0开始算起，系统调用在该表中的位置就是它的系统调用号。每种体系结构下对应的系统调用号不一定相同。 添加系统调用号&emsp;&emsp;对于系统调用所支持的各种体系结构，把由上一步得到的系统调用号添加到文件unistd.h中，并修改总的系统调用个数NR_syscalls的值。 添加系统调用函数&emsp;&emsp;最后把编写好的系统调用函数添加到内核中时，要保证系统必须被编译进内核映像（而不是被编译成模块）。 重新编译内核&emsp;&emsp;编译修改过的Linux内核，再次系统选择启动新内核，这样就可以使用刚才写好的系统调用了。 从用户空间使用系统调用&emsp;&emsp;通常，系统调用靠C库的支持，用户程序通过包含标准头文件并和C库链接，就可以使用系统调用了。但是如果仅仅写出系统调用，glibc库恐怕并提供支持。在2.6.20之后，出于安全的考虑，Linux删除了_syscalln的一组宏，这样就只有使用内核为用户程序提供的另外一个函数syscall。该函数的形式如下： 1syscall(_NR_mysyscall,arg1,arg2……）;]]></content>
      <categories>
        <category>Linux内核</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
        <tag>Linux内核</tag>
        <tag>Linux系统调用</tag>
        <tag>Linux添加系统调用</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux系统调用实现分析]]></title>
    <url>%2F2019%2FLinux%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E5%AE%9E%E7%8E%B0%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[一、C程序库和系统调用&emsp;&emsp;系统调用视为了编程人员提供内核服务的一组函数，而C程序库通过软中断陷入内核，实现内核服务。 &emsp;&emsp;系统调用时系统内核向用户程序提供支持的接口，通过这些接口应用程序向系统内核服务，控制转向系统内核，而系统内核在完成服务之后，将控制和结果返回给用户程序。系统调用是用户程序与系统内核的边界，通过系统调用，进程可由用户模式转入内核模式，在内核模式下完成一定的服务请求后再返回用户模式。系统调用只是提供一个基本功能集，而通过对这些操作的引用和封装，可以形成丰富而且强大的系统调用库。这里体现了Linux的机制与策略相分离的编程思想——系统调用只是提供访问核心的基本机制，而策略是通过系统调用库来实现的。 &emsp;&emsp;在Linux中，系统调用库实体通过C程序来实现的，又称为C程序库。C程序库主要是为编程人员提供应用程序编程接口（API），即为编程人员提供与内核进行交互的一组法术。一般情况下，应用程序使用的这种编程接口实际上并不需要和内核提供的系统调用对应。一个API的功能可以通过一个系统调用来实现，也可以通过多个系统调用来实现，也可以完全不使用系统调用。实际上，API可以在各种操作系统上实现，给应用程序提供完全相同的接口，而它们自身在这些系统同上的实现可能不同。 &emsp;&emsp;从程序员的角度来看，系统调用无关紧要；他们只需要跟C库的API打交道就可以。相反的，内核只跟系统调用打交道；库函数及应用程序怎么使用系统调用并不是内核所关心的。只是内核必须时刻牢记系统调用所有潜在的用途并保证它们有良好的通用性和灵活性。 二、系统调用实现分析&emsp;&emsp;在Linux系统中系统调用时用户空间访问内核的一种方式，系统调用执行大致过程如下： （1）在应用程序中调用用户空间的库函数 （2）库函数在执行一系列预处理后，取得系统调用号，传递相应的参数并执行软中断指令INT产生中断 （3）Linux系统进行地址空间的转换和堆栈的切换，执行SAVE_ALL宏定义，从而保存现场 （4）根据系统调用号从系统调用表找到对应系统调用处理程序的入口地址 （5）执行系统调用对应的处理程序 （6）执行RESTORE_ALL宏定义，恢复系统调用前的任务现场并返回用户模式 不同的平台，系统调用的实现也不同。下面是在x86体系结构中系统调用的实现。 系统调用的初始化&emsp;&emsp;在应用程序调用系统调用时，应该以某种方式从用户态陷入到内核态，在Linux中可以通过软中断（这里的软中断是相对于外部的硬件中断来说的）来实现陷入，在x86平台上，这条指令是init 0x80。也就是说在Linux中，向系统调用的接口是一个中断处理函数的特例。这样，就需要在系统启动时，对系统调用中断进行初始化。 &emsp;&emsp;Linux内核在初始化期间会调用arch/i386/kernel/traps.c文件中的trap_init()函数来设置中断描述符表。在这个函数中，通过调用函数set_system_gate(SYSCALL_VECTOR,&amp;SYSTEM_call)来完成该项的设置。其中的SYSTEMCALL_VECTOR就是0x80，而system_call则是一个汇编子函数，它是中断0x80的处理函数，也是系统调用的入口函数。 与系统调用相关的数据结构（1）系统调用号&emsp;&emsp;在Linux中每个系统调用被赋予一个唯一的编号，这个编号被称为系统调用号。这样通过这个独一无二的号就可以关联到相应的系统调用处理处理程序。系统调用号定义在include/asm/unistd.h中，编号的定义方式如下所示： 12345678910#define _NR_result_syscall 0#define _NR_exit 1#define _NR_fork 2#define _NR_read 3#define _NR_write 4#define _NR_open 5#define _NR_close 6……#define NR_syscalls 325 &emsp;&emsp;其中，NR_syscalls表示系统调用的总数，在检查一个系统调用号是否合法时要用到。 &emsp;&emsp;系统调用号非常关键，当用户空间的进程执行一个系统调用的时候，系统使用系统调用号而不是系统调用的函数名称，来指明到底是要执行那个系统调用。系统调用号一旦分配就不能再有任何变更，否则编译好的应用程序就会崩溃。此外，如果一个系统调用被删除，它所占用的系统调用号也不允许被回收利用，否则，以前编译过的代码在调用这个系统调用时，就会出错。为此，Linux设置了专门的“未实现”系统调用sys_ni_syscall()，它除了返回-ENOSYS外，不做任何其他的事。当系统调用一个被删除的系统调用时，或者无效的系统调用时，这个函数就会被执行。 （2）系统调用表&emsp;&emsp;内核使用系统调用表记录了各个系统调用处理函数的入口地址，以系统同调用号为偏移量能够很容易地在该表中找到对应的处理函数地址。系统调用表存储在sys_call_table中，它与体系结构有关，x86体系结构的系统调用表定义在arch/x86/kernel/syscall_table.S中，其定义方式如下： 123456ENTER(sys_call_table) .long sys_restart_syscall .long sys_exit .long sys_fork .long sys_read …… &emsp;&emsp;当用户空间程序调用一个系统调用时，系统调用号作为参数传递给中断0x80，而该标号实际上就相当于系统调用表的下标，通过该值可以找到相应的系统调用的处理函数。 系统调用入口函数&emsp;&emsp;当用户执行了软中断指令后，系统从用户空间进入内核空间，并在内核空间执行系统调用入口函数。系统调用入口函数由arch/x386/kernel/entry_32.S文件中的system_call汇编代码段定义，其主要功能是对系统调用进行预处理，并调用相应的系统调用服务例程。函数的执行过程如下： （1）首先将系统调用号（eax的值，因为在save_all中保存的eax寄存器会被调用的返回值覆盖）放入栈中 （2）调用save_all保存寄存器上下文 （3）得到进程的thread_info结构指针放到ebp中。检查struct thread_info中的flags标志，看是否有系统管理调用跟踪等，有则跳到syscall_trace_entry （4）检查系统调用号的有效性，若不小于nr_syscalls则报错并返回-ENOOSYS，否则跳转到该系统调用的处理函数入口。这里以eax作为偏移，在系统调用表sys_call_table中查找处理函数入口地址，并跳转到该入口地址 （5）将返回值存放在eax中，调用restore_all恢复寄存器上下文。 系统调用的参数传递&emsp;&emsp;与普通的函数类似，系统调用通常也需要输入/输出参数，这些参数可能是实际的值，也可能是函数的地址及用户态进程地址空间的变量。在系统调用需要传递少量参数的情况下，通常采用处理器中的寄存器完成参数的传递工作。系统调用过程中所需要的参数由寄存器%eax,%ebx,%ecx,%edx,%esi,%edi来传递。 &emsp;&emsp;事实上，系统调用过程中系统调用号就是通过处理器中的寄存器%eax进行传递的，系统调用入口函数system_call()根据保存在该寄存器中的不同系统调用号，调用相应的系统调用处理函数来完成具体的系统调用。 &emsp;&emsp;具体的系统调用处理函数所需参数依次由除了%eax外剩余的5个寄存器%ebx,%ecx,%edx,%esi,%edi来传递。在系统调用处理过程中，这些保存在处理器寄存器中的参数被系统调用入口函数system_call()通过调用save_all()函数压入到内核态栈中。具体的系统调用处理函数从内核态栈中取得相应的参数值，完成具体的处理工作。 &emsp;&emsp;当系统调用需要在用户态和内核态传递大量数据时，处理器中内置的寄存器显然不够使用。通常的做法是，把所传递的参数封装到特定的结构中，此时采用一个指向该结构的指针和该结构的长度值来描述这一参数，再和传递少量数据的情况一样将这两个通过处理器中的参数进行传递。 &emsp;&emsp;由于在内核中，不可以访问用户态地址空间，Linux提供了copy_from_user()和copy_to_user()两个函数，用于用户态空间和内核态空间的数据交换。]]></content>
      <categories>
        <category>Linux内核</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
        <tag>Linux系统调用</tag>
        <tag>C程序库</tag>
        <tag>系统调用</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux调度相关系统调用]]></title>
    <url>%2F2019%2FLinux%E8%B0%83%E5%BA%A6%E7%9B%B8%E5%85%B3%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;Linux内核提供的一些系统调用主要用于管理和维护与进程调度相关的参数值，这些系统调用可以用来获取和设置进程的优先级、进程调度策略，以及进程与处理器的亲和力等。 系统调用 功能简介 nice() 用于设置普通进程的静态优先级，即设置进程的nice值 getprioprity() 返回20减去给定进程组中所有进程之中最低nice字段的值，即获得一组普通进程的最大优先级 setpriority() 把给定组中所有进程的静态优先级都设置为一个给定的值 sched_getaffinity() 获取进程与处理器的亲和力掩码 sched_setaffinity() 设置进程与处理器的亲和力掩码 sched_getscheduler() 获取进程的调度策略 sched_setschedule() 设置一个进程的调度策略和实时优先级 sched_getparam() 获取一个进程的实时优先级 sched_setparam() 设置一个进程的实时优先级 sched_yield() 进程自愿暂时让出CPU sched_get_priority_min() 获取最小的实时静态优先级 sched_get_priority_max() 获取最大的实时静态优先级 sched_rr_get_interval() 获得时间片轮转策略的时间片值 nice()系统调用 &emsp;&emsp;该函数用于设置普通进程的静态优先级，它可以将给定进程的静态优先级增加一个给定的量，这时我们应该注意，这个给定的量有两种情况，第一种是将给定的进程的静态优先级加上一个正值，其实这相当于降低进程的优先级，第二种是将给定的进程的静态优先级加上一个负值，其实这相当于提高进程的优先级。 &emsp;&emsp;在Linux中规定，作为一般原则，总是允许用户降低他们进程的优先级，即给定的那个量是一个正值。然而，如果他们想修改属于某一用户进程的优先级，或者如果他们想增加自己进程的优先级，即给定的量是一个负值，那么，他们必须拥有超级用户的特权。 &emsp;&emsp;nice()函数会调用内核的set_uer_nice()函数，这个函数会设置进程的task_struct中的static_prio和prio的值。 getprioriity()和setpriority()系统调用 &emsp;&emsp;nice()系统调用只影响调用它的进程，而另外两个系统调用getpriority()和setpriority()则作用于给定组中所有进程的基本优先级。getpriority()返回20减去给定组中所有进程之中最低nice字段的值，setpriority()把给定组中所有进程的基本优先级都设置为一个给定的值。 getaffinity()和setaffinity()系统调用 &emsp;&emsp;Linux调度程序提供强制的处理器绑定机制，即它允许用户强制指定某个进程必须在相应的CPU上运行，所谓亲和力掩码就是用于指定该进程可以在哪个CPU上运行的一个标志位，它保存在进程结构体（task_struct)的cpu_allowed这个位掩码标志中。该掩码1的每一位对应于系统中的一个CPU，在默认情况下一个进程的该掩码所有的位都被设置，即默认情况下一个进程可以在系统中所有可用的CPU上运行。 sched_getscheduler()和sched_setscheduler()系统调用 &emsp;&emsp;sched_getscheduler()和sched_setscheduler()分别用于设置和获取进程的调度策略和实时优先级。其主要工作就是读取和设置进程结构体task_struct中的policy和rt_priority域的值。 &emsp;&emsp;sched_getscheduler()函数查询与给定的pid相对应的进程当前所用的调度策略。如果pid为0，将检索调用该函数的进程的调度策略；如果成功，这个系统调用为进程返回策略。 &emsp;&emsp;sched_setscheduler()系统调用既可以设置调度策略，也可以设置与给定的pid相对应的进程的相关参数。如果pid为0，调用该函数的进程的调度程序参数将被设置。 sched_getparam()和sched_setparam()系统调用 &emsp;&emsp;sched_getparam()和sched_setparam()分别用于设置和获取进程的实时优先级。sched_getparam()系统调用可以获取与给定的pid相对应的进程的实时优先级。如果pid为0，current进程的实时优先级将被检索。它首先找到与pid相关的进程描述符指针，把它的rt_priority字段存放在类型为sched_param的局部变量中，并调用copy_to_user()把它复制到进程地址空间中由param参数指定的地址。sched_setparam()系统调用类似于sched_setscheduler()，它与后者的不同在于不让调用者设置policy字段的值。 sched_yield()系统调用 &emsp;&emsp;sched_yield()系统调用提供了一种让进程资源地让出CPU给其他等待执行的进程的方法，这个调用主要由SCHED_FIFO实时进程调用。 &emsp;&emsp;在Linux中对于实时进程和普通进程在调用该函数后的处理有些不同。当调用该函数的进程是一个普通进程时，内核会把该进程移到进程队列中的过期队列中，这样可以保证该进程在一段时间内不会再次被调度。当调用该函数的进程是一个实时进程时，由于实时进程不会过期，所以内核会将调用该函数的进程放到优先级队列的后面，而不是移到过期队列中。 sched_get_priority_min()和sched_get_priority_max()系统调用 &emsp;&emsp;该系统调用主要用于返回给定调度策略的最大和最小优先级。实时调度策略的最大优先级时MAX_USER_RT_PRIO减1，最小优先级是1.当调用该函数时若current是实时进程,sys_sched_get_priority_min()服务例程返回1，否则返回0；sys_sched_get_priority_max()服务例程返回99（最高优先级），否则返回0. sched_rr_get_interval()系统调用 sched_rr_get_interval()系统调用把参数pid表示的实时进程的轮转时间片写入用户态地址空间的一个结构中。如果pid等于0，系统调用就写当前进程的时间片。相应的sys_sched_rr_get_interval()服务例程同样带哦用find_process_by_pid()检索与pid相关的进程描述符。然后，把存放在所选中进程的基本时间片转换为秒数和纳秒数，并把它们复制到用户态的结构中，通常，FIFO实时进程的时间片等于0。]]></content>
      <categories>
        <category>Linux内核</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
        <tag>Linux内核</tag>
        <tag>系统调用</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux内核调度]]></title>
    <url>%2F2019%2Fnux%E5%86%85%E6%A0%B8%E8%B0%83%E5%BA%A6%2F</url>
    <content type="text"><![CDATA[一、schedule()&emsp;&emsp;选定下一个需要调度的进程并切换到该进程上面去执行是通过schedule()函数来实现的。当内核代码想要休眠时，将会直接调用该函数；另外，在系统返回到用户态以及从中断返回时，内核都会调用need_resched()函数检查时候设置了need_resched标志，来决定是否调用schedule()函数。need_resched存放在thread_info结构体中，用一个标志变量中的一位来表示，用于表示当前是否需要重新调度。 &emsp;&emsp;schedule()函数独立于每个处理器运行，每个CPU都有自己的标号id和运行队列，因此每个CPU可以独立地对下一次该运行那个进程做出判断。通过smp_processor_id()可以获取当前的CPU标号，其类型为unsigned int。通过cpu_rq(cpu)可以获取CPU的运行队列。 schedule()函数中的部分代码如下： 12345678need_resched: preempt_disable(); cpu=smp_processor_id(); rq=cpu_rq(cpu); rcu_qsctr_inc(cpu); prev=rq-&gt;curr; switch_count=&amp;prev-&gt;nivcsw; release_kernel_lock(prev); 调用preempt_disable()函数禁止内核抢占，然后获取当前CPU的运行队列。调用release_kernel_lock()函数，如果内核被锁定，该函数释放大内核锁。 1234local_irq_disable();_update_rq_clock(rq);sppin_lock(&amp;rq-&gt;lock);clear_tsk_need_resched(prev); 代码中local_irq_disable()函数用于禁止当前处理器中断，_update_rq_clock()函数用于更新当前运行队列rq的时钟，clear_tsk_need_resched()函数用于清除当前进程的need_resched()标志。 123456789101112if(prev-&gt;state&amp;&amp;!(preempt_count()&amp;&amp;PREEMPT_ACCTIVE))&#123; if(unlikely((prev-&gt;state&amp;TASK_INTERRUPTIBLE)&amp;&amp;unlikely(signal_pending(prev)))) &#123; prev-&gt;state=TASK_RUNNING; &#125; else &#123; deactivate_task(rq,prev,1); &#125; switch_count=&amp;prev-&gt;nvcsw;&#125; if(prev-&gt;state&amp;&amp;!(preempt_count()&amp;&amp;PREEMPT_ACCTIVE)),表示判断当前进程的状态是否为TASK_RUNNING状态，并且当前的内核是否为非抢占式。 12345678if(unlikely((prev-&gt;state&amp;TASK_INTERRUPTIBLE)&amp;&amp;unlikely(signal_pending(prev)))) &#123; prev-&gt;state=TASK_RUNNING; &#125; else &#123; deactivate_task(rq,prev,1); &#125; 其中，以上代码查看当前进程的状态是否为可中断睡眠状态TASK_INTERRUPTIBLE，并且等待的信号已经发生。如果是，则将当前进程的状态重新设置为可执行状态TASK_RUNNING，否则将当前进程从运行队列中删除。 1234if(unlikely(!rq-&gt;nr_running))&#123; idle_balance(cpu,rq);&#125; 以上代码检查当前CPU的运行队列是否有可执行的进程，如果没有可执行的进程且定义了SMP，调用idle_balance()函数进行负载平衡。 1prev-&gt;sched_class-&gt;put_prev_task(rq,prev); 以上代码调用当前进程调度类的put_prev_task()函数，根据进程的状态将其放入到相应的队列中。 1next=pick_next_task(rq,prev); 以上代码调用pick_next_task()函数从当前CPU的运行队列中选取下一个需要执行的任务。pick_next_task()函数在选择下一个需要调度的进程时，充分体现了模块化调度的好处。它首先检查是否有实时进程，如果没有，就调用CFS调度类的pick_next_task()函数选择下一个需要调度的进程；如果存在实时进程，则调用实时进程调度类的pick_next_task()函数。 1234567891011if(likely(prev!=next))&#123; rq-&gt;nr_switchs++; rq-&gt;curr=next; ++*switch_count; context_switch(rq,prev,next);&#125;else&#123; spin_unlock_irq(&amp;rq-&gt;lock);&#125; 以上代码检查下一个需要调度的进程和当前进程是否为同一个进程。如果不是，则调用context_switch()函数进行上下文切换。context_switch()函数负责上下文的切换，即从一个进程切换到另一个可执行的进程。它主要完成以下两个工作： 虚拟内存映射的切换：负责把虚拟内存从被切换下来的进程映射到新进程中，该功能是由函数switch_mm()来实现的。 进程的寄存器状态的切换：负责从一个进程的处理器状态切换到新进程的处理器状态，该功能是由函数switch_to()来实现的。 二、内核抢占&emsp;&emsp;为了提高系统的响应能力、实时能力以及用户的满意度，在Linux2.6内核中引入了抢占机制；即只要重新调度是安全的，那么内核就可以在任何时间抢占正在执行的任务。内核抢占与用户抢占一样，包含显式内核抢占和隐式内核抢占。 （1）显式内核抢占：这种抢占很简单，它发生在内核代码调用schedule()函数时的内核空间中，内核代码可以用两种方式调用schedule()函数，即主动调用schedule()函数让出CPU控制权或内核代码被阻塞时调用schedule()函数。显式内核抢占从来都是受支持的，因为它无需额外的逻辑来保证内核可以安全地被抢占，如果内核代码调用schedule()，那么它应该很清楚自己是可以被安全地抢占的。 （2）隐式内核抢占：这是Linux2.6新增的功能，当一个内核任务拥有对CPU控制权时，只要当前进程没有持有任何锁（即重新调度是安全的），这个内核任务就可以被另一个更高优先级的内核任务抢占。为了支持隐式内核抢占，在每个进程的thread_info结构中引入了preempt_count计数器，该计数器的初始值为0，每当使用锁的时候数值增加1，释放锁的时候数值减1。当数值为0时，内核就可以执行抢占。从中断返回内核空间的时候，内核会检查need_resched和preempt_count的值，如果need_resched被设置，并且preempt_count为0的话，这说明有一个更为重要的任务需要执行且可以安全地被抢占，此时，调度程序就会被调用。如果preempt_count不为0，说明当前的任务持有锁，不能被抢占，这时就会直接从中断返回到当前执行的任务中。如果当前的任务持有的锁被释放，preempt_count等于0，释放锁的代码就会检查need_resched时候被设置，如果是，就会调用调度程序。与内核相关的几个函数如下： preempt_enable_no_resched()函数激活内核抢占，该函数会调用dec_preempt_count()函数，使preempt_count的值减1。 preempt_disable()函数禁止内核抢占，该函数会调用inc_preempt_count(),使preempt_count的值加1。 preempt_enable()函数激活内核抢占且检查是否需要内核抢占，该函数会调用preempt_enable_no_resched()函数，同时会调用preempt_check_resched()判断当前进程是否被标记为重新调度，如果是，它调用preempt_schedule()函数进行内核抢占。 根据以上描述，可知内核抢占的时机是： 从中断处理程序返回内核空间时 内核代码再一次具有可抢占性的时候 内核中显式地调用schedule() 内核的任务阻塞]]></content>
      <categories>
        <category>Linux内核</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
        <tag>Linux内核调度</tag>
        <tag>内核抢占</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux进程调度——实时调度算法]]></title>
    <url>%2F2019%2FLinux%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6%E2%80%94%E2%80%94%E5%AE%9E%E6%97%B6%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[一、实时调度策略&emsp;&emsp;在Linux中，实时优先级范围从0到MAX_RT_PRIO-1，默认情况下，MAX_RT_PRIO为100，所以默认情况的实时优先级从0到99。任何实时进程都比普通进程先得到调度，Linux提供了两种调度策略：SCHED_FIFO和SCHED_RR。 &emsp;&emsp;SCHED_FIFO实现了一种非常简单的、先进先出的调度算法。适用于对相应时间要求比较高，运行所需时间比较短的实时进程。采用该策略时，各实时进程按其进入可运行队列的顺序依次获得CPU。除了因等待某一时间主动放弃CPU，或者出现优先级更高的进程而剥夺CPU之外，该进程将一直占用CPU，直到进程运行结束。 &emsp;&emsp;SCHED_RR与SCHED_FIFO大致相同，是带有时间片的SCHED_FIFO。适用于对响应时间要求比较高，运行所需时间比较长的实时进程。采用该策略时，各实时进程按时间片轮流使用CPU。当一个运行进程的时间片用完之后，重置其时间片，进程调度程序停止其运行并将其置于可运行队列的末尾。 &emsp;&emsp;Linux实时调度策略提供的实时调度是软实时调度。软实时的含义是：内核调度进程尽力使进程在它优先的限定时间到来前运行，但内核并不保证总能满足这些进程的要求。相反，硬实时系统保证在一定条件下，可以满足任何调度的要求。Linux对于实时任务的调度不做任何保证，虽然不能保证硬实时工作方式，但是Linux的实时调度算法经过简单的修改可以满足硬实时的要求。 &emsp;&emsp;实时任务存放在实时运行队列中。由结构rt-rq表示。 123456struct rt-rq&#123; struct rt_prio_array active;/*实时任务的优先级数组*/ int rt_load_balance_idx;/*需要进行负载平衡的实时队列的下标*/ struct list_head *rt_load_balance_head *rt_load_balance_curr;/*需要进行负载平衡队列的链表头节点，需要负载平衡的下一个任务*/&#125;; &emsp;&emsp;在实时运行队列rt_rq中有一个实时优先队列数组，定义在kernel/sched.c中，由结构rt_prio_array表示。实时优先级数组使处理器中实时进程的每个优先级包含一个相应的队列，而这些队列包含了对应优先级上的可运行实时任务链表。优先级数组还有一个优先级位图，当需要查找当前系统内拥有最高优先级的可执行进程时，它可以帮助提高效率，rt_prio_array定义如下： 12345struct re_prio_array&#123; DECLARE_BITMAP(bitmap,MAX_RT_PRIO+1);/*优先级位图*/ struct list_head queue[MAX_RT_PRIO];/*优先级队列*/&#125;; &emsp;&emsp;优先级位图的实际类型为unsigned long长整型数组，数组的大小通过BITS_TO_LONGS(bits)来确定，默认的MAX_RT_PRIO值为100，因此需要使用5个长整型的数来表示。长整型数组中的每一位代表一个优先级。一开始，所有的位都被设置为0，当某个任务的状态变为可执行状态时，位图中相应的优先级位被设置为1. &emsp;&emsp;比如一个优先级为2的实时任务变为可执行状态时，第2位就被置为1.这样，查找系统中最高的优先级就成了查找位图中第一个被设置的位。因为优先级格式是一个定值，所以查找时间恒定。此外，Linux对它支持的每个体系结构上都提供了对应的快速查找函数sched_find_first_bit()，以保证对位图的快速查找。 &emsp;&emsp;每个优先级数组还包含了一个叫做struct list_head的队列，每个队列上都包含对应处理器上相应优先级的全部可运行任务。 二、实时调度的具体实现&emsp;&emsp;实时调度类定义在sched_rt.c中，下面对实时调度类对应的每个函数进行简要的说明。 enqueue_task_rt() 把实时进程插入到相应的运行队列尾部，并设置对应的优先级位图。 dequeue_task_rt() 记录实时任务的运行时间，把进程从相应的优先级队列中删除，检查相对应的优先级队列是否为空，如果为空，清除相应的优先级位图。 yidld_task_rt() 把实时进程从相应的优先级队列的头部插入到尾部。 check_preempt_curr_rt() 函数原型如下： static void check_preempt_curr_rt(struct rq*rq,struct task_struct *p) 检查任务p的优先级是否大于当前运行队列中的优先级，如果是，调用resched_task()函数，设置当前进程需要被调度的标志。 pick_next_task_rt() 从优先级数组中选取一个优先级最高的进程。 put_prev_task_rt() 更新当前任务的运行时间信息。 set_curr_task_rt() 重新计算实时进程运行的开始时间。 task_tick_rt() 当时间节拍函数被调用时，函数执行流程如下： 首先更新当前进程的运行时间信息，然后再查看该进程是否是时间片轮转的实时进程，如果是，对实时进程的时间片time_slice减1，如果time_slice等于0，则设置进程的time_slice为默认时间片（100*Hz/1000),并把当前进程加入到所对应的优先级队列的尾部。]]></content>
      <categories>
        <category>Linux内核</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
        <tag>Linux进程调度</tag>
        <tag>实时调度策略</tag>
        <tag>实时调度算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux进程调度——CFS调度算法]]></title>
    <url>%2F2019%2FLinux%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6%E2%80%94%E2%80%94CFS%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[一、进程优先级和虚拟运行时间&emsp;&emsp;对于普通的进程，CFS保留了系统的静态优先级nice值。其范围从-20到19，默认值为0，nice值越大，优先级越低。但是CFS不再使用动态优先级的概念，而是对每个进程进行加权，权值越大的进程获得CPU时间相对较多。nice值与权值之间存在着对应关系，nice每增加1，其对应权值就会降低25%；nice值每减小1，其对应的权值就会增大25%；nice值为0，对应的权值为1024.nice值和权值可以通过prio_to_weight数组进行转换。 &emsp;&emsp;CFS中每个任务的权值由load_weight结构来存储。 1234struct load_weight&#123; unsigned long weight,inv_weight;&#125;; &emsp;&emsp;其中，weight是任务的权值，inv_weight表示权值的倒置，在根据权值计算进程的虚拟运行时间时，需要使用该值。 &emsp;&emsp;vruntime(单位：纳秒)记录每个任务已经获得的CPU时间。理想的状态下，在任何时刻，系统中所有任务都应该得到相同额vruntime。但是由于同一时刻，系统中只能有一个任务（在单CPU的机器上）可以执行，因此每个任务的vruntime并不相同。vruntime是CFS选择下一个需要运行的任务的依据，是红黑树中每个实体的键值，系统从红黑树中选择vruntime最小值的节点（最左边的节点）作为下一个可运行的实体。 &emsp;&emsp;一个任务的vruntime的值与其权值weight有关，当一个新的任务产生时，vruntime可简单地通过下面的公司计算获得： vruntime=sysctl_sched_latecy *NICE_TO_LOAD/weight &emsp;&emsp;其中sysctl_sched_latecy是任务的一次可执行时间，默认为20ms；NICE_TO_LOAD是nice值为0的权值，即1024；weight为任务的权值。 &emsp;&emsp;任务在运行时，权值不同的任务执行相同的时间，其对应的vruntime的增量是不同的，vruntime的增量delta_vruntime可以使用下面的公式来计算。 delta_vruntime=exec_time*NICE_TO_LOAD/weight 通过给每个任务赋予一定的权值，我们就可以区别每个任务的重要性，权值越高的任务越重要，其vruntime增长得越慢，得到的执行时间就会越多。 二、CFS调度算法的实现我们根据CFS调度类fair_sched_class所对应的每个函数进行简要的说明。 enqueue_task_fair()： 该函数首先获取任务的调度实体，检查该调度实体是否已经在运行队列上，如果是，函数退出；否则计算调度实体的vruntime，并把调度实体加入到相应的运行队列中，运行队列的nr_running加1。如果定义了组调度，则要查看对应的父调度实体是否在相应的运行队列上，如果不是，则更新调度实体的vruntime，并加入到相应的运行队列，运行队列的nr_running加1。重复以上过程，直到到达最上层的调度实体。 dequeue_task_fair() 当任务执行完毕，或者阻塞的时候，调用该函数，把相应的调度实体从CFS的运行队列中删除。该函数首先获取任务的调度实体，把它从相应的运行队列中删除，运行队列的nr_running减1；如果定义了组调度，则检查调度实体对应的运行队列是否为空，如果是，把父调度实体从相应的运行队列中删除，重复以上过程。 yield_task_fair() 这个函数的实现很简单，只是把当前正在运行的任务调度实体的vruntime设置为运行队列最左边调度实体（vruntime最小的调度实体）的vruntime加1.当我们希望当前任务让出CPU时，首先调用该函数，更新当前运行的调度实体的vruntime，然后调用put_prev_task()把当前的调度实体加入到队列中。 put_prev_task_fair() 把当前任务的调度实体放入相应的运行队列中。如果定义了组调度，把父调度实体也放入相应的运行队列，重复此过程，直到到达最上层的调度实体。 check_preempt_wakeup() 函数原型为：static void check_preempt_wakeup(struct rq* rq,struct task_struct *p)。该函数检查刚创建的任务或者从阻塞状态转为可执行的任务p，是否应该抢占当前正在运行的任务。即查看当前调度实体的vruntime加上环形粒度（wakeup_granularity)是否大于任务p的调度实体的vruntime。如果是，调用resched_task()函数，设置当前进程需要被调度的标志。 pick_next_task_fair() 从运行队列中找出下一个需要调度的调度实体（红黑树最左边的节点），并返回该调度实体对应的任务。如果定义了组调度，查看该调度实体是否有自己的运行队列，如果有，从其运行队列中找出下一个调度实体，重复此过程，直到最底层的调度实体，当调度实体不存在自己的运行队列时，该调度实体只包含一个任务。 set_curr_task_fair() 函数原型为：static void set_curr_task_fair(struct rq*rq)。该函数把CPU的运行队列rq的当前任务p，设置成任务p的调度实体所对应的CFS运行队列的当前任务。如果定义了组调度，重复此过程，直到到达最上层的调度实体。 task_tick_fair() 时间节拍函数，检查当前的调度实体的运行时间是否大于其一次应该具有的运行时间，如果是，调用resched_task()函数，设置当前进程需要被调度的标志。如果定义了组调度，重复此过程，直到到达最上层的调度实体。 task_new_fair() 计算新任务调度实体的vruntime，并把任务实体放入到对应的运行队列中，调用resched_task()函数，设置当前进程需要被调度的标志。如果我们指定子进程先运行，则检查新任务调度实体的vruntime是否小于当前正在运行的调度实体的vruntime，如果不是，交换这两个调度实体vruntime，使新任务调度实体的vruntime最小。 &emsp;&emsp;在CFS调度算法的实现中，引入了重要的sysctl()函数来在运行时对调度程序进行调优，时间都是以纳秒为单位。 (1)sysctl_sched_latecy 抢占潜伏时间，一个任务一次可运行的最长时间。这个值与时间片长度不一样，它表示一个时间长度的变量，默认为20ms。针对CPU密集型任务进行目标抢占延迟。 (2)sysctl_sched_min_granularity 最小抢占粒度，默认为4ms。针对CPU密集型任务执行最低级别抢占粒度。 (3)sysctl_nr_latecy 在一个抢占潜伏期内可调度的次数。其值等于sysctl_sched_latecy/sysctl_sched_min_granlarity (4)sysctl_sched_child_runs_first 在创建新进程时，子进程是否先运行，设置为1，表示子进程向运行，设置为0，表示父进程先运行。 (5)sysctl_sched_batch_wakeup_granularity 针对SCHED_BATCH的唤醒粒度，默认为10ms (6)sysctl_sched_wakeup_granularity 针对SCHED_OTHER的唤醒粒度，默认为10ms。]]></content>
      <categories>
        <category>Linux内核</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
        <tag>Linux进程调度</tag>
        <tag>CFS调度算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux进程调度——模块化调度和组调度]]></title>
    <url>%2F2019%2Finux%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6%E2%80%94%E2%80%94%E6%A8%A1%E5%9D%97%E5%8C%96%E8%B0%83%E5%BA%A6%E5%92%8C%E7%BB%84%E8%B0%83%E5%BA%A6%2F</url>
    <content type="text"><![CDATA[一、模块化调度&emsp;&emsp;CFS提供了模块化调度，使得各种不同的调度算法都可以作为一个模块注册到该管理器中。不同的进程可以选择不同的调度模块。为了实现模块化调度，引入了称为“调度类”的概念。 &emsp;&emsp;调度类类似于一个模块链，封装了关于调度算法的信息，协助内核调度程序工作，每个调度算法模块需要实现由调度类建议的一组函数。CFS实现了两个调度算法模块，CFS算法模块(sched_fair.c)和实时调度模块(sched_re.c)。对应实时进程，将使用实时调度模块，对应普通进程则使用CFS算法。 12345678910111213141516171819202122struct sched_class&#123; const struct sched_class *next;/*指向下一个调度类*/ void(*enqueue_task)(struct rq *rq,struct task_struct *p,int wakeup); void(*dequeue_task)(struct rq *rq,struct task_struct *p,int sleep); void(*yield_task)(struct rq *rq); void(*check_preempt_curr)(struct rq *rq,struct task_struct *p); struct task_struct *(*pick_next_task)(struct rq *rq); void(*put_prev_task)(struct rq *rq,struct task_struct *p);#ifdef CONFIG_SMP unsigned long(*load_balance)(struct rq *this_rq,int this_cpu, struct rq *busiest,unsigned long max_load_move, struct sched_domain *sd,enum cpu_idle_type idle, int *all_pinned,int *this_best_prio); int(*move_one_task)(struct rq * this_rq,int this_cpu, struct rq *busiest,struct sched_domain *sd, enum cpu_idle_type idle);#endif void(*set_curr_task)(struct rq *rq); void(*task_tick)(struct rq *rq,struct task_struct *p); void(*task_new)(struct rq *rq,struct task_struct *p);&#125;; enqueue_task:当某个任务进入可运行状态时，该函数将得到调用。它将调度实体（进程）放入相应的运行队列中，并对运行队列成员变量nr_running加1 dequeue_task：当某个任务退出运行状态时调用该函数，它将从相应的运行队列中去掉对应的调度实体，并从nr_running变量中减1 yield_task：在compat_yield_syscttl选项关闭的情况下，该函数实际上执行先出队后入队，这样就将相应的调度实体放在运行队列的最后。（如果是CFS运行队列，则将调度实体放在红黑树的最右端） check_preempt_curr：该函数将检查当前运行的任务是否被抢占。在实际抢占正在运行的任务之前，CFS调度程序模块将执行公平性测试。这将驱动唤醒（wakeup）抢占。 pick_next_task：该函数选择接下来要运行的最合适的进程。 put_prev_task：当一个进程不再运行时，调用该函数通知相应的调度模块。 load_balance：每个调度程序模块实现两个函数，load_balance_start()和load_balance_next()，使用者两个函数实现一个迭代器，在调度模块的load_balance例程中调用。内核调度程序使用这种方法实现由调度模块管理的进程的负载平衡。 set_curr_task：当任务修改其调度类或修改其任务组时，将调用这个函数。 task_tick：该函数通常为时间节拍函数；它可能引起进程切换。这将驱动运行时（running）抢占。 task_new：内核调度程序为调度模块提供了管理新任务启动的机会。CFS调度模块使用它进行组调度，而用于实时任务的调度模块不会使用这个函数。 二、组调度&emsp;&emsp;通常情况下，调度器都是针对单个任务进行调度，为每个任务提供公平的CPU时间。但是在有些时候，我们需要为任务组提供公平的CPU时间考虑一个两用户的例子：用户A和用户B在一台机器上运行任务。用户A只有两个任务正在运行，而用户B正在运行48个任务。组调度使CFS能够对用户A和用户B进行公平调度，而不是对系统运行50个任务进行公平调度。每个用户拥有50%的CPU使用。用户B使用自己50%的CPU分配他的48个任务，而不会占用属于用户A的另外50%的CPU分配。 &emsp;&emsp;为了实现组调度，引入了一个称为“调度实体”的概念，用以指代被调度的对象，这个对象不一定是一个进程。调度实体保持了每个实体的调度信息，并将它们封装在sched_entity结构中，但它并没有改变CFS调度的工作方式。 &emsp;&emsp;调度实体是一个层次结构，每个调度实体代表一组进程，每个调度实体内部有一个自己的运行队列my_q。当我们定义了组调度时，调度实体内还存在一个指向上一层的实体parent指针和一个该实体所在的运行队列cfs_rq。缺省地，调度实体中只存在一个进程，且都在顶级层次结构中。 &emsp;&emsp;但当调度器选择下一个要运行的任务的时候，它首先检查所有顶级调度实体，取出最应获取CPU的实体，如果这个实体是一个高层调度实体，那么调度器就会检查调度实体中运行队列，并重复这一过程，直到达到层次结构的最底层，找到一个可执行的进程。在进程运行过程中，同样会收集一些运行时信息，这些信息同时会向上层调度实体传播，从而在每个级别上都正确度量其占用CPU的时间。 12345678910111213141516struct sched_entity&#123; struct load_weight load; struct rb_node run_node;/*调度实体上的运行节点*/ unsigned int on_rq;/*该调度实体上是否在运行队列上*/ u64 exec_strart;/*任务开始运行的时间*/ u64 sum_exec_runtime;/*任务总的运行时间*/ u64 vruntime;/*应当占用CPU的时间*/ u64 prev_sum_exec_runtime;/*任务最近一次执行前的sum_exec_runtime*/ #ifdef CONFIG_FAIR_GROUP_SCHED struct sched_entity *parent;/*指向该调度实体的父节点*/ struct cfs_rq *cfs_rq;/*调度实体所在的CFS运行队列*/ struct cfs_rq *my_q;/*调度实体所拥有的CFS运行队列*/#endif&#125;; &emsp;&emsp;从调度实体可以看出，当我们定义了CONFIG_FAIR_GROUP_SCHED时，就开启了组调度。到目前为止，有两种策略对任务进行分组。 （1）基于用户id的分组策略（CONFIG_FAIR_GROUP_SCHED) 在这种分组策略中，根据任务所属的用户，对任务进行分组。 （2）基于cgroup的伪文件系统（CONFIG_FAIR_CGROUP_SCHED) 在这种分组策略中，管理员可以使用cgroup伪文件系统任意地创建任务组。调度器只能采用这两种策略中的一个，不能全部采用。Linux内核使用task group结构描述与任务组相关的信息。 1234567891011struct task_group&#123;#ifdef CONFIG_FAIR_CGROUP_SCHED struct cgroup_subsys_state css;#endif struct sched_entity **se;/*任务组在每个CPU上所包含的调度实体*/ struct cfs_rq **cfs_rq;/*任务组在每个CPU上所用的运行队列*/ unsigned long shares; spinlock_t lock; struct rcu)head rcu;&#125;;]]></content>
      <categories>
        <category>Linux内核</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
        <tag>Linux内核</tag>
        <tag>进程调度</tag>
        <tag>模块化调度</tag>
        <tag>组调度</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux进程调度——内核调度概述]]></title>
    <url>%2F2019%2FLinux%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6%E2%80%94%E2%80%94%E5%86%85%E6%A0%B8%E8%B0%83%E5%BA%A6%E6%A6%82%E8%BF%B0%2F</url>
    <content type="text"><![CDATA[一、调度原理&emsp;&emsp;调度程序是内核的组成部分，它负责选择下一个要运行的进程。进程调度器可以看做是为处于就绪态的所有进程分配有限的处理器时间资源的内核子系统。在多任务的操作系统中，进程调度是一个全局性的关键的问题，它对系统的总体设计、系统的实现、功能设置以及各方面的性能都有着决定性的影响，是多任务操作系统的基础，只有通过调度程序的合理调度，系统资源才能最大限度地发挥作用，多任务才会有并发执行的效果。 &emsp;&emsp;调度程序的主要目标是：最大限度地利用处理器时间，同时要保证进程之间的公平性，使系统中的所有进程都有机会执行。为了满足这些目标，在设计进程调度程序时，应该考虑以下三个方面： 调度时机：什么时候，什么情况下进行程序调度 调度策略：使用什么样的策略来选择下一个进入运行的进程 调度的方式：是抢占式还是非抢占式。当由调度程序来决定什么时候停止一个进程的执行，以便让其他程序能够得到执行机会时，这种强制挂起进程的动作称为抢占式。 &emsp;进程调度器的设计，对系统的复杂性有着极大的影响，常常会由于调度器实现过于复杂而需要在功能与性能方面做出必要的权衡和让步。一个好的操作系统调度算法要兼顾三种不同应用的需要。 交互式进程:在这种应用中，着重于系统的响应速度，使共用一个系统的各个用户都能感觉到自己是在独占地使用一个系统。特别是，当系统中有大量进程共存时，需要能保证每个交互式进程都有可接受的响应速度而使每个用户感觉不到明显的延时。 批处理进程：批处理进程往往是作为“后台作业”运行的，所以对响应速度并无要求，但是完成一个作业所要的时间仍是一个重要的因素，主要考虑“平均速度”。 实时进程：这是时间性最强的一类进程，不但要考虑进程执行的平均速度，还要考虑“即时速度”；不但要考虑响应速度，还要考虑有关程序能否在规定时间内执行完毕。 二、Linux调度器的发展 Linux2.4内核的调度器&emsp;&emsp;Linux2.4中使用的调度器采用基于优先级的设计。该调度器的pick_next算法非常简单：对运行队列runqueue中所有进程优先级依次进行比较，选择最高优先级的进程作为下一个被调度的进程。 &emsp;&emsp;每个进程被创建时都被赋予一个时间片。时钟中断则递减当前运行进程的时间片，当进程的时间片被用完时，它必须等待重新赋予时间片才能有机会运行。Linux2.4调度器保证只有当所有处于RUNNING状态的进程的时间片都被用完之后，才对所有进程重新分配时间片。这种设计保证了每个进程都有机会得到执行。 &emsp;&emsp;对于实时进程，调度器将实时进程的优先级静态设定，而且始终大于普通进程的优先级。因此只有当runqueue队列中没有实时进程存在的情况下，普通进程才能够得到调度，获得处理器时间。在Linux内核，实时进程采用两种调度策略：SCHED_FIFO和SCHED_RR。FIFO调度采用先进先出的策略，对于所有相同优先级的进程，最先进入runqueue队列的进程总能优先获得调度；SCHED_RR调度采用更加公平的轮转策略，使得相同优先级的实时进程能够轮流得到执行。 &emsp;&emsp;对于普通进程，调度器倾向于提高交互式进程的优先级，因为它们需要快速地用户响应。普通进程的优先级主要由进程描述符中的counter字段决定。进程被创建时子进程的counter值为父进程counter值的一半，这样保证了任何进程不能依靠不断的调用fork()函数创建子进程从而获得更多的执行机会。Linux2.4调度器在提高交互式进程的优先级时，做了如下工作：当所有RUNNING状态进程的时间片被用完之后，将重新计算所有进程的counter值，所有进程不仅包括RUNNING进程，也包括处于睡眠状态的进程。处于睡眠状态的进程的counter本来就没有用完，在重新计算时，它们的counter值会加上这些原来未用完的部分，从而提高了它们的优先级。交互式进程经常因为等待用户输入而处于睡眠状态，当它们重新被唤醒并进入runqueue队列时，就会优于其他进程而获得CPU。从用户的角度来看，交互式进程的响应速度就提高了。 &emsp;&emsp;这种调度的主要不足在于： （1）可扩展性不好：调度器选择进程时需要遍历整个runqueue队列，从中选出最佳调度进程，因此该算法的执行时间与进程数成正比。另外每次重新计算counter所花费的时间也会随着系统中进程数的增加而线性增长，当进程数很大时，更新counter操作的代价会非常高，导致系统整体的性能下降。 （2）高负载系统上的调度性能比较低：Linux2.4的调度器预分配给每个进程的时间片比较大，因此在高负载的服务器上，该调度器的效率比较低，因为平均每个进程的等待时间与该时间片的大小成正比。 （3）交互式进程的优化并不完善：Linux2.4识别交互式进程的原理基于如下假设：即交互式进程比批处理进程更频繁地处于阻塞状态。然而现实情况往往并非如此，有些批处理进程虽然没有用户交互，但是也会频繁地进行I/O操作，比如一个数据库引擎在处理查询时会经常地进行磁盘I/O，虽然它们并不需要快速的用户响应，还是被提高了优先级。当系统中这类进程的负载较重时，会影响真正的交互式进程的响应时间。 （4）对实时进程的支持不够：Linux2.4内核是非抢占的，当进程处于内核态时不会发生抢占，这对于真正的实时应用是不能接受的。 Linux2.6内核的O(1)调度器&emsp;&emsp;O(1)调度算法所花费的时间为常数，与当前系统中的进程个数无关。此外Linux2.6内核支持内核抢占，因此更好地支持了实时进程。相比于前任，O(1)调度器还更好地区分了交互式进程和批处理式进程。 &emsp;&emsp;Linux2.6内核也支持三种调度策略：SCHED_NORMAL、SCHED_FIFO、SHCED_RR。其中，SCHED_FIFO和SCHED_RR用于实时进程，而SCHED_NORMAL用于普通进程。O(1)调度器在两个方面修改了Linux2.4调度器，一是进程优先级的计算方法，二是pick_next算法。 &emsp;&emsp;（1）优先级计算方法 &emsp;&emsp;普通进程优先级是动态计算的，计算公式中包含了静态优先级。一般来讲，静态优先级越高，进程所能分配到的时间片越长，用户可通过nice系统调用修改进程的静态优先级。动态优先级由下面的公式计算得出。 1dynamic_priority=max(100,min(static prority-bonus+5139)) &emsp;&emsp;其中，bouns取决于进程的平均睡眠时间。平均睡眠时间越长，其bouns越大，从而得到更高的优先级。 &emsp;&emsp;实时进程的优先级由系统调用sys_sched_setschedule()设置。该值不会动态修改，而且总是比普通进程的优先级高。在进程描述符中用rt_prioriity域表示。 &emsp;&emsp;(2)pick_next算法 &emsp;&emsp;普通进程的调度选择算法基于进程优先级，拥有最高优先级的进程被调度器选中。在Linux2.4内核中，时间片counter同时也表示了一个进程的优先级。Linux2.6中的时间片用任务描述符中的time_slice域表示，而优先级用prio(普通进程)或者rt_priority（实时进程）表示。 &emsp;&emsp;调度器为每个CPU维护了两个进程队列数组：active数组（时间片未耗尽的进程队列）和expire数组（时间片以耗尽的进程队列）。数组中的元素保存某一优先级的进程队列指针。系统一共有140个不同的优先级，因此这两个数组大小都是140。当需要选择最高优先级进程时，Linux2.6内核的调度器不用遍历整个runqueue，而是直接从active数组中选择当前最高优先级队列中的第一个进程。 &emsp;&emsp;为了实现上述算法，active数组维护了一个bitmap位图，当某个优先级别上有进程被插入列表时，相应的比特位就被置位。sched_find_first_bit()函数查询位图bitmap，返回当前被置位的最高优先级的数组下标。 &emsp;&emsp;为了二提高交互式进程的响应时间，O(1)调度器不仅动态地提高该类进程的优先级，还采用以下方法。 &emsp;&emsp;在每次时钟tick中断时，进程的时间片(time_slice)被减1。当time_slice为0时，调度器判断当前进程的类型，如果是交互式进程或者实时进程，则重置时间片并重新插入active数组。如果不是交互式进程则从active数组中移到expired数组。这样实时进程和交互式进程就总能获得CPU。然而这些进程不能始终留在active数组，否则进入expire数组的进程就会产生饥饿现象。当进程已经占用CPU的时间超过一个固定值后，即使它是交互式进程或实时进程也会被移到expire数组中。 &emsp;&emsp;当active数组中的所有进程都被移到expire数组中后，调度器就会交换active数组和expire数组。当进程被调度器移入active数组中时，调度器会重置其时间片，因此新的active数组又恢复了初始情况，而expire数组为空，从而开始新的一轮调度。 &emsp;&emsp;这种调度器的主要不足是： &emsp;&emsp;O(1)调度器群交互式进程和批处理进程的算法与以前虽大有改进，但是仍然在很多情况下会失效。有一些著名的程序总能让该调度器性能下降，导致交互式进程反应缓慢。 三、CFS调度器&emsp;&emsp;CFS(Completely Fair Scheduler)即“完全公平调度”，是一个新的进程调度器。 &emsp;&emsp;CFS的设计思想可以用一句话概括：CFS建立了一个调度模型，在实际的硬件上模拟出一个理想的、精确的多任务CPU。理想的多任务CPU即是要发挥实际CPU100%的能量，在CPU上并行地执行每个任务，且任务的执行速度相同，即1/nr_running。例如，假如系统中有两个任务在执行，则每个任务并行化地占有50%的资源，但是在实际的硬件条件下，每时每刻都只能有一个任务运行，为此引入了虚拟运行时间（vruntime)。一个任务的虚拟运行时间用来表示任务已经获得的CPU时间。CFS根据vruntime的值来选择下一个需要运行的任务。 &emsp;&emsp;与O(1)调度器相比，具有以下特点： （1）CFS的核心数据结构不再基于队列数组，而是红黑树。树里面包含了所有的处理RUNNING状态的进程，而在最左边的进程就是下一个被调度的进程。 （2）CFS彻底以时间和系统负载为参照，完全抛弃原有调度方案中的双优先级数组的概念，使用红黑树来代替运行队列数组，vruntime作为红黑树中节点的键值。 （3）对于普通的进程，不再进一步区分是I/O消耗型进程还是处理器消耗型进程。 （4）不再使用时间片的概念，也不使用jiffies或者其他的Hz，而使用单位为纳秒的时间长度变量。 （5）引入了模块化调度：调度实体和调度类。 （6）对SMP负载平衡进行了重构，使用调度模块的迭代器。]]></content>
      <categories>
        <category>Linux内核</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
        <tag>Linux进程调度</tag>
        <tag>内核调度器</tag>
        <tag>内核调度算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vim的使用]]></title>
    <url>%2F2019%2Fvim%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[一、vim &emsp;&emsp;vim是从vi发展出来的一个文本编辑器。代码补全、编译及错误跳转等方便编程的功能特别丰富，在程序员中被广泛使用，和Emacs并列称为类Unix系统用户最喜欢的文本编辑器。 &emsp;vim的设计理念是命令的组合。用户学习了各种各样的文本间移动/跳转的命令和其他的普通模式的编辑命令，并且能够灵活使用的话，能够比那些没有模式的编辑器是更加高效地进行文本编辑。同时vim与很多快捷键设置和正则表达式类似，可以辅助记忆，并且vim针对程序员做了优化。 二、vim的使用 光标移动 按键 动作 k 上 j 下 h 左 l 右 0 到行首 shift+4（即$) 到行尾 gg 移动到文件头 G 移动到文件尾部 nG（n为行数） 移动到某一行 删除内容 按键 动作 x 删除光标所在字母 u 撤销 X 删除光标前面的内容 dw 从光标删除一个单词 d0 删除光标到行首 D 删除光标到行尾 dd 删除光标所在行 ndd 删除光标所在行开始n行 复制粘贴与可视模式 按键 动作 yy 复制一行内容 dd 剪切一方内容 nyy 复制n行内容 p 粘贴到当前行 P 粘贴到上一行 r 替换一个字母（输入r之后，再输入一个字母） 可视模式： 按v进入可视模式 移动光标选中内容 按y复制内容 移动光标到目的地 按p/P将内容粘贴 查找&amp;格式调整&amp;查看内容查找： /要查找的字符或字符串 n/N进行遍历，向前或向后 ?要查找的字符或字符串 光标移动到字符串上，按#也可以查找该字符串 格式调整： gg=G 文件整体调整格式 &gt;&gt;当前光标所在行右移一个Tab &lt;&lt;光标所在行左移一个Tab n&gt;&gt;光标开始n行左移一个Tab 从命令模式到编辑模式命令模式变为编辑模式： i在光标前插入 a在光标后插入 I在行首插入 A在行尾插入 o/O在下一行或上一行插入 s删除当前字母，进入插入模式 S删除当前行，进入插入模式 末行查找替换与保存退出末行模式： :s/被替换内容/替换内容只替换当前行第一个匹配的“被替换内容”为“替换内容” :s/被替换内容/替换内容/g替换当前行所有的“被替换类同”为“替换内容” :%s/被替换内容/替换内容替换所有行的第一个匹配“被替换内容”为“替换内容” :%s/被替换内容/替换内容/g替换文件内所有的“被替换内容”为“替换内容” 保存退出： wq保存退出 :w只保存 :q只退出，文件不能修改 :q!强退，不保存 :x保存退出 ZZ保存退出（命令模式下） 分屏:sp filename横分 :vsp filename竖分 退出：:q退出一个文件 :qall全部文件退出 :wqall全部保存退出 切换屏幕： ​ Ctrl+w+w]]></content>
      <categories>
        <category>Linux命令</category>
      </categories>
      <tags>
        <tag>Ubuntu</tag>
        <tag>Linux</tag>
        <tag>Vim</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux压缩解压命令及其他命令]]></title>
    <url>%2F2019%2FLinux%E5%8E%8B%E7%BC%A9%E8%A7%A3%E5%8E%8B%E5%91%BD%E4%BB%A4%E5%8F%8A%E5%85%B6%E4%BB%96%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[一、压缩解压命令 压缩解压命令：gzip 命令名称：gzip 命令英文原意：GUN zip 命令所在路径：/bin/gzip 执行权限：所有用户 语法：gzip [文件] 功能描述：压缩文件 压缩后文件格式：.gz 注意： gizp只能压缩文件，不能压缩目录 压缩之后不保留原文件 压缩解压命令：gunzip 命令名称：gunzip 命令英文原意：GUN unzip 命令所在路径：/bin/gunzip 执行权限：所有用户 语法： gunzip [压缩文件] 功能描述： 解压缩.gz的压缩文件 压缩解压命令：tar 命令名称：tar 命令所在路径：/bin/tar 执行权限：所有用户 语法：tar 选项[-zcf] [压缩后文件名] [目录] -c 打包 -v 显示详细信息 -f 指定文件名 -z 打包同时压缩 功能描述：打包目录 压缩后文件格式：.tar.gz 压缩解压缩命令：tar tar命令解压缩语法： ​ -x 解包 ​ -v 显示详细信息 ​ -f 指定解压文件 ​ -z 解压缩 压缩解压缩命令：zip 命令名称：zip 命令所在路径：/usr/bin/zip 执行权限：所有用户 语法： zip 选项 [-r] [压缩后文件名] [文件或目录] ​ -r 压缩目录 功能描述：压缩文件或目录 压缩后文件格式：zip 压缩之后可以保留原文件 压缩解压缩命令：unzip 命令名称：unzip 命令所在路径：/usr/bin/unzip 执行权限：所有用户 语法：unzip [压缩文件] 功能描述：解压.zip的压缩文件 压缩解压缩命令：bzip2 命令名称：bzip2 命令所在路径：/usr/bin/bzip2 执行权限：所有用户 语法：bzip2 选项[-k] [文件] ​ -k 产生压缩文件后保留原文件 功能描述：压缩文件 压缩后文件格式：.bz2 不能压缩目录 压缩解压缩命令：bunzip2 命令名称：bunzip2 命令所在权限：所有用户 语法：bunzip2 选项[-k] [压缩文件] ​ -k 解压缩后保留原文件 功能描述：解压缩 二、用户管理命令 用户管理命令：useradd 命令名称：useradd 命令所在路径：/usr/sbin/useradd 执行权限：root 语法：useradd 用户名 功能描述：添加新用户 用户管理命令：passwd 命令名称：passwd 命令所在路径：/usr/bin/passwd 执行权限：所有用户 语法：passwd 用户名 功能描述：设置用户密码 用户管理命令：who 命令名称：who 命令所在路径：/usr/bin/who 执行权限：所有用户 语法：who 功能描述：查看登录用户信息 三、帮助命令 帮助命令：man 命令名称：man 命令英文原意：mannual 命令所在路径：/usr/bin/man 执行权限：所有用户 语法： man [命令或配置文件] //配置文件不写绝对路径 功能描述：获得帮助信息 帮助命令：help 命令名称：help 命令所在路径：Shell内置命令 执行权限：所有用户 语法 ：help 命令 功能描述：获得shell 内置命令的帮助信息 范例：$help umask ​ 查看umask命令的帮助信息]]></content>
      <categories>
        <category>Linux命令</category>
      </categories>
      <tags>
        <tag>Linux命令</tag>
        <tag>Ubuntu</tag>
        <tag>Linux压缩解压</tag>
        <tag>Linux用户管理</tag>
        <tag>Linux帮助命令</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux文件搜索命令]]></title>
    <url>%2F2019%2FLinux%E6%96%87%E4%BB%B6%E6%90%9C%E7%B4%A2%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[文件搜索命令：find 注意：搜索会占用大量服务器资源。 命令名称：find 命令所在路径：/bin/find 执行权限：所有用户 语法：find [搜索范围] [匹配条件] 执行权限： 所有用户 语法：find [文件搜索] [匹配条件] 功能描述：文件搜索 $find aokis -name cpp 在目录aokis中查找文件cpp $find aokis -size +1024 +n代表大于， -n代表小于， n 表示等于 $find aokis -user aoki 在目录aokis中查找所有者为aoki的文件 -group为根据所属组查找 $find aokis -cmin -120 在目录aokis下查找120分钟内修改过的文件和目录。 -amin 访问时间access -cmin 文件属性change，改变文件属性的时间 -mmin 文件内modify,文件内容被改变 find aokis -size +0 -a -size -1024 在aokis目录下查找大于0，小于1024的文件 -a两个条件同时满足 -o两个条件满足任意一个即可。 $find aokis -name aoki -exec cat {} \; 在aokis下查找aoki文件，并对其进行查看操作 -exec/-ok 命令{}\对搜索结果执行操作 -type根据文件类型查找 -f文件 -d目录 -l软链接文件 -inum根据i结点查找 文件搜索命令：locate 命令名称：locate 命令所在路径：/usr/bin/locate 执行权限:所有用户 语法：locate 文件名 功能描述：在文件资料库中查找文件 updatedb 更新locate文件资料库 注意： /tmp临时文件并不在locate的文件资料库中 locate 严格区分大小写 locate -i 不严格区分大小写 文件搜索命令：which 命令名称：which 命令所在路径：/usr/bin/which 执行权限：所有用户 语法：which 命令 功能描述：搜索命令所在目录及别名信息 文件搜索命令：grep 命令名称：grep 命令所在路径：/bin/grep 执行权限：所有用户 语法：grep -iv [指定字符串] [文件] 功能描述：在文件中搜寻字符串匹配的行并输出 ​ -i 不区分大小写 ​ -v 排除指定字串]]></content>
      <categories>
        <category>Linux命令</category>
      </categories>
      <tags>
        <tag>Linux命令</tag>
        <tag>Ubuntu</tag>
        <tag>Linux文件搜索</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux链接命令及权限管理命令]]></title>
    <url>%2F2019%2FLinux%E9%93%BE%E6%8E%A5%E5%91%BD%E4%BB%A4%E5%8F%8A%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[文件处理命令：ln 命令名称：ln 命令英文原意：link 命令所在路径：/bin/ln 执行权限：所有用户 语法：ln -s [原文件] [目标文件] ​ -s 创建软链接 功能描述：生成链接文件 软链接特征：类似于Windos快捷方式 lrwxrwxrwx l代表软链接 文件大小只是符号链接的大小 cpp.soft-&gt;aokis/cpp 指向源文件 硬链接特征： 相当于执行了‘cp -p’命令，复制了相同属性的文件，且硬链接可以同步更新 通过i结点识别 不能跨分区 不能针对目录使用 权限管理命令：chmod 命令名称：chmod 命令英文原意：change the permissions mode of a file 命令所在路径：/bin/chmod 执行权限：所有用户 语法：chmod [{ugoa} {+-=} {rwx}] [文件或目录] a表示所有人 u 表示所有者 g表示所属组 o表示other，其他人 ​ [mode=421] [文件或目录] ​ -R 递归修改 功能描述：改变文件或目录权限 权限的数字表示： r —-4 w —-2 x —–l rwxrw-r– 7 6 4 代表字符 权限 对文件的含义 对目录的含义 r 读权限 可以查看文件内容 可以列出目录中的内容 w 写权限 可以修改文件内容 可以在目录中创建、删除文件 x 执行权限 可以执行文件内容 可以进入目录 权限管理命令：useradd &amp; groupadd添加用户：useradd 添加结果： 添加组： 权限管理命令：chown 权限管理命令：chown 命令名称：chown 命令英文原意：change owership file 命令所在路径：/bin/chown 执行权限：所有用户 语法：chown [用户] [文件或目录] 功能描述：改变文件或目录的所有者 权限管理命令：chgrp 权限管理命令：chgrp 命令名称：chgrp 命令英文原意：change file group ownership 命令所在路径：/bin/chgrp 执行权限：所有用户 语法：chgrp [用户组] [文件或目录] 功能描述：改变文件或目录的所属组]]></content>
      <categories>
        <category>Linux命令</category>
      </categories>
      <tags>
        <tag>Ubuntu</tag>
        <tag>Linux</tag>
        <tag>文件处理命令</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux文件处理命令]]></title>
    <url>%2F2019%2FLinux%E6%96%87%E4%BB%B6%E5%A4%84%E7%90%86%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[文件处理命令：touch 命令名称：touch 命令所在路径：/bin/touch 执行权限：所有用户 语法：touh [文件名] 功能描述：创建空文件 范例： ​ touch program files //会在当前目录下创建两个文件，一个为program，另一个为files ​ 创建一个文件 ：touch “program files” //不建议加空格 文件处理命令：cat 文件处理命令：cat 命令名称：cat 命令所在路径：/bin/cat 执行权限：所有用户 语法：cat [文件名] 功能描述：显示文件内容 ​ -n 显示行号 文件处理命令：more 文件处理命令：more 命令名称：more 命令所在路径：/bin/more 执行权限：所有用户 语法：more [文件名] ​ (空格)或f 翻页 ​ （Enter） 换行 ​ q或Q 退出 功能描述：分页显示文件内容 文件处理命令：less 文件处理命令：less 命令名称：less 命令所在路径： /usr/bin/less 执行权限：所有用户 语法：less [文件名] 功能描述：分页显示文件内容 （可向上翻页） 文件处理命令：head 文件处理命令：head 命令名称：head 命令所在路径：/usr/bin/head 执行权限：所有用户 语法：head [文件名] 功能描述：显示文件前面几行 ​ -n 指定行数 文件处理命令：tail 文件处理命令：tail 命令名称：tail 命令所在路径：/usr/bin/tail 执行权限：所有用户 语法： tail [文件名] 功能描述：显示文件后面几行 ​ -n 指定行数 ​ -f 动态显示文件末尾内容]]></content>
      <categories>
        <category>Linux命令</category>
      </categories>
      <tags>
        <tag>Linux命令</tag>
        <tag>Ubuntu</tag>
        <tag>Linux文件处理命令</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux目录及常用命令]]></title>
    <url>%2F2019%2FLinux%E7%9B%AE%E5%BD%95%E5%8F%8A%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[一、Ubuntu各目录含义 目录名 作用 /boot/ 启动目录，保存系统启动相关文件 /boot/grub/ grub引导其器相关的配置文件 /dev/ 设备文件保存位置。Linux中所有内容以文件形式保存，包括硬件。那么这个目录就是用来保存所有硬件设备文件的 /proc/ 虚拟文件目录，该目录中的数据并不保存到硬盘当中，而是保存到内存中。主要保存系统同的内核、进程、外部设备状态和网络状态灯 /mnt/ 挂载目录，系统建议用来挂载NFS服务的共享目录。只要是一个已经建立的空目录就可以作为挂载点。系统虽然准备了三个默认挂载点/media、/mnt、/misc，但是到底哪个目录挂载什么设备都可以由管理员自己决定。 /media/ 挂载目录，系统建议用来挂载媒体设备的，例如光盘和软盘 /root/ 超级用户的家目录。普通用户家目录在/home下，超级用户家目录直接在/下 /home/用户名/ 普通用户的家目录，创建一个一般用户账号时，默认的用户主文件夹就在该目录下 /bin/ 存放系统命令的目录，普通用户和超级用户都可以执行 /sbin/ 保存和系统环境设置相关的命令，只有超级用户可以使用这些命令进行系统环境设置 /lib/ 系统调用的函数库保存位置 /etc/ 配置文件保存位置。 /etc/init.d/ System V分类风格的启动脚本 /etc/X11/ 图形界面配置文件 /lost+found 包含了系统修复时的恢复文件 /sys/ 虚拟文件系统。和/proc目录相似，都是保存在内存当中的，主要保存与内核相关信息 /usr Unix Software Resouce,即Unix操作系统软件资源放在该目录，而不是用户的是数据 /usr/bin 用户可使用的大部分命令都放在这儿 /usr/include 存放C/C++等程序语言的头文件和目标文件 /usr/lib 包含各应用软件的函数库，目标文件 /usr/local 系统管理员在本机执行下载自行安装的软件 /var 动态数据保存位置。主要保存缓存，日志以及软件运行所产生的文件 /var/cache 应用缓存目录 /var/lib 存放程序执行过程中，需要使用到的数据文件 /var/lock 它是/run/lock目录的软链接，某些设备或文件一次只能被一个应用所使用 var/log 日志文件目录 二、Linux相关知识 Linux严格区分大小写 Linux中所有内容以文件形式保存，包括硬件 硬盘文件是/dev/sd[a-p] 光盘文件是/dev/sr0等 Linux不靠扩展名区分文件类型 压缩包：.gz、.bz、.tar、.bz2、.tgz 二进制软件包：.rpm 网页文件：.html、.php 脚本文件：.ssh 配置文件：.conf Linux所有的存储设备都必须挂载之后用户才能使用，包括硬盘，U盘，光盘。 Windows下的程序不能直接在Linux中安装和运行 三、Linux目录处理命令 命令格式 命令格式： 命令 [-选项] [参数] 例如： 1ls -la 说明： 个别命令使用不遵循此格式 当有多个选项时，可以写在一起 简化选项与完整选项 -a等于–all 目录处理命令：ls 命令名称：ls 命令英文原意：list 命令所在路径：/bin/ls 执行权限：所有用户 功能描述：显示目录文件夹 语法： ls 选项[-add] [文件或目录] ​ -a 显示所有文件，包括隐藏文件 ​ -l详细信息显示 ​ -d查看指定目录的详细信息 ​ -i 查询任何一个文件的id 1ls -lh #人性化显示 目录处理命令：mkdir 命令名称：mkdir 命令英文原意：make directories【目录】 命令所在路径:/bin/mkdir 执行权限：所有用户 语法：mkdir -p[目录名] 功能描述：创建新目录 ​ -p 递归创建 目录处理命令：cd 命令名称：cd 命令英文原意：change directory 命令所在路径：shell内置命令 执行权限：所有用户 语法：cd [目录] 功能描述：切换目录 目录处理命令：pwd 目录处理命令：pwd 命令名称：pwd 命令英文原意：print working directory 命令所在路径：/bin/pwd 执行权限：所有用户 语法：pwd 功能描述：显示当前目录 目录处理命令：rmdir 命令名称：rmdir 命令英文原意：remove empty directories 命令所在路径：/bin/rmdir 执行权限：所有用户 语法：rmdir [目录名] 功能：删除空目录 当目录非空时，使用rmdir无法删除目录。 将目录为空时，可以使用rmdir删除目录。这里删除了xiaoming目录下的文件，删除成功。 目录处理命令：cp 命令名称：cp 命令英文原意：copy 命令所在路径：/bin/cp 执行权限：所有用户 语法： cd -rp [原文件或目录] [目标目录] ​ -r 复制目录 ​ -p 保留文件属性 功能：复制文件或目录 ​ 可以同时复制多个文件 目录处理命令：mv 命令名称：mv 命令英文原意：move 命令所在路径：/bin/mv 执行权限：所有用户 语法：mv [原文件或目录] [目标目录] 功能描述：剪切文件、改名 上图所示操作将/xiaohong/xiaoming目录下的my目录剪切到了/xiaohong目录下，并改名为aokis。]]></content>
      <categories>
        <category>Linux命令</category>
      </categories>
      <tags>
        <tag>Linux命令</tag>
        <tag>Ubuntu</tag>
        <tag>目录处理命令</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux进程管理（二）]]></title>
    <url>%2F2019%2FLinux%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86%EF%BC%88%E4%BA%8C%EF%BC%89%2F</url>
    <content type="text"><![CDATA[三、进程创建 概述&emsp;&emsp;在创建进程时，Windows等操作系统都提供了产生（spawn)进程的机制，即首先在新的地址空间里创建进程，读入可执行文件，最后开始执行。Linux采用了一种不同的方式，它把上述过程分解到两个单独的函数(fork()和exec())中去执行。 &emsp;&emsp;首先fork()函数通过复制当前进程创建一个子进程，子进程与父进程的唯一区别是task_struct不同；接着exec()函数负责读取可执行文件并将其载入地址空间开始运行。 &emsp;&emsp;在Linux中，除了init进程外，所有进程都是由其他进程创建的。为此，Linux提供了三个函数来创建一个新的进程，分别是fork()、vfork()和clone(),内核中提供了三个与它们相对应的系统调用，分别是sys_fork()、sys_vfork()和sys_clone()，而这三个系统调用其实最终都是通过调用一个叫做do_fork()函数来完成一个进程的创建的。 写时复制&emsp;&emsp;在创建进程时，传统的fork()函数的系统调用直接把所有的资源复制到新创建的进程内存空间，这种实现过于简单并且效率低下，因为如果新进程打算立即执行新的映像，那么所有的复制都将是无用的。 &emsp;&emsp;为了克服这个缺点，Linux在创建进程时，采用“写时复制”（copy-on-write)技术，即指在创建进程时并不将父进程的所有资源都复制到子进程，而是在需要的时候才进行资源的复制，采用该方法可以大大提高Linux的系统性能。该技术之所以有时可以避免数据复制，是因为在产生子进程时，并不复制父进程的所有页面，而是置父进程所有页面的写时复制位，子进程共享父进程的所有页面，直到父进程或子进程写某个页面时，就会发生一个保护性错误，并复制该页面。也就是说资源的复制只有在需要写入的时候才进行，在这之前，只是以只读的方式共享。 fork()、vfork()与clone() fork()函数 fork()函数调用一次返回两次：一次在父进程，一次在子进程。如果在子进程中，则返回0；如果在父进程中，则将返回子进程的pid。fork()函数通过系统调用sys_fork()来实现，sys_fork()函数的实现依赖于体系结构，因为它的参数需要系统寄存器来传递。 在x86体系结构下该函数定义如下： 1234asminkage int sys_fork(struct pt_regs regs)&#123; return do_fork(SIGCHILD,reg.esp,&amp;reg,0,NULL,NULL);&#125; vfork()函数 vfork()函数和fork()函数类似，但前者的父进程一直阻塞，直到子进程退出或者调用exec()函数。之所以引进该函数，是因为当时还没有引入“写时复制”技术，调用fork()来创建新的进程需要复制整个父进程的数据，在有些情况下，这样会降低系统的利用率，引入vfork()就是为了在创建进程时子进程不复制父进程的页表项。 1234asmlinkage int sys_vfork(struct pt_regs regs)&#123; return do_fork(CLONE_VFORK|CLONE_VM|SIGCHLD,regs.esp,&amp;regs,0,NULL,NULL);&#125; clone()函数 clone()函数不同于fork()和vfork()函数，它接受一个指向函数的指针和该函数的参数，由do_fork()创建的子进程刚一创建就去调用这个函数。 12345678910111213asmlinkage int sys_clone(struct pt_regs regs)&#123; unsigned long clone_flags; unsigned long newsp; int _user *parent_tidptr,*child_tidptr; clone_flags=regs.ebx; newsp=reg.ecx; parent_tidptr=(int _user *)regs.edx; child_tidptr=(int _user *)regs.edi; if(!newsp) newsp=regs.esp; return do_fork(clone_flags,newsp,&amp;regs,0,parent_tidptr,child_tidptr);&#125; do_fork()函数 我们知道需要通过调用fork()、vfork()、clone()来创建进程，这三个函数调用相应的系统调用sys_fork()、sys_vfork()和sys_clone()，而这三个系统调用的区别在于调用do_fork()函数时设置的那些标志不同，该函数实现真正的进程创建。函数原型如下： 1long do_fork(unsigned long clone_flags,unsigned long stack_start,struct pt_regs *regs,unsigned long stack_size,int _user *parent_tidptr,int _user *child_tidptr); 其中，参数stack_start表示栈的起始地址，参数regs表示存储所有寄存器的结构指针，参数stack_size表示栈的大小，参数parent_tidptr表示父进程的用户态变量pid地址，参数child_tidptr表示子进程的用户态变量pid地址，clone_flags表示clone标志位，包括CLONE_VM,CLONE_FILES,CLONE_SIGHAND,CLONE_PID,CLONE_VFORK等，任何一位被置1则表明创建的子进程和父进程共享该位对应的资源。 1234567891011121314151617181920#define CSIGNAL 0x000000ff /*进程退出时需要传递的信号*/#define CLONE_VM 0x00000100 /*父子进程共享地址空间*/#define CLONE_FS 0x00000200 /*父子进程共享文件系统信息*/#define CLONE_FILES 0x00000400 /*父子进程共享已打开的文件*/#define CLONE_SIGHAND 0x00000800 /*父子进程共享信号处理*/#define CLONE_PTRACE 0x00002000 /*继续调试子进程*/#define CLONE_VFORK 0x00004000 /*调用vfork(),父进程休眠*/#define CLONE_PARENT 0x00008000 /*设置一个共有的父进程*/#define CLONE_THREAD 0x00010000 /*父子进程在同一个线程组*/#define CLONE_NEWNS 0x00020000 /*为子进程创建一个新的命名空间*/#define CLONE_SYSVSEM 0x00040000 /*父子进程共享system V SEM_UNDO*/#define CLONE_SETTLES 0x00080000 /*为子进程创建新的TLS*/#define CLONE_PARENT_SETTID 0x00100000 /*设置父进程TID*/#define CLONE_CHILD_CLEARTID 0x00200000 /*清除子进程TID*/#define CLONE_DETACHED 0x00400000 /*Unused,ignored*/#define CLONE_UNTRACED 0x00800000 /*不允许调试子进程*/#define CLONE_CHILD_SETTID 0x01000000 /*设置子进程TID*/#define CLONE_STOPPED 0x02000000 /*设置进程停止状态*/#define CLONE_NEWUTS 0x04000000 /*创建新的utsname组*/#define CLONE_NEWIPC 0x08000000 /*创建新的IPC*/ 四、进程终止 概述&emsp;&emsp;进程的终止方式有两种：（1）正常结束，即在进程执行过程中调用exit()函数，或者在main函数中执行return语句，或者是main函数执行完，进程就正常结束了。（2）异常结束，在进程运行过程中出现了错误或故障被迫结束。这类错误或故障有很多，常见的有：进程收到自己不能处理的一个信号，进程在内核执行期间可能产生一个异常，进程可能收到SIGABRT或其他终止信号等。 无论进程以哪一种方式终止，Linux内核并不是在进程终止的同时就将与进程相关的所有资源都释放掉，而是分为两步执行的： 首先，通过调用do_eait()函数，释放掉与进程相关的大部分资源，并使进程处于ZMOBIE（僵死）状态，但此时进程描述符并没有释放。 然后，根据父进程是否终止，对子进程进行相应的处理。若子进程先于父进程终止了，则子进程会一直处于僵死状态直到父进程调用wait()或waitpid()，当父进程调用了wait()或waitpid()函数时，子进程的进程描述符和所有其独享的资源都将被释放掉；若父进程先于子进程终止，则内核必须首先为子进程找到一个新的父进程，方法是首先给子进程在当前进程组内找一个进程作为其父进程，如果该方法不行则让init进程作该进程的父进程。 下面详细说明父进程是如何获得子进程死亡的消息以及内核是如何完成进程终止的第二步。 当一个进程进入僵死状态后，尽管它已经不能再次被调度运行了，但是并不能将其马上就释放掉，而是应该保存其进程描述符，这样可以使得系统在子进程终止了的情况下仍然可以获得它的信息。 当子进程终止时，父进程会收到内核发送给它的SIGCHLD信号，父进程可以通过调用wait()函数来处理信号，wait()函数族有两个作用:获取子进程终止的消息和清除子进程的所有独享资源。wait()函数首先会挂起调用它的进程，直到该进程的一个子进程终止，此时，该函数会返回该子进程的pid给父进程。 do_exit()函数&emsp;&emsp;在Linux中不管是以何种方式结束进程，最终都要调用内核函数do_exit()。该函数释放掉与该进程有关系的大多数资源（如果进程是这些资源的唯一使用者），进程运行该函数后将不再可以运行，处于TASK_ZOMBIE状态，此时进程占有的所有资源就是内核栈、thread_info结构和task_struct结构，用于向它的父进程提供信息。 &emsp;&emsp;do_exit()函数的大致处理流程： 排除一些无效的特殊情况，即确保该进程不处于中断处理中，确保该进程不是idle进程(pid=0)。如果该进程正在被追踪并且设置了PT_TRACE_EXIT标志，就传递退出码并通知父进程。 对重读调用do_exit进行处理，并把进程的标志置为PF_EXITING，表明进程正在关闭。 如果进程审计功能开启，则记录进程的运行信息。 进程资源释放。例如，更新内存信息，然后调用exit_mm()函数释放进程所占用的内存，并释放mm_struct结构；调用exit_sem()函数把进程从任一IPC信号量中释放出来；调用_exit_files()函数释放分配给进程的所有文件，减少文件描述符的个数；调用module_put()函数减少模块的引用数。 调用exit_notify()函数向父进程发送信号，将子进程的父进程重新设置为线程组中的其他线程或者init进程，并把进程的状态设置为TASK_ZOMBIE状态。 最后调用schedule()函数切换到其他进程。 wait()函数&emsp;&emsp;在调用了do_exit()函数之后，尽管进程已经僵死不能再运行了，但是系统还保留了它的进程描述符，系统可以通过wait()函数来获取进程信息。父进程可以选择调用wait()函数族中的4个函数之一。 1234pid_t wait(int *status);pid_t waitpid(pid_t pid,int *status,int options);pid_t wait3(int *status,int options,struct rusage*rusage);pid_t wait4(pid_t pid,int * status,int options,struct rusage *rusage); 每个函数又会调用系统调用sys_wait4，而sys_wait4只做一些错误检查，随后调用do_wait()函数。 1static long do_wait(pid_t pid,int options,struct signinfo _user *infop,int _user *stat_addr,struct rusage _user *ru); 其中参数pid表示目标进程的pid，options表示传递给该函数的标志，infop指向进程的信号信息的指针，stat_addr表示子进程退出状态应存放的地址，ru表示子进程资源使用信息应存放的地址。do_wait()函数的处理流程如下: 把当前进程放到等待队列中，设置进程的状态为TASK_INTERRUPRIBLE 检查进程的每个子进程的状态。如果进程正在睡眠、就绪或者运行，则什么都不做；如果进程停止或僵死，调用wait_task_zombie()函数，对僵死进程进行处理。 将进程的状态再一次置为TASK_RUNNING，从等待队列中删除该进程。 五、线程的实现 用户线程&emsp;&emsp;线程的概念是现代操作系统中比较重要的一个概念，线程的引入实现了程序的并发执行，改善了资源的利用率，并提高了系统的吞吐量，通常情况下将线程看做是进程内的一个执行单元，一般定义为：线程是进程内的一个相对独立的、可独立调度和指派的执行单元。进程是资源管理的最小单位，线程时程序执行的最小单位。在操作系统设计上，从进程演化出线程，最主要的目的就是更好地支持SMP(对称多处理)以及减小（进程/线程）上下文切换开销。 &emsp;&emsp;在Linux中线程的实现比较特殊，它不像其他操作系统将进程与线程严格分开对待和处理，并在系统内核中提供专门的支持线程的机制，而是将系统中所有的线程都当作进程来实现的，在内核中没有准备一个特定的数据结构来表示线程，也没有为线程定义它们自己的调度策略，相反在Linux中线程仅仅是被看作一个与其他进程共享某些资源的进程。 &emsp;&emsp;正是由于Linux并没有将线程作为一个单独的对象来对待，在Linux中创建一个线程与一个进程非常相似，唯一的区别就是调用特定的函数的时候所传递的参数不同，在Linux中可以通过系统调用clone()来创建一个线程，它与创建进程的区别就在于调用clone()的时候需要传递一些参数来指定需要共享的资源。 1clone(CLONE_VM|CLONE_FS|CLONE_FILES|CLONE_SIGHAND,0); &emsp;&emsp;上面的代码产生的结果和调用fork()差不多，只是“父子俩”共享地址空间、文件系统资源、文件描述符和信号处理程序。 内核线程 &emsp;&emsp;内核经常需要在后台执行一些操作。这种任务可以通过内核线程完成——独立运行在内核空间的标准进程。内核线程和普通进程间的区别在于内核线程没有独立的地址空间，它们只是在内核空间运行，从来不切换到用户空间去。内核线程和普通进程一样，可以被调度，也可以被抢占。 &emsp;&emsp;Linux确实会把一些任务交给内核线程去做，像pdflush和ksoftrqd这些任务就是明显的例子。这些线程在系统启动时由另外一些内核线程启动。实际上，内核线程也只能由其他内核线程创建。内核通过kernel_thread()函数来创建内核线程，该函数的实现与体系结构有关。在x86体系结构中，该函数定义如下： 1234567891011121314151617int kernel_thread(int(*fn)(void*),void* arg,unsigned long flags)&#123; /*声明一个寄存器变量，并对其进行初始化*/ struct pt_regs regs; memset(&amp;regs,0,sizeof(regs)); regs.ebx=(unsigned long)fn; regs.edx=(unsigned long)arg; regs.xds=_USER_DS; regs.xes=_USER_DS; regs.xfs=_KERNEL_PERCPU; regs.orig_eax=-1; regs.eip=(unsigned long)kernel_thread_helper; regs.xcs=_KERNEL_CS|get_kernel_rpl(); regs.eflags=x86_EFLAGS_IF|X86_EFLAGS_SF|X86_EFLAGS_PF|0X2; /*调用do_fork()函数创建一个内核线程*/ return do_fork(flags|CLONE_VM|CLONE_UNTRACED,0,&amp;regs,0,NULL,NULL);&#125;]]></content>
      <categories>
        <category>Linux内核</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Linux进程管理</tag>
        <tag>Linux进程创建</tag>
        <tag>Linux进程终止</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux进程管理（一）]]></title>
    <url>%2F2019%2FLinux%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[一、进程描述&emsp;&emsp;进程的定义：进程是可并发执行的程序在一个数据集合上的运行过程。进程具有动态性、并发性、独立性、异步性等基本特征。 &emsp;&emsp;为了使参与并发执行的每个程序（含数据）都能独立地运行，在操作系统中必须为之配置一个专门的数据结构，称为进程控制块（PCB）。系统利用PCB来描述进程的基本情况和活动过程，进而控制和管理进程。这样，由程序段、相关数据段和PCB三部分便构成了进程实体。进程的程序段就是该进程所对应静态程序实体在进程地址空间中的映像，而数据段就是进程数据工作集合在进程地址空间中的映像。 &emsp;&emsp;进程控制块是系统为了管理进程而设置的专门数据结构，用于记录进程的外部特征，描述进程的运动变化过程；它包含了有关进程的描述信息、控制信息以及资源信息，是进程动态特征的集中反映。因此，系统同利用PCB来控制和管理进程。PCB是系统感知进程存在的唯一标志，所以进程与PCB是一一对应的。也就是说，进程的创建以PCB的产生为标志，进程的消亡以PCB的删除为标志。 1.Linux进程描述符&emsp;&emsp;在Linux中，PCB使用task_struct结构来描述，该结构定义在&lt;Linux/sched.h&gt;文件中，称为Linux进程描述符。该描述符结构task_struct存放在任务对内的双向链表task_list中，当有新的程序创建的时候，系统从内存中分配一个新的task_struct结构，并把它放到双向链表中，为了便于查找，系统用全局指针current指向当前运行进程的task_struct。 &emsp;&emsp;进程描述符task_struct结构包括了许多字段，下面按照字段进程管理过程中的不同作用，分为以下几类来介绍其中的基本功能。 进程的基本属性 进程之间的关系 调度相关 进程地址空间 进程的文件系统信息 进程的信号处理 进程的访问权限 资源限制 1）进程的基本属性 volatile long state 用于保存进程的状态，在进程的生命期内，可以从该域获得自己的状态，在2.6中进程可以有以下几种状态： 12345678#define TASK_RUNNING 0#define TASK_INTERRUPTIABLE 1#define TASK_UNINTERRUPTIBLE 2#define TASK_STOPPED 4#define TASK_TRACED 8#define EXIT_ZOMBIE 16#define EXIT_DEAD 32#define TASK_DEAD 64 TASK_RUNNING：进程当前正在运行，或者正在运行队列中等待调度 TASK_INTERRUPTIABLE：进程处于睡眠状态，正在等待某些事件发生。进程可以被信号中断。进程被显式唤醒或接收到信号之后，将转变为TASK_RUNNING状态。 TASK_UNINTERRUPTIBLE：进程状态类似TASK_INTERRUPTIABLE，只是它不会处理信号。中断处于这种状态的进程是不合适的，因为它可能正在完成某些重要的任务。当它所等待的事件发生时，进程将被唤醒。 TASK_STOPPED：进程已中止执行，它没有运行，并且不能运行，接收到SIGSTOP和SIGSTP等信号时，进程将进入这种状态。接收到SIGCONT信号之后，进程将再次变得可运行。 TASK_TRACED：正在被调试程序等其他进程监控时，进程将进入这种状态。 EXIT_ZOMBIE:进程已终止，它正等待其父进程收集关于它的一些统计信息。 EXIT_DEAD:最终状态，将进程从系统中删除时，它将会进入此状态，因为其父进程已经通过wait4()和waitpid()调用收集了所有统计信息。 TASK_DEAD：表示已经退出且不需要父进程回收的进程的状态。 atomic_t usage 表示对该结构的引用次数，在进程退出时，只有当对该结构的引用次数为0时，才可以删除该结构。 int lock_depth 表示大内核锁深度，主要用于实现内核的同步机制。 pid_t pid 进程标识符，系统通过进程标识符唯一地标识一个进程。pid_t是一个隐含类型，实际上就是一个int类型，为了与老版本的UNIX和Linux兼容，pid的最大默认值为32768(short int短整型数的最大值).如果需要更大的取值范围，可以修改/proc/sys/kernel/pid_max，从而提高进程数的上限。 struct pid_link pids[PIDTYPE_MAX] 标识该进程的pid所对应的哈希链表。 pid_t tgid 表示线程组的ID unsigned int flags 定义了该进程的特殊属性，flags的值定义在Linux/sched.h中。 int exit_code, exit_signal 系统强行退出时发出的信号，父进程通过这两个值来获取子进程的退出状态。exit_code表示进程的退出值，exit_signal表示进程通过信号被终止的信号值。 struct Linux_binfmt *binfmt Linux支持多种可执行文件格式，每种可执行文件格式都定义了一种数据结构，指明程序代码如何被载入内存。 unsigned int ptrace 当调用ptrace()系统调用时，prtace被设置，ptrace的值定义在linux/ptrace.h中。 char comm[TASK_COMM_LEN] 通常在命令行调用一个可执行程序来创建进程，当在命令行调用可执行程序的时候用comm表示其命令名称。 2）进程之间的关系 struct task_struct *group_leader 每个进程组都有一个被定义为该组领头的进程，如果进程是某个组的成员，group_leader则是一个指向其组领头的进程描述符的指针，组领头进程拥有自己的终端设备tty，它就是从这个终端创建的。 struct list_head thread_group 指向该进程所在进程组的所有进程链表。 struct task_struct *real_parent 指向当前进程的父进程，如果父进程已经死亡，则指向init进程。 struct task_struct *parent 指向当前进程的父进程，这个值通常和real_parent相同，但在某些情况会和real_parent不同，例如使用gdb对程序进行调试时，parent指向gdb进程。 struct list_head children 指向当前进程的子进程的链表 struct list_head sibling 指向当前进程的兄弟进程的链表。 &emsp;&emsp;Linux系统进程之间存在明显的继承关系，所有的进程都是init进程的后代，内核在系统启动的最后阶段启动此进程。系统中的每个进程都有一个父进程，相应地，每个进程可以拥有0个或多个子进程，拥有相同父进程的所有进程都成为兄弟。 3）进程调度 int prio,static_prio,normal_prio prio表示进程的动态优先级，取值范围[0,139]。根据进程prio取值的不同，可以把进程分为实时进程（prio$\in$[0,99])和非实时进程（普通进程，prio$\in$[100,139]),针对他们分别由不同的调度策略。动态优先级prio是调度器选择候选进程next的主要依据，数值越小，进程的优先级越高，越早被调度到。 static_prio是进程的静态优先级，取值范围[0,139]，进程刚被创建时从父进程继承而来，主要用于进程初始时间片的计算和动态优先级prio的计算。 normal_prio是常规动态优先级，使用“优先级继承协议”时，可能会临时提升进程的优先级，但提升后应该立即返回到其应有的优先级上。这个成员保存的正是这个“应有的优先级”。 struct list_head run_list 指向就绪队列runqueue const struct sched_class *sched_class 调度类，该调度类类似一个模块链，协助内核调度程序工作。每个调度程序模块需要实现struct sched_class建议的一组函数。 struct sched_entitu se 该结构包含了关于调度的完整信息，用于实现对于单个任务或任务组的调度，调度实体可能与进程没有关联。 undigned int policy 进程的调度策略。包括实时调度和非实时调度。 cpumask_t cpus_allowed 当存在多个处理器时，用它来指明该进程可以由哪个CPU来执行。 unsigned int time_slice 进程的时间片余额，相当于内核2.4的counter，但不再直接影响进程的动态优先级。 unsigned int rt_priority 实时进程的优先级，在调用schedule()时被更新，仅对实时进程有效。 unsigned long nvcsw,nivcsw nvcsw，主动的上下文切换数，计算非基于内核抢占的上下文切换数。nivcsw，被动的上下文切换数，计算进程被内核抢占的次数，其值仅当进程从内核返回的时候才增加。 4）进程地址空间和文件系统 struct mm_struct *mm,*active_mm mm是一个指向地址空间和内存管理相关的信息，active_mm是一个指向最近最常使用的地址空间的指针。 struct fs_struct *fs,*files fs保存了进程本身与VFS的关系信息，files包含了进程当前所打开的文件列表。 5）进程的信号管理 sigset_t saved_sigmask 进程所能接收信号的位掩码。置位表示屏蔽，复位表示不屏蔽。 struct sigpending pending 存放进程中所有挂起的信号，即记录进程所有已经触发但是还未处理的信号 struct signal_struct *signal 指向进程信号的描述符 struct sughand_struct *sighand 指向信号的处理标识符 int pdeath_signal 是父进程死亡时设置的信号 6）进程的访问权限 uid和gid 该进程的用户ID，通常是进程的创建者。因为每个用户可能属于多个组，所以还需要gid来表示该进程属于哪个用户组。 euid和egid 有效的uid和gid,处于系统安全权限的考虑，运行程序时要检查euid和egid的合法性。通常，uid等于euid，gid等于egid。有时候，系统会赋予一般用户暂时拥有root的uid和gid，以便于进行运作。 suid和sgid 根据POSIX标准引入的，在系统调用改变uid和gid时，用于保留真正的uid和gid fsuid和fsgid 文件系统的uid和gid，用于对文件系统操作时的合法性检查，是Linux独特的标识类型。它们一般分别和euid和egid一致，但在NFS文件系统中NFS服务器需要一个特殊的进程访问文件，这时只修改客户进程的fsuid和fsgid以便确保对于该文件的访问权限。 struct group_info *group_info 一个Linux进程可以属于多个用户组，group_info保存与这些组相关的信息。 二、进程的组织形式&emsp;&emsp;为了高效地对进程进行管理，内核中采用了不同的数据结构将系统中的进程通过不同方式组织起来，以满足进程管理子系统中各种不同需求。 进程链表Linux采用了双向链表将系统中的所有进程连接起来，该双向链表基于进程描述符中类型为struct list_head的成员变量tasks。 Linux内核提供了宏定义for_each_process()用于遍历系统中的每一个进程，该宏定义在需要对系统中每一个进程进行操作时非常有用。 12#define for_each_process(p)\ for(p=&amp;init_task;(p=next_task(p))!=&amp;init_task;) 其中，init_task是系统初始化过程中创建的第一个进程的进程描述符，宏定义next_task表示链表的下一个进程。 函数原型 说明 next_task(p) 当前进程p的下一进程 add_task(p) 从p的父进程孩子链表中添加该进程 remove_task(p) 从p的父进程孩子链表中删除该进程 哈希链表&emsp;&emsp;内核中使用一个进程描述符来表示一个进程，因此通过进程描述符的地址来访问一个进程再方便不过了。但是POSIX规范中规定，每一个进程要有进程号，而且POSIX规范中规定的系统调用kill()是基于进程号向其他进程发送信号的。这就需要一种机制来高效地完成从进程号到进程描述符地址的转换。Linux内核引入了哈希表来完成进程号到进程描述符task_struct结构的映射。 &emsp;&emsp;根据进程类型的不同以及效率上的考虑，内核设置了PIDTYPE_MAX（默认值为3）个不同用途的哈希表，哈希表的类型使用枚举类型pid_type进行定义。 1234567enum pid_type&#123; PIDTYPE_PID, PIDTYPE_PGID, PIDTYPE_SID, PIDTYPE_MAX&#125;; &emsp;&emsp;其中，PIDTYPE_PID代表了进程号（Process ID）哈希表，系统中所有进程（包括线程）的进程号都在该哈希表中有相应的存储位置。PIDTYPE_PGID代表了进程组号（Process）哈希表。PIDTYPE_SID代表了会话号（Session ID）哈希表。 &emsp;&emsp;为了查找哈希表，需要知道进程号（pid）与哈希表中位置之间的映射函数——哈希函数，定义如下： 12#define pid_hashfn(nr,ns) Hash_long((unsigned long)nr+(unsigned long)ns,pidhash_shift) &emsp;&emsp;其中nr表示进程的pid，ns表示进程的pid命名空间结构pid_namespace,pidhash_shift表示哈希表的大小（1&lt;&lt;pidhash_shift). &emsp;&emsp;Linux把通过哈希函数计算得到的哈希值作为数组pid_Hash的下标，并且把哈希值相同的进程组成哈希链表，我们称该链表为哈希链表的主链表。链表中的每个哈希结点（hlist_node结构）表示进程的pid。 (1)相关的数据结构&emsp;&emsp;随着在Linux内核2.6.24中引入了pid命名空间，结构pid被分割成结构pid和结构upid，其定义如下： 123456789101112131415struct upid&#123; int nr;/*pid值*/ struct pid_namespace *ns;/*所在的命名空间*/ struct hlist_node pid_chain;/*哈希链表节点*/&#125;;struct pid&#123; atomic_t count;/*引用计数*/ struct hlist_head tasks[PIDTYPE_MAX];/*保存所有使用此pid的进程*/ struct rcu_head rcu;/*读写锁*/ int level;/*包含upid结构的个数*/ struct upid numbers[1];/*包含的upid结构*/&#125;; &emsp;&emsp;在pid结构中，包含一个struct hlist_head类型的成员变量tasks，该变量把具有相同pid值的进程联系起来，如同一个进程组的进程拥有相同的进程组号pgid，此时可以将同一个进程组的进程通过该变量联系起来，我们称该链表尾哈希链表的从链表。 &emsp;&emsp;在进程描述符task_struct中存在成员变量pids，定义如下所示： 1struct pid_link pids[PIDTYPE_MAX]; 该成员变量的数据类型pid_link的定义如下： 12345struct pid_link&#123; struct hlist_nnode node;/*从哈希表节点*/ struct pid *pid;/*进程对应的pid结构*/&#125;; 该结构是表示进程描述符task_struct与结构pid之间的映射关系。使用这个变量可以根据pid结构找出对应的描述符。 (2)哈希表相关的操作 find_pid()函数根据nr的值，利用哈希函数计算其哈希值，从哈希表pid_Hash中找出哈希链表头节点，然后遍历整个链表，找出哈希值为nr的pid结构。 1struct pid* find_pidd(int nr);/*nr表示进程的pid值*/ pid_task()函数根据pid返回其对应的进程描述符地址 1struct task_struct *fastcall pid(struct pid* pid,enum pid_type type);/*参数type表示pid的类型*/ transfer_pid()函数使用新的继承描述符new替换旧的进程描述符 1void fastcall transfer_pid(struct task_struct *old,struct task_struct *new ,enum pid_type type); attach_pid()函数建立进程描述符task与结构pid之间的映射关系，并将pid添加到相应的哈希链表的开头。 1int fastcall attach_pid(struct task_struct *task,enum pid_type,struct pid* pid); 当进程被销毁时需要将进程在哈希表中的映射关系解除，这一过程通过函数detach_pid()完成。该函数首先解除进程描述符与哈希链表的映射关系，然后检查pid结构中是否还包含别的进程，如果不是，则释放pid结构。 1void fastcall detach_pid(struct task_struct *task,enum pid_type type); 等待队列&emsp;&emsp;当进程等待一个外部事件发生时，就把它从运行队列中删除并放到等待队列上。 &emsp;&emsp;在Linux内核中，使用wait_queue_t结构的双向链表来表示一个等待队列。在每个等待队列链表中，以wait_queue_head_t结构表示等待队列的表头，wait_queue_t表示等待队列中的每一个节点，它记录了等待进程所需要的所有信息。 123456struct _wait_queue_head&#123; spinlock_t lock; struct list_head task_list;&#125;;typedef struct _ wait_queue_head wait_queue_head_t; lock用于保护该等待队列中数据的一致性。 task_list表示睡眠在该等待队列上的所有进程构成的链表的表头 123456789struct _ wait_queue&#123; unsigned int flags;#define WQ_FLAG_EXCLUSIVE 0X01 void *private; wait_queue_func_t func; struct list_head task_list;&#125;;typedef struct _ wait_queue wait_queue_t; flags:它指示了该结点对应进程的环形方式，取值为WQ_FLAG_EXCLUSIVE或0；WQ_FLAG_EXCLUSIVE表示节点对应进程对临界区资源使用是排他性的，即进程是独占式进程。 private:一个私有数据指针，通常保存了睡眠进程的进程描述符task_struct的地址 func:存放函数的一个结构，这个函数用于唤醒等待队列上的进程。这个域的默认值为default_wake_function()函数，该函数负责将变量private指示的进程设置为可运行状态并插入到合适的运行队列中。 当前进程&emsp;&emsp;Linux关于进程管理的大部分代码都需要获得或设置当前进程的信息，因此，是否能快速、高效地找到当前进程的描述符task_struct对系统的性能有很大的影响。Linux内核2.2开始采用了宏定义current来获取当前进程的描述符。硬件体系结构把不同，该宏的定义也不同，它必须针对专门的硬件体系结构作处理。有的硬件体系结构可以拿出一个专门的寄存器来存放指向当前进程描述符task_struct的指针，而像x86这样的体系由于寄存器并不富余，就只能在当前内核栈的尾端创建thread_info结构，通过计算偏移间接地查找task_struct结构。 &emsp;&emsp;在x86体系结构中，每个进程拥有一个内核栈，且通过寄存器%esp即可访问内核栈的元素。基于这种思想，内核首先将当前进程的地址以及需要快速访问的其他状态标记记录在数据结构struct thread info中，然后将该数据结构保存到内核栈空间中的最低地址位置。 12345union thread_union&#123; struct thread_info thread_info; unsigned long stack[THREAD_SIZE/sizeof(long)];&#125;; 从该结构中可以看出，内核栈stack和数据结构thread_info共享同一块内存。]]></content>
      <categories>
        <category>Linux内核</category>
      </categories>
      <tags>
        <tag>Linux内核</tag>
        <tag>Linux</tag>
        <tag>Liinux进程管理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于Linux内核]]></title>
    <url>%2F2019%2F%E5%85%B3%E4%BA%8ELinux%E5%86%85%E6%A0%B8%2F</url>
    <content type="text"><![CDATA[一、Linux内核特征&emsp;&emsp;&emsp;Linux操作系统的内核稳定而高效，以独占的方式执行最底层任务，保证其他程序的正常运行。它是整个系统的核心，具有独特的性质。 接口特色&emsp;&emsp;按照POSIX标准，一个可以运行UNIX程序的系统就是UNIX。Linux系统提供和一般UNIX系统相同的标准界面，包括程序级和用户级的界面。 &emsp;&emsp;在程序级，Linux系统提供标准的UNIX函数库，一个在Linux下开发的应用程序，几乎不经过任何改动就可以在其他UNIX系统下编译执行，完成同样的功能。 &emsp;&emsp;Linux系统对用户同时提供图形和文本用户界面，文本界面是shell接口，图形界面是X-Window系统。UNIX下的基本命令在Linux下的功能和使用方式都完全相同。而最早在UNIX平台开发的图形用户界面X-Window系统，在Linux系统下运行良好并可以展示与其他版本UNIX系统下相同甚至更好的效果。 功能特色&emsp;&emsp;Linux系统可以支持多种硬件设备。Linux系统下的驱动程序开发和Windows系统相比简单得多。 &emsp;&emsp;Linux自身使用的专用的文件系统为Ext3，可以提供方便有效的文件共享及保护机制。同时，它可以通过虚拟文件系统的技术，支持包括微软系列操作系统所使用的FAT16、FAT32和NTFS等文件系统在内的几十种现有的文件系统。 &emsp;&emsp;Linux系统具有内置的TCP/IP协议栈，可以提供各种高效的网络功能，包括基本的进程间通信、网络文件服务等。 结构特征&emsp;&emsp;Linux内核基本采用模块结构，单内核模式，这使得系统具有很高的运行效率，但系统的可扩展性及移植性会受到一定的影响。为了解决这个问题，Linux使用了附加模块技术。利用模块技术，可以方便地在内核中添加新的组件或卸载不再需要的内核组件，而且这种装载和卸载可以动态进行。 &emsp;&emsp;内核模块的引入也带来了对系统性能、内存利用和系统稳定性的一些影响，可动态装卸的模块需要系统增加额外的资源来记录、管理，而装入的内核模块和其他内核部分一样，具有相同的访问权限，差的内核模块会导致系统不稳定甚至崩溃，一些恶意的内核模块可能对系统安全造成极大的威胁。 &emsp;&emsp;总的来说，Linux内核基本采用模块式结构构造，同时加入动态的模块技术，在追求系统整体效率的同时，实现了内核的动态可伸缩性。这样的结构给系统移植带来一定的负面影响。 二、Linux内核体系结构&emsp;&emsp;Linux内核主要由5个模块构成，分别是进程调度模块、内存管理模块、虚拟文件系统模块、进程间通信模块和网络接口模块。 &emsp;（1）进程调度模块：进程调度模块程序是内核的重要组成部分，它选择下一个要运行的进程并负责控制进程对CPU资源的使用，调度程序采用一种策略使各个进程能够公平合理地访问CPU，同时保证内核能够实时地执行必要的硬件操作。 &emsp;（2）内存管理模块：内存管理模块负责管理系统，用于确保所有进程能够安全地共享计算机的内存，同时，内存管理模块还支持虚拟内存，使得Linux能够支持进程使用比实际内存空间更大的内存地址空间。 &emsp;（3）虚拟文件系统模块：虚拟文件系统（VFS）模块通过向所有的外部存储设备提供一个通用的文件接口，隐藏了各种硬件的不同细节，从而提供并支持与其他操作系统兼容的多种文件系统。Linux最好的特征之一就是它支持多种文件系统，用户不仅可以从它自己的文件系统如Ext2，Ext3，ReiserFS等查看文件，而且可以从与其他操作相关的文件系统插卡文件。对用户来说，从一种文件系统到另一种文件系统就没有任何差异，只要是Linux支持的文件系统类型，用户就可以很方便地将它安装到Linux系统中使用。 &emsp;（4）进程间通信模块：进程间通信模块主要负责进程之间如何进行信息交换或共享信息等工作，Linux提供了多种进程之间的通信机制，其中信号和管道是最基本的两种。除此之外，Linux还提供了System V特有的进程间通信机制，包括消息队列，信号量，共享内存等，为了支持网络通信，Linux还引入了套接字（Socket）机制。 &emsp;（5）网络接口模块：网络接口模块提供对多种网络通信标准的访问并支持许多网络硬件，网络接口分为网络协议和网络驱动程序，其中网络协议部分负责实现网络传输协议，网络驱动程序部分负责与硬件设备的通信。 &emsp;（6）进程调度与内存管理模块之间的关系：这两个子系统互相依赖。在多道程序环境下，程序要运行必须为之创建进程，而创建进程的第一件事情就是将程序和数据装入内存。 &emsp;（7）进程间通信与内存管理之间的关系：进程间通信子系统要依赖内存管理支持共享内存机制，这种机制允许两个进程除了拥有自己的私有空间，还可以存取共同的内存区域。 &emsp;（8）虚拟文件系统与网络接口和内存管理之间的关系：虚拟文件系统利用网络接口支持网络文件系统（NFS），也利用内存管理支持RAMDISK设备。 &emsp;（9）内存管理与虚拟文件系统之间的关系：内存管理利用虚拟文件系统支持交换，交换进程(swapd)定期由调度程序调度，这也是内存管理依赖于进程调度的唯一原因。当一个进程存取的内存映射被换出时，内存管理向文件系统发出请求，同时，挂起当前正在运行的进程。 三、单内核与微内核&emsp;&emsp;微内核（MicroKernel Kernel）:在微内核中，大部分内核都作为独立的进程在特权状态下运行，它们通过消息传递进行通信。在典型情况下，每个概念模块都有一个进程。因此，如果在设计中有一个系统调用模块，那么就必然有一个相应的进程来接收系统调用，并和能够执行系统调用的其他进程（或模块）通信以完成所需任务。 &emsp;&emsp;微内核设计的一个优点是在不影响系统其他部分的情况下，更高效地实现代替现有的文件系统模块的工作将会更加容易。我们甚至可以在系运行时将开发出的新系统模块或者需要替换现有模块的模块直接而且迅速地加入系统。另外一个优点是不需要的模块将不会被加载到内存中，因此微内核就可以更有效地利用内存。 &emsp;&emsp;单内核（Monolithic kernel):单内核是一个很大的进程。它的内部又可以被分为若干模块（或者是层次或其他）。但是在运行的时候，它是一个独立的二进制大映像。其模块间的通信是通过直接调用其他模块中的函数实现的，而不是消息传递。 &emsp;&emsp;单内核的支持者声称微内核的消息传递开销引起了效率的损失，微内核的支持者则认为因此而增加的内核设计的灵活性和可维护性可以弥补任何损失。 &emsp;&emsp;Linux是一个单内核结构，也就是说，Linux运行在单独的内核地址空间。同时吸收了微内核的优点：模块化设计，支持动态装载内核模块。Linux还避免了微内核设计上的缺陷，让一切都运行在内核态，直接调用函数，无需消息传递。]]></content>
      <categories>
        <category>Linux内核</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
        <tag>Linux</tag>
        <tag>微内核</tag>
        <tag>单内核</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[map容器]]></title>
    <url>%2F2019%2Fmap%E5%AE%B9%E5%99%A8%2F</url>
    <content type="text"><![CDATA[一、map容器概述&emsp;&emsp;map的特性是，所有元素都会根据元素的键值被自动排序。map所有元素都是pair，同时拥有实值(value)和键值(key)。pair的第一元素被视为键值，第二元素被视为实值。map并不允许两个元素拥有相同的键值。 &emsp;&emsp;我们不可以通过map的迭代器改变map的键值，因为map的键值关系到map元素的排列规则，任意改变map键值将会严重破坏map组织。如果想要修改元素的实值，是可以的。 &emsp;&emsp;map和list拥有相同的某些性质，当对它的容器元素进行新增操作或者删除操作时，操作之前的所有迭代器，在操作完成之后依然有效，当然被删除的那个元素的迭代器必然是个例外。 &emsp;&emsp;multimap和map的操作类似，唯一区别是multimap键值可重复。 &emsp;&emsp;map和multimap都是以RB-tree为底层机制。又由于map所开放的各种操作接口，RB-tree也都提供了，所以几乎所有map操作行为的，都只是转调用RB-tree的操作行为而已。 二、map/multimap容器常用API map构造函数 12map&lt;T1,T2&gt; mapTT;//map默认构造函数map(const map&amp;map);//拷贝构造函数 map赋值操作 12map&amp;operator=(const map&amp;mp);//重载等号操作符swap(mp);//交换两个集合容器 map大小操作 12size();//返回容器中元素的数目empty();//判断容器是否为空 map插入数据元素操作 1234567map.insert(1);//往容器中插入元素，返回pair&lt;iterator,bool&gt;map&lt;int,string&gt;mapStu;//通过pair方式插入对象mapStu.insert(pair&lt;int,string&gt;(3,"Aoki"));//通过pair方式插入对象mapStu.insert(make_pair(-1,"Aoki"));//通过value_type的方式插入对象mapStu.insert(map&lt;int,string&gt;::value_type(1,"Aoki"));mapStu[3]="Aoki";mapStu[5]="青木"; map删除操作 1234clear();//删除所有元素erase(pos);//删除pos迭代器所指元素，返回下一个元素的迭代器erase(beg,end);//删除区间[beg,end)的所有元素，返回下一个元素的迭代器erase(keyElem);//删除容器中key为keyElem的对组 map查找操作 12345find(key);//查找键key是否存在，若存在，返回该键的元素的迭代器，若不存在，返回map.end()count(keyElem);//返回容器中key为keyElem的对组个数。对于map来说，要么是0，要么是1，对于multimap来说，值可能大于1lower_bound(keyElem);//返回第一个key&gt;=keyElem元素的迭代器upper_bound(keyElem);//返回第一个key&gt;keyElem元素的迭代器equal_range(keyElem);//返回容器中key与keyElem相等的上下限的两个迭代器 三、map容器示例123456789101112131415161718192021void test01()&#123; map&lt;int, string&gt; m1; m1.insert(make_pair(1, "张三")); m1.insert(make_pair(2, "李四")); m1.insert(pair&lt;int, string&gt;(3, "李五")); m1.insert(map&lt;int, string&gt;::value_type(4, "张六")); m1[5] = "张四"; for (map&lt;int, string&gt;::iterator it = m1.begin(); it != m1.end(); it++) &#123; cout &lt;&lt; "ID:" &lt;&lt; it-&gt;first &lt;&lt; " 姓名：" &lt;&lt; it-&gt;second &lt;&lt; endl; &#125; if (m1.empty()) &#123; cout &lt;&lt; "map为空" &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; "size=" &lt;&lt; m1.size() &lt;&lt; endl; &#125;&#125; 执行结果： 12345678910111213141516171819202122232425262728293031323334void test02()&#123; map&lt;int, int&gt;m2; m2.insert(make_pair(1, 10)); m2.insert(make_pair(2, 50)); m2.insert(make_pair(3, 40)); m2.insert(make_pair(4, 60)); m2.insert(make_pair(5, 10)); for (map&lt;int, int&gt;::iterator it1 = m2.begin(); it1 != m2.end(); it1++) &#123; cout &lt;&lt; "key:" &lt;&lt; (*it1).first &lt;&lt; " value:" &lt;&lt; (*it1).second &lt;&lt; endl; &#125; m2.erase(3); for (map&lt;int, int&gt;::iterator it1 = m2.begin(); it1 != m2.end(); it1++) &#123; cout &lt;&lt; "key:" &lt;&lt; (*it1).first &lt;&lt; " value:" &lt;&lt; (*it1).second &lt;&lt; endl; &#125; if (m2.find(5) != m2.end()) &#123; cout &lt;&lt; "找到了" &lt;&lt; endl; cout &lt;&lt; "ID:" &lt;&lt; m2.find(5)-&gt;first &lt;&lt; " value:" &lt;&lt; m2.find(5)-&gt;second &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; "没有找到" &lt;&lt; endl; &#125; map&lt;int, int&gt;::iterator pos = m2.lower_bound(4); cout &lt;&lt; "ID:" &lt;&lt; pos-&gt;first &lt;&lt; " value:" &lt;&lt; pos-&gt;second &lt;&lt; endl; map&lt;int, int&gt;::iterator pos1 = m2.upper_bound(4); cout &lt;&lt; "ID:" &lt;&lt; pos-&gt;first &lt;&lt; " value:" &lt;&lt; pos-&gt;second &lt;&lt; endl; pair&lt;map&lt;int, int&gt;::iterator, map&lt;int, int&gt;::iterator&gt;ret = m2.equal_range(4); cout &lt;&lt; "ID:" &lt;&lt; ret.first-&gt;first &lt;&lt; " value:" &lt;&lt; ret.first-&gt;second &lt;&lt; endl; cout &lt;&lt; "ID:" &lt;&lt; ret.second-&gt;first &lt;&lt; " value:" &lt;&lt; ret.second-&gt;second &lt;&lt; endl;&#125; 执行结果： 四、multimap示例12345678910111213void test03()&#123; multimap&lt;int, int&gt;mulmap; mulmap.insert(make_pair(1, 15)); mulmap.insert(make_pair(1, 20)); mulmap.insert(make_pair(1, 25)); mulmap.insert(make_pair(1, 5)); for (multimap&lt;int, int&gt;::iterator it0 = mulmap.begin(); it0 != mulmap.end(); it0++) &#123; cout &lt;&lt; "ID：" &lt;&lt; it0-&gt;first &lt;&lt; " value:" &lt;&lt; it0-&gt;second &lt;&lt; endl; &#125; cout &lt;&lt; "键值为1的对组的个数：" &lt;&lt; mulmap.count(1) &lt;&lt; endl;&#125; 执行结果： 五、源码地址​ map示例源码]]></content>
      <categories>
        <category>STL</category>
      </categories>
      <tags>
        <tag>STL</tag>
        <tag>map容器</tag>
        <tag>multimap</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[set容器]]></title>
    <url>%2F2019%2Fset%E5%AE%B9%E5%99%A8%2F</url>
    <content type="text"><![CDATA[一、关联式容器&emsp;&emsp;标准的STL关联式容器分为set(集合)和map(映射表)两大类，以及这两大类的衍生体multiset（多键集合）和multimap（多键映射表）。这些容器的底层机制均以RB-tree(红黑树)完成。RB-tree也是一个独立的容器，但并不开放给外界使用。 &emsp;所谓关联式容器，观念上类似关联式数据库（实际上则简单的多）：每笔数据（每个元素）都有一个键值（key）和一个实值（value）。当元素被插入到关联式容器中时，容器内部结构便依照其键值大小，以某种特定规则将这个元素放置在适当的位置。关联式容器没有所谓头尾，所以不会有所谓push_back()、push_front()、pop_back()、pop_front()、begin()、end()这样的操作行为。 &emsp;&emsp;一般而言，关联式容器的内部结构是一个平衡二叉树，以便获得良好的搜寻效率。平衡二叉树有许多种类型，包括AVL-tree、RB-tree、AA-tree,其中最被广泛运用于STL的是RB-tree(红黑树)。 二、set&emsp;&emsp;set的特性是，所有元素都会根据元素的键值自动被排序。set不像map那样可以同时拥有实值(value)和键值(key)，set元素的键值就是实值，实值就是键值。set不允许两个元素有相同的键值。 &emsp;&emsp;我们不可以通过set的迭代器改变set元素的值，因为set元素的值就是其键值，关系到set元素的排序规则。如果任意改变set元素值，会严重破坏set组织。在set源代码中，set&lt;T&gt;::iterator被定义为底层RB-tree的const_iterator。换句话说，set iterator是一种constanit iterators。 &emsp;&emsp;set拥有与list相同的某些性质：当客户端对它进行元素新增操作(insert)或删除操作(erase)时，操作之前的所有迭代器，在操作完成之后都依然有效。当然被删除的那个元素的迭代器必然是个例外。 &emsp;&emsp;由于RB-tree是一种平衡二叉树，自动排序的效果很不错，所以标准的STL set即以RB-tree为底层机制。又由于set所开放的各种操作接口，RB-tree也都提供了，所以几乎所有的set操作行为，都只是转调RB-tree的操作行为而已。 1）set常用API set构造函数 123set&lt;T&gt; st;//set默认构造函数multiset&lt;T&gt; mst;//multiset默认构造函数set(const set&amp;st);//拷贝构造函数 set赋值操作 12set&amp; operator=(const set&amp; st);//重载等号操作符swap(st);//交换两个集合容器 set大小操作 12size();//返回容器中元素的数目empty();//判断容器是否为空 set插入和删除操作 12345insert(elem);//在容器中插入元素clear();//清除所有元素erase(pos);//删除pos迭代器所指的元素，返回下一个元素的迭代器erase(beg,end);//删除区间[beg,end)的所有元素，返回下一个元素的迭代器erase(elem);//删除容器中值为elem的元素 set查找操作 12345find(key);//查找键key是否存在，若存在，返回该键的元素的迭代器；若不存在，返回set.end()count(key);//查找键key的元素个数lower_bound(keyElem);//返回第一个key&gt;=keyElem元素的迭代器upper_bound(keyElem);//返回第一个key&gt;keyElem元素的迭代器equal_range(keyElem);//返回容器中key与keyElem相等的上下限的两个迭代器 2）示例1234567891011121314151617181920void test01()&#123; set&lt;int&gt; st = &#123; 1,2,3,4,5,6 &#125;; DisplaySet(st);//输出set中的元素 if (st.empty()) &#123; cout &lt;&lt; "set为空" &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; "size=" &lt;&lt; st.size() &lt;&lt; endl; &#125; st.erase(st.begin()); DisplaySet(st); st.erase(6); DisplaySet(st); st.insert(15); st.insert(10); DisplaySet(st);&#125; 执行结果： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869void test02()&#123; set&lt;int&gt;st; st.insert(5); st.insert(1); st.insert(9); st.insert(3); st.insert(7); //查找操作 set&lt;int&gt;::iterator it1 = st.find(3); if (it1 != st.end()) &#123; cout &lt;&lt; "找到了，值为：" &lt;&lt; *it1 &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; "没有找到" &lt;&lt; endl; &#125; set&lt;int&gt;::iterator it0 = st.find(8); if (it0 != st.end()) &#123; cout &lt;&lt; "找到了，值为：" &lt;&lt; *it0 &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; "没有找到" &lt;&lt; endl; &#125; int num = st.count(2);//2的个数 cout &lt;&lt; "2的个数为：" &lt;&lt; num &lt;&lt; endl; //lower_bound(keyElem);//返回第一个key&gt;=keyElem元素的迭代器 set&lt;int&gt;::iterator pos = st.lower_bound(3); if (pos != st.end()) &#123; cout &lt;&lt; "lower_bound(3)的值为：" &lt;&lt; *pos &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; "没有找到" &lt;&lt; endl; &#125; //upper_bound(keyElem);//返回第一个key&gt;keyElem元素的迭代器 set&lt;int&gt;::iterator it2 = st.upper_bound(3); if (it2 != st.end()) &#123; cout &lt;&lt; "找到了upper_bound(3)的值为：" &lt;&lt; *it2 &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; "没有找到" &lt;&lt; endl; &#125; //equal_range(keyElem);//返回容器中key与keyElem相等的上下限的两个迭代器 pair&lt;set&lt;int&gt;::iterator, set&lt;int&gt;::iterator&gt;ret = st.equal_range(3); if (ret.first != st.end()) &#123; cout &lt;&lt; "找到equal_range中lower_bound的值为：" &lt;&lt; *(ret.first) &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; "没有找到" &lt;&lt; endl; &#125; if (ret.second != st.end()) &#123; cout &lt;&lt; "找到equal_range中upper_bound为：" &lt;&lt; *(ret.second) &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; "没有找到" &lt;&lt; endl; &#125;&#125; 执行结果： 三、multiset容器&emsp;&emsp;multiset特性及用于和set完全相同，唯一的差别在于它允许键值重复。 1）示例12345678910void test03()&#123; multiset&lt;int&gt;muset; muset.insert(15); muset.insert(20); muset.insert(15); DisplayMultiset(muset); cout &lt;&lt; "元素个数为："; cout &lt;&lt; muset.size() &lt;&lt; endl;&#125; 执行结果： 四、对组（pair）&emsp;&emsp;对组(pair)将一对值组合成一个值，这一对值可以具有不同的数据类型，两个值可以分别用pair的两个公有属性first和second访问。 1）示例1234567891011121314151617181920212223class Compare&#123;//利用仿函数指定排序规则public: bool operator()(pair&lt;string,int&gt; p1,pair&lt;string,int&gt;p2) &#123; return p1.second &gt; p2.second; &#125;&#125;;void test04()&#123; pair&lt;string, int&gt; p1("Aoki", 23); pair&lt;string, int&gt; p2("张三", 25); pair&lt;string, int&gt; p3("李四", 26); set&lt;pair&lt;string, int&gt;, Compare&gt; pSt;; pSt.insert(p1); pSt.insert(p2); pSt.insert(p3); for (set&lt;pair&lt;string, int&gt;, Compare&gt;::iterator it = pSt.begin(); it != pSt.end(); it++) &#123; cout &lt;&lt; "姓名：" &lt;&lt; it-&gt;first &lt;&lt; " 年龄：" &lt;&lt; it-&gt;second &lt;&lt; endl; &#125;&#125; 执行结果： 五、源码地址​ set示例源码]]></content>
      <categories>
        <category>STL</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>set容器</tag>
        <tag>pair</tag>
        <tag>Multiset</tag>
        <tag>关联式容器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[选择排序——直接选择排序和堆排序的实现]]></title>
    <url>%2F2019%2F%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F%E2%80%94%E2%80%94%E7%9B%B4%E6%8E%A5%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F%E5%92%8C%E5%A0%86%E6%8E%92%E5%BA%8F%E7%9A%84%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[一、选择排序概述&emsp;&emsp;选择排序的基本思想是：不断从待排序的对象集合中选取关键码最小的对象放到已排序对象集合的后面，直到集合这两个所有对象都取完为止。 &emsp;&emsp;常用的选择排序方法有直接排序法和堆排序法。 二、直接选择排序的实现&emsp;&emsp;直接选择排序是一种简单且直观的排序方法。直接选择排序的思想是：从待排序的对象集合中选择关键码最小的对象，并将它与原始对象集合中的第一个对象交换位置；然后从不包括第一个位置对象的对象集合中选取关键码最小的对象，并将它与原始对象集合中的第二个元素交换位置；如此重复，直到对象集合中只剩下一个对象为止。 1)直接选择排序的实现1234567891011121314151617181920212223template&lt;class T&gt;void DirectSelectSort(T arr[], int n)&#123;//对arr[0]~arr[n-1]进行排序 T temp; int CurrentMin;//当前最小值的位置 for (int i = 0; i &lt; n ; i++) &#123; CurrentMin = i; for (int j = i + 1; j &lt; n ; j++) &#123; if (arr[j] &lt; arr[CurrentMin]) &#123; CurrentMin = j;//记录当前最小值的下标 &#125; &#125; if (CurrentMin != i) &#123; temp = arr[i]; arr[i] = arr[CurrentMin]; arr[CurrentMin] = temp; &#125; &#125;&#125; 2)测试函数123456789101112131415161718void test()&#123; int arr[] = &#123; 64,55,7,5,89,15,22,25 &#125;; int n = sizeof(arr) / sizeof(arr[0]); cout &lt;&lt; "原始数组为：" &lt;&lt; endl; for (int i = 0; i &lt; n; i++) &#123; cout &lt;&lt; arr[i] &lt;&lt; " "; &#125; cout &lt;&lt; endl; DirectSelectSort&lt;int&gt;(arr, n); cout &lt;&lt; "排序结果为：" &lt;&lt; endl; for (int i = 0; i &lt; n; i++) &#123; cout &lt;&lt; arr[i] &lt;&lt; " "; &#125; cout &lt;&lt; endl;&#125; 3）执行结果 4）时空复杂度分析 时间复杂度 在直接选择排序中，第1次排序要进行n-1次比较，第2次排序要进行n-2次比较，……，第n-1次排序要进行1次比较。所以总比较次数为$\frac{n(n-1)}{2}$ 在各次排序中，对象的移动次数最好为0，最坏为3次。 时间复杂度为O($n^2$) 空间复杂度 直接选择排序算法的空间复杂度为O(1) 直接选择排序算法是一种稳定的排序方法 5）源码地址​ 直接插入排序实现源码 三、堆排序的实现&emsp;&emsp;堆排序是利用堆数据结构进行的排序方法。堆式结点间数据元素的关键码具有层次次序关系的完全二叉树。堆排序算法的思想是：建立一个堆结构的数组对象，不断删除堆顶对象并依次存于数组后面空出的存储单元中，当n个对象的数组中第n-1个对象被这样操作后，数组中的对象即排好序了。 1）堆排序的实现1234567891011template&lt;class T&gt;void HeapSort(T arr[], int n)&#123; MaxHeap&lt;T&gt; heap(arr, n); T temp; for (int i = n - 1; i &gt; 0; i--) &#123; temp = heap.Delete(); arr[i] = temp; &#125;&#125; 堆排序的实现借助了之前实现的最大堆，最大堆的堆顶始终是最大值。 2）测试函数123456789101112131415161718void test()&#123; int arr[] = &#123; 64,55,7,5,89,15,22,25 &#125;; cout &lt;&lt; "原数组元素为：" &lt;&lt; endl; int n = sizeof(arr) / sizeof(arr[0]); for (int i = 0; i &lt; (sizeof(arr) / sizeof(arr[0])); i++) &#123; cout &lt;&lt; arr[i] &lt;&lt; " "; &#125; cout &lt;&lt; endl; HeapSort&lt;int&gt;(arr, (sizeof(arr) / sizeof(arr[0]))); cout &lt;&lt; "利用最大堆排序结果：" &lt;&lt; endl; for (int i = 0; i &lt; n; i++) &#123; cout &lt;&lt; arr[i] &lt;&lt; " "; &#125; cout &lt;&lt; endl;&#125; 3）执行结果 4）时空复杂度分析 堆化数组最坏情况的时间复杂度为O(nlgn)，在堆中删除一个元素最坏情况的时间复杂度为O(lgn)。因此，堆排序算法最坏情况的时间复杂度是O(nlgn) 堆排序算法的空间复杂度为O(1)。 堆排序是一种不稳定的排序方法。 5）源码地址​ 堆排序实现源码]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>排序</tag>
        <tag>选择排序</tag>
        <tag>直接选择排序</tag>
        <tag>堆排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[堆——最小堆和最大堆的实现]]></title>
    <url>%2F2019%2F%E5%A0%86%E2%80%94%E2%80%94%E6%9C%80%E5%B0%8F%E5%A0%86%E5%92%8C%E6%9C%80%E5%A4%A7%E5%A0%86%E7%9A%84%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[一、堆概述 堆(Heap)是结点间数据元素的关键码具有层次次序关系的完全二叉树； 堆是二叉树的顺序存储结构的一个应用； 堆可用于应用程序希望能直接访问一个表中的最小或最大数据元素的应用问题； 堆结构的重要价值在于，在所有能直接访问一个表中的最小或最大数据元素的算法中，堆结构方法是时间效率最高的一种。 二、堆定义&emsp;&emsp;设数据元素是一个有多个域的复合结构，其中有一个称为关键码的域，定义n个数据元素$d_0$、$d_1$、$d_2$、……、$d_{n-1}$所对应的关键码域为$k_0$、$k_1$、$k_2$、……、$k_{n-1}$，假设数据元素$d_0$、$d_1$、$d_2$、……、$d_{n-1}$按完全二叉树的顺序存放在一个一维数组中，当2i+1&lt;n时有： $k_i&lt;=k_{2i+1}$($k_i$中的i是元素在数组中的下标) 当2i+2&lt;n时有： $k_i&lt;=k_{2i+2}$($k_i$中的i是元素在数组中的下标) 这样的数据元素集合称为最小堆。 与此类似，当2i+1&lt;n时有： $k_i&gt;=k_{2i+1}$($k_i$中的i是元素在数组中的下标) 当2i+2&lt;n时有： $k_i&gt;=k_{2i+2}$($k_i$中的i是元素在数组中的下标) 这样的数据元素集合称为最大堆。 根据堆的定义可以推知堆有下面两个性质： 最小堆的根结点时堆中值最小的数据元素，最大堆的根结点时堆中值最大的数据元素，我们称之为堆顶元素 对于最小堆，从根结点到每个叶结点的路径上，数据元素组成的的序列都是非递减有序的。对于最大堆，从根结点到每个叶结点的路径上，数据元素组成的序列都是非递增有序的 三、最小堆的实现1）最小堆类1234567891011121314151617181920212223template&lt;class T&gt;class MinHeap&#123;public: MinHeap(int maxsize);//构造函数 MinHeap(T arr[], int n);//拷贝构造函数，将n个arr元素堆化 ~MinHeap();//析构函数 //最小堆的相关操作 void Insert(const T&amp; item);//插入元素item T Delete();//删除堆中最小元素 T GetHeapTop();//获取堆顶元素 int HeapSize();//获取堆中元素个数 bool isHeapEmpty();//堆是否为空 bool isHeapFull();//堆是否已满 void Display();//打印堆private: T* heapArray;//存放数据元素的数组 int markArray;//标记 int MaxHeapSize;//可存元素个数 int heapSize;//当前元素个数 void FilterUp(int i);//插入元素后进行堆化 void FilterDown(int i);//删除元素后进行堆化&#125;; 2)最小堆类部分成员函数的实现&emsp;&emsp;插入成员函数是在原先的数据元素已经是堆的基础上，插入一个数据元素后，调整使之继续维持为一个堆。我们把要插入的数据元素放在堆尾。虽然插入前的数据元素集合构成堆，但是新的数据元素插入后可能违背堆的定义。 &emsp;&emsp;插入新元素后继续维持为一个最小堆的算法是 看新插入元素的值是否小于其双亲的值，如果不小于，则仍维持为一个最小堆，算法结束； 如果小于，则交换两者的值； 交换后有可能在更上一层仍然不能满足最小堆的定义，需继续交换，直到满足最小堆的定义为止。 最小堆插入图示： 123456789101112131415161718192021222324252627282930313233343536373839//插入元素时重新堆化template&lt;class T&gt;void MinHeap&lt;T&gt;::FilterUp(int i)&#123;//调整插入的新元素使之上升到合适的结点位置 int currentPos, parentPos; T target; currentPos = i; target = heapArray[i]; parentPos = (i-1)/2;//获取结点i的双亲结点位置 while (currentPos != 0) &#123;//到根结点为止 if (heapArray[parentPos] &lt;= target) return; else &#123; heapArray[currentPos] = heapArray[parentPos];//双亲结点下降 currentPos = parentPos;//当前结点为双亲结点，重新开始 parentPos = (currentPos - 1) / 2;//计算当前结点的双亲结点 &#125; &#125; heapArray[currentPos] = target;//插入新元素&#125;//插入template&lt;class T&gt;void MinHeap&lt;T&gt;::Insert(const T&amp; item)&#123; if (heapSize == MaxHeapSize) &#123; cout &lt;&lt; "堆已满！" &lt;&lt; endl; return; &#125; else &#123; heapArray[heapSize] = item; FilterUp(heapSize);//新插入结点上移，进行堆化 heapSize++; &#125;&#125; &emsp;&emsp;删除成员函数是删除堆顶的最小的数据元素。删除堆顶元素后，我们用堆中最后一个元素填充堆顶位置，此时必然违反堆的定义。 &emsp;&emsp;删除后继续维持为一个最小堆的算法是： 令堆顶位置为当前位置，看当前位置元素的值时候小于其左右孩子中的最小值，如果不小于，则仍然维持为一个最小堆，算法结束； 如果小于，则交换两者的值； 交换后有可能在更下一层仍然不满足最小堆的定义，需继续交换，直到满足堆的定义为止。 最小堆删除图示： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546//删除元素时重新堆化template&lt;class T&gt;void MinHeap&lt;T&gt;::FilterDown(int i)&#123;//调整第i个结点使之下移到合适的位置 int currentPos, childPos; T target; currentPos = i; childPos = 2 * i + 1;//计算左孩子结点 target = heapArray[i]; while (childPos &lt; heapSize) &#123;//childPos为当前结点的左右孩子中值较小的孩子结点位置 if (childPos &lt; heapSize &amp;&amp; (heapArray[childPos + 1] &lt;= heapArray[childPos])&amp;&amp;childPos+1&lt;heapSize) &#123; childPos = childPos + 1; &#125; if (target &lt; heapArray[childPos]) break;//满足最小堆的定义 else &#123; heapArray[currentPos] = heapArray[childPos];//孩子结点上升 currentPos = childPos;//从孩子结点位置重新开始 childPos = childPos * 2 + 1;//当前结点的孩子结点 &#125; &#125; heapArray[currentPos] = target;//把填充的堆顶元素插入&#125;//删除堆中最小元素template&lt;class T&gt;T MinHeap&lt;T&gt;::Delete()&#123; if (heapSize == 0) &#123; cout &lt;&lt; "堆为空！" &lt;&lt; endl; exit(1); &#125; else &#123; T item = heapArray[0];//保存原堆顶元素 heapArray[0] = heapArray[heapSize - 1];//用最后一个元素填充堆顶位置 heapSize--; FilterDown(0);//下移当前堆顶元素 return item;//返回原堆顶元素 &#125;&#125; &emsp;&emsp;数组的堆化是把一个有n个数据元素的非堆的数组构造为一个堆。 &emsp;&emsp;数组的堆化过程可以设计成递推过程。在完全二叉树形式的数组中，所有叶结点都满足堆的定义，令最后一个叶结点的双亲结点为当前结点，其下标为：currentPos=((n-1)-1)/2 &emsp;&emsp;对于结点currentPos，其左右孩子结点已满足堆的定义，使结点currentPos也满足堆的定义的过程与插入过程中使用的FilterDown相同。因此使用参数currentPos调用FilterDown(currentPos)；在结点currentPos满足最小堆的定义后，使当前结点currentPos=currentPos-1，对于结点currentPos，其左右孩子结点已满足最小堆的定义，再次用参数currentPos调用FilterDown(currentPos)；这样的过程一直进行到当前结点currentPos=0，即到达根结点为止。 数组堆化图示： 1234567891011121314151617181920212223//将数组堆化template&lt;class T&gt;MinHeap&lt;T&gt;::MinHeap(T arr[], int n)&#123; if (n &lt; 0) &#123; cout &lt;&lt; "非法参数!" &lt;&lt; endl; exit(1); &#125; else &#123; MaxHeapSize = n; heapSize = n; heapArray = arr; int currentPos = (n - 1) / 2;//计算第一个非叶子结点 while (currentPos &gt;= 0) &#123; FilterDown(currentPos);//调整结点currentPos使之下移到合适的位置 currentPos--; &#125; markArray = 1;//置构造函数标记 &#125;&#125; 3)测试函数12345678910111213141516void test()&#123; int arr[] = &#123; 24,10,90,77,16,25,33,89,67 &#125;; cout &lt;&lt; "原数组元素为：" &lt;&lt; endl; for (int i = 0; i &lt; (sizeof(arr) / sizeof(arr[0])); i++) &#123; cout &lt;&lt; arr[i] &lt;&lt; " "; &#125; cout &lt;&lt; endl; MinHeap&lt;int&gt; heap(arr, (sizeof(arr) / sizeof(arr[0]))); cout &lt;&lt; "输出堆中元素：" &lt;&lt; endl; heap.Display(); cout &lt;&lt; heap.Delete() &lt;&lt; "已被删除！" &lt;&lt; endl; cout &lt;&lt; "输出堆中元素：" &lt;&lt; endl; heap.Display();&#125; 4）执行结果 5)源码地址​ 最小堆的实现源码 四、最大堆的实现1)最大堆类1234567891011121314151617181920212223template&lt;class T&gt;class MaxHeap&#123;public: MaxHeap(int maxsize);//构造函数 MaxHeap(T arr[], int n);//拷贝构造函数，将n个arr元素堆化 ~MaxHeap();//析构函数 //最小堆的相关操作 void Insert(const T&amp; item);//插入元素item T Delete();//删除堆中最大元素 T GetHeapTop();//获取堆顶元素 int HeapSize();//获取堆中元素个数 bool isHeapEmpty();//堆是否为空 bool isHeapFull();//堆是否已满 void Display();//打印堆private: T* heapArray;//存放数据元素的数组 int markArray;//标记 int MaxHeapSize;//可存元素个数 int heapSize;//当前元素个数 void FilterUp(int i);//插入元素后进行堆化 void FilterDown(int i);//删除元素后进行堆化&#125;; 2)最大堆类部分成员函数的实现最大堆类的成员函数的实现与最小堆类成员函数的实现基本相同，这里只列出部分成员的函数实现，不做解释。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100template&lt;class T&gt;inline MaxHeap&lt;T&gt;::MaxHeap( T arr[], int n)&#123; if (n &lt; 0) &#123; cout &lt;&lt; "非法参数！" &lt;&lt; endl; exit(1); &#125; else &#123; heapArray = arr; heapSize = n; MaxHeapSize = n; markArray = 1; int currentPos = (n - 1) / 2;//计算第一个非叶子结点的位置 while (currentPos &gt;= 0) &#123; FilterDown(currentPos);//下移当前结点到合适的位置 currentPos--; &#125; &#125;&#125;template&lt;class T&gt;inline void MaxHeap&lt;T&gt;::Insert(const T&amp; item)&#123;//插入元素 if (heapSize == MaxHeapSize) &#123; cout &lt;&lt; "非法参数！" &lt;&lt; endl; exit(1); &#125; else &#123; heapArray[heapSize] = item; FilterUp(heapSize); heapSize++; &#125;&#125;template&lt;class T&gt;inline T MaxHeap&lt;T&gt;::Delete()&#123; if (heapSize == 0) &#123; cout &lt;&lt; "堆为空！" &lt;&lt; endl; exit(1); &#125; else &#123; T item = heapArray[0]; heapArray[0] = heapArray[heapSize - 1];//用最后一个元素填充堆顶元素 heapSize--; FilterDown(0); return item; &#125;&#125;template&lt;class T&gt;inline void MaxHeap&lt;T&gt;::FilterUp(int i)&#123; int currentPos, ParentPos; T target = heapArray[i]; currentPos = i; ParentPos = (i - 1) / 2; while (currentPos != 0) &#123; if (heapArray[ParentPos] &gt;= target)//已经是最大堆 break; else &#123; heapArray[currentPos] = heapArray[ParentPos];//双亲结点下移 currentPos = ParentPos;//双亲结点为当前结点 ParentPos = (currentPos - 1) / 2;//找到当前结点的双亲结点 &#125; &#125; heapArray[currentPos] = target;//插入新元素&#125;template&lt;class T&gt;inline void MaxHeap&lt;T&gt;::FilterDown(int i)&#123; int currentPos,childPos; T target = heapArray[i]; currentPos = i; childPos = i * 2 + 1; while (childPos &lt; heapSize) &#123; if (childPos + 1 &lt; heapSize &amp;&amp; (heapArray[childPos + 1] &gt;= heapArray[childPos])&amp;&amp;childPos+1&lt;heapSize) childPos = childPos + 1;//选择两个孩子结点中较大的一个作为孩子结点为位置 if (target &gt;= heapArray[childPos]) break;//满足最大堆的性质 else &#123; heapArray[currentPos] = heapArray[childPos];//孩子结点上移 currentPos = childPos;//当前孩子结点作为当前结点 childPos = childPos * 2 + 1;//当前结点的孩子结点位置 &#125; &#125; heapArray[currentPos] = target;//把填充的堆顶元素插入&#125; 3）测试函数12345678910111213141516void test()&#123; int arr[] = &#123; 24,10,90,77,16,25,33,89,67 &#125;; cout &lt;&lt; "原数组元素为：" &lt;&lt; endl; for (int i = 0; i &lt; (sizeof(arr) / sizeof(arr[0])); i++) &#123; cout &lt;&lt; arr[i] &lt;&lt; " "; &#125; cout &lt;&lt; endl; MaxHeap&lt;int&gt; heap(arr, (sizeof(arr) / sizeof(arr[0]))); cout &lt;&lt; "输出堆中元素：" &lt;&lt; endl; heap.Display(); cout &lt;&lt; heap.Delete() &lt;&lt; "已被删除！" &lt;&lt; endl; cout &lt;&lt; "输出堆中元素：" &lt;&lt; endl; heap.Display();&#125; 4）执行结果 5）源码地址​ 最大堆的实现源码]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>堆</tag>
        <tag>最大堆</tag>
        <tag>最小堆</tag>
        <tag>优先队列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[交换排序——冒泡快速和快速排序的实现]]></title>
    <url>%2F2019%2F%E4%BA%A4%E6%8D%A2%E6%8E%92%E5%BA%8F%E2%80%94%E2%80%94%E5%86%92%E6%B3%A1%E5%BF%AB%E9%80%9F%E5%92%8C%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E7%9A%84%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[一、概述&emsp;&emsp;利用交换对象的位置进行排序的方法称之为交换排序。常用的交换排序方法有冒泡排序法和快速排序法。快速排序法是一种分区交换排序方法。 二、冒泡排序 冒泡排序法是一种简单常用的排序方法。 冒泡排序的思想是：对n个对象的对象集合，设第一个对象下标为0，依次把对象下标i定为0,1,2,3,……，n-2，然后依次将待排序对象集合中下标为i对象的关键码与下标为i+1对象的关键码进行比较，若前者大于后者，则交换两者的位置；后者不交换。 当这样的过程完成后，n个对象的数组的最后一个单元中就存放了对象集合中关键码最大的对象。 然后，不考虑这个已排好序对的对象，重新进行这样的过程，当这样的过程完成后，n-1个对象的数组的最后一个单元中就存放了对象集合中关键码最大的对象。当这样的过程进行n-1次，对象集合中就是排好序的对象集合。 1）冒泡排序的实现12345678910111213141516171819202122232425template&lt;class T&gt;void BubbleSort(T arr[], int n)&#123;//对arr数组元素进行排序 int i, j, flag=1; T temp; for (i = 0; i &lt; n &amp;&amp; flag == 1; i++) &#123; flag = 0; /* flag用于标记本次交换排序过程是否 有交换动作，若本次交换排序过程没有交换动作， 则说明对象集合已全部排好序，就可提前结束排序过程 */ for (j = 0; j &lt; n-i; j++) &#123; if (arr[j] &gt; arr[j + 1]) &#123; flag = 1; temp = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = temp; &#125; &#125; &#125;&#125; 2）测试函数123456789101112131415161718void test()&#123; int arr[] = &#123; 5,15,1,48,23,2,5,4,9 &#125;; int n = sizeof(arr) / sizeof(arr[0])-1; cout &lt;&lt; "原数组为：" &lt;&lt; endl; for (int i = 0; i &lt; n; i++) &#123; cout &lt;&lt; arr[i] &lt;&lt; " "; &#125; cout &lt;&lt; endl; BubbleSort(arr, n); cout &lt;&lt; "排序结果为：" &lt;&lt; endl; for (int j = 0; j &lt; n; j++) &#123; cout &lt;&lt; arr[j] &lt;&lt; " "; &#125; cout &lt;&lt; endl;&#125; 3）执行结果 4）时空复杂度分析 时间复杂度: 冒泡排序算法的最好情况是对象集合已全部排好序，这时循环n-1次，每次循环都因没有交换动作而退出，因此冒泡排序最好情况的时间复杂度是O(n); 冒泡排序的最坏情况是对象集合全部逆序存放，这时循环n-1次，整个循环的比较次数和移动次数为： 比较次数=$\sum^{1}_{i=n-1}{i}$=$\frac{n(n-1)}{2}$ 移动次数=3$\sum^{i}_{i=n-1}{i}$=$\frac{3n(n-1)}{2}$ 因此，冒泡排序算法最坏情况的时间复杂度为O($n^2$) 空间复杂度： 冒泡排序算法的空间复杂度为O(1)。显然，冒泡排序算法是一种稳定的排序方法。 5）源码地址​ 冒泡排序实现源码 三、快速排序 快速排序又称为分区交换排序。 快速排序算法的基本思想是：从待排序的对象数组中任取一个个对象（通常是取对象数组中的第一个对象）作为基准，调整对象数组中各个对象在数组中的位置，使排在该对象前面对象的关键码均小于该对象的关键码，使排在该对象后面对象的关键码均大于该对象的关键码。 这样的交换过程结束后，一方面将该对象放在未来排好序的对象数组中该对象应在的位置上；另一方面将该对象数组中的对象以该对象为基准划分成了两个子对象数组，位于该基准对象左边子对象数组中对象的关键码均小于该对象的关键码，位于该基准对象右边子对象数组中对象的关键码均大于等于该对象的关键码。 对于这两个子对象数组中的对象分别再进行方法类同的快速排序，当各个子对象数组中的对象个数均小于1时，排序过程结束。显然，快速排序算法过程是递归的过程。 1）快速排序的实现12345678910111213141516171819202122232425262728293031template&lt;class T&gt;int Partition(T arr[], int low, int high)&#123;//表的划分 T pivot;//基准 Swap(arr, low, (low + high) / 2);//交换第一个元素与中间元素 pivot = arr[low];//将交换过来的中间元素作为基准 int last_small = low; for (int i = low + 1; i &lt;= high; i++) &#123; if (arr[i] &lt; pivot) &#123; last_small = last_small + 1; Swap(arr, last_small, i); &#125; &#125; Swap(arr, low, last_small); return last_small;&#125;template&lt;class T&gt;void QuickSort(T arr[], int low, int high)&#123;//快速排序 int q; if (low &lt; high) &#123; q = Partition&lt;T&gt;(arr, low, high); QuickSort(arr, low, q - 1); QuickSort(arr, q + 1, high); &#125;&#125; 2)快速排序的过程&emsp;&emsp;在快速排序中，Partition函数的构造比较重要。Partition函数的算策略有几种，有的策略比本文中的算法要快，但却复杂并且容易出错。本文中的算法更加简单而且易于理解，当然也不慢。实际上，在所有的算法中，它所进行的键比较的次数可能是最少的。 &emsp;&emsp;对于基准的选择，并非一定要选择顺序表的首个元素作为基准，我们可以选择任意一个元素并在划分表的循环开始之前将它与表中的第一个元素交换。实际上，首个元素作为基准经常是一种拙劣的选择，因为一旦此顺序表是已经排过序的，则不会有其他元素再小于此基准，这将导致其中的一个子表为空表。因此，我们在表的近中央位置处选择了一个基准，希望这种选择可以把关键码划分在基准两边约各占一半。 &emsp;&emsp;给定一个基准pivot，我们必须重新排列表中的元素并计算一个下标pivot_position，使得基准位于pivot_position，在此下标左边的所有元素的关键码均小于pivot，在其右边的所有元素的关键码均大于或等于pivot。 第一趟排序过程： 3）测试函数123456789101112131415161718void test()&#123; int arr[] = &#123; 5,15,1,48,23,2,5,4,9 &#125;; int n = sizeof(arr) / sizeof(arr[0])-1; cout &lt;&lt; "原数组为：" &lt;&lt; endl; for (int i = 0; i &lt; n; i++) &#123; cout &lt;&lt; arr[i] &lt;&lt; " "; &#125; cout &lt;&lt; endl; QuickSort(arr, 0, n); cout &lt;&lt; "排序结果为：" &lt;&lt; endl; for (int i = 0; i &lt; n; i++) &#123; cout &lt;&lt; arr[i] &lt;&lt; " "; &#125; cout &lt;&lt; endl;&#125; 4）执行结果 5）时空复杂度分析 时间复杂度： 快速排序算法的时间复杂度和各次基准对象的值关系很大。如果每次取得的基准对象的值都能使该对象处于当前对象数组的中间位置上，将原来的对象数组分为两个大小相等的子对象数组，这样的快速排序算法过程相当于一个完全二叉树（即每个结点都把当前对象数组分为两个大小相等的子对象数组结点，n个对象数组的根结点的分解次数就构成一棵完全二叉树）。 这时分解次数等于n个结点的完全二叉树的深度lg2n 每次快速排序过程无论把对象数组怎样划分，全部的比较次数都基本等于n次，所以最好情况下快速排序算法的时间复杂度为O(lgn)。 快速排序算法的最坏情况是n个对象数组的根结点的分解次数构成一棵二叉退化树，一棵二叉退化树的深度为n，所以最坏情况下快速排序算法的时间复杂度为O($n^2$). 一般情况下，基准对象值的分布式随机的，而随机的基准对象值的n个对象数组的根结点的分解次数构成一棵二叉树，这样的二叉树的深度接近lgn，所以快速排序算法的平均时间复杂度为O(nlgn)。 空间复杂度： 快速排序算法需要堆栈空间临时保存递归调用参数，堆栈空间的使用个数与递归调用次数（即n个结点的二叉树的深度）有关，和上述时间复杂度分析类似，最好情况下快速排序算法的空间复杂度为O(lgn); 最坏情况下快速排序算法的空间复杂度为O(n)； 快速排序算法的平均空间复杂度为O(lgn) 5）源码地址​ 快速排序实现源码]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>冒泡排序</tag>
        <tag>快速排序</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[插入排序及其实现]]></title>
    <url>%2F2019%2F%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F%E5%8F%8A%E5%85%B6%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[一、排序的基本概念&emsp;&emsp;排序是将一个无序的数据元素集合整理成按关键码递增（或递减）排列的有规律有序集合的过程。关键码是所定义的数据元素类型中的一个域。 关键码要排序的对象集合可能有多个域，关键码是当前排序时进行比较以确定各个对象位置的域。 在对象集合中，不同的对象其关键码值一定不相同的关键码称为主关键码;不同的对象其关键码值有可能相同的关键码称为次关键码。 排序算法的稳定性&emsp;&emsp;任何排序算法在使用主关键码进行排序时，其排序结果是相同的。当排序算法使用次关键码进行排序时，其排序结果可能相同，也可能不同。 &emsp;&emsp;对于有n个对象集合中的次关键码K[i](i=0,1,2……，n-1)，若K[i]等于K[j](j=0,1,2……，n-1,j!=i),其在排序之前，对象R[i]排在对象R[j]之前，如果在排序之后对象R[i]仍在对象R[j]的前面的排序算法称为稳定的排序算法。否则称为不稳定的排序算法。 &emsp;&emsp;显然，对于一组给定的对象集合，所有稳定的排序算法的排序结果都是相同的，不稳定的排序算法的排序结果有可能相同，也有可能不同。稳定的排序算法通常是应用问题所希望的，因此，排序算法的稳定性是衡量排序算法好坏的一个重要标准。 排序算法的时间复杂度&emsp;&emsp;和所有算法一样，时间复杂度是衡量排序算法好坏的一个重要标准。排序算法的时间复杂度主要表现在算法中对象关键码的比较和对象的移动上。对于有n个对象的集合的排序问题，因为从该集合中找出一个最大（或最小）对象一定要遍历该集合，其时间复杂度为O(n),而进一步将n个对象均排列整齐的最理想情况可对应成完全二叉树结果，其时间复杂度为O(nlgn),因此排序算法最好的时间复杂度为O(nlgn) 排序算法的空间复杂度&emsp;&emsp;和所有算法一样，空间复杂度是衡量排序算法好坏的一个重要标准。排序算法的空间复杂度也就是算法中使用的辅助存储单元的多少。当排序算法中使用的存储单元与排序对象的个数n无关时，其空间复杂度为O(1),因此排序算法最好的空间复杂度为O(1)。空间复杂度为O(1)的排序算法也称为原地排序算法。原地排序算法就是在原来存放对象的数组空间中重新按关键码大小排放对象集合。 二、插入排序&emsp;&emsp;插入排序是一种由初始空集开始，不断地把新的对象插入到数组合适位置的排序方法，常用的插入排序法有直接插入排序、链表插入排序、希尔排序。 直接插入排序 直接插入排序的基本思想是：顺序地把待排序的对象按其关键码值的大小插入到已排序对象集合的适当位置。 假设待排序的对象为R[0]、R[1]、R[2]、……、R[n-1],开始排序时对象集合R[0]因只有一个对象，所以已排好序。 第一次循环准备将对象R[1]插入到已排好序的对象集合R[0]中，这只需要比较K[0]和K[1]，若K[0]&lt;=K[1]，则已排好序，否则将R[1]插入到R[0]之前，这样，对象集合R[0],R[1]已排好序。 第二次循环准备将R[2]插入到已排好序的对象集合R[0],R[1]中，这需要先比较K[2]和K[1]以确定是否需要把R[2]插入到R[1]之前，然后比较K[2]和K[0]以确定是否需要把R[2]插入到R[0]之前。 这样的循环过程一直进行到R[n-1]插入完为止。这时对象集合R[0]、R[1]、R[2]、……、R[n-1]就全部排好序了。 1）直接插入排序的实现1234567891011121314151617template&lt;class T&gt;void InsertSort(T a[], int n)&#123; int i, j; T temp; for (int i = 0; i &lt; n - 1; i++) &#123; temp = a[i + 1]; j = i; while (j &gt; -1 &amp;&amp; temp &lt; a[j]) &#123; a[j + 1] = a[j]; j--; &#125; a[j + 1] = temp; &#125;&#125; 2）测试函数 123456789101112131415161718void test()&#123; int sort[] = &#123; 15,22,6,7,2,1,56,89,14 &#125;; int n = sizeof(sort) / sizeof(sort[0])-1; cout &lt;&lt; "原数组为：" &lt;&lt; endl; for (int i = 0; i &lt; n; i++) &#123; cout &lt;&lt; sort[i] &lt;&lt; " "; &#125; cout &lt;&lt; endl; InsertSort(sort, n); cout &lt;&lt; "排序结果为：" &lt;&lt; endl; for (int i = 0; i &lt; n; i++) &#123; cout &lt;&lt; sort[i] &lt;&lt; " "; &#125; cout &lt;&lt; endl;&#125; 3）执行结果 4）时空复杂度分析 直接插入排序算法的时间复杂度分析可分为最好和最坏两种情况考虑： 最好的情况是原始对象集合已全部排好序。此时while循环的循环次数均为0。这样在每次排序过程中关键码的比较次数为1，对象的移动次数为2，因此整个排序过程中关键码的比较次数为n-1，对象的移动次数为2(n-1)，所以最好情况的时间复杂度为O(n) 最坏的情况是原始对象集合逆序排列。这种情况下第i次排序时算法中的while循环的循环次数均为i。这样在整个排序过程中关键码的比较次数和对象移动次数可计算如下： ​ 比较次数=$\sum^{ n-1}_{i=1}{(i+1)}$=$\frac {(n-1)(n+2)}{2}$ ​ 移动次数=$\sum_{i=1}^{n-1}{i+2}$=$\frac{(n-1)(n+4)}{2}$ 因此，最坏情况下其时间复杂度为O($n^2$)。 空间复杂度 直接插入排序算法的空间复杂度为O(1) 直接插入排序算法是一种稳定的排序算法 5）源码地址​ 直接插入排序实现源码 链表插入排序&emsp;&emsp;链表插入排序的最终排序结果将把对象集合按关键码大小依次链接地存储在一个链表中。这时链表中每个结点的结构除数据域外要增加一个指向结点类型的指针域。 链表插入排序的思想是：初始时链表为空，第一个对象R[0]直接插入到链表中。第二个对象R[1]插入到链表中的位置由K[0]和K[1]比较确定：若K[1]&lt;K[0]，则把R[1]插入到R[0]前；否则把R[1]插入到R[0]后. 第三个对象R[2]插入到链表中的位置由K[2]和K[1]、K[0]比较确定。若K[2]&lt;K[0],则把K[2]插入到K[0]前。若K[2]&gt;K[0]，应比较K[2]、K[1]； 若K[2]&lt;K[1]，则把R[2]插入到R[0]后，R[1]前，若K[2]&gt;K[1]，则把R[2]插入到R[1]后。 这样的插入过程进行到R[n-1]插入完成后，则原始对象集合按关键码大小依次链接在一个链表中。 1）链表插入排序的实现链表中结点的数据类型定义：12345678template&lt;class T&gt;struct Node&#123; T data;//数据域 Node* next;//指针域 Node(Node* p = NULL) :next(p) &#123;&#125;//用于构造头结点 Node(T item,Node*p=NULL):data(item),next(p)&#123;&#125;//构造其他存放数据元素的结点&#125;; 链表插入排序的实现： 123456789101112131415161718template&lt;class T&gt;void LinkListInsertSort(T a[], Node&lt;T&gt;*&amp; list, int n)&#123; Node&lt;T&gt;* curr, * pre, * q; for (int i = 0; i &lt; n; i++) &#123; curr = list-&gt;next; pre = list; q = new Node&lt;T&gt;(a[i]); while (curr != NULL &amp;&amp; curr-&gt;data &lt;= a[i]) &#123; pre = curr; curr = curr-&gt;next; &#125; q-&gt;next = pre-&gt;next; pre-&gt;next = q; &#125;&#125; 2）测试函数 1234567891011121314void test()&#123; int arr[]= &#123; 15,22,6,7,2,1,56,89,14 &#125;; int n = sizeof(arr) / sizeof(arr[0])-1; cout &lt;&lt; "原数组为：" &lt;&lt; endl; for (int i = 0; i &lt; n; i++) &#123; cout &lt;&lt; arr[i] &lt;&lt; " "; &#125; cout &lt;&lt; endl; Node&lt;int&gt;* list = new Node&lt;int&gt;; LinkListInsertSort(arr, list, n); Display(list);//输出链表&#125; 3）执行结果 4）时空复杂度分析 最坏时间复杂度 链表插入排序算法不需要移动数据对象，每插入一个对象时，最小关键码比较次数等于1，最大关键码比较次数等于链表中已排好序的对象的个数，即： ​ 最小比较次数=n-1​ ​ 最大比较次数=$\sum^{n-1}_{i=1}{i}$=$\frac{n(n-1)}{2}$ 所以，链表插入排序算法最坏情况的时间复杂度为O($n^2$)。 空间复杂度 链表插入排序算法另外需要n个结点存放排好序的数据对象，所以，链表插入排序算法的空间复杂度为O(n). 链表插入排序算法是一种稳定的排序算法。 5）源码地址​ 链表插入排序实现源码 希尔排序&emsp;&emsp;希尔排序又称作最小增量排序，希尔排序算法的思想是：不断把待排序的对象分成若干个小组，对同一小组内的对象用直接插入法进行排序，当完成了所有对象都分在一个小组内的排序之后，排序过程结束。 &emsp;&emsp;希尔排序是在分组概念上的插入排序，即在不断缩小组的个数时把原各小组的对象插入到新组中的合适位置上。 &emsp;&emsp;原始对象集合越接近有序，直接插入排序算法的时间效率越高，这也是希尔排序算法能够成立的基础。希尔排序算法把待排序对象分成若干小组，在小组内用直接插入排序算法排序，当把小的小组合并为一些大的小组时，其中的对象集合将会接近有序，从而使直接插入排序算法的时间效率很高。 1）希尔排序的实现12345678910111213141516171819202122template&lt;class T&gt;void ShellSort(T arr[], int n, int increment[], int numOfIncrement)&#123; T temp; for (int m = 0; m &lt; numOfIncrement; m++) &#123; for (int k = 0; k &lt; increment[m]; k++) &#123;//每个小组内按直接插入排序算法排序，区别只是每次不是增1，而是increment[m] for (int i = k; i &lt; n - increment[m]; i = i + increment[m]) &#123; temp = arr[i + increment[m]]; int j = i; while (j &gt; -1 &amp;&amp; temp &lt;= arr[j]) &#123; arr[j + increment[m]] = arr[j]; j = j - increment[m]; &#125; arr[j + increment[m]] = temp; &#125; &#125; &#125;&#125; 2）希尔排序过程当增量increment=4时： 当增量increment=3时： 当增量increment=1时： 3）测试函数1234567891011121314151617181920void test()&#123; int arr[]= &#123; 15,22,6,7,2,1,56,89,14 &#125;; cout &lt;&lt; "原数组为：" &lt;&lt; endl; int n = sizeof(arr) / sizeof(arr[0])-1; for (int i = 0; i &lt; n; i++) &#123; cout &lt;&lt; arr[i] &lt;&lt; " "; &#125; cout &lt;&lt; endl; int increment[] = &#123; 4,3,1 &#125;; int numOfIncrement = sizeof(increment) / sizeof(increment[0]); ShellSort(arr, n, increment, numOfIncrement); cout &lt;&lt; "排序结果：" &lt;&lt; endl; for (int i = 0; i &lt; n; i++) &#123; cout &lt;&lt; arr[i] &lt;&lt; " "; &#125; cout &lt;&lt; endl;&#125; 4）执行结果 5）时空复杂度 时间复杂度： 比较希尔排序和直接排序算法可见，直接插入排序算法是两重循环，希尔排序算法是四重循环，但分析希尔排序算法中四重循环的循环数值可以发现，四重循环每重的循环数值都很小，并且当增量递减、小组变大时，小组内的对象数值已经基本有序了，而我们知道，越接近有序的直接插入，排序算法的时间效率越高。因此，希尔排序算法的时间复杂度较直接插入排序算法的时间复杂度改善了很多。 希尔排序算法的时间复杂度分析比较复杂，实际所需的时间取决于各次排序时增量的个数和增量的取值。研究证明，若增量的取值合理，希尔排序算法的时间复杂度约为O(n$({lgn})^2$)。 空间复杂度： 希尔排序算法的空间复杂度为O(1)。由于希尔排序算法是按增量分组进行的排序，所以希尔排序是一种不稳定的排序算法。 5）源码地址​ 希尔排序实现源码]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>排序</tag>
        <tag>插入排序</tag>
        <tag>直接插入排序</tag>
        <tag>链表插入排序</tag>
        <tag>希尔排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二叉搜索树及其实现]]></title>
    <url>%2F2019%2F%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E5%8F%8A%E5%85%B6%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[一、二叉搜索树概述&emsp;&emsp;一棵二叉搜索树(Binary Search Tree,BST)是以一棵二叉树来组织的。BST是满足下面条件的二叉树，该条件即二叉搜索树属性： 对于二叉搜索树的一个结点，设其值为K，则该结点左子树任意一个结点的值都小于K 该结点右子树中任意一个结点的值都大于或等于K。 &emsp;二叉查找树的特点是，如果按照中序周游将各个结点打印出来，就会得到由小到大排列结点。 &emsp;&emsp;从根结点开始，在BST中检索值K。如果根结点存储的值为K，则检索结束。如果不是，则必须检索树的更深一层。BST的效率在于只需检索两棵子树之一。如果K小于根结点的值，则只需检索左子树；如果K大于根结点的值，则只需检索右子树。这个过程一直持续到K被找到或遇到一个叶结点为止。如果遇到叶结点仍没有发现K，那么K就不在这个BST中。 二、二叉搜索树的实现&emsp;二叉搜索树结点类的定义：12345678910111213141516171819202122template&lt;class T&gt;class BinarySearchTree;template&lt;class T&gt;class BitreeNode&#123; friend class BinarySearchTree&lt;T&gt;;public: T data;//数据域 BitreeNode() :leftChild(NULL), rightChild(NULL) &#123;&#125;//构造函数 BitreeNode(T item, BitreeNode&lt;T&gt;* left = NULL, BitreeNode&lt;T&gt;* right = NULL) :data(item), leftChild(left), rightChild(right) &#123;&#125; ~BitreeNode() &#123;&#125;//析构函数 BitreeNode&lt;T&gt;*&amp; Left() &#123; return leftChild; &#125; BitreeNode&lt;T&gt;*&amp; Right() &#123; return rightChild; &#125;private: BitreeNode&lt;T&gt;* leftChild;//左子树指针 BitreeNode&lt;T&gt;* rightChild;//右子树指针&#125;; 二叉搜索树是以二叉树来组织的，所以其结点类的定义于二叉树结点类的定义相同。 二叉搜索树类的定义：1234567891011121314151617181920212223242526272829template&lt;class T&gt;class BinarySearchTree&#123;public: BinarySearchTree() :root(NULL) &#123;&#125;//无参构造参数 BinarySearchTree(const BinarySearchTree&amp; rhs);//有参构造函数 ~BinarySearchTree();//析构函数 const T&amp; findMax() const;//寻找最大值 const T&amp; findMin() const;//寻找最小值 bool contains(const T&amp; value) const;//判断value是否存在 bool isEmpty() const;//二叉搜索树是否为空 void InOrder(void(*visit)(T item)) const;//输出树结点 void makeEmpty();//清空树 void insert(const T&amp;value);//插入 void remove(const T&amp;value);//删除值为value的结点private: BitreeNode&lt;T&gt;* root;//根结点 void insert(const T&amp; value, BitreeNode&lt;T&gt;*&amp; t) const;//插入新结点 void remove(const T&amp; value, BitreeNode&lt;T&gt;*&amp; t) const;//删除结点 BitreeNode&lt;T&gt;* finMin(BitreeNode&lt;T&gt;* t) const;//查找二叉搜索树中值最小的结点 BitreeNode&lt;T&gt;* finMax(BitreeNode&lt;T&gt;* t) const;//查找二叉搜索树中值最大的结点 bool contains(const T&amp; value, BitreeNode&lt;T&gt;* t) const;//判断二叉搜索树中是否存在一个值为value的结点 void makeEmpty(BitreeNode&lt;T&gt;*&amp; t);//清空结点 void InOrder(BitreeNode&lt;T&gt;* t, void(*visit)(T item))const;//中序输出结点 void PreOrder(BitreeNode&lt;T&gt;* t, void(*visit)(T item)) const;//前序输出结点 void PostOrder(BitreeNode&lt;T&gt;* t, void(*visit)(T item)) const;//后序输出结点&#125;; 二叉搜索树的一个最重要的应用就是它们在查找中的应用。虽然任意复杂的项在C++中都很容易处理，但是为了简单起见，先假设它们都是整数。 其实现的部分代码如下： 1234567891011121314151617181920212223template&lt;class T&gt;inline bool BinarySearchTree&lt;T&gt;::contains(const T&amp; value) const&#123; return contains(value, root);&#125;template&lt;class T&gt;inline bool BinarySearchTree&lt;T&gt;::contains(const T&amp; value, BitreeNode&lt;T&gt;* t) const&#123; if (t == NULL) return false; else if (value &lt; t-&gt;data) &#123; return contains(value, t-&gt;leftChild); &#125; else if (value &gt; t-&gt;data) &#123; return contains(value, t-&gt;rightChild); &#125; else return true;&#125; contains函数用来判断二叉树中是否存在值为value的结点。如果在树中存在该结点，那么该函数返回true,否则返回false.树的结构使得该操作很简单。如果树为空，则返回false,否则，如果根结点的值为value，则返回true。若以上两种情况都不成立，则根据value与根结点值的大小关系决定对左子树还是右子树进行递归调用。 1234567891011121314151617181920212223242526272829303132template&lt;class T&gt;inline void BinarySearchTree&lt;T&gt;::InOrder(BitreeNode&lt;T&gt;* t,void(*visit)(T item)) const&#123;//中序遍历 if (t != NULL) &#123; printTree(t-&gt;leftChild, visit); visit(t-&gt;data); printTree(t-&gt;rightChild, visit); &#125;&#125;template&lt;class T&gt;inline void BinarySearchTree&lt;T&gt;::PreOrder(BitreeNode&lt;T&gt;* t, void(*visit)(T item)) const&#123;//前序遍历 if (t != NULL) &#123; visit(t-&gt;data); PreOrder(t-&gt;leftChild, visit); PreOrder(t-&gt;rightChild, visit); &#125;&#125;template&lt;class T&gt;inline void BinarySearchTree&lt;T&gt;::PostOrder(BitreeNode&lt;T&gt;* t, void(*visit)(T item)) const&#123;//后序遍历 if (t != NULL) &#123; PostOrder(t-&gt;leftChild,visit); PostOrder(t-&gt;rightChild, visit); visit(t-&gt;data); &#125;&#125; 以上分别为中序遍历，前序遍历和后序遍历。其中，中序遍历的输出结果是从小到大进行排列的，这也是二叉搜索树的一个特点。中序遍历(LDR)、前序遍历(DLR)、后序遍历(LRD)。 12345678910111213141516171819202122232425template&lt;class T&gt;inline BitreeNode&lt;T&gt;* BinarySearchTree&lt;T&gt;::finMin(BitreeNode&lt;T&gt;* t) const&#123; if (t != NULL) &#123; while (t-&gt;leftChild != NULL) &#123; t = t-&gt;leftChild; &#125; &#125; return t;&#125;template&lt;class T&gt;inline BitreeNode&lt;T&gt;* BinarySearchTree&lt;T&gt;::finMax(BitreeNode&lt;T&gt;* t) const&#123; if (t != NULL) &#123; while (t-&gt;rightChild != NULL) &#123; t = t-&gt;rightChild; &#125; &#125; return t;&#125; 以上两个函数是用来查找最大值和最小值。由于二叉搜索函树的性质，所以查找最大值和最小值也比较方便。对于最小值，还需要查找到最左叶子结点，即为最小值；而最大值则需要查找到最右叶子节点，即为最大值。 12345678910111213141516template&lt;class T&gt;inline void BinarySearchTree&lt;T&gt;::insert(const T&amp; value, BitreeNode&lt;T&gt;*&amp; t) const&#123; if (t == NULL) &#123; t = new BitreeNode&lt;T&gt;(value); &#125; else if (value &lt; t-&gt;data) &#123; insert(value, t-&gt;leftChild); &#125; else if (value &gt; t-&gt;data) &#123; insert(value, t-&gt;rightChild); &#125;&#125; 对于一个二叉搜索树来说，insert函数相对来说比较重要，因为二叉搜索树的属性是左孩子始终比双亲结点小，而右孩子始终比双亲结点大。此时需要注意的是，此二叉搜索树并不能处理插入已存在数据的操作，即二叉树结点中的每一项的值是各不相同的。 123456789101112131415161718192021222324252627template&lt;class T&gt;inline void BinarySearchTree&lt;T&gt;::remove(const T&amp; value,BitreeNode&lt;T&gt;*&amp; t) const&#123; if (t == NULL) &#123; return; &#125; if (value &lt; t-&gt;data) &#123; remove(value, t-&gt;leftChild); &#125; else if (value &gt; t-&gt;data) &#123; remove(value, t-&gt;rightChild); &#125; else if (t-&gt;leftChild != NULL &amp;&amp; t-&gt;rightChild != NULL) &#123; t-&gt;data = findMin(t-&gt;right)-&gt;data; remove(t-&gt;data, t-&gt;rightChild); &#125; else &#123; BitreeNode&lt;T&gt;* oldNode = t; t = (t-&gt;leftChild != NULL) ? t-&gt;leftChild : t-&gt;rightChild; delete oldNode; &#125;&#125; 最值得注意的是删除操作，即remove。删除操作需要考虑多种情况。 当要删除的对象为叶子结点时，可以直接删除该叶子结点。 如果结点有一个孩子，则该结点可以在其父结点调整它的链以绕过该结点后被删除。图示如下： ​ 在该树中，我们删除了具有一个孩子的结点4。 复杂的情况是，处理具有两个孩子的结点。一般的删除策略是用其右子树的最小数据代替该结点的数据并递归地删除该结点。因为右子树中的最小的结点不可能有左孩子，所以第二次remove就很容易了。图示如下： ​ 在该树中，我们删除了具有两个孩子的结点4，其中虚线连接的结点代表已经删除了。右边的图是删除后的结果。在删除后，它被右子树中最小的值，即3代替了。 三、主函数及执行结果1234567891011121314151617181920212223242526272829303132333435363738#include&lt;iostream&gt;#include"BST.h"using namespace std;int main()&#123; BinarySearchTree&lt;int&gt; BST; BST.insert(20); BST.insert(18); BST.insert(5); BST.insert(10); BST.insert(25); BST.insert(4); BST.insert(21); BST.insert(18); cout &lt;&lt; "最大值："; cout &lt;&lt; BST.findMax() &lt;&lt; endl; cout &lt;&lt; "最小值："; cout &lt;&lt; BST.findMin() &lt;&lt; endl; int temp = 18; if (BST.contains(temp)) &#123; cout &lt;&lt; "BST中存在" &lt;&lt;temp&lt;&lt; endl; &#125; else cout &lt;&lt; "BST中不存在"&lt;&lt;temp &lt;&lt; endl; BST.InOrder(Visit); cout &lt;&lt; endl; BST.makeEmpty(); if (BST.isEmpty()) &#123; cout &lt;&lt; "BST为空！" &lt;&lt; endl; &#125; else cout &lt;&lt; "BST非空！" &lt;&lt; endl; system("pause"); return EXIT_SUCCESS;&#125; 执行结果： 四、源码地址​ 二叉搜索树的实现源码]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>二叉树</tag>
        <tag>二叉搜索树</tag>
        <tag>BST</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二叉树的实现]]></title>
    <url>%2F2019%2F%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[一、二叉树结点类定义1234567891011121314151617181920212223template&lt;class T&gt;class BinaryTree;template&lt;class T&gt;class BiTreeNode&#123; friend class BinaryTree&lt;T&gt;;public: T data;//数据域 BiTreeNode() :leftChild(NULL), rightChild(NULL) &#123;&#125;//构造函数 BiTreeNode(T item,BiTreeNode&lt;T&gt;*left=NULL,BiTreeNode&lt;T&gt;*right=NULL)//构造函数 :data(item),leftChild(left),rightChild(right)&#123;&#125; ~BiTreeNode()&#123;&#125;//析构函数 BiTreeNode&lt;T&gt;*&amp; Left() &#123;//获得左孩子 return leftChild; &#125; BiTreeNode&lt;T&gt;*&amp; Right() &#123;//获得右孩子 return rightChild; &#125;private: BiTreeNode&lt;T&gt;* leftChild;//左子树指针 BiTreeNode&lt;T&gt;* rightChild;//右子树指针&#125;; 二、二叉树类定义123456789101112131415161718192021222324252627282930313233343536template&lt;class T&gt;class BinaryTree&#123;public: BinaryTree() :root(NULL)&#123;&#125;;//构造函数 ~BinaryTree() &#123;&#125;;//析构函数 //构造二叉树 void MakeTree(const T&amp; item); //第一类操作的成员函数 bool Root();//使根结点为当前结点 bool Parent();//使双亲结点为当前结点 bool LeftChild();//使左孩子结点为当前结点 bool RightChild();//使右孩子结点为当前结点 //第二类操作的成员函数 void InsertChild(const T &amp;value);//使根结点为当前结点 void DeleteSubTree(BiTreeNode&lt;T&gt;*&amp; t);//删除以t为根结点的子树 void clear();//清空树 //第三类操作的成员函数 //遍历访问二叉树 void PreOrder(void(*visit)(T item));//前序遍历访问树 void InOrder(void(*visit)(T item));//中序遍历访问树 void PostOrder(void(*visit)(T item));//后序遍历访问树private: BiTreeNode&lt;T&gt;* root;//根结点指针 BiTreeNode&lt;T&gt;* current;//当前结点指针 bool Current(BiTreeNode&lt;T&gt;*&amp; t);//使当前结点为t所指结点 void PreOrder(BiTreeNode&lt;T&gt;*&amp; t, void(*visit)(T item)); void InOrder(BiTreeNode&lt;T&gt;*&amp; t, void(*visit)(T item)); void PostOrder(BiTreeNode&lt;T&gt;*&amp; t, void(*visit)(T item)); //插入 void Insert(const T&amp; value, BiTreeNode&lt;T&gt;*&amp; t); //在树root中回溯查找s的双亲结点 BiTreeNode&lt;T&gt;* SearchParent(BiTreeNode&lt;T&gt;*&amp; root, BiTreeNode&lt;T&gt;*&amp; s);&#125;; 三、二叉树实现的部分代码前序遍历即DLR，也叫做先根遍历、先序遍历、前序周游，记作根左右。前序遍历首先访问根结点，然后遍历左子树，最后遍历右子树。 这里使用visit(item)函数来输出结点数据域值，同时，visit(item)函数经过修改之后，也可以输出自定义数据类型中需要输出的数据。 visit(item)函数的实现如下： 12345template&lt;class T&gt;void Visit(T item)&#123; cout &lt;&lt; item &lt;&lt; " ";&#125; 12345678910111213141516template&lt;class T&gt;inline void BinaryTree&lt;T&gt;::PreOrder(void(*visit)(T item))&#123; PreOrder(root,Visit);&#125;template&lt;class T&gt;inline void BinaryTree&lt;T&gt;::PreOrder(BiTreeNode&lt;T&gt;*&amp; t, void(*visit)(T item))&#123; if (t != NULL) &#123; visit(t-&gt;data); PreOrder(t-&gt;leftChild,visit); PreOrder(t-&gt;rightChild,visit); &#125;&#125; 中序遍历即DLR，也叫中根遍历、中序周游。可记作根左右。在二叉树中，中序遍历首先遍历左子树，然后访问根结点，最后遍历右子树。 12345678910111213141516template&lt;class T&gt;inline void BinaryTree&lt;T&gt;::InOrder(void(*visit)(T item))&#123; InOrder(root,Visit);&#125;template&lt;class T&gt;inline void BinaryTree&lt;T&gt;::InOrder(BiTreeNode&lt;T&gt;*&amp; t, void(*visit)(T item))&#123; if (t != NULL) &#123; InOrder(t-&gt;leftChild, visit); visit(t-&gt;data); InOrder(t-&gt;rightChild, visit); &#125;&#125; 后序遍历即LRD，也叫后根遍历、后序变周游，可记作左右根。在二叉树中，首先遍历左子树，然后遍历右子树，最后访问根结点。 12345678910111213141516template&lt;class T&gt;inline void BinaryTree&lt;T&gt;::PostOrder(void(*visit)(T item))&#123; PostOrder(root,Visit);&#125;template&lt;class T&gt;inline void BinaryTree&lt;T&gt;::PostOrder(BiTreeNode&lt;T&gt;*&amp; t, void(*visit)(T item))&#123; if (t != NULL) &#123; PostOrder(t-&gt;leftChild, visit); PostOrder(t-&gt;rightChild, visit); visit(t-&gt;data); &#125;&#125; 删除子树123456789101112131415161718template&lt;class T&gt;inline void BinaryTree&lt;T&gt;::DeleteSubTree(BiTreeNode&lt;T&gt;*&amp; t)&#123; if (t == NULL) return; else &#123; BiTreeNode&lt;T&gt;* q=t-&gt;leftChild, *p; while (q != NULL) &#123; p = q-&gt;rightChild; DeleteSubTree(q); q = p; &#125; delete t; t = NULL; &#125;&#125; 插入结点在此实现中，对于二叉树结点的插入基本与二叉搜索树相同。当根结点为空时，新插入的结点作为根结点。当新插入的结点值小于根结点值时，插入到左子树；当新插入的结点值大于根结点值时，插入到右子树。 12345678910111213141516171819202122template&lt;class T&gt;inline void BinaryTree&lt;T&gt;::InsertChild(const T&amp; value)&#123; Insert(value, root);&#125;template&lt;class T&gt;inline void BinaryTree&lt;T&gt;::Insert(const T&amp; value, BiTreeNode&lt;T&gt;*&amp; t)&#123; if (t == NULL) t = new BiTreeNode&lt;T&gt;(value); else if (value &lt; t-&gt;data) &#123; Insert(value, t-&gt;leftChild); &#125; else if (value &gt; t-&gt;data) &#123; Insert(value, t-&gt;rightChild); &#125; else return;&#125; 四、主函数及执行结果123456789101112131415161718192021222324int main()&#123; BinaryTree&lt;int&gt;BiTree; BiTree.InsertChild(15); BiTree.InsertChild(5); BiTree.InsertChild(6); BiTree.InsertChild(8); BiTree.InsertChild(20); BiTree.InsertChild(22); BiTree.InsertChild(16); BiTree.InsertChild(18); cout &lt;&lt; "前序：" &lt;&lt; endl; BiTree.PreOrder(Visit); cout &lt;&lt; endl &lt;&lt; "中序:" &lt;&lt; endl; BiTree.InOrder(Visit); cout &lt;&lt; endl &lt;&lt; "后序:" &lt;&lt; endl; BiTree.PostOrder(Visit); cout &lt;&lt; endl; BiTree.clear(); cout &lt;&lt; "前序：" &lt;&lt; endl; BiTree.PreOrder(Visit); system("pause"); return EXIT_SUCCESS;&#125; 执行结果： 五、源码地址​ 二叉树的实现源码]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>二叉树</tag>
        <tag>二叉树的遍历</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[多态]]></title>
    <url>%2F2019%2F%E5%A4%9A%E6%80%81%2F</url>
    <content type="text"><![CDATA[一、多态&emsp;多态是面向对象程序设计语言中数据抽象和继承之外的第三个基本特征。 &emsp;多态性(Polymorphism)提供接口与具体实现之间的另一层隔离，从而实现将“what”和“how”分离开来。多态性改善了代码的可读性和组织性，同时也使创建的程序具有可扩展性。项目不仅在最初创建时期可以扩展，而且当项目在需要有新功能时也能扩展。 &emsp;C++支持编译时多态（静态多态）和运行时多态（动态多态），运算符重载和函数重载就是编译时多态，而派生类和虚函数实现运行时多态。 二、静态联编和动态联编静态多态和动态多态的区别就是函数地址是早绑定（静态联编）还是晚绑定（动态联编）。如果函数的调用，在编译阶段就可以确定函数的调用地址，并产生代码，就是静态多态（联编时多态），也就是说地址是早绑定的。而如果函数的调用地址不能在编译期间确定，而需要在运行时才能决定，这就属于晚绑定（运行时多态）。 1234567891011121314151617181920212223242526272829303132#include&lt;iostream&gt;using namespace std;class Animal&#123;public: void speak() &#123; cout &lt;&lt; "动物在说话" &lt;&lt; endl; &#125;&#125;;class Cat:public Animal&#123;public: void speak() &#123; cout &lt;&lt; "喵喵喵" &lt;&lt; endl; &#125;&#125;;void doSpeak(Animal&amp;animal)&#123; animal.speak();&#125;void test01()&#123; Cat cat; doSpeak(cat);&#125; 当主函数调用dospeak()函数时，执行结果如下： &emsp;我们可以看到输出结果为“动物在说话”,这是因为当调用dospeak函数时，speak函数的地址早就绑定好了，早绑定，即动态联编，在编译近阶段就确定好了地址。 &emsp;如果想调用猫的speak函数，就不能提前绑定好地址，所以需要在运行的时候再去确定函数地址，即动态联编，将dospeak方法改为虚函数，写法是在父类上声明虚函数，发生多态。发生多态时，父类的引用或指针指向了子类对象。 12345678class Animal&#123;public: virtual void speak() &#123; cout &lt;&lt; "动物在说话" &lt;&lt; endl; &#125;&#125;; 此时运行结果为： 三、多态原理动态绑定的实现：&emsp;&emsp;当编译器发现我们的类中有虚函数时，编译器会创建一张虚函数表，把虚函数的函数入口地址放到虚函数表中，并且在类中秘密增加一个指针，这个指针就是vfptr，即virtual function pointer，这个指针是指向对象的虚函数表。在多态调用对的时候，根据vfptr指针，找到虚函数表来实现动态绑定。 &emsp;子类Cat写父类的虚函数speak，这中写法为重写。重写要求返回值、参数个数、类型、顺序都相同。 &emsp;当父类中有虚函数后，父类的内部结构就发生了变化。借助开发人员命令提示符为我们可以看到类的内部结构。 改变前的情况下图所示： 改变后的情况如下图所示： 我们可以看到，父类的内部结构发生了明显的变化，内部多了一个vfptr，且其大小也发生了变化。所谓vfptr即virtual function pointer，虚函数表指针，指向虚函数表。 而子类会继承父类的vfptr table，在构造函数中，子类会将虚函数表指针，指向自己的虚函数表。当发生重写时，会替换掉虚函数表中原有的speak，改为&amp;Cat::speak 子类Cat的内部结构如下： 四、抽象基类和纯虚函数&emsp;&emsp;在设计时，常常希望基类仅仅作为其派生类的一个接口。这就是说，仅想对基类进行向上类型转换，使用它的接口，而不希望用户实际地创建一个基类的对象。同时创建一个纯虚函数允许接口中放置成员函数，而不一定要提供一段可能对这个函数毫无意义的代码。 &emsp;&emsp;做到这一点，可以在基类中加入至少一个纯虚函数（pure virtual function)，使得基类称为抽象类(abstract class)。 纯虚函数使用关键字virtual，并在其后面加上=0。如果试图去实例化一个抽象类，编译器会阻止这种操作。 当继承一个抽象类时，必须实现所有的纯虚函数，否则由抽象类派生的类也是一个抽象类。 virtual void func()=0;告诉把编译器在vtable中为函数保留一个位置，但在在这个特定位置不放地址。 创建公共接口的目的是：为了将子类的公共操作抽象出来，可以通过一个公共接口来操纵一组类，且这个公共交界口不需要事先（或者不要完全实现）。可以创建一个公共类。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354class Animal&#123;public: virtual void speak() = 0; virtual void eat() = 0;&#125;;class Cat :public Animal&#123;public: void speak() &#123; cout &lt;&lt; "喵喵喵" &lt;&lt; endl; &#125; void eat() &#123; cout &lt;&lt; "猫在吃饭" &lt;&lt; endl; &#125;&#125;;class Dog :public Animal&#123;public: void speak() &#123; cout &lt;&lt; "汪汪汪" &lt;&lt; endl; &#125; void eat() &#123; cout &lt;&lt; "狗在吃饭" &lt;&lt; endl; &#125;&#125;;void doEat(Animal&amp; animal)&#123; animal.eat();&#125;void doSpeak(Animal&amp; animal)&#123; animal.speak();&#125;void test02()&#123; Cat cat; Dog dog; doSpeak(cat); doEat(cat); doSpeak(dog); doEat(dog);&#125; 执行结果： 多态成立的条件： 有继承 子类重写父类虚函数 返回值、函数名、函数参数必须与父类完全一致 子类中virtual关键字可不写 类型兼容，父类指针或父类引用指向子类对象 五、虚析构和纯虚析构函数 虚析构函数普通的析构函数不会调用子类的析构函数，这可能会导致释放不干净。可以利用虚析构来解决这个问题。 虚析构函数时为了解决基类的指针指向派生类对象，并用基类的指针删除派生类对象。 1234567891011121314151617181920212223242526272829303132333435363738394041class People&#123;public: People() &#123; cout &lt;&lt; "People的构造函数" &lt;&lt; endl; &#125; virtual void showName() = 0; virtual ~People() &#123; cout &lt;&lt; "People的虚析构函数" &lt;&lt; endl; &#125;&#125;;class Worker :public People&#123;public: Worker() &#123; cout &lt;&lt; "Worker的构造函数" &lt;&lt; endl; name = new char[10]; &#125; virtual void showName() &#123; cout &lt;&lt; "打印子类的名字" &lt;&lt; endl; &#125; ~Worker() &#123; cout &lt;&lt; "Worker的析构函数" &lt;&lt; endl; if (name != NULL) delete name; &#125;private: char* name;&#125;;void test03()&#123; People* people = new Worker; people-&gt;~People();&#125; 执行结果: 纯虚析构函数纯虚析构函数在C++是合法的，但是在使用的时候有一个额外的限制：必须为纯虚析构函数提供一个函数体。 那么问题是：如果给虚析构函数提供了函数体，那怎么还能称为纯虚析构函数呢？纯虚析构函数与非纯虚析构函数之间唯一的不同之处在于纯虚析构函数使得基类是抽象类，不能创建基类的对象。 纯虚析构函数需要声明和实现，在类内声明，类外实现。如果函数中出现了纯虚析构函数，那么这个类是抽象类，不可以实例化对象。 六、纯虚函数和多继承&emsp;&emsp;多继承带来了一些争议，但是接口继承可以说是一种毫无争议的运用。 &emsp;&emsp;绝大多数面向对象语言都不支持多继承，但是绝大多数面向对象语言都支持接口的概念，C++没有接口的概念，但是可以通过纯虚函数实现接口 接口类中只有函数原型定义，没有任何数据定义 &emsp;&emsp;多重继承接口不会带来二义性和复杂性问题。接口类知识一个功能声明，并不是功能实现，子类需要根据功能说明定义功能实现。 除了析构函数外，其他声明都是纯虚函数。 123456789101112131415161718192021222324252627282930313233343536373839404142class Animal&#123;public: virtual void speak() &#123; cout &lt;&lt; "动物说话" &lt;&lt; endl; &#125; virtual ~Animal() = 0;&#125;;Animal::~Animal()//纯虚析构函数的实现&#123; cout &lt;&lt; "Animal的纯虚析构函数调用" &lt;&lt; endl;&#125;class Cat :public Animal&#123;public: Cat(const string name) &#123; m_Name = name; &#125; virtual void speak() &#123; cout &lt;&lt; "小猫"&lt;&lt;m_Name&lt;&lt;"在说话" &lt;&lt; endl; &#125; ~Cat() &#123; cout &lt;&lt; "Cat的析构函数调用" &lt;&lt; endl; &#125;private: string m_Name;&#125;;void test04()&#123; //Animal animal;//抽象基类不可实例化 string name = "Mimi"; Cat cat(name); cat.speak();&#125; 执行结果： 七、向上类型转换和向下类型转换基类转派生类，即向下类型转换，是不安全的。 派生类转基类，即向上类型转换，是安全的。 如果发生了多态，就总是安全的。 向下类型转换的可访问性：&emsp;&emsp;派生类向基类的转换是否可以访问由使用该转换的代码决定，同时，派生类的派生访问说明符也会有影响。假定D继承自B： 只有当D公有继承B时，用户代码才能使用派生类向基类的转换；如果D继承B的方式是受保护的或者私有的，则用户代码不能使用该转换。 不论D以什么方式继承B，D的成员函数和友元都能使用派生类向基类的转换；派生类向其直接基类的转换对于派生类的成员和友元来说是永远可访问的。 如果D继承B的方式是公有的，或受保护的，则D的派生类成员可以使用D向B的类型转换，反之，如果D继承B对的方式是私有的，那么不能使用。 八、指向类成员的指针 指向成员变量的指针定义格式 &lt;数据类型&gt;&lt;类名&gt;::*&lt;指针名&gt; 例如：int A::*pPram; 赋值/初始化 &lt;数据类型&gt;&lt;类名&gt;::*&lt;指针名&gt;=&amp;&lt;类名&gt;::&lt;非静态数据成员&gt; 例如：int A::*pParam=&amp;A::param 解引用 &lt;类对象名&gt;.*&lt;非静态数据成员指针&gt; &lt;类对象指针&gt;-&gt;*&lt;非静态数据成员指针&gt; 例如： A a; a.*pParam; a-&gt;*pParam 123456789101112131415161718192021class A&#123;public: A(int param) &#123; mParam = param; &#125; int mParam;&#125;;void test05()&#123; A a1(10); A* a2 = new A(200); int* p1 = &amp;a1.mParam; int A::* p2 = &amp;A::mParam; cout &lt;&lt; "*p1:" &lt;&lt; *p1 &lt;&lt; endl; cout &lt;&lt; "a1.p2:" &lt;&lt; a1.*p2 &lt;&lt; endl; cout &lt;&lt; "a2-&gt;*p2:" &lt;&lt; a2-&gt;*p2 &lt;&lt; endl;&#125; 执行结果： 指向成员函数的指针定义格式化 &lt;返回类型&gt;(&lt;类名&gt;::*&lt;指针名&gt;)(&lt;参数列表&gt;) 例如： void(A::*pFunc)(int,int); 赋值/初始化 &lt;返回类型&gt;(&lt;类名&gt;::*&lt;指针名&gt;)(&lt;参数列表&gt;)=&amp;&lt;类名&gt;::&lt;非静态数据函数&gt; 例如： void(A::pFunc(int,int)=&amp;A::func; 解引用 (&lt;类对象名&gt;.*&lt;非静态成员函数&gt;)(&lt;参数列表&gt;) (&lt;类对象指针&gt;-&gt;*&lt;非静态成员函数&gt;)(&lt;参数列表&gt;) 例如： A a; (a.*pFunc)(10,20); (a-&gt;*pFunc)(10,20); 12345678910111213141516171819202122232425262728class A&#123;public: A() &#123; mParam = 10; &#125; A(int param) &#123; mParam = param; &#125; int func(int a, int b) &#123; return a + b; &#125; int mParam;&#125;;void test06()&#123; A a1; A* a2 = new A; //初始化成员函数指针 int(A:: * pFunc)(int, int) = &amp;A::func; //指针解引用 cout &lt;&lt; "(a1.*pFunc(10,20)=" &lt;&lt; (a1.*pFunc)(10, 20) &lt;&lt; endl; cout &lt;&lt; "(a2-&gt;*pFunc(10,20)=" &lt;&lt; (a2-&gt;*pFunc)(10, 20) &lt;&lt; endl;&#125; 执行结果： 指向静态成员的指针 指向静态数据成员的指针 指向静态数据成员的指针的定义和使用与普通指针相同，在定义时无须和类向关联，在使用时也无须和具体的对象相关联。 指向类静态成员函数的指针 指向静态成员函数的指针和普通指针相同，在定义时无须和类相关联，在使用时也无须和具体的对象相关联。 1234567891011121314151617181920212223242526272829303132class A&#123;public: A() &#123; mParam = 10; &#125; A(int param) &#123; mParam = param; &#125; int func(int a, int b) &#123; return a + b; &#125; static void dis() &#123; cout &lt;&lt; data &lt;&lt; endl; &#125; static int data; int mParam;&#125;;int A::data = 555;void test07()&#123; int* p = &amp;A::data; cout &lt;&lt; *p &lt;&lt; endl; void(*pfunc)() = &amp;A::dis; pfunc();&#125; 执行结果： 九、源码地址​ 多态源码示例]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>多态</tag>
        <tag>虚函数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[树的实现]]></title>
    <url>%2F2019%2F%E6%A0%91%E7%9A%84%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[一、树结点类&emsp;这里我们使用使用孩子兄弟结点表示法表示树的每个结点，每个结点包括三个域：数据域、第一个孩子结点指针域和下一个兄弟结点指针域。 1234567891011121314151617181920212223242526#pragma oncetemplate&lt;class T&gt;class Tree;template&lt;class T&gt;class TreeNode&#123; friend class Tree&lt;T&gt;;public: T data;//数据域 //构造函数 TreeNode(T value, TreeNode&lt;T&gt;* fc = nullptr, TreeNode&lt;T&gt;* ns = nullptr) :data(value), firstChild(fc), nextSibling(ns) &#123;&#125; //访问指针域的成员函数 TreeNode&lt;T&gt;*&amp; FirstChild() &#123; return firstChild; &#125; TreeNode&lt;T&gt;*&amp; NextSibling() &#123; return nextSibling; &#125;private: TreeNode&lt;T&gt;* firstChild;//第一个孩子结点指针域 TreeNode&lt;T&gt;* nextSibling;//下一个兄弟结点指针域&#125;; 二、树类&emsp;树类的数据成员有根结点和当前结点指针。树类设计为树结点类的友元，树类成员函数可直接操作树结点内的私有数据成员，所以这里树类的成员函数是直接对树结点类的私有数据成员firstChild和nextSibling进行操作的。对于外部应用，可通过成员函数FirstChild()和NextSilibing()取得树结点类的私有数据成员firstChild和nextSibling的值和修改它们的值。 123456789101112131415161718192021222324252627282930313233#pragma once#include"treeNode.h"using namespace std;template&lt;class T&gt; class Tree&#123;public: Tree() &#123; root = current = nullptr; &#125;//构造函数 ~Tree() &#123; DeleteSubTree(root); &#125;//析构函数 //第一类操作的成员函数 int Root();//使根结点为当前结点 int Parent();//使当前结点的双亲结点为当前结点 int FirstChild();//使当前结点的第一个孩子结点为当前结点 int NextSilibing();//使当前结点的兄弟结点为当前结点 //第二类操作的成员函数 void Insert(T value);//把value插入到当前结点的最后一个结点 void DeleteSubTree(TreeNode&lt;T&gt;*&amp; t);//删除以t为根结点的子树 void DeleteChile(int i);//删除当前结点的第i个孩子结点 //第三类操作的成员函数 void DisplayTree();//按先根遍历次序显示树的数据域值private: TreeNode&lt;T&gt;* root;//根结点指针 TreeNode&lt;T&gt;* current;//当前结点指针 //私有成员函数 void PreOrderTree(TreeNode&lt;T&gt;*&amp; t);//显示以t为根节点的树的数据域，先根遍历 void PosOrderTree(TreeNode&lt;T&gt;*&amp; t);//后根遍历 int Current(TreeNode&lt;T&gt;*&amp; t);//使当前节点为t所指结点 //在树root中回溯查找结点s的双亲结点 TreeNode&lt;T&gt;* SearchParent(TreeNode&lt;T&gt;*&amp; root, TreeNode&lt;T&gt;*&amp; s);&#125;; 三、树类成员函数的实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190template&lt;class T&gt;inline int Tree&lt;T&gt;::Root()&#123; if (root == nullptr) &#123; current = nullptr; return 0; &#125; return Current(root);&#125;template&lt;class T&gt;inline int Tree&lt;T&gt;::Parent()&#123; if (root == nullptr) &#123; current = root; return 0; &#125; TreeNode&lt;T&gt;* p = SearchParent(root, current); if (p == nullptr) return 0; else return Current(p);&#125;template&lt;class T&gt;inline int Tree&lt;T&gt;::FirstChild()&#123; if (current != nullptr &amp;&amp; current-&gt;firstChild != nullptr) &#123; return Current(current-&gt;firstChild); &#125; else return 0;&#125;template&lt;class T&gt;inline int Tree&lt;T&gt;::NextSilibing()&#123; if (current != nullptr &amp;&amp; current-&gt;nextSibling != nullptr) &#123; return Current(current-&gt;nextSibling); &#125; else &#123; return 0; &#125;&#125;template&lt;class T&gt;inline void Tree&lt;T&gt;::Insert(T value)&#123; //把value插入到当前结点的最后一个结点 /* 分为三种情况 1. 空树 2. 当前结点无孩子结点 3. 当前结点已有孩子结点 */ TreeNode&lt;T&gt;* newNode = new TreeNode&lt;T&gt;(value); if (root == nullptr) &#123; root = current = newNode; return; &#125; if (current-&gt;firstChild == nullptr)//当前结点无孩子结点 &#123; current-&gt;firstChild = newNode; &#125; else &#123; TreeNode&lt;T&gt;* p = current-&gt;firstChild; while (p-&gt;nextSibling != nullptr) &#123; p = p-&gt;nextSibling; &#125; p-&gt;nextSibling = newNode; &#125; Current(newNode);//使当前结点为新节点&#125;template&lt;class T&gt;inline void Tree&lt;T&gt;::DeleteSubTree(TreeNode&lt;T&gt;*&amp; t)&#123; if (t == nullptr) return; TreeNode&lt;T&gt;* q = t-&gt;firstChild, * p; while (q != nullptr) &#123; p = q-&gt;nextSibling; DeleteSubTree(q); q = p; &#125; delete t;&#125;template&lt;class T&gt;inline void Tree&lt;T&gt;::DeleteChile(int i)&#123; TreeNode&lt;T&gt;* r = nullptr; if (i == 1)//当删除当前结点的第一棵子树 &#123; r = current-&gt;firstChild; if (r == nullptr) return; current-&gt;firstChild = r-&gt;nextSibling;//脱链要删除的子树 &#125; else &#123; int k = 1; TreeNode&lt;T&gt;* p = current-&gt;firstChild; while (p != nullptr &amp;&amp; k &lt;= i - 1) &#123;//寻找指向要删除子树的指针 p = p-&gt;nextSibling; k++; &#125; if (p != nullptr) &#123; r = p-&gt;nextSibling; if (r != nullptr) &#123; p-&gt;nextSibling = r-&gt;nextSibling;//脱链要删除的子树 &#125; else return;//要删除的子树为空时返回 &#125; else return;//查找失败 &#125; DeleteSubTree(r);//删除找到的要删除的子树 return;//删除成功&#125;template&lt;class T&gt;inline void Tree&lt;T&gt;::DisplayTree()&#123; PreOrderTree(root);&#125;template&lt;class T&gt;inline void Tree&lt;T&gt;::PreOrderTree(TreeNode&lt;T&gt;*&amp; t)&#123; if (t == nullptr) return; cout &lt;&lt; t-&gt;data &lt;&lt; " ";//显示根节点数据 if (t-&gt;firstChild != nullptr) PreOrderTree(t-&gt;firstChild); if (t-&gt;nextSibling != NULL) PreOrderTree(t-&gt;nextSibling);&#125;template&lt;class T&gt;inline void Tree&lt;T&gt;::PosOrderTree(TreeNode&lt;T&gt;*&amp; t)&#123; if (t == nullptr) return; if (t-&gt;firstChild != nullptr) PosOrderTree(t-&gt;firstChild); cout &lt;&lt; t-&gt;data &lt;&lt; " ";//显示根节点 if (t-&gt;nextSibling != nullptr) PosOrderTree(t-&gt;nextSibling);&#125;template&lt;class T&gt;inline int Tree&lt;T&gt;::Current(TreeNode&lt;T&gt;*&amp; t)&#123; if (t == nullptr) return 0; current = t; return 1;&#125;template&lt;class T&gt;inline TreeNode&lt;T&gt;* Tree&lt;T&gt;::SearchParent(TreeNode&lt;T&gt;*&amp; root, TreeNode&lt;T&gt;*&amp; s)&#123; //在树root中回溯查找结点s的双亲结点 //查找到时使current指向s结点的双亲结点 if (current == nullptr) return nullptr; if (root-&gt;firstChild == s || root-&gt;nextSibling == s) return root; TreeNode&lt;T&gt;* p; if ((p = SearchParent(root-&gt;firstChild, s)) != nullptr) return p; if ((p = SearchParent(root-&gt;nextSibling, s)) != nullptr) return p; return nullptr;&#125; 四、源码地址 ​ 树的实现源码]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>树</tag>
        <tag>树的实现</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二叉树]]></title>
    <url>%2F2019%2F%E4%BA%8C%E5%8F%89%E6%A0%91%2F</url>
    <content type="text"><![CDATA[一、二叉树的定义&emsp;二叉树（Binary Tree）是n（n&gt;=0)个有限结点构成的集合。n=0的树称为空二叉树；n&gt;0的二叉树由一个根节点和两个互不相交、分别称作左子树和右子树的子二叉树构成。 &emsp;二叉树是一种有序树。二叉树中某个结点即使只有一个子树，也要区分是左子树还是右子树。 &emsp;二叉树中所有结点的形态共有5种：空结点、无左右子树结点、只有左子树结点、只有右子树结点和左右子树均存在的结点。 &emsp;满二叉树。在一棵二叉树中，如果所有分支结点都存在左子树和右子树，并且所有叶子结点在同一层上，这样的二叉树称为满二叉树。 &emsp;完全二叉树。如果一棵具有n个结点的二叉树的结构与满二叉树的前n个结点的结构相同，这样的二叉树称为完全二叉树。 二、二叉树的性质 性质1：若规定根结点的层次为0，则一棵非空二叉树的第i层上最多有$2^i$(i&gt;=0)个结点。 性质2：若规定空树的深度为-1，则深度为k的二叉树的最大结点数是$2^{k+1}-1$(k&gt;=-1)个。 性质3：对于一棵非空的二叉树，如果叶节点的个数为$n_0$，度为2的结点数为$n_2$,则有$n_0=n_2+1$. 性质4：对于具有n个结点的完全二叉树，如果按照从上至下和从左至右的顺序对所有结点从0开始顺序编号，则对于任意的序号为i的结点，有： 如果i&gt;0,则序号为i结点的双亲结点的序号为（i-1)/2，如果i=0，则序号为i的结点为根结点，无双亲结点。 如果2i+1&lt;n，则序号为i结点的左孩子结点的序号为2i+1；如果2i+1&gt;=n,则序号为i结点无左孩子。 如果2i+2&lt;n,则序号为i结点的右孩子结点的序号为2i+2;如果2i+2&gt;=n,则序号为i的结点无右孩子。 三、二叉树的操作&emsp;二叉树是由一个根结点和两个互不相交的、分别称为左子树和右子树的子二叉树构成。因此，二叉树的操作和树的操作多数及基本类同，只在子树操作上略有不同。 &emsp;二叉树的操作也分为三类：第一类，找满足某种特定关系的结点；第二类，插入或删除某个结点；第三类，遍历树中每个结点。 第一类操作 寻找根结点使之成为当前结点 寻找当前结点的双亲结点使之成为当前结点 寻找当前结点的左孩子结点使之成为当前结点 寻找当前结点的右孩子结点使之成为当前结点 第二类操作 在二叉树的当前结点上插入一个新结点，使新插入的节点称为当前结点的左孩子结点 在二叉树的当前结点上插入一个新结点，使新插入结点成为当前结点的右孩子结点 在二叉树的当前结点插入一个新子树，使新插入子树称为当前结点的左子树 在二叉树的当前结点插入一个新子树，使新插入子树称为当前结点的右子树 删除二叉树的当前结点的左孩子结点 删除二叉树的当前结点的右孩子结点 删除二叉树的当前结点的左子树 删除二叉树的当前结点的右子树 第三类操作 按某种方式遍历一棵二叉树显示二叉树中每个结点的数据域值 按某种方式遍历一棵二叉树寻找数据元素域为某一值的结点 先序遍历（DLR）递归算法 访问根结点 前序遍历根结点的左子树 前序遍历根结点的右子树 中序遍历（LDR）递归算法 中序遍历根结点的左子树 访问根结点 中序遍历根结点的右子树 后序遍历（LRD）递归算法 后序遍历根结点的左子树 后序遍历根结点的右子树 访问根结点 二叉树还有层序遍历。二叉树的层序遍历要求按照从根结点至叶结点、从左子树至右子树的次序访问二叉树的结点。二叉树的层序遍历算法为： 初始化设置一个队列，并把根结点加入队列 当队列非空时，循环下面注明的步骤③到步骤⑤；否则到步骤⑥ 出队列取得一个结点，访问该结点的（步骤③） 若该结点的左子树非空，则将该结点的左子树入队列 若该结点的右子树非空，则将该结点的右子树入队列（步骤⑤） 结束。 四、二叉树的存储结构&emsp;二叉树的存储结构主要有三种：顺序存储结构、链式存储结构和仿真指针存储结构。 二叉树的顺序存储结构 &emsp;对于一般的二叉树，如果按从上至下和从左至右的次序存储在一组从0开始的连续内存单元中，则数据下标之间的关系就不能反映二叉树中结点之间的逻辑关系。此时，可在一般二叉树中增添一些并不存在的空结点使之变成完全二叉树的形态，然后再用二叉树的顺序存储结构存储。 &emsp;完全二叉树使用顺序存储结构存储时，既能节省存储空间，又能使二叉树的操作实现简单。但对于一般二叉树，如果它接近于完全二叉树，需要增加的空结点数目不多时，可采用顺序存储结构存储。但如果需要增加许多空结点时，就不宜采用顺序存储结构存储。最坏的情况是右单只树，一棵深度为k的右单只树只有k个结点，却需分配$2^k$-1个存储单元。 二叉树的链式存储结构 &emsp;二叉树的链式存储结构方式用指针建立二叉树中结点之间的关系。二叉树最常用的链式存储结构是二叉链。二叉链存储结构的每个结点包含三个域：数据域data，左子树指针域leftChild和右子树指针域rightChild。 &emsp;二叉树的二叉链存储结构是一种常用的二叉树存储结构。二叉链存储结构的优点是：结构简单，可以方便地构造任意需要的二叉树，可以方便地实现二叉树操作中的大多数操作。二叉链仓促结构的缺点是查找当前结点的双亲结点操作实现起来比较麻烦。 &emsp;二叉树的另一种常用的存储结构是三叉链。三叉链式在二叉链的基础上再增加一个双亲结点指针域parent。三叉链除基于二叉链的优点外，对于查找当前结点的双亲结点操作实现起来也很容易。相对于二叉链，三叉链的缺点是结构更为复杂，因而每个结点占用的内存单元也更多一些。 二叉树的仿真指针存储结构 &emsp;二叉树的仿真指针存储结构是用数组存储二叉树中的结点，再增加仿真指针域仿真常规指针建立二叉树中结点之间的关系。二叉树的仿真指针存储结构有仿真二叉链存储结构和仿真三叉链存储结构。 &emsp;仿真指针存储结构的最大优点是遍历操作实现非常容易。用for循环或while循环就可实现。仿真指针存储结构的最大缺点是可存储的结点个数受初始化定义的数组元素个数限制。 五、树和二叉树的转换 树转换为二叉树 树中所有相同双亲结点的兄弟结点之间加一条连线 对树中不是双亲结点第一个孩子的结点，只保留它与左兄弟结点之间的连线，删去该结点与双亲结点之间的连线 整理所有保留的和添加的连线，使每个结点的孩子结点连线位于左孩子指针位置，使每个结点的右兄弟结点连线位于右孩子指针位置 二叉树还原为树 若某结点是其双亲结点的左孩子，则把该结点的右孩子、右孩子的右孩子……都与该结点的双亲结点用线连起来 删除原二叉树中所有双亲结点与右孩子结点的连线 整理所有保留的和添加的连线，使每个结点的孩子结点连线顺序位于下方孩子结点位置]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>二叉树</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[树]]></title>
    <url>%2F2019%2F%E6%A0%91%2F</url>
    <content type="text"><![CDATA[一、仿真指针&emsp;在链式存储结构中，我们实现数据元素之间的次序关系依靠指针。在使用数据存储数据元素时，我们可在存储数据元素的数组中增加一个或几个数据下标域，这些数据下标域的值表示了该数组中某个数据元素的下标。由于在数据中增加的数据下标域仿真了链式存储结构中的指针域，所以这种存储结构也称为仿真指针。 &emsp;仿真指针也可英语存储如树和二叉树的非线性结构。当仿真指针用于存储树或二叉树时通常需要一个以上的仿真指针域。 二、树的定义树是由n个有限节点构成的集合。n=0的树为空树，对于n&gt;0的树T有： 有一个特殊的节点称为根节点，根节点没有前趋节点 当n&gt;1时，除根节点外其他节点被分成m（m&gt;0）个互不相交的集合T1,T2……,Tm。其中，每一个集合Ti本身又是一棵称为根节点的子树的树。 &emsp;&emsp;显然，树是递归定义的，即在树的定义中用到了树本身，因此，在包含树结构的算法中将会频繁地出现递归。 三、树的常用术语 结点。在树中通常把数据元素和构造数据元素之间的指针合起来称为结点。 结点的度。结点所拥有的子树的个数称为该结点的度。 叶结点。度为0的结点称为叶结点，叶结点也称为终端结点。 分支结点。度不为0的结点会称为分支结点，分支结点也称为非终端结点。显然，一棵树中除了叶结点外的所有节点都是分支结点。 孩子结点。树中一个结点的子树的根节点称为这个节点的孩子结点. 双亲结点。若树中某结点有孩子结点，则该结点就称为它的孩子结点的双亲结点。双亲结点也称为前趋结点。 兄弟结点。具有相同的双亲结点被称为兄弟结点。 祖先结点。从根结点到树中某结点经过的所有分支结点被称为该结点的祖先结点。一个树中根结点是该树中所有其他结点的祖先结点。 子孙结点。某一节点的所有孩子结点，以及这些孩子结点的孩子结点称为该结点的子孙结点。一个树中所有结点都是根结点的子孙结点。 树的度。树中所有结点的度的最大值称为该树的结点。 结点的层次。从根结点到树中某结点所经路径上的分支数称为该结点额层次。通常规定根结点的层次为0，这样其他结点的层次就是它的双亲结点的层次加1. 树的深度。树中所有结点的层次的最大值称为该树的深度。空树的深度规定为0. 无序树。树中任意一个结点的各个子树之间的次序构成无关紧要，即交换树中任意一个结点的各个子树的次序均和原树相同的树称为无序树。树均定义为无序树。 有序树。树中任意一个结点的各个子树都是有次序的树称为有序树。二叉树是一种有序树。 森林。m(m&gt;=0)棵树的集合称为森林。 四、树的基本操作&emsp;&emsp;由于树是非线性结构，节点之间的关系较线性结构复杂得多，所以树的操作也复杂得多。表示一棵树的数据成员一般来说不仅要有树的根节点指针（简称根指针），还应有树的当前操作节点指针（简称当前指针）。当前指针能保证当对树的某个节点操作后，下一次再要对其相邻节点（如该节点的双亲节点或该节点的第一个孩子节点）操作时不至于又从根节点开始查找起。&emsp;&emsp;树的操作主要分为三大类：第一类，寻找满足某种特定关系的节点；第二类，插入或删除某个节点；第三类，遍历树中每个节点。 第一类操作。 寻找根节点使之成为当前节点 寻找当前节点的双亲节点使之成为当前节点 寻找当前节点的第一个孩子节点使之后才能为当前节点 寻找当前节点的下一个兄弟节点使之成为当前节点这一类操作时树的其他两类操作的基础操作，如插入操作就可设计成在当前节点插入一个新节点。 第二类操作 在树的当前节点上插入一个新节点，使新插入节点成为当前节点的第i个孩子节点 删除树的当前节点的第i个孩子节点 在树的当前节点上插入一个新子树，使新插入子树称为当前节点的第i棵子树 删除树的当前节点的第i棵子树 第三类操作 按某种方式遍历一棵树显示树中每个节点的数据域值 按某种方式遍历一棵树寻找数据元素域为某一值的节点 &emsp;&emsp;树的遍历操作是指按照某种方式访问树中的每一个节点且每一个节点只被访问一次。对于线性结构，通过for循环或while循环就可访问其中的每一个数据元素且每一个数据元素只被访问一次。但是对于树这种非线性数据结构，for循环和while循环就无法访问树中的每一个节点且每一个节点只被访问一次。树的遍历操作算法主要有先根遍历和后根遍历两种。下面的先根遍历和后根遍历算法都是递归的。 先根遍历。先根遍历算法为： 访问根节点 按照从左到右的次序先根遍历根节点的每一棵子树 后根遍历。后根遍历算法为： 按照从左导游的次序后根遍历根节点的每一棵子树 访问根节点 &emsp;&emsp;此外，树的遍历算法还有层序遍历。树的层序遍历是要求按照从根节点至叶节点、从第一棵子树到最后一棵子树的次序访问树的节点。 五、树的存储结构计算机中树的存储要求既要存储节点的数据元素，又要存储节点之间的逻辑关系。构造节点之间的逻辑关系的方法可用指针或仿真指针。 1.双亲表示法 &emsp;&emsp;双亲表示法是用仿真指针结构存储树。具体方法是用一组连续的存储单元（数组）存储树中的所有节点，每个节点有两个域，一个域是数据域，一个域是指示其双亲节点在数组中下标序号的仿真指针域。&emsp;&emsp;双亲表示法的仿真指针也可以改为常规的指针域。双亲表示法对于实现前述的树的基本操作中寻找双亲节点和寻找根节点使它们各自成为当前节点操作很方便，但是对于实现寻找第一个孩子节点和循环下一个兄弟节点使它们各自成为当前节点却很不方便。 2.孩子表示法 &emsp;&emsp;由于树中每个节点的子树个数（即节点的度）不同，如果按照各个节点的度设计变长结构，则每个节点的孩子节点指针域个数增加使算法实现非常麻烦。孩子表示法可按树的度（即树中所有节点度的最大值）设计节点的孩子节点指针域的个数。同样，节点的孩子节点指针域可以是仿真指针，也可以是常规指针。 3.双亲孩子表示法 &emsp;&emsp;树的存储结构若把双亲表示法和孩子表示法结合起来可使之兼有这两种存储结构的优点。可有许多种结合双亲表示法和孩子表示法的存储结构方法。一种双亲孩子表示法是在仿真指针双亲表示法的基础上，给数组得到每个节点增加一个指向该节点所有孩子节点链表的常规指针。 4.孩子兄弟表示法 &emsp;&emsp;孩子兄弟表示法是为每个节点设计三个域，一个数据元素域，一个该节点的第一个孩子指针域，一个该节点的下一个兄弟节点指针域。此种孩子兄弟表示法的两个域通常都是常规指针。&emsp;&emsp;由于树的孩子兄弟表示法有两个指针域，并且这两个指针是有序的，所以孩子兄弟表示法是将树转换为二叉树的存储结构。把二叉树转换为二叉树所对应的结构恰好就是这种孩子兄弟表示法结构，所以，孩子兄弟表示法的最大优点是可方便地实现树和二叉树的相互转换。但是，孩子兄弟表示法的缺点也和孩子表示法的缺点一样，就是从当前节点查找双亲节点比较麻烦，需要从树的根节点开始逐个查找。]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[继承]]></title>
    <url>%2F2019%2F%E7%BB%A7%E6%89%BF%2F</url>
    <content type="text"><![CDATA[一、继承&emsp;继承是面向对象编程额基本概念之一。继承使我们能在已有类的基础上构造新类。这个新的类拥有或继承已有类的数据成员和成员函数，也可添加新的数据成员和成员函数，对已有的类进行扩充。这个已有的类就称为基类,而这个新类则称为派生类。 &emsp;如果我们需要定义一个个人类和职工类，在不使用继承的情况下，代码重复会比较严重。这时，我们就需要用到继承。 &emsp;下面定义一个基类网页，重复的代码都写到这个网页上。 1234567891011121314151617181920212223242526//基类class BasePage&#123;public: void header() &#123; cout &lt;&lt; "公共头部" &lt;&lt; endl; &#125; void footer() &#123; cout &lt;&lt; "公共底部" &lt;&lt; endl; &#125; void left() &#123; cout &lt;&lt; "公共左侧列表" &lt;&lt; endl; &#125;&#125;;class News :public BasePage//继承BasePage&#123;public: void content() &#123; cout &lt;&lt; "今日新闻" &lt;&lt; endl; &#125;&#125;; 主函数： 12345678910int main()&#123; News news; news.header(); news.left(); news.footer(); news.content(); system("pause"); return EXIT_SUCCESS;&#125; 执行结果： 继承可以减少代码的重复部分，派生类可以继承基类的数据成员和成员函数。 网页中有很多公共部分，导致实现的时候由很多重复的代码。在使用继承之后，基类为公共网页，具体的子类实现把不同的内容，较好地解决了代码的复用。 二、继承方式继承方式主要有： public：公有继承 private：私有继承 protected：保护继承 不管是公有继承、保护继承还是私有继承，基类中的私有属性，都不可以继承下去 在公有继承中，父类的protected属性在子类中是protected属性。父类中的public属性在子类中是public属性 在保护继承中，父类中的protected属性，在子类中是protected属性。父类中的public属性在子类中是protected属性 在私有继承中，父类中的protected属性在子类中是private属性。父类中的public属性在子类中是private属性。 三、继承中的构造和析构顺序123456789101112131415161718192021222324class Base&#123;public: Base() &#123; cout &lt;&lt; "Base默认构造函数调用" &lt;&lt; endl; &#125; ~Base() &#123; cout &lt;&lt; "Base析构函数调用" &lt;&lt; endl; &#125;&#125;;class Son:public Base&#123;public: Son() &#123; cout &lt;&lt; "Son默认构造函数调用" &lt;&lt; endl; &#125; ~Son() &#123; cout &lt;&lt; "Son析构函数调用" &lt;&lt; endl; &#125;&#125;; 12345678//子类会继承父类的成员属性，成员函数//但是子类不会继承父类的构造函数和析构函数//只有父类自己知道如何构造和析构自己的属性，而子类不知道void test02()&#123; Base base; Son son;&#125; 执行结果： 子类在创建对象时，先调用父类的构造函数，然后再调用自身的构造函数 析构顺序与构造顺序相反 子类不会继承父类的构造函数和析构函数 如果父类中没有合适默认构造，那么子类可以利用初始化列表方式显式地调用父类的其他构造函数。 1234567891011121314151617181920212223242526272829303132class Base&#123;public: Base() &#123; cout &lt;&lt; "Base默认构造函数调用" &lt;&lt; endl; &#125; ~Base() &#123; cout &lt;&lt; "Base析构函数调用" &lt;&lt; endl; &#125; Base(int a) &#123; cout &lt;&lt; "有参构造函数调用,参数为：" &lt;&lt; a &lt;&lt; endl; &#125;&#125;;class Son:public Base&#123;public: Son() &#123; cout &lt;&lt; "Son默认构造函数调用" &lt;&lt; endl; &#125; Son(int a) :Base(a) &#123; cout &lt;&lt; "Son初始化列表调用父类带参构造" &lt;&lt; a &lt;&lt; endl; &#125; ~Son() &#123; cout &lt;&lt; "Son析构函数调用" &lt;&lt; endl; &#125;&#125;; 123456789//子类会继承父类的成员属性，成员函数//但是子类不会继承父类的构造函数和析构函数//只有父类自己知道如何构造和析构自己的属性，而子类不知道void test02()&#123; Base base; Son son; Son son2(15);&#125; 执行结果： 四、继承中同名函数的处理 如果子类和父类拥有同名的函数、属性，子类不会覆盖父类的成员 如果子类与父类的成员函数名称相同，子类会把父类的所有同名版本都隐藏掉 如果想调用父类的方法，必须加作用域 成员属性直接调用是子类的，如果想调用父类的成员属性，需要加作用域 成员函数直接调用先调用子类的，父类的所有版本都会被隐藏，除非显式地用作用域运算符去调用。 12345678910111213141516171819class Base0&#123;public: Base0() &#123; m_A = 100; &#125; int m_A;&#125;;class Son0:public Base0&#123;public: Son0() &#123; m_A = 20; &#125; int m_A;&#125;; 12345678void test03()&#123; Son0 s1; cout &lt;&lt; "子类中的属性："; cout &lt;&lt; s1.m_A &lt;&lt; endl; cout &lt;&lt; "父类中的属性："; cout &lt;&lt; s1.Base0::m_A &lt;&lt; endl;&#125; 执行结果： 五、继承中的静态成员处理 如果基类定义了一个静态成员，则在整个继承体系中只存在该成员的唯一定义。不论从基类中派生出多少个派生类，对于每个静态成员来说都只存在唯一的实例。 静态成员遵循通用的访问控制规则，如果基类中的成员是private的，则派生类无权访问它。假设某静态成员是可访问的，则我们既能通过基类使用它，也可以通过派生类使用它。 12345678910111213141516171819class Father&#123;public: static int m_A; static void func() &#123; cout &lt;&lt; "Father func()" &lt;&lt; endl; &#125;&#125;;int Father::m_A = 200;class Son1 :public Father&#123;public: static int A; static void func() &#123; cout &lt;&lt; "Son func()" &lt;&lt; endl; &#125;&#125;; 123456789void test04()&#123; cout &lt;&lt; "Father的静态成员值为："; cout &lt;&lt; Father::m_A &lt;&lt; endl; cout &lt;&lt; "Son1继承的静态成员值为："; cout &lt;&lt; Son1::m_A &lt;&lt; endl; Son1::func(); Father::func();&#125; 执行结果： 六、防止继承的发生有时候我们会定义这样一种类，我们不希望其他类继承它，或者不想考虑它是否合适作为一个基类。为了实现这个目的，C++11新标准提供了一种防止继承发生的方法，即在类后跟一个关键字final。 七、菱形继承（钻石继承）的问题&emsp;两个派生类继承同一个基类，而又有某个类同时继承了两个派生类，这种继承被称为菱形继承，或者钻石继承。 这种继承带来的问题： 羊继承了动物的数据和函数，驼继承了动物的数据和函数，羊驼同时继承了羊和驼的数据和函数。当羊驼调用函数或者数据时，就会产生二义性。 羊驼继承自动物的函数和数据继承了两份，其实我们应该清楚，这份数据我们只需要一份就可以了。 解决办法： 采用虚继承的方式来解决。通过虚继承的方式，可以保证羊驼类中只有一份动物类的属性和函数的赋值，因此可以避免菱形继承的二义性，也就解决了“钻石继承”的问题。 123456789101112131415161718192021//动物类class Animal&#123;public: int m_Age;&#125;;//羊类class Sheep :virtual public Animal&#123; &#125;;//驼类class Tuo :virtual public Animal&#123;&#125;;//羊驼类class SheepTuo :public Tuo, public Sheep&#123;&#125;; 1234567891011121314void test06()&#123; SheepTuo st; st.Sheep::m_Age = 10; st.Tuo::m_Age = 20; st.m_Age = 5; cout &lt;&lt; "驼的年龄为"; cout &lt;&lt; st.Tuo::m_Age &lt;&lt; endl; cout &lt;&lt; "羊的年龄为："; cout &lt;&lt; st.Sheep::m_Age &lt;&lt; endl; cout &lt;&lt; "羊驼的年龄为："; //可以直接访问，没有二义性的可能，只有一份数据 cout &lt;&lt; st.m_Age &lt;&lt; endl;&#125; 执行结果： 八、源码地址​ 继承源码示例]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>继承</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[stack和queue]]></title>
    <url>%2F2019%2Fstack%E5%92%8Cqueue%2F</url>
    <content type="text"><![CDATA[stack 一、stack概述 &emsp;stack是一种先进后出（First In Last Out，FILO)的数据结构，它只有一个出口。stack允许新增元素、移除元素、取得最顶端元素。但是除了最顶端外，没有任何其他方法可以存取其他元素，换言之，stack不允许有遍历行为。 二、stack没有迭代器 &emsp;stack所有元素的进出都必须符合“先进后出”的条件，只有stack顶端的元素才有机会被外界取用。stack不提供遍历功能，也不提供迭代器。 三、stack常用API 栈顶top 压栈push 栈顶弹出pop 大小 size 是否empty 示例： 12345678910111213141516171819202122void stest()&#123; stack&lt;int&gt;istack; if (istack.empty()) &#123; cout &lt;&lt; "stack为空!" &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; "stack的大小为：" &lt;&lt; istack.size() &lt;&lt; endl; &#125; for (int i = 0; i &lt; 10; i++) &#123; istack.push(i); &#125; cout &lt;&lt; "stack的大小为：" &lt;&lt; istack.size() &lt;&lt; endl; cout &lt;&lt; "stack的栈顶元素为：" &lt;&lt; istack.top() &lt;&lt; endl; cout &lt;&lt; "弹出栈顶元素后:" &lt;&lt; endl; istack.pop(); cout &lt;&lt; "stack的大小为：" &lt;&lt; istack.size() &lt;&lt; endl; cout &lt;&lt; "stack的栈顶元素为：" &lt;&lt; istack.top() &lt;&lt; endl;&#125; 输出结果： queue 一、queue概述 &emsp;queue是一种先进先出（First In First Out，FIFO）的数据结构。它有两个出口。queue允许新增元素、移除元素、从最低端加入元素、取得最顶端元素。但除了最底端可以加入、最顶端可以取出外，没有任何办法可以存取queue的其他元素。换言之，queue不允许有遍历行为。 二、queue没有迭代器 &emsp;queue所有元素的进出都必须符合“先进先出“的条件，只有queue顶端的元素，才有机会被外界取用。queue不提供遍历功能，也不提供迭代器。 三、queue常用API 先进先出 队头front 队尾back 入队 push 弹出队头 pop 大小 size 为空 empty 示例: 12345678910111213141516void qtest()&#123; queue&lt;int&gt;iqueue; for (int i = 0; i &lt; 10; i++) &#123; iqueue.push(i); &#125; cout &lt;&lt; "队头为：" &lt;&lt; iqueue.front() &lt;&lt; endl; cout &lt;&lt; "队尾为：" &lt;&lt; iqueue.back() &lt;&lt; endl; cout &lt;&lt; "iqueue的大小为：" &lt;&lt; iqueue.size() &lt;&lt; endl; iqueue.pop(); cout &lt;&lt; "弹出队头后：" &lt;&lt; endl; cout &lt;&lt; "队头为：" &lt;&lt; iqueue.front() &lt;&lt; endl; cout &lt;&lt; "队尾为：" &lt;&lt; iqueue.back() &lt;&lt; endl; cout &lt;&lt; "iqueue的大小为：" &lt;&lt; iqueue.size() &lt;&lt; endl;&#125; 输出结果： 四、源码地址 ​ stack and queue示例源码]]></content>
      <categories>
        <category>STL</category>
      </categories>
      <tags>
        <tag>STL</tag>
        <tag>stack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[deque容器]]></title>
    <url>%2F2019%2Fdeque%E5%AE%B9%E5%99%A8%2F</url>
    <content type="text"><![CDATA[一、deque概述 &emsp;vector是单向开口的连续线性空间，deque则是一种双向开口的连续线性空间。所谓双向开口，意思是可以在头尾两端分别做元素的插入和删除操作。虽然vector容器也可以在头尾两端插入元素，但是在其头部操作效率奇差，无法被接受。 &emsp;deque容器和vector容器最大的差异在于： deque允许使用常数项时间对头端进行元素的插入和删除 deque没有容量的概念，因为它是动态的以分段连续空间组成的，随时可以增加一段新的空间并链接起来，换句话说，像vector那样“旧空间不足而重新配置一块更大的空间，然后复制元素，再释放旧空间”这样的事情不会在deque发生，也因此，deque没有必要提供所谓的空间保留功能。 虽然deque容器也提供Random Access Iterator，但是它的迭代器并不是普通指针，其复杂度和vector不是一个量级，这当然影响各个运算的层面，除非必要，我们应该尽可能选择vector而不是deque，对deque进行的排序操作，为了最高效率，可将deque先完整复制到一个vector中，将vector排序后，再复制回deque。 二、deque容器的中控器 &emsp;deque是由一段一段定量连续空间构成。一旦有必要在deque的前端或尾端增加新空间，便配置一段定量连续空间，串接在整个deque的头端或尾端，deque的最大任务，便是在这些分段的定量连续空间上，维护其整体连续的假象，并提供随机存取的接口，避开了“重新配置、复制、释放”的轮回，代价则是复杂的迭代器架构。 &emsp;deque为分段连续空间，就必须有中央控制，而为了维持整体连续的假象，数据结构的设计及迭代器前进后退等操作都颇为繁琐。deque的实现代码分量远比vector或list都多得多。 &emsp;采用一块所谓的map（不是STL的map）作为主控。这里所谓的map是一小块连续空间，其中每个元素都是指针，指向另一段（较大的）连续线性空间，称为缓冲区。缓冲区才是deque存储空间主体。 三、deque迭代器 1234T* cur;//此迭代器指向缓冲区中当前的元素T* first;//此迭代器指向缓冲区的头T* last;//此迭代器指向缓冲区的尾map_pointer node;//指向中控器中心 四、deque常用API 1.deque构造函数 1234deque&lt;T&gt; deqT;//默认构造形式deque(beg,end);//构造函数将[beg,end)区间中的元素拷贝给本身deque(n,elem);//构造函数将n个elem拷贝给本身deque(const deque &amp;deq);//拷贝构造函数 示例： 12345678910void test01()&#123; deque&lt;int&gt;deq1(5,10);//构造deq1 deque&lt;int&gt;deq2(deq1);//拷贝构造deq2 displayDeque(deq1);//打印deq1 cout &lt;&lt; endl; displayDeque(deq2); deque&lt;int&gt;deq3(deq2.begin(), deq2.begin() + 3);//区间拷贝方式构造deq3 cout &lt;&lt; endl; displayDeque(deq3); 输出结果： 2.deque赋值操作 1234assign(beg,end);//将[beg,end)区间中的数据拷贝给本身assign(n,elem);//将n个elem拷贝赋值给本身deque&amp; operator=(const deque &amp;deq);//重载等号操作符swap(deq);//将deq与本身的元素互换 示例： 123456789101112131415161718192021222324void test02()&#123; deque&lt;int&gt;deq1(5, 10);//构造deq1 deque&lt;int&gt;deq2(10, 15); deq1.assign(deq2.begin(), deq2.begin() + 3);//将deq2下标为0,1,2的数据拷贝给deq1 cout &lt;&lt; "deq1:"; displayDeque(deq1); cout &lt;&lt; endl; deq1.assign(4, 4); cout &lt;&lt; "deq1:"; displayDeque(deq1); cout &lt;&lt; endl; cout &lt;&lt; "deq2:"; displayDeque(deq2); cout &lt;&lt; endl; deq1.swap(deq2); cout &lt;&lt; "deq1和deq2的数据交换后：" &lt;&lt; endl; cout &lt;&lt; "deq1:"; displayDeque(deq1); cout &lt;&lt; endl; cout &lt;&lt; "deq2:"; displayDeque(deq2); cout &lt;&lt; endl;&#125; 输出结果： 3.deque大小操作 1234deque.size();//返回容器中元素的个数deque.empty();//判断容器是否为空deque.resize(num);//重新指定容器的长度为num，若容器变长，则以默认值填充新位置。如果容器变短，则末尾超出容器长度的元素被删除deque.resize(num,elem);//重新指定容器的长度为num，若容器变长，则以elem值填充新位置，如果容器变短，则末尾超出容器长度的元素被删除 示例： 123456789101112131415161718192021222324252627void test03()&#123; deque&lt;int&gt;deq1(5, 10); cout &lt;&lt; "deq1的长度为：" &lt;&lt; deq1.size() &lt;&lt; endl; if (deq1.empty()) &#123; cout &lt;&lt; "deq1为空!" &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; "deq1非空!长度为：" &lt;&lt; deq1.size() &lt;&lt; endl; displayDeque(deq1); cout &lt;&lt; endl; &#125; deq1.resize(10);//重新指定deq的长度为10, cout &lt;&lt; "指定deq1的长度为10时，其元素为："; displayDeque(deq1); cout &lt;&lt; endl; deq1.resize(15, 100); cout &lt;&lt; "指定deq1的长度为15时，其元素为："; displayDeque(deq1); cout &lt;&lt; endl; deq1.resize(3,100); cout &lt;&lt; "指定deq1的长度为3时，其元素为："; displayDeque(deq1); cout &lt;&lt; endl;&#125; 输出结果： 4.deque双端插入和删除操作 1234push_back(elem);//在容器尾部添加一个数据push_front(elem);//在容器头部插入一个数据pop_back();//删除容器最后一个数据pop_front();//删除容器第一个数据 示例: 1234567891011121314151617181920void test04()&#123; deque&lt;int&gt;deq1(5, 5); cout &lt;&lt; "deq1："; displayDeque(deq1); cout &lt;&lt; endl; deq1.push_back(100); cout &lt;&lt; "deq1.push_back(100)后为："; displayDeque(deq1); cout &lt;&lt; endl; deq1.push_front(15); cout &lt;&lt; "deq1.push_front(15)后为："; displayDeque(deq1); cout &lt;&lt; endl; deq1.pop_back(); deq1.pop_front(); cout &lt;&lt; "deque删头去尾后为："; displayDeque(deq1); cout &lt;&lt; endl;&#125; 输出结果： 5.deque数据存取 1234at(index);//返回索引index所指的数据，如果index越界，抛出out_of_rangeoperator[];//返回索引index所指向的数据，如果index越界，不抛出异常，直接出错front();//返回第一个数据back();//返回最后一个数据 示例： 1234567891011121314void test05()&#123; deque&lt;int&gt; deq1(5, 15); //cout &lt;&lt; "索引为5的元素为：" &lt;&lt; deq1.at(5) &lt;&lt; endl; //上面的输出语句报错，抛出out_of_range cout &lt;&lt; "索引为3的元素为：" &lt;&lt; deq1.at(3) &lt;&lt; endl; deq1.push_front(44); cout &lt;&lt; "索引为0的元素为：" &lt;&lt; deq1.at(0) &lt;&lt; endl; //cout &lt;&lt; deq1[15] &lt;&lt; endl;//越界报错 cout &lt;&lt; "索引为3的元素为：" &lt;&lt; deq1[3] &lt;&lt; endl; cout &lt;&lt; "索引为0的元素为：" &lt;&lt; deq1[0] &lt;&lt; endl; cout &lt;&lt; "deq的首元素为：" &lt;&lt; deq1.front() &lt;&lt; endl; cout &lt;&lt; "deq的尾元素为：" &lt;&lt; deq1.back() &lt;&lt; endl;&#125; 输出结果： 6.deque插入操作 123insert(pos,elem);//在pos位置插入一个elem元素的拷贝，返回新数据的位置insert(pos,n,elem);//在pos位置插入n个elem数据，无返回值insert(pos,beg,end);//在pos位置插入[beg,end)区间的数据，无返回值 示例： 123456789101112131415161718192021222324252627void test06()&#123; deque&lt;int&gt; deq1(5, 15); cout &lt;&lt; "deq1:"; displayDeque(deq1); cout &lt;&lt; endl; deq1.insert(deq1.begin() + 3, 18); cout &lt;&lt; "deq1:"; displayDeque(deq1); cout &lt;&lt; endl; deq1.insert(deq1.begin(),2,20); cout &lt;&lt; "deq1:"; displayDeque(deq1); cout &lt;&lt; endl; deq1.erase(deq1.begin()); cout &lt;&lt; "deq1:"; displayDeque(deq1); cout &lt;&lt; endl; deq1.erase(deq1.begin(), deq1.begin() + 5); cout &lt;&lt; "deq1:"; displayDeque(deq1); cout &lt;&lt; endl; deq1.clear(); cout &lt;&lt; "deq1:"; displayDeque(deq1); cout &lt;&lt; endl;&#125; 输出结果： 7.deque删除操作 123clear();//移除容器的所有数据erase(beg,end);//删除[beg,end)区间的数据，返回下一个数据的位置erase(pos);//删除pos位置的很舒服，返回下一个数据的位置 如上例所示。 五、源码地址 ​ deque容器示例源码]]></content>
      <categories>
        <category>STL</category>
      </categories>
      <tags>
        <tag>STL</tag>
        <tag>deque</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用点对点信道的数据链路层]]></title>
    <url>%2F2019%2F%E7%82%B9%E5%AF%B9%E7%82%B9%E4%BF%A1%E9%81%93%E7%9A%84%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%2F</url>
    <content type="text"><![CDATA[一、数据链路层的功能 &emsp;&emsp;数据链路层在物理层提供服务的基础上向网络层提供服务，其主要作用是加强物理层传输原始比特流的功能，将物理层提供的可能出错的物理连接改造为逻辑上无差错的数据链路，使之对网络层表现为一条无差错的链路。 为网络层提供服务 对网络层而言，数据链路层的基本任务是将源机器中来自网络层的数据传输到目标其的网络层。数据链路层通常可为网络层提供如下服务： （1）无确认的无连接服务。员及其发送数据帧时不需先建立链路连接，目的机器收到数据帧时不需发回确认。对丢失的帧，数据链路层不负责重发而交给上层处理。适用于实时通信或误码率较低的通信信道，如以太网 （2）有确认的无连接服务。源机器发送数据帧时不需先建立链路连接，但目的机器收到数据帧时必须发回确认。源机器在所规定的时间内未收到确定信号时，就重传丢失的帧，以提高传输的可靠性。该服务适用于误码率较高的通信信道，如无线通信 （3）有确认的面向连接服务。帧传输过程分为三个阶段：建立数据链路，传输帧，释放数据链路。目的机器对收到的每一帧都要给出确认，源机器收到确认后才能发送下一帧，因而该服务的可靠性最高。该服务适用于通信要求较高的场合 二、使用点对点信道的数据链路层 数据链路和帧 链路，就是从一个结点到相邻结点的一段物理线路，而中间没有任何其他的交换结点。 数据链路，当需要在一条线路上传送数据时，除了必须要有一条物理线路外，还必须要有一些必要的通信协议来控制这些数据的传输。若把实现这些协议的硬件和软件加到链路上，就构成了数据链路。这样的数据链路就不再是简单的物理链路而是个逻辑链路了。现在最常用的方法是使用网络适配器来实现这些协议的硬件和软件。一般的适配器都包括了数据链路层和物理层这两层功能。 帧，数据链路层把网络层交下来的数据构成帧发送到链路上，以及把接收到的帧中的数据报取出并上交给网络层。在因特网中，网络层协议数据单元就是IP数据报 点对点信道的数据链路层在进行通信时的主要步骤： 结点A的数据链路层把网络层交下来的IP数据报添加首部和尾部封装成帧 结点A把封装号的帧发送给结点B的数据链路层 若结点B的数据链路层收到的帧无差错，则从收到的帧中提取出IP数据报上交给上面的网络层，否则就丢弃这个帧 封装成帧 数据链路层以帧为单位传输和处理数据。网络层的IP数据报必须向下传送到数据链路层，成为帧的数据部分，同时它的前面和后面分别添加上首部和尾部，封装成一个完整的帧。帧的长度等于帧的数据部分的长度加上帧首部和帧尾部的长度。 数据链路层的接收方为了能以帧为单位处理接收的数据，必须正确地识别每个帧的开始和结束，即进行帧定界 首部和尾部的作用之一就是进行帧定界，同时也包括其他必要的控制信息。 每一种链路层协议都规定了帧的数据部分长度的上限，即最大传送单元(MTU) PPP协议采用的零比特填充法 在发送端，先扫描整个信息字段。只要发现有5个连续1，则立即填入一个0，经过这种零比特填充后的数据，就可以保证在信息字段中不会出现6个连续1. 接收端在收到一个帧时，先找到帧定界标志“Flag”以确定一个帧的边界，接着再用硬件对其中的比特流进行扫描。每当发现5个连续的1时，就把5个连续1后面的一个0删除，以还原成原来的数据比特流。 这样就保证了透明传输：在所传送的树比特流中可以包含任意组合的比特模式，而不会引起对帧定界的判断错误。 差错检测 现实的通信链路都不会是理想的，比特在传输过程中可能会产生差错：1可能会变为0,0可能会变为1，则就叫做比特差错 传输错误的比特占所传输比特总数的比率称为误码率 为了保证接收到的数据是正确的，在计算机网络传输数据时，必须采用某种差错检测措施。虽然各种差错检测技术的具体方法差别很大，但它们最基本的原理是一样的。 在数据链路层，为了便于硬件检测差错，通常在帧的尾部设置一个差错检验字段存放整个帧的差错检测码，这个差错检验字段常称为帧检验序列（FCS）。因此，要在数据链路层进行差错检验，就必须把数据划分成帧，每一帧都加上差错检验码，一帧接一帧地传送，然后再接收方逐帧进行差错检验。 在数据链路层通常使用循环冗余检验（CRC）技术进行差错检测。 CRC编码额基本原理是，发送方和接收方首先必须协商一个r+1比特的生成式G。算法要求G的最高位和最低位的比特为1,。考虑d比特的数据D，发送方要选择一个合适的r比特冗余码R（即检错码），并将它附加到D上，使得得到的d+r比特模式用模2算术恰好能被G整除。接收方进行差错检测时，用G去除接收到的d+r比特，如果余数非零则检测出差错，否则认为树正确。 模2运算中，加法不进位，减法不错位，等价于按位异或，乘以和除以2等价于左/右移位。 可靠传输 在某些情况下，我们需要数据链路层向上面的网络层提供“可靠传输”的服务。“可靠传输”就是要做到：发送端发送什么，在对应的接收端就收到什么。 为了实现可靠的单向数据传输，可靠传输协议需要进行双向通信，因此底层的不可靠信道必须是双向的。 （1）停止等待协议（SW） 当正确接收到一个分组时，向发送方发送一个确认分组ACK，当接收到的分组出现比特差错时，丢弃该分组并发送一个否认分组NAK。发送方收到ACK则可以发送下一个分组，而收到NAK则要重传原来的分组，直到收到ACK为止。由于发送方每发送完一个分组必须停下来等接收到确认后才能发送下一个分组，该协议被称为停止等待协议（SW） 如果底层的信道会丢失分组，当数据分组或确认分组丢失时，发送方将会一直等待接收方的确认分组。为了解决给问题，可以在发送方发送完一个数据分组时，启动一个超时计数器。若到了超时计数器所设置的重传时间而发送方仍收不到接收方的任何确认分组，则重传原来的分组，这就是超时重传。 当确认分组丢失时，接收方会收到两个同样的数据分组，即重复分组。若接收方不能识别重复分组，则会导致另一种差错——数据重复。为了解决该问题，必须使每个数据分组带上不同的发送序号。每发送一个新的数据分组就把它的发送序号加1.若接收方连续收到发送序号相同的数据分组，就表明出现了重复分组。这时应丢弃重复的分组，此时，接收方还必须向发送方补发一个确认分组ACK。 停止等待协议的优点是简单，但缺点是信道利用率太低。 假设存在发送方A，发送分组需要的时间是$T_D$,接收方B，发送确认分组需要时间$T_A$.如果A处理确认分组的时间可以忽略不计，那么A在经过时间（$T_D$+RTT+$T_A$)后就可以再发送下一个分组，这里的RTT是往返时间。因为仅仅是在时间$T_D$内采用来传送有用的数据，因此，信道的利用率U为：U=$\frac{TD}{TD+RTT+TA}$. 当RTT远大于分组发送时间$T_D$时，信道的利用率就会非常低 当RTT远小于发送时间$T_D$时，信道的利用率较高。 流水线传输方式就是发送方可连续发送多个分组，不必每发完一个分组就停下来等待对方的确认。这样可使得信道上一直有数据不间断地在传送。显然，这种传输方式可以获得很高的信道利用率。 （2）回退N帧协议（GBN） 回退N帧协议在流水线传输的基础上利用发送窗口来限制发送方连续发送分组的个数，是一种连续ARQ协议。 为此，在发送方要维持一个发送窗口。发送窗口时允许发送方已发送但还没有收到的分组序号的范围，窗口大小就是发送方已发送但还没有收到确认的最大分组数。 在协议的工作过程中，发送窗口不断向前滑动，因此，这类协议又称为滑动窗口协议。 GBN采用累积确认的方式。优点是容易实现，即使确认丢失也可能不必重传。但缺点是不能向发送方准确反映出接收方已经正确收到的所有分组的信息。 （3）选择重传协议 GBN协议存在一个缺点：一个分组的差错可能引起大量分组的重传，这些分组可能已经被接收方正确接收了，但由于未按序到达而被抛弃。显然对这些分组的重传是对通信资源的极大浪费。为进一步提高性能，可设法只重传出现差错的分组，但这时接收窗口不再为1，以便先收下失序到达但仍然处在接收窗口中的那些分组，等到所缺分组收齐后再一并送交上层，这就是选择重传（SR）协议。 为了使发送方仅重传出现差错的分组，接收方不能再采用累积确认，而需要对每个正确接收到的分组进行逐一确认。 （4）数据链路层的可靠传输 不可靠的链路加上适当的协议就可以使链路层向上提供可靠传输服务。但付出的代价是数据的传输效率降低了，而且增加了协议的复杂性。因此，应当根据链路的具体情况来决定是否需要让链路层向上提供可靠传输服务。 现在有线网络广泛使用的数据链路层协议一般都不使用确认和重传机制，即不要求数据链路层向上提供可靠传输服务。若数据链路层传输数据偶尔出现了差错，并且需要进行改正，则改正差错的任务就由上层协议来完成。实践证明，这样做可以提高通信效率，降低设备成本。]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>数据链路层</tag>
        <tag>差错检测</tag>
        <tag>可靠传输</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[list容器]]></title>
    <url>%2F2019%2Flist%E5%AE%B9%E5%99%A8%2F</url>
    <content type="text"><![CDATA[一、list容器概述 &emsp;&emsp;链表是一种物理存储单元上非连续、非顺序的存储结构，数据元素的逻辑顺序是通过链表中的指针链接次序实现的。链表由一系列结点（链表中每一个元素称为结点）组成，结点可以在运行时动态生成。每个结点包括两部分：一个是存储数据元素的数据域，另一个是存储下一个节点地址的指针域。 &emsp;&emsp;相较于vector的连续线性空间，list就显得复杂许多，它的好处是每次插入或删除一个元素，就配置或释放一个元素空间。因此，list对于空间的运用有绝对的精准，一点也不浪费。而且，对于任何位置的元素插入或移除，list永远都是常数时间。 &emsp;&emsp;list容器是一个双向链表 采用动态存储分配，不会造成内存浪费和溢出 链表执行插入和删除操作十分方便，修改指针即可，不需要移动大量元素 链表灵活，但是空间和时间额外耗费较大 二、list容器的迭代器 &emsp;&emsp;list不再能够像vector一样以普通指针作为迭代器，因为其节点不保证在同一块连续的内存空间上，list迭代器必须有能力指向list结点，并有能力进行正确的递增、递减、取值、成员存储操作。所谓list正确的递增、递减、取值、成员取用是指，递增时指向下一个节点，递减时指向上一个节点，取值时取的是结点的数据值，成员取用时取的是结点成员。 &emsp;&emsp;由于list是一个双向链表，迭代器必须能够具备前移后移的能力，所以list容器提供的是Bidirectional Iterator &emsp;&emsp;list有一个重要的性质，插入操作和删除操作都不会造成原有list迭代器的失效，这在vector中是不成立的，因为vector的插入操作可能会造成记忆体重新配置，导致原有的迭代器全部失效，甚至list元素的删除，也只有被删除的那个元素的迭代器失效，其他迭代器不受任何影响。 三、list的节点 12345678template&lt;class T&gt;struct _list_node&#123; typedef void* void_pointer; void_pointer prve;//型别为void*，其实可设为_list_node&lt;T&gt;* void_pointer next; T data;&#125;; 显然这是一个双向链表。 四、list的元素操作 常用API list lstT;//list采用采用模板类实现,对象的默认构造形式 list(beg,end);//构造函数将[beg, end)区间中的元素拷贝给本身 list(n,elem);//构造函数将n个elem拷贝给本身 list(const list &amp;lst);//拷贝构造函数 push_back(elem);//在容器尾部加入一个元素 pop_back();//删除容器中最后一个元素 push_front(elem);//在容器开头插入一个元素 pop_front();//从容器开头移除第一个元素 insert(pos,elem);//在pos位置插elem元素的拷贝，返回新数据的位置 insert(pos,n,elem);//在pos位置插入n个elem数据，无返回值。 insert(pos,beg,end);//在pos位置插入[beg,end)区间的数据，无返回值。 clear();//移除容器的所有数据 erase(beg,end);//删除[beg,end)区间的数据，返回下一个数据的位置。 erase(pos);//删除pos位置的数据，返回下一个数据的位置。 remove(elem);//删除容器中所有与elem值匹配的元素。 示例如下： 1234567891011121314151617181920212223242526272829303132333435363738394041void test01()&#123; list&lt;int&gt;L1(10, 10); list&lt;int&gt;L2(L1.begin(), L1.end());//使用L1构造L2 DislayList(L1); DislayList(L2); L2.push_back(15);//给L2后面加入一个元素 DislayList(L2); //逆序打印L2 for (list&lt;int&gt;::reverse_iterator it = L2.rbegin(); it != L2.rend(); it++) &#123; cout &lt;&lt; *it &lt;&lt; " "; &#125; cout &lt;&lt; endl; //插入数据 list&lt;int&gt;L3; L3.push_back(15); L3.push_back(20); L3.push_front(10); L3.push_front(5); DislayList(L3);//打印L3中的元素 //删除list两端的元素 L3.pop_front();//头删 L3.pop_back();//尾删 DislayList(L3);//打印L3中的元素 //插入元素 L3.insert(L3.begin(), 333); DislayList(L3); L3.remove(15); DislayList(L3); if (L3.empty()) &#123; cout &lt;&lt; "L3为空" &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; "L3中元素的个数为：" &lt;&lt; L3.size() &lt;&lt; endl; &#125; L3.erase(L3.begin()); DislayList(L3);&#125; 输出结果如下图： 其他操作 resize(num);//重新指定容器的长度为num，若容器变长，则以默认值填充新位置。如果容器变短，则末尾超出容器长度的元素被删除 resize(num, elem);//重新指定容器的长度为num，若容器变长，则以elem值填充新位置。如果容器变短，则末尾超出容器长度的元素被删除 assign(beg, end);//将[beg, end)区间中的数据拷贝赋值给本身 assign(n, elem);//将n个elem拷贝赋值给本身 swap(lst);//将lst与本身的元素互换 reverse();//反转链表 示例如下： 123456789101112131415161718192021222324252627282930void test02()&#123; list&lt;int&gt;L; for (int i = 0; i &lt; 10; i++) &#123; L.push_back(i); &#125; cout &lt;&lt; "初始L为："; DislayList(L); cout &lt;&lt; "指定容器长度为15："; L.resize(15); DislayList(L); L.resize(10); L.resize(15,121212); cout &lt;&lt; "执行操作resize(15,121212)后："; DislayList(L); L.resize(5); cout &lt;&lt; "执行操作resize(5)后："; DislayList(L); list&lt;int&gt;L2; L2.assign(L.begin(), L.end()); cout &lt;&lt; "L2:"; DislayList(L2); cout &lt;&lt; "L2 front:" &lt;&lt; L2.front() &lt;&lt; endl; cout &lt;&lt; "L2 back:" &lt;&lt; L2.back() &lt;&lt; endl; //反转链表 L2.reverse(); cout &lt;&lt; "反转后的L2为："; DislayList(L2);&#125; 输出结果如下图： ==运算符重载 自定义数据类型Person 1234567891011121314151617181920class Person&#123;public: string m_name; int m_age; Person(string name, int age) &#123; this-&gt;m_name = name; this-&gt;m_age = age; &#125; bool operator==(const Person&amp; p)//重载==运算符 &#123; if (this-&gt;m_name == p.m_name &amp;&amp; this-&gt;m_age == p.m_age) &#123; return true; &#125; else return false; &#125;&#125;; 利用重载的==运算符删除其中一个元素 12345678910111213141516171819202122void test03()&#123; list&lt;Person&gt;L; Person p1("Aoki", 23); Person p2("青木", 18); Person p3("张一",20); Person p4("张二", 10); L.push_back(p1); L.push_back(p2); L.push_back(p3); L.push_back(p4); for (list&lt;Person&gt;::iterator it = L.begin(); it != L.end(); it++) &#123; cout &lt;&lt; "姓名：" &lt;&lt; it-&gt;m_name &lt;&lt; "年龄：" &lt;&lt; it-&gt;m_age &lt;&lt; endl; &#125; cout &lt;&lt; "删除张二" &lt;&lt; endl; L.remove(p4); for (list&lt;Person&gt;::iterator it = L.begin(); it != L.end(); it++) &#123; cout &lt;&lt; "姓名：" &lt;&lt; it-&gt;m_name &lt;&lt; "年龄：" &lt;&lt; it-&gt;m_age &lt;&lt; endl; &#125;&#125; 输出结果如下： 自定义规则排序 这里我们借助sort()函数对自定义数据类型进行排序操作。 需要引用一个头文件#include&lt;algorithm&gt; 排序规则： 1234bool ComparePerson(Person&amp; p1, Person&amp; p2)&#123;//自定义排序规则，按年龄从小到大排序 return p1.m_age &lt; p2.m_age;&#125; 根据排序规则对list中的自定义数据类型元素进行排序： 12345678910111213141516171819202122void test04()&#123; list&lt;Person&gt;L; Person p1("Aoki", 23); Person p2("青木", 18); Person p3("张一", 20); Person p4("张二", 10); L.push_back(p1); L.push_back(p2); L.push_back(p3); L.push_back(p4); for (list&lt;Person&gt;::iterator it = L.begin(); it != L.end(); it++) &#123; cout &lt;&lt; "姓名：" &lt;&lt; it-&gt;m_name &lt;&lt; "年龄：" &lt;&lt; it-&gt;m_age &lt;&lt; endl; &#125; L.sort(ComparePerson); cout &lt;&lt; "使用自定义规则排序：" &lt;&lt; endl; for (list&lt;Person&gt;::iterator it = L.begin(); it != L.end(); it++) &#123; cout &lt;&lt; "姓名：" &lt;&lt; it-&gt;m_name &lt;&lt; "年龄：" &lt;&lt; it-&gt;m_age &lt;&lt; endl; &#125;&#125; 输出结果如下： 五、源码地址 list源码示例]]></content>
      <categories>
        <category>STL</category>
      </categories>
      <tags>
        <tag>STL</tag>
        <tag>list</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[交换技术和分组交换的两种方式]]></title>
    <url>%2F2019%2F%E4%BA%A4%E6%8D%A2%E6%8A%80%E6%9C%AF%E5%92%8C%E5%88%86%E7%BB%84%E4%BA%A4%E6%8D%A2%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%96%B9%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[一、电路交换 在进行数据传输前，两个结点之间必须建立一条专用（双方独占）的物理通信路径，该路径可能经过许多中间结点。这一路径在整个数据传输期间一直被独占，直到通信结束才被释放。因此，电路交换技术分为三个阶段：连接建立、数据传输、连接释放 从通信资源的分配角度来看，“交换”就是按照某种方式动态地分配传输线路的资源。电路交换的关键点是，在数据传输过程中，用户始终占用端到端的固定传输带宽。 电路交换的优点： 通信时延小。当传输的数据量较大时，这一优点非常明显 有序传输 没有冲突 适用范围广 实用性强 控制简单 电路交换的缺点 建立连接时间长 线路独占 灵活性差 难以规格化 电路建立后，除源结点和目的节点外，电路上的任何结点都采取“直通方式”接收数据和发送数据，即不会存在存储转发所耗费的时间。 二、报文交换 数据交换的单位是报文，报文携带有目标地址、源地址等信息。报文交换在交换结点采用的是存储转发的传输方式 报文交换的优点 无须建立连接 动态分配线路 提高线路可靠性 提高线路利用率 提供多目标服务 报文交换的缺点 由于数据进入交换结点后要经历存储、转发这一过程，因此会引起转发时延 报文交换对报文的大小没有限制，这就要求网络结点需要有较大的缓存空间 三、分组交换 采用存储转发方式，但解决了报文交换中大报文传输的问题。 分组交换限制了每次传送的数据块大小的上限，把大的数据块划分为合理的小的数据块，再加上一些必要的控制信息，构成分组。网络结点根据控制信息把分组送到下一结点，下一结点接收到分组后，暂时保存并排队等待传输，然后根据分组控制信息选择它的下一结点，直到到达目的结点。 分组交换的优点 无建立时延 线路利用率高 简化了存储管理 加速传输 减少了出错概率和重发数据量 分组交换的缺点 存在传输时延 需要传输额外的信息 当分组交换采用数据报服务时，可能会出现失序、丢失或重复分组，分组到达目的结点时，要对分组按编号进行排序等工作，因此很麻烦。若采用虚电路服务，虽无失序问题，但有呼叫建立、数据传输和虚电路释放三个过程。 四、电路交换、分组交换和分组交换 要传送的数据量很大且其传送时间远大于呼叫时间时，采用电路交换较为合适 端到端的通路由多段链路组成时，采用分组交换传送数据较为合适 从提高整个网络的信道利用率上看，报文交换和分组交换优于电路交换，其中分组交换比报文交换的时延小，尤其适合于计算机之间的突发式数据通信。 五、数据报与虚电路 分组交换根据其通信子网向端点系统提供的服务，还可以进一步分为面向连接的虚电路方式和无连接的数据报方式。这两种服务方式都由网络层提供。数据报方式和虚电路方式是分组交换的两种方式。 数据报 作为通信子网用户的端系统发送一个报文时，在端系统中实现的高层协议先把报文拆成若干带有序号的数据单元，并在网络层加上地址等控制信息后形成数据办分组。中间节点存储分组很短一段时间，找到最佳路由后，尽快转发每个分组。不同的分组可以走不同的路径，也可以按不同的顺序到达目的结点。 数据报服务的特点 发送分组前不需要建立连接，发送方可随时发送分组，网络中的结点可随时接收分组 网络尽最大努力交付，传输不保证可靠性，所以可能丢失；为每个分组独立地选择路由，转发的路径可能不同，因而分组不一定按序到达目的结点 发送的分组中要包括发送端和接收端的完整地址，以便可以独立传输 分组在交换结点存储转发时，需要排队等候处理，这会带来一定的时延。通过交换结点的通信量较大或网络发生拥塞时，这种时延会大大增加，交换结点还可根据情况丢弃部分分组 网络具有冗余路径，当某一交换结点或一段链路出现故障时，可相应地更新转发表，寻找另一条路径转发分组，对故障的适应能力强 存储转发的时延一般较小，提高了网络的吞吐量 收发双方不独占某一链路，资源利用率高 虚电路 虚电路方式试图将数据报方式与电路交换方式结合起来，充分发挥两种方法的优点，以达到最佳的数据交换效果。在分组发送之前，要求在发送方和接收方建立一条逻辑上相连的虚电路，并且连接一旦建立，就固定了虚电路所对应的物理路径。与电路交换类似，整个通信过程分为三个阶段：虚电路建立、数据传输与虚电路释放 在虚电路方式中，端系统每次建立虚电路时，选择一个未用过的虚电路号分配给该虚电路以区别于本系统中的ITA虚电路。在传送数据时，每个数据分组不仅要有分组号、校验和等控制信息，还要有它通过的虚电路号，以区别于其他虚电路上的分组。在虚电路网路中的每个结点上都维持一张虚电路表，表中的每项记录了一个打开的虚电路信息，包括在接收链路和发送链路上的虚电路号、前一结点和下一结点的标识。数据传输时双向进行的，上述信息是在建立过程中确定的。 虚电路服务的特点 虚电路通信链路的建立和拆除需要时间开销，对交互式应用和小量的短分组情况显得很浪费，但对长时间、频繁的数据交换效率较高 虚电路的路由选择体现在连接建立阶段，连接建立后，就确定了传输路径 虚电路提供了可靠的通信功能，能保证每个分组正确且有序到达。此外还可以对两个数据端点的流量进行控制，当接收方来不及接收数据时，可以通知发送方暂缓发送 虚电路有一个致命的弱点，即当网络中的某个结点或某条链路出现故障而彻底失效时，所有经过该结点或该链路的虚电路将遭到破坏 分组首部不含目的地址，而包含虚电路标识符，相对数据报方式开销小 虚电路之所以是“虚”的，是因为这条电路不是专用的，每个节点到其他节点之间的链路可能同时有若干虚电路通过，也可能同时与多个结点之间建立虚电路。每天虚电路支持特定的两个端系统之间的数据传输，两个端系统之间也可以有多条虚电路为不同的进程服务，这些虚电路的实际路由可能相同也可能不同。 数据报服务和虚电路服务的比较 数据报服务 虚电路服务 连接的建立 不需要 必须有 目的地址 每个分组都有完整的目的地址 仅在建立连接阶段使用，之后每个分组使用长度较短的虚电路号 路由选择 每个分组独立地进行路由选择和转发 属于同一条虚电路的分组按照同一路由转发 分组顺序 不保证分组的有序到达 保证分组的有序到达 可靠性 不保证可靠通信，可靠性由用户主机来保证 可靠性由网络保证 对网络故障的适应性 出故障的结点丢失分组，其他分组路径选择发生变化时可以正常传输 所有经过故障结点的虚电路均不能正常工作 差错处理和流量控制 由用户主机进行流量控制，不保证数据报的可靠性 可由分组交换网负责，也可由用户主机负责]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>电路交换</tag>
        <tag>报文交换</tag>
        <tag>分组交换</tag>
        <tag>虚电路</tag>
        <tag>数据报</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vector容器]]></title>
    <url>%2F2019%2Fvector%E5%AE%B9%E5%99%A8%2F</url>
    <content type="text"><![CDATA[一、序列式容器 所谓序列式容器，其中的元素都是可序的，但未必有序。C++本身体用了一个序列式容器array，STL另外提供了vector,list,deque,stack.priority-queue等序列式容器。 二、vector vector与array的区别 vector的数据安排以及操作方式，与array非常相似，两者的唯一差别在于空间运用的灵活性。 array是静态空间，一旦配置了就不能改变，要更换大一些的空间，就必须执行如下操作： 配置一块新空间 将元素从旧地址一一搬往新地址 把原来的空间释放还给系统 vector是动态空间，随着元素的加入，它的内部机制会自行扩充空间以容纳新元素 vector空间配置 为了降低空间配置时的速度成本，vector实际配置的大小比客户端需求大一些，以备将来可能的扩充。这便是容量（capacity）的概念。换句话说，一个vector的容量永远大于或等于其大小。一旦容量等于大小，便是满载，下次再有新增元素，整个vector就得另觅居所。 所谓动态增加大小，并不是在原空间之后续接新空间，而是一块更大的内存空间，然后将元数据拷贝到新空间，并释放原空间，因此，对vector的任何操作，一旦引起空间的重新配置，指向原vector额度所有迭代器就都失效了。 vector的数据结构 vector所采用的数据结构非常简单：线性连续空间。它以两个迭代器start和finish分别指向配置得来的连续空间中已经使用的范围，并以迭代器end_of_storage指向整块连续空间（含备用空间）的尾端。 123456789template&lt;class T, class Alloc = alloc&gt;class vector &#123; ……protected: iterator start; //表示目前使用空间的头 iterator finish; //表示目前使用空间的尾 iterator end_of_storage; //表示目前可用空间的尾&#125;; push_back操作 12345678910111213void test01()&#123; vector&lt;int&gt;v; cout &lt;&lt; "vector当前使用的空间为：" &lt;&lt; v.size() &lt;&lt; endl; cout &lt;&lt; "vector的容量为：" &lt;&lt; v.capacity() &lt;&lt; endl; for (int i = 0; i &lt; 10; i++) &#123; v.push_back(i); cout &lt;&lt; "vector当前使用的空间为：" &lt;&lt; v.size() &lt;&lt; endl; cout &lt;&lt; "vector的容量为：" &lt;&lt; v.capacity() &lt;&lt; endl; &#125; DisplayVector(v);&#125; 构造一个vector容器 vector中提供的构造函数和拷贝构造函数如下： 12345678910111213vector() :start(0), finish(0), end_of_storage(0) &#123;&#125;vector(size_type n, const T&amp; value)&#123; fill_initialize(n, value);&#125;vector(int n, const T&amp; value)&#123; fill_initialize(n, value);&#125;vector(long n, const T&amp; value)&#123; fill_initialize(n, value);&#125; 下面使用一个vector容器构造另一个vector容器，代码如下： 1234567891011void test02()&#123; vector&lt;int&gt; v1; for (int i = 0; i &lt; 10; i++) &#123; v1.push_back(i); &#125; vector&lt;int&gt; v2(v1.begin(), v1.end()); DisplayVector(v1); DisplayVector(v2);&#125; 输出结果如下图： 使用数组初始化vector 123456void test03()&#123; int array[] = &#123; 1,3,5,7,9,11 &#125;; vector&lt;int&gt;v(array, array + sizeof(array) / sizeof(int)); DisplayVector(v);&#125; 输出结果如下图： 初始化vector容器的一些方式 123456789101112131415161718192021222324void test04()&#123; vector&lt;int&gt;v1(10, 1);//初始化vector容器v为10个1 cout &lt;&lt; "v1:"; DisplayVector(v1); vector&lt;int&gt;v2&#123; 2,4,6,8,10 &#125;;//列表初始化vector容器 cout &lt;&lt; "v2:"; DisplayVector(v2); vector&lt;int&gt;v3; //assign(begin(),end());将[begin,end]区间中的数据拷贝给容器 v3.assign(v1.begin(), v1.end()); cout &lt;&lt; "v3:"; DisplayVector(v3); //assign(n,value);将n个value赋值给容器 v3.assign(10, 100); cout &lt;&lt; "v3:"; DisplayVector(v3); //swap(vector);将vector中的元素与本身的元素交换 v1.swap(v3);//v1与v3的元素进行交换 cout &lt;&lt; "v1:"; DisplayVector(v1); cout &lt;&lt; "v3:"; DisplayVector(v3);&#125; 结果如下图所示： vector的元素操作：insert、push_back、pop_back、erase、clear 对元素操作的说明如下： insert(const_iterator pos, int count,ele);//迭代器指向位置pos 插入count 个元素ele. push_back(ele); //尾部插入元素ele pop_back();//删除最后一个元素 erase(const_iterator start, const_iterator end);//删除迭代器从start 到end 之间的元素 erase(const_iterator pos);//删除迭代器指向的元素 clear();//删除容器中所有元素 size();//返回容器中元素的个数 empty();//判断容器是否为空 resize(int num);//重新指定容器的长度为num，若容器变长，则以默认值填充新位置。如果容器变短，则末尾超出容器长度的元素被删除。 resize(int num, elem);//重新指定容器的长度为num，若容器变长，则以elem 值填充新位置。如果容器变短，则末尾超出容器长&gt;度的元素被删除。 capacity();//容器的容量 reserve(int len);//容器预留len 个元素长度，预留位置不初始化，元素不可访问。 示例如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950void test05()&#123; vector&lt;int&gt;v1&#123; 10,15,16,17,18,19,20 &#125;; if (v1.empty()) &#123; cout &lt;&lt; "v1为空" &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; "v1:"; DisplayVector(v1); cout &lt;&lt; "v1不为空，元素个数为：" &lt;&lt; v1.size() &lt;&lt; endl; &#125; v1.resize(10);//重新指定vector容器的长度 cout &lt;&lt; "v1的元素个数为：" &lt;&lt; v1.size() &lt;&lt; endl; DisplayVector(v1); v1.resize(15, 8888); cout &lt;&lt; "v1的元素个数为：" &lt;&lt; v1.size() &lt;&lt; endl; DisplayVector(v1); v1.resize(4); cout &lt;&lt; "现在v1的元素个数为：" &lt;&lt; v1.size() &lt;&lt; endl; DisplayVector(v1); vector&lt;int&gt;v2; v2.reserve(15);//为v2预留15个元素的长度 for (int i = 0; i &lt; 5; i++) &#123; v2.push_back(i); &#125; DisplayVector(v2); int ret = v1.at(2);//取索引5指向的元素 cout &lt;&lt; "索引为2所指的数据为：" &lt;&lt; ret &lt;&lt; endl; cout &lt;&lt; "v1中的第三个元素为：" &lt;&lt; v1[2] &lt;&lt; endl; cout &lt;&lt; "v1的首元素为：" &lt;&lt; v1.front() &lt;&lt; endl; cout &lt;&lt; "v1的尾元素为：" &lt;&lt; v1.back() &lt;&lt; endl; v1.insert(v1.begin() + 1, 4, 5);//在迭代器v1.begin()+1指向的位置插入4个5 cout &lt;&lt; "v1:"; DisplayVector(v1);//输出 v1.pop_back();//删除v1的尾元素 cout &lt;&lt; "v1:"; DisplayVector(v1); v1.erase(v1.begin());//删除v1的v1.begin指向的元素 cout &lt;&lt; "v1:"; DisplayVector(v1); v1.erase(v1.begin()+1, v1.end());//删除v1.begin()+1,v1.end()之间的元素 cout &lt;&lt; "v1:"; DisplayVector(v1); v1.clear();//清空v1中的元素 cout &lt;&lt; "v1:"; DisplayVector(v1);&#125; 输出结果如下： 使用swap来收缩vector容器的空间 123456789101112131415161718void test06()&#123; vector&lt;int&gt;v; for (int i = 0; i &lt; 10; i++) &#123; v.push_back(i); &#125; cout &lt;&lt; "v的容量为：" &lt;&lt; v.capacity() &lt;&lt; endl; cout &lt;&lt; "v的大小为：" &lt;&lt; v.size() &lt;&lt; endl; v.resize(5); cout &lt;&lt; "调整大小后vector容器的容量和大小如下：" &lt;&lt; endl; cout &lt;&lt; "v的容量为：" &lt;&lt; v.capacity() &lt;&lt; endl; cout &lt;&lt; "v的大小为：" &lt;&lt; v.size() &lt;&lt; endl; cout &lt;&lt; "使用swap收缩vector空间" &lt;&lt; endl; vector&lt;int&gt;(v).swap(v); cout &lt;&lt; "v的容量为：" &lt;&lt; v.capacity() &lt;&lt; endl; cout &lt;&lt; "v的大小为：" &lt;&lt; v.size() &lt;&lt; endl;&#125; 输出结果如下： 源码地址 vector源码示例]]></content>
      <categories>
        <category>STL</category>
      </categories>
      <tags>
        <tag>STL</tag>
        <tag>vector</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[STL概论]]></title>
    <url>%2F2019%2FSTL%E6%A6%82%E8%AE%BA%2F</url>
    <content type="text"><![CDATA[长久以来，软件界一直希望建立一种可重复运用的东西，以及一种得以制造出“可重复运用的东西”的方法，让工程师/程序员的心血不致于随时间迁移、人事异动、私心欲念而烟消云散。从子函数、程序、函数、类别、到函数库、类别库、各种组件、从结构化设计、模块化设计、面向对象设计、到模式的归纳整理，无一不是软件工程的慢慢奋斗史。 为的，就是复用性的提升。 ——《STL源码剖析》 为了建立数据结构和算法的一套标准，并且降低他们之间的耦合关系，以提升各自的独立性、弹性、交互操作性、，诞生了STL。 STL（标准模板库），是惠普实验室开发的一系列软件的统称。 STL从广义上分为：容器、算法、迭代器。容器和算法之间通过迭代器进行无缝连接。STL几乎所有的代码都采用了模板类或模板函数，相比于由函数和类组成的库来说提供了更好的代码复用机会。 一、STL六大组件 容器：各种数据结构，如vector,list,deque,set,map，用来存放数据。 算法：各种常用的算法如：sort,search,copy,erase…… 迭代器:扮演了容器和算法之间的胶合剂，是所谓的泛型指针。共有五种类型，以及其他的衍生变化，从实现的角度来看，迭代器是一种将operator*,operator-&gt;,operator++,operator–等指针相关操作予以重载的class template。所有STL容器都附带有自己专属的迭代器，只有容器设计者才知道如何遍历自己的元素。原生指针也是一种迭代器。 仿函数：行为类似函数，可作为算法的某种策略。从实现的角度看，仿函数是一种重载了operator()的class或class template 适配器：一种用来修饰容器或仿函数或得带器接口的东西。 空间配置器：负责空间配置与管理。从实现的角度来看，配置器是一个实现了动态空间配置，空间管理，空间释放的class template。 STL六大组件的交互关系，容器通过空间配置器取得数据存储空间，算法通过迭代器存储容器空间中的内容，仿函数可以协助算法完成不同的策略的变化，适配器可以修饰仿函数 二、STL优点 STL是C++的一部分，因此不用额外安装什么，它被内建在编译器之内 STL的一个重要特性是将数据和操作分离，数据由容器类别加以管理，操作则由可定制的算法定义。迭代器在两者之间充当粘合剂，以使算法可以和容器交互运行。 程序员不用思考STL具体的实现过程，只要能熟练使用STL就可以。这样他们就可以把精力放在程序开发的别的方面 STL具有高复用性、高性能、高移植性、跨平台等优点。 高可重用性：STL中几乎所有的代码都采用了模板类和模板函数的方式实现，这相比于传统的由函数和类组成的库来说提供了更好的代码重用机会。 高性能：如map可以高效地从十万记录里面查找出指定的记录。因为map是采用红黑树的变体实现的 高移植性：如在项目A上用STL编写的模块，可以直接移植到项目B上。 三、STL三大组件介绍 容器 容器，置物之所也。 研究数据的特定排列方式，以利于搜索或排序或其他特殊每亩地，这一门学科就是数据结构。 任何特定的数据结构都是为了实现某种特定的算法。STL容器就是将运用最广泛的一些数据结构实现出来。 常用的数据结构：数组（array），链表（list）、树（tree），栈（stack），队列（queue），集合（set），映射表（map），根据数据在容器这两个排列的特性，这些数据分为序列式容器和关联式容器两种。 序列式容器强调的是值的排序，序列式容器中的每个元素均有固定的位置，除非用删除或插入操作改变这个位置。vector容器，deque容器，list容器 关联式容器是非线性的树结构，更准确的说是二叉树结构，各元素之间没有严格的物理上的顺序关系，也就是说元素在容器中并没有保存元素置入容器时的逻辑顺序。关联式容器另一个显著特点是：在值中选择一个值作为关键字key，这个关键字对值起到了索引的作用，方便查找。set/multiset容器，map/multimap容器 算法 算法，问题之解法也。 以有限的步骤，解决逻辑或数学上的问题，即为算法。 算法分为：质变算法和非质变算法 质变算法：是指在运算过程中会戈恩噶区间内元素的内容，例如拷贝、替换、删除等 非质变算法：是指运算过程中不会更改区间内的元素内容，例如查找、计数、遍历寻找极值等。 迭代器 迭代器（iterator）是一种抽象的设计概念，显示程序语言中并诶呦直接对应于这个概念的实物。设计模式中iterator模式定义如下：提供一种方法，使之能够依序寻访某个容器所含的各个元素，而又无须暴露该容器的内部表示方式。 迭代器的设计思维-STL的关键所在，STL的中心思想在于将容器和算法分开，彼此独立设计，最后再贴胶着剂将他们撮合在一起，从技术角度来看，容器和算法的泛型化并不困难，C++的class template 和function template可分别达到目标，如果设计出这两个之间的良好的胶着剂，才是大难题。 分类 描述 功能 输入迭代器 提供对数据的只读访问 输出迭代器 提供读写操作，并能向前推进迭代器 前向迭代器 提供读写操作，并能向前推进迭代器 读写，支持++，==，~= 双向迭代器 提供读写操作，并能向前和向后操作 读写，只会++，– 随机访问迭代器 提供读写操作，并能以跳跃的方式访问容器的任意数据，是功能最强大的的迭代器 读写，支持++，–，[n],-n,&lt;,&lt;=,&gt;,&gt;=]]></content>
      <categories>
        <category>STL</category>
      </categories>
      <tags>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[软件测试知识点总结]]></title>
    <url>%2F2019%2F%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[一、软件测试基本概念 软件测试的定义 使用人工或自动手段来运行或测试某个系统的过程，其目的在于检验它是否满足规定的需求或是否弄清预期结果与实际结果之间的差别。 软件缺陷的定义 软件缺陷，常常被称为bug。所谓软件缺陷，即计算机软件或程序中存在某种破坏正常运行能力的问题、错误，或者隐藏的功能缺陷。缺陷的存在会导致软件产品在某种程度上不能满足用户的需要。 标准定义：从产品内部看，缺陷时软件产品的开发或维护过程中存在的错误、毛病等各种问题；从产品外部看，缺陷是系统所需要实现的某种功能的失效或违背。 软件缺陷的主要类型 (1)软件没有是实现产品说明书中要求的功能模块 (2)软件中出现了产品说明书中指明不应出现的错误 (3)软件实现了产品说明书中没有提到的功能模块 (4)软件没有实现产品说明书中没有明确提到但应该实现的目标 (5)软件难以理解、不易于使用，运行缓慢，或从测试员的角度看，最终用户会认为不好。 软件缺陷的级别 (1)微小的。一些小问题，对功能几乎没有影响，软件产品仍然可以使用 (2)一般的。不太严重的问题，如次要功能模块丧失、提示信息不够准确、用户界面差、操作时间长等 (3)严重的。严重错误，指没有实现功能模块或某个特性，主要功能部分丧失、次要功能全部丧失，或致命的错误声明 (4)致命的。致命的错误，将造成系统崩溃、死机，或造成数据丢失、主要功能完全丧失等 通常情况下，问题越严重，其处理优先级就越高。 软件缺陷的状态 (1)激活状态：问题没有解决，测试人员新报告的缺陷或者验证后的缺陷仍旧存在 (2)已修正状态：已经被开发人员检查、修复过的缺陷，通过单元测试，认为已经解决但还没有被测试人员验证 (3)关闭状态：测试人员经过验证后，确认验证不存在之后的状态 软件缺陷的原因 (1)软件产品说明书 (2)设计方法 (3)编写代码 (4)其他 比例依次减小 软件缺陷修复的代价 依次递增，如下： (1)编制说明书 (2)设计阶段 (3)编写代码 (4)测试 (5)发布 软件测试的分类 (1)按照开发阶段划分 ​ ①单元测试 ​ ②集成测试 ​ ③系统测试 ​ ④验收测试 (2)按测试技术划分 ​ ①白盒测试 ​ ②黑盒测试 ​ ③灰盒测试 (3)按被测软件是否实际运行划分 ​ ①静态测试 ​ ②动态测试 (4)按照测试实施组织划分 ​ ①开发方测试（α测试) ​ ②用户测试（β测试） ​ ③第三方测试 软件测试的原则 （1）完全测试程序是不可能的 （2）软件测试是有风险的 （3）测试无法显示潜伏的软件缺陷 （4）软件缺陷的群集现象 （5）杀虫剂怪事：软件测试越多，其免疫力越强 （6）并非所有的软件缺陷都能被修复 （7）难以描述的软件缺陷 二、黑盒测试用例设计方法 测试用例在软件测试中的作用 （1）推导测试的实施 （2）规划测试数据的准备 （3）编写测试脚本的“设计规格说明书” （4）评估测试结果的度量基准 （5）分析缺陷的标准 设计测试用例的步骤 （1）测试需求分析 （2）业务流程分析 （3）测试用例设计 （4）测试用例评审 （5）测试用例更新完善 等价类划分法 等价类划分法是一种最为常见的黑盒测试方法。 其基本实现是把程序的输入域划分为若干个子集，然后从每个子集中选取少量具有代表性的数据作为测试用例。在该子集合中，各个输入数据对于揭示程序中的错误都是等效的 等价类可以分为两种： （1）有效等价类。指对于程序的规格说明来说，是由合理的、与意义的输入数据构成的集合。主要为了检验程序是否实现了规格说明书中规定的功能和性能 （2）无效等价类。对规格说明书而言，是由无意义的、不合理的输入数据构成的集合。利用无效等价类中的数据，检验程序对错误输入的处理能力。 设计测试用例的步骤 （1）划分等价类 （2）建立等价类表，列出所有划分出的等价类，并为每一个等价类规定一个唯一的编号 （3）从划分出的等价类中按以下原则设计测试用例。设计一个新的测试用例，使其尽可能多地覆盖尚未被覆盖的有效等价类，重复这一步骤，直到所有的有效等价类都被覆盖为止；设计一个新的测试用例，使其仅覆盖一个尚未被覆盖的无效等价类，重复这一步，直到所有的无效等价类都被覆盖为止 边界值分析法 边界值分析法用于考察处于等价划分边界或在边界附近的状态。 通常，软件中边界分为内部边界和外部边界两种。所谓的外部边界是可以在需求规格说明书、设计规格说明书中找到相应的描述的，而内部边界是在程序实现环节存在的、至关重要的界限。 因果图法 等价类划分法和边界值分析方法都着重考虑输入条件，但没有考虑输入条件的各种组合、输入条件之间的相互制约关系。 因果图是一种利用图解法分析输入的各种组合情况，从而设计测试用例的方法，它适合于检查程序输入条件的各种组合情况。 因果图的定义：因果图是一种描述输入和输出之间关系的图，其中出现的基本符号主要有：节点和弧线。 因果图描述的原因和结果之间的关系： （1）恒等 （2）非 （3）或 （4）与 输入条件的约束： （1）E约束（异） （2）I约束（或） （3）O约束（唯一） （4）R约束（要求） 因果图法的基本步骤 （1）分析程序规格说明书中描述的语义内容，找出“原因”和“结果”，将其表示成连接各个原因与结果的“因果图” （2）由于语法或环境限制，有些原因与原因之间或原因与结果之间的组合情况是不可能出现的，可用记号标明约束或限制条件 （3）将因果图转换成判定表 （4）根据判定表中的每一列设计测试用例 决策表法 决策表，也称判定表。在所有的黑盒测试方法中，基于决策表的测试方法被认为是最严格的的，因为决策表具有逻辑严格性。 决策表是分析和表达多逻辑条件下执行不同操作的情况的工具。 决策表的结构 （1）条件桩：列出问题的所有条件 （2）条件项：针对条件桩给出的条件列出所有可能的取值 （3）动作桩：列出问题规定的可能采取的操作 （4）动作项：指出在条件项的各组取值情况下应采取的动作 （5）规则：贯穿条件项和动作项的一列就是一条规则 决策表的化简 初始决策表的条件项的数目很大，若表中有两条以上规则具有相同的动作，并且在条件项之间存在极为相似的关系，便可以将它们合并。合并后的条件项用符号“—”表示，说明执行的动作与该条件的取值无关，称为无关条件。 三、白盒测试用例设计方法 逻辑覆盖测试 白盒测试方法是把测试对象看作一个打开的盒子，测试人员依据程序内部逻辑结构相关信息，设计或选择测试用例，对程序所有逻辑路径进行测试，通过在不同点检查程序的状态，确定实际的状态是否与预期的状态一致。 逻辑覆盖测试是以程序内在逻辑结构为基础的测试，重点关注测试覆盖率。包括以下6种类型：语句覆盖、判定覆盖、条件覆盖、判定/条件覆盖、条件组合覆盖和路径覆盖。 语句覆盖 语句覆盖是指设计若干个测试用例，使程序中的每个可执行语句至少执行一次。在保证每条语句都运行的前提下，测试用例应尽量少。在语句覆盖的基础上可以实现程序覆盖，进而是程序块的覆盖。 语句覆盖是一种较弱的覆盖测试。 判定覆盖 判定覆盖的含义是：设计足够多的测试用例，使程序中的每个判定都至少获得“真值”和“假值”。程序中的判定有：分支判定和循环判定。 为了表示方便，做到理解上的统一，表示某个条件的真假用$T_i$和$F_i$,表示某个判定的真假使用$TD_i$和$FD_i$ 条件覆盖 条件覆盖的含义是:构造一组测试用例，使得每一个判定中每个逻辑条件的可能值至少被满足一次。 判定/条件覆盖 设计足够的测试用例，使得判定中每个条件的所有可能（真/假）至少出现一次，并且每个判定本身的判定结果（真/假）也至少出现一次，即满足判定/条件覆盖的测试用例同时满足条件覆盖和判定覆盖。 组合条件覆盖 组合条件覆盖的含义是：设计足够的测试用例，使得每个判定中条件的各种可能组合都至少出现一次。 显然，满足组合条件覆盖的测试用例是一定满足判定覆盖、条件覆盖和判定/条件覆盖的。 具体的组合策略如下： （1）如果某个条件组合只有一种可能性，则优先确立关系 （2）不可能存在的组合不住要设计测试用例 （3）除了不可能的情况，所有的条件组合都必须至少出现一次 路径覆盖 所谓路径覆盖就是设计足够多的测试用例使每个路径都有可能被执行。 基本路径测试 包括程序控制流图，环形复杂度、独立路径 控制流图 在设计程序时，为了更加突出控制流的结构，可对程序流程图进行简化，简化后的流程图称为控制流图。 控制流图的构成： 控制流线 结点 必须用结点表示的情况： （1）程序流程图中矩形框表示的处理 （2）菱形框表示的两个甚至多个出口判断 （3）多条流线相交的汇合点 环形复杂度 环形复杂度（圈复杂度）是一种为程序逻辑复杂度提供定量尺度的软件度量。也可将该度量用于基本路径测试方法，它可以提供程序基本集的独立路径数量和确保所有语句至少被执行一次的测试数量上界。 计算环形复杂度的方法： （1）流图中区域的数量对应于环形复杂度 （2）给定流图G的环形复杂度为V（G），定义为V(G)=E-N+2,其中，E是流图中边的数量，N是流图中节点的数量 （3）给定流图G的环形复杂度V(G)，定义为V(G)=P+1,P是流图G中判定结点的数量 独立路径 独立路径是指程序中至少引入了一个新的处理语句集合或一个新条件的程序通路，它必须至少包含一条路径在本次定义路径之前不曾用过的边。 程序的环形复杂度是程序基本路径集合中的独立路径条数，这是确定路径中每个可执行语句至少被执行一次所必需的测试用例数目的上界。 代码检查 在实际使用中，静态代码检查比动态测试更有效率，更能快速找到缺陷。 静态测试包括代码检查和静态分析两种途径，它可以由人工进行，充分发挥人的逻辑优势，也可以借助软件工具自动进行。代码检查包括桌面检查、代码审查、代码走查、技术评审等。 主要检查代码的设计是否一致、代码是否遵循标准性和可读性、代码的逻辑表达的正确性，以及代码结构的合理性等。 代码评审也称代码复查，是指通过阅读代码来检查源代码与编码标准的符合性以及代码质量的活动。 代码评审的目的： （1）确保要发布质量可靠的代码，能非常有效地发现所有类型的错误 （2）作为教学工具帮助开发人员学会何时并且如何应用技术来提高代码的质量、一致性和维护性 代码评审是发现缺陷的有效方法。代码评审包括代码审查、代码走查、桌面检查等。 代码审查 代码审查作为质量保证的一部分，是静态测试的主要手段之一。 代码审查的内容： （1）编码规范问题 （2）代码结构问题 （3）工具、框架使用不当 （4）实现问题 （5）测试问题 代码走查 代码走查是以小组为单位进行代码阅读的，同样也是一系列规程和错误检查技术的集合。且代码走查也采用了持续1小时~2小时的不间断会议的形式。 代码走查的任务：就是参与者“使用计算机”。被指定为测试为人员的那个人会带着一些书面的测试用例来参加会议。且在会议期间，每个测试用例都在人们的头脑中进行推演。即把测试数据沿程序的逻辑结构走一遍，并把程序的状态记录以纸上或白板上以供监视。 桌面检查 桌面检查可被视为由担任进行的代码检查或代码走查：由一个人阅读程序，对照错误列表检查程序，对程序推演测试数据。 四、单元测试 单元测试的定义 单元测试又称模块测试，是最小单位的测试，其依据是详细设计规格说明书，对模块内所有重要的控制路径设计测试用例，以便发现模块内部的错误。 单元测试多采用白盒测试技术，系统内多个模块可以并行地进行单元测试 单元测试的对象 一般认为，在结构化程序时代，单元测试所说的单元是指函数，在面向对象编程中，单元测试的单元一般是指类。 但从实践来看，以类作为测试单位，复杂度高、可操作性较差，所以仍然主张以类中的方法作为单元测试的测试单位但可以用一个测试类来组织某个类的所有测试函数 单元测试不应过分强调面向对象，因为局部代码依然是结构化的。单元测试的工作量较大，简单、实用、高效才是硬道理， 单元测试的时间 单元测试当然是越早越好，通常在编码阶段进行。在源程序代码编制完成、经过评审和验证、确定没有语法错误之后，就可以了开始进行单元测试的测试用例设计 单元测试的内容 （1）模块接口测试 （2）模块局部数据结构测试 （3）模块边界条件测试 （4）模块中所有数日执行通路测试 （5）模块的各条错误处理通路测试 模块接口测试是单元测试的基础。只有在数据能正确流入、流出模块的前提下，其他测试才有意义。 单元测试的过程 （1）计划单元测试：确定测试需求，制订测试策略，确定测试所用的资源，创建测试任务的时间表 （2）设计单元测试：根据单元测试计划设计单元测试模型，制订测试方案，确认测试过程，设计具体的测试用例，创建可重用的测试脚本 （3）执行单元测试：根据单元测试的方案、用例对软件单元进行测试，验证测试结果并记录测试过程中出现的缺陷 （4）评估单元测试：对单元测试的结果进行评估，主要从需求覆盖和代码覆盖的角度进行测试完备性的评估 单元测试的模型 在进行单元测试时，如果模块不是独立的程序，需要辅助测试模块，有两种辅助模块： 驱动模块：所测模块的主程序。它接收测试数据，把这些数据传递给所测试模块，最后再输出测试结果。当被测试模块能完成一定功能时，也可以不要驱动模块。 桩模块：用来代替所测模块调用的子模块。被测试模块、驱动模块共同构成了一个测试模型 执行单元测试 （1）设置测试环境 （2）将测试环境初始化，以确保所有构件都处于正确的初始状态 （3）执行测试过程。需要注意的是，测试过程的执行将随着具体情况而变化：测试方式是自动还是人工，以及必需的测试构件是作为驱动程序还是桩模块。自动测试的测试脚本在执行实施测试步骤的过程中创建。而人工测试则是在“构建测试过程”活动中制定的结构化测试过程。 评估单元测试 测试完备性评估 代码覆盖率评估 从覆盖的角度看，。测试应该做到以下覆盖：功能覆盖、输入域覆盖、输出域覆盖、函数交互覆盖和代码执行覆盖 五、集成测试 集成测试的定义 集成测试又称组装测试，是在单元测试的基础上，将所有模块按照设计要求组装成子系统或系统，而进行的测试活动 集成测试的目的是确保各单元组合在一起后能够按照既定意图协作运行，并确保增量的行为正确。 它所测试内容包括单元间的接口以及集成后的功能，通常使用黑盒测试方法测试集成的功能，并且对以前的集成进行回归测试。 集成测试阶段主要检查以下几个方面： （1）在把各个模块连接起来的时候，穿越模块接口的数据是否会丢失 （2）一个模块的功能是否会对另一个模块的功能产生不利的影响 （3）各个子功能组合起来，能否达到预期要求的父功能 （4）全局数据结构是否有问题 （5）单个模块的误差累积起来，是否会被放大，从而达到不能接受的程度 （6）在单元测试的同时可进行集成测试，发现并排除在模块连接中可能出现的问题，最终构成要求的软件系统 集成测试的内容 一个产品的开发过程包括了分层的设计和逐步细化的过程，从最初的产品到最小的单元，由于集成的力度不同，一般可以把集成测试划分为三个级别： （1）模块内集成测试 （2）子系统内集成测试（模块）：先测试子系统内的功能模块（不能单独运行的程序），然后将各个功能模块组合起来确认子系统的功能是否达到预期要求 （3）子系统间集成测试（可执行程序）：测试的单元是子系统之间的接口，这里的子系统是可单独运行的程序或进程。 模块和子系统的区别： 一个完整的软件系统通常包括若干个具有不同功能的子系统。而每个子系统又由多个功能模块组成。 集成测试的原则 （1）要测试所有的公共接口，尤其是那些与系统相关联的外部接口，测试的重点是要检查数据的交换、传递和控制管理过程，还包括处理的次数 （2）必须对关键模块进行充分测试。在集成的过程中应该重点关注一个系统的关键模块。在确定测试需求时，测试人员就要确定系统的关键模块，这些关键模块包含在最希望测试的那些模块中。一般我们将系统中的模块划分成3个等级：高危模块、一般模块、低危模块。一个关键模块应该具有一个或多个下列特性： 和多个软件需求有关，或与关键功能有关 处于程序控制结构的顶层 本身是复杂的或者容易出错的 含有确定性的性能需求 被频繁使用的模块 （3）继承测试应当按一定的层次进行。系统的模块之间是有层次关系的，就像函数之间的相互调用关系。在对系统进行集成时，要按照一定的层次顺序进行集成，避免集成过程中发生错误无法对错误进行定位。 （4）集成测试的策略选择应当综合考虑质量、成本和进度之间的关系。风险分析贯穿整个集成测试过程中，总的原则是花费最小的成本，取得最大的测试效果 （5）集成测试应当尽早开始，并以总体设计为基础 （6）在模块与接口的划分上，测试人员应当和开发人员进行充分沟通 （7）测试执行结果应当被如实记录 集成测试的策略 （1）非增量式集成策略 非增量集成，又称大爆炸式集成，采用一步到位的方法来进行集成，又称一次组装或整体拼装。使用该方法进行集成时，首先分别测试每个模块，即对每个模块都进行独立的单元测试。测试通过后，再把所有模块按设计要求组合在一起构成整体，再对这个整体进行测试。 （2）增量式集成策略 增量式集成方法又被称为渐增式组装，它的集成时逐步实现的。首先对一个个模块进行模块测试，然后按照某种策略，将这些模块逐步组装成较大的系统，在组装的过程中边连接边测试，以发现连接过程中产生的问题。通过增值逐步组装成为满足要求的软件系统。 自顶向下的集成测试 自顶向下增量式集成就是按照模块结构图自上而下进行集成 自底向上的集成测试 自底向上的增量式集成就是按照模块结构图自底向上进行组装，首先从模块结构的底层开始，依次往高层次集成。在集成的过程中，不需要再编写桩模块，只需要为被组装模块编写驱动模块。 混合增量式集成策略 也称“三明治”集成，对软件结构中较上层，使用的是“自顶向下”集成；对软件结构中较下层，使用的是“自底向上”继承，将两种策略的优点结合在一起。 六、功能测试 系统测试 系统测试是通过与系统的需求规格做比较，发现软件与系统需求规格不相符或与之矛盾的地方。它将通过确认测试的软件，作为整个基于计算机系统的一个元素，与计算机硬件、外设、某些支持软件、数据和人员等其他系统元素结合起来，在实际运行（使用）环境下，对软件进行系统测试。 系统测试的依据为需求规格说明书、概要设计说明书和各种规范。通信产品与一般的软件产品不同，其系统测试往往需求依据大量的既定规范；对于海外产品，系统测试依据还包括各个国家自定的规范。 系统测试包括功能测试、性能测试、压力测试、协议一致性测试、容量测试、安全性测试、恢复性测试、备份测试、UI测试、安装和卸载测试、本地化测试、可用性测试等。 功能测试 功能测试又称正确性测试，就是对产品的各项功能进行验证，根据功能测试用例，逐项测试，检查产品是否达到用户要求的功能或者说检查软件的功能是否符合规格说明。由于正确性是软件最重要的质量因素，所以功能测试也非常重要。做功能测试需要首先明确业务和需求。理解了需求和业务，才知道客户想要系统实现什么。然后按照需求来进行测试，不满足要求的都可以被认为是缺陷。 功能测试的策略 测试需求分析 指定测试计划 测试设计和测试用例设计 测试环境搭建 测试实施 缺陷报告 回归测试 功能测试的内容 功能测试包括对用户界面的测试、对各种操作的测试，对不同的数据输入、逻辑思路、数据输出、存储等的测试。不同的应用系统，功能测试的内容差异很大，但一般都可归为界面、数据、操作、逻辑、接口等几个方面，主要包括： （1）程序安装和启动正常，有相应的提示框、适当的错误提示等 （2）每项功能符合实际要求 （3）系统的界面清晰、美观；菜单、按钮操作正常、灵活，能处理一些异常操作 （4）能接受正确的数据输入，对异常数据的输入可以进行提示、容错处理等 （5）数据的输出结果准确、格式清晰，可以保存和读取 （6）功能逻辑清楚，符合使用者习惯 （7）系统的各种状态按照业务流程而变化，并保持稳定 （8）支持各种应用的环境，能配合多种硬件周边设备，与外部应用系统的接口有效 （9）软件升级后，能够继续支持旧版本的数据 七、性能测试 性能测试 性能测试的目的是验证软件系统是否能够达到用户要求的性能指标，同时发现软件系统中出来的性能瓶颈，最后起到优化系统的目的。 性能测试的内容 具体包括以下几个方面： （1）评估系统的能力：测试中得到的负荷和响应时间数据可以用于验证软件系统能力是否符合设计要求 （2）识别系统中的瓶颈：当系统符合被增加到极限水平并继续增加时，可以通过性能指标的变化情况监测系统的瓶颈，从而帮助系统设计者修复系统的瓶颈 （3）系统调优：重复运行测试，验证调整系统的活动得到了预期的结果，从而改进系统性能 （4）验证稳定性与可靠性：在一定的负载压力下执行测试一定时间，是评估系统稳定性和可靠性是否满足要求的有效方法 性能测试的分类 性能测试类型包括负载测试、压力测试、强度测试、容量测试。通常，性能测试通过自动化的测试工具模拟多种正常、峰值以及异常负载条件来对系统的各项性能指标进行测试，负载测试和压力测试都属于性能测试，两者可以结合进行 （1）负载测试，是确定在各种工作负载下系统的性能，目标是测试当负载逐渐增加时，系统各项性能指标的变化情况，例如，吞吐量、响应时间、CPU负载、内存使用等，来确定系统的性能。负载测试是一个分析软件应用程序和支撑架构、模拟真实环境的使用，从而来确定能够接受的性能的过程。 （2）压力测试是通过确定一个系统的瓶颈或者不能接受的性能点，来获得系统能提供的最大服务级别的测试 （3）疲劳测试是采用系统稳定运行情况下，能够支持的最大并发用户数，持续执行一段时间业务，通过综合分析交易执行指标和资源监控指标来确定系统处理最大工作量强度性能的过程。疲劳强度测试可以采用自动化工具进行测试，也可以手工编写程序测试，其中后者占的比例较大 （4）容量测试用于确定系统可处理同时在线的最大用户数 （5）大数据量测试可以分为两种类型：针对某些系统存储、传输、统计、查询等业务进行大数据量的独立数据量测试；与压力性能测试、负载性能测试、疲劳性能测试相结合的综合数据量测试方案。大数据量测试的关键是测试数据的准备，可以依靠工具准备测试数据。 （6）速度测试目前主要针对关键的，有速度要求的业务进行手工测速度，可以在多次测试的基础上求平均值，可以和工具测试得到的响应时间等指标做对比分析。 性能计数器 影响一个系统性能的因素主要有：软件因素，包括系统软件、第三方软件等；硬件因素，如内存、磁盘、CPU、网卡等；网络因素，如网络吞吐量、带宽、网络传输速率等。 性能计数器是描述服务器或操作系统性能的一些数据指标。 （1）内存，内存性能计数器主要检查应用程序是否存在内存泄漏 （2）处理器，监视“处理器”和“系统”对象计数器可以提供关于处理器使用的有价值的信息，帮助测试人员决定是否存在瓶颈 （3）物理磁盘，磁盘性能 性能测试流程 （1）性能测试的计划 （2）性能测试的设计 （3）性能测试的执行 （4）测试结果的分析 八、本地化测试 本地化测试的定义 本地化测试是对软件进行本地化过程中记性的测试 所谓本地化就是将软件版本语言进行就更该。 本地化测试的对象是软件的本地化版本 本地化测试目的是测试待定目标区域设置的软件本地化质量 本地化测试的环境是在本地化的操作系统上安装本地化的软件。 从测试方法上可以分为：基本功能测试、安装或卸载测试、当地区域的软硬件兼容测试。 测试的内容主要包括软件本地化后的界面布局和软件翻译的语言质量，包含软件、文档和在线帮助等部分 本地化测试的目的首先是保证本地化的软件与源语言软件具有相同的功能和性能。其次还要保证本地化的软件在语言、文化、传统观念等方面符合当地用户的习惯。 本地化测试过程中的测试工作集中在： （1）易受本地化影响的方面，如用户界面 （2）区域性或区域设置特定的、语言特定的和地区特定的方面 本地化测试与其他测试的区别 软件本地化测试的测试对象是本地化的软件，需要在本地化的操作系统上进行。虽然本地化的软件是基于源程序软件创建的，但与其他测试的测试内容和重点有很大不同。 不同点 描述 测试顺序 首先要对源程序软件进行测试，然后再创建本地化软件，测试本地化软件 测试内容和重点 源程序软件主要测试功能和性能，结合软件界面的测试；本地化软件的测试，更注重因本地化引起的错误；例如，翻译是否正确，本地化的界面是否美观、本地化后的功能是否与源语言软件保持一致 测试环境 源程序软件测试通常在源语言的操作系统上进行；本地化软件在本地化的操作系统上进行 本地化测试的类型 （1）导航测试，是为了降低软件本地化的风险而进行的一种本地化测试 （2）可接受性测试，也被称为冒烟测试，是指对编译的软件本地化版本的主要特征进行基本测试，从而确定版本是否满足详细测试的条件。 （3）语言质量测试，是软件本地化测试的重要组成部分，贯穿于本地化项目的各个阶段。语言质量测试的主要内容是软件界面和在线帮助等文档的翻译质量，包括正确性，完整性，专业性和一致性。 （4）用户界面测试，也被称为外观测试，主要是对软件的界面文字和控件布局进行测试 （5）功能测试，原始语言开发的软件的功能测试主要测试软件的各项功能是否被实现以及是否正确，而本地化软件的功能测试主要是测试软件经过本地化后，软件的功能是否与源软件一致，是否存在因软件本地化而产生的功能错误 本地化软件缺陷的分类 核心软件缺陷 （1）源语言功能缺陷 （2）源语言国际化缺陷 本地化缺陷 （1）语言质量缺陷 （2）用户界面缺陷 （3）本地化功能缺陷 本地化测试的流程 （1）测试规划 （2）测试设计 （3）测试实施 （4）配置管理 （5）测试管理 本地化测试工程师 基础技能 （1）安装和配置常用操作系统的知识 （2）计算机网络基础知识 （3）通用软件的使用知识 （4）良好的语言技能 专业基础知识 （1）软件本地化或国际化的基本知识 （2）软件本地化工程的基础知识 职业素质 （1）解决问题的专业态度和创新能力 （2）主动迅速学习新知识的能力 （3）执著敬业和团队合作能力 （4）良好的书面和口头交流技能 （5）承受压力的能力 九、软件测试管理 缺陷生命周期 （1）新建：当缺陷被第一次递交的时候，它的状态即为“新建”。这也就是说缺陷未被确认其是否真正是一个缺陷 （2）打开：在测试者提交一个缺陷后，测试组长确认其确实为一个缺陷的时候，会把状态置为“打开” （3）分配：一旦缺陷被测试经理置为“打开”，再把缺陷交给相应的开发人员或开发组。这时缺陷状态变更为“分配” （4）测试：当开发人员修复缺陷后，缺陷提交给测试组进行新一轮的测试，在开发人员公布以修复缺陷的程序之前，缺陷状态被置为“测试”。这时表明缺陷已经被修复并已经提交给了测试组 （5）已确认：当缺陷被修复后就会被置为“测试”，测试员会执行测试。如果缺陷不再出现，这就证明缺陷被修复了的同时其状态被置为“已确认” （6）延期：延期状态被置为“延期”意味着，缺陷将会在下一个版本中被修复 （7）重新打开：如果缺陷被开发人员修复后，问题仍然存在，测试人员会把缺陷状态置为“重新打开”。缺陷即将再次穿越其生命周期 （8）重复：如果同一个缺陷被重复提交或者两个缺陷表明的意思相同，那么这个缺陷状态将会被置为“重复”提交 （9）拒绝：如果开发人员不认为其实一个缺陷，会拒绝此缺陷，缺陷状态被置为“拒绝” （10）关闭：当缺陷被修复后，测试人员会对其进行测试。如果测试人员认为缺陷不存在了，会把缺陷状态置为“关闭”，。这个状态意味着缺陷已被修复，通过了测试并且核实确实如此 缺陷报告的编写 （1）清晰地描述缺陷 （2）使用简洁的语言 （3）重现的步骤和数据 （4）提供参考信息 （5）抓屏截图 团队管理 （1）组织结构 基于技能的组织模式 基于测试流程的组织模式 基于项目的组织模式 （2）素质要求 踏实细心和积极主动 怀疑一切 协作和团队感 自我提高和总结的能力 （3）激励方法 表扬和奖励 信任的力量 提高士气 薪水 职务 工作时间 培训机会 风险管理 （1）需求风险 （2）人员风险 （3）环境风险 （4）回归风险 （5）测试资源 （6）需求变更 （7）用例质量 （8）标准差异 （9）测试工具 过程管理 （1）测试需求分析 测试需求的依据与收集 测试需求的分析 测试需求的优先级 （2）测试计划 （3）测试设计 （4）测试开发 （5）测试执行]]></content>
      <categories>
        <category>软件测试</category>
      </categories>
      <tags>
        <tag>软件测试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机操作系统（第四版）习题四解答]]></title>
    <url>%2F2019%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC%E5%9B%9B%E7%89%88%EF%BC%89%E4%B9%A0%E9%A2%98%E5%9B%9B%E8%A7%A3%E7%AD%94%2F</url>
    <content type="text"><![CDATA[为什么要配置层次式存储器？ 设置多个存储器可以使存储器两端的硬件能并行工作； 采用多级存储系统，特别是Cache技术，是减轻存储器带宽对系统性能影响的最佳结构方案； 在微处理机内部设置各种缓冲存储器，减轻对存储器存取的压力 增加CPU中寄存器数量，大大缓解翠存储器压力 可采用哪几种方式将程序装入内存？它们分别适用于何种场合？ 绝对装入方式 只适用于单道程序环境 可重定位装入方式 适用于多道程序环境 动态运行时装入方式 用于多道程序环境 不允许程序运行时在内存中移动位置 何谓静态链接？静态链接时需要解决两个什么问题？ 静态链接是指在程序运行之前，先将各目标模块及它们所需的库函数链接成一个完整的装配模块，以后不再拆开。 需要解决为问题是： 对相对地址进行修改 变换外部调用符号 何谓装入时动态链接？装入时动态链接方式有何优点？ 装入时动态链接是指将用户源程序编译后得到的一组目标模块，在装入内存时，采用边装入边链接的链接方式。 优点： 便于修改和更新 便于实现对目标模块的共享 何谓运行时动态链接？运行时动态链接又何优点？ 运行时动态链接是将对某些模块的链接推迟到程序执行时才运行。 优点： 加快程序的装入过程 节省大量的内存空间 在动态分区分配方式中，应如何将各空闲分区链接成空闲分区链？在每个分区的起始部分设置一些用于控制分区分配的信息，以及用于链接各分区所用的前向指针，在分区尾部则设置一后向指针。通过前、后向链接指针，可将所有的空闲分区链接成一个双向链。 为什么要引入动态重定位？如何实现？ 在程序执行的过程中，每当访问指令或数据时，将要访问的程序或数据的逻辑地址转换成物理地址，所以引入了动态重定位。 实现方法 在系统中增设一个重定位寄存器，用它来存放程序（数据）在内存中的起始地址。程序在执行时，真正访问的内存地址是相对地址与重定位寄存器中的地址相加而形成的。 什么是基于顺序搜索的动态分区分配算法？它可分为哪几种？ 为了实现动态分区分配，通常是将系统中的空闲分区链接成一个链。所谓顺序搜索，是指依次搜索空闲分区链上的空闲分区，去寻找一个其大小能满足要求的分区。 基于顺序搜索的动态分区分配算法可分为： 首次适应算法 循环首次适应算法 最佳适应算法 最坏适应书房 在采用首次适应算法回收内存时，可能出现哪几种情况？应怎样处理？可能会出现四种情况： 回收区与插入点前的一个分区$F_1$相邻接。将回收区与插入点的前一分区合并，不必再为回收分区分配新表项，而只需修改其前一分区$F_1$的大小 回收分区与插入点后的一空闲分区$F_2$相邻接。将两个分区合并，形成新的分区，但用回收区的首址作为新空闲区的首址，大小为两者之和 回收区同时与插入点的前、后两个分区邻接。将三个分区合并，使用$F_1$的表项和$F_1$的首址，取消$F_2$的表项，大小为三者之和。 什么是基于索引搜索的动态分区分配算法？它可分为哪几种？ 基于顺序搜索的动态分区分配算法，比较适用于不太大的系统。当系统很大时，系统中的内存分区可能会很多，相应的空闲分区链就很长，这是采用顺序搜索方法可能会很慢。为了提高搜索空闲分区的速度，在大、中型系统中往往会采用基于索引搜索的动态分区分配算法。 基于索引搜索的动态分区分配算法可分为： 快速适应算法 伙伴系统 哈希算法 令$buddy_k$(x)为大小为$2^k$、地址为x的块的伙伴系统地址，试写出$buddy_k$(x)的通用表达式 分区存储管理中常用哪些分配策略？比较它们的优缺点？ 首次适应算法 保留了高址部分的大空闲区，有利于后来的大型作业分配 地址部分不断被划分，留下很多难以利用的小空闲区，每次查找都从地址开始增加了系统开销 循环首次适应算法 内存空闲分区分布均匀，减少了查找系统开销 缺乏大空闲分区，导致不能装入大型作业 最佳适应算法 每次分配给文件的都是最合适该文件大小的分区，内存中留下了很多难以利用的小空闲区 最坏适应算法 剩下空闲分区不至于太小，产生碎片的可能性最小，对中、小型作业有利 存储器中缺乏大空闲区，对大型文件分区分配不利 查找效率很高 为什么要引入对换？对换可分为哪几种类型？ 在多道程序环境下，一方面，在内存中的某些进程由于某花时间尚未发生而被阻塞运行，但它却占用了大量的内存空间，甚至有时有可能出现在内存中所有进程都被阻塞，而没有可以运行的进程，另一方面，却有着很多作业，因两次了空间不足，一直驻留在外存上，而不能进入内存运行。为了解决这一问题，系统引入了对换。 对换的类型 整体对换 页面（分段）对换 对文件区管理的目标和对对换空间管理的目标有何不同？ 对文件区管理的主要目标： 提高文件存储空间的利用率，然后才是提高对文件的访问速度。因此，对文件区空间的管理采取离散分配方式 对对换空间管理的目标： 提高进程换入和换出的速度，然后才是提高文件存储空间的利用率。为此，对对换空间的管理采取连续分配方式，较少考虑外存中的碎片问题 为实现对换，系统应具备哪几方面的功能？ 对换空间管理 进程换入 进程换出 在以进程为单位进行对换时，每次是否都将整个进程换出？为什么？在以进程为单位进行对换时，并非每次都将整个进程换出，这是因为： 从结构上讲，进程是由程序段、数据段和进程控制块组成的，其中进程控制块中总有部分或全部常驻内存，不被换出 程序段和数据段可能正在被若干进程共享，此时它们也不能换出 基于离散分配时所用的基本单位不同，可将离散分配分为哪几种？ 分页存储管理方式 分段存储管理方式 段页式存储管理方式 什么是页面？什么是物理块？页面的大小应如何确定？ 页面。分页存储管理将进程的逻辑地址空间分为若干个页，并为各页加以编号。 物理块：将内存中的物理地址空间分层若干个块 在分页系统中，若选择过小的页面大小，虽然一方面可以减轻碎片，起到减少内存碎片总空间的作用，有利于内存利用率的提高，但另一方面却会造成每个进程占用较多的页面，从而导致进程的页表过长，占用大量内存。此外，还会降低换进换出的效率。然而，页面选择过大，虽然可以减少页表的长度，提高页面换进换出的速度，但却又会使页内碎片增大。因此，页面的大小应选择适中，且页面大小应是2的幂，通常为1KB-8KB。 什么是页表？页表的作用是什么？ 在分页系统中，允许将进程的各个页面离散地存储在内存的任一地址块中，为了保证进程仍然能够正确地运行，即能在内存中找到每个页面所对应的物理块，系统又为每个进程建立了一张页面映像表，简称页表。 页表的作用是实现从页号到物理块号的地址映射 为实现分页存储管理，需要哪些硬件支持？ 页表寄存器 地址变换机构 联想寄存器 在分页系统中是如何实现地址变换的？&emsp;&emsp;当进程要访问某个逻辑地址中的数据时，分页地址变换机构会自动地将有效地址分为页号和页内地址两部分，再以页号为索引去检索页表。查找操作由硬件执行。在执行检索之前，先将页号与页表长度进行比较，如果页号大于或等于页表长度，则表示本次所访问的地址已超越进程的地址空间。于是，这一错误将被系统发现，并产生一地址越界中断。 &emsp;&emsp;若未出现越界错误，则将页表始址与页号和页表项长度的乘积相加，便得到该表项在页表中的位置，于是可从中得到该页的物理块号，将之装入物理地址寄存器中。与此同时，再将有效地址寄存器中的页内地址送入物理地址寄存器的块内地址字段中。这样便完成了从逻辑地址到物理地址的变换。 具有快表时是如何实现地址变换的？&emsp;&emsp;在CPU给出有效地址后，由地址变换机构自动地将页号P送入高速缓冲寄存器，并将此页号与高速缓存中的所有页号进行比较，若其中有与此相匹配的页号，便表示所要访问的页表项在快表中。于是，可直接从快表中读出该页所对应的物理块号，并送到物理地址寄存器中。 &emsp;&emsp;若在快表中未找到对应的页表项，则还须再访问内存中的页表，找到后，把从页表项中读出的物理块号送往地址寄存器；同时，再将此页表项存入快表的一个寄存器单元中。但如果联想寄存器已满，则OS必须找到一个老的且已被认为是不再需要的页表项，将它换出。 较详细地说明引入分段存储管理是为了满足用户哪几方面的需要。 方便编程。用户通常把自己的作业按照逻辑关系划分为若干段，每段都从0 编址，并有自己名字和长度。因此，希望要访问的逻辑地址是由段名和段内偏移量决定。 信息共享。在实现对程序和数据的共享时，是以信息逻辑单位为基础。分页系统中的页是存放信息的物理单位，无完整意义，不便于共享；段是信息的逻辑单位。为了实现段的共享，希望存储管理能与用户程序分段的组织方式相适应。 信息保护。对信息的逻辑单位进行保护，分段能更有效方便地实现信息保护功能。 动态增长。在实际应用中，有些段特别是数据段，在使用过程中会不断增长，事先又无法确切知道增长多少。分段存储管理方式能较好解决这个问题。 动态链接。运行时先将主程序对应的目标程序装入内存并启动运行，运行过程中又需要调用某段时，才将该段调入内存链接。所以动态链接也要求以段作为管理单位。 在具有快表的段页式存储管理方式中，如何实现地址变换？&emsp;在CPU给出有效地址后，由地址变换机构自动地将页号P送入高速缓冲寄存器，并将此页号与高速缓存中的所有页号进行比较，若其中有与此相匹配的页号，便表示所要访问的页表项在快表中。于是，可直接从快表中读出该页所对应的物理块号，并送到物理地址寄存器中。 &emsp;&emsp;若在快表中未找到对应的页表项，则还须再访问内存中的页表，找到后，把从页表项中读出的物理块号送往地址寄存器；同时，再将此页表项存入快表的一个寄存器单元中。但如果联想寄存器已满，则OS必须找到一个老的且已被认为是不再需要的页表项，将它换出。 为什么说分段系统比分页系统更易于实现信息的共享和保护？ 分页系统的每个页面是分散存储的，为了实现信息共享和保护，页面之间需要一一对应，为此需要建立大量的页表项； 而分段系统的每个段都从0 编址，并采用一段连续的地址空间，在实现共享和保护时，只需为要共享和保护的程序设置一个段表项，将其中的基址与内存地址一一对应就能够实现。 分页和分段存储管理有何区别？ 页是信息的物理单位。采用分页存储管理方式是为了实现离散分配方式，以消减内存的外零头，提高内存的利用率。段则是信息的逻辑单位，它通常包含的是一组意义相对完整的信息。分段的目的主要在于能更好地满足用户的需要。 页的大小固定且由系统决定。在采用分页存储管理方式的系统中，在硬件结构上就把用户程序的逻辑地址划分为页号和页内地址两部分。而段的长度却是不固定的，决定于用户所编写的程序，通常由编译程序在对源程序进行编译时，根据信息的性质来划分 分页的用户程序地址空间是一维的。分页完全是系统的行为，故在分页系统中，用户程序的地址是属于单一的线性地址空间。而段式用户的行为，故在分段系统中，用户程序的地址空间是二维的。 试全面比较连续分配和离散分配方式 连续分配是指为一个用户程序分配一个连续的地址空间，包括单一和分区两种分配方式。单一方式将内存分为系统区和用户区，最简单且只用于单用户单任务操作系统：分区方式分为固定分区和动态分区。 离散分配方式分为分页、分段和段页式存储管理。分页式存储管理旨在提高内存利用率，分段时存储管理旨在满足用户的需要，段页式存储管理则是将两者结合起来，具有分段系统便于实现、可分享、易于保护和动态链接等优点，又能像分页系统一样，很好地解决外部碎片及为各段可离散分配内存等问题，是比较有效的存储管理方式。]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>存储器管理</tag>
        <tag>习题解答</tag>
        <tag>对换</tag>
        <tag>分页存储管理方式</tag>
        <tag>分段存储管理方式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机操作系统（第四版）习题二解答]]></title>
    <url>%2F2019%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC%E5%9B%9B%E7%89%88%EF%BC%89%E4%B9%A0%E9%A2%98%E4%BA%8C%E8%A7%A3%E7%AD%94%2F</url>
    <content type="text"><![CDATA[为什么程序并发执行会产生间断性特征？程序在并发执行时，由于它们共享系统管理资源，以及为万分同一项任务而相互合作，致使在这些并发执行的程序之间形成了相互制约的关系，而相互制约将导致程序具有“执行——暂停——执行”这种间断性的活动规律，所以说程序并发执行会产生间断性特征。 程序并发执行时为什么会失去封闭性和可再现性？当系统中存在着多个可以并发执行的程序时，系统中的各种资源将为它们所共享，而这些资源的状态也由这些程序来改变，致使其中任一程序在运行时，其环境都必然会受到其他程序的影响，显然，程序的运行已失去了封闭性。而失去封闭性会导致程序失去可再现性。 在操作系统中为什么要引入进程的概念？它会产生什么样的影响?在多道程序环境下，程序的执行属于并发执行，此时它们失去其封闭性，并且具有间断性，以及其运行结果不可再现。这些决定了通常的程序是不能参与并发执行的，否则，程序的运行也就失去了意义。为了能使程序并发执行，并且可以对并发执行的程序加以描述和控制，才操作系统中引入了进程概念. 试从动态性、并发性和独立性上比较进程和程序进程和程序是两个截然不同的概念。 动态性。进程的实质是进程实体的执行过程，因此，动态性是进程的最基本的特征。表现为“由创建而产生，由调度而执行，由撤销而消亡”，进程具有一定的生命期；而程序则只是一组有序指令的集合，并存放于某种介质上，其本身并不具有活动的含义，是静态实体。 并发性是进程的重要特征，同时也是OS的重要特征；而程序是不能参与并发执行的。 独立性是指进程实体是一个能独立运行、独立获得资源和独立接受调度的基本单位（传统OS中）；而对于未建立PCB的程序来说，它不能作为一个独立单位参与运行。 试说明PCB的作用具体表现在哪几个方面，为什么说PCB是进程存在的唯一标志？PCB作为进程实体的一部分，记录了操作系统所需的，用于描述进程当前情况以及管理进程运行的全部信息，是操作系统中最重要的记录型数据结构。 作用是使一个在多道陈存储环境下不能独立运行的程序（包括数据）成为一个能独立运行的基本单位，一个能与其他进程并发执行的进程。 当一个程序（含数据）配置了PCB后，就表示它已是一个能在多道程序环境下独立运行的、合法的基本单位，也就具有取得OS服务的权利。系统时通过PCB感知进程的存在的，所以，PCB已成为进程存在的唯一标志。 PCB提供了进程管理和进程调度所需要的哪些信息？ 进程标识符 处理机状态 进程调度信息 进程状态 进程优先级 进程调度所需的其他信息 事件 进程控制信息 程序和数据的地址 进程同步和通信机制 资源清单 链接指针 进程控制块的组织方式有哪几种？ 线性方式 链接方式 索引方式 何谓操作系统内核？内核的主要功能是是什么？现代操作系统一般将OS划分为若干层次，再将OS的不同功能分别设置在不同的层次中。 通常将一些与硬件紧密相关的模块、各种常用设备的驱动程序以及运行频率较高的模块，都安排在紧靠硬件的软件层次，让它们常驻内存，即OS内核。 OS内核的功能主要是以下两大方面： 支撑功能 中断处理 时钟管理 原语操作 资源管理功能 进程管理 存储器管理 设备管理 试说明进程在三个基本状态之间转换的典型原因 执行状态$\rightarrow$就绪状态：时间片完 就绪状态$\rightarrow$执行状态：进程调度 执行状态$\rightarrow$阻塞状态：I/O请求 阻塞状态$\rightarrow$就绪状态：I/O完成 为什么要引入挂起状态？该状态有哪些性质？引入挂起的原因，是基于系统和用户的如下需要： 终端用户的需要 父进程请求 负荷调节的需要 操作系统的需求 挂起状态的性质是：放弃CPU调度，不接受调度。引入挂起状态后，进程状态转换图增加了活动阻塞、静止阻塞、活动就绪、静止就绪四个状态，并增加了活动就绪与静止就绪，活动阻塞和静止阻塞之间的相互转换。 在进行进程切换时，所要保存的处理机状态信息有哪些？进程进行切换时，需要保存的处理机状态信息有： 进程当前暂存信息 下一指令地址信息 进程状态信息 过程和系统调用参数及调用地址信息 试说明引起进程创建的主要事件 用户登录 作业调度 提供服务 应用请求 试说明引起进程被撤销的主要事件 正常结束 异常结束 越界错 保护错 非法指令 特权指令错 运行超时 等待超时 算术运算错 I/O故障 外界干预 在创建一个进程时所要完成的主要工作是什么？在系统中每当出现了创建新进程的请求后，OS便调用进程创建原语Create按下述步骤创建一个新进程： 申请空白PCB 为新进程分配运行所需的资源 初始化进程控制块 如果进程就绪队列能够接纳新进程，便将新进程插入就绪队列 在撤销一个进程时所要完成的主要工作是什么？如果系统中发生了要求终止进程的某事件，OS便调用进程终止原语，按下述过程去终止指定的进程： 根据被终止进程的标识符，从PCB集合中检索出该进程的PCB，从中读出该进程的状态 若被终止形成正处于执行状态，应立即终止该进程的执行，并置调度标志为真，用于指示该进程被终止后应重新进行调度 若该进程还有子孙进程，还应将其所有子孙进程也都予以终止，以防它们成为不可控进程 将被终止进程所拥有的全部资源或者归还给其父进程，或者归还给系统 将被终止进程（PCB）从所在队列（或链表）移除，等待其他程序来搜集信息 试说明引起进程阻塞或被唤醒的主要事件是什么？ 向系统请求共享资源失败 等待某种操作完成 新数据尚未到达 等待新任务的到达 为什么要在OS中引入线程？在OS中引入线程，是为了减少程序在并发执行时所付出的时空开销，使OS具有更好的并发性。 试说明线程具有哪些属性？ 轻型进程 调度的基本单位 并发性 拥有资源 独立性 系统开销 支持多处理机系统 试从调度性、并发性、拥有资源及系统开销方面对进程和线程进行比较 调度性 在传统的OS中，进程是作为独立调度和分派的基本单位，因而进程是能独立运行的基本单位。在每次调度时，都需要进行上下文切换，开销较大。 在引入线程的OS中，已把线程作为调度和分派的基本单位，因而线程是能独立运行的基本单位。当线程切换时，仅需要保存和设置少量寄存器内容，切换代价远低于进程。在同一进程中，线程的切换不会引起进程的切换，但从一个进程中的线程切换到另一个进程中的线程时，必然会引起进程的切换 并发性 在引入线程的OS中，不仅进程之间可以并发执行，而且在一个进程的多个线程之间亦可并发执行，甚至允许在一个进程中的所有线程都能并发执行。同样，不同进程中的线程也能并发执行。 拥有资源 进程可以拥有资源，并作为系统中拥有资源的一个基本单位。然而，线程本身并不拥有系统资源，而是仅有一点必不可少的、能保证独立运行的资源 线程除了拥有自己的少量资源外，还云溪多个线程共享该进程拥有的资源。 系统开销 在创建或撤销进程时，系统都要为之分配和回收进程控制块、分配或回收其他资源。OS为此所付出的开销，明显大于线程创建或撤销时所付出的开销。类似地，在进程切换时，涉及到进程上下文的切换，而线程的切换代价也远低于进程的。 线程控制块TCB中包含了哪些内容？ 线程标识符 一组寄存器 线程运行状态 优先级 线程专有存储区 信号屏蔽 堆栈指针 何谓用户级线程和内核支持线程？ 用户级线程：用户级线程是在用户空间中实现的。对线程的创建、撤销、同步与通信等功能，都无需内核的支持，即用户级线程是与内核无关的。 内核支持线程：是在内核的支持下运行的，它们的创建、阻塞、撤销和切换等，都是在内核空间实现的 试说明用户级线程的实现方法用户级线程是在用户空间中的实现的，运行在“运行时系统”与“内核控制线程”的中间系统上。运行时系统用于管理和控制线程的函数的集合。内核控制线程或轻型进程LWP可通过系统调用获得内核提供服务，利用LWP进程作为中间系统。 试说明内核支持线程的实现方法系统在创建一个新进程时，便为它分配一个任务数据区PTDA，其中包括若干个线程控制块TCB空间。在每个TCB中可保存线程标识符、优先级、线程运行的CPU状态信息。每当进程要创建一个线程时，便为新线程分配一个TCB，将相关信息填入该TCB中，并为之分配必要的资源；当PTDA中的所有TCB空间已用完，而进程又要创建新的线程时，只要其所创建的线程数目未超过系统允许值，系统可再为之分配新的TCB空间；在撤销一个线程时，也应回收该线程的所有资源和TCB。 多线程模型有哪几种类型？多对一模型有何优缺点？由于用户级线程和内核级线程连接方式的不同，从而形成了三种不同的模型： 多对一模型 一对一模型 多对多模型 多对一模型的优点： 线程管理的开销小，效率高 多对一模型的缺点： 如果一个线程在访问内核时发生阻塞，则整个进程都会被阻塞 在任一时刻，只有一个线程能访问内核，多个线程不能同时在多个处理机上运行]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>习题解答</tag>
        <tag>线程</tag>
        <tag>进程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ASP.NET Core MVC 视图与控制器传值]]></title>
    <url>%2F2019%2F%E8%A7%86%E5%9B%BE%E4%B8%8E%E6%8E%A7%E5%88%B6%E5%99%A8%E4%BC%A0%E5%80%BC%2F</url>
    <content type="text"><![CDATA[一、form表单传值 View页面：GetFormValue.cshtml12345678&lt;h1&gt;GetFormValue&lt;/h1&gt;&lt;form asp-action="Home/GetFormValue" method="post"&gt; &lt;div&gt; &lt;input type="text" name="name" placeholder="名字" /&gt; &lt;/div&gt; &lt;button id="submit" type="submit"&gt;提交&lt;/button&gt;&lt;/form&gt; 在这个form表单中，用asp-action=&quot;Home/GetFormValue&quot;指定了表单中的值需要传到什么地方，其中Home代表控制器，GetFromValue代表Action。 Action: GetFormValue12345678910public IActionResult GetFormValue() &#123; return View(); &#125; [HttpPost] public IActionResult GetFormValue(string name) &#123; return View(); &#125; GetFormValue用来接受从视图传过来的值，这次传的是名字。 页面输入 传值结果 二、JS传值 视图页面：GetJsValue.cshtml12345678910111213141516&lt;h1&gt;GetFormValue&lt;/h1&gt;&lt;div&gt; &lt;input id="testdata" type="text"/&gt; &lt;input id="submitButton" type="button" value="提交" /&gt;&lt;/div&gt;&lt;script &gt; var button = document.getElementById('submitButton'); button.onclick = function () &#123; var data = $('#testdata').val(); $.post("Home/GetJsValue", &#123; name: data &#125;, function () &#123; alert("submit data success!"); &#125;); &#125;&lt;/script&gt; Action：GetJsValue123456789public IActionResult GetJsValue() &#123; return View(); &#125; [HttpPost] public IActionResult GetJsValue(string name) &#123; return View(); &#125; 页面输入 传值结果 三、Jquery AJAX方法传值 视图页面：GetJqueryValue.cshtml123456789101112131415161718192021222324&lt;h1&gt;GetJqueryValue&lt;/h1&gt;&lt;div&gt; &lt;input id="testdata" type="text" /&gt; &lt;input id="submitButton" type="button" value="提交" /&gt;&lt;/div&gt;&lt;script type="text/javascript" src="~/js/jQuery.form.js"&gt;&lt;/script&gt;&lt;script type="text/javascript" src="~/js/jquery-1.12.4.min.js"&gt;&lt;/script&gt;&lt;script&gt; $("#submitButton").click(function () &#123; var name = $("#testdata").val(); $.ajax(&#123; type: 'post', url:'/Home/GetJqueryValue', data: &#123; "name": name &#125;, success: function (data) &#123; alert("submit success"); &#125;, error: function (data) &#123; alert("failed"); &#125; &#125;) &#125;);&lt;/script&gt; 在使用jquery的ajax方法传递数据的时候，会出现not defined错误，网上查了一圈也没有解决，最后用上面的方式解决了。 Action:GetJqueryValue123456789public IActionResult GetJqueryValue() &#123; return View(); &#125; [HttpPost] public IActionResult GetJqueryValue(string name) &#123; return View(); &#125; 页面结果 传值结果 四、模型绑定模型绑定就是将表单中的传递来的数据，创建对应的model并把数据赋给model的属性。我们能看到的就是表单传过来的数据是一个对象。 需要注意的是，传递每一项数据的名称和接受的类的属性名称必须相同。 Aoki类：1234567public class Aoki &#123; [Required(ErrorMessage = &quot;尚有未填写项，请先完善&quot;)] public string name &#123; get; set; &#125; [Required(ErrorMessage = &quot;尚有未填写项，请先完善&quot;)] public string description &#123; get; set; &#125; &#125; 对于Aoki类，我添加了模型验证，Required就是说这个属性不能为空，当表单中这个数据没有填写的时候，是无法提交的。当然，我觉得前端的验证有浏览器完成比较好一些。 视图页面：GetModelValue.cshtml1234567891011&lt;h1&gt;GetModelValue&lt;/h1&gt;&lt;form asp-action="Home/GetModelValue" method="post"&gt; &lt;div&gt; &lt;input type="text" name="name" placeholder="名字" /&gt; &lt;/div&gt; &lt;div&gt; &lt;input type="text" name="description" placeholder="描述" /&gt; &lt;/div&gt; &lt;button id="submit" type="submit"&gt;提交&lt;/button&gt;&lt;/form&gt; 这里要注意的是，name必须和原有对象的属性名相同。 Action:GetModelValue123456789public IActionResult GetModelValue() &#123; return View(); &#125; [HttpPost] public IActionResult GetModelValue(Aoki aoki) &#123; return View(); &#125; 在第二个Action中会收到前端传过来的一个对象，这个对象的属性是和前端页面中表单中填写的数据绑定的。 页面输入： 传值结果： 五、定位标记帮助程序标记帮助程序使服务器端代码可以在Razor文件中参与创建和呈现HTML元素。在下面的代码中，AnchorTagHelper从控制器操作方法和路由ID动态生成HTMLhref特性值。 视图页面：GetNum.cshtml1234567891011121314151617181920&lt;h1&gt;GetNum&lt;/h1&gt;&lt;table border="1"&gt; &lt;tr&gt; &lt;th&gt;名字&lt;/th&gt; &lt;th&gt;描述&lt;/th&gt; &lt;th&gt;操作&lt;/th&gt; &lt;/tr&gt; &lt;tr&gt; &lt;th&gt; Aoki &lt;/th&gt; &lt;th&gt; 试举头，一笑问青天、天无语 &lt;/th&gt; &lt;th&gt; &lt;a asp-action="GetNum" asp-controller="Home" asp-route-ID="1"&gt;查看&lt;/a&gt; &lt;/th&gt; &lt;/tr&gt;&lt;/table&gt; 这里需要注意的是asp-action、asp-controller、asp-route-ID是生成URL。在asp-route-ID中值得注意的是，这里面的ID就是传递的参数，控制器里面的参数名字是什么，这里的ID就换成什么。否则会出错 Action:GetNum1234public IActionResult GetNum(int ID) &#123; return View(); &#125; 页面结果 鼠标悬停在查看按钮上，下方会出现URL。如图所示。 在浏览器中“查看源”，生成的HTML的部分如下如图所示。 传值结果 &emsp;&emsp;获得源码]]></content>
      <categories>
        <category>ASP.NET Core MVC</category>
      </categories>
      <tags>
        <tag>ASP.NET Core</tag>
        <tag>视图与控制器</tag>
        <tag>传值</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ASP.NET Core MVC控制器与视图传值]]></title>
    <url>%2F2019%2FASP-NET-Core-MVC%E6%8E%A7%E5%88%B6%E5%99%A8%E4%B8%8E%E8%A7%86%E5%9B%BE%E4%BC%A0%E5%80%BC%2F</url>
    <content type="text"><![CDATA[一、传值方式 弱类型参数传递数据 强类型参数传递数据 二、弱类型参数传递数据 ViewData1）派生自ViewDataDictionary，因此它有可用的字典属性，如，ContainsKey、Add、Remove、Clear &emsp; 2）字典中键是字符串，所以允许有空格 &emsp; 3）任何非string类型均须在试图中进行强制转换才能使用ViewData ViewBag1）派生自DynamicViewData，因此它可使用点表示法（ViewBag.name=name)创建动态属性，且无需强制转换 2) ViewBag的语法使控制器到视图的速度更快 3) ViewBag更易于检查NULL值 3. ViewData的使用1）创建Action：Index 123456public IActionResult Index() &#123; ViewData[&quot;name&quot;] = &quot;Aoki&quot;; ViewData[&quot;description&quot;] = &quot;试举头，一笑问青天、天无语&quot;; return View(); &#125; 2）创建视图：Index.cshtml 1234&lt;div class="text-center"&gt; &lt;h1&gt;@ViewData["name"]&lt;/h1&gt; &lt;p&gt;@ViewData["description"]&lt;/p&gt;&lt;/div&gt; 3）实现结果： 4. ViewBag的使用1）创建Action：Index \ASP-NET-Core-MVC控制器与视图传值 1234567public IActionResult Index() &#123; ViewBag.type = &quot;ViewBag&quot;; ViewBag.name = &quot;Aoki&quot;; ViewBag.description = &quot;试举头，一笑问青天、天无语&quot;; return View(); &#125; 2）创建视图：Index.cshtml 12345&lt;div class="text-center"&gt; &lt;h1&gt;@ViewBag.name&lt;/h1&gt; &lt;p&gt;@ViewBag.description&lt;/p&gt; &lt;h4&gt;Pass the value through @ViewBag.type&lt;/h4&gt;&lt;/div&gt; 3）实现结果 三、强类型参数传递数据 强类型参数说明&emsp;&emsp;视图强类型通常称为ViewModel，可以在return View();时指定参数/对象。并在视图文件（.cshtml）中通过@model语法来指定对应的类型。 强类型参数示例1）创建Aoki类 12345public class Aoki &#123; public string name &#123; get; set; &#125; public string description &#123; get; set; &#125; &#125; 2）创建Action：Index 123456789public IActionResult Index() &#123; var aoki = new Aoki &#123; name = "Aoki", description = "试举头，一笑问青天、天无语" &#125;; return View(aoki); &#125; 3）创建视图：Index.cshtml 1234&lt;div class="text-center"&gt; &lt;h1&gt;@Model.name&lt;/h1&gt; &lt;p&gt;@Model.description&lt;/p&gt;&lt;/div&gt; 4）实现结果]]></content>
      <categories>
        <category>ASP.NET Core MVC</category>
      </categories>
      <tags>
        <tag>ASP.NET Core</tag>
        <tag>MVC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[软件管理]]></title>
    <url>%2F2019%2F%E7%AE%A1%E7%90%86%2F</url>
    <content type="text"><![CDATA[一、软件过程改进模型CMMI软件组织的产品质量和服务质量，来自组织内部的过程改进状态。而过程改进是要有模型的，模型是实践、理论、方法、经验和技术的结晶，是软件组织的一种企业文化、工作环境和管理理念；模型能够引导企业从杂乱无章的管理状态到有条不紊的管理状态。 目前为止，IT企业界的过程管理和过程改进模型共有三个类型： ISO 9001 模型 CMMI模型 软件企业文化模型 微软企业文化 IBM企业文化 敏捷文化现象 CMMI是什么软件能力成熟度模型CMMI是由美国卡内基-梅隆大学软件工程研究所推出的评估软件能力与成熟度等级的一套标准。 CMMI的作用是什么 软件组织，用它来不断改进自身的软件过程管理能力 评估机构，用它来评估某软件组织当前软件能力成熟度级别 客户，用它来评估某承包商的软件能力 CMMI的实质 以“过程”为核心，抓软件组织的管理，即软件“组织”的过程改进 以“项目”为手段，抓团队开发过程的“活动”，即落实过程改进的措施 以“活动”记录为基础，抓软件过程的“度量”，即“度量”软件组织改进的情况 CMMI阶段模型的成熟度等级 CMMI等级 PA数目 管理特点 ML1:初始级 0 过程不可预测且缺乏控制 ML2：已管理级 7 过程为项目服务，即项目级管理 ML3：已定义级 11 过程为组织服务，即组织级管理 ML4：定量管理级 2 过程已度量和控制，即定量级管理 ML5：优化级 2 集中于过程改进，即优化管理级 ISO 9001与CMMI的联系和区别&emsp;&emsp;与ISO 9001标准相比，CMMI更为软件产业所看好。原因是CMMI专门针对软件工程控制而设置。它不仅进行软件企业工程能力的评估，更致力于软件开发过程的管理，强调对软件开发过程进行持续改进，引导软件开发过程走向成熟。 &emsp;&emsp;两者的相同点是：CMMI和ISO 9001标准都致力于质量和过程管理，都是为了解决同样的问题。 &emsp;&emsp;两者的不同点是：CMMI是动态的、开放的和持续改进的，它强调“没有最好，只有更好”，强调不断改进，强调人在软件开发方面的主动性，非常适用于软件过程改进；ISO 9001是静态的质量控制，只要达到20个关键指标或过程，就能完成质量控制，它更适用于硬件制造行业和第三产业的质量控制。CMMI与IO 9001的设计思路有差异：CMMI是“专用的”，ISO 9001是“通用”的。ISO 9001不覆盖CMMI，CMMI也不覆盖ISO 9001. 二、软件配置管理软件配置管理SCM是对软件开发过程中配置项的一组追踪和控制活动，它开始于软件开发之初，结束于软件淘汰之时。 三、软件质量保证软件质量保证SQA是一个过程，是CMMI和ISO 9001的重要议题，同样也是项目管理的重要议题。 软件质量，是供方提供的软件产品满足用户明确或隐含需求的能力特性的总和。 质量管理的三大支柱 质量标准 配置管理 测试测量 质量管理的三大要素 SQA计划 SQA进度 SQA评审和审计 四、软件项目管理 什么是项目项目，是一次性的多任务工作，它具有确定的开始日期，结束日期，工作范围，经费预算，质量标准，以及特定的功能、性能和接口要求。 什么是项目管理项目管理，是为了实现项目目标，运用相关知识、技能、方法与工具，对项目的计划、进度、质量、成本、资源进行管理和控制的活动。 项目经理的七项职责 抓需求获取与确认 抓计划制订与执行 抓团队分工与协作 抓后勤供应与保障 抓产品测试和交付 抓开发标准与规范 抓员工考核与奖励 项目经理对程序员的八项要求 团队协作精神的训练和要求 数据库和数据结构分析与设计能力的训练和要求 书写文档习惯的训练和要求 规范化代码编写能力的训练和要求 复用性能力与构件技术的训练和要求 测试习惯的训练和要求 学习和总结能力的训练和要求 引导程序员由“丑小鸭”变成“白天鹅”]]></content>
      <categories>
        <category>软件工程</category>
      </categories>
      <tags>
        <tag>CMMI</tag>
        <tag>软件管理</tag>
        <tag>项目管理</tag>
        <tag>软件质量保证</tag>
        <tag>项目经理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[软件实施与维护]]></title>
    <url>%2F2019%2F%E5%AE%9E%E6%96%BD%E4%B8%8E%E7%BB%B4%E6%8A%A4-1%2F</url>
    <content type="text"><![CDATA[一、软件产品 软件企业开发的软件可以分为软件项目和软件产品。 软件产品分为三类分别是： 类别 产品特点 举例 1 不需要客户化的产品 系统软件 2 只需要少量客户化工作的产品 专业性特强的应用软件产品 3 需要重新做业务流程规范和需求规格定义的软件产品 分行业ERP 项目与产品的区别与联系 除了上述三类软件产品外，其他软件一般称为软件项目，不能叫软件产品。 软件项目就是为用户定制的软件系统，它的专业性强，通用性差，从需求分析、设计、编码、测试，到安装、试运行、正式运行，直至验收交付，整个开发流程一步都不能省。 软件项目的特点是，业务领域知识所占比重大，工程性强，因此用CMMI模型实现规范化管理和量化控制比较适合。IT企业做软件项目的目的，一般都是为了将软件项目逐步产品化，如同做财务项目是为了做财务产品一样。一方面，只有产品化了才能赚取最大的利润，另一方面，只有拥有自己的软件产品，才能在投标活动中获得更大更好的项目。 项目和产品既有显著的不同，又有紧密的关系。这种关系是：做软件项目是手段，做软件产品是目的，软件项目做多了，软件项目就慢慢变成了软件产品。 二、软件产品的发布&emsp;&emsp;产品的发布时机，是由市场利润、开发进度、产品的功能与质量、客户可接受程度等多方面因素决定的。 三、软件产品的实施软件产品发布以后，销售中心就会获取各种客户信息，并准备用各种方式为客户服务。在服务中，需要各种销售技术人员的支持，这些技术人员包括售前、售中、售后三部分人员。售前技术人员称为售前工程师，售中技术人员称为实施工程师，售后技术人员称为维护工程师。 四、软件维护的传统方法软件维护，是指软件项目或产品爱安装、运行并交付给用户使用后，在新产品升级之前这段时间里，软件厂商向客户提供的服务工作。 软件维护的分类 序号 维护的种类 维护的内容 1 纠错性维护 产品或项目中存在缺陷或错误，在测试和验收时未发现，到了使用过程中逐渐暴露出来，需要改正。 2 适应性维护 这类维护是为了产品或项目适应变化了的硬件、系统软件的运行环境，如系统升级 3 完善性维护 这类维护是为了给软件系统增加一些新的功能，使产品或项目更加完善与合理，又不至于对系统进行伤筋动骨的改造，这类维护占维护的大部分 4 预防性维护 这类维护是为了提高产品或项目的可靠性和可维护性，有利于系统的进一步改造或升级换代 软件维护的副作用 序号 维护的方式 副作用的表现 1 修改编码 使编码更加混乱，程序结构更不清晰，可读性更差，而且会有连锁反应 2 修改数据结构 数据结构是系统的骨架，修改数据结构是对系统伤筋动骨的大手术，在数据冗余与数据不一致方面，可能顾此失彼 3 修改用户数据 需要与用户协商，一旦有疏忽，可使系统发生意外 4 修改文档 对非结构化维护不适应，对结构化维护要严防程序与文档的不匹配 五、软件维护的最新方法 软件维护的最新分类方法 面向缺陷维护——程序级维护 面向功能维护——设计级维护 软件维护的最新方法 基于两层结构（客户机/服务器）划分软件维护的方法 基于三层结构划分软件维护的方法 基于“三种开发方法”，来划分软件维护的方法 软件维护工作流程 流程步骤 流程内容 1 分类整理用户意见 2 提出维护申请 3 评审、审计、批准维护申请 4 修改需求文档 5 维护需求文档评审 6 维护设计文档 7 维护设计文档评审 8 修改源程序 9 回归测试 10 修改软件版本号 11 交付用户运行 12 收集用户反馈意见，准备进行新一轮维护活动，转向流程第1个步骤]]></content>
      <categories>
        <category>软件工程</category>
      </categories>
      <tags>
        <tag>软件维护</tag>
        <tag>软件产品</tag>
        <tag>软件项目</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[软件设计、实现与测试]]></title>
    <url>%2F2019%2F%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E3%80%81%E5%AE%9E%E7%8E%B0%E3%80%81%E6%B5%8B%E8%AF%95%2F</url>
    <content type="text"><![CDATA[一、软件设计 三层结构设计1）表示层：也称浏览层，通常采用图形化界面，在客户端PC或工作站上运行。站在“三个模型”的思想上看，系统内部支持表示层的模型是“功能模型”。 &emsp;表示层的主要功能： &emsp;1)接受用户请求，将这些请求反馈给业务逻辑层，等待业务逻辑层的应答信息。 &emsp;2）对业务逻辑层的应答信息进行显示 &emsp;3）有时会兼做一些业务逻辑层的小功能 2）中间层（业务层）：它由许多构件和组件组成，它们完全体现了用户的业务逻辑或业务规则，站在“三个模型”建模思想上看，系统内部支持业务层的模型是“业务模型”。 &emsp;业务层的主要功能： &emsp;1）接受从表示层传来的用户请求信息 &emsp;2）根据用户的请求信息生成SQL语句 &emsp;3)利用生成的SQL语句从数据层取数据、修改数据、删除数据 &emsp;4）将结果返回表示层 中间层也可以分为两个子层，分别是业务逻辑层和数据访问层。 在这段时间的信息系统设计中我深有体会，将虽然三层结构从一定程度上可以降低系统的耦合度，但是如果数据层出现问题，需要进行调整，那么中间层也要进行大规模的调整，这对系统的实现进度是有害的。如果将中间层划分为两个子层，那么，如果数据层出现问题，进行了大规模调整，那么我们的业务逻辑层是不会受到影响的，只需要对数据访问层进行适当的修改。 3）数据层：是数据库服务器上的数据库层，它包括数据库管理系统DBMS和数据库DB两部分。站在“三个模型”建模思想上看，系统内部支持数据层的模型是“数据模型”。 &emsp;数据层的功能： &emsp;1）接受业务层数据处理请求的SQL语句或存储过程 &emsp;2）利用SQL语句或存储过程，对数据库服务器上数据库的相关表进行存储或检索 &emsp;3）将存储或检索的结果传递给业务层。 软件设计原理软件设计原理，就是各种软件设计方法中都应该遵守的共同基本原理。这些原理包括：抽象、模块化、信息隐藏、模块独立性、封装、接口和实现分离。 1）抽象。 在每个阶段中，抽象的层次逐步降低，在软件结构设计中的模块分层也是由抽象到具体分析和构造出来的。抽象就是将几个有区别的物体的共同性质或特性，形象地抽取出来，独立地进行考虑的过程。 常用的抽象技术有：控制抽象、过程抽象、数据抽象 2）模块化。 模块指程序中的数据说明、可执行语句等程序对象的集合，或单独命名和编程的元素。 模块化，就是解决一个复杂问题时，自顶向下、逐步求精地把软件系统划分为若干模块的过程。为了解决复杂的问题，在软件设计中，必须把整个问题分解来降低复杂性，以减小开发工作量，降低开发成本，提高软件生产率。但是模块并不是越多越好，因为这会增加模块之间的接口量。所以划分模块的层次和数量应该避免过多或过少。 3）信息隐藏。 信息隐藏，指在设计和确定模块时，使一个模块内包含的信息，对于不需要这些信息的其他模块来说是不能访问的。 4）模块独立性。 模块独立性指每个模块只完成系统要求的独立的子功能，并且与其他模块的联系最少，且接口简单。模块独立性是抽象、模块化、信息隐藏的直接产物，在概要设计的过程中，就是要设计出具有良好模块独立性的软件结构。用来衡量软件模块独立性的定性度量标准有：高内聚、低耦合 5）封装。 封装是将信息隐藏在一个实体中，使其内部细节对外不可见。封装是实现“低耦合、高内聚”的技术手段之一。要进行正确的封装，必须遵守的原则是： 实体间相互隐藏内部实现 尽量减少全局的共享数据 6）接口和实现分离 将接口与实现分离，对外只提供接口，隐藏具体的实现。接口与实现的分离，保证了实现的独立变化，降低了模块间的耦合。 二、三种设计方法 面向过程设计1）面向过程概要设计的主要方法有： 功能模块分解方法 功能模块调用方法 功能模块转化方法 数据流图转换为层次结构图方法 2）面向过程设计技术，采用“自顶向下、逐步求精”的设计方法和“单入口、单出口”的控制结构，并且只包含顺序、选择和循环三种结构，设计目标之一是使程序的控制流程线性化，即程序的动态执行顺序符合静态书写结构。 3）详细设计的工具有：程序流程图、N-S图、程序设计语言PDL、PAD图等 面向对象设计面向对象设计描述工具： 1）系统静态建模图（结构图） 类图 部件图 部件图比类图在更高层次上体现了系统中部件、部件接口以及部件之间的关系。 部署图 表示运行时处理元素（节点）的物理配置情况。 界面图 2）系统动态建模（行为图） 用例图 顺序图 &emsp;&emsp;顺序图是系统的动态视图，表示系统基于时间序列的操作。在顺序图中可以包括与系统交互的角色。顺序图以一个二维视图展现交互过程，垂直方向上是时间轴，水平方向上是参与交互的对象或角色。 &emsp;&emsp;顺序图是类图的补充，类图是系统的静态视图，顺序图反映了系统的动态视图。通常先绘制用例图，接着根据用例图中涉及的实体绘制类图，再绘制顺序图来展现用例的交互过程。 状态图 &emsp;&emsp;状态图是状态机图形化的表现，用于描述用例、部件或类的行为。状态图对实体的有限状态、事件和状态间的转换进行建模。 活动图 &emsp;&emsp;活动图描述的是执行某个功能的活动。 面向元数据设计&emsp;&emsp;面向元数据设计，以实体-关系模型为基础，按照一定的规则将概念模型CDM转换成为能被某种数据库管理系统接受的物理数据模型PDM，创建物理上的数据库表、索引和视图，并且用存储过程和触发器来实现各种业务规则。 三、软件实现 构件：就是被标识的且可被复用的软件制品。 中间件：是一个非常大的组件（构件），一般在网络上运行，完成批量数据的传递和通信工作，调用方式是通过一组事先约定的格式与参数进行的。 软件实现原则 尽可能简单。在软件实现过程中，应创建简单、容易阅读的代码；相同功能的代码只写一次；简单的代码易于维护；通过采用一些编码规范和标准，可以有效地降低代码的复杂度。 易于验证。无论是在编码、测试和实际操作中，软件工程师应该很容易发现其中的错误；自动化的单元测试可产生易于验证的代码；写代码时，要限制使用复杂的难以理解的语言结构 适应变化。外部环境、软件需求和软件设计，在整个开发过程中可能会随时发生变化，因此要求软件实现时考虑适应这些变化 遵守某一编程规范。尽量使用了标准库函数和公共函数。不要随意定义全局变量，尽量使用局部变量。使用括号避免二义性。 选择项目组成员最熟悉的工具或语言。 除此之外，除了特殊要求之外，任何程序必须遵守”可读性第一、效率第二“的实现原则。 四、软件测试在另外的一些文章或资料中有所涉及和详细解释。]]></content>
      <categories>
        <category>软件工程</category>
      </categories>
      <tags>
        <tag>软件设计</tag>
        <tag>软件实现</tag>
        <tag>三层结构</tag>
        <tag>软件设计原理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[软件建模]]></title>
    <url>%2F2019%2F%E8%BD%AF%E4%BB%B6%E5%BB%BA%E6%A8%A1%2F</url>
    <content type="text"><![CDATA[一、三个模型的建模思想 功能模型功能模型，实质上是用户需求模型，用来描述系统能做什么，即对系统的功能、性能、接口和界面进行定义。 从用户角度来看，功能模型就是系统功能需求列表 从设计者的角度看，功能模型就是系统内部功能模块的有机排列和组合 从Rose的角度上看，功能模型就是系统的用例的集合 从产品的角度看，功能模型就是系统的用户操作手册 从操作界面的角度上看，功能模型就是系统的功能菜单 从B/A/S的角度上看，功能模型就对应在浏览层上建模 业务模型业务模型，实质上是业务逻辑模型，用于描述系统在何时、何地、由何角色、按什么业务规则去做、以及做什么的流程或步骤，即对系统的操作流程进行定义。 业务模型反映了系统的业务行为，是算法设计的主要依据。站在B/A/S的角度上看，业务模型就对应在中间层（业务逻辑层或业务应用层）上建模。 数据模型数据模型实质上是实体或类的状态关系模型，用于描述系统工作前的数据来自何处、工作中的数据暂存在什么地方、工作后的数据放到哪儿、以及这些数据的状态及相互之间的关联，即对系统的数据结构进行定义。 二、数据模型设计 什么是好的数据模型？条件有三： 1）满足功能需求 2）满足性能需求 3）该模型能够长期使用，也就是“以不变应万变 数据库的基本表、代码表、中间表和临时表存放元素数据的表，称为基本表 存放信息代码的表，称为代码表 存放统计信息的表，称为中间表（又称查询表） 存放临时数据的表，称为临时表 基本表的4个特性：1）原子性：基本表中的字段是不可再分解的。 2）原始性：基本表中的记录是原始数据记录。 3）演绎性：由基本表与代码表中的数据可以派生出所有的输出数据。 4）稳定性：基本表的结构是相对稳定的，表中的记录需要长期保存。 数据库设计的步骤：1）将原始单据分类整理，理清原始单据与输出数据之间的数据转换关系和算法，澄清一切不确定的问题。 2）从原始单据出发，划分出各个实体，给实体命名，初步分配属性，标识出主键或外键，理清实体之间的关系。 3）进行数据库概念数据模型设计，画出实体关系图ERD，定义完整性约束 4）进行数据库物理数据模型PDM设计，将概念模型CDM转换为物理数据模型PDM 5）在待定对的数据库管理系统上定义表空间，实现物理建表与建索引 6）定义触发器与存储过程 7）定义视图，说明数据库与应用程序之间的关系 8）数据库加载测试：向基表中追加记录，对数据库的功能、性能进行全面测试 9）数据库性能优化：从数据库系统的参数配置、数据库设计的反规范化两个方面，对数据库的性能进行优化 10）数据库设计评审：从数据库的整体功能和性能两个方面，请同行专家评审评价 三、数据库设计理论与方法 数据库范式理论1NF，关系模式中的关系的每个分量都是不可再分的数据项 2NF，满足1NF，且每一非主属性完全函数依赖于候选键 3NF，消除非主属性对候选键的传递依赖 数据库设计中的“第三者插足”设计模式当两个实体之间存在多对关系时，必须在它们之间插入第三个实体，以化解这种多对多关系。 数据库设计中的“列变行”模式就是将第一个表中的某些列，变为第二个表中的某些行。 数据库设计中的四个原子化理论站在数据库设计者的角度看，只要实现属性原子化、实体原子化、主键原子化、联系原子化，数据的所谓更新异常、插入异常、删除异常、数据冗余现象就从根本上消除了。 属性原子化：实体的属性本身不能再分解 实体原子化：实体本身不能再分解 主键原子化：是指实体的主键本身是一个ID（identifier） 联系原子化：是指实体之间的联系都是一对多联系。]]></content>
      <categories>
        <category>软件工程</category>
      </categories>
      <tags>
        <tag>软件建模</tag>
        <tag>功能模型</tag>
        <tag>数据库设计</tag>
        <tag>范式理论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[软件需求分析]]></title>
    <url>%2F2019%2F%E8%BD%AF%E4%BB%B6%E9%9C%80%E6%B1%82%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[写在前面&emsp;需求分析的输入是软件的《合同》或《立项建议书》，以及对用户现场的调研、分析和确认，输出是《用户需求报告》。 一、需求分析是什么？&emsp;在对需求分析进行了解之前，得知道需求分析是什么。 &emsp;需求分析的定义如下： 用户解决问题或达到目标所需的条件或能力 系统或系统部件要满足合同、标准、规范或其他正式文档规定所需具有的条件或能力 一种反映1或2所描述的条件或能力的文档说明 &emsp;我对需求分析的定义时理解是，需求分析中的文档说明起到了至关重要的作用。 &emsp;当然对于一个软件系统来说，前期的需求分析是十分重要的，这几乎可以决定软件系统开发的成败。 二、需求获取的三原则&emsp;所谓需求获取，就是开发者与用户共同提取并共同确认需求。“划分、抽象、投影”是需求获取的三要素。 划分，就是捕获问题空间的“整体/部分”关系。 抽象，就是捕获问题空间的“一般/特殊”或“一般/特例”关系。 投影，就是捕获问题空间的多维”视图“。 &emsp;我对这三原则的理解可能欠妥，但这是我在学习过程中的一些想法。首先，划分，就是将整个系统进行划分，将复杂的系统划分为小系统，这样不仅可以简化系统分析的难度，同时，由于对其进行了划分，所以在需求分析的时候，能够对系统的需求细节进行完善。 &emsp;其次是抽象，对于一个软件系统，能够实现功能的复用性是再好不过了，那么就需要对需求中的“特殊”扩展泛华为“一般”，依次来实现复用。 &emsp;最后是投影，程序的实质是对现实世界的投影，是对现实世界中不同角色工作流程或工作业务的抽象处理，而对于一个系统来说，操作它的可能有三种角色，比如，高层领导，中层管理和基层操作人员。而这三种角色的业务流程和工作业务是不同，需要从三维视图进行分析。 三、需求分析的任务是什么？ 画出目标系统的组织结构图，列出各部门的岗位角色表，即组织机构模型。 画出目标系统的业务操作流程图，即业务模型。 画出目标系统的数据流图，即单据和报表的流图，掌握业务规则，获得初步的数据模型 列出目标系统的功能点列表，即功能模型。 列出系统的性能点列表，即性能模型。 确定目标系统的接口列表，即接口模型 确定目标系统的运行环境，即环境模型 目标系统的界面约定，即界面模型 对目标系统的开发工期、费用、开发进度、系统风险等问题进行分析和评估。 四、面向流程分析&emsp;需求分析是面向流程的，而流程是动态的、实时的。系统的功能、性能、接口、界面都是在流程中反映出来的。在所有的流程中，数据流最为很重要，同时也最具代表性。因为在计算机网络系统中，一切流程都表现为数据流。所以，面向流程分析，实质上是面向数据流程分析或面向数据分析。计算机网络只认识数据，其他所有信息必须转化为数据之后才能流动，所以面向流程分析本质上是面向数据流程分析。 五、需求分析的方法有哪些？&emsp;业界存在三种需求分析方法，分别是：面向功能分析、面向对象分析、面向数据分析。 &emsp;面向功能分析，是将软件需求看做一棵倒置的功能树，树根在上，树枝与树叶在下，每个节点都是一项具体的功能，从上到下，功能由粗到细，树根是总功能，树叶是细功能，整棵树就是一个信息系统的全部功能树。功能分析体现了“自顶向下，逐步求精”的思想，适合于“结构化分析、结构化设计、结构化编程、结构化测试、结构化组装、结构化维护”的传统式软件工程思想。 &emsp;面向对象分析，实质上是面向类分析，它也从系统的基本功能入手，或从与系统有关的人和事入手，将所有的功能需求找出来，然后将每一项功能对应一个对象集（类），分析每个对象集的属性、方法和包装方式，最后归并为相同对象集，删除冗余属性，用类与类之间的关联来表示所有的需求。 &emsp;面向数据分析，是面向元数据和中间数据分析。 六、需求分析的描述工具有哪些？ 面向元数据的需求描述工具 实体关系图 面向过程的需求描述工具 数据流图DFD、数据字典DD 面向对象的需求描述工具 用例图、类图、]]></content>
      <categories>
        <category>软件工程</category>
      </categories>
      <tags>
        <tag>需求分析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[软件生命周期模型]]></title>
    <url>%2F2019%2F%E8%BD%AF%E4%BB%B6%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E6%A8%A1%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[写在前面&emsp;开发一个软件项目，首先要选择并确定一个适合于该项目的软件生命周期模型，然后按照该软件生命周期模型的开发路线图，进行开发。 软件生命周期模型是指在整个软件生命周期中，软件开发过程应遵循的开发路线图。或者说，软件生命周期模型是软件开发全部过程、活动和任务的结构框架。 软件生命周期的9个阶段1）立项（或签订合同）、下达任务书 2）需求分析 3）概要设计 4）详细设计 5）编码实现 6）软件测试 7）软件发布与实施 8）软件维护 9）版本更新或退役 软件生命周期模型有哪些？瀑布模型、增量模型、原型模型、迭代模型、螺旋模型、喷泉模型、XP模型 瀑布模型是什么？具体的详细定义不再展开。 分为5个阶段：需求、设计、编码、测试、发布。自上而下。 首先，我们需要知道，瀑布模型师最早的软件生命周期模型，时至今日，仍然有强大的生命力，也是唯一被广泛使用的软件开发模型。 项目经理或软件管理人员，只要控制好每级台阶的高度和宽度，在每级台阶处设立里程碑或基线，并组织好对基线的评审，就可以控制好项目的开发成本、进度和质量。 但是，该模型的问题就在于阶梯，瀑布只能向下流，需要向上流的时候就需要付出很大的代价。这就是它的“问题堆积”，错误或发散扩大。 该模型的“问题堆积”并不是不可解决的，只要采用适合的管理方法，就可以控制或避免。比如微软公司采用的严格的里程碑管理制度。 增量模型是什么？增量模型是遵循递增方式来进行软件开发的。 在增量模型中，软件产品被看成了一组增量构件或模块。每次需求分析、设计、实现、集成、测试和交付一块构件。 对于一个复杂的大型系统，采用分解的方式来将大系统分解成小系统，这样虽然可以将大风险分解成多个小风险，并逐步消除小风险。但是，将一个复杂的大型系统进行合理、有效的分解和划分是最难的地方。 同时，对大系统进行有效的分解和划分的前提是，该复杂系统可被分解。若复杂系统的拆卸性和组装性不强，那么，增量模型就不再适合该复杂系统的开发。 原型模型原型模型的本意是在初步需求分析后，立马就向用户展示一个软件产品原型。 原型模型开发的过程中始终是以原型来驱动的，这很适合于那些已经有软件产品积累的公司。 但是，画画之前就已经知道画出来的结果是什么了，那么在画的过程中就很难有创新了。对于软件开发也是，这也是原型模型的主要缺点。 迭代模型迭代模型通过对各个工作流程的多次进行，更好地理解需求，从而可以设计出更为强壮的软件构架，逐步提高开发组织能力。 从宏观上看，迭代模型有4个状态阶段，分别是：先启、精化、构建和产品化。 而它的工作流程共有9个，分别是：1）业务建模 2）需求获取 3）分析设计 4）实施 5）测试 6）部署 7）配置与变更管理 8）项目管理 9）环境 在这9个工作流程中，核心流程是业务建模，因为在迭代模型开发之前一定要有一个初始的业务模型，以便对其进行迭代。 螺旋模型螺旋模型将瀑布模型和原型模型结合起来，特别强调风险分析，特别适用于大型复杂系统。 喷泉模型喷泉模型认为，软件开发过程自上而下的各个阶段是相互重叠和多次反复进行的。 喷泉模型有大量的重叠，所以需要大量的开发人员，不利于项目的管理。 XP模型XP模型即极限编程模型。本是敏捷文化现象。 XP模型通过需求、实现、重构、测试、发布的迭代过程，来实现一种轻量级的软件开发模型。 XP的核心要求是：交流、简单、进取、反馈 XP模型作为一种新的模型，在实际运用中存在较多的问题。同时，它与ISO 9001、CMMI的精神也存在冲突。]]></content>
      <categories>
        <category>软件工程</category>
      </categories>
      <tags>
        <tag>软件生命周期</tag>
        <tag>软件生命周期模型</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[软件工程的内容和方法]]></title>
    <url>%2F2019%2F%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E7%9A%84%E5%86%85%E5%AE%B9%E5%92%8C%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[写在前面&emsp;经过一个礼拜的准备，终于结束了软件工程的复习。在复习软件工程的同时也在做信息系统综合设计的课程设计。在做课程设计的过程中，发现了软件工程的重要性和必要性。作为立志成为程序猿的我，软件工程在将来的工作中一定大有用处，故总结如下。 一、软件、软件工程、软件工程学科体系学习软件工程，首先得知道软件是什么。其次，得知道软件工程是做什么的，它研究了什么内容，同时也应该知道软件工程学科体系是什么，与软件工程有什么关系。 软件：最新定义为，软件=知识+程序+数据+文档那么这里面的知识，程序，数据，文档又是指什么呢？ 知识，即各种各样的相关领域的专业知识。 程序，即使对计算机任务的处理对象和处理规则的描述。这里，我们一定要注意，软件并不等于程序，这也是一大误区。 数据，即程序赖以运行的初始化数据。 文档，即为了理解程序所需的详细描述性资料。 软件工程是什么？软件工程是研究软件开发和管理的一门工程学科。 这个定义很短，但是知识点还是挺多的。一强调开发，毕竟开发是软件工程的主体；二强调管理或过程管理，当然，管理是为了更好的开发；三是强调工程，把软件的开发和维护当成一项工程，用工程的办法去开发，按工程的办法去管理；四是强调学科，时至今日，软件工程不只是一门学科，而是一个学科体系。这里也就引出了软件工程学科体系。 软件工程来源于软件危机。软件工程是为了克服软件危机才产生的。 软件工程学科体系 软件工程作为一个学科体系，到21世纪才初步形成。2004年ACM和IEEE-CS联合制订了SWEBOK 2004版，它将软件工程学科体系的知识划分为10个知识域。 对于这10个知识域，我的理解是它覆盖了整个软件生命周期。 1） 软件需求 2）软件设计 3）软件构造 4）软件测试 5）软件维护 6）软件配置管理 7）软件工程管理 8）软件工程过程 9）软件工程工具和方法 10）软件质量 软件工程和软件工程学科体系的关系总体上来说，软件工程是一个局部问题，而软件工程学科体系是一个整体问题。 软件工程研究的内容软件工程研究的内容主要有五个方面。 一是软件生命周期模型 二是软件开发方法 三是软件支持过程 四是软件管理过程 五是软件工程标准与规范 软件工程基本原理软件工程的三要素：方法、工具和过程 有7个基本原理，外加一个二八定律。具体内容见文章末尾的链接。 软件工程在行业中的作用软件工程作为一门工程管理学科，它对软件行业的作用毋庸置疑。那么，这里会有一个问题，既然已经有软件工程了，那么还会不会出现软件危机呢？我的答案是会的。软件工程的产生是为了克服软件危机，但是它的存在并不会完全消除软件危机。这和现实社会中法律存在的意义是相通的。法律的产生是为了消除犯罪，但是法律的存在并不会完全消除犯罪（至少在当前的社会阶段是不会的）。 软件工程可以作用到从业者，也可以作用到项目组，作用到软件公司，甚至作用到整个国家的软件产业1发展。 二、软件工程方法论和软件工程实践论1. 软件工程方法论是什么？软件工程方法论实质上是软件工程中软件开发方法的集合。 那么软件工程方法的集合包括哪些元素呢？ 2. 软件工程方法集合软件工程方法集合包括面向过程方法、面向对象方法、面向元数据方法。 3. 为什么说面向对象方法可以描述无穷的信息世界呢？要搞清楚面向对象为什么可以描述无穷的世界，首先需要知道面向对象方法是什么，其次，需要知道现实世界和软件的普遍联系。 面向对象方法是什么？是一种运用对象、类、消息传递、继承、封装、聚合、多态性等概念构造软件系统的软件开发方法。 我记得高中哲学里面听到的一句话，世界是物质的，物质是运动的，运动是有规律的。而对于软件而言，其实质是对现实人工系统的一种映射、优化和替换。通过对现实世界的分析，我们可以知道，世界是由对象组成的，对象之间时存在普遍联系的，而物质运动则说明了对象的功能。 面向方法是将这现实世界抽象映射为对象的手段。分析设计时由对象抽象出类，程序运行时由类还原到了对象。所以它能够描述无穷的信息世界。 4. 软件工程实践论是什么？软件工程实践论是研究在开发一个大型软件系统时，到底应该怎样选取合适的开发方法。 5. 软件工程实践论指什么？“五个面向”实践论，指面向流程分析、面向元数据设计、面向对象实现、面向功能测试、面向过程管理。 在后面，我们会发现软件工程的“五个面向”实践论在各个软件生命周期模型中都有一定的体现。 三、软件支持过程、软件管理过程 软件过程是什么？软件过程，指软件生命周期中的时间序列 软件支持过程是什么？软件支持过程，由支持软件生命周期模型各个阶段的生产工具组成。 软件生命周期中的生产工具有哪些？CASE工具、软件开发环境SDE、软件工程环境SEE 软件管理是什么？管理过程和支持过程又称为“软件过程工程”。它是软件工程的一部分。 软件管理实质上是过程管理。 软件管理有哪几类？ISO 9001质量管理和质量保证体系 CMMI软件能力成熟度模型 软件企业文化，包括微软企业文化，IBM企业文化，敏捷文化。]]></content>
      <categories>
        <category>软件工程</category>
      </categories>
      <tags>
        <tag>软件工程方法论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[指针，又见指针]]></title>
    <url>%2F2019%2F%E6%8C%87%E9%92%88%EF%BC%8C%E5%8F%88%E8%A7%81%E6%8C%87%E9%92%88%2F</url>
    <content type="text"><![CDATA[一、指针简介一般来说，指针是一个其数值为地址的变量（或更一般地说是一个数据对象）。正如char类型的变量用字符作为其数值，而int类型变量的数值是整数，指针变量的数值表示的是地址。 如果你将某个指针变量命名为ptr，就可以使用如下语句： 1ptr=&amp;pooh; //把pooh的地址赋给ptr 对于这个语句，我们称ptr指向pooh。ptr和&amp;pooh的区别在于前者是变量，后者是常量。ptr可以指向任何地方： 1ptr=&amp;bath; //令ptr指向bath 二、间接运算符假定ptr指向bath：ptr=&amp;bath 这时就可以使用间接运算符*（也称取值运算符）来获取bath中存放的数值。 1val=*ptr; //得到ptr指向的值 语句ptr=&amp;bath；以及语句val=*ptr；放在一起等同于下面的语句： 1val=bath; 下面进行举例： 123nurse=22;ptr=&amp;nurse; //指向nurse的指针val=*ptr; //将ptr指向的值赋给val 上述语句实现的功能是把数值22赋给变量val 三、指针声明例如：long和float两种类型的数值可能使用相同大小的存储空间，但是他们的数据存储方式完全不同，指针的声明形式如下： 123int *pi; //pi是指向一个整数变量的指针char *pc; //pc是指向一个字符变量的指针float *pf,*pg; //pf和pg是指向浮点变量的指针 类型标识符表明了被指向变量的类型，而表示该变量是一个指针。声明int * pi;的意思是pi是一个指针，而且pi是int类型的。 *和指针名之间地空格是可选的。通常程序员在声明中用空格，而在指向变量时将其省略。 pc所指向的值（*pc）是char类型的。而pc本身是什么类型的？ 我们将其描述为“指向char的指针”类型。pc的值是一个地址，在大多数系统中，它是由一个无符号整数表示。但是这并不表示可以把指针当做整数类型。一些处理整数的方法不能用来处理指针，反之亦然。例如，可以进行两整数相乘，而指针不能。因此指针的确是一种新的数据类型，而不是整数类型。 四、使用指针在函数间通信在下面的程序中，函数interchange（）只用了指针参数，我们将对该函数进行详细的讨论。 123456789101112131415161718#include&lt;stdio.h&gt;void interchange(int * u, int * v);int main(void)&#123; int x = 5, y = 10; printf("Originally x=%d and y= %d.\n", x, y); interchange(&amp;x, &amp;y); //向函数传送地址 printf("Now x= %d and y=%d.\n", x, y); return 0;&#125;void interchange(int * u, int * v)&#123; int temp; temp = *u;//temp得到u指向的值。 *u = *v; *v = temp;&#125; 下面我们分析以上程序的运行情况。首先，函数调用语句如下： 1interchange(&amp;x, &amp;y); //向函数传送地址 可以看出，函数传递的是x和y的地址而不是他们的值。这就意味着intechange（）函数原型声明和定义中的形式参数u和v将使用地址作为它们的值。因此他们应该声明为指针，由于x和y都是整数，所以u和v是指向整数的指针。其声明如下： 1void interchange(int * u, int * v); 接下来，函数体进行如下声明： 1int temp; 从而提供了所需要的临时变量。为了把x的值存在temp中，需要使用下面语句： 1temp = *u;//temp得到u指向的值。 注意，因为u的值是&amp;x，所以u指向x的地址，这就以意味着*u代表了x的值，而这正是我们需要的数值。 在示例程序中，我们用一个函数实现x和y的数值交换。首先函数使用x和y的地址作为参数，这使得它可以访问x和y变量。通过使用指针和运算符*，函数可以获得相应存储地址的数据，从而就可以改变这些数据。 在ANSI原型中可以省略变量名称。这样，函数原型可以按如下形式进行声明： 1void interchange (int * ,int *); 通常情况下，可以把关于变量的两类信息传递给一个函数，如果函数的调用形式为： 1function1(x); 这时传递的是x的值，但是如果使用下面这种函数调用形式： 1function2(&amp;x); 那么会把x的地址传递给函数。第一种调用形式要求函数定义部分必须包含一个和x具有相同数据类型的形式参数。如下所示： 1int function1(int num); 而第二种形式要求函数定义部分的形式参数必须是指向相应数据类型的指针： 1int function2(int *ptr); 使用函数进行数据计算等操作时，可以使用第一种调用形式。但是如果需要改变调用函数中的多个变量的值时，就需要使用第二种调用形式。 尽管interchange（）只使用局部变量，但是通过使用指针，该函数可以操作main（）中的变量的值。]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>指针</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[软件工程相关名词解释]]></title>
    <url>%2F2019%2F%E5%B7%A5%E7%A8%8B%E7%9B%B8%E5%85%B3%E5%90%8D%E8%AF%8D%E8%A7%A3%E9%87%8A-1%2F</url>
    <content type="text"><![CDATA[软件： 一般认为，程序是计算机为完成特定任务而执行的指令的有效集合。站在应用的角度可以通俗地理解为： 面向过程的程序=算法+数据结构 面向对象的程序=对象+消息 面向构件的程序=构件+构架 通常，软件有以下定义： 软件=程序+数据+文档 这里的“程序”，是对计算机任务的处理对象和处理规则的描述；这里的“文档”，是为了理解程序所需的详细描述性资料；这里的“数据”，主要是软件系统赖以运行的初始化数据。 软件的最新定义如下： 软件=知识+程序+数据+文档 定义中增加了“知识”。这里的“知识”,主要指各种各样的相关行业领域的专业知识。实际上，知识只是网络的外在表现，程序，数据，文档才是网络的内在实质。也就是说，知识是通过程序、数据、文档来实现的。 对这一定义的另外一种解释是，软件到底是什么呢？软件就是网络，网络就是知识，知识就是信息。站在网民的角度看，软件就是知识加信息。站在程序员角度看，软件就是程序加数据；站在软件管理者角度看，软件就是数据加文档。 网络是知识的载体，知识是网络的灵魂。 软件工程 软件工程是研究软件开发和管理的一门学科。 这里，以是强调开发。开发是软件工程的主体，开发是在规定的时间、按照规定的成本，开发出符合规定质量要求的软件。二是强调管理或过程管理。当然，开发中有管理，管理是为了更好地开发。所以开发和管理是一个问题的相辅相成的两个方面。许多软件项目的失败，不是在开发技术上出了问题，二是在管理过程上出了问题。所以在某种程度上说，对于一个软件企业，过程管理比开发技术更重要。三十强调工程。要将软件的开发（包括维护）当成一项工程，既要按照工程的办法去开发，又要按照工程的办法去管理。四是强调学科。时至今日，软件工程不止是一门课程，而是一个学科体系，即软件工程知识体系。 软件工程学科体系（swebok2004）： 软件工程作为一个学科体系，到21世纪初才初步形成。2001年4月18日，美国发布了软件工程知识体系指南SWEBOK（guide to the Software Engineering body of Knowledge）0.95版。2004年，软件工程学科体系的内容才基本确立，就在这一年，美国ACM和IEEE-CS联合制订了SWEBOK2004版，它将软件工程学科体系的知识划分为如下10个知识域： （1）软件需求：软件需求是真实世界中的问题而必须展示的特性。软件的需求知识域有7个子域：需求基础、需求过程、需求获取、需求分析、需求规格说明、需求确认、实践考虑。 （2）软件设计：软件设计既是定义一个系统的体系结构，组件，接口和其他特征的过程，又是这个过程的结果，软件设计知识域有6个子域：软件设计基础，软件设计关键问题，软件结构与体系结构，软件设计质量的分析与评价，软件设计符号，软件设计的策略与方法。 （3）软件构造：它指通过编码，验证，单元测试，集成测试和排错的组合，具体创建一个可以工作的，有意义的软件。其知识域有3个子域：软件构造基础，管理构造，实际考虑 （4）软件测试：它由在有限测试用例集合上，根据期望的行为对程序的行为进行的动态验证组成，测试用例是从实际上无限的执行域中适当选择出来的。软件测试知识域有5个子域：软件测试基础和测试级别，测试技术，需求分析，与测试相关的度量，测试过程。 （5）软件维护：软件一旦投入运行，就可能出现异常，运行环境可能发生改变，用户会提出新的需求。生命周期中的软件维护，从软件交付时开始。软件维护的知识域有4个子域：软件维护基础，软件维护的关键问题，维护过程，维护技术。 （6）软件配置管理：软件配置是为了系统地控制配置的变更，维护软件在整个系统生命周期中的完整性及可追踪性，而标志软件在不同时间点上的配置的学科。软件配置管理知识域有6个子域：软件配置管理过程管理，软件配置标志，软件配置控制，软件配置状态统计，软件配置审核，软件发行管理和交付。 （7）软件工程管理：进行软件工程的管理与度量，虽然度量是所有知识域的一个重要方面，但是这里所说的是度量程序的主体。软件工程管理只是域有6个子域：启动和范围定义，软件项目计划，软件项目实施，评审与评价，关闭，软件工程度量。前5个覆盖软件过程工程管理，第6个描述软件度量的程序。 （8）软件工程过程：涉及软件工程过程本身的定义、实现、评定、度量、管理、变更和改进。软件工程过程知识域有4个子域：过程实施与改变、过程定义、过程评定、过程和产品度量。 （9）软件工程工具和方法：它具有软件工程工具、软件工程方法两个子域。 （10）软件质量：处理跨域整个软件生命周期过程的软件质量的考虑，由于软件质量问题在软件工程中无处不在，其他知识领域也涉及到质量问题。软件质量知识域有3个子域：软件质量基础，软件质量过程、时间考虑。 在上述软件工程学科体系中前5个知识域是讲软件开发，后5个知识域是讲软件管理。由此可见，软件工程知识体系包括软件开发和软件管理两大部分，所以软件工程的定义也应该包括软件开发和软件管理两项内容。 软件工程课程 软件工程课程与软件工程学科体系是有区别的：前者是一门或一组课程，后者是一个知识体系；前者是一个局部问题，后者是一个整体问题。 作为一门软件工程客户才能，它研究的内容至今没有统一的说法。可以这么认为，软件工程课程研究的内容应该涵盖“软件生命周期模型、软件开发方法、软件支持过程、软件管理过程、软件工程标准与规范”这5个方面。 序号 研究方向 具体内容 1 软件生命周期模型 如：瀑布模型，增量模型 2 软件开发方法 如：面向过程的方法 3 软件支持过程 如：CASE工具ROSE，北大青鸟系统，Power Designer 4 软件管理过程 如：CMMI，软件企业文化，敏捷（XP）文化现象 5 软件工程标准与规范 如：命名标准与规范，设计标准与规范，编程标准与规范 尽管软件生命周期模型和软件支持过程非常重要，但是现代软件工程研究的重点，仍然是软件开发方法和软件管理过程。在软件管理过程的内容中，除了ISO9001的CMMI之外，还将软件企业文化也列入其中，如微软企业文化，敏捷文化现象和IBM企业文化。 软件工程标准是对软件产品的约束，如软件产品的界面标准，包装标准，文档标准，测试标准，评审标准，鉴定标准等。软件工程规范是对软件开发人员行为的约束，例如命名规范，需求规范，设计规范，编码规范，维护规范等。在软件企业内部，企业管理人员特别重视软件工程的标准与规范。为此，每个大型的软件企业，根据自身的特点，都制订并发布了自己的软件工程标准与规范，在自己企业内部严格执行。 软件工程基本原理 习惯上，人们常常把软件工程方法（开发方法）、工具（支持方法的工具）、过程（管理过程）称为软件工程三要素，而把美国著名的软件工程专家B.W Boehm于1983年提出的7条原理作为软件工程的基本原理。 （1） 用分阶段的生命周期计划严格管理软件开发。阶段划分为计划、分析、设计、编程、测试和运行维护。 （2） 坚持进行阶段评审。若上一阶段评审不通过，则不能进入下一阶段开发 （3） 实行严格的产品版本控制 （4） 采用现代程序设计技术 （5） 结果应能清楚地审查。因此，对文档要有严格的要求 （6） 开发小组的成员要少而精 （7） 要不断地改进软件工程实践的经验和技术，要与时俱进 上述7条原理，虽然是在面向过程设计时代（结构化时代）提出的，但是，直到今天，在面向元数据和面向对象的程序设计新时代，它仍有效。根据“与时俱进”的原则，还有一条基本原理在软件的开发和管理中特别重要，需要补充进去，作为软件工程的第8条基本原理。 （8） 二八定律 在软件工程中，所谓二八定律，就是一般人常常将20%的东西误认为80%的东西，而将80%的东西误认为是20%的东西。 例如，对软件项目进度和工作量的估计：一般人主观上认为已经完成了80%，但实际上只完成了20%；对于程序中存在问题的估计，：一般人不知道80%的问题存在于20%的程序之中；对模块功能的估计：一般人不知道20%的模块，实现了80%的功能；对人力资源的估计：一般人不知道20%的人，解决了程序中80%的问题；对投入资金的估计：一般人不知道信息系统中80%的问题，可以用20%的资金来解决。 研究二八定律的现实意义是，指导软件计划的制订与执行。 软件生命周期模型 软件生命周期模型时指在整个软件生命周期中，软件开发过程应该遵循的开发路线图。或者说，软件生命周期模型是软件开发全部过程、活动和任务的结构框架。 例如：瀑布模型、增量模型、螺旋模型、喷泉模型、XP模型、原型模型和RUP迭代模型，它们都有各自清晰的开发路线图，规定了各自的开发过程、活动和任务的结构框架。 从字面上理解，“软件生命周期”应该涵盖软件产品、项目或系统从产生、投入使用看到被淘汰的全过程。由于早期人们关注的是技术开发活动，还没有考虑到管理活动，因此“软件生命周期模型”主要描述的还是软件开发的过程及其任务。 与人不同的是，软件的生命周期和软件生命周期模型有关：不同的软件生命周期模型，可能对应着不同的生命周期。生命周期不同，该软件的开发阶段划分、评审次数、基线标准都有所不同。软件公司的项目组在开发一个大项目或产品时，首先在技术上必须选择一个软件生命周期模型，使该模型非常适合这个项目或产品的生命周期模型；随后通过对软件生命周期模型的裁剪，给出适用于本项目或产品的软件生命周期定义；以生命周期定义为标准，在需求定义之后，编制详细的软件开发计划；然后项目组按计划进行软件开发，软件工程管理部门按计划进行软件过程跟踪和管理。 软件生命周期模型能清晰、直观地表达软件开发全过程，明确规定了要完成的主要活动和任务，用来作为软件项目工作的基础。一般以时间为序，软件生命周期模型可详细地划分为9个阶段。 序号 周期名称 序号 周期名称 1 立项（或签合同）、下达任务书 6 软件测试 2 需求分析 7 软件发布与实施 3 概要设计 8 软件维护 4 详细设计 9 版本更新或退役 5 编码实现 软件开发方法是指在软件工程开发路线图中，开发人员对软件需求、设计、实现、维护所采用的开发思想开发技术、描述方法、支持工具等。 软件工程中软件开发方法的集合，称为软件工程方法论。 迭代模型及其9个核心流程 针对瀑布模型的缺陷，人们提出了迭代模型。 所谓迭代，是指活动的多次重复。从这个意义法伤来讲，原型不断完善，增量不断产生，都是迭代的过程。因此，快速原型法和增量模型都可以看成局部迭代模型。但这里所讲的迭代模型时RUP推出的一种“逐步求精”的面向对象的软件开发过程模型，被认为是软件界迄今为止最完善、可实现商品化的开发过程模型。 RUP模型的原型图看起来非常简单，其内涵却非常丰富。它表面上是一个二维图，实质上用一张二维图表示了一个多维空间模型。从宏观上看，它是一个大的迭代过程；横坐标表示软件产品所处的4个阶段：先启、精化、构建、产品化（移交），纵坐标表示软件产品在每个阶段的工作流程。从微观上看，任何一个阶段本身，其内部工作流程也是一个小的迭代过程。 为使项目能够顺利地进行，一种较灵活（并且风险更小）的方法是：多次执行各个开发工作流程，从饿了更好地理解需求，设计出更为强壮的软件架构，逐步提高开发组织能力，最终交付一系列逐步完善的实施成果，这就是迭代生命周期模型。每次按顺序完成一系列工作流程就称为一次迭代，每次迭代，均以次要里程碑结束，按照特定的迭代成功标准，对迭代的结果进行评估。每个阶段都可以进一步细分为迭代。迭代是产生可执行的产品发布（内部或外部的）的完整开发循环，所发布的产品是开发过程最终产品的子集，它将通过一次又一次的迭代实现递增成长，最后形成最终的软件系统或产品。 优点： n 在开发的早期或中期，用户需求可以变化； n 在迭代之初，不要求有一个相近的产品原型 n 模型的适用范围很广，几乎适用于所有项目的开发 缺点：传统的组织方法是按顺序（一次且仅一次）完成每个工作流程，即瀑布式生命模型。迭代模型采取循环工作方式，每次循环均使工作产品更靠近目标产品，这要求项目组成员具有很高的水平并掌握先进的开发工具。反之，存在较大的技术和技能风险。 模型的9个核心流程： 迭代声明周期模型包含9个核心流程（需要指出的，采用迭代模型，事先要有一个初始业务模型，以便进行迭代。这就是为什么将“业务建模”作为9个核心流程之首的道理）。 （1） 业务建模：目的是， 了解目标组织的结构和机制；了解目标组织中当前存在的问题，并确定改进的可能性；确保客户、最终用户和开发人员就目标组织达成共识；导出支持目标组织所需的系统需求。通俗地讲，业务建模就是用户业务流程的重新规划与合理改进，即业务流程的优化，目的是使开发出来的系统能反映最优化的业务流程。 （2） 需求获取：目的是，与客户在系统的工作内容方面达成并保持一致；使系统开发人员能够更清楚地了解系统需求；定义系统边界；为计划迭代的内容提供基础；为估算开发系统所需成本和时间提供基础；定义系统的用户界面，重点是用户的需要和目标。 （3） 分析设计：目的是，将需求转换为未来系统的设计；逐步开发强壮的系统构架；使设计适合实施环境，为提高性能而进行设计。 （4） 实施：目的是，对照实施子系统的分层结构定义代码结构；以构件（源文件，二进制文件，可执行文件以及其他文件等）方式实施类和对象；对已开发的构件按单元进行测试；将各实施成员（或团队）完成的结果集成到可执行系统中。 （5） 测试：目的是，核实对象之间的交互；核实软件的所有构件是否正确集成；核实所有需求是否已经正确实施；确定缺陷并确保在部署软件之前将缺陷解决。 （6） 部署：目的是，将构件部署到网络的各个节点上，使最终用户可以使用该软件产品。 （7） 配置与变更管理，目的是，始终保持工作产品的完整性和一致性 （8） 项目管理：目的是，为软件密集型项目的管理提供框架；为项目计划，人员配备，执行和检测提供实用准则；为风险管理提供框架。 （9） 环境：目的是，为软件开发组织提供软件开发环境（流程和工具），该环境将支持开发团队。 XP模型 XP模型，即极限编程模型，它本来是敏捷企业文化现象，但是不少人将它当成一种软件开发模型。 对传统软件开发模型进行重新审视发现，它们太正规、太呆板、太浪费资源，从而提出了省时省力的XP模型。它属于轻量级开发模型，由一组简单规则（需求、实现、重构、测试、发布）组成，它既保持开发人员的自由创造性，又保持对需求变动的适应性，即使在开发的后期，也不怕用户需求的变更。 在需求、实现、重构、测试、发布的迭代过程中，XP模型有4条核心原则：交流、简单、反馈和进取。XP开发小组包括开发人员、管理人员和客户。 优点： l 采用简单策略，不需要长时间计划和复杂管理，开发周期短 l 采用迭代增量开发，反馈修正和反复测试的方法，因而软件质量有保证。 l 适应用户需求变化，因而与用户关系和谐。 缺点： XP模型作为一种新的模型，在实际应用中还存在一些问题，引起了一些争议。它一般适用于小型项目，同时，它与ISO9001、CMMI的精神也存在冲突。 订单软件 与固定的用户签订软件开发合同，由软件公司启动该项目的开发，这类软件被称为“订单软件”，典型的例子有企业资源规划系统ERP和电子商务大型网站。 非订单软件 市场调研之后，认为某产品将会有巨大的市场空间，而软件公司在人力资源、设备资源、抵抗风险、资金和时间上都具备开发该产品的能力，于是决定立项，这类软件被称为“非订单软件”，典型的例子是网上游戏软件 任务书 有一份《任务书》的正文。包括任务下达的对象、内容、要求完成的日期、决定投入的资源、必要时包括任命项目经理（技术经理和产品经理）、其他保证措施、奖惩措施等。《任务书》正文可长可短，若《合同》或《立项建议书》很详细，则正文可短，若《合同》或《立项建议书》很粗很短，则正文应该很长、很详细。 有一份《任务书》的附件。一般情况下，它就是软件《合同》/《立项建议书》，如果是指令性计划，它的格式和内容，也应与《合同》/《立项建议书》基本相同，即附件的内容应覆盖系统的功能点列表、接口列表、资源需求列表、开发进度列表、阶段评审列表等。 《任务书》与《合同》/《立项建议书》一样重要，它是该项目的第二份管理文档。 合同 对于一些大型项目，在签订合同之前，一般有一个招标和投标的过程，只有中标之后才能签订合同。开发“非订单软件”需要“立项”，开发“订单软件”需要签订“合同”。所以“立项”与“合同”是IT企业软件项目（或产品）的两个源头。一旦立项或签订合同，企业领导或软件管理部门就要下达《任务书》，开发部门接到《任务书》后就要组建开发团队，成立项目组。 立项建议书 立项文档就是《立项建议书》，它本身不是软件策划的内容，但是很重要，也很特殊。《立项建议书》的目的，就是在某种程度上代替开发合同或用户需求报告，作为软件策划的基础。《立项建议书》的编制者一般不是软件开发人员，而是软件公司的市场销售人员，因为他们熟悉市场行情及客户需求 需求分析 1997年，IEEE软件工程标准词汇表中定义的需求为： （1） 用户解决问题或达到目标所需的条件或能力 （2） 系统或系统部件要满足合同、标准、规范或其他正式规定文档所具有的条件或能力 （3） 一般反映（1）或（2）所描述的条件或能力的文档说明 一般而言，需求分析阶段位于软件开发的前期，它的基本任务是准确地定义未来系统的目标，确定为了满足用户的需要系统必须做什么。 需求分析分为两个阶段：需求获取阶段和需求规约阶段。需求关系的是系统的目标而不是系统实现。 需求可以分为两类：功能性需求和非功能性需求。前者定义了系统做什么，后者定义了系统工作时的特性。 基线 基线是软件工作产品，它是要经内部和外部评审过的，是下一阶段工作的基础。 审计 审计，是复查评审活动程序的合法性，是否按程序与规范进行等 里程碑 里程碑是一个标记，只需要经过内部评审。一个里程碑是一个检查点，但不一定对应一条基线 定义软件过程 所谓定义软件过程，就是根据选定的生命周期模型，规定软件的开发1模型，以及每一阶段的工作步骤和文档标准等内容。 在项目策划阶段，先要根据项目特性，使用软件生命周期模型，对项目中将要进行的软件工程过程进行描述。根据项目自身的特点，对项目的类型进行详细划分，然后根据软件组织的“生命周期模型裁剪指南”，对标准软件过程进行裁剪，形成项目定义软件过程。再使用项目定义软件过程，指导项目策划活动的进行。 开发计划是对项目定义软件过程的具体描述。软件项目的规模、工作量、成本、进度、质量、人员配置和其他资源等，与项目定义软件过程中的活动紧密相关。由于项目定义软件过程的标准，全部由“生命周期模型裁剪指南”而得到，因此软件项目能共享过程数据，并且吸取软件组织中积累的经验教训。 LOC LOC（line of code），LOC指所有的可执行源代码行数。包括可交付的工作控制语言（job control language，JCL）语句，数据定义，数据类型声明，等价声明，输入/输出格式声明等。一代码行（1LOC）的价值和人月均代码行数可以体现一个软件生产组织的生产能力。组织可以根据对历史项目的审计来核算组织的单行代码价值。 功能模型 （Function Model, FM）。实质上是用户需求模型，用来描述系统能做什么，即对系统的功能，性能，接口和界面进行定义。 业务模型 （Operation Model，OM），实质上是业务逻辑模型，用于描述系统在何时，何地、由何角色、按什么业务规则去做，以及做的步骤或流程，即对系统的操作流程进行定义。 数据模型 （Data Model, DM）,实质上是实体或类的状态关系模型，用于描述系统工作前的数据来自何处，工作中的数据暂存在什么地方，工作后的数据放到何处，以及这些数据的状态以及相互之间的关联，即对系统的数据结构进行定义。 风险分析 软件策划过程，也包括对软件风险进行分析。所谓软件风险分析，指对项目及团队的政策风险、技术风险、技能风险、资源风险等因素，进行逐个分析与分解，将一个大风险分解为若干个小风险，对各个小风险进行排除，最后制订跟踪和监控风险的风险管理计划。软件一般存在5种风险，如下表： 序号 风险名称 风险内容 1 政策风险 IT企业外部和IT企业内部两个方面的政策及政策的变化，将会给项目带来什么风险 2 技术风险 新技术的成熟程度以及难度系数，将会给项目带来什么风险 3 技能风险 项目组成员学习、领会、掌握、运用新技术的能力，将会给项目带来什么风险 4 资源风险 保证项目正常进行所需的各种资源的供应程度，将会给项目带来什么风险 5 其他风险 目前意想不到的风险，即不可预测的风险，如天灾人祸 三层结构设计 三层结构设计通常被划分为表示层、中间层和数据层三层，各个分层之间通过对外接口互相访问。分层的主要目的是，允许各层可以随着需求的变化或技术的变化而独立地升级或替换，如当替换数据库时，只需要变化数据层。 所谓的三层结构，就是在原来两层结构（Client/Server）的客户层和数据层之间，加入一个中间层（也叫业务层），并将应用程序的业务规则、数据访问、合法型校验等工作放到了中间层进行处理，这样就变成了三层结构，也不仅仅有B/S应用才是三层结构，三层是指逻辑上的三层，即使这三层都放置到了一台机器上。当然，这三层也可以放在两台或三台机器上。 （1） 表示层（浏览层） 表示层也称为浏览层，它通常采用图形化用户界面，在客户端PC或工作站上运行。站在“三个模型”建模思想上看，系统内部支持表示层的模型是“功能模型”，尽管“功能模型”中的功能思想组件放在业务层，但是功能组件的表现方式却在表示层上。该层的主要功能是： ​ 1）接受用户请求，将这些请求反馈给业务逻辑层，等待业务逻辑层的应答信息 12） 对业务逻辑层的应答信息，进行显示（不进行任何加工） ​ 3） 有时也会兼做业务逻辑层的一些小功能，比如对用户输入数据的验证，以及操作合法性的检验 （2） 中间层（业务层） 中间层也称业务层，有时又称为应用层，它由许多构建或组件组成，它们完全体现了用户的业务逻辑或业务规则。站在“三个模型”建模思想看，系统内部支持业务层的模型是“业务模型”。尽管Java EE与.NET在实现业务层上的方法略有差异，但是，业务层本质上在表示层与数据层之间起桥梁作用。有时，业务层被划分为两个子层：业务逻辑层和数据访问层。业务层的主要功能是： ​ 1） 接受从表示层传来的用户请求信息 ​ 2） 根据用户的请求信息生成SQL语句 ​ 3） 利用生成的SQL语句从数据层取数据、修改数据、删除数据 ​ 4） 将结果返回给表示层 （3） 数据层 数据层是数据库服务器上的数据库层，它包括数据库管理系统DBMS和数据库DB两部分。站在“三个模型”建模思想看，系统内部支持数据层的模型是“数据模型”，该层的主要功能是： ​ 1）接受业务层数据处理请求的SQL语句或存储过程 ​ 2） 利用SQL语句或存储过程，对数据库服务器上数据库的相关表进行存储或检索 ​ 3） 将存储或检索的结果信息，传递给业务层 构件 所谓构件，就是被标识的且可被复用的软件制品。 构件与部件，组件基本上是一个意思，有时会认为部件和组件的粒度比构件大一些或范围更广一些。上述定义有三个特点：第一个特点是构件要被明确标识，即有一个被调用的名字；第二个特点是应该可服用，不可复用的只能称为模块或子系统，第三个特点是构件是软件制品，在宏观上软件制品可以是项目计划、成本估价、体系结构、需求模型、设计模型、程序代码、窗口界面、文档、数据结构、测试用例等。 中间件 中间件是一个非常大的组件（构件），一般在网络上运行，完成批量数据的传递和通信工作，调用方式是通过一组事先约定的格式与参数进行的。常见的中间件为问价传输中间件，如IBM公司的消息队列中间件MQ，在网络节点之间进行点对点的数据通信和传输。又如城市医疗保险系统中的中间件，它在市医保局节点和全市各家医院节点之间，进行点对点的数据通信和传输，病号每次划价计费，节点之间就交换一次信息。在详细设计说明书中已对新增中间件的功能和算法进行了详述，此处只要将详细设计翻译为源程序即可。 结对编程 在敏捷方法中，成对（或结对）编程时极限编程的实践之一。当进行成对编程时每一个程序员输入代码，另一个在旁边观察代码中是否存在错误，并思考下一步要进行的工作。 优点： 1） 可以提高代码的可读性和可理解性，产生高质量的代码 2） 提高编程效率，使编程速度更快，代码错误更少，后期测试和纠错的工作量就会大大降低 3） 成对编程可以提高开发团队的凝聚力和协作精神 规则： 1） 编码标准 2） 积极参与 3） 非强制性 4） 定期轮换 5） 速度匹配 6） 新老匹配 软件测试 软件测试按照规定的测试规程发现软件缺陷的问题。 为了理解这个定义，有如下解释： 1） 软件测试是一个过程，而且是一个发现软件缺陷，但不包括修复软件缺陷的过程。 2) 软件测试是按照规定的测试规程进行。这些规程包括制定测试计划，搭建测试环境，明确测试任务，规定测试时间、方法和步骤，记录测试数据和产生测试报告 3) 在测试规程中，测试计划最为重要，它指导整个测试计划 4) 在测试计划中，测试需求的定义很重要。如果没有列出明确的测试需求，那么就并不会设计出正确的测试用例，最后必然导致盲目的测试。这样，隐藏的软件缺陷也无法被发现。 5) 软件测试的目的是发现软件缺陷，软件测试的目标是尽可能早地发现软件缺陷，因为缺陷发现越早，其修复成本越低。 软件测试不仅仅局限于测试程序代码，还可以测试软件数据与软件文档。也就是说，软件生命周期中所产生的软件工作产品，都可以作为测试对象，因为它们影响最终软件产品的质量。 软件缺陷 定义如下： 软件未实现产品说明书要求的功能。 软件出现产品说明书指明不应该出现的错误 软件实现了产品说明书未说明的功能 软件未实现产品说明书虽未明确提及但应该实现的目标 软件难以理解，不易使用，运行速度慢，或者软件测员，最终用户认为软件不好。 由于不同的理解方式和中英文翻译问题，软件缺陷的说法很多，如错误、失效、失败等，本书中统称为软件缺陷（bug）。实际测试中，将软件缺陷定义为不同级别，代表不同程度的软件缺陷。 随着软件定义的变化，软件缺陷的定义也应随之更新。软件缺陷不仅仅局限于软件代码，还包括文档缺陷（不符合规范或者不详细，有错误和歧义等）、测试缺陷（测试不充分，或测试方法本身的局限）、过程缺陷（软件生命周期的流程问题造成的产品质量问题）和管理缺陷（由于管理本身不到位导致的产品质量问题）。 软件测试的V模型 早期的软件测试V模型 模型的左侧是开发阶段，右侧是测试阶段。开发阶段从了解并定义软件需求开始，然后要把需求转换到概要设计和详细设计，最后形成程序代码。测试阶段是在代码编写完成之后，先做单元测试，然后做集成测试、系统测试和验收测试。 单元测试：主要检测代码的编写是否符合详细设计中单个模块或组件的要求 集成测试：主要检测此前测试过的单个模块或组件，能否正确地集成到系统，与其他模块一起运行，是否符合概要设计和详细设计说明书的要求。 系统测试：以集成后的完整系统作为测试对象，主要检测其是否符合需求说明书、概要设计说明书和详细设计说明书的要求。 验收测试：主要检测软件产品是否符合用户需求，用户合同和需求说明书中的要求，需要得到用户认可并签字确认。 改进后的V模型： 改进后的V模型，一是加入软件测试分析和测试设计阶段，二是体现“尽早”思想。改进后的V模型，形成了一个没有软件开发过程的、单独的软件测试V模型。它的左边是软件测试需求分析和测试设计，右边是软件测试执行。虽然测试执行过程同样集中在软件编码之后，但是测试需求分析和测试设计已经提前，一直提前到与开发阶段并行开展。一方面可以为后期的测试执行过程做计划和准备，另一方面可以对软件的阶段性产品（软件工作产品）进行测试。前期的软件工作产品主要是文档，如测试需求分析阶段，就是测试软件需求分析过程的工作产品《需求规格说明书》，进而提炼出测试需求。 黑盒测试 黑盒测试又称为不透明盒测试，它给我们的更多启示是它的思考方式，即不考虑（主观上屏蔽）或者不需要（客观条件限制）知道被测对象的内部实现细节，只关心输入输出。在运用黑盒测试方法进行软件测试时，它并不关心软件的内部逻辑结构和实现方法，而是站在使用者的角度，主要测试软件的功能指标，即测试系统的功能模型。黑盒测试的依据是软件的行为描述，是面向功能的穷举输入测试。从理论上讲，只有把所有可能的行为都作为测试用例输入，才能完成黑盒测试工作。黑盒测试的对象可以是软件单元、软件模块、软件组件、软件子系统和软件系统，也可以是发散思维到软件文档，软件管理文档等软件生命周期中的任何可测试对象。 黑盒测试用例设计方法： （1） 等价类划分法 （2） 边界值分析法 （3） 错误推测法 （4） 因果图分析法 （5） 场景分析法 白盒测试 白盒测试又称为透明盒测试，要求测试人员必须清楚被测对象的内部实现细节。白盒测试方法的测定依据是《详细设计说明书》。理论上讲，面向程序执行路径进行穷举代码测试，直至覆盖所有路径，才算完成了白盒测试。白盒测试的测试对象，侧重于软件单元，模块和构件等小规模对象，绝对不适合软件项目或产品的等大规模测试对象。 实用的白盒测试覆盖技术有4种，即语句覆盖，条件覆盖，分支覆盖和组合覆盖。覆盖的主要思想，是从不同角度尽可能提高代码的测试覆盖率。为了减少测试工作量，应该使每一个测试用例满足多个覆盖条件。 等价类 等价类划分的具体做法是：把所有可能的输入数据，即软件的输入域，划分成若干部分（子集），使每部分内的数据都是等效的（对于软件而言，等效可以理解为对数据的处理过程以及处理结果都完全一致），然后从每一个子集中选取少数具有代表性的数据，作为测试用例。 每一个等价类又可以划分为两种不同类别：有效等价类和无效等价类。 边界值 边界值分析方法是对等价类划分方法的补充。 测试工作者已经总结出经验：大量的错误常常发生在输入或输出范围的边界上，因此针对各种边界情况设计测试用例，可以查出更多的错误。 使用边界值分析方法设计测试用例使，首先参考等价类划分法确定边界情况，除了在等价类中选取典型代表数据外，通常还要着重测试边界值情况，应当选取正好等于、刚刚大于、或刚刚小于边界的值作为测试数据。 测试需求 它指软件测试员站在与用户相同角度上理解的需求，主要是确保需求的可测试性。同时找出软件需求和用户需求的偏差，并确保认可的偏差修改后体现在软件需求中，因为测试工作以《软件需求说明书》为基准，测试人员需要尽量保证《软件需求说明书》可以满足测试工作。 Bug 即软件缺陷，如错误，失效，失败等。 CMMI 软件能力成熟度模型CMMI，是由美国卡内基-梅隆大学软件工程研究所退出的评估软件能力与成熟度等级的一套标准。该标准基于众多软件专家的实践经验，侧重于软件开发过程管理能力的提高，是软件生产过程改进的标准和软件企业成熟度等级评估的标准。由于该标准不涉及具体的软件开发方法和技术，所以它具有广泛性、通用性和持久性。 CMMI的作用：概括地讲，过程能力成熟度模型集成CMMI的作用，主要是软件组织的能力评估和过程改进，它的应用领域具体体现在三个方面： 软件组织，用它来不断改进自身的软件过程管理能力 评估机构，用它来评估某软件组织当前软件能力成熟度级别 客户，用它来评价某承包商（软件外包商）的软件能力 CMMI的实质： 为了真正达到持续改进软件过程能力的目的，并以尽量低的成本获得高的效益，首先要弄清楚“过程”、“项目”、“组织”、“度量”等五个基本概念。 以“过程”为核心，抓软件组织的管理，即软件“组织”的过程改进 以“项目”为手段，抓团队开发过程的“活动”，即落实过程改进的措施 以“活动”记录为基础，抓软件过程的“度量”，即“度量”软件组织改进的情况 软件配置管理 软件配置管理SCM，是对软件开发过程中配置项的一组追踪和控制活动，它开始于软件开发之初，结束于软件淘汰之时。软件配置管理在软件过程管理中，占有特殊得到地位，也是项目管理的重要内容。无论是ISO9001、CMMI，还是软件企业文化，都非常强调配置管理。在大中型软件企业内部设置专职的配置管理员，在各个项目组内部设置兼职的配置管理员，引进配置管理电子工具，开展配置管理的日常工作。 CMMI阶段的成熟度等级 阶段模型的5个等级，称为成熟度等级ML，从ML1级到ML5级。 CMMI的等级 PA数目 管理特点 ML1:Initial（初始级） 0 过程不可预测且缺乏控制 ML2：Managed（已管理级） 7 过程为项目服务，即项目级管理 ML3：Defined（以定义级） 11 过程为组织服务，即组织级管理 ML4:Quantitatively Managed(定量管理级) 2 过程已度量和控制，即定量级管理 ML5：Optimizing（优化级） 2 集中于过程改进，即优化级管理 极限编程 极限编程（即XP）是一个周密而严谨的软件开发流程。XP从4个基本方面对软件项目进行改善：交流、简单、反馈和进取。 XP程序员与客户交流、与同事交流； 他们的设计简单而干净； 他们通过测试来得到反馈； 他们根据变化修改代码，并争取尽可能早地将软件交付给客户。 在此基础上，XP程序员能够勇于面对需求变化和技术变化，“船小好调头”，对需求变化和技术变化做出敏捷反应，把那个取得成功，是敏捷文化的特色和本质。 软件质量管理的三大支柱 软件质量保证SQA是一个过程，是CMMI和ISO9001的重要议题，是微软公司和IBM公司的重点课题，同样也是项目管理的重要内容。 软件质量：是供方提供的软件产品满足用户明确和隐含需求的能力特性的总和。 通常，人们将“质量标准”、“配置管理”、“质量测试”作为质量管理的三大支柱。 而将”SQA计划”、“SQA进度”、“SQA评审和审计”作为质量管理三大要素。 软件质量保证是一个质量管理过程，基本思想是“以事先预防为主，以事后纠偏为辅”，采取标本兼治的方法。]]></content>
      <categories>
        <category>软件工程</category>
      </categories>
      <tags>
        <tag>软件工程名词解释</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机网络体系结构]]></title>
    <url>%2F2019%2F%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%2F</url>
    <content type="text"><![CDATA[一、计算机网络分层结构两个系统中实体间的通信是一个很复杂的过程，为了降低协议设计和调试过程的复杂性，也为了便于对网络进行研究、实现和维护，促进标准化工作，通常对及时算计网络的体系结构以分层的形式进行建模。 我们将计算机网络的各层及其协议的集合称为网络的体系结构。 网络设计者以分层的方式组织协议以及实现这些协议的网络硬件和软件，每个协议就属于这些层次之一。某层向它的上一层提供服务，即所谓每一层的服务模型。例如，第n层提供的服务可能包括报文从网络的一边到另一边的可靠传送。这可能是通过使用第n-1层的边缘到边缘的不可靠报文传送，加上第n层的检测和重传丢失报文的功能来实现的。 计算机网络的体系结构通常都具有可分层的特性，它将复杂的大系统分为若干个较容易实现的层次。分层的基本原则如下： 每次都实现一种相对独立的功能，降低大系统的复杂度 各层之间界面自然清晰，易于理解，相互交流尽可能少 各层功能的精确定义独立于具体的实现方法，可以采用合适的技术来实现 整个分层结构应该促进标准化工作 在计算机网路的分层结构中，第n层中的活动元素通常被称为n层实体。具体来说，实体指任何可发送或接受信息的硬件或软件进程，通常是一个特定的软件模块。不同机器上的同一层称为对等层，同一层的实体称为对等实体。 在计算机网络体系结构的各个层次中，每个报文都分为两部分：一是数据部分，即SDU；二是控制信息部分，即PCI，它们共同组成PDU。 服务数据单元（SDU）：为完成用户所要求的功能而应传送的是数据。第n层的服务数据单元记为n-SDU。 协议控制信息（PCI）：控制协议操作的信息。第n层的协议控制信息记为n-PCI。 协议数据单元（PDU）：对等层次之间传送的数据单位称为该层的PDU。第n层的协议数据记为n-PDU。在实际的网络中，每层的协议数据单元都有一个通俗的名称，如物理层的PDU称为比特，链路层的PDU称为帧，网络层的PDU称为分组，传输层的PDU称为报文。 在各层间传输数据时，把从第n+1层收到的PDU作为第n层的SDU，加上第n层的PCI，变成了第n层的PDU，交给第n-1层后作为SDU发送，接收方接收时做相反处理。故可知三者的关系是n-SDU+n-PCI=n-PDU=(n-1)-SDU. 二、协议、接口、服务 协议 协议，就是规则的集合。在网络中要做到有条不紊地交换数据，就必须遵循一些事先约定好的规则，这些规则明规定了所交换的数据的格式及有关的同步问题。这些为进行网络中的数据交换而建立的规则、标准或约定称为网络协议。它是控制两个（或多个）对等实体进行通信的规则的集合，是水平的。不对等的实体之间没有协议。 接口 接口是同一结点内相邻两层之间交换信息的连接点，是一个系统内部的规定。每层只能为紧邻的层次之间定义接口，不能跨层定义接口。在典型的接口上，同一结点相邻两层的实体通过服务访问点（SAP）进行交互。服务是通过SAP提供给上层使用的，第n层的SAP就是第n+1层可以访问第n层服务的地方。 服务 服务是指下层为紧邻的上层提供的功能调用，它是垂直的。 上层使用下层所提供的服务时必须与下层交换一些命令，这些命令在OSI中称为服务原语。OSI将原语划分为4类：1）请求：由服务用户发往服务提供者，请求完成某项工作 2）指示：由服务提供者发往服务用户，提示用户做某件事 3）相应：由服务用户发往服务提供者，作为对指示的响应 4）证实：由服务提供者发往服务用户，作为对请求的证实 并非在一层内完成的全部功能都称为服务，只有那些能够被高一层实体“看得见”的功能才称为服务。 计算机网络提供的服务可按以下三种方式分类： （1）面向连接服务于无连接服务 在面向连接服务中，通信前双方必须先建立连接，分配相应的资源，以保证通信能正常进行，传输结束后释放连接和所占用的资源。因此这种服务可分为建立连接、数据传输和释放连接三个阶段。TCP就是一种面向连接服务的协议。 在无连接服务中，通信前双方不需要先建立连接，需要发送数据时可直接发送，把每个带有目的地址的包传送到线路上，由系统选定路线进行传输。这是一种不可靠的服务，这种服务常被描述为“尽最大可能交付”，它不能保证通信的可靠性。例如IP、UDP就是一种无连接服务的协议。 （2）可靠服务与不可靠服务 可靠服务是网络具有检错、纠错、应答机制，能保证数据正确、可靠地传送到目的地。 不可靠服务是指网络只是尽量正确、可靠地传送，而不能保证数据正确、可靠地传送到目的地，是一种尽力而为的服务。 （3）有应答服务和无应答服务 有应答服务是指接收方在收到数据后向发送方给出相应的应答，该应答由传输系统同内部自动实现，而不由用户实现。所发送的应答既可以是可乐定应答，也可以是否定应答，通常在接收到数据有错误时发送否定应答。文件传输服务就是一种有应答服务。 无应答服务是指接收方收到数据后不自动给出应答。若需要应答，则由高层实现。例如，对于WWW服务，客户端收到服务器发送的页面文件不给出应答。 三、ISO/OSI参考模型和TCP/IP模型 OSI参考模型 国际标准化组织（ISO）提出的网络体系结构模型，称为开放系统互联参考模型。通常简称为OSI模型。OSI有7层，自下而上依次是物理层、数据链路层、网络层、传输层、会话层、表示层、应用层。 低三层称为通信子网，它是为了联网而附加的通信设备，完成数据的传输功能；高三层统称为资源子网，它相当于计算机系统，完成数据的处理等功能。 1）物理层 物理层的传输单位是比特，任务是透明的传输比特流，功能是在物理媒体上为数据端设备透明地提供传输原始比特流。 物理层主要定义数据终端设备(DTE)和数据通信设备（DCE）的物理与逻辑连接方法，所以物理层协议也称为物理层接口标准，也称为规程。 2）数据链路层 数据链路层的传输单位是帧，任务是将网络层传来的IP数据报组装成帧。数据链路层的功能可以概括为成帧、差错控制、流量控制和传输管理。 典型的数据链路层协议有SDLC、HDLC、PPP、STP和帧中继等。 3）网络层 网络层的传输单位是数据报，它关心的是通信子网的运行控制，主要任务是把网络层的协议数据单元（分组）从源端传送到目的端，为分组交换网上的不同主机提供通信服务。关键问题是对分组进行路由选择，并实现流量控制、拥塞控制、差错控制和网际互联等功能。 网络层的协议有IP、IPX、ICMP、IGMP、ARP 、RARP、OSPF等 4）传输层 传输层也称为运输层，传输大单位是报文段（TCP）或用户数据报（UDP），传输层负责主机中两个进程之间的通信，功能是为端到端连接提供可靠的传输服务，为端到端连接提供流量控制、差错控制、服务质量、数据传输管理等服务。 数据链路层提供的是点对点的通信，传输层提供的是端到端的通信。 传输层的协议有TCP、UDP 5）会话层 会话层允许不同的主机上的各个进程之间进行通信。会话层利用传输层提供的端到端的服务向表示层提供它的增值服务。这种服务主要为表示层实体或用户进程建立连接并在连接上有序地传输数据，这就是会话，也称为建立同步(SYN)。 会话层负责管理主机间的会话进程，包括建立、管理及终止进程间的会话。会话层可以使用校验点使通信会话在通信失效时从校验点继续恢复通信，实现数据同步。 6）表示层 表示层主要用于处理在两个通信系统中交换信息的表示形式。不同机器采用的编码和表示方法不同，使用的数据结构也不同。为了使不同表示方法的数据和信息之间能互相交流，表示层采用抽象的标准方法定义数据结构，并采用标准的编码形式。数据压缩、加密和解密也是表示层可提供的数据表示交换功能。 7）应用层 应用层是OIS模型的最高层，是用户与网络的界面。应用层为特定类型的网络应用提供访问OSI环境的手段。因为用户的实际应用多种多样，这就要求应用层采用不同的应用协议来解决不同类型的应用要求，因此应用层是最复杂的一层，使用的协议也最多。 典型的应用层协议有用于文件传输的FTP、用于电子邮件的SMTP、用于万维网的HTTP等。 TCP/IP模型 TCP/IP模型从低到高依次是网络接口层（对应OSI参考模型中的物理层和数据链路层）、网际层、传输层和应用层（对应OSI模型的会话层、表示层、应用层）。 1）网络接口层 网络接口层的功能类似于OSI的物理层和数据链路层。它表示与物理网络的接口，但实际上TCP/IP本身并未真正描述这一部分，只是指出主机必须使用某种协议和网络连接，以便在其上传递IP分组。 2）网际层 网际层（主机-主机）是TCP/IP体系结构的关键部分。它和OSI网络层在功能上是非常相似的。网际层将分组发往任何网络，并为之独立地选择合适的路由，但它不保证各个分组有序地到达，各个分组的有序交付由高层负责。 3）传输层 传输层（应用-应用或进程-进程）的功能同样与OSI中的传输层类似，使得发送端和目的端主机的对等实体进行会话。传输层主要使用以下两种协议：（1） 传输控制协议（Transmission Control Protocol，TCP）。它是面向连接的，数据传输的单位是报文段，能够提供可靠的交付。 （2）用户数据报协议（User Datagram Protocol，UDP）。它是无连接的，数据传输的单位是用户数据报，不能保证提供可靠的交付，只能提供“尽最大努力交付”。 4）应用层（用户-用户）包含所有的高层协议。IP协议是因特网中的核心协议；TCP/IP可以为各种各样的应用提供服务，同时TCP/IP也允许在由各种网络构成的互联网上运行。 TCP/IP模型与OSI模型的比较 1）二者都采用分层的体系结构，分层的功能也大体相似 2）二者都基于独立的协议栈概念 3）二者都可以解决异构网络的互联，实现世界上不同厂家生产的计算机之间的通信 4）OSI模型最大的贡献是精确地定义了三个主要的概念：服务，协议和接口，与现代的面向对象程序设计思想非常吻合。而TCP/IP模型在这三个概念上却没有明确区分，不符合软件工程的思想 5）OSI模型产生在协议之前，没有偏向于任何特定的协议，通用性良好。TCP/IP模型产生于协议之后，实际是对协议的描述 6）TCP/IP在设计之初就考虑了多种异构网的互联问题，并将网际协议（IP）作为一个单独的重要层次。OSI模型最初只考虑到用一种标准的公用数据网络将不同的系统互联。OSI模型认识到网际协议IP的重要性后，只好在网络层中划分出一个子层来完成类似于TCP/IP模型中的IP功能 7）OSI模型在网络层支持无连接和面向连接的通信，但在传输层仅有面向连接的通信。而TCP/IP模型认为可靠性是端到端的问题，因此它在网际层仅有一种无连接的通信模式，但传输层支持无连接和面向连接两种模式。]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>网络体系结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[通信基础]]></title>
    <url>%2F2019%2F%E9%80%9A%E4%BF%A1%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[写在前面 物理层协议的主要任务就是确定与传输媒体的接口有关的一些特性，如下所述： 机械特性：指明接口所用接线器的形状和尺寸、引脚数目和排列、固定和锁定装置等。 电气特性：指明在接口电缆的各条线上出现的电压范围1. 功能特性：指明某条线上出现的某一电平代表何种意义。 过程特性：指明对于不同功能的各种可能事件的出现顺序。 一、数据通信的模型一个数据通信系统可划分为三大部分，即源系统（或发送端，发送方）、传输系统（或传输网络）和目的系统（或接收方、接收端）。 源系统一般包括两部分： 源点：源点设备产生要传输的数据。 发送器：通常源点生成的数字比特流要通过发送器编码之后才能在传输系统中进行传输。 目的系统一般包括两部分： 接收器：接收传输系统传送过来的信号，并把它转换为能够被目的设备处理的信息。 终点：终点设备从接收器获取传送来的数字比特流，然后进行信息输出。终点又称为目的站或信宿。 在源系统和目的系统之间的传输系统可以是简单的传输线路，也可以是连接在源系统和目的系统之间的复杂网络系统。 通信的目的是传送消息。 数据是消息的实体。 信号是数据的电器或电磁表现。根据信号中代表的消息的参数的取值方式不同，信号可分为两类： 模拟信号（或连续信号）——消息的参数的取值时连续的 数字信号（或离散信号）——消息的参数的取值时离散的。在使用时间域的波形表示数字信号时，代表不同离散数值的基本波形就称为码元。在使用二进制编码时，只有两种不同的码元，一种代表0状态，另一种代表1状态。 速率、波特与带宽 速率也称为数据率，指的是数据的传输速率，表示单位之间内传输的数据量。可以用码元传输速率和信息传输速率表示。 码元传输速率。又称码元速率，波形速率等，它表示单位时间内数字通信系统所传输的码元个数，单位是波特（Baud）。1波特表示数字通信系统每秒传输一个码元。这里的码元可以是多进制的，也可以是二进制的，但码元速率与进制数无关。 信息传输速率。又称信息速率，比特率等。它表示单位时间内数字通信系统传输的二进制码元数（即比特数），单位是比特/秒（b/s). 二、编码与调制 常用编码方式 要利用信道传输数据，必须将数据转换为能在传输媒体媒体上传送的信号。信道可以分为传送模拟信号的模拟信道和传送数字信号的数字信道两大类。 将数字数据转换为数字信号的过程称为编码。 将数字信号转换为模拟信号的过程称为调制。 归零制：正脉冲代表1，负脉冲代表0； 不归零制：正电平代表1，负电平代表0； 曼彻斯特编码：位周期中心的是上跳变代表0，位周期中心的下跳变代表1； 差分曼彻斯特编码：在每一位的中心处始终有跳变。位开始边界有跳变代表0，而位边界没有跳变代表1； 基本的调制方法 矩形脉冲波形的数字信号包含从直流开始的低频分量，被称为基带信号 在数字信道上直接传输基带信号的方法称为基带传输 基带信号往往包含较多的低频成分，甚至直流成分。而许多模拟信道仅能通过某一频率范围的信号，不能直接传输这种基带信号。因此必须对基带信号进行调制，使它能够在模拟信道中传输。 在很多情况下，需要使用载波进行调制，把基带信号的频率范围搬移到较高的频段以便在信道中传输。经过载波调制后的信号称为带通信号，而使用载波的调制称为带通调制。 最基本的带通调制的方法有：1）调幅（AM），即载波的增幅随基带数字信号而变化。 2）调频（FM），即载波的频率随着基带数字信号的变化而变化。 3）调相（PM），即载波的初始相位随基带数字信号而变化。 在数字通信中，调幅、调频和调相相应地称为幅移键控、频移键控和相移键控。实现调制和解调功能的设备称为调制解调器。 三、奈奎斯特定理与香农定理 奈奎斯特定理 奈奎斯特定理又称奈氏准则。它指出在理想低通（没有噪声、带宽有限）的信道中，极限码元速率为2W波特，其中W是理想低通信道的带宽，单位是Hz。若用V表示每个码元离散电平的数目（码元的离散电平数目是指有多少种不同的码元，比如有16种不同的码元，则需要有4位二进制位，因此数据传输率是码元传输率的4倍），则极限速率为 ​ 理想低通信道下的极限数据传输率=$2Wlog_2V$（单位为b/s) 对于奈氏准则，可以得出以下结论： 1）在任何信道中，码元传输的速率是有上限的。若传输速率超过此上限，就会出现严重的码间串扰问题，使得接收端不可能完全正确地识别码元。 2）信道的频带越宽(即通过的信号高频分量越多)，就可用更高的速率进行码元的有效传输。 3）奈氏准则给出了码元传输速率的限制，但是并未对信息传输速率给出限制，即未对一个码元可以对应多少个二进制位给出限制。 由于码元的传输速率受奈氏准则的制约，所以要提高数据的传输速率，就必须设法使每个码元携带更多个比特的信息量，此时就需要多元制的调制方法。 香农定理 香农定理给出了带宽受限且有高斯白噪声干扰的信道的极限数据传输率，当用此速率进行传输时，可以做到不产生误差。香农定理定义为： ​ 信道的极限数据传输率=$Wlog_2(1+S/N)$ 单位为b/s 式中，W为信道带宽，S为信道所传输信号的平均功率，N为信道内部的高斯噪声功率，$S/N$为信噪比，即信号的平均功率与噪声的平均功率之比。 对于香农定理，可以得出以下的结论：1）信道的带宽或信道中的信噪比越大，信息的极限传输速率越高。 2）对一定的传输带宽和一定的信噪比，信息传输速率的上限是确定的。 3）只要信息的传输速率低于信道的极限传输速率，就能找到某种方法来实现无差错的传输。 4）香农定理得出的是极限信息传输速率，实际信道能达到的传输速率比它低不少。 从香农定理可以看出，若信道带宽W或信噪比S/N没有上限，则信道的极限信息传输速率也没有上限。 奈氏准则只考虑了带宽与极限码元速率的关系，而香农定义不仅考虑了带宽，而且考虑到了信噪比。这从另一个侧面表明，一个码元对应的二进制位数是有限的。 四、传输方式 并行传输与串行传输 并行传输，是指一次发送n个比特而不是一个比特，为此，在发送端和接收端之间需要有n条传输线路。 串行传输，是指数据是一个比特一个比特发送的，为此，发送端和接收端之间只需要一条传输线路。 异步传输与同步传输 异步传输以字节为独立的传输单位，字节之间的时间间隔不是固定的，接收端仅在每个字节的起始处对字节内的比特实现同步。为此，通常需要在每个字节前后分别加上起始位和结束位，这里的异步是指在字节级上的异步，但是字节中的每个比特仍然要同步，它们的持续时间是相同的。 采用同步传输方式时，数据块以稳定的比特流形式传输，字节之间没有间隔，也没有起始位和结束位。由于不同设备的时钟频率存在一定差异，为避免在传输大量数据的过程中累积误差所导致的错误，要采取技术使得收发双方的时钟保持同步。实现收发双方时钟同步的方法有两种，即外同步和内同步。 外同步，是在发送端和接收端之间提供一条单独的时钟线，发送端在发送数据信号的同时，另外发送一条时钟同步信号。接收端根据接收到的时钟同步信号来校正时间基准，实现收发双方之间的同步。 内同步，是发送端将时钟同步信号编码到发送数据中一起传输，如曼彻斯特编码与差分曼彻斯特编码都含有时钟编码，具有自同步能力。 单工、半双工、全双工 1）单向通信，又称为单工通信，即只能有一个方向的通信而没有反方向的交互。如广播等。 2）双向交替通信，又称半双工通信，即通信的双方都可以发送信息，但不能双方同时发送。这种通信方式是一方发送另一方接收，过一段时间再反回来。 3）双向同时通信，又称为全双工通信，即通信的双方可以同时发送和接收信息。]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>通信</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机网络概述]]></title>
    <url>%2F2019%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%A6%82%E8%BF%B0%2F</url>
    <content type="text"><![CDATA[写在前面一般认为，计算机网路是一个将分散的、具有独立功能的计算机系统，通过通信设备与线路连接在一起，由功能完善的软件实现资源共享和信息传递的系统。简言之，计算机网络就是一些互联的、自治的计算机系统的集合。 一、计算机网络在计算机的不同发展阶段，网络有不同的定义，这些定义反映了当时网络技术的发展水平。分为三类： 广义观点 广义观点认为，只要是能实现远程信息处理的系统或能进一步达到资源共享的系统，，都是计算机网络。 资源共享观点 资源共享观点认为，计算机网络是“以能够相互共享资源的方式互联起来的自治计算机系统的集合”。这个定义符合目前计算机网络的基本特征。 用户透明性观点 这种观点认为，存在一个能为用户自动管理资源的网络操作系统。它能够调用用户所需要的资源，而整个网络就像是一个大的计算机系统一样对用户是透明的。用户透明性观点的定义描述了一个分布式系统，它是网络未来发展追求的目标。 二、计算机网络的组成从不同的角度，可以将计算机网路的组成分为以下几类： 从组成部分上来看，一个完整的计算机网络主要由硬件、软件、协议散发部分组成。硬件主要由主机（端系统）、通信链路（如双绞线、光纤）、交换设备（如交换机、路由器）和通信处理机（如网卡）等组成。软件主要包括各种实现资源共享的软件和方便用户使用的各种工具软件。软件部分多属于应用层。协议是计算机网络的核心。 从工作方式看，计算机网络可分为边缘部分和核心部分。边缘部分由所有连接到因特网上、供用户使用的端系统组成，用来进行通信和资源共享。核心部分由大量的网络和连接这些网络的路由器组成，为边缘部分提供连通性和交换服务。 从功能组成上看，计算机网络由通信子网和资源子网构成。通信子网由各种传输介质、通信设备和相应的网络协议组成，它使网络具有数据传输、交换、控制和存储的能力，实现联网计算机之间的数据通信。资源子网是实现资源共享功能的设备及其软件的集合，向用户提供共享其他其他计算机上的硬件资源、软件资源和数据资源的服务。 三、计算机网络的功能计算机网路的功能很多，现如今的很多应用都与网络有关。主要有下面5个部分。 数据通信 它是计算机网络最基本也是最重要的功能，用来实现联网计算机之间的各种信息的传输，并将分散在不同地理位置的计算机联系起来，进行统一的调配、控制和管理。 资源共享 资源共享可以是软件共享、数据共享，也可以是硬件共享。使计算机网络中的资源互通有无，分工协作，从而极大地提高了硬件资源、软件资源和数据资源的利用率 分布式处理 当计算机网络中的某个计算机负荷过重时，可以将其处理的某个复杂的任务分配给网络中的其他计算机系统，从而利用空闲资源以提高整个系统的利用率 提高可靠性 计算机网络中的各台计算机通过网络互为替代机 负载均衡 将工作任务均衡地分配给计算机网络中的各台计算机。 四、计算机网络的分类 按分布范围分： 1) 广域网（WAN）。任务是提供长距离通信，运送主机所发送的数据。 2）城域网（MAN）。城域网的覆盖范围可以跨越几个街区甚至几个城市，大多采用以太网技术。 3）局域网（LAN）。局域网一般用微机或工作站通过高速线路相连，覆盖范围较小。传统上，局域网使用广播技术，而广域网使用交换技术。 4）个人局域网（PAN）。在个人工作的地方将消费电子设备用无线技术连接起来的网络。 按传输技术分： 1）广播式网络。所有联网计算机都共享一个公共通信信道。当一台计算机利用共享通信信道发送报文分组时，所有其他的计算机都会“收听”到这个分组。接收到该分组的计算机将通过检查目的地址来决定是否接收该分组。 局域网基本上都采用广播式通信技术，广域网中的无线，卫星通信网络也采用广播式通信技术。 2）点对点网络。每条物理线路连接一对计算机。如果通信的两台计算机之间没有直接连接线路，那么它们之间的分组传输就要通过中间结点的接收、存储和转发，直至目的结点。 是否采用分组存储转发与路由选择机制是点对点网络与广播式网络的重要区别，广域网基本都属于点对点网络。 按拓扑结构分: 网络拓扑结构是指由网中结点（路由器、主机等）与通信线路（网线）之间的几何关系表示的网络结构，主要指通信子网的拓扑结构。 按网络的拓扑结构，主要分为星形、总线形、环形和网状形网络等。星形、总线形和环形网络多用于局域网，网状网络多用于广域网。 1）星形网络。每个终端或计算机都以单独的线路与中央设备相连。中央设备早期是计算机，现在一般是交换机或路由器。星形网络便于集中控制和管理，因为端用户之间的通信必须通过中间设备。缺点是成本高，中心节点对故障敏感。 2）总线形网络。用单根传输线将计算机连接起来。总线形网络的优点是建网容易，增减节点方便，节省线路。缺点是重负载时通信效率不高，总线任意一处对故障敏感。 3）环形网络。所有计算机接口设备连接成一个环。环形网络最典型的例子是令牌环局域网。环可以是单环，也可以是双环，环中信号是单向传输的。 4）网状网络。一般情况下，每个结点至少有两条路径与其他节点相连，多用于广域网中。有规则型和非规则型。其优点是可靠性高，缺点是控制复杂，线路成本高。 按使用者分: 1）公用网。指电信公司出资建造的大型网络。 2）专用网。指某个部门为了满足本单位特殊业务的需要而建造的网络，这种网络不对单位以外的人开放。 按交换技术分： 1）电路交换网络。在源结点和目的结点之间建立一条专用的通路用于传送数据，包括建立连接、传输数据和断开连接三个阶段。最典型的电路交换网络是传统电话网络。 该类网络的主要特点是整个报文的比特流连续地从源点直达终点，好像是在一条管道中传送。优点是数据直接传送，时延小。缺点是线路利用率低、不能充分利用线路容量，不便于进行差错控制。 2）报文交换网络。用户数据加上源地址、目的地址、校验码等辅助信息，然后封装成报文。整个报文传送到相邻结点全部存储后，再转发到下一个结点，重复这一过程直到到达目的结点。每个报文可以单独选择到达目的结点的路径。 报文交换网络也称存储-转发网络，主要特点是整个报文先传送到相邻结点，全部存储后查找转发表，转发到下一个结点。优点是可以较为充分的利用线路容量，可以实现不同链路之间不同数据率的转换，可以实现格式转换，可以实现一对多，多对一的访问，可以实现差错控制。缺点是增大了资源开销，增加了缓冲时延，需要额外的控制机制来保证多个报文的顺序不乱序，缓冲区难以管理。 3）分组交换网络。也称包交换网络。其原理是将数据分为较短的固定长度的数据块，在每个数据块中加上目的地址、源地址等辅助信息组成分组（包），以存储-转发方式传输。 其主要特点是单个分组传送到相邻结点，存储后查找转发表，转发到下一个结点。除具备报文交换网络的优点外，分组交换网络还具有自身的优点：缓冲易于管理；包的平均时延更小，网络占用的平均缓冲更少；易于标准化；更适合应用。现在的主流网络基本上都可视为分组交换网络。 按传输介质分： 传输介质可分为有线和无线两大类，故网络可分为有线网络和无线网络。有线网络又分为双绞线网络，同轴电缆网络等。无线网络可分为蓝牙、微波、无线电等。 五、计算机网络的的性能指标性能指标从不同的方面来度量计算机网络的性能。 速率 速率是数据的传送速率，它也称为数据率或比特率。 带宽 本来表示某个信号具有的频带宽度，单位是赫兹（Hz），而在计算机网络分钟，带宽用来表示网络的通信线路所能传送数据的能力，单位是比特/秒（b/s） 吞吐量 也称为吞吐率，表示单位时间内通过某个网络（或信道、接口）的数据量。 时延 时延是指一个数据（一个报文或分组，甚至比特）从网路（或链路）的一端传送到另一端所需要的时间。时延有时称为延迟或迟延。 1）发送时延，是主机或路由器将分组发送到通信线路上所需要的时间。 1发送时延=分组长度/发送速率 2）传播时延，是电磁波在信道中传播需要一定的距离而花费的时间。 1传播时延=信道长度/电磁波在信道上的传播速率 3）处理时延，主机或路由器收到分组时要花费一定的时间进行处理，例如，分析分组的首部、从分组中提取数据部分、进行差错检验或查找适当的路由等，这就产生了处理时延。 4）排队时延，分组在进入路由器后要先在输入队列在排队等待处理。路由器确定转发端口后，还要在输出队列中排队等待转发，这就产生了排队时延。 这样，分组从一个结点转发到另一个结点转发到另一个结点所经历的时延就是以上4种时延之和。 1总时延=发送时延+传播时延+处理时延+排队时延 丢包率 即分组丢失率，是指在一定的时间范围内，分组在传输过程中丢失的分组数量和总的分组数量的比率。 分组丢失的两种情况：一是因为传输过程中出现比特级差错被结点丢弃。二是因为分组交换机队列溢出。 利用率 令D0表示网络空闲时的时延，D表示网络当前时延，那么在适当的假定条件下，利用率可表示为：D=D0/1-U。 信道或网络利用率过高会产生非常大的时延。 时延带宽积 指发送端连续发送数据且发送的第一个比特即将到达终点时，发送端已经发出的比特数，即时延带宽积=传播时延*信道带宽。]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[顺序循环链表的实现]]></title>
    <url>%2F2019%2F%E9%A1%BA%E5%BA%8F%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8%E7%9A%84%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[写在前面&emsp;&emsp;队列（Queue)是一种特殊的线性表，是一种只允许在表的一端进行插入操作，在表的另一端进行删除操作的线性表。表中允许进行插入操作的一端称为队尾，允许进行删除操作的一端为队头。队头和队尾分别由队头指示器和队尾指示器指示。队列的插入操作通常称为入队，队列的删除操作通常称为出队。当队列中没有元素时，为空队列。&emsp;&emsp;根据队列的定义，每次进队列的数据元素都放在原来的队尾之后成为新的队尾元素，每次出队列得到数据元素都是原来的队头元素。这样，最先入队的数据元素总是最先出队，所以队列也被称为先进先出表。&emsp;&emsp;对队列的操作主要有：初始化建立队列、入队列、出队列、取队头元素、判断队列是否为空等操作。 1.顺序队列的类定义 123456789101112131415161718192021const int maxsize = 10;template&lt;class T&gt;class Queue&#123;public: Queue();//构造函数 ~Queue() &#123;&#125;;//析构函数 void insert(const T&amp;item);//入队 T delet();//出队列 T readFront() const;//读队头元素 bool empty() const;//判断队列是否为空 void clearQueue();//清空队列 int getsize() const;//获取队列长度 void display() const;//输出队列中的元素private: T data[maxsize]; int front; int rear; int count;&#125;; 2.顺序队列类的实现 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970template&lt;class T&gt;inline Queue&lt;T&gt;::Queue()&#123; front = 0; rear = 0; count = 0;&#125;template&lt;class T&gt;inline void Queue&lt;T&gt;::insert(const T &amp; item)&#123; if (count == maxsize) &#123; cout &lt;&lt; "Queue is full" &lt;&lt; endl; exit(1); &#125; count++; data[rear] = item; rear = ((rear + 1) == maxsize) ? 0 : (rear + 1); &#125;template&lt;class T&gt;inline T Queue&lt;T&gt;::delet()&#123; if (count&lt;=0) &#123; cout &lt;&lt; "Queue is empty" &lt;&lt; endl; &#125; count--; T p = data[front]; front = ((front + 1) == maxsize) ? 0 : (front + 1); return p;&#125;template&lt;class T&gt;inline T Queue&lt;T&gt;::readFront() const&#123; return data[front];&#125;template&lt;class T&gt;inline bool Queue&lt;T&gt;::empty() const&#123; return (count == 0);&#125;template&lt;class T&gt;inline void Queue&lt;T&gt;::clearQueue()&#123; count = 0; front = rear = 0;&#125;template&lt;class T&gt;inline int Queue&lt;T&gt;::getsize() const&#123; return count;&#125;template&lt;class T&gt;inline void Queue&lt;T&gt;::display() const&#123; int i = 0; while (i != count) &#123; cout &lt;&lt; i &lt;&lt; "号元素：" &lt;&lt; data[i] &lt;&lt; endl; i++; &#125;&#125; 3.测试主函数 1234567891011121314151617181920void test()&#123; Queue&lt;int&gt; queue; for (int i = 0; i &lt; 10; i++) &#123; queue.insert(i); &#125; cout &lt;&lt;"队列的长度为："&lt;&lt; queue.getsize() &lt;&lt; endl; queue.display(); cout &lt;&lt;"队头元素为："&lt;&lt; queue.readFront() &lt;&lt; endl; cout &lt;&lt; "元素："&lt;&lt;queue.delet()&lt;&lt;"已删除" &lt;&lt; endl;&#125;int main()&#123; test(); system("pause"); return EXIT_SUCCESS;&#125; 输出结果如下：]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>顺序循环链表</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[链式队列的实现]]></title>
    <url>%2F2019%2F%E9%93%BE%E5%BC%8F%E9%98%9F%E5%88%97%E7%9A%84%E5%AE%9E%E7%8E%B0-1%2F</url>
    <content type="text"><![CDATA[写在前面&emsp;&emsp;链式队列是队列的链式存储结构表示。队列是操作受限的表，队列有队头和队尾，插入元素的一端称为队尾，删除元素的一端称为队头。这和一般排队的概念一样，后来的人排在队尾，首先对队头的人进行服务，对队头的人服务后，原当前队头后的人就排在了当前队头。新来的人排在队尾后，原队尾的人就不再是当前队尾了，新来的人就成了当前队尾。&emsp;&emsp;链式队列的队头指针指在队列的当前队头节点位置，队尾指针指在队列的当前队尾节点位置。不带头节点的链式队列，出队列时可直接删除头指针所指的节点，因此，链式队列不带头指针时更加方便。 1.链式队列节点类的定义和实现 12345678910111213141516171819202122template&lt;class T&gt;class LinkQueue;template&lt;class T&gt;class QueueNode&#123; friend class LinkQueue&lt;T&gt;;public: T data; QueueNode&lt;T&gt;(const T&amp; item, QueueNode&lt;T&gt; *ptrNext = NULL); ~QueueNode() &#123;&#125;;private: QueueNode&lt;T&gt; *next;&#125;;template&lt;class T&gt;inline QueueNode&lt;T&gt;::QueueNode(const T &amp; item, QueueNode&lt;T&gt;* ptrNext)&#123; this-&gt;data = item; this-&gt;next = ptrNext;&#125; 2.链式队列类的定义 1234567891011121314151617181920template&lt;class T&gt;class LinkQueue&#123;public: LinkQueue();//构造函数 ~LinkQueue();//析构函数 void insert(const T&amp; item);//入队 T delet();//出队 T readFront() const;//读队头元素 bool empty() const;//判断队列是否为空 void clearQueue();//清空队列 int getSize() const;//取队列长度 void display() const;//输出队列元素private: QueueNode&lt;T&gt; *front;//指向队头的指针 QueueNode&lt;T&gt; *rear;//指向队尾的指针 int size;&#125;; 3.链式队列类的实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990template&lt;class T&gt;inline LinkQueue&lt;T&gt;::LinkQueue()&#123; size = 0; front = rear = NULL;&#125;template&lt;class T&gt;inline LinkQueue&lt;T&gt;::~LinkQueue()&#123; clearQueue(); front = rear = NULL;&#125;template&lt;class T&gt;inline void LinkQueue&lt;T&gt;::insert(const T &amp; item)&#123; QueueNode&lt;T&gt; *new_node = new QueueNode&lt;T&gt;(item); if (rear != NULL) &#123; rear-&gt;next = new_node; &#125; rear = new_node; if (front == NULL) &#123; front = new_node; &#125; size++;&#125;template&lt;class T&gt;inline T LinkQueue&lt;T&gt;::delet()&#123; if (size == 0) &#123; cout &lt;&lt; "Queue is empty" &lt;&lt; endl; exit(1); &#125; T member = front-&gt;data; QueueNode&lt;T&gt; *p = front-&gt;next; delete front; front = p; size--; return member;&#125;template&lt;class T&gt;inline T LinkQueue&lt;T&gt;::readFront() const&#123; return front-&gt;data;&#125;template&lt;class T&gt;inline bool LinkQueue&lt;T&gt;::empty() const&#123; return (size==0);&#125;template&lt;class T&gt;inline void LinkQueue&lt;T&gt;::clearQueue()&#123; QueueNode&lt;T&gt; *p1, *p2; p1 = front; while (p1 != NULL) &#123; p2 = p1; p1 = p1-&gt;next; delete p2; &#125; size = 0;&#125;template&lt;class T&gt;inline int LinkQueue&lt;T&gt;::getSize() const&#123; return size;&#125;template&lt;class T&gt;inline void LinkQueue&lt;T&gt;::display() const&#123; QueueNode&lt;T&gt; *p = front; int i = 0; while (p != NULL) &#123; cout &lt;&lt; "第" &lt;&lt; i &lt;&lt; "号元素为：" &lt;&lt; p-&gt;data &lt;&lt; endl; i++; p = p-&gt;next; &#125;&#125; 4.测试主函数 123456789101112131415161718192021222324252627282930313233343536373839404142434445void test()&#123; LinkQueue&lt;int&gt; queue; for (int i = 0; i &lt; 10; i++) &#123; queue.insert(i * 10); &#125; cout &lt;&lt; "队列长度为：" &lt;&lt; queue.getSize() &lt;&lt; endl; queue.display(); cout &lt;&lt; "栈顶元素为：" &lt;&lt; queue.readFront() &lt;&lt; endl; for (int i = 0; i &lt; 10; i++) &#123; cout &lt;&lt; "元素：" &lt;&lt; queue.delet() &lt;&lt; "被删除" &lt;&lt; endl; &#125; cout &lt;&lt; "队列长度为：" &lt;&lt; queue.getSize() &lt;&lt; endl;&#125;int main()&#123; test(); system("pause"); return EXIT_SUCCESS;&#125;void test()&#123; LinkQueue&lt;int&gt; queue; for (int i = 0; i &lt; 10; i++) &#123; queue.insert(i * 10); &#125; cout &lt;&lt; "队列长度为：" &lt;&lt; queue.getSize() &lt;&lt; endl; queue.display(); cout &lt;&lt; "栈顶元素为：" &lt;&lt; queue.readFront() &lt;&lt; endl; for (int i = 0; i &lt; 10; i++) &#123; cout &lt;&lt; "元素：" &lt;&lt; queue.delet() &lt;&lt; "被删除" &lt;&lt; endl; &#125; cout &lt;&lt; "队列长度为：" &lt;&lt; queue.getSize() &lt;&lt; endl;&#125;int main()&#123; test(); system("pause"); return EXIT_SUCCESS;&#125; 输出结果如下：]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>队列</tag>
        <tag>链式队列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[双向循环链表]]></title>
    <url>%2F2019%2F%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[写在前面&emsp;&emsp;双向循环链表（Double Circular Linked List)是每个节点有前趋指针和后继指针，且后继指针和前趋指针各自构成自己的单循环链表的链表。&emsp;&emsp;在单链表中查找当前节点的后继节点并不困难，可以通过当前节点的next指针进行，但要查找当前节点的前趋节点就要从头指针head开始重新进行。对于一个要进行频繁查找当前节点的后继节点和当前节点的前趋节点的应用来说，使用单链表的时间效率是非常低的，双向链表是有效解决这类问题的选择。&emsp;&emsp;在双向链表中，每个节点包括三个域，分别是data,next,prior。其中data为数据域，next为后继节点指针，prior为前趋节点指针。&emsp;&emsp;双向链表通常均为双向循环链表，这是因为读双向循环链表，不论是插入还是删除，对第一个节点、最后一个节点的操作和对链表中间任意一个节点的操作过程是一样的。而双向非循环链表对这些节点的操作是不同的。 1.节点类的定义和实现 1234567891011121314151617181920212223242526template&lt;class T&gt;class DCirlist;template&lt;class T&gt;class DLnode&#123; friend class DCirlist&lt;T&gt;;public: T data; //构造函数，无数据域的头结点 DLnode&lt;T&gt;(DLnode&lt;T&gt; *ptrn = NULL, DLnode&lt;T&gt; *ptrp = NULL)&#123;&#125;; //构造函数，非头节点的节点 DLnode&lt;T&gt;( T item, DLnode&lt;T&gt; *ptrn = NULL, DLnode&lt;T&gt; *ptrp = NULL); //析构函数 ~DLnode() &#123;&#125;;private: DLnode&lt;T&gt; *next; DLnode&lt;T&gt; *prior;&#125;;template&lt;class T&gt;inline DLnode&lt;T&gt;::DLnode(T item, DLnode&lt;T&gt;* ptrn, DLnode&lt;T&gt;* ptrp)&#123; this-&gt;data = item; this-&gt;next = ptrn; this-&gt;prior = ptrp;&#125; &emsp;&emsp;双向循环链表只是在单循环链表的基础上又增加了一个指向前趋节点的指针，而且指向前趋节点指针也构成了自己的单循环链表。双循环链表的定义与单循环链表的定义非常相似。 2.双向循环链表类的定义 1234567891011121314151617181920212223242526272829template &lt;class T&gt;class DCirlist&#123;public: DCirlist();//构造函数 ~DCirlist();//析构函数 int listsize() const;//返回链表长度 bool empty() const;//判断链表是否为空 DLnode&lt;T&gt; *index(int pos) const;//返回指向第pos个节点的指针 void insert(const T &amp;item, int pos);//在第pos个节点插入item T del(int pos);//删除第pos个节点，并返回数据域 T getdata(int pos) const;//返回第pos个节点的值 void clearlist();//清空表 DLnode&lt;T&gt; *reset(int pos = 0); DLnode&lt;T&gt; *next(); DLnode&lt;T&gt; *prior(); bool EndOfList() const;//是否到链表尾 bool nextEndoflist() const;//currPtr-&gt;next是否到链表尾 bool PriorEndoflist() const;//currPtr-&gt;prior是否到链表尾 T deleprior();//删除currPtr节点，新currPtr是原currPtr的前趋，返回数据域private: DLnode&lt;T&gt; *head; DLnode&lt;T&gt; *currPtr; int size;&#125;; 3.双向循环链表类的实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178template&lt;class T&gt;inline DCirlist&lt;T&gt;::DCirlist()&#123; head = new DLnode&lt;T&gt;(); head-&gt;next = head; head-&gt;prior = head; size = 0;&#125;template&lt;class T&gt;inline DCirlist&lt;T&gt;::~DCirlist()&#123; clearlist(); delete head; head = NULL;&#125;template&lt;class T&gt;inline int DCirlist&lt;T&gt;::listsize() const&#123; return size;&#125;template&lt;class T&gt;inline bool DCirlist&lt;T&gt;::empty() const&#123; return (size == 0);&#125;template&lt;class T&gt;inline DLnode&lt;T&gt;* DCirlist&lt;T&gt;::index(int pos) const&#123; if (pos == -1) &#123; return head; &#125; if (pos&lt;0 || pos&gt;size) &#123; cout &lt;&lt; "illegal operator" &lt;&lt; endl; exit(1); &#125; int i = 0; DLnode&lt;T&gt; *p = head-&gt;next; while (i &lt; pos&amp;&amp;p != head) &#123; p = p-&gt;next; i++; &#125; return p;&#125;template&lt;class T&gt;inline void DCirlist&lt;T&gt;::insert(const T &amp; item, int pos)&#123; DLnode&lt;T&gt; *p = index(pos-1); DLnode&lt;T&gt; *new_node = new DLnode&lt;T&gt;(item, NULL, NULL); new_node-&gt;prior = p; p-&gt;next-&gt;prior = new_node; new_node-&gt;next = p-&gt;next; p-&gt;next = new_node; size++;&#125;template&lt;class T&gt;inline T DCirlist&lt;T&gt;::del(int pos)&#123; if (size == 0) &#123; cout &lt;&lt; "list is empty" &lt;&lt; endl; exit(1); &#125; if (pos&lt;0 || pos&gt;size) &#123; cout &lt;&lt; "illegal operator" &lt;&lt; endl; exit(1); &#125; DLnode&lt;T&gt; *p = index(pos); p-&gt;prior-&gt;next = p-&gt;next; p-&gt;next-&gt;prior = p-&gt;prior; T data = p-&gt;data; delete p; size--; return data;&#125;template&lt;class T&gt;inline T DCirlist&lt;T&gt;::getdata(int pos) const&#123; DLnode&lt;T&gt; *p = index(pos); return p-&gt;data;&#125;template&lt;class T&gt;inline void DCirlist&lt;T&gt;::clearlist()&#123; DLnode&lt;T&gt; *p1, *p2; p1 = head-&gt;next; while (p1 != head) &#123; p2 = p1; p1 = p1-&gt;next; delete p2; &#125; size = 0;&#125;template&lt;class T&gt;inline DLnode&lt;T&gt;* DCirlist&lt;T&gt;::reset(int pos)&#123; if (pos == -1) &#123; return head; &#125; if (pos&lt;0 || pos&gt;size) &#123; cout &lt;&lt; "illegal operator" &lt;&lt; endl; exit(1); &#125; int i = 0; currPtr = head-&gt;next; while (i &lt; pos&amp;&amp;currPtr != head) &#123; currPtr = currPtr-&gt;next; i++; &#125; return currPtr;&#125;template&lt;class T&gt;inline DLnode&lt;T&gt;* DCirlist&lt;T&gt;::next()&#123; if (currPtr!= NULL) &#123; currPtr = currPtr-&gt;next; &#125; return currPtr; &#125;template&lt;class T&gt;inline DLnode&lt;T&gt;* DCirlist&lt;T&gt;::prior()&#123; if (currPtr != NULL) &#123; currPtr = currPtr-&gt;prior; &#125; return currPtr;&#125;template&lt;class T&gt;inline bool DCirlist&lt;T&gt;::EndOfList() const&#123; return (currPtr == head);&#125;template&lt;class T&gt;inline bool DCirlist&lt;T&gt;::nextEndoflist() const&#123; return (currPtr-&gt;next == head);&#125;template&lt;class T&gt;inline bool DCirlist&lt;T&gt;::PriorEndoflist() const&#123; return (currPtr-&gt;prior == head);&#125;template&lt;class T&gt;inline T DCirlist&lt;T&gt;::deleprior()&#123;//删除当前节点的前一节点 DLnode&lt;T&gt; *p = currPtr-&gt;prior; currPtr-&gt;prior-&gt;next = currPtr-&gt;next; currPtr-&gt;next-&gt;prior = currPtr-&gt;prior; T data = currPtr-&gt;data; delete currPtr; size--; currPtr = p; return currPtr;&#125; 4.测试主函数 1234567891011121314151617181920212223242526272829303132void test()&#123; DCirlist&lt;int&gt; list; for (int i = 0; i &lt; 10; i++) &#123; list.insert(i * 10, i); &#125; cout &lt;&lt; "list中元素的个数为：" &lt;&lt; list.listsize() &lt;&lt; endl; DLnode&lt;int&gt; *p = list.reset(); while (!list.EndOfList()) &#123; cout &lt;&lt; p-&gt;data &lt;&lt; endl; p = list.next(); &#125; p = list.next(); cout &lt;&lt; list.del(1) &lt;&lt; "已被删除" &lt;&lt; endl; cout &lt;&lt; "list中元素的个数为：" &lt;&lt; list.listsize() &lt;&lt; endl; while (!list.EndOfList()) &#123; cout &lt;&lt; p-&gt;data &lt;&lt; endl; p = list.next(); &#125; cout &lt;&lt; list.getdata(1) &lt;&lt; endl; cout &lt;&lt; list.index(2)-&gt;data &lt;&lt; endl;&#125;int main()&#123; test(); system("pause"); return EXIT_SUCCESS;&#125; 输出结果如下：]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>双向循环链表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[单循环链表]]></title>
    <url>%2F2019%2F%E5%8D%95%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[写在前面&emsp;&emsp;单循环链表，简称循环链表（circular linked list)，是表的一种链式存储结构。&emsp;&emsp;设p是指向循环链表的指针，currPtr是当前指向对的循环链表的指针，head是指向循环链表的头指针，与链表判断是否到达链尾相比，循环链表中判断是否到达链表尾的条件是：p!=head或者是currPtr!=head。所以，循环链表类中成员函数的实现与链表类中的成员函数的实现差别不大，只是把p!=null换成了p!=head，把currPtr!=null换成了currptr!=head. 1.节点类的定义和实现 1234567891011121314151617181920212223242526template&lt;class T&gt;class CirList;template&lt;class T&gt;class ListNode&#123; friend class CirList&lt;T&gt;;//声明友元类public: T data;//数据域 ListNode(ListNode&lt;T&gt; *ptrNext = NULL);//构造函数，用于构造头节点，头节点没有data参数 ListNode(const T &amp;item, ListNode&lt;T&gt; *ptrNext = NULL);//构造函数，主要用于构造非头节点的节点 ~ListNode() &#123;&#125;;//析构函数private: ListNode&lt;T&gt; *next;//指向下一节点的指针&#125;;template&lt;class T&gt;inline ListNode&lt;T&gt;::ListNode(ListNode&lt;T&gt;* ptrNext) :next(ptrNext)&#123;&#125;template&lt;class T&gt;inline ListNode&lt;T&gt;::ListNode(const T &amp; item, ListNode&lt;T&gt;* ptrNext)&#123; this-&gt;data = item; this-&gt;next = ptrNext;&#125; 2.循环链表类的定义 12345678910111213141516171819202122232425262728template &lt;class T&gt;class CirList&#123;public: CirList();//构造函数 ~CirList();//析构函数 int listsize();//长度 bool listempty() const;//是否为空 ListNode&lt;T&gt; *index(int pos);//返回指向位置pos的指针 void insert(const T&amp; item, int pos);//在pos节点前插入一个节点 T del(int pos);//删除第pos个节点 T getdata(int pos) const;//返回pos节点的值域 void clearlist();//清空表为初始状态 ListNode&lt;T&gt; *reset();//currptr指向节点pos并返回currptr ListNode&lt;T&gt; *next();//currptr指向下一节点并返回currptr bool EndOfList() const;//判断是否到了尾部 ，currptr==head bool nextEndofList() const;//currptr-&gt;next是否链表尾 T delAfter();//删除currptr-&gt;next所指节点并返回被删除节点的dataprivate: ListNode&lt;T&gt; *head;//表头指针 int size;//链表的节点个数 ListNode&lt;T&gt; *currPtr;//当前节点指针&#125;; 3.循环链表类的实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146template&lt;class T&gt;inline CirList&lt;T&gt;::CirList()&#123; head = new ListNode&lt;T&gt;(); size = 0; head-&gt;next = head;&#125;template&lt;class T&gt;inline CirList&lt;T&gt;::~CirList()&#123; clearlist(); delete head; head = NULL; &#125;template&lt;class T&gt;inline int CirList&lt;T&gt;::listsize()&#123; return size;&#125;template&lt;class T&gt;inline bool CirList&lt;T&gt;::listempty() const&#123; return (size == 0);&#125;template&lt;class T&gt;inline ListNode&lt;T&gt;* CirList&lt;T&gt;::index(int pos)&#123; if (pos == -1) &#123; return head; &#125; if (pos&lt;0 || pos&gt;size) &#123; cout &lt;&lt; "illegal operator" &lt;&lt; endl; exit(1); &#125; currPtr = head-&gt;next; int i = 0; while (currPtr != NULL &amp; i &lt; pos) &#123; currPtr = currPtr-&gt;next; i++; &#125; return currPtr;&#125;template&lt;class T&gt;inline void CirList&lt;T&gt;::insert(const T &amp; item, int pos)&#123; if (pos&lt;0 || pos&gt;size) &#123; cout &lt;&lt; "illegal operator" &lt;&lt; endl; exit(1); &#125; ListNode&lt;T&gt; *p = index(pos - 1); ListNode&lt;T&gt; *newnode = new ListNode&lt;T&gt;(item, p-&gt;next); p-&gt;next = newnode; size++;&#125;template&lt;class T&gt;inline T CirList&lt;T&gt;::del(int pos)&#123; if (pos&lt;0 || pos&gt;size) &#123; cout &lt;&lt; "illegal operator" &lt;&lt; endl; exit(1); &#125; ListNode&lt;T&gt; *p = index(pos-1); ListNode&lt;T&gt; *q; q = p-&gt;next; p-&gt;next = q-&gt;next; T data = q-&gt;data; delete q; size--; return data;&#125;template&lt;class T&gt;inline T CirList&lt;T&gt;::getdata(int pos) const&#123; ListNode&lt;T&gt; *p = index(pos); return p-&gt;data;&#125;template&lt;class T&gt;inline void CirList&lt;T&gt;::clearlist()&#123; ListNode&lt;T&gt; *p, *p1; p = head-&gt;next; while (p != head) &#123; p1 = p; p= p-&gt;next; delete p1; &#125; size = 0;&#125;template&lt;class T&gt;inline ListNode&lt;T&gt;* CirList&lt;T&gt;::reset()&#123; currPtr = head-&gt;next; return currPtr;&#125;template&lt;class T&gt;inline ListNode&lt;T&gt;* CirList&lt;T&gt;::next()&#123; if (currPtr != NULL) &#123; currPtr = currPtr-&gt;next; &#125; return currPtr;&#125;template&lt;class T&gt;inline bool CirList&lt;T&gt;::EndOfList() const&#123; return (currPtr == head);&#125;template&lt;class T&gt;inline bool CirList&lt;T&gt;::nextEndofList() const&#123; return (currPtr-&gt;next == head);&#125;template&lt;class T&gt;inline T CirList&lt;T&gt;::delAfter()&#123;//删除currpter-&gt;next,并返回currptr-&gt;next-&gt;data if (currPtr-&gt;next != NULL) &#123; ListNode&lt;T&gt; *p = currPtr-&gt;next; currPtr-&gt;next = p-&gt;next; T data = p-&gt;data; delete p; size--; return data; &#125;&#125; 4.测试主函数 1234567891011121314151617181920212223242526272829303132void test()&#123; CirList&lt;int&gt; list; cout &lt;&lt; "当前链表中的元素有" &lt;&lt; list.listsize() &lt;&lt; endl; for (int i = 0; i &lt; 10; i++) &#123; list.insert(10 * i, i); &#125; list.insert(100, 0); cout &lt;&lt; "当前链表中的元素有" &lt;&lt; list.listsize() &lt;&lt; endl; ListNode&lt;int&gt; *p = list.reset(); while (!list.EndOfList()) &#123; cout &lt;&lt; p-&gt;data &lt;&lt; endl; p = list.next(); &#125; cout&lt;&lt; list.del(1)&lt;&lt;"已被删除"&lt;&lt;endl; while (!list.EndOfList()) &#123; cout &lt;&lt; p-&gt;data &lt;&lt; endl; p = list.next(); &#125; cout &lt;&lt; list.index(5)-&gt;data &lt;&lt; endl;&#125;int main()&#123; test(); system("pause"); return EXIT_SUCCESS;&#125; 输出结果如下：]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>单循环链表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[顺序表的简单实现]]></title>
    <url>%2F2019%2F%E9%A1%BA%E5%BA%8F%E8%A1%A8%E7%9A%84%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[写在前面 &emsp;&emsp;数据结构是一个数据对象，同时这个对象的实例以及构成实例的元素都存在着联系，而且这些联系是由相关函数来规定的。&emsp;&emsp;研究数据结构，关心的是数据对象（实际上是实例）的描述以及相关函数的具体实现。数据对象描述得好，函数的实现就会高效。&emsp;&emsp;最常用的数据对象以及操作都已经在C++中作为基本数据类型而实现，如整数对象，布尔对象等。其他数据对象均可以用基本数据类型以及由C++的类、数组和指针所提供的组合功能来实现。 1.线性表的数据结构 &emsp;&emsp;线性表（linear list)也称有序表，它的每一个实例都是元素的一个有序集合。&emsp;&emsp;对线性表实施的操作有： 创建一个线性表 撤销一个线性表 确定线性表是否为空 确定线性表的长度 按给定的索引查找一个元素 按一个给定的元素查找其索引 按一个给定的索引删除一个元素 按一个给定的索引插入一个元素 从左至右顺序输出线性表元素 &emsp;&emsp;用顺序存储结构存储的表称为顺序表（sequent list）。顺序表中任意数据元素的存取和访问都可以通过它的位置指针来（即数组下标）进行访问。对顺序表中元素访问的效率是一个比较重要的问题。通常情况下，有序顺序表的访问效率大大高于无序顺序表的访问效率。 2.顺序表的类定义 12345678910111213141516171819typedef int Seqlist_Entry;const int maxsize = 10;class Seqlist&#123;public: Seqlist();//构造函数 ~Seqlist();//析构函数 int listsize()const;//返回元素的个数 bool listempty() const;//判断表是否为空 int find(const Seqlist_Entry &amp;item);//返回元素item在表中的位置 Seqlist_Entry getdata(int pos) const;//返回位置pos的元素 void insert(const Seqlist_Entry &amp;item, int pos);//在位置pos处插入元素item Seqlist_Entry Delete(const int pos);//删除位置pos的元素并返回 void clearlist();//清空表 void showall() const;//输出表private: Seqlist_Entry data[maxsize]; int size;//数据元素的个数&#125;; 3.顺序表的类实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104//构造函数Seqlist::Seqlist()&#123; size = 0;&#125;//析构函数Seqlist::~Seqlist() &#123;&#125;//返回顺序表元素的个数int Seqlist::listsize() const&#123; return size;&#125;//判断顺序表是否为空bool Seqlist::listempty() const&#123; return (size == 0);&#125;//查找item，并返回位置索引int Seqlist::find(const Seqlist_Entry &amp; item)&#123; if (size == 0) &#123; cout &lt;&lt; "list is empty " &lt;&lt; endl; &#125; int i = 0; while (i &lt; size&amp;&amp;item != data[i]) &#123; i++; &#125; if (i &lt; size) return i; else cout &lt;&lt; "illegal operator" &lt;&lt; endl;&#125;//取出pos位置上的元素Seqlist_Entry Seqlist::getdata(int pos) const&#123; if (pos&lt;0 || pos&gt;size - 1) &#123; cout &lt;&lt; "illegal operator" &lt;&lt; endl; exit(1); &#125; return data[pos];&#125;//在pos位置插入元素itemvoid Seqlist::insert(const Seqlist_Entry &amp; item, int pos)&#123; if (size == maxsize) &#123; cout &lt;&lt; "list is full" &lt;&lt; endl; return; &#125; if (pos&lt;0 || pos&gt;size ) &#123; cout &lt;&lt; "illegal operator" &lt;&lt; endl; return; &#125; for (int i = size; i &gt; pos; i--) &#123; data[i] = data[i - 1]; &#125; data[pos] = item; size++;&#125;//删除pos位置的元素Seqlist_Entry Seqlist::Delete(const int pos)&#123; Seqlist_Entry tmp=data[pos]; if (size == 0) &#123; cout &lt;&lt; "list is empty" &lt;&lt; endl; exit(1); &#125; if (pos&lt;0 || pos&gt;size - 1) &#123; cout &lt;&lt; "illegal operator" &lt;&lt; endl; exit(1); &#125; for (int i = pos; i &lt; size-1; i++) &#123; data[i] = data[i + 1]; &#125; size--; return tmp;&#125;//置顺序表为空void Seqlist::clearlist()&#123; size = 0; cout &lt;&lt; "已清空" &lt;&lt; endl;&#125;//输出顺序表中所有元素void Seqlist::showall() const&#123; if (size == 0) &#123; cout &lt;&lt; "list is empty" &lt;&lt; endl; &#125; for (int i = 0; i &lt; size; i++) &#123; cout &lt;&lt;i&lt;&lt;"号元素:"&lt;&lt; data[i] &lt;&lt; endl; &#125;&#125; 4.测试主函数 123456789101112131415161718192021222324void test()&#123; Seqlist list; for (int i = 0; i &lt; 10; i++) &#123; list.insert(i * 12, i); &#125; for (int i = 0; i &lt; 10; i++) &#123; cout &lt;&lt; list.getdata(i) &lt;&lt; endl; &#125; int tmp = list.Delete(2); cout &lt;&lt; "元素" &lt;&lt; tmp &lt;&lt; "已经被删除了" &lt;&lt; endl; list.showall(); cout&lt;&lt;"84在顺序表的"&lt;&lt;list.find(84)&lt;&lt;"号位置"&lt;&lt;endl; list.clearlist(); list.showall();&#125;int main()&#123; test();&#125; 输出结果如下图：]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>顺序表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[栈的实现]]></title>
    <url>%2F2019%2F%E6%A0%88%E7%9A%84%E5%AE%9E%E7%8E%B0-1%2F</url>
    <content type="text"><![CDATA[写在前面&emsp;栈（Stack)是一种特殊的线性表，是一种只允许在表的一端进行插入和删除操作的线性表。栈中允许进行插入和删除操作的一端称为栈顶，另一端为栈底。栈顶的当前位置是动态的，标识栈顶当前位置的称为栈顶指示器（或栈顶指针）。栈的插入和删除操作通常称为入栈或进栈，栈的删除操作称为出栈或退栈。当栈中没有数据元素时称为空栈。&emsp;&emsp;根据栈的定义，每次进栈的数据元素都放在原当前栈顶元素之前而成为新的栈顶元素，每次退栈的数据元素都是当前栈顶元素，这样，最后进入堆栈的数据元素总是最先出栈，因此栈也被成为后进先出表。 1.栈的基本运算 初始化栈 销毁栈 判断栈是否为空 进栈 出栈 取栈顶元素 2.顺序栈四要素 栈空条件： top==-1 栈满条件： top==max_stack - 1 item进栈操作：top++,将item放在top处 退栈操作：从top处取出元素item，top– 3.类说明 &emsp;对于顺序栈Stack的实现，应创建一个数组来存放栈中的元素，并用一个始终指向栈顶的变量top来表示栈顶的位置。类定义如下： 12345678910111213141516171819202122232425typedef int Stack_Entry;const int max_stack = 10;class Stack&#123;public: Stack(); //构造函数 ~Stack() &#123;&#125;; //析构函数 bool empty() const; //判断栈是否为空 Stack_Entry pop(); //出栈数据元素 Stack_Entry Top(Stack_Entry &amp;item) const; //返回栈顶元素 void push(const Stack_Entry &amp;item); //数据元素item进栈 int getsize() const; //获取栈中元素的个数 void clearstack(); //清空栈private: int top;//栈顶位置指示器 Stack_Entry entry[max_stack];//Stack_Entry类型的数组&#125;; 4.具体实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748Stack::Stack()&#123; top=-1;&#125;bool Stack::empty() const&#123; return (top==-1);&#125;Stack_Entry Stack::pop()&#123; if (top==-1) &#123; cout &lt;&lt; "Stack is empty" &lt;&lt; endl; &#125; return entry[top--]; &#125;Stack_Entry Stack::Top(Stack_Entry &amp; item) const&#123; if (top == -1) &#123; cout &lt;&lt; "Stack is empty" &lt;&lt; endl; &#125; return entry[top];&#125;void Stack::push(const Stack_Entry &amp; item)&#123; if (top == max_stack - 1) &#123; cout &lt;&lt; "Stack is full" &lt;&lt; endl; &#125; top++; entry[top] = item;&#125;int Stack::getsize() const&#123; return top+1;&#125;void Stack::clearstack()&#123; top = -1;&#125; 5.主函数 12345678910111213141516171819202122232425262728293031void test()&#123; Stack stack; for (int i = 0; i &lt; 10; i++) &#123; stack.push(i+10*i); &#125; cout &lt;&lt; "当前栈中元素数为：" &lt;&lt; stack.getsize() &lt;&lt; endl; for (int i = 0; i &lt; 10; i++) &#123; Stack_Entry tmp; tmp = stack.pop(); cout &lt;&lt; "我是" &lt;&lt; i &lt;&lt; "号元素:"&lt;&lt;tmp &lt;&lt; endl; &#125; cout &lt;&lt; "当前栈中元素数为：" &lt;&lt; stack.getsize() &lt;&lt; endl; if (stack.empty()) &#123; cout &lt;&lt; "Stack is empty" &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; "Stack is not empty" &lt;&lt; endl; &#125;&#125;int main()&#123; test(); system("pause"); return EXIT_SUCCESS;&#125; 输出结果如下图：]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>数据结构</tag>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[单链表的实现]]></title>
    <url>%2F2019%2F%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[写在前面&emsp;链式存储结构是计算机中另一种最基本和最主要的数据存储结构。和顺序存储结构不同，初始化时链式存储结构为空链，每当有新的元素需要存储时用户向系统动态申请所需的存储空间插入链中。所有高级程序设计语言都为用户提供了向系统动态申请和动态释放存储空间的办法。C++提供了new和delete运算符，分别用于向系统动态申请所需存储空间和动态释放用new申请的存储空间。new能自动计算要分配的类型大小并自动返回正确的指针类型。delete能自动释放由new分配的存储空间。&emsp;&emsp;在顺序存储结构中，用户向系统申请一块地址连续的有限空间用于存储数据元素，这样任意两个在逻辑上相邻的数据元素在物理上也必然相邻。但在链式存储结构中，由于它在初始化时为空链，每当有新的数据元素需要存储时用户才向系统动态申请所需的存储空间插入链中，而这些在不同时刻向系统动态申请的存储空间在内存上很可能是不连续的。因此，在链式存储结构中，任意两个在逻辑上相邻的数据元素在物理上不一定相邻，数据元素的逻辑次序是通过链中的指针连接实现的。 &emsp;&emsp;链式存储结构存储线性结构数据元素集合的方法是用节点（Node)构造链。线性结构数据元素的特点是：除第一个和最后一个元素外，每个元素只有一个唯一的前驱和一个唯一的后继。链式结构中每个节点除数据域外，还有一个或两个以上的指针域，数据域用来存放数据元素，指针域用来构造数据元素之间的关系。 1.单链表 &emsp;单链表简称链表（linked list)，是表数据元素的单链结构存储。链表使用一个一个的节点链接构成的。&emsp;&emsp;表要求允许在任意位置进行插入和删除。当选用带头节点的单链表时，在第一个位置插入节点和在其他位置插入节点一样不会改变头指针head的值，此时改变的是head-&gt;next的值。&emsp;在第一个位置删除节点和在其他位置删除节点一样也不会改变头指针head的值，此时改变的也是head-&gt;next的值。 2.节点类的定义和实现 &emsp;在单链表中，每个节点构成包括数据域和指针域两部分。每个节点的基本操作包括构造一个节点对象、建立一个新节点、给出当前节点的下一个节点指针等。 1234567891011121314151617181920212223template&lt;class T&gt;class ListNode&#123; friend class LinList&lt;T&gt;;//声明友元类public: T data;//数据域 ListNode(ListNode&lt;T&gt; *ptrNext = NULL);//构造函数，用于构造头节点，头节点没有data参数 ListNode(const T &amp;item, ListNode&lt;T&gt; *ptrNext = NULL);//构造函数，主要用于构造非头节点的节点 ~ListNode() &#123;&#125;;//析构函数private: ListNode&lt;T&gt; *next;//指向下一节点的指针&#125;;template&lt;class T&gt;inline ListNode&lt;T&gt;::ListNode(ListNode&lt;T&gt;* ptrNext):next(ptrNext)&#123;&#125;//构造函数，用于构造头节点，头节点没有值template&lt;class T&gt;inline ListNode&lt;T&gt;::ListNode(const T &amp; item, ListNode&lt;T&gt;* ptrNext)&#123;//构造函数，用于构造非头节点的节点 data = item; next = ptrNext;&#125; &emsp;节点类的成员有data域和next域。data域中存放了该节点的数据值，由于应用问题中需要使用链表中的data值，所以定义为公有数据成员方便使用；next域定义为私有数据成员。节点类的成员函数由两个不同参数的构造函数和空的析构函数。析构函数为空是因为节点类中没有用new函数向系统申请空间，而节点对象本身分配的空间，系统可自动识别释放。 3.单链表类的定义 12345678910111213141516171819202122232425template&lt;class T&gt;class LinList&#123;public: LinList();//构造函数 ~LinList();//析构函数 //表操作成员函数 int listsize() const;//返回链表中元素的个数 bool listempty() const;//链表是否为空 ListNode&lt;T&gt; *index(int pos);//返回指向第pos个节点的指针 void insert(const T&amp; item, int pos);//在pos节点前插入一个data域为item的元素 T Delete(int pos);//删除第pos个节点并返回被删除节点的data域 T getdata(int pos);//返回第pos个节点的data值 void clearlist();//清空表为初始化状态 //遍历链表的成员函数 ListNode&lt;T&gt; *Reset(int pos = 0);//currPtr指向节点pos并返回currPtr ListNode&lt;T&gt; *Next();//currPtr指向下一个节点并返回currPtr bool endOfList() const;//currPtr==head？private: ListNode&lt;T&gt; *head;//指向头节点的指针 ListNode&lt;T&gt; *currPtr;//当前指针 int size;//单链表中元素的个数&#125;; &emsp;单链表类的数据成员有头指针、元素个数和当前节点指针。头指针指向头结点，任何对单链表中节点的操作都要从头指针进入。初始化状态下，节点个数为0.当前节点指针是遍历链表成员函数使用的数据成员，遍历链表成员函数通过控制当前节点指针来遍历链表。&emsp;&emsp;单链表类的成员函数由三组：构造函数和析构函数、表操作的成员函数和遍历链表的成员函数。由于单链表类中的节点是通过new函数向系统申请的，在释放单链表类对象的时候，系统无法自行释放这些空间，所以析构函数不能为空，析构函数必须用delete函数逐个释放这些空间。表操作成员函数时对表操作的基本成员函数，这与顺序表类中对表进行操作的成员函数意义相同，但是实现方法不同。链表的遍历操作是每次寻找当前节点的下一个节点，由于每次对链表类中节点的操作都要从头指针进入后寻找到相应的节点后才可完成，这样的单链表类遍历操作的时间复杂度返回大大增加，在单链表中增加一组遍历链表的成员函数可使单链表遍历操作的时间复杂度不增加。 4.单链表类的实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141template&lt;class T&gt;inline LinList&lt;T&gt;::LinList()&#123; head = new ListNode&lt;T&gt;();//头指针指向头结点 size = 0;&#125;template&lt;class T&gt;inline LinList&lt;T&gt;::~LinList()&#123; clearlist(); delete head; head = NULL;&#125;template&lt;class T&gt;inline int LinList&lt;T&gt;::listsize() const//返回单链表中元素的个数&#123; return size;&#125;template&lt;class T&gt;inline bool LinList&lt;T&gt;::listempty() const&#123; return size == 0;&#125;template&lt;class T&gt;inline ListNode&lt;T&gt;* LinList&lt;T&gt;::index(int pos)&#123; if (pos == -1) return head; if (pos&lt;0 || pos&gt;size) &#123; cout &lt;&lt; "illegal operator" &lt;&lt; endl; exit(1); &#125; ListNode&lt;T&gt; *p = head-&gt;next;//p指向第一个节点 int i = 0; while (p != NULL &amp;&amp; i &lt; pos) &#123; p = p-&gt;next; i++; &#125; return p;&#125;template&lt;class T&gt;inline void LinList&lt;T&gt;::insert(const T &amp; item, int pos)&#123; ListNode&lt;T&gt; *p = index(pos - 1); ListNode&lt;T&gt; *newnode = new ListNode&lt;T&gt;(item, p-&gt;next); p-&gt;next = newnode; size++;&#125;template&lt;class T&gt;inline T LinList&lt;T&gt;::Delete(int pos)&#123; if (size == 0) &#123; cout &lt;&lt; "list is empty" &lt;&lt; endl; exit(1); &#125; ListNode&lt;T&gt;*q, *p = index(pos - 1);//p为指向第pos-1个节点的指针 q = p-&gt;next;//q指向要删除节点 p-&gt;next = p-&gt;next-&gt;next;//p指向要删除节点的后一节点 T data = q-&gt;data; //data保存要删除节点值 delete q; size--; return data;&#125;template&lt;class T&gt;inline T LinList&lt;T&gt;::getdata(int pos)&#123; ListNode&lt;T&gt; *p = index(pos);//指针p指向第pos个节点 return p-&gt;data;&#125;template&lt;class T&gt;inline void LinList&lt;T&gt;::clearlist()&#123; ListNode&lt;T&gt; *p, *p1; p = head-&gt;next; while (p != NULL) &#123;//delete所有new出来的空间 p1 = p; p = p-&gt;next; delete p1; &#125; size = 0;&#125;template&lt;class T&gt;inline ListNode&lt;T&gt;* LinList&lt;T&gt;::Reset(int pos)&#123; if (head == NULL) return NULL; if (pos &lt; -1 || pos&gt;size) &#123; cout &lt;&lt; "mistake" &lt;&lt; endl; exit(1); &#125; if (pos == -1) return head; if (pos == 0) &#123; currPtr = head-&gt;next; &#125; else &#123; currPtr = head-&gt;next; ListNode&lt;T&gt; prevPtr = head; for (int i = 0; i &lt; pos; i++) &#123; prevPtr = currPtr; currPtr = currPtr-&gt;next; &#125; &#125; return currPtr;&#125;template&lt;class T&gt;inline ListNode&lt;T&gt;* LinList&lt;T&gt;::Next()&#123; if (currPtr != NULL) &#123; currPtr = currPtr-&gt;next; &#125; return currPtr;&#125;template&lt;class T&gt;inline bool LinList&lt;T&gt;::endOfList() const&#123; return currPtr == NULL;&#125; &emsp;&emsp;这些成员函数基本上实现了单链表所需的基本操作。 5.主函数测试 测试主函数如下： 123456789101112131415161718192021222324252627void test()&#123; LinList&lt;int&gt; list; cout &lt;&lt; "单链表中的元素个数为："&lt;&lt;list.listsize() &lt;&lt; endl; for (int i = 0; i &lt; 10; i++) &#123; list.insert(15 * i, i); &#125; cout &lt;&lt; "单链表中的元素个数为：" &lt;&lt; list.listsize() &lt;&lt; endl; cout &lt;&lt; "5号为：" &lt;&lt; list.getdata(5) &lt;&lt; endl; cout&lt;&lt;list.Delete(5)&lt;&lt;"已被删除"&lt;&lt;endl; cout &lt;&lt; "5号为：" &lt;&lt; list.getdata(5) &lt;&lt; endl; ListNode&lt;int&gt; *p = list.Reset(); while (!list.endOfList()) &#123; cout &lt;&lt; p-&gt;data &lt;&lt; endl; p = list.Next(); &#125;&#125;int main()&#123; test(); system("pause"); return EXIT_SUCCESS;&#125; 输出结果如下：]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>数据结构</tag>
        <tag>单链表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[运算符重载（2）]]></title>
    <url>%2F2019%2F%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD%EF%BC%882%EF%BC%89%2F</url>
    <content type="text"><![CDATA[5.左移(输出）运算符重载 &emsp;&emsp;如我们所知，IO标准库分别使用&gt;&gt;和&lt;&lt;执行输入输出操作。对于这两个运算符来说，IO库定义了其用读写内置类型的版本，但是类则需自定义适合其对象的新版本支持IO操作。&emsp;&emsp;通过情况下左移运算符的第一形参是一个非常量ostream的引用。而ostream是非常量的原因是向流写入内容会改变其状态。而该形参是引用，是因为我们无法直接复制一个ostream对象。&emsp;&emsp;第二个形参一般来说是一个常量的引用，该常量是我们想要打印的类类型。第二个形参是引用的原因是我们希望避免复制实参，而形参为常量是因为打印对象不会改变对象的内容。举例如下： 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;iostream&gt;#include&lt;string&gt;using namespace std;class Person&#123; friend ostream &amp;operator&lt;&lt;(ostream &amp;cout, const Person &amp;p);public: Person(string name, int age);private: string m_name; int m_age;&#125;;Person::Person(string name, int age)&#123; this-&gt;m_name = name; this-&gt;m_age = age;&#125;ostream &amp;operator&lt;&lt;(ostream &amp;cout, const Person &amp;p)&#123; cout &lt;&lt; p.m_name &lt;&lt; "的年龄为：" &lt;&lt; p.m_age &lt;&lt; endl; return cout;&#125;void test()&#123; Person p("Aoki", 20); cout &lt;&lt; p; cout &lt;&lt; "Hello world" &lt;&lt; endl;&#125;int main()&#123; test(); system("pause"); return EXIT_SUCCESS;&#125; 输出结果如下： 6.右移（输入）运算符重载 &emsp;&emsp;通常情况下，输入运算符的第一个形参是运算符简要读取的流的引用，第二个形参是将要读入的非常量对象的引用。该运算符通常会返回某个给定流的引用。第二个形参之所以必须是个非常量是因为输入运算符本身的目的就是将数据读入到这个对象中。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include &lt;iostream&gt;#include&lt;string&gt;using namespace std;class Person&#123; friend istream &amp;operator&gt;&gt;(istream &amp;cin, Person &amp;p);public: Person ()&#123;&#125; Person(string name, int age); void Show();private: string m_name; int m_age;&#125;;Person::Person(string name, int age)&#123; this-&gt;m_name = name; this-&gt;m_age = age;&#125;istream &amp; operator&gt;&gt;(istream &amp; cin, Person &amp; p)&#123; string name; int age; cin &gt;&gt; name &gt;&gt; age; if (cin) &#123; p.m_name = name; p.m_age = age; &#125; else &#123; p = Person();//如果输入失败，对象被赋予默认状态 &#125; return cin;&#125;void Person::Show()&#123; cout &lt;&lt; this-&gt;m_name &lt;&lt; "的年龄是：" &lt;&lt; this-&gt;m_age &lt;&lt; endl;&#125;void test()&#123; Person p1; cin &gt;&gt; p1; p1.Show();&#125;int main()&#123; test(); system("pause"); return EXIT_SUCCESS;&#125; 输出结果如下：&emsp;&emsp;可以注意到，在输入运算符重载中，有输入失败的处理。那么输入时可能会发生什么错误呢？ 当流含有错误类型的数据时读取操作可能失败 当读取操作到达文件末尾或遇到输入流的其他错误时也会失败 &emsp;&emsp;在程序中我们没有逐个检查每个读取操作，而是等读取了所有数据之后赶在使用这些数据前面进行了一次性的检查。&emsp;&emsp;如果在发生错误之前对象已经有一部分改变，则适时地将对象置为合法状态显得异常重要。&emsp;&emsp;通过将对象置为合法状态，我们能保护使用者免受到输入错误的影响。此时的对象处于可用状态，即它的成员都是被正确定义的。而且该对象也不会产生误导性结果，因为它的数据本质上是一致的。 7.指针运算符重载 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879#include &lt;iostream&gt;#include&lt;string&gt;using namespace std;class Person&#123;public: Person(string name, int age); void Display();private: string m_name; int m_age;&#125;;class SmartPointer&#123;public: SmartPointer(Person *person); Person* operator-&gt;(); Person&amp; operator*(); ~SmartPointer();public: Person *pPerson;&#125;;Person::Person(string name, int age)&#123; this-&gt;m_name = name; this-&gt;m_age = age;&#125;void Person::Display()&#123; cout &lt;&lt; this-&gt;m_name &lt;&lt; "的年龄是：" &lt;&lt; this-&gt;m_age &lt;&lt; endl;&#125;SmartPointer::SmartPointer(Person * person)&#123; this-&gt;pPerson = person;&#125;Person * SmartPointer::operator-&gt;()&#123; //重载指针的-&gt;运算符 return pPerson;&#125;Person &amp; SmartPointer::operator*()&#123; //重载指针的*运算符 return *pPerson;&#125;SmartPointer::~SmartPointer()&#123; if (pPerson != NULL) &#123; delete pPerson; &#125;&#125;void test()&#123; Person *person = new Person("Aoki", 20); //如果忘记释放，那么就会造成内存泄漏 SmartPointer poiner(new Person("Aoki", 20)); poiner-&gt;Display();&#125;int main()&#123; test(); system("pause"); return EXIT_SUCCESS;&#125; 输出结果如下： 8.赋值运算符重载 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#define _CRT_SECURE_NO_WARNINGS#include &lt;iostream&gt;#include&lt;string&gt;using namespace std;class Person&#123;public: Person(const char *name); Person&amp; operator=(const Person &amp;p); ~Person();public: char *name;&#125;;Person::Person(const char * name)&#123; this-&gt;name = new char[strlen(name) + 1]; strcpy(this-&gt;name, name);&#125;Person &amp; Person::operator=(const Person &amp; p)&#123; if (this-&gt;name != NULL) &#123;//判断原来堆区中是否有内容，如果有，先释放 delete[] this-&gt;name; this-&gt;name = NULL; &#125; this-&gt;name = new char[strlen(p.name) + 1]; strcpy(this-&gt;name, p.name); return *this;&#125;Person::~Person()&#123; if (this-&gt;name != NULL) &#123; delete[] this-&gt;name; this-&gt;name = NULL; &#125;&#125;void test()&#123; Person p1("Aoki"); Person p2("青木"); p1 = p2; cout &lt;&lt; p1.name &lt;&lt; endl; cout &lt;&lt; p2.name &lt;&lt; endl;&#125;int main()&#123; test(); system("pause"); return EXIT_SUCCESS;&#125; 输出结果如下：]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>运算符重载</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[运算符的重载（1）]]></title>
    <url>%2F2019%2F%E8%BF%90%E7%AE%97%E7%AC%A6%E7%9A%84%E9%87%8D%E8%BD%BD%EF%BC%881%EF%BC%89%2F</url>
    <content type="text"><![CDATA[写在前面 &emsp;&emsp;运算符重载，就是对已有的运算符重新进行定义，赋予其另一种功能，以适应不同的数据类型。&emsp;&emsp;运算符重载（operator overloading)只是一种“语法上的方便”,也就它只是另一种函数调用的方式。&emsp;&emsp;在C++中，可以定义一个处理类的新运算符。这种定义很像一个普通的函数定义，只是函数的名字由关键字operator及其紧跟的运算符组成。差别仅此而已。它像任何其他函数一样也是一个函数，当编译器遇到适当的模式时，就会调用这个函数。&emsp;&emsp;重载运算符的参数数量与该运算符作用的对象数量一样多。一元运算符有一个参数，二元运算符有两个参数。对于二元运算符来说，左侧运算符对象传递给第一个参数，而右侧运算符对象传递给第二个参数。除了重载的函数调用运算符operator()之外，其他重载运算符不能含有默认实参。&emsp;&emsp;如果一个重载运算符函数时成员函数，则它的第一个（左侧）运算符对象绑定到隐式地this指针上，因此，成员运算符函数的（显式）参数数量比运算符的运算对象总数少一个。 1.关系运算符重载 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include &lt;iostream&gt;#include&lt;string&gt;using namespace std;class Person&#123;public: Person(string name, int age); bool operator==(Person &amp;p);//==运算符重载 bool operator!=(Person &amp;p);//！=运算符重载 private: string m_Name; int m_Age;&#125;;Person::Person(string name, int age)&#123; this-&gt;m_Name = name; this-&gt;m_Age = age;&#125;bool Person::operator==(Person &amp; p)&#123; if (this-&gt;m_Name == p.m_Name&amp;&amp;this-&gt;m_Age == p.m_Age) &#123; return true; &#125; return false;&#125;bool Person::operator!=(Person &amp; p)&#123; if (this-&gt;m_Name == p.m_Name&amp;&amp;this-&gt;m_Age == p.m_Age) &#123; return false; &#125; return true;&#125;void test()&#123; Person p1("Aoki", 22); Person p2("Aoki", 22); Person p3("Aoki", 20); if (p1 == p2) &#123; cout &lt;&lt; "p1和p2相等" &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; "p1和p2不相等" &lt;&lt; endl; &#125; if (p1 != p3) &#123; cout &lt;&lt; "p1和p3不相等" &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; "p1和p3相等" &lt;&lt; endl; &#125;&#125;int main()&#123; test();&#125; 输出结果如下： 2.自增自减运算符重载 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#include &lt;iostream&gt;#include&lt;string&gt;using namespace std;class Person&#123;public: Person()&#123;&#125; Person(string name, int age); Person operator++();//前置++运算符 Person operator--();//前置--运算符重载 Person operator++(int);//后置++运算符重载 Person operator--(int);//后置--运算符重载 void show();private: string m_Name; int m_Age;&#125;;Person::Person(string name, int age)&#123; this-&gt;m_Name = name; this-&gt;m_Age = age;&#125;Person Person::operator++()&#123; m_Age++; return *this;&#125;Person Person::operator--()&#123; m_Age--; return *this;&#125;Person Person::operator++(int)&#123; Person tmp; tmp.m_Age = this-&gt;m_Age; m_Age++; return tmp;&#125;Person Person::operator--(int)&#123; Person tmp; tmp.m_Age = this-&gt;m_Age; m_Age--; return tmp;&#125;void Person::show()&#123; cout &lt;&lt; this-&gt;m_Name &lt;&lt; "的年龄为" &lt;&lt; this-&gt;m_Age &lt;&lt; endl;&#125;void test()&#123; Person p1("Aoki",22); p1++; p1.show(); p1--; p1.show(); --p1; p1.show(); ++p1; p1.show();&#125;int main()&#123; test(); return 0;&#125; 输出结果如下：优先使用++和–的标准形式，优先调用前置++&emsp;&emsp;如果定义了++c，也要定义c++，递增操作符比较麻烦，因为他们都有前缀和后缀形式，而两种语义略有不同。重载123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&amp;emsp;&amp;emsp;对于++和--而言，后置形式是先返回，然后对象++或--，返回的是对象的原值。前置形式，对象先++或--，然后返回当前对象，返回的是新对象。 &amp;emsp;&amp;emsp;调用代码的时候，要优先使用前缀形式，除非确实需要后缀形式返回的原值，，前缀和后缀形式语义上是等价的，输入工作量也相当，只是效率经常会略高一些，由于前缀形式少创建了一个临时对象。 &lt;br /&gt;&lt;br /&gt;&gt; # 3.加号运算符重载 &lt;br /&gt;```c++#include &lt;iostream&gt;#include&lt;string&gt;using namespace std;class Person&#123;public: Person() &#123;&#125;; Person(string a, int b) :m_name(a), m_age(b) &#123;&#125; Person operator+(Person &amp;p);public: string m_name; int m_age;&#125;;Person Person::operator+(Person &amp; p)&#123; Person tmp; tmp.m_age = this-&gt;m_age + p.m_age; tmp.m_name = this-&gt;m_name + p.m_name; return tmp;&#125;void test()&#123; Person p1(&quot;Ao&quot;, 20); Person p2(&quot;ki&quot;,10); Person p3 = p1 + p2; cout &lt;&lt; &quot;p3的名字为：&quot; &lt;&lt; p3.m_name &lt;&lt; &quot;,p3的年龄为&quot; &lt;&lt; p3.m_age &lt;&lt; endl;&#125;int main()&#123; test(); return 0;&#125; 输出结果如下： 下面也是加号运算符重载的一些方法： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include &lt;iostream&gt;#include&lt;string&gt;using namespace std;class Person&#123;public: Person() &#123;&#125;; Person(string a, int b) :m_name(a), m_age(b) &#123;&#125; //Person operator+(Person &amp;p);public: string m_name; int m_age;&#125;;////Person Person::operator+(Person &amp; p)//&#123;// Person tmp;// tmp.m_age = this-&gt;m_age + p.m_age;// tmp.m_name = this-&gt;m_name + p.m_name;// return tmp;//&#125;Person operator+(Person &amp;p1, Person &amp;p2)&#123; Person tmp; tmp.m_age = p1.m_age + p2.m_age; tmp.m_name = p1.m_name + p2.m_name; return tmp;&#125;Person operator+(Person &amp;p1, int a)&#123; Person tmp; tmp.m_age = p1.m_age + a; tmp.m_name = p1.m_name; return tmp;&#125;void test()&#123; Person p1("Ao", 20); Person p2("ki",10); Person p3 = p1 + p2; Person p4 = p2 + 10; cout &lt;&lt; "p3的名字为：" &lt;&lt; p3.m_name &lt;&lt; ",p3的年龄为" &lt;&lt; p3.m_age &lt;&lt; endl; cout &lt;&lt; "p4的名字为：" &lt;&lt; p4.m_name &lt;&lt; ",p4的年龄为" &lt;&lt; p4.m_age &lt;&lt; endl;&#125;int main()&#123; test(); return 0;&#125; 输出结果如下： 4.减号运算符重载 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include &lt;iostream&gt;#include&lt;string&gt;using namespace std;class Person&#123;public: Person() &#123;&#125;; Person(string a, int b) :m_name(a), m_age(b) &#123;&#125; //Person operator+(Person &amp;p);public: string m_name; int m_age;&#125;;//Person Person::operator+(Person &amp; p)//&#123;// Person tmp;// tmp.m_age = this-&gt;m_age + p.m_age;// tmp.m_name = this-&gt;m_name + p.m_name;// return tmp;//&#125;Person operator-(Person &amp;p1, Person &amp;p2)&#123; Person tmp; tmp.m_age = p1.m_age - p2.m_age; tmp.m_name = p1.m_name + p2.m_name; return tmp;&#125;Person operator-(Person &amp;p1, int a)&#123; Person tmp; tmp.m_age = p1.m_age - a; tmp.m_name = p1.m_name; return tmp;&#125;void test()&#123; Person p1("Ao", 20); Person p2("ki",10); Person p3 = p1 - p2; Person p4 = p2 -1; cout &lt;&lt; "p3的名字为：" &lt;&lt; p3.m_name &lt;&lt; ",p3的年龄为" &lt;&lt; p3.m_age &lt;&lt; endl; cout &lt;&lt; "p4的名字为：" &lt;&lt; p4.m_name &lt;&lt; ",p4的年龄为" &lt;&lt; p4.m_age &lt;&lt; endl;&#125;int main()&#123; test(); return 0;&#125; 输出结果如下:]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>运算符重载</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[友元]]></title>
    <url>%2F2019%2F%E5%8F%8B%E5%85%83%2F</url>
    <content type="text"><![CDATA[写在前面 &emsp;&emsp;类的主要特点之一就是数据隐藏，即类的私有成员无法在类的外部（作用域之外）访问。但是，有时候需要在类的外部访问类的私有数据成员，怎么办呢？&emsp;&emsp;解决办法是使用友元函数，友元函数时一种特权函数c，C++允许这个特权函数访问私有成员。这一点我们可以用生活中的例子来看：&emsp;&emsp;比如你的家有客厅，有卧室，客厅是public的，所有来的客人都可以进去，但是你的卧室是私有的，也就是说只有你能进去，但是，你可以允许你的好朋友进去。&emsp;&emsp;程序员可以把一个全局函数、某个类中的成员函数、甚至整个类声明为友元。 1.全局函数做友元函数 友元语法 friend关键字只出现在声明处 其他类、类成员函数、全局函数都可以声明为友元 友元函数不是类的成员，不带this指针 1234567891011121314151617181920212223242526272829303132#include &lt;iostream&gt;#include&lt;string&gt;using namespace std;class Home&#123;public: friend void test(Home *home); Home() &#123; this-&gt;bedroom = "卧室"; this-&gt;sittingroom = "客厅"; &#125; string sittingroom;//客厅private: string bedroom;//卧室 &#125;;void test(Home *home)&#123; cout &lt;&lt; "你的好友正在访问" &lt;&lt; home-&gt;sittingroom &lt;&lt; endl; cout &lt;&lt; "你的好友正在访问" &lt;&lt; home-&gt;bedroom &lt;&lt; endl;&#125;int main()&#123; Home *home=new Home; test(home);&#125; 输出结果如下： 从输出结果可以看出，当全局函数作为声明为友元函数之后，全局函数也可以访问类的私有成员。 2.整个类做友元类 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;iostream&gt;#include&lt;string&gt;using namespace std;class Home&#123;public: friend class Good_Friend; Home() &#123; this-&gt;bedroom = "卧室"; this-&gt;sittingroom = "客厅"; &#125; string sittingroom;//客厅private: string bedroom;//卧室 &#125;;class Good_Friend&#123;public: Good_Friend(string name) &#123; this-&gt;name = name; &#125; void visit() &#123; cout &lt;&lt; "好友"&lt;&lt;this-&gt;name&lt;&lt;"正在拜访" &lt;&lt; this-&gt;home.sittingroom &lt;&lt; endl; cout &lt;&lt; "好友"&lt;&lt;this-&gt;name&lt;&lt;"正在拜访" &lt;&lt; this-&gt;home.bedroom &lt;&lt; endl; &#125;private: Home home; string name;&#125;;void test()&#123; Good_Friend frend("Aoki"); frend.visit();&#125;int main()&#123; test();&#125; &emsp;&emsp;输出结果如下：&emsp;&emsp;将好友类声明为友元类之后，好友类的对象可以访问Home类的私有成员。&emsp;&emsp;在友元类中我们应当注意： 友元关系不能被继承 友元关系是单向的 友元关系不具有传递性 C++是纯面向对象的吗？&emsp;&emsp;如果一个类被声明为friend，意味着它不是这个类的成员函数，却可以是修改这个类的私有成员，而且必须列在类的定义中，因此它是一个特权函数。C++不是完全的面向对象语言，而是一个混合产品。增加friend关键字只是用来解决一些实际问题，这也说明这种语言是不纯的。毕竟C++设计的目的是为了实用性，而不是追求理想的抽象。 -———《Think in C++》 3.成员函数做友元函数 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include &lt;iostream&gt;#include&lt;string&gt;using namespace std;class Home;class Good_Friend&#123;public: Good_Friend(string name); void visit(); void visit2();private: Home *home; string name;&#125;;class Home&#123; friend void Good_Friend::visit();public: Home();public: string sittingroom;private: string bedroom;&#125;;Good_Friend::Good_Friend(string name)&#123; home = new Home; this-&gt;name = name;&#125;void Good_Friend::visit()&#123; cout &lt;&lt; "你的好友" &lt;&lt; this-&gt;name &lt;&lt; "正在访问" &lt;&lt; this-&gt;home-&gt;sittingroom &lt;&lt; endl; cout &lt;&lt; "你的好友" &lt;&lt; this-&gt;name &lt;&lt; "正在访问" &lt;&lt; this-&gt;home-&gt;bedroom &lt;&lt; endl;&#125;void Good_Friend::visit2()&#123; cout &lt;&lt; "你的好友"&lt;&lt;this-&gt;name&lt;&lt;"正在访问" &lt;&lt; this-&gt;home-&gt;sittingroom &lt;&lt; endl; //cout &lt;&lt; "你的好友" &lt;&lt; this-&gt;name &lt;&lt; "正在访问" &lt;&lt; this-&gt;home-&gt;bedroom &lt;&lt; endl;&#125;Home::Home()&#123; this-&gt;sittingroom = "客厅"; this-&gt;bedroom = "卧室";&#125;void test()&#123; Good_Friend frien("Aoki"); frien.visit(); frien.visit2();&#125;int main()&#123; test(); return 0;&#125; &emsp;&emsp;当我们试图使用一个没有声明为Home类友元的成员函数去访问Home的私有成员时，编译器报错如下：正确是输出结果如下：&emsp;&emsp;虽然我现在将visit()函数定义为Home类的友元，但是事情并没有这么简单地结束，因为当我第一次定义友元函数时，编译器莫名其妙地报错。那么，编译器报错的原因是什么呢？&emsp;&emsp;当我尝试着把成员函数的声明与定义分开的时候，编译器显示没有错误。这也就告诉我们，在声明成员函数的时候，将声明与定义分开放，编译器会更好地处理。]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>友元函数</tag>
        <tag>友元类</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++对象模型初探]]></title>
    <url>%2F2019%2FC-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B%E5%88%9D%E6%8E%A2%2F</url>
    <content type="text"><![CDATA[1.成员变量和函数的存储 在C语言中，分开来声明，也就说，语言本身并没有支持“数据”和“函数”之间的关联性，我们把这种程序方法称为“程序性的”，由一组“分布在各个以功能为导向的函数中的算法驱动，它们处理的是共同的外部数据。C++实现了“封装”，那么数据（成员属性）和操作（成员函数）是什么样的呢？“数据”和“处理数据的操作（函数）”是分开存储的。 C++中的非静态数据成员直接内含在类对象中，就像C struct一样 成员函数（member function）虽然内含正在class声明之内，却不出现在对象中 每一个非内联成员函数只会的诞生一份函数实例 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include &lt;iostream&gt;using namespace std;class Myclass&#123;public: int m_A;&#125;;class Myclass1&#123;public: int m_A; static int m_B;&#125;;class Myclass2&#123;public: void test01() &#123; cout &lt;&lt; "001" &lt;&lt; endl; &#125;public: static int m_A;&#125;;class Myclass3&#123;public: static void test02() &#123; cout &lt;&lt; "002" &lt;&lt; endl; &#125;public: int m_A; static int m_B;&#125;;class Myclass4&#123;public: void test03() &#123; cout &lt;&lt; "003" &lt;&lt; endl; &#125; static void test04() &#123; cout &lt;&lt; "004" &lt;&lt; endl; &#125;public: int m_A; static int m_B;&#125;;int main()&#123; Myclass myclass; Myclass1 myclass1; Myclass2 myclass2; Myclass3 myclass3; Myclass4 myclass4; cout &lt;&lt; "size of myclass:" &lt;&lt; sizeof(myclass) &lt;&lt; endl; cout &lt;&lt; "size of myclass1:" &lt;&lt; sizeof(myclass1) &lt;&lt; endl; cout &lt;&lt; "size of myclass2:" &lt;&lt; sizeof(myclass2) &lt;&lt; endl; cout &lt;&lt; "size of myclass3:" &lt;&lt; sizeof(myclass3) &lt;&lt; endl; cout &lt;&lt; "size of myclass4:" &lt;&lt; sizeof(myclass4) &lt;&lt; endl; return 0;&#125; 输出结果如下：从输出结果我们可以看出，C++中成员变量和成员属性是分开存储的。 而且，只有非静态成员才属于对象身上。 2.this指针 通过上面的例子我们知道，C++的数据和操作时分开存储的，并且每个非内联成员函数只会诞生一份函数实例，也就是说多个同类型的对象会共用一块代码。那么问题是，这块代码是如何区分是哪个对象调用自己的呢？C++通过提供特殊的对象指针，this指针，来解决上述问题。this指针指向被调用的成员函数所属的对象。C++规定，this指针是隐含在对象成员函数内的一种指针。当一个对象被创建后，它的每一个成员函数都含有一个系统自动生成的隐含指针this，用以保存这个对象的地址。也就是说，虽然我们没有写上this指针，编译器在编译的时候也会加上的。因此，this指针也被称为“指向本对象的指针”，this指针不并不是对象的一部分，并不会影响sizeof（对象）对的结果。this指针是C++实现封装的一种机制，它将对象和该对象调用的非成员函数连接在一起，在外部看来，每个对象都拥有自己的成员函数。一般情况下，并不写this，而是让系统进行默认设置。this指针永远指向当前对象。 成员函数通过this指针即可知道操作的是哪个对象的数据。this指针是一种隐含指针，它隐含于每个类的非静态成员函数中，this指针无须定义，直接使用即可。静态成员函数内部没有this指针，静态成员函数不能操作非静态成员变量。 3.this指针的使用 当形参和成员变量同名时，可用this指针区分 在类的非静态成员函数中返回对象本身，可用return *this 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;iostream&gt;#include&lt;string&gt;using namespace std;class Person&#123;public: Person(string name, int age) &#123;//当形参与成员变量名相同时，可以使用this指针来区分 this-&gt;age = age; this-&gt;name = name; &#125; Person Person_Plus(Person &amp;person) &#123; string newname = this-&gt;name + person.name; int newage = this-&gt;age + person.age; Person newperson(newname, newage); return newperson; &#125; void show() &#123; cout &lt;&lt; "Name:" &lt;&lt; name &lt;&lt; ",Age:" &lt;&lt; age &lt;&lt; endl; &#125;public: int age; string name;&#125;;void test()&#123; Person person("Aoki", 20); person.show(); Person p1("Aoki", 20); Person p2("青木", 15); Person p3 = p1.Person_Plus(p2); p3.show();&#125;int main()&#123; test();&#125; 输出结果如下： 4.const修饰成员函数（常函数） 用const修饰成员函数时，const修饰this指针指向的内存区域，成员函数体内不可以修改本类中的任何普通变量 当成员变量类型符前面用mutable修饰时例外 12345678910111213141516171819202122232425262728293031323334#include &lt;iostream&gt;using namespace std;class Person&#123;public: Person() &#123; this-&gt;m_A = 0; this-&gt;m_B = 0; &#125; void showinfor () const &#123; //this-&gt;m_B = 10; this-&gt;m_A=100; cout &lt;&lt; "m_A=" &lt;&lt;m_A&lt;&lt; endl; cout &lt;&lt; "m_B=" &lt;&lt; m_B&lt;&lt;endl; &#125; mutable int m_A;//如果需要使用常函数修改变量，加mutable关键字 int m_B;&#125;;void test()&#123; Person p1; p1.showinfor();&#125;int main()&#123; test();&#125; 当我们试图使用常函数对成员变量进行修改时，编译器会报错。报错结果如下图：由此可知，常函数不能修改this指针指向的值。那么，当我们需要使用常函数对成员变量进行修改时呢？那么，我们可以在变量前面加mutable关键字。输出结果如下： 5.const修饰对象（常对象） 常对象只能调用const的成员函数 常对象可访问const或非const数据成员，但是不能修改，除非成员用mutable修饰 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;iostream&gt;using namespace std;class Person&#123;public: Person() &#123; this-&gt;m_A = 0; this-&gt;m_B = 0; &#125; void showinfor () const &#123; //this-&gt;m_B = 10; this-&gt;m_A = 100; cout &lt;&lt; "m_A=" &lt;&lt;m_A&lt;&lt; endl; cout &lt;&lt; "m_B=" &lt;&lt; m_B&lt;&lt;endl; &#125; void show() &#123; cout &lt;&lt; "m_A=" &lt;&lt; this-&gt;m_A &lt;&lt; endl; cout &lt;&lt; "m_B=" &lt;&lt; this-&gt;m_B &lt;&lt; endl; &#125; mutable int m_A;//如果需要使用常函数修改变量，加mutable关键字 int m_B;&#125;;void test()&#123; const Person p1; Person p2; p2.show(); p2.showinfor(); p1.showinfor(); //p1.m_B = 100; p1.m_A = 20; //p1.show(); cout &lt;&lt; "m_A=" &lt;&lt; p1.m_A &lt;&lt; endl; cout &lt;&lt; "m_B=" &lt;&lt; p1.m_B &lt;&lt; endl;&#125;int main()&#123; test();&#125; 当我试图使用常对象来对成员变量进行修改时，编译器报错如下：常对象不能修改没有关键字mutable修饰的成员变量，也就是说，如果一个变量被关键字mutable修改时，那么常对象可以对其进行修改。当我试图使用常对象来访问普通成员函数时，编译器报错如下：也就说，常对象不能调用普通成员函数，它只能调用常函数。最终输出结果如下所示： 5.常函数与常对象的总结 常函数 常函数格式：返回类型 函数名（）const{} 常函数不能修改this指针指向的值 如果需要修改，就必须用关键字mutable来修饰成员变量 常对象 常对象就是在对象前加上const修饰符，如 const Person p1 常对象不可以调用普通成员函数 常对象可以调用常函数 常对象可以修改用mutable关键字修饰的成员变量]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>this指针</tag>
        <tag>常函数</tag>
        <tag>常对象</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[静态成员]]></title>
    <url>%2F2019%2F%E9%9D%99%E6%80%81%E6%88%90%E5%91%98%2F</url>
    <content type="text"><![CDATA[写在前面 在类定义中，它的成员（包括成员变量和成员函数），这些成员可以用关键字static声明为静态的，称为静态成员。不管这个类创建了多少个对象，静态成员只有一个拷贝，这个拷贝被所有属于这个类的对象共享。 1.静态成员变量 在一个类中，若将一个成员变量声明为static，这种成员变量称为静态成员变量。与一般的数据成员不同，无论建立多少个对象，都只有一个静态数据的拷贝。静态成员变量，属于某个类，所有对象共享。静态变量，是在编译阶段就分配空间，对象还没创建，就已经分配空间。 静态成员变量必须在类中声明，在类外定义 静态数据成员不属于某个对象，在为对象分配空间中不包括静态成员所占的空间 静态数据成员可以通过类名或者对象名来引用 123456789101112131415161718192021222324252627282930313233#include &lt;iostream&gt;using namespace std;class Person&#123;public: static int m_Age;private: static int m_other;&#125;;int Person::m_Age = 100;int Person::m_other = 20;void test()&#123; Person p1; p1.m_Age = 10; cout &lt;&lt; "p1=" &lt;&lt; p1.m_Age &lt;&lt; endl; cout &lt;&lt; "p1的地址为：" &lt;&lt; &amp;p1.m_Age &lt;&lt; endl; Person p2; p2.m_Age = 20; cout &lt;&lt; "p1=" &lt;&lt; p1.m_Age &lt;&lt; endl; cout &lt;&lt; "p2=" &lt;&lt; p2.m_Age &lt;&lt; endl; cout &lt;&lt; "p2的地址为：" &lt;&lt; &amp;p2.m_Age &lt;&lt; endl;&#125;int main()&#123; test();&#125; 输出结果如下图：通过输出结果我们可以很清除地看到，静态成员变量是所有对象共享的。任何一个对象都可以改变静态变量的值，但是静态变量不属于任何一个对象。下面我们看一下对象的大小，以此来说明静态数据成员不属于某个对象，在为对象分配的空间中不包括静态成员所占的空间。 12345678910111213141516171819202122232425#include &lt;iostream&gt;using namespace std;class Person&#123;public: static int m_Age;private: static int m_other;&#125;;int Person::m_Age = 100;int Person::m_other = 20;void test()&#123; Person p; cout &lt;&lt; sizeof(p) &lt;&lt; endl; cout &lt;&lt; sizeof(p.m_Age) &lt;&lt; endl;&#125;int main()&#123; test();&#125; 输出结果如下图：我们可以看出，对象的大小为1，而静态成员佰利联的大小为4。当我们尝试去访问m_other时，编译器会报错，因为它是一个私有数据成员，这也说明了静态成员变量是有权限控制机制的。 2.静态成员变量 在类定义中，前面有static说明的成员函数称为静态成员函数。静态成员函数使用方式和静态变量一样，同样在对象没有创建前创建，即可他通过类名调用。静态成员函数主要为了访问静态变量，但是不能访问普通成员变量。静态成员函数的意义，不在于信息共享，数据沟通，而在于管理静态数据成员，完成对静态数据成员的封装。 静态成员函数只能访问静态变量，不能访问普通成员变量 静态成员函数的使用和静态成员变量一样 静态成员函数也有访问权限 普通成员函数可以访问静态成员变量，也可以访问非静态变量 如上图所示，当我们使用静态成员函数试图访问非静态成员变量时，编译器会报错，提示信息如上图所示。在上图中，我试图使用类名来访问私有的静态成员函数，编译器报错，因为静态成员函数也有自己的权限。 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;iostream&gt;using namespace std;class Person&#123;public: static void func()//静态成员函数 &#123; m_Age = 100; //m_A = 20;//作用域 cout &lt;&lt; "静态成员函数调用" &lt;&lt; endl; &#125; static int m_Age; int m_A;private: static int m_other; static void func01() &#123; cout &lt;&lt; "静态成员函数func2调用" &lt;&lt; endl; &#125;&#125;;int Person::m_Age = 100;int Person::m_other = 20;void test()&#123; Person p1; Person p2; p1.func(); p2.func(); Person::func(); //Person::func01();//作用域&#125;int main()&#123; test();&#125; 输出结果如下图： 3.总结 静态成员变量 编译阶段分配内存 所有对象共享数据 通过对象访问，通过类名访问 有权限控制 类内声明，类外初始化 静态成员函数 可以访问静态成员变量，不可以访问普通成员变量 普通成员函数都可以访问 静态成员函数也有权限 可以通过对象访问，也可以通过类名访问]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>静态成员变量</tag>
        <tag>静态成员函数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[拷贝构造函数]]></title>
    <url>%2F2019%2F%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[写在前面 默认情况下，C++编译器至少会为我们写的类增加三个函数 默认构造函数（无参，函数体为空） 默认析构函数（无参，函数体为空） 默认拷贝构造函数，对类中非静态成员属性进行简单的值拷贝 如果用户定义了拷贝构造函数，C++不会再提供任何默认的构造函数 如果用户定义了普通构造函数（非拷贝），C++不再提提供默认无参构造，但是会提供默认拷贝构造。 在之前的博文中，我介绍了构造函数和析构函数，这一篇里面，我会对拷贝构造函数单独进行介绍，并介绍深拷贝、浅拷贝等。 1.拷贝构造函数的调用时机 拷贝构造函数的调用时机如下： 用一个对象初始化另一个对象 对象以值传递的方式给函数参数 函数局部对象以值传递的方式从函数返回 下面，我举例说明： 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;iostream&gt;using namespace std;class MyClass&#123;public: MyClass() &#123; cout &lt;&lt; "默认构造函数" &lt;&lt; endl; &#125; MyClass(int a) &#123; cout &lt;&lt; "有参构造函数" &lt;&lt; endl; &#125; MyClass(const MyClass &amp;m) &#123; cout &lt;&lt; "拷贝构造函数调用" &lt;&lt; endl; &#125; ~MyClass() &#123; cout &lt;&lt; "析构函数调用" &lt;&lt; endl; &#125; int ak;&#125;;void test()&#123; MyClass m1; m1.ak = 10; MyClass m2(m1);//用已经创建好的对象来初始化新的对象&#125;int main()&#123; test();&#125; 输出结果如下图:在上面的例子中，我使用了一个已经创建好的对象来初始化一个新的对象。 这也就是拷贝构造函数对的第一个调用时机。下面是第二个调用时机，即对象以值传递的方式给函数参数。 1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;iostream&gt;using namespace std;class MyClass&#123;public: MyClass() &#123; cout &lt;&lt; "默认构造函数" &lt;&lt; endl; &#125; MyClass(int a) &#123; cout &lt;&lt; "有参构造函数" &lt;&lt; endl; &#125; MyClass(const MyClass &amp;m) &#123; cout &lt;&lt; "拷贝构造函数调用" &lt;&lt; endl; &#125; ~MyClass() &#123; cout &lt;&lt; "析构函数调用" &lt;&lt; endl; &#125; int ak;&#125;;void dowork(MyClass m)//以值传递方式给函数传参&#123;&#125;void test()&#123; MyClass m1; m1.ak = 10; dowork(m1);&#125;int main()&#123; test();&#125; 输出结果如下图: 最后，是函数局部对象以值传递的方式从函数返回。 12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;iostream&gt;using namespace std;class MyClass&#123;public: MyClass() &#123; cout &lt;&lt; "默认构造函数" &lt;&lt; endl; &#125; MyClass(int a) &#123; cout &lt;&lt; "有参构造函数" &lt;&lt; endl; &#125; MyClass(const MyClass &amp;m) &#123; cout &lt;&lt; "拷贝构造函数调用" &lt;&lt; endl; &#125; ~MyClass() &#123; cout &lt;&lt; "析构函数调用" &lt;&lt; endl; &#125; int ak;&#125;;MyClass dowork()//函数局部对象以值传递的方式从函数返回&#123; MyClass m1; return m1;&#125;void test()&#123; MyClass m = dowork();&#125;int main()&#123; test();&#125; 输出结果如下： 2.浅拷贝和深拷贝 浅拷贝同一个类型的对象之间可以赋值，使得两个对象的成员变量的值相同，两个对象仍然是独立的两个对象，这种情况被称为浅拷贝。一般情况下，浅拷贝没有任何副作用，但是当类中有指针，并且指针指向动态内存分配的内存空间，析构函数做了动态内存释放的处理，会导致内存问题。 1234567891011121314151617181920212223242526272829303132333435363738394041424344#define _CRT_SECURE_NO_WARNINGS#include &lt;iostream&gt;using namespace std;class Person&#123;public: Person() &#123; &#125; Person(const char *name, int age) &#123; Name = (char*)malloc(strlen(name) + 1); strcpy (Name, name); Age = age; &#125; ~Person() &#123; cout &lt;&lt; "析构函数调用" &lt;&lt; endl; if (Name != NULL) &#123; free(Name); Name = NULL; &#125; &#125;//系统提供默认拷贝构造函数 char *Name; int Age;&#125;;void test()&#123; Person p1("Aoki", 20); Person p2(p1);&#125;int main()&#123; test();&#125; 输出结果如下：我们可以看到，错误提示信息中提到了heap.cpp。此外，输出结果中出现了两次析构函数的调用。下面，我尝试尽可能地解释清楚原因。我们创建了一个对象p1，它有两个属性，一个存放在堆区，一个在栈区，当编译器进行简单的值拷贝时，只是将堆区内容的地址给了新对象p2，接着调用析构函数，释放p1的空间，而存放在堆区的数据也就消失了，紧接着，对象p2也调用析构函数来进行释放。那么，堆区的同一个地址就被释放了两次，引发了异常。图示如下：这时候，我们就要用到深拷贝了。深拷贝当类中有指针，并且此指针有动态分配空间，析构函数做了释放处理，往往需要自定义拷贝构造函数，自行给指针动态分配空间，深拷贝。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#define _CRT_SECURE_NO_WARNINGS#include &lt;iostream&gt;using namespace std;class Person&#123;public: Person() &#123; &#125; Person(const char *name, int age) &#123; Name = (char*)malloc(strlen(name) + 1); strcpy (Name, name); Age = age; &#125; Person(const Person &amp;p)//深拷贝 &#123; Age = p.Age; Name = (char*)malloc(strlen(p.Name) + 1); strcpy(Name, p.Name); &#125; ~Person() &#123; cout &lt;&lt; "析构函数调用" &lt;&lt; endl; if (Name != NULL) &#123; free(Name); Name = NULL; &#125; &#125; char *Name; int Age;&#125;;void test()&#123; Person p1("Aoki", 20); Person p2(p1);&#125;int main()&#123; test();&#125; 输出结果如下：]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>拷贝构造函数</tag>
        <tag>深拷贝</tag>
        <tag>浅拷贝</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[函数重载]]></title>
    <url>%2F2019%2F%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD%2F</url>
    <content type="text"><![CDATA[写在前面 如果同一个作用域内的几个函数名字相同，但是形参列表不同，我们称之为重载函数。实现函数重载的条件： 同一个作用域 参数个数不同 参数类型不同 参数顺序不同 函数的名字仅仅是让编译器知道它调用的是哪个函数，而函数重载在一定程度上可以减轻程序员起名字、记名字的负担。 1.定义重载函数 下面是一个函数重载的例子。函数重载使得我们可以定义一组函数，名字都为func。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;iostream&gt;#include&lt;string&gt;using namespace std;namespace A&#123; void func() &#123; cout &lt;&lt; "没有参数" &lt;&lt; endl; &#125; void func(int a) &#123; cout &lt;&lt; "a=" &lt;&lt; a &lt;&lt; endl; &#125; void func(string a) &#123; cout &lt;&lt; "a=" &lt;&lt; a &lt;&lt; endl; &#125; void func(int a, float b) &#123; cout &lt;&lt; "a=" &lt;&lt; a &lt;&lt; " b=" &lt;&lt; b &lt;&lt; endl; &#125; void func(string a, int b) &#123; cout &lt;&lt; "a=" &lt;&lt; a &lt;&lt; " b=" &lt;&lt; b &lt;&lt; endl; &#125;&#125;void test()&#123; A::func(); A::func(15); A::func("Aoki"); A::func(12, 3.12); A::func("Aoki", 15);&#125;int main()&#123; test();&#125; 输出结果如下：虽然我们定义的是五个函数各不相同，但是它们都有同一个名字。编译器根据实参的类型来决定应该调用哪一个函数。对于重载的函数来说，它们应该在形参数量或形参类型上有所不同。对于函数的重载，我们不能以函数的返回值作为重载的条件，这是为什么呢？当编译器能从上下文中确定唯一的函数时，如int ret=func(),这样就不会有问题。但是我们在编写程序的过程中还可以忽略它的返回值，那么这个时候，一个函数为 void fun(int x),另一个为 int func(int x),当我们直接调用func(10)，这时候编译器就不确定该调用哪个函数。所以，在C++中禁止使用返回值作为重载的条件。 对于函数重载，我们还应当注意避免二义性。举例如下： 1234567891011121314151617181920212223242526272829#include &lt;iostream&gt;#include&lt;string&gt;using namespace std;namespace A&#123; void func(string a) &#123; cout &lt;&lt; "a=" &lt;&lt; a &lt;&lt; endl; &#125; void func(string a, int b=10) &#123; cout &lt;&lt; "a=" &lt;&lt; a &lt;&lt; " b=" &lt;&lt; b &lt;&lt; endl; &#125;&#125;void test()&#123; //A::func("Aoki");//出现二义性&#125;int main()&#123; test();&#125; 错误提示如下：在使用函数重载的同时，我们应该注意避免这种情况出现。 2.调用重载的函数 定义了一组重载函数之后，我们需要以合理的实参来调用它们。函数匹配是指一个过程，在这个过程中我们把函数调用与一组重载函数中的某一个关联起来，函数匹配也叫重载确定。编译器首先将调用的实参与重载集合中对的每一个函数的形参进行比较，然后根据比较的结果决定到底调用哪个函数。在很多情况下，我们很容易判断某次调用是不是合法对的，以及当调用合法时该调用哪个函数。通常，重载集中的函数区别明显，它们要不然是参数的数量不同，要不然就是参数类型毫无关系。此时，确定调用哪个函数比较容易。但是在另外一些情况下要想选择函数就比较困难了。比如当两个重载函数参数数量相同，且参数类型可以相互转换。当调用重载函数时有三种可能的结果： 编译器找到一个与实参最佳匹配的函数，并生成了调用该函数的代码。 找不到任何一个函数与调用的实参匹配，此时编译器发出无匹配的错误信息。 有多于一个函数可以匹配，但是每一个都不是明显的最佳选择。此时也发生错误，称为二义性调用。 3.函数重载实现原理 编译器为了实现函数重载，为我们做了一些幕后的工作，编译器用不同的参数类型来修饰不同的函数名，比如 void func();编译器可能会将函数名修饰成—func，当编译器碰到void func(int x)，编译器可能会将函数名修饰为_func_int,当编译器碰到void func(int x,char c)，编译器可能会将函数名修饰为_func_int_char，这里使用可能，是因为编译器如何修饰重载的函数名称并没有一个统一的标准，所以不同的编译器可能会产生不同的内部名。]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>函数重载</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[构造函数和析构函数]]></title>
    <url>%2F2019%2F%E5%87%BD%E6%95%B0%E5%92%8C%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[1.初始化和清理 C++中OO思想也是来源于现实，是对现实事物的抽象模拟，具体来说，当我们常见对象的时候，这个对象应该有一个初始状态，当对象销毁之前应该销毁自己创建的一些数据。对象的初始化和清理也是两个非常重要的安全问题，一个对象或者变量没有初始化时，对其使用后果是未知的，同样的使用完一个变量，，没有及时清理，也会造成一定的安全问题。C++为了给我们提供这种问题的解决方案，构造函数和析构函数。这两个函数将会被编译器自动调用，完成对象初始化和对象清理工作。无论我们是否喜欢这种方式，对象的初始化和清理工作是编译器强制我们必须要做的事情，即使我们不提供初始化操作和清理操作，编译器也会给我们增加默认对的操作，只是这个默认初始化操作不会做任何事，所以编写类就应该顺便提供初始化函数。为什么初始化操作时自动调用而不是手动调用？既然是必然操作，那么自动调用会更好，如果靠我们自觉，那么就会存在遗漏初始化的情况出现。 2.构造函数 构造函数主要作用在于创建时为对象的成员属性赋值，构造函数由编译器自动调用，无须手动调用。构造函数语法： 构造函数函数名和类名相同，没有返回值，不能有void，但可以有参数。 ClassName(){} 3.析构函数 析构函数主要用于对象销毁前系统自动调用，执行一些清理工作。析构函数语法： 析构函数函数名是类名前面加”~”组成，没有返回值，不能有void，不能有参数，不能重载。 ~ClassName（）{} 下面我举例说明构造函数与析构函数。 12345678910111213141516171819202122232425#include &lt;iostream&gt;using namespace std;class Person&#123;public: Person() &#123; cout &lt;&lt; "构造函数调用" &lt;&lt; endl; &#125; ~Person() &#123; cout &lt;&lt; "析构函数调用" &lt;&lt; endl; &#125;&#125;;void test()&#123; Person p1;&#125;int main()&#123; test();&#125; 输出结果如下：从输出结果我们可以看出，在创建对象时，构造函数调用。当对象销毁之前，又调用了析构函数。 4.构造函数的分类及调用 按参数类型：分为无参构造函数和有参构造函数 按类型分类：分为普通构造函数和拷贝构造函数（复制构造函数） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;iostream&gt;using namespace std;class Person&#123;public: Person()//默认，无参构造函数 &#123; cout &lt;&lt; "默认构造函数调用" &lt;&lt; endl; &#125; Person(int a)//有参构造函数调用 &#123; cout &lt;&lt; "有参构造函数调用" &lt;&lt; endl; &#125; //拷贝构造函数 Person(const Person&amp; p) &#123; m_age = p.m_age; cout &lt;&lt; "拷贝构造函数调用" &lt;&lt; endl; &#125; ~Person() &#123; cout &lt;&lt; "析构函数调用" &lt;&lt; endl; &#125; long m_age; static int n_age; &#125;;static int n_age = 100;void test()&#123; Person p1(1);//有参拷贝构造函数调用 p1.m_age = 10; cout &lt;&lt; "p1的年龄为：" &lt;&lt; p1.m_age &lt;&lt; endl; Person p2(p1);//拷贝构造函数调用 cout &lt;&lt; "p2的年龄为：" &lt;&lt; p2.m_age &lt;&lt; endl; Person(100);//匿名对象，当本行代码执行完毕就释放对象 Person p3 = 100;//隐式类型转换，相当于调用了Person p7=Person(100) Person p4 = p3;//拷贝构造函数调用，相当于Person p4=Person(p3)&#125;int main()&#123; test(); return 0;&#125; 输出结果如下：这里，我们需要注意的是，析构函数和构造函数必须写在public下才可以调用。同时，对于无参构造函数（默认构造）、有参构造函数在创建对象时的调用应当注意。当我们我们没有定义构造函数时，系统会给我们提供一个空的默认构造函数，但是当我们定义了无参构造函数时，系统使用我们的构造函数。除此之外，当我们定义了一个有参构造函数，但是并没有提供无参构造函数时，在创建对象的时候必须使用有参构造。原因是，当我们声明一个有参构造函数之后，系统不再提供默认构造函数。]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>析构函数</tag>
        <tag>构造函数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于C语言下的封装和C++语言封装的区别]]></title>
    <url>%2F2019%2FC%E8%AF%AD%E8%A8%80%E4%B8%8B%E7%9A%84%E5%B0%81%E8%A3%85%E5%92%8CC-%E8%AF%AD%E8%A8%80%E5%B0%81%E8%A3%85%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[1.封装 我们编写程序来解决现实中的问题，而这些问题的是由各种事物组成的。我们解决这个问题的前提就是将事和物抽象得到计算机程序中，也就是用程序语言表示现实的事物。现实世界的事物所具有的共性就是每个事物都具有自身的属性和行为，所以如果我们能把这些事物的属性和行为表示出来，那么就可以抽象出这个事物。属性和行为应该放在一起，一起来表示一个具有属性和行为的对象。为什么需要这样做呢？我稍后解释。假如某对象的某项属性不想被外界获知，比如女孩子的体重，那么对于体重这个属性，就应该是只有女孩自己知道的属性，或者女孩的某些行为，比如暗恋某个男生，不想让外界知道，只能让自己知道，那么在这种情况下，封装应该提供一种机制，能够给属性和行为的访问权限控制住。所以说封装特性包含两方面，一个是属性和变量合成一个整体，一个是给属性和函数增加访问权限。 封装 把变量（属性）和函数（操作）合成一个整体，封装在一个类中。 对变量和函数进行访问控制。 访问权限 在类的内部（作用域范围之内），没有访问权限之分，所有成员可以相互访问。 在类的外部（作用域范围外），访问权限才有意义：public,private,protected 在类的外部，只有public修饰的成员才能被访问，在没有涉及继承和派生时，private和protected是同等级的，外界不可以访问。 访问属性 属性 对象内部 对象外部 public 公有 可访问 可访问 protected 保护 可访问 不可访问 private 私有 可访问 不可访问 其中，potected为保护权限，类内部可以访问，当前类的子类可以访问，类外部不可以。而private是对象的私有数据，子类和类外部都不可以访问。 下面，我们对比以下C语言下的封装和C++语言下封装的区别。 2.C语言下的封装 在C语言中我们可以定义一个结构体来表示一个对象所包含的属性，函数用来表示出来一个事物，在C语言中，结构体中不能定义函数，所以行为和定义方式分开的，也就是说吃饭这个属性不属于某个对象，而属于所有的共同数据。 1234567891011121314151617181920212223242526272829303132333435363738394041424344#define _CRT_SECURE_NO_WARNINGS#include&lt;stdio.h&gt;#include&lt;string.h&gt;#include&lt;stdlib.h&gt;struct person &#123; char name[10]; int age;&#125;;void PersonEat(struct person *p)&#123; printf("%s在吃饭\n", p-&gt;name);&#125;struct Dog&#123; char name[10]; int age;&#125;;void DogEat(struct Dog *d)&#123; printf("%s在狗粮\n", d-&gt;name);&#125;void test01()&#123; struct Dog one; strcpy(one.name, "旺财"); DogEat(&amp;one); struct person two; strcpy(two.name, "Aoki"); DogEat(&amp;two);&#125;void main()&#123; test01(); system("pause");&#125; 输出结果如下：从输出结果我们可以看出，小狗旺财和Aoki这个人正在一块吃狗粮，但是正常情况下，Aoki怎么可能吃狗粮呢？从这里，我们可以看出在C中封装一个对象造成了什么样的后果。那么，在C++中的封装呢？ 123456789101112131415161718192021222324252627282930313233343536373839#define _CRT_SECURE_NO_WARNINGS#include &lt;iostream&gt;using namespace std;struct Person&#123; char name[10]; int age; void PersonEat() &#123; cout &lt;&lt; name &lt;&lt; "在吃饭" &lt;&lt; endl; &#125;&#125;;struct Dog&#123; char name[10]; int age; void DogEat() &#123; cout &lt;&lt; name &lt;&lt; "在吃狗粮" &lt;&lt; endl; &#125;&#125;;void test()&#123; Person one; strcpy(one.name, "Aoki"); one.PersonEat(); //one.DogEat();&#125;int main()&#123; test();&#125; 刚开始，我尝试了使用one这个对象来调用DogEat这个函数，编译器报错，不允许我们使用它，因为DogEat并不是Person的成员函数。编译器报错如下：在注释掉报错语句之后，正确输出结果如下：从上面的例子中，我们可以看到，C++中的封装，有着严格的类型转换检测，C++让属性和行为绑定在一起。属性和行为作为一个整体来表示生活中的事物。]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>封装</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[宏缺陷和内联函数]]></title>
    <url>%2F2019%2F%E5%AE%8F%E7%BC%BA%E9%99%B7%E5%92%8C%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[写在前面 C++从C中继承的一个重要特征就是效率。 在C中我们经常把一些短并且执行频繁的计算写成宏，而不是函数，这样做的理由方式为了执行效率，宏可以避免函数调用的开销，这些都由预处理来完成。 但是在C++出现以后，使用宏处理会出现两个问题： 第一个在C中也会出现，宏看起来像是一个函数调用，但是会隐藏一些难以发现的错误。 第二个问题是C++特有的，预处理器不允许访问类的成员，也就是说预处理器宏不能用作类的成员的函数。 为了保持预处理宏的效率又增加安全性，而且能像一般成员函数那样在类里访问自如，C++引入了内联函数。 内联函数为了继承宏函数的效率，没有函数调用的开销，然后又可以像普通函数那样，可以进行参数、返回值类型的安全检查，又可以作为成员函数。 1.预处理宏的缺陷 预处理器宏存在问题的关键是我们可能认为预处理器的行为和编译器时一样的。当然也是由于宏函数调用和函数调用在外表看起来是一样的，因此也容易混淆。但是其中会有一些微妙的问题出现。 例112345678910111213141516171819202122232425262728293031323334353637#include &lt;iostream&gt;using namespace std;#define ADD(x,y) x+yvoid test()&#123; int ret = ADD(10, 10); int ret0 = ADD(10, 10) * 10;//预期结果为200 cout &lt;&lt; "ret=" &lt;&lt; ret &lt;&lt; endl; cout &lt;&lt; "ret0=" &lt;&lt; ret0 &lt;&lt; endl;&#125;int main()&#123; test();&#125; 输出结果如下： 在输出结果里，我们可以看到，实际输出结果为110，并不是我们想要的结果。它实际进行运算时，运算式应该是：10+10*10。 对于这个微小的问题，我们可以通过加括号的方式来解决它。源代码和输出结果如下： 123456789101112131415161718192021222324252627282930313233#include &lt;iostream&gt;using namespace std;#define ADD(x,y) ((x)+(y))void test()&#123; int ret = ADD(10, 10); int ret0 = ADD(10, 10) * 10;//预期结果为200 cout &lt;&lt; "ret=" &lt;&lt; ret &lt;&lt; endl; cout &lt;&lt; "ret0=" &lt;&lt; ret0 &lt;&lt; endl;&#125;int main()&#123; test();&#125; 输出结果如下： 我们可以看到，加括号之后，输出结果和预期相同。 例2为了防止出现例1中的问题，这次，我特意对三目运算符加了括号。代码如下： 1234567891011121314151617181920212223242526272829303132333435#include &lt;iostream&gt;using namespace std;#define compare(a,b) ((a)&lt;(b))?(a):(b)void test()&#123; int a = 10; int b = 20; int ret = compare(a, b); cout &lt;&lt; "ret=" &lt;&lt; ret &lt;&lt; endl; int ret0 = compare(++a, b); cout &lt;&lt; "ret0=" &lt;&lt; ret0 &lt;&lt; endl;&#125;int main()&#123; test();&#125; 输出结果如下: 这次出现的问题让人有点摸不到头脑，因此++运算符表示在进行运算之前加1，但是输出结果中，实际输出为12，相当于加了两次。 除此之外，我们还应当注意的是，预定义宏函数没有作用域概念，无法作为一个类的成员函数，也就是说，预定义宏没办法表示类的范围。 2.内联函数 在C++中，预定义宏额概念是用内联函数来实现的，而内联函数本身也是一个真正的函数。内联函数具有普通函数的所有行为。唯一不同之处在于内联函数会在适当得到地方像预定义宏一样展开，所以不需要函数调用的开销。因此应该不使用宏，使用内联函数。 普通函数（非成员函数）函数前面加上inline关键字使之成为内联函数。但是必须注意函数体和声明结合在一起，否则编译器会把它当成普通函数对待。 1inline void func(int a); 上面的这种写法没有任何效果，仅仅是声明函数，应该像下面这样的方式来定义。 1234567inline void func(int a)&#123; return ++;&#125; 注意：编译器将会检查函数参数列表使用是否正确，并返回值（进行必要的转换）。这些事预处理器是无法完成的。 内联函数的确占用空间，但是内联函数相对于普通函数的优势只是省去了函数调用是否的压栈、跳转、返回的开销。我们可以理解为内联函数是以空间换时间。 内联说明只是向编译器发出一个请求，编译器可以选择忽略这个请求。 一般来说，内联机制用于优化规模较小、流程直接、频繁调用的函数。很多编译器都不支持内联函数递归函数，而且一个75行的函数也不太可能在调用点内联地展开。]]></content>
      <tags>
        <tag>宏缺陷</tag>
        <tag>内联函数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[函数默认参数及占位参数]]></title>
    <url>%2F2019%2F%E5%87%BD%E6%95%B0%E9%BB%98%E8%AE%A4%E5%8F%82%E6%95%B0%E5%8F%8A%E5%8D%A0%E4%BD%8D%E5%8F%82%E6%95%B0%2F</url>
    <content type="text"><![CDATA[1.函数默认参数C++在声明函数原型时可为一个或多个参数指定默认（缺省）的参数值，当函数调用的时候如果没有指定这个值，编译器会自动用默认值代替。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;iostream&gt;using namespace std;void func01(int a = 10, int b = 100)&#123; cout &lt;&lt; "a+b=" &lt;&lt; a + b &lt;&lt; endl;&#125;void func02(int a, int b = 12, int c = 11)&#123; cout &lt;&lt; "a=" &lt;&lt; a &lt;&lt; ",b=" &lt;&lt; b &lt;&lt; ",c=" &lt;&lt; c &lt;&lt; endl;&#125;void func03(int a = 0, int b = 0);void func03(int a, int b)&#123; cout &lt;&lt; "a=" &lt;&lt; a &lt;&lt; ",b=" &lt;&lt; b &lt;&lt; endl;&#125;int main()&#123; func01();//使用默认参数 func01(100, 100);//使用现在传入的参数 func01(110);//只传入一个参数，第二个参数使用默认参数 func02(12);//b，c使用默认参数 func03();//没有传参数，使用默认参数 return 0;&#125; 输出结果如下： 注意点： 函数的默认常数函数从左往右，如果一个参数设置了默认参数，那么这个参数之后的参数都必须设置默认参数。 如果函数声明和函数定义分开写，函数声明与函数定义不能同时设置默认参数。 2.函数的占位符 C++在声明函数时，可以使用占位参数。占位参数只有类型声明，而没有参数名声明。一般情况下，在函数体内无法使用占位参数。 12345678910111213141516171819202122232425262728293031323334353637#include &lt;iostream&gt;using namespace std;void func01(int a,int b,int) &#123; //函数内部无法使用占位参数 cout &lt;&lt; a + b &lt;&lt; endl;&#125;void func02(int a, int b, int = 10)&#123; //无法使用占位参数 cout &lt;&lt; a + b &lt;&lt; endl;&#125;int main()&#123; func01(10, 15, 20); func02(10, 25);//占位参数使用默认参数 return 0;&#125; 输出结果如下：]]></content>
      <tags>
        <tag>默认参数</tag>
        <tag>占位参数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++命名空间及using的使用]]></title>
    <url>%2F2019%2FC-%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%E5%8F%8Ausing%E7%9A%84%E4%BD%BF%E7%94%A8-1%2F</url>
    <content type="text"><![CDATA[一、C++命名空间&emsp;在C++中，名称（name）可以是符号常量、变量、函数、结构、枚举、类和对象。工程越大，名称相互冲突性的可能性越大。另外，在使用多个厂商的类库时，也可能导致名称冲突。为了避免冲突，在大规模的设计中，以及程序员使用1各种各样的C++库时，这些标识符的命名发生冲突，标准C++引入关键字namesapce（命名空间/名字空间/名称空间），可以更好的控制标识符得到作用域。 12345678910111213141516171819202122232425262728293031323334353637#include &lt;iostream&gt;using namespace std;//创建一个命名空间namespace study&#123; int a = 10;&#125;namespace learn&#123; int a = 20;&#125;int main()&#123; cout &lt;&lt; "命名空间study的a="&lt;&lt;study::a &lt;&lt; endl; cout &lt;&lt;"命名空间learn的a="&lt;&lt; learn::a &lt;&lt; endl;&#125; 运行结果输出： 在命名空间下，可以定义函数，变量、结构体、类；除此之外，对于命名空间的定义还应当注意，它必须定义在全局作用域下。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include &lt;iostream&gt;#include&lt;string&gt;using namespace std;namespace study&#123; int a = 10; namespace A &#123; int a = 100; void sayhi() &#123; cout &lt;&lt; "hi,Aoki" &lt;&lt; endl; &#125; struct Student &#123; string name; &#125;; &#125;&#125;namespace learn&#123; int a = 20;&#125;int main()&#123; //cout &lt;&lt; "命名空间study的a="&lt;&lt;study::a &lt;&lt; endl; //cout &lt;&lt;"命名空间learn的a="&lt;&lt; learn::a &lt;&lt; endl; study::A::sayhi(); cout &lt;&lt; "作用域A下的a=" &lt;&lt; study::A::a &lt;&lt; endl;&#125; 输出结果： 下面是对命名空间错误定义的举例： 对于命名空间，我们还可以定义无名命名空间，意味着命名空间中的标识符只能在本文件中访问，相当于给这个标识符加上了static，使得其可以作为内部连接。 除此之外，还有就是给命名空间起别名，我们为命名空间A起别名为b，源码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;iostream&gt;#include&lt;string&gt;using namespace std;namespace A&#123; int a = 100; void test() &#123; namespace b = A;//给命名空间起别名为b cout &lt;&lt;"A作用域内a="&lt;&lt; b::a &lt;&lt; endl; &#125;&#125;namespace //无名（匿名）命名空间&#123; int c = 15; int d = 16;&#125;int main()&#123; cout &lt;&lt; "c=" &lt;&lt; c &lt;&lt; endl; cout &lt;&lt; "d=" &lt;&lt; d &lt;&lt; endl; A::test();&#125; 运行结果如下图： 下面对命名空间namespace的用法总结如下： 命名空间的用途：解决名称冲突问题 命名空间下可以定义函数、变量、结构、类 命名空间必须定义在全局作用域下 命名空间可以嵌套命名空间 命名空间是开放的，可以随时给原先的命名空间添加内容 定义另个名字相同的命名空间时，两个命名空间会合并，但是不会覆盖 当我们定义了无名空间时，相当于写了static intc=15，static int d=16，只能在当前文件内使用 二、using声明using声明可使得指定的标识符可用 1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;iostream&gt;using namespace std;namespace One&#123; int test = 100;&#125;void test()&#123; int test = 100; using One::test;//using声明 cout &lt;&lt; "test=" &lt;&lt; test &lt;&lt; endl;&#125;int main()&#123; test();&#125; 此处我们使用了using声明，但是编译却发生了错误。因为在test()中我们定义了一个整型数test，并赋予了初值。当我们使用using声明时，编译器有就近原则，它会选择输出test中定义的整型数，但是又发现有using声明，出现二义性问题，编译器不知道怎么处理，所有报错。报错信息如下： 所以，在using声明中，我们应当注意避免二义性问题。 1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;iostream&gt;using namespace std;namespace One&#123; int test = 100;&#125;void test()&#123; int test = 100; //using One::test;//using声明 cout &lt;&lt; "test=" &lt;&lt; test &lt;&lt; endl;&#125;int main()&#123; test();&#125; 输出结果如下图： using声明的一个例子： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include &lt;iostream&gt;using namespace std;namespace One&#123; int test = 100; int a = 99; int b = 30; void func() &#123; cout &lt;&lt; "hi,Aoki!" &lt;&lt; endl; &#125; void func1() &#123; cout &lt;&lt; "hello,Aoki!" &lt;&lt; endl; &#125;&#125;void test()&#123; cout &lt;&lt; "test=" &lt;&lt; One::a &lt;&lt; endl; //using声明 using One::a; using One::func1; using One::func; cout &lt;&lt; "a=" &lt;&lt; a &lt;&lt; endl; func1(); func();&#125;int main()&#123; test();&#125; 运行结果如下图： 下面是using声明遇到函数重载的一个例子： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include &lt;iostream&gt;using namespace std;namespace Two&#123; void func() &#123; cout &lt;&lt; "Nothing!" &lt;&lt; endl; &#125; void func(int x) &#123; cout &lt;&lt; x &lt;&lt; endl; &#125; void func(int x, int y) &#123; cout &lt;&lt; "x=" &lt;&lt; x ; cout &lt;&lt; ",y=" &lt;&lt; y &lt;&lt; endl; &#125;&#125;void test1()&#123; using Two::func; func(); func(15); func(15, 20);&#125;int main()&#123; test1();&#125; 输出结果如下图： 如果命名空间包含一组用相同名字重载的函数，using声明就声明了这个重载函数的所有集合。 三、using编译指令using编译指令使整个命名空间标识符可用。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879#include &lt;iostream&gt;using namespace std;namespace One&#123; int a = 99; int b = 30; void func() &#123; cout &lt;&lt; "hi,Aoki!" &lt;&lt; endl; &#125; void func1() &#123; cout &lt;&lt; "hello,Aoki!" &lt;&lt; endl; &#125;&#125;void test()&#123; using namespace One; cout &lt;&lt; a &lt;&lt; endl; cout &lt;&lt; b &lt;&lt; endl; func(); func1(); int a = 100;//没有产生二义性 cout &lt;&lt; a &lt;&lt; endl;&#125;namespace Two&#123; int a = 1; int b = 2;&#125;;void test1()&#123; //产生二义性 using namespace One; using namespace Two; cout &lt;&lt; a &lt;&lt; endl;&#125; 当我们像上面一样使用using编译指令时，会出现二义性问题，编译器无法通过编译。错误信息如下： 当我们使用using声明或using编译指令时，会增加命名冲突的可能性。也就是说，如果有命名空间，并在代码中使用作用域解析运算符，则不会出现二义性问题。 例子如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091#include &lt;iostream&gt;using namespace std;namespace One&#123; int a = 99; int b = 30; void func() &#123; cout &lt;&lt; "hi,Aoki!" &lt;&lt; endl; &#125; void func1() &#123; cout &lt;&lt; "hello,Aoki!" &lt;&lt; endl; &#125;&#125;void test()&#123; using namespace One; cout &lt;&lt; a &lt;&lt; endl; cout &lt;&lt; b &lt;&lt; endl; func(); func1(); int a = 100; cout &lt;&lt; a &lt;&lt; endl;&#125;namespace Two&#123; int a = 1; int b = 2;&#125;;void test1()&#123; using namespace One; using namespace Two; //cout &lt;&lt; a &lt;&lt; endl;&#125;int main()&#123; test(); test1();&#125; 输出结果如下： 当我们引入一个全局的using编译指令时，就为该文件打开了命名空间，它不会影响其他的文件，所以可以再每一个实现文件中调整对命名空间的控制。比如，如果发现某一个实现文件中有太多using指令而产生命名冲突，就要对该文件做个简单的改变，通过明确限定或者using声明来消除名字冲突，这样不需要修改其他实现文件。]]></content>
      <tags>
        <tag>命名空间</tag>
        <tag>using的使用</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于const限定符的一些总结]]></title>
    <url>%2F2019%2Fconst%E9%99%90%E5%AE%9A%E7%AC%A6%2F</url>
    <content type="text"><![CDATA[写在前面 有时候我们希望定义这样一种变量，它的值不能被改变。例如，用一个变量表示缓冲区的大小。使用变量的好处是我们觉得缓冲区不再合适的时候，很容易对其进行调整。另一方面，也应随时警惕，防止程序一不小心修改了这个值。为了满足这一要求，可以用关键词const对变量的类型加以限定。 在C++中，一个const不必创建内存空间，而在C中，const总是需要一块内存空间。在C++中，是否为const常量分配内存空间依赖于如何使用。一般来说，如果一个const仅仅用来把一个名字用一个值来代替，那么该存储空间就不必创建。 在存储空间没有分配内存的话，在进行完数据类型检查后，为了代码更加有效，值也许会折叠到代码中。不过取一个const地址，或者把它定义为extern，则会为该const创建内存空间。 在C++中，出现在所有函数之外的const作用于整个文件（也就是说它在该文件外部不可见，默认为内部连接，C++中其他标识符一般默认为外部连接。 1.初始化和const const类型的对象能完成非const类型所能完成的大部分操作，但是对于const类型对象的主要限制就是只能在const类型对的对象上执行不改变其内容的操作。 在不改变const对象的操作中还有一种是初始化，如果利用一个对象去初始化另外一个对象，则它们是不是const都无关紧要。 123456789101112#include &lt;iostream&gt;using namespace std;int main()&#123; int i = 12; const int ci = i;//i的值拷贝给了ci int j = ci; cout &lt;&lt; "i=" &lt;&lt; i &lt;&lt; endl; cout &lt;&lt; "ci=" &lt;&lt; ci &lt;&lt; endl; cout &lt;&lt; "j=" &lt;&lt; j &lt;&lt; endl;&#125; 输出结果如下： ![](https://i.imgur.com/RpcPLLp.png) 2.const引用 可以把引用绑定到const对象上，就像绑定到其他对象上一样，我们称之为——常量引用。 与普通引用不同的是，对常量的引用不能被用作修改它所绑定的对象。 错误示范如下： 3.初始化和对const的引用 引用的类型必须与其所引用对象的类型一致，但是有两个情况例外。第一个例外情况就是在初始化常量引用时，允许用任意表达式作为初始值，只要该表达式的结果能转化成引用的类型即可。 允许一个常量引用绑定非常量的对象、字面值、甚至是一般表达式。 123456789101112131415#include &lt;iostream&gt;using namespace std;int main()&#123; int i = 42; const int &amp;r1 = i;//允许将const int &amp;绑定到一个普通int对象上 const int &amp;r2 = 42;//r1是一个常量引用 const int &amp;r3 = r1 * 2;//r3是一个常量引用 cout &lt;&lt; "i=" &lt;&lt; i &lt;&lt; endl; cout &lt;&lt; "r1=" &lt;&lt; r1 &lt;&lt; endl; cout &lt;&lt; "r2=" &lt;&lt; r2 &lt;&lt; endl; cout &lt;&lt; "r3=" &lt;&lt; r3 &lt;&lt; endl;&#125; 输出结果如下： 4.对cons的引用可能引用一个并非const的对象 12345678910111213141516171819#include &lt;iostream&gt;using namespace std;int main()&#123; int i = 42; int &amp;r1 = i;//引用r1绑定对象i const int &amp;r2 = i;//常量引用r2绑定i，但是r2不能修改i的值 cout &lt;&lt; "i=" &lt;&lt; i &lt;&lt; endl; cout &lt;&lt; "r1=" &lt;&lt; r1 &lt;&lt; endl; cout &lt;&lt; "r2=" &lt;&lt; r2 &lt;&lt; endl; r1 = 10; cout &lt;&lt; "i=" &lt;&lt; i &lt;&lt; endl; cout &lt;&lt; "r1=" &lt;&lt; r1 &lt;&lt; endl; cout &lt;&lt; "r2=" &lt;&lt; r2 &lt;&lt; endl; //r2 = 5;//此处报错，因为r2是一个常量引用&#125; 输出结果如下： 对于常量引用来说，一般情况下是没有办法来对它进行修改的，但是可以使用下面的方法来尝试对常量引用进行修改。代码图如下： 1234567891011#include &lt;iostream&gt;using namespace std;int main()&#123; const int &amp;ref = 10; cout &lt;&lt; "ref=" &lt;&lt; ref &lt;&lt; endl; int *p = (int *)&amp;ref; *p = 100; cout &lt;&lt; "ref=" &lt;&lt; ref &lt;&lt; endl;&#125; 输出结果如下：这里我们使用了一个指针来对常量引用进行修改。首先，我们要知道的是，常量引用不是一个对象，编译器并没有给它分配内存空间。当我们使用指针指向常量引用时，编译器会给常量引用临时开辟一块内存空间。代码示意如下： 12int tmp=ref;//tmp有内存int *p=(int *)&amp;ref;//*p指向的是那块临时空间，临时空间看不到 5.指针和const 与引用一样，也可以令指针指向常量或非常量。类似于常量引用，指向常量的指针不能改变其所指对象的值。要想存放常量对象的地址，只能使用指向常量的指针。 实例代码如下： 123456789101112131415#include &lt;iostream&gt;using namespace std;int main()&#123; const int i = 10; //int *r1 = &amp;i;//报错，r1是一个普通指针，并不能指向一个常量 const int *r2 = &amp;i;//常量指针指向常量 //常量指针可以指向常量，但是并不能修改常量的值 cout &lt;&lt; "常量i的地址为：" &lt;&lt; &amp;i &lt;&lt; endl; cout &lt;&lt; "r2指向的地址为：" &lt;&lt; r2 &lt;&lt; endl; cout &lt;&lt; "i=" &lt;&lt; i &lt;&lt; endl; cout &lt;&lt; "r2=" &lt;&lt; *r2 &lt;&lt; endl;&#125; 输出结果如下： 6.const指针 指针是对象而引用不是，就像其他对象类型一样，允许把指针本身定义为常量。常量指针必须初始化，而且一旦初始化完成，则它的值（也就是存放在指针中的那个地址）就不能再修改。把*放在const关键字之前用以说明指针是一个常量。这样书写的意味着，不变的是指针本身的值，而不是指向的那个值。 12345678910111213141516#include &lt;iostream&gt;using namespace std;int main()&#123; int i = 10; int *const r1 = &amp;i;//r1将一直指向i const int i1 = 11; const int *const r2 = &amp;i1;//r2是指向常量的常量指针 cout &lt;&lt; "i=10时地址为：" &lt;&lt; &amp;i &lt;&lt; endl; cout &lt;&lt; "常量指针r1指向的地址为：" &lt;&lt; r1 &lt;&lt; endl; i = 100; cout &lt;&lt; "i=100时地址为：" &lt;&lt; &amp;i &lt;&lt; endl; cout &lt;&lt; "常量指针r1指向的地址为：" &lt;&lt; r1 &lt;&lt; endl;&#125; 输出结果如下： 7.顶层const 指针本身就是一个对象，它又可以指向1另外一个对象。因此指针本身是不是常量，以及指针指向的对象是不是一个常量是两个独立的问题。 顶层const表示指针本身是一个常量。 底层const表示指针所指的对象时一个常量。 更一般地，顶层const可以表示任意的对象时常量，这一点对任何数据类型都适用，如算术类型、类、指针等。底层const则与指针和引用等符合类型的基本类型有关。比较特殊的是，指针类型既可以是顶层const，也可以是底层const。 8.尽量使用const代替#define 在旧版本的C中，如果想建立一个常量，必须使用预处理器。 1#define MAX 1024; 这里我们定义的宏MAX从未被编译器看到过，因为在预处理阶段，所有的MAX已经全部被替换成了1024，于是MAX并没有将其加入符号表中。但是我们使用这个常量获得一个编译错误信息时，可能会带来一些困扰，因为这个信息可能会提到1024，但是并没有提到MAX。如果MAX被定义在一个不是我们自己写的头文件中，我们可能并不知道1024代表着什么，也许解决这个问题需要很长的时间。解决这个问题的办法就是用一个常量来替换掉上面的宏： 1const int MAX=1024； 1#undef A //卸载宏常量A ###const和#define的区别 const有类型，可进行编译器类型安全检查，#define无类型，不可进行类型检查 const有作用域，而#define不重视作用域，默认定义处到文件末尾，如果定义在指定作用域下有效的常量，那么#define就不能用。]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>限定符</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++复合类型]]></title>
    <url>%2F2019%2FC-%E5%A4%8D%E5%90%88%E7%B1%BB%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[复合类型是指基于其他类型定义的类型。C++有几种复合类型，下面主要是引用和指针。 定义复合类型的变量复杂很多，通用的描述为：一条声明语句由一个基本数据类型和紧随其后的一个声明符列表组成。每个声明符命名了一个变量并指定该变量为与基本数据类型有关的某种类型。 引用 C++11中新增加了一种引用，为右值引用，主要用于内置类。这里，我们使用引用时，指的是左值引用。 引用为对象起了另外一个名字，引用类型引用另外一种类型。通过将声明符写成&amp;d的形式来定义引用类型，其中d是声明的变量名。引用即别名，并非对象，它只是为一个已经存在的对象所起的另外一个名字。下面是引用的一个例子。 123456789101112#include &lt;iostream&gt;using namespace std;int main()&#123; int vale = 1024; int &amp;vale00 = vale; //注意：引用必须进行初始化 cout &lt;&lt; "vale的值为：" &lt;&lt; vale &lt;&lt; endl; cout &lt;&lt; "vale00的值为：" &lt;&lt; vale00 &lt;&lt; endl; cout &lt;&lt; "vale00是vale的引用。" &lt;&lt; endl;&#125; 定义了一个引用之后，对其进行的所有操作都是在与之绑定的对象上进行的。为引用赋值，实际上是把值赋给了与引用绑定的对象。获取引用的值，实际上是获取到了与之绑定的对象的值。同理，以引用作为初始值，实际上是以引用绑定的对象作为初始值。 1234567891011121314#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;int main()&#123; string name = "青木"; string &amp;name_ = name; string name0 = "Aoki"; cout &lt;&lt; "大家好，我的名字是" &lt;&lt; name_ &lt;&lt; endl; cout &lt;&lt; "大家好，我是" &lt;&lt; name0 &lt;&lt; endl; name0 = name_;//为引用赋值 cout &lt;&lt; "大家好，我现在是" &lt;&lt; name0 &lt;&lt; endl;&#125; 输出结果为： 引用 指针是指向另外一种类型的复合类型。与引用类似，指针也实现了对其他对象的间接访问，但是指针与引用也有很多不同点，如下： 指针本身就是个对象，允许对指针赋值和拷贝，在指针的生命周期内，它可以先后指向几个不同的对象 指针无须在定义时赋初值。和其他内置类型一样，在块作用域内定义的指针如果没有定义，也将拥有一个不确定的值。 >## 获取对象的地址 指针存放某个对象的地址，要向获取该地址，就要使用取地址符（&amp;）。在声明语句中，指针的类型实际上被用于它所指向的对象的类型，所以二者必须匹配。如果指针指向了一个其他类型的对象，对该对象的操作将会发生错误。 123456789101112#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;int main()&#123; string name = "青木"; string* name_=&amp;name;//name_存放变量name的地址，或者说name_是指向变量name的指针 cout &lt;&lt; "大家好，我的名字是" &lt;&lt; name &lt;&lt; endl; cout &lt;&lt; "name的地址为:" &lt;&lt; name_ &lt;&lt; endl; cout &lt;&lt; "大家好，我的名字是" &lt;&lt; name_ &lt;&lt; endl;&#125; 输出结果为： 指针值 指针的值（即地址）应属于下列4中状态之一： 指向一个对象 指向紧邻对象所占空间的下一个位置 空指针，意味着指针没有指向任何值 无效指针，就是上述状态之外的其他值。 对于无效指针，试图拷贝或以其他方式访问无效指针的值都将引发错误。 >## 利用指针访问对象 如果一个指针指向了一个对象，则允许使用解引用符（*）来访问该对象。对指针解引用会得到所指的对象，因此如果给解引用的结果赋值，实际上也就是给指针所指的内容赋值。 注意：解引用操作仅适用于那些确实指向了某个对象的有效指针。 12345678910111213141516#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;int main()&#123; string name = "青木"; string name0 = "Aoki"; string* name_=&amp;name;//name_存放变量name的地址，或者说name_是指向变量name的指针 cout &lt;&lt; "大家好，我的名字是" &lt;&lt; name &lt;&lt; endl; cout &lt;&lt; "name的地址为:" &lt;&lt; name_ &lt;&lt; endl; cout &lt;&lt; "大家好，我的名字是" &lt;&lt; *name_ &lt;&lt; endl;//指针解引用，获取对象的值 *name_ = name0;//经由指针为name赋值 cout &lt;&lt; "大家好，我的名字是" &lt;&lt; name &lt;&lt; endl; cout &lt;&lt; "大家好，我的名字是" &lt;&lt; *name_ &lt;&lt; endl;&#125; ![](https://i.imgur.com/lno4Q9r.png) 空指针 空指针不指向任何对象，在试图使用一个指针之前，代码可以首先检查它是否为空。生成空指针的方法： 12int* p1=nullptr;//等价于int* ptr=0int* p2=0;//直接将p2初始化为字面常量0 得到空指针最直接的办法是使用字面值nullptr来初始化指针。nullptr是一种特殊的指针，它可以被转换成任意其他指针类型。 赋值和指针 指针额引用都能够提供对其他的对象的间接访问，但是在具体的实现细节上两者有很大不同，其中最主要的又掉了是引用本身并不是一个对象。指针和它存放的地址之间没有这种限制。和其他任何变量一样，给指针赋值就是令它存放一个新地址，从而指向一个新对象。对于指针的赋值，前文已经给出。 其他指针操作 只要指针拥有一个合法值，就能将它用在条件表达式中。和采用算术值作为条件遵循的规则一样，如果指针的值是0，条件取false。对于两个类型相同的合法指针，可以用相等操作符或不相等操作符来比较它们，比较的结果是布尔类型。两个指针存放的地址值相同（两个指针相等），有三种可能： 它们都为空 都指向同一个对象 都指向同一个对象的下一个地址 1234567891011121314#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;int main()&#123; string name = "青木"; string* name_=&amp;name;//name_存放变量name的地址，或者说name_是指向变量name的指针 int* a = nullptr; if (name_&amp;&amp;a) //与运算，一真一假为假 cout &lt;&lt; "大家好，我是指向" &lt;&lt; name &lt;&lt; "的指针，我不为空" &lt;&lt; endl; else cout &lt;&lt; "大家好，我是空指针a，我的地址是" &lt;&lt; &amp;a &lt;&lt; endl;&#125; 输出结果如下： 最后是void*指针。 void* 指针 void* 指针是一种特殊的指针类型，可用于存放任意对象的指针，一个void指针存放着一个地址。利用void指针可以做的事有： 拿它和别的指针比较 作为函数的输入和输出 赋值给另外一个void*指针 但是我们不能直接操作void* 指针，因为它的类型未知。以void*的视角来看内存空间也仅仅是内存空间，没办法访问内存空间中所存的对象。 12345678910111213#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;int main()&#123; int a = 10; int* name_=&amp;a;//name_存放变量a的地址，或者说name_是指向变量a的指针 void* names; names = name_; cout &lt;&lt; "name_指向的值为：" &lt;&lt; *name_ &lt;&lt;",地址为："&lt;&lt;name_&lt;&lt; endl; cout &lt;&lt; "names地址为：" &lt;&lt; names &lt;&lt; endl;&#125; 输出结果： 对于void* 指针，我还有许多不解的地方，在网上搜索之后发现了一个比较详细解释void* 指针的博文——[void及void指针含义的深刻解析](https://blog.csdn.net/geekcome/article/details/6249151?reload)]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>引用</tag>
        <tag>指针</tag>
        <tag>复合类型</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++变量]]></title>
    <url>%2F2019%2F%E5%8F%98%E9%87%8F%2F</url>
    <content type="text"><![CDATA[变量定义 1.初始值不是赋值。初始化的含义是创建变量时赋予其一个初始值。而赋值的含义是把对象当前值擦除，以一个新值来代替。 2.定义可以为分为列表初始化和默认初始化。 变量声明与定义的关系 为了允许把程序拆分成多个逻辑部分来编写，C++语言支持分离式编译机制，该机制允许将程序分隔为若干个文件，每个文件可被独立编译。为了支持分离式编译，C++语言将声明和定义区别开来 声明使得名字为变量所知 定义负责创建与名字关联的实体 123extern int i; //声明i，不是定义 int j;//声明并定义j extern double pi=3.1416;//定义 标识符 C++标识符由字母、数字和下划线组成，其中必须以字母或者下划线开头，标识符的长度没有限制，但是对大小写字母敏感。 以下为变量命名规范： 标识符要能体现实际含义 变量名一般用小写字母，如index 用户自定义类名一般以大写字母开头 如果标识符由多个单词组成，则单词之间要有明显区分 名字的作用域 作用域是程序的一部分，在其中名字有其特定的含义。C++语言中，大多数作用域都以花括号为分隔。 同一个名字在不同的作用域中可能指向不同的实体，名字的有效区域始于名字的声明语句，以声明语句所在的作用域末端为结束。 嵌套的作用域 内层作用域：作用域能彼此包含，被包含的作用域为内层作用域。 外层作用域：包含着别的作用域的作用域。]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>变量</tag>
      </tags>
  </entry>
</search>

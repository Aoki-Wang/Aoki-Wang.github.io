<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[关于const限定符的一些总结]]></title>
    <url>%2FAoki%2F2019%2F03%2F11%2Fconst%E9%99%90%E5%AE%9A%E7%AC%A6%2F</url>
    <content type="text"><![CDATA[写在前面 有时候我们希望定义这样一种变量，它的值不能被改变。例如，用一个变量表示缓冲区的大小。使用变量的好处是我们觉得缓冲区不再合适的时候，很容易对其进行调整。另一方面，也应随时警惕，防止程序一不小心修改了这个值。为了满足这一要求，可以用关键词const对变量的类型加以限定。 在C++中，一个const不必创建内存空间，而在C中，const总是需要一块内存空间。在C++中，是否为const常量分配内存空间依赖于如何使用。一般来说，如果一个const仅仅用来把一个名字用一个值来代替，那么该存储空间就不必创建。 在存储空间没有分配内存的话，在进行完数据类型检查后，为了代码更加有效，值也许会折叠到代码中。不过取一个const地址，或者把它定义为extern，则会为该const创建内存空间。 在C++中，出现在所有函数之外的const作用于整个文件（也就是说它在该文件外部不可见，默认为内部连接，C++中其他标识符一般默认为外部连接。 1.初始化和const const类型的对象能完成非const类型所能完成的大部分操作，但是对于const类型对象的主要限制就是只能在const类型对的对象上执行不改变其内容的操作。 在不改变const对象的操作中还有一种是初始化，如果利用一个对象去初始化另外一个对象，则它们是不是const都无关紧要。 123456789101112#include &lt;iostream&gt;using namespace std;int main()&#123; int i = 12; const int ci = i;//i的值拷贝给了ci int j = ci; cout &lt;&lt; "i=" &lt;&lt; i &lt;&lt; endl; cout &lt;&lt; "ci=" &lt;&lt; ci &lt;&lt; endl; cout &lt;&lt; "j=" &lt;&lt; j &lt;&lt; endl;&#125; 输出结果如下： ![](https://i.imgur.com/RpcPLLp.png) 2.const引用 可以把引用绑定到const对象上，就像绑定到其他对象上一样，我们称之为——常量引用。 与普通引用不同的是，对常量的引用不能被用作修改它所绑定的对象。 错误示范如下： 3.初始化和对const的引用 引用的类型必须与其所引用对象的类型一致，但是有两个情况例外。第一个例外情况就是在初始化常量引用时，允许用任意表达式作为初始值，只要该表达式的结果能转化成引用的类型即可。 允许一个常量引用绑定非常量的对象、字面值、甚至是一般表达式。 123456789101112131415#include &lt;iostream&gt;using namespace std;int main()&#123; int i = 42; const int &amp;r1 = i;//允许将const int &amp;绑定到一个普通int对象上 const int &amp;r2 = 42;//r1是一个常量引用 const int &amp;r3 = r1 * 2;//r3是一个常量引用 cout &lt;&lt; "i=" &lt;&lt; i &lt;&lt; endl; cout &lt;&lt; "r1=" &lt;&lt; r1 &lt;&lt; endl; cout &lt;&lt; "r2=" &lt;&lt; r2 &lt;&lt; endl; cout &lt;&lt; "r3=" &lt;&lt; r3 &lt;&lt; endl;&#125; 输出结果如下： 4.对cons的引用可能引用一个并非const的对象 12345678910111213141516171819#include &lt;iostream&gt;using namespace std;int main()&#123; int i = 42; int &amp;r1 = i;//引用r1绑定对象i const int &amp;r2 = i;//常量引用r2绑定i，但是r2不能修改i的值 cout &lt;&lt; "i=" &lt;&lt; i &lt;&lt; endl; cout &lt;&lt; "r1=" &lt;&lt; r1 &lt;&lt; endl; cout &lt;&lt; "r2=" &lt;&lt; r2 &lt;&lt; endl; r1 = 10; cout &lt;&lt; "i=" &lt;&lt; i &lt;&lt; endl; cout &lt;&lt; "r1=" &lt;&lt; r1 &lt;&lt; endl; cout &lt;&lt; "r2=" &lt;&lt; r2 &lt;&lt; endl; //r2 = 5;//此处报错，因为r2是一个常量引用&#125; 输出结果如下： 对于常量引用来说，一般情况下是没有办法来对它进行修改的，但是可以使用下面的方法来尝试对常量引用进行修改。代码图如下： 1234567891011#include &lt;iostream&gt;using namespace std;int main()&#123; const int &amp;ref = 10; cout &lt;&lt; "ref=" &lt;&lt; ref &lt;&lt; endl; int *p = (int *)&amp;ref; *p = 100; cout &lt;&lt; "ref=" &lt;&lt; ref &lt;&lt; endl;&#125; 输出结果如下：这里我们使用了一个指针来对常量引用进行修改。首先，我们要知道的是，常量引用不是一个对象，编译器并没有给它分配内存空间。当我们使用指针指向常量引用时，编译器会给常量引用临时开辟一块内存空间。代码示意如下： 12int tmp=ref;//tmp有内存int *p=(int *)&amp;ref;//*p指向的是那块临时空间，临时空间看不到 5.指针和const 与引用一样，也可以令指针指向常量或非常量。类似于常量引用，指向常量的指针不能改变其所指对象的值。要想存放常量对象的地址，只能使用指向常量的指针。 实例代码如下： 123456789101112131415#include &lt;iostream&gt;using namespace std;int main()&#123; const int i = 10; //int *r1 = &amp;i;//报错，r1是一个普通指针，并不能指向一个常量 const int *r2 = &amp;i;//常量指针指向常量 //常量指针可以指向常量，但是并不能修改常量的值 cout &lt;&lt; "常量i的地址为：" &lt;&lt; &amp;i &lt;&lt; endl; cout &lt;&lt; "r2指向的地址为：" &lt;&lt; r2 &lt;&lt; endl; cout &lt;&lt; "i=" &lt;&lt; i &lt;&lt; endl; cout &lt;&lt; "r2=" &lt;&lt; *r2 &lt;&lt; endl;&#125; 输出结果如下： 6.const指针 指针是对象而引用不是，就像其他对象类型一样，允许把指针本身定义为常量。常量指针必须初始化，而且一旦初始化完成，则它的值（也就是存放在指针中的那个地址）就不能再修改。把*放在const关键字之前用以说明指针是一个常量。这样书写的意味着，不变的是指针本身的值，而不是指向的那个值。 12345678910111213141516#include &lt;iostream&gt;using namespace std;int main()&#123; int i = 10; int *const r1 = &amp;i;//r1将一直指向i const int i1 = 11; const int *const r2 = &amp;i1;//r2是指向常量的常量指针 cout &lt;&lt; "i=10时地址为：" &lt;&lt; &amp;i &lt;&lt; endl; cout &lt;&lt; "常量指针r1指向的地址为：" &lt;&lt; r1 &lt;&lt; endl; i = 100; cout &lt;&lt; "i=100时地址为：" &lt;&lt; &amp;i &lt;&lt; endl; cout &lt;&lt; "常量指针r1指向的地址为：" &lt;&lt; r1 &lt;&lt; endl;&#125; 输出结果如下： 7.顶层const 指针本身就是一个对象，它又可以指向1另外一个对象。因此指针本身是不是常量，以及指针指向的对象是不是一个常量是两个独立的问题。 顶层const表示指针本身是一个常量。 底层const表示指针所指的对象时一个常量。 更一般地，顶层const可以表示任意的对象时常量，这一点对任何数据类型都适用，如算术类型、类、指针等。底层const则与指针和引用等符合类型的基本类型有关。比较特殊的是，指针类型既可以是顶层const，也可以是底层const。 8.尽量使用const代替#define 在旧版本的C中，如果想建立一个常量，必须使用预处理器。 1#define MAX 1024; 这里我们定义的宏MAX从未被编译器看到过，因为在预处理阶段，所有的MAX已经全部被替换成了1024，于是MAX并没有将其加入符号表中。但是我们使用这个常量获得一个编译错误信息时，可能会带来一些困扰，因为这个信息可能会提到1024，但是并没有提到MAX。如果MAX被定义在一个不是我们自己写的头文件中，我们可能并不知道1024代表着什么，也许解决这个问题需要很长的时间。解决这个问题的办法就是用一个常量来替换掉上面的宏： 1const int MAX=1024； 1#undef A //卸载宏常量A ###const和#define的区别 const有类型，可进行编译器类型安全检查，#define无类型，不可进行类型检查 const有作用域，而#define不重视作用域，默认定义处到文件末尾，如果定义在指定作用域下有效的常量，那么#define就不能用。]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>限定符</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++复合类型]]></title>
    <url>%2FAoki%2F2019%2F03%2F09%2FC-%E5%A4%8D%E5%90%88%E7%B1%BB%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[复合类型是指基于其他类型定义的类型。C++有几种复合类型，下面主要是引用和指针。 定义复合类型的变量复杂很多，通用的描述为：一条声明语句由一个基本数据类型和紧随其后的一个声明符列表组成。每个声明符命名了一个变量并指定该变量为与基本数据类型有关的某种类型。 引用 C++11中新增加了一种引用，为右值引用，主要用于内置类。这里，我们使用引用时，指的是左值引用。 引用为对象起了另外一个名字，引用类型引用另外一种类型。通过将声明符写成&amp;d的形式来定义引用类型，其中d是声明的变量名。引用即别名，并非对象，它只是为一个已经存在的对象所起的另外一个名字。下面是引用的一个例子。 123456789101112#include &lt;iostream&gt;using namespace std;int main()&#123; int vale = 1024; int &amp;vale00 = vale; //注意：引用必须进行初始化 cout &lt;&lt; "vale的值为：" &lt;&lt; vale &lt;&lt; endl; cout &lt;&lt; "vale00的值为：" &lt;&lt; vale00 &lt;&lt; endl; cout &lt;&lt; "vale00是vale的引用。" &lt;&lt; endl;&#125; 定义了一个引用之后，对其进行的所有操作都是在与之绑定的对象上进行的。为引用赋值，实际上是把值赋给了与引用绑定的对象。获取引用的值，实际上是获取到了与之绑定的对象的值。同理，以引用作为初始值，实际上是以引用绑定的对象作为初始值。 1234567891011121314#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;int main()&#123; string name = "青木"; string &amp;name_ = name; string name0 = "Aoki"; cout &lt;&lt; "大家好，我的名字是" &lt;&lt; name_ &lt;&lt; endl; cout &lt;&lt; "大家好，我是" &lt;&lt; name0 &lt;&lt; endl; name0 = name_;//为引用赋值 cout &lt;&lt; "大家好，我现在是" &lt;&lt; name0 &lt;&lt; endl;&#125; 输出结果为： 引用 指针是指向另外一种类型的复合类型。与引用类似，指针也实现了对其他对象的间接访问，但是指针与引用也有很多不同点，如下： 指针本身就是个对象，允许对指针赋值和拷贝，在指针的生命周期内，它可以先后指向几个不同的对象 指针无须在定义时赋初值。和其他内置类型一样，在块作用域内定义的指针如果没有定义，也将拥有一个不确定的值。 >## 获取对象的地址 指针存放某个对象的地址，要向获取该地址，就要使用取地址符（&amp;）。在声明语句中，指针的类型实际上被用于它所指向的对象的类型，所以二者必须匹配。如果指针指向了一个其他类型的对象，对该对象的操作将会发生错误。 123456789101112#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;int main()&#123; string name = "青木"; string* name_=&amp;name;//name_存放变量name的地址，或者说name_是指向变量name的指针 cout &lt;&lt; "大家好，我的名字是" &lt;&lt; name &lt;&lt; endl; cout &lt;&lt; "name的地址为:" &lt;&lt; name_ &lt;&lt; endl; cout &lt;&lt; "大家好，我的名字是" &lt;&lt; name_ &lt;&lt; endl;&#125; 输出结果为： 指针值 指针的值（即地址）应属于下列4中状态之一： 指向一个对象 指向紧邻对象所占空间的下一个位置 空指针，意味着指针没有指向任何值 无效指针，就是上述状态之外的其他值。 对于无效指针，试图拷贝或以其他方式访问无效指针的值都将引发错误。 >## 利用指针访问对象 如果一个指针指向了一个对象，则允许使用解引用符（*）来访问该对象。对指针解引用会得到所指的对象，因此如果给解引用的结果赋值，实际上也就是给指针所指的内容赋值。 注意：解引用操作仅适用于那些确实指向了某个对象的有效指针。 12345678910111213141516#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;int main()&#123; string name = "青木"; string name0 = "Aoki"; string* name_=&amp;name;//name_存放变量name的地址，或者说name_是指向变量name的指针 cout &lt;&lt; "大家好，我的名字是" &lt;&lt; name &lt;&lt; endl; cout &lt;&lt; "name的地址为:" &lt;&lt; name_ &lt;&lt; endl; cout &lt;&lt; "大家好，我的名字是" &lt;&lt; *name_ &lt;&lt; endl;//指针解引用，获取对象的值 *name_ = name0;//经由指针为name赋值 cout &lt;&lt; "大家好，我的名字是" &lt;&lt; name &lt;&lt; endl; cout &lt;&lt; "大家好，我的名字是" &lt;&lt; *name_ &lt;&lt; endl;&#125; ![](https://i.imgur.com/lno4Q9r.png) 空指针 空指针不指向任何对象，在试图使用一个指针之前，代码可以首先检查它是否为空。生成空指针的方法： 12int* p1=nullptr;//等价于int* ptr=0int* p2=0;//直接将p2初始化为字面常量0 得到空指针最直接的办法是使用字面值nullptr来初始化指针。nullptr是一种特殊的指针，它可以被转换成任意其他指针类型。 赋值和指针 指针额引用都能够提供对其他的对象的间接访问，但是在具体的实现细节上两者有很大不同，其中最主要的又掉了是引用本身并不是一个对象。指针和它存放的地址之间没有这种限制。和其他任何变量一样，给指针赋值就是令它存放一个新地址，从而指向一个新对象。对于指针的赋值，前文已经给出。 其他指针操作 只要指针拥有一个合法值，就能将它用在条件表达式中。和采用算术值作为条件遵循的规则一样，如果指针的值是0，条件取false。对于两个类型相同的合法指针，可以用相等操作符或不相等操作符来比较它们，比较的结果是布尔类型。两个指针存放的地址值相同（两个指针相等），有三种可能： 它们都为空 都指向同一个对象 都指向同一个对象的下一个地址 1234567891011121314#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;int main()&#123; string name = "青木"; string* name_=&amp;name;//name_存放变量name的地址，或者说name_是指向变量name的指针 int* a = nullptr; if (name_&amp;&amp;a) //与运算，一真一假为假 cout &lt;&lt; "大家好，我是指向" &lt;&lt; name &lt;&lt; "的指针，我不为空" &lt;&lt; endl; else cout &lt;&lt; "大家好，我是空指针a，我的地址是" &lt;&lt; &amp;a &lt;&lt; endl;&#125; 输出结果如下： 最后是void*指针。 void* 指针 void* 指针是一种特殊的指针类型，可用于存放任意对象的指针，一个void指针存放着一个地址。利用void指针可以做的事有： 拿它和别的指针比较 作为函数的输入和输出 赋值给另外一个void*指针 但是我们不能直接操作void* 指针，因为它的类型未知。以void*的视角来看内存空间也仅仅是内存空间，没办法访问内存空间中所存的对象。 12345678910111213#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;int main()&#123; int a = 10; int* name_=&amp;a;//name_存放变量a的地址，或者说name_是指向变量a的指针 void* names; names = name_; cout &lt;&lt; "name_指向的值为：" &lt;&lt; *name_ &lt;&lt;",地址为："&lt;&lt;name_&lt;&lt; endl; cout &lt;&lt; "names地址为：" &lt;&lt; names &lt;&lt; endl;&#125; 输出结果： 对于void* 指针，我还有许多不解的地方，在网上搜索之后发现了一个比较详细解释void* 指针的博文——[void及void指针含义的深刻解析](https://blog.csdn.net/geekcome/article/details/6249151?reload)]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>引用</tag>
        <tag>指针</tag>
        <tag>复合类型</tag>
      </tags>
  </entry>
</search>

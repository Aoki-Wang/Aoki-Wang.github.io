<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[软件工程的内容和方法]]></title>
    <url>%2FAoki%2F2019%2F06%2F14%2F%E5%B7%A5%E7%A8%8B%E7%9A%84%E5%86%85%E5%AE%B9%E5%92%8C%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[写在前面&emsp;经过一个礼拜的准备，终于结束了软件工程的复习。在复习软件工程的同时也在做信息系统综合设计的课程设计。在做课程设计的过程中，发现了软件工程的重要性和必要性。作为立志成为程序猿的我，软件工程在将来的工作中一定大有用处，故总结如下。 一、软件、软件工程、软件工程学科体系学习软件工程，首先得知道软件是什么。其次，得知道软件工程是做什么的，它研究了什么内容，同时也应该知道软件工程学科体系是什么，与软件工程有什么关系。 软件：最新定义为，软件=知识+程序+数据+文档那么这里面的知识，程序，数据，文档又是指什么呢？ 知识，即各种各样的相关领域的专业知识。 程序，即使对计算机任务的处理对象和处理规则的描述。这里，我们一定要注意，软件并不等于程序，这也是一大误区。 数据，即程序赖以运行的初始化数据。 文档，即为了理解程序所需的详细描述性资料。 软件工程是什么？软件工程是研究软件开发和管理的一门工程学科。 这个定义很短，但是知识点还是挺多的。一强调开发，毕竟开发是软件工程的主体；二强调管理或过程管理，当然，管理是为了更好的开发；三是强调工程，把软件的开发和维护当成一项工程，用工程的办法去开发，按工程的办法去管理；四是强调学科，时至今日，软件工程不只是一门学科，而是一个学科体系。这里也就引出了软件工程学科体系。 软件工程来源于软件危机。软件工程是为了克服软件危机才产生的。 软件工程学科体系 软件工程作为一个学科体系，到21世纪才初步形成。2004年ACM和IEEE-CS联合制订了SWEBOK 2004版，它将软件工程学科体系的知识划分为10个知识域。 对于这10个知识域，我的理解是它覆盖了整个软件生命周期。 1） 软件需求 2）软件设计 3）软件构造 4）软件测试 5）软件维护 6）软件配置管理 7）软件工程管理 8）软件工程过程 9）软件工程工具和方法 10）软件质量 软件工程和软件工程学科体系的关系总体上来说，软件工程是一个局部问题，而软件工程学科体系是一个整体问题。 软件工程研究的内容软件工程研究的内容主要有五个方面。 一是软件生命周期模型 二是软件开发方法 三是软件支持过程 四是软件管理过程 五是软件工程标准与规范 软件工程基本原理软件工程的三要素：方法、工具和过程 有7个基本原理，外加一个二八定律。具体内容见文章末尾的链接。 软件工程在行业中的作用软件工程作为一门工程管理学科，它对软件行业的作用毋庸置疑。那么，这里会有一个问题，既然已经有软件工程了，那么还会不会出现软件危机呢？我的答案是会的。软件工程的产生是为了克服软件危机，但是它的存在并不会完全消除软件危机。这和现实社会中法律存在的意义是相通的。法律的产生是为了消除犯罪，但是法律的存在并不会完全消除犯罪（至少在当前的社会阶段是不会的）。 软件工程可以作用到从业者，也可以作用到项目组，作用到软件公司，甚至作用到整个国家的软件产业1发展。 二、软件工程方法论和软件工程实践论1. 软件工程方法论是什么？软件工程方法论实质上是软件工程中软件开发方法的集合。 那么软件工程方法的集合包括哪些元素呢？ 2. 软件工程方法集合软件工程方法集合包括面向过程方法、面向对象方法、面向元数据方法。 3. 为什么说面向对象方法可以描述无穷的信息世界呢？要搞清楚面向对象为什么可以描述无穷的世界，首先需要知道面向对象方法是什么，其次，需要知道现实世界和软件的普遍联系。 面向对象方法是什么？是一种运用对象、类、消息传递、继承、封装、聚合、多态性等概念构造软件系统的软件开发方法。 我记得高中哲学里面听到的一句话，世界是物质的，物质是运动的，运动是有规律的。而对于软件而言，其实质是对现实人工系统的一种映射、优化和替换。通过对现实世界的分析，我们可以知道，世界是由对象组成的，对象之间时存在普遍联系的，而物质运动则说明了对象的功能。 面向方法是将这现实世界抽象映射为对象的手段。分析设计时由对象抽象出类，程序运行时由类还原到了对象。所以它能够描述无穷的信息世界。 4. 软件工程实践论是什么？软件工程实践论是研究在开发一个大型软件系统时，到底应该怎样选取合适的开发方法。 5. 软件工程实践论指什么？“五个面向”实践论，指面向流程分析、面向元数据设计、面向对象实现、面向功能测试、面向过程管理。 在后面，我们会发现软件工程的“五个面向”实践论在各个软件生命周期模型中都有一定的体现。 三、软件支持过程、软件管理过程 软件过程是什么？软件过程，指软件生命周期中的时间序列 软件支持过程是什么？软件支持过程，由支持软件生命周期模型各个阶段的生产工具组成。 软件生命周期中的生产工具有哪些？CASE工具、软件开发环境SDE、软件工程环境SEE 软件管理是什么？管理过程和支持过程又称为“软件过程工程”。它是软件工程的一部分。 软件管理实质上是过程管理。 软件管理有哪几类？ISO 9001质量管理和质量保证体系 CMMI软件能力成熟度模型 软件企业文化，包括微软企业文化，IBM企业文化，敏捷文化。]]></content>
      <tags>
        <tag>软件工程</tag>
        <tag>软件工程方法论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[宏缺陷和内联函数]]></title>
    <url>%2FAoki%2F2019%2F03%2F18%2F%E5%AE%8F%E7%BC%BA%E9%99%B7%E5%92%8C%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[写在前面 C++从C中继承的一个重要特征就是效率。 在C中我们经常把一些短并且执行频繁的计算写成宏，而不是函数，这样做的理由方式为了执行效率，宏可以避免函数调用的开销，这些都由预处理来完成。 但是在C++出现以后，使用宏处理会出现两个问题： 第一个在C中也会出现，宏看起来像是一个函数调用，但是会隐藏一些难以发现的错误。 第二个问题是C++特有的，预处理器不允许访问类的成员，也就是说预处理器宏不能用作类的成员的函数。 为了保持预处理宏的效率又增加安全性，而且能像一般成员函数那样在类里访问自如，C++引入了内联函数。 内联函数为了继承宏函数的效率，没有函数调用的开销，然后又可以像普通函数那样，可以进行参数、返回值类型的安全检查，又可以作为成员函数。 1.预处理宏的缺陷 预处理器宏存在问题的关键是我们可能认为预处理器的行为和编译器时一样的。当然也是由于宏函数调用和函数调用在外表看起来是一样的，因此也容易混淆。但是其中会有一些微妙的问题出现。 例112345678910111213141516171819202122232425262728293031323334353637#include &lt;iostream&gt;using namespace std;#define ADD(x,y) x+yvoid test()&#123; int ret = ADD(10, 10); int ret0 = ADD(10, 10) * 10;//预期结果为200 cout &lt;&lt; "ret=" &lt;&lt; ret &lt;&lt; endl; cout &lt;&lt; "ret0=" &lt;&lt; ret0 &lt;&lt; endl;&#125;int main()&#123; test();&#125; 输出结果如下： 在输出结果里，我们可以看到，实际输出结果为110，并不是我们想要的结果。它实际进行运算时，运算式应该是：10+10*10。 对于这个微小的问题，我们可以通过加括号的方式来解决它。源代码和输出结果如下： 123456789101112131415161718192021222324252627282930313233#include &lt;iostream&gt;using namespace std;#define ADD(x,y) ((x)+(y))void test()&#123; int ret = ADD(10, 10); int ret0 = ADD(10, 10) * 10;//预期结果为200 cout &lt;&lt; "ret=" &lt;&lt; ret &lt;&lt; endl; cout &lt;&lt; "ret0=" &lt;&lt; ret0 &lt;&lt; endl;&#125;int main()&#123; test();&#125; 输出结果如下： 我们可以看到，加括号之后，输出结果和预期相同。 例2为了防止出现例1中的问题，这次，我特意对三目运算符加了括号。代码如下： 1234567891011121314151617181920212223242526272829303132333435#include &lt;iostream&gt;using namespace std;#define compare(a,b) ((a)&lt;(b))?(a):(b)void test()&#123; int a = 10; int b = 20; int ret = compare(a, b); cout &lt;&lt; "ret=" &lt;&lt; ret &lt;&lt; endl; int ret0 = compare(++a, b); cout &lt;&lt; "ret0=" &lt;&lt; ret0 &lt;&lt; endl;&#125;int main()&#123; test();&#125; 输出结果如下: 这次出现的问题让人有点摸不到头脑，因此++运算符表示在进行运算之前加1，但是输出结果中，实际输出为12，相当于加了两次。 除此之外，我们还应当注意的是，预定义宏函数没有作用域概念，无法作为一个类的成员函数，也就是说，预定义宏没办法表示类的范围。 2.内联函数 在C++中，预定义宏额概念是用内联函数来实现的，而内联函数本身也是一个真正的函数。内联函数具有普通函数的所有行为。唯一不同之处在于内联函数会在适当得到地方像预定义宏一样展开，所以不需要函数调用的开销。因此应该不使用宏，使用内联函数。 普通函数（非成员函数）函数前面加上inline关键字使之成为内联函数。但是必须注意函数体和声明结合在一起，否则编译器会把它当成普通函数对待。 1inline void func(int a); 上面的这种写法没有任何效果，仅仅是声明函数，应该像下面这样的方式来定义。 1234567inline void func(int a)&#123; return ++;&#125; 注意：编译器将会检查函数参数列表使用是否正确，并返回值（进行必要的转换）。这些事预处理器是无法完成的。 内联函数的确占用空间，但是内联函数相对于普通函数的优势只是省去了函数调用是否的压栈、跳转、返回的开销。我们可以理解为内联函数是以空间换时间。 内联说明只是向编译器发出一个请求，编译器可以选择忽略这个请求。 一般来说，内联机制用于优化规模较小、流程直接、频繁调用的函数。很多编译器都不支持内联函数递归函数，而且一个75行的函数也不太可能在调用点内联地展开。]]></content>
      <tags>
        <tag>宏缺陷</tag>
        <tag>内联函数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[函数默认参数及占位参数]]></title>
    <url>%2FAoki%2F2019%2F03%2F18%2F%E5%87%BD%E6%95%B0%E9%BB%98%E8%AE%A4%E5%8F%82%E6%95%B0%E5%8F%8A%E5%8D%A0%E4%BD%8D%E5%8F%82%E6%95%B0%2F</url>
    <content type="text"><![CDATA[1.函数默认参数C++在声明函数原型时可为一个或多个参数指定默认（缺省）的参数值，当函数调用的时候如果没有指定这个值，编译器会自动用默认值代替。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;iostream&gt;using namespace std;void func01(int a = 10, int b = 100)&#123; cout &lt;&lt; "a+b=" &lt;&lt; a + b &lt;&lt; endl;&#125;void func02(int a, int b = 12, int c = 11)&#123; cout &lt;&lt; "a=" &lt;&lt; a &lt;&lt; ",b=" &lt;&lt; b &lt;&lt; ",c=" &lt;&lt; c &lt;&lt; endl;&#125;void func03(int a = 0, int b = 0);void func03(int a, int b)&#123; cout &lt;&lt; "a=" &lt;&lt; a &lt;&lt; ",b=" &lt;&lt; b &lt;&lt; endl;&#125;int main()&#123; func01();//使用默认参数 func01(100, 100);//使用现在传入的参数 func01(110);//只传入一个参数，第二个参数使用默认参数 func02(12);//b，c使用默认参数 func03();//没有传参数，使用默认参数 return 0;&#125; 输出结果如下： 注意点： 函数的默认常数函数从左往右，如果一个参数设置了默认参数，那么这个参数之后的参数都必须设置默认参数。 如果函数声明和函数定义分开写，函数声明与函数定义不能同时设置默认参数。 2.函数的占位符 C++在声明函数时，可以使用占位参数。占位参数只有类型声明，而没有参数名声明。一般情况下，在函数体内无法使用占位参数。 12345678910111213141516171819202122232425262728293031323334353637#include &lt;iostream&gt;using namespace std;void func01(int a,int b,int) &#123; //函数内部无法使用占位参数 cout &lt;&lt; a + b &lt;&lt; endl;&#125;void func02(int a, int b, int = 10)&#123; //无法使用占位参数 cout &lt;&lt; a + b &lt;&lt; endl;&#125;int main()&#123; func01(10, 15, 20); func02(10, 25);//占位参数使用默认参数 return 0;&#125; 输出结果如下：]]></content>
      <tags>
        <tag>默认参数</tag>
        <tag>占位参数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++命名空间及using的使用]]></title>
    <url>%2FAoki%2F2019%2F03%2F16%2FC-%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%E5%8F%8Ausing%E7%9A%84%E4%BD%BF%E7%94%A8-1%2F</url>
    <content type="text"><![CDATA[一、C++命名空间&emsp;在C++中，名称（name）可以是符号常量、变量、函数、结构、枚举、类和对象。工程越大，名称相互冲突性的可能性越大。另外，在使用多个厂商的类库时，也可能导致名称冲突。为了避免冲突，在大规模的设计中，以及程序员使用1各种各样的C++库时，这些标识符的命名发生冲突，标准C++引入关键字namesapce（命名空间/名字空间/名称空间），可以更好的控制标识符得到作用域。 12345678910111213141516171819202122232425262728293031323334353637#include &lt;iostream&gt;using namespace std;//创建一个命名空间namespace study&#123; int a = 10;&#125;namespace learn&#123; int a = 20;&#125;int main()&#123; cout &lt;&lt; "命名空间study的a="&lt;&lt;study::a &lt;&lt; endl; cout &lt;&lt;"命名空间learn的a="&lt;&lt; learn::a &lt;&lt; endl;&#125; 运行结果输出： 在命名空间下，可以定义函数，变量、结构体、类；除此之外，对于命名空间的定义还应当注意，它必须定义在全局作用域下。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include &lt;iostream&gt;#include&lt;string&gt;using namespace std;namespace study&#123; int a = 10; namespace A &#123; int a = 100; void sayhi() &#123; cout &lt;&lt; "hi,Aoki" &lt;&lt; endl; &#125; struct Student &#123; string name; &#125;; &#125;&#125;namespace learn&#123; int a = 20;&#125;int main()&#123; //cout &lt;&lt; "命名空间study的a="&lt;&lt;study::a &lt;&lt; endl; //cout &lt;&lt;"命名空间learn的a="&lt;&lt; learn::a &lt;&lt; endl; study::A::sayhi(); cout &lt;&lt; "作用域A下的a=" &lt;&lt; study::A::a &lt;&lt; endl;&#125; 输出结果： 下面是对命名空间错误定义的举例： 对于命名空间，我们还可以定义无名命名空间，意味着命名空间中的标识符只能在本文件中访问，相当于给这个标识符加上了static，使得其可以作为内部连接。 除此之外，还有就是给命名空间起别名，我们为命名空间A起别名为b，源码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;iostream&gt;#include&lt;string&gt;using namespace std;namespace A&#123; int a = 100; void test() &#123; namespace b = A;//给命名空间起别名为b cout &lt;&lt;"A作用域内a="&lt;&lt; b::a &lt;&lt; endl; &#125;&#125;namespace //无名（匿名）命名空间&#123; int c = 15; int d = 16;&#125;int main()&#123; cout &lt;&lt; "c=" &lt;&lt; c &lt;&lt; endl; cout &lt;&lt; "d=" &lt;&lt; d &lt;&lt; endl; A::test();&#125; 运行结果如下图： 下面对命名空间namespace的用法总结如下： 命名空间的用途：解决名称冲突问题 命名空间下可以定义函数、变量、结构、类 命名空间必须定义在全局作用域下 命名空间可以嵌套命名空间 命名空间是开放的，可以随时给原先的命名空间添加内容 定义另个名字相同的命名空间时，两个命名空间会合并，但是不会覆盖 当我们定义了无名空间时，相当于写了static intc=15，static int d=16，只能在当前文件内使用 二、using声明using声明可使得指定的标识符可用 1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;iostream&gt;using namespace std;namespace One&#123; int test = 100;&#125;void test()&#123; int test = 100; using One::test;//using声明 cout &lt;&lt; "test=" &lt;&lt; test &lt;&lt; endl;&#125;int main()&#123; test();&#125; 此处我们使用了using声明，但是编译却发生了错误。因为在test()中我们定义了一个整型数test，并赋予了初值。当我们使用using声明时，编译器有就近原则，它会选择输出test中定义的整型数，但是又发现有using声明，出现二义性问题，编译器不知道怎么处理，所有报错。报错信息如下： 所以，在using声明中，我们应当注意避免二义性问题。 1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;iostream&gt;using namespace std;namespace One&#123; int test = 100;&#125;void test()&#123; int test = 100; //using One::test;//using声明 cout &lt;&lt; "test=" &lt;&lt; test &lt;&lt; endl;&#125;int main()&#123; test();&#125; 输出结果如下图： using声明的一个例子： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include &lt;iostream&gt;using namespace std;namespace One&#123; int test = 100; int a = 99; int b = 30; void func() &#123; cout &lt;&lt; "hi,Aoki!" &lt;&lt; endl; &#125; void func1() &#123; cout &lt;&lt; "hello,Aoki!" &lt;&lt; endl; &#125;&#125;void test()&#123; cout &lt;&lt; "test=" &lt;&lt; One::a &lt;&lt; endl; //using声明 using One::a; using One::func1; using One::func; cout &lt;&lt; "a=" &lt;&lt; a &lt;&lt; endl; func1(); func();&#125;int main()&#123; test();&#125; 运行结果如下图： 下面是using声明遇到函数重载的一个例子： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include &lt;iostream&gt;using namespace std;namespace Two&#123; void func() &#123; cout &lt;&lt; "Nothing!" &lt;&lt; endl; &#125; void func(int x) &#123; cout &lt;&lt; x &lt;&lt; endl; &#125; void func(int x, int y) &#123; cout &lt;&lt; "x=" &lt;&lt; x ; cout &lt;&lt; ",y=" &lt;&lt; y &lt;&lt; endl; &#125;&#125;void test1()&#123; using Two::func; func(); func(15); func(15, 20);&#125;int main()&#123; test1();&#125; 输出结果如下图： 如果命名空间包含一组用相同名字重载的函数，using声明就声明了这个重载函数的所有集合。 三、using编译指令using编译指令使整个命名空间标识符可用。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879#include &lt;iostream&gt;using namespace std;namespace One&#123; int a = 99; int b = 30; void func() &#123; cout &lt;&lt; "hi,Aoki!" &lt;&lt; endl; &#125; void func1() &#123; cout &lt;&lt; "hello,Aoki!" &lt;&lt; endl; &#125;&#125;void test()&#123; using namespace One; cout &lt;&lt; a &lt;&lt; endl; cout &lt;&lt; b &lt;&lt; endl; func(); func1(); int a = 100;//没有产生二义性 cout &lt;&lt; a &lt;&lt; endl;&#125;namespace Two&#123; int a = 1; int b = 2;&#125;;void test1()&#123; //产生二义性 using namespace One; using namespace Two; cout &lt;&lt; a &lt;&lt; endl;&#125; 当我们像上面一样使用using编译指令时，会出现二义性问题，编译器无法通过编译。错误信息如下： 当我们使用using声明或using编译指令时，会增加命名冲突的可能性。也就是说，如果有命名空间，并在代码中使用作用域解析运算符，则不会出现二义性问题。 例子如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091#include &lt;iostream&gt;using namespace std;namespace One&#123; int a = 99; int b = 30; void func() &#123; cout &lt;&lt; "hi,Aoki!" &lt;&lt; endl; &#125; void func1() &#123; cout &lt;&lt; "hello,Aoki!" &lt;&lt; endl; &#125;&#125;void test()&#123; using namespace One; cout &lt;&lt; a &lt;&lt; endl; cout &lt;&lt; b &lt;&lt; endl; func(); func1(); int a = 100; cout &lt;&lt; a &lt;&lt; endl;&#125;namespace Two&#123; int a = 1; int b = 2;&#125;;void test1()&#123; using namespace One; using namespace Two; //cout &lt;&lt; a &lt;&lt; endl;&#125;int main()&#123; test(); test1();&#125; 输出结果如下： 当我们引入一个全局的using编译指令时，就为该文件打开了命名空间，它不会影响其他的文件，所以可以再每一个实现文件中调整对命名空间的控制。比如，如果发现某一个实现文件中有太多using指令而产生命名冲突，就要对该文件做个简单的改变，通过明确限定或者using声明来消除名字冲突，这样不需要修改其他实现文件。]]></content>
      <tags>
        <tag>命名空间</tag>
        <tag>using的使用</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于const限定符的一些总结]]></title>
    <url>%2FAoki%2F2019%2F03%2F11%2Fconst%E9%99%90%E5%AE%9A%E7%AC%A6%2F</url>
    <content type="text"><![CDATA[写在前面 有时候我们希望定义这样一种变量，它的值不能被改变。例如，用一个变量表示缓冲区的大小。使用变量的好处是我们觉得缓冲区不再合适的时候，很容易对其进行调整。另一方面，也应随时警惕，防止程序一不小心修改了这个值。为了满足这一要求，可以用关键词const对变量的类型加以限定。 在C++中，一个const不必创建内存空间，而在C中，const总是需要一块内存空间。在C++中，是否为const常量分配内存空间依赖于如何使用。一般来说，如果一个const仅仅用来把一个名字用一个值来代替，那么该存储空间就不必创建。 在存储空间没有分配内存的话，在进行完数据类型检查后，为了代码更加有效，值也许会折叠到代码中。不过取一个const地址，或者把它定义为extern，则会为该const创建内存空间。 在C++中，出现在所有函数之外的const作用于整个文件（也就是说它在该文件外部不可见，默认为内部连接，C++中其他标识符一般默认为外部连接。 1.初始化和const const类型的对象能完成非const类型所能完成的大部分操作，但是对于const类型对象的主要限制就是只能在const类型对的对象上执行不改变其内容的操作。 在不改变const对象的操作中还有一种是初始化，如果利用一个对象去初始化另外一个对象，则它们是不是const都无关紧要。 123456789101112#include &lt;iostream&gt;using namespace std;int main()&#123; int i = 12; const int ci = i;//i的值拷贝给了ci int j = ci; cout &lt;&lt; "i=" &lt;&lt; i &lt;&lt; endl; cout &lt;&lt; "ci=" &lt;&lt; ci &lt;&lt; endl; cout &lt;&lt; "j=" &lt;&lt; j &lt;&lt; endl;&#125; 输出结果如下： ![](https://i.imgur.com/RpcPLLp.png) 2.const引用 可以把引用绑定到const对象上，就像绑定到其他对象上一样，我们称之为——常量引用。 与普通引用不同的是，对常量的引用不能被用作修改它所绑定的对象。 错误示范如下： 3.初始化和对const的引用 引用的类型必须与其所引用对象的类型一致，但是有两个情况例外。第一个例外情况就是在初始化常量引用时，允许用任意表达式作为初始值，只要该表达式的结果能转化成引用的类型即可。 允许一个常量引用绑定非常量的对象、字面值、甚至是一般表达式。 123456789101112131415#include &lt;iostream&gt;using namespace std;int main()&#123; int i = 42; const int &amp;r1 = i;//允许将const int &amp;绑定到一个普通int对象上 const int &amp;r2 = 42;//r1是一个常量引用 const int &amp;r3 = r1 * 2;//r3是一个常量引用 cout &lt;&lt; "i=" &lt;&lt; i &lt;&lt; endl; cout &lt;&lt; "r1=" &lt;&lt; r1 &lt;&lt; endl; cout &lt;&lt; "r2=" &lt;&lt; r2 &lt;&lt; endl; cout &lt;&lt; "r3=" &lt;&lt; r3 &lt;&lt; endl;&#125; 输出结果如下： 4.对cons的引用可能引用一个并非const的对象 12345678910111213141516171819#include &lt;iostream&gt;using namespace std;int main()&#123; int i = 42; int &amp;r1 = i;//引用r1绑定对象i const int &amp;r2 = i;//常量引用r2绑定i，但是r2不能修改i的值 cout &lt;&lt; "i=" &lt;&lt; i &lt;&lt; endl; cout &lt;&lt; "r1=" &lt;&lt; r1 &lt;&lt; endl; cout &lt;&lt; "r2=" &lt;&lt; r2 &lt;&lt; endl; r1 = 10; cout &lt;&lt; "i=" &lt;&lt; i &lt;&lt; endl; cout &lt;&lt; "r1=" &lt;&lt; r1 &lt;&lt; endl; cout &lt;&lt; "r2=" &lt;&lt; r2 &lt;&lt; endl; //r2 = 5;//此处报错，因为r2是一个常量引用&#125; 输出结果如下： 对于常量引用来说，一般情况下是没有办法来对它进行修改的，但是可以使用下面的方法来尝试对常量引用进行修改。代码图如下： 1234567891011#include &lt;iostream&gt;using namespace std;int main()&#123; const int &amp;ref = 10; cout &lt;&lt; "ref=" &lt;&lt; ref &lt;&lt; endl; int *p = (int *)&amp;ref; *p = 100; cout &lt;&lt; "ref=" &lt;&lt; ref &lt;&lt; endl;&#125; 输出结果如下：这里我们使用了一个指针来对常量引用进行修改。首先，我们要知道的是，常量引用不是一个对象，编译器并没有给它分配内存空间。当我们使用指针指向常量引用时，编译器会给常量引用临时开辟一块内存空间。代码示意如下： 12int tmp=ref;//tmp有内存int *p=(int *)&amp;ref;//*p指向的是那块临时空间，临时空间看不到 5.指针和const 与引用一样，也可以令指针指向常量或非常量。类似于常量引用，指向常量的指针不能改变其所指对象的值。要想存放常量对象的地址，只能使用指向常量的指针。 实例代码如下： 123456789101112131415#include &lt;iostream&gt;using namespace std;int main()&#123; const int i = 10; //int *r1 = &amp;i;//报错，r1是一个普通指针，并不能指向一个常量 const int *r2 = &amp;i;//常量指针指向常量 //常量指针可以指向常量，但是并不能修改常量的值 cout &lt;&lt; "常量i的地址为：" &lt;&lt; &amp;i &lt;&lt; endl; cout &lt;&lt; "r2指向的地址为：" &lt;&lt; r2 &lt;&lt; endl; cout &lt;&lt; "i=" &lt;&lt; i &lt;&lt; endl; cout &lt;&lt; "r2=" &lt;&lt; *r2 &lt;&lt; endl;&#125; 输出结果如下： 6.const指针 指针是对象而引用不是，就像其他对象类型一样，允许把指针本身定义为常量。常量指针必须初始化，而且一旦初始化完成，则它的值（也就是存放在指针中的那个地址）就不能再修改。把*放在const关键字之前用以说明指针是一个常量。这样书写的意味着，不变的是指针本身的值，而不是指向的那个值。 12345678910111213141516#include &lt;iostream&gt;using namespace std;int main()&#123; int i = 10; int *const r1 = &amp;i;//r1将一直指向i const int i1 = 11; const int *const r2 = &amp;i1;//r2是指向常量的常量指针 cout &lt;&lt; "i=10时地址为：" &lt;&lt; &amp;i &lt;&lt; endl; cout &lt;&lt; "常量指针r1指向的地址为：" &lt;&lt; r1 &lt;&lt; endl; i = 100; cout &lt;&lt; "i=100时地址为：" &lt;&lt; &amp;i &lt;&lt; endl; cout &lt;&lt; "常量指针r1指向的地址为：" &lt;&lt; r1 &lt;&lt; endl;&#125; 输出结果如下： 7.顶层const 指针本身就是一个对象，它又可以指向1另外一个对象。因此指针本身是不是常量，以及指针指向的对象是不是一个常量是两个独立的问题。 顶层const表示指针本身是一个常量。 底层const表示指针所指的对象时一个常量。 更一般地，顶层const可以表示任意的对象时常量，这一点对任何数据类型都适用，如算术类型、类、指针等。底层const则与指针和引用等符合类型的基本类型有关。比较特殊的是，指针类型既可以是顶层const，也可以是底层const。 8.尽量使用const代替#define 在旧版本的C中，如果想建立一个常量，必须使用预处理器。 1#define MAX 1024; 这里我们定义的宏MAX从未被编译器看到过，因为在预处理阶段，所有的MAX已经全部被替换成了1024，于是MAX并没有将其加入符号表中。但是我们使用这个常量获得一个编译错误信息时，可能会带来一些困扰，因为这个信息可能会提到1024，但是并没有提到MAX。如果MAX被定义在一个不是我们自己写的头文件中，我们可能并不知道1024代表着什么，也许解决这个问题需要很长的时间。解决这个问题的办法就是用一个常量来替换掉上面的宏： 1const int MAX=1024； 1#undef A //卸载宏常量A ###const和#define的区别 const有类型，可进行编译器类型安全检查，#define无类型，不可进行类型检查 const有作用域，而#define不重视作用域，默认定义处到文件末尾，如果定义在指定作用域下有效的常量，那么#define就不能用。]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>限定符</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++复合类型]]></title>
    <url>%2FAoki%2F2019%2F03%2F09%2FC-%E5%A4%8D%E5%90%88%E7%B1%BB%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[复合类型是指基于其他类型定义的类型。C++有几种复合类型，下面主要是引用和指针。 定义复合类型的变量复杂很多，通用的描述为：一条声明语句由一个基本数据类型和紧随其后的一个声明符列表组成。每个声明符命名了一个变量并指定该变量为与基本数据类型有关的某种类型。 引用 C++11中新增加了一种引用，为右值引用，主要用于内置类。这里，我们使用引用时，指的是左值引用。 引用为对象起了另外一个名字，引用类型引用另外一种类型。通过将声明符写成&amp;d的形式来定义引用类型，其中d是声明的变量名。引用即别名，并非对象，它只是为一个已经存在的对象所起的另外一个名字。下面是引用的一个例子。 123456789101112#include &lt;iostream&gt;using namespace std;int main()&#123; int vale = 1024; int &amp;vale00 = vale; //注意：引用必须进行初始化 cout &lt;&lt; "vale的值为：" &lt;&lt; vale &lt;&lt; endl; cout &lt;&lt; "vale00的值为：" &lt;&lt; vale00 &lt;&lt; endl; cout &lt;&lt; "vale00是vale的引用。" &lt;&lt; endl;&#125; 定义了一个引用之后，对其进行的所有操作都是在与之绑定的对象上进行的。为引用赋值，实际上是把值赋给了与引用绑定的对象。获取引用的值，实际上是获取到了与之绑定的对象的值。同理，以引用作为初始值，实际上是以引用绑定的对象作为初始值。 1234567891011121314#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;int main()&#123; string name = "青木"; string &amp;name_ = name; string name0 = "Aoki"; cout &lt;&lt; "大家好，我的名字是" &lt;&lt; name_ &lt;&lt; endl; cout &lt;&lt; "大家好，我是" &lt;&lt; name0 &lt;&lt; endl; name0 = name_;//为引用赋值 cout &lt;&lt; "大家好，我现在是" &lt;&lt; name0 &lt;&lt; endl;&#125; 输出结果为： 引用 指针是指向另外一种类型的复合类型。与引用类似，指针也实现了对其他对象的间接访问，但是指针与引用也有很多不同点，如下： 指针本身就是个对象，允许对指针赋值和拷贝，在指针的生命周期内，它可以先后指向几个不同的对象 指针无须在定义时赋初值。和其他内置类型一样，在块作用域内定义的指针如果没有定义，也将拥有一个不确定的值。 >## 获取对象的地址 指针存放某个对象的地址，要向获取该地址，就要使用取地址符（&amp;）。在声明语句中，指针的类型实际上被用于它所指向的对象的类型，所以二者必须匹配。如果指针指向了一个其他类型的对象，对该对象的操作将会发生错误。 123456789101112#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;int main()&#123; string name = "青木"; string* name_=&amp;name;//name_存放变量name的地址，或者说name_是指向变量name的指针 cout &lt;&lt; "大家好，我的名字是" &lt;&lt; name &lt;&lt; endl; cout &lt;&lt; "name的地址为:" &lt;&lt; name_ &lt;&lt; endl; cout &lt;&lt; "大家好，我的名字是" &lt;&lt; name_ &lt;&lt; endl;&#125; 输出结果为： 指针值 指针的值（即地址）应属于下列4中状态之一： 指向一个对象 指向紧邻对象所占空间的下一个位置 空指针，意味着指针没有指向任何值 无效指针，就是上述状态之外的其他值。 对于无效指针，试图拷贝或以其他方式访问无效指针的值都将引发错误。 >## 利用指针访问对象 如果一个指针指向了一个对象，则允许使用解引用符（*）来访问该对象。对指针解引用会得到所指的对象，因此如果给解引用的结果赋值，实际上也就是给指针所指的内容赋值。 注意：解引用操作仅适用于那些确实指向了某个对象的有效指针。 12345678910111213141516#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;int main()&#123; string name = "青木"; string name0 = "Aoki"; string* name_=&amp;name;//name_存放变量name的地址，或者说name_是指向变量name的指针 cout &lt;&lt; "大家好，我的名字是" &lt;&lt; name &lt;&lt; endl; cout &lt;&lt; "name的地址为:" &lt;&lt; name_ &lt;&lt; endl; cout &lt;&lt; "大家好，我的名字是" &lt;&lt; *name_ &lt;&lt; endl;//指针解引用，获取对象的值 *name_ = name0;//经由指针为name赋值 cout &lt;&lt; "大家好，我的名字是" &lt;&lt; name &lt;&lt; endl; cout &lt;&lt; "大家好，我的名字是" &lt;&lt; *name_ &lt;&lt; endl;&#125; ![](https://i.imgur.com/lno4Q9r.png) 空指针 空指针不指向任何对象，在试图使用一个指针之前，代码可以首先检查它是否为空。生成空指针的方法： 12int* p1=nullptr;//等价于int* ptr=0int* p2=0;//直接将p2初始化为字面常量0 得到空指针最直接的办法是使用字面值nullptr来初始化指针。nullptr是一种特殊的指针，它可以被转换成任意其他指针类型。 赋值和指针 指针额引用都能够提供对其他的对象的间接访问，但是在具体的实现细节上两者有很大不同，其中最主要的又掉了是引用本身并不是一个对象。指针和它存放的地址之间没有这种限制。和其他任何变量一样，给指针赋值就是令它存放一个新地址，从而指向一个新对象。对于指针的赋值，前文已经给出。 其他指针操作 只要指针拥有一个合法值，就能将它用在条件表达式中。和采用算术值作为条件遵循的规则一样，如果指针的值是0，条件取false。对于两个类型相同的合法指针，可以用相等操作符或不相等操作符来比较它们，比较的结果是布尔类型。两个指针存放的地址值相同（两个指针相等），有三种可能： 它们都为空 都指向同一个对象 都指向同一个对象的下一个地址 1234567891011121314#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;int main()&#123; string name = "青木"; string* name_=&amp;name;//name_存放变量name的地址，或者说name_是指向变量name的指针 int* a = nullptr; if (name_&amp;&amp;a) //与运算，一真一假为假 cout &lt;&lt; "大家好，我是指向" &lt;&lt; name &lt;&lt; "的指针，我不为空" &lt;&lt; endl; else cout &lt;&lt; "大家好，我是空指针a，我的地址是" &lt;&lt; &amp;a &lt;&lt; endl;&#125; 输出结果如下： 最后是void*指针。 void* 指针 void* 指针是一种特殊的指针类型，可用于存放任意对象的指针，一个void指针存放着一个地址。利用void指针可以做的事有： 拿它和别的指针比较 作为函数的输入和输出 赋值给另外一个void*指针 但是我们不能直接操作void* 指针，因为它的类型未知。以void*的视角来看内存空间也仅仅是内存空间，没办法访问内存空间中所存的对象。 12345678910111213#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;int main()&#123; int a = 10; int* name_=&amp;a;//name_存放变量a的地址，或者说name_是指向变量a的指针 void* names; names = name_; cout &lt;&lt; "name_指向的值为：" &lt;&lt; *name_ &lt;&lt;",地址为："&lt;&lt;name_&lt;&lt; endl; cout &lt;&lt; "names地址为：" &lt;&lt; names &lt;&lt; endl;&#125; 输出结果： 对于void* 指针，我还有许多不解的地方，在网上搜索之后发现了一个比较详细解释void* 指针的博文——[void及void指针含义的深刻解析](https://blog.csdn.net/geekcome/article/details/6249151?reload)]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>引用</tag>
        <tag>指针</tag>
        <tag>复合类型</tag>
      </tags>
  </entry>
</search>

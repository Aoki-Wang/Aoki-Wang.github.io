<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Linux进程管理（一）]]></title>
    <url>%2F2019%2F08%2F06%2FLinux%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[一、进程描述&emsp;&emsp;进程的定义：进程是可并发执行的程序在一个数据集合上的运行过程。进程具有动态性、并发性、独立性、异步性等基本特征。 &emsp;&emsp;为了使参与并发执行的每个程序（含数据）都能独立地运行，在操作系统中必须为之配置一个专门的数据结构，称为进程控制块（PCB）。系统利用PCB来描述进程的基本情况和活动过程，进而控制和管理进程。这样，由程序段、相关数据段和PCB三部分便构成了进程实体。进程的程序段就是该进程所对应静态程序实体在进程地址空间中的映像，而数据段就是进程数据工作集合在进程地址空间中的映像。 &emsp;&emsp;进程控制块是系统为了管理进程而设置的专门数据结构，用于记录进程的外部特征，描述进程的运动变化过程；它包含了有关进程的描述信息、控制信息以及资源信息，是进程动态特征的集中反映。因此，系统同利用PCB来控制和管理进程。PCB是系统感知进程存在的唯一标志，所以进程与PCB是一一对应的。也就是说，进程的创建以PCB的产生为标志，进程的消亡以PCB的删除为标志。 1.Linux进程描述符&emsp;&emsp;在Linux中，PCB使用task_struct结构来描述，该结构定义在&lt;Linux/sched.h&gt;文件中，称为Linux进程描述符。该描述符结构task_struct存放在任务对内的双向链表task_list中，当有新的程序创建的时候，系统从内存中分配一个新的task_struct结构，并把它放到双向链表中，为了便于查找，系统用全局指针current指向当前运行进程的task_struct。 &emsp;&emsp;进程描述符task_struct结构包括了许多字段，下面按照字段进程管理过程中的不同作用，分为以下几类来介绍其中的基本功能。 进程的基本属性 进程之间的关系 调度相关 进程地址空间 进程的文件系统信息 进程的信号处理 进程的访问权限 资源限制 1）进程的基本属性 volatile long state 用于保存进程的状态，在进程的生命期内，可以从该域获得自己的状态，在2.6中进程可以有以下几种状态： 12345678#define TASK_RUNNING 0#define TASK_INTERRUPTIABLE 1#define TASK_UNINTERRUPTIBLE 2#define TASK_STOPPED 4#define TASK_TRACED 8#define EXIT_ZOMBIE 16#define EXIT_DEAD 32#define TASK_DEAD 64 TASK_RUNNING：进程当前正在运行，或者正在运行队列中等待调度 TASK_INTERRUPTIABLE：进程处于睡眠状态，正在等待某些事件发生。进程可以被信号中断。进程被显式唤醒或接收到信号之后，将转变为TASK_RUNNING状态。 TASK_UNINTERRUPTIBLE：进程状态类似TASK_INTERRUPTIABLE，只是它不会处理信号。中断处于这种状态的进程是不合适的，因为它可能正在完成某些重要的任务。当它所等待的事件发生时，进程将被唤醒。 TASK_STOPPED：进程已中止执行，它没有运行，并且不能运行，接收到SIGSTOP和SIGSTP等信号时，进程将进入这种状态。接收到SIGCONT信号之后，进程将再次变得可运行。 TASK_TRACED：正在被调试程序等其他进程监控时，进程将进入这种状态。 EXIT_ZOMBIE:进程已终止，它正等待其父进程收集关于它的一些统计信息。 EXIT_DEAD:最终状态，将进程从系统中删除时，它将会进入此状态，因为其父进程已经通过wait4()和waitpid()调用收集了所有统计信息。 TASK_DEAD：表示已经退出且不需要父进程回收的进程的状态。 atomic_t usage 表示对该结构的引用次数，在进程退出时，只有当对该结构的引用次数为0时，才可以删除该结构。 int lock_depth 表示大内核锁深度，主要用于实现内核的同步机制。 pid_t pid 进程标识符，系统通过进程标识符唯一地标识一个进程。pid_t是一个隐含类型，实际上就是一个int类型，为了与老版本的UNIX和Linux兼容，pid的最大默认值为32768(short int短整型数的最大值).如果需要更大的取值范围，可以修改/proc/sys/kernel/pid_max，从而提高进程数的上限。 struct pid_link pids[PIDTYPE_MAX] 标识该进程的pid所对应的哈希链表。 pid_t tgid 表示线程组的ID unsigned int flags 定义了该进程的特殊属性，flags的值定义在Linux/sched.h中。 int exit_code, exit_signal 系统强行退出时发出的信号，父进程通过这两个值来获取子进程的退出状态。exit_code表示进程的退出值，exit_signal表示进程通过信号被终止的信号值。 struct Linux_binfmt *binfmt Linux支持多种可执行文件格式，每种可执行文件格式都定义了一种数据结构，指明程序代码如何被载入内存。 unsigned int ptrace 当调用ptrace()系统调用时，prtace被设置，ptrace的值定义在linux/ptrace.h中。 char comm[TASK_COMM_LEN] 通常在命令行调用一个可执行程序来创建进程，当在命令行调用可执行程序的时候用comm表示其命令名称。 2）进程之间的关系 struct task_struct *group_leader 每个进程组都有一个被定义为该组领头的进程，如果进程是某个组的成员，group_leader则是一个指向其组领头的进程描述符的指针，组领头进程拥有自己的终端设备tty，它就是从这个终端创建的。 struct list_head thread_group 指向该进程所在进程组的所有进程链表。 struct task_struct *real_parent 指向当前进程的父进程，如果父进程已经死亡，则指向init进程。 struct task_struct *parent 指向当前进程的父进程，这个值通常和real_parent相同，但在某些情况会和real_parent不同，例如使用gdb对程序进行调试时，parent指向gdb进程。 struct list_head children 指向当前进程的子进程的链表 struct list_head sibling 指向当前进程的兄弟进程的链表。 &emsp;&emsp;Linux系统进程之间存在明显的继承关系，所有的进程都是init进程的后代，内核在系统启动的最后阶段启动此进程。系统中的每个进程都有一个父进程，相应地，每个进程可以拥有0个或多个子进程，拥有相同父进程的所有进程都成为兄弟。 3）进程调度 int prio,static_prio,normal_prio prio表示进程的动态优先级，取值范围[0,139]。根据进程prio取值的不同，可以把进程分为实时进程（prio$\in$[0,99])和非实时进程（普通进程，prio$\in$[100,139]),针对他们分别由不同的调度策略。动态优先级prio是调度器选择候选进程next的主要依据，数值越小，进程的优先级越高，越早被调度到。 static_prio是进程的静态优先级，取值范围[0,139]，进程刚被创建时从父进程继承而来，主要用于进程初始时间片的计算和动态优先级prio的计算。 normal_prio是常规动态优先级，使用“优先级继承协议”时，可能会临时提升进程的优先级，但提升后应该立即返回到其应有的优先级上。这个成员保存的正是这个“应有的优先级”。 struct list_head run_list 指向就绪队列runqueue const struct sched_class *sched_class 调度类，该调度类类似一个模块链，协助内核调度程序工作。每个调度程序模块需要实现struct sched_class建议的一组函数。 struct sched_entitu se 该结构包含了关于调度的完整信息，用于实现对于单个任务或任务组的调度，调度实体可能与进程没有关联。 undigned int policy 进程的调度策略。包括实时调度和非实时调度。 cpumask_t cpus_allowed 当存在多个处理器时，用它来指明该进程可以由哪个CPU来执行。 unsigned int time_slice 进程的时间片余额，相当于内核2.4的counter，但不再直接影响进程的动态优先级。 unsigned int rt_priority 实时进程的优先级，在调用schedule()时被更新，仅对实时进程有效。 unsigned long nvcsw,nivcsw nvcsw，主动的上下文切换数，计算非基于内核抢占的上下文切换数。nivcsw，被动的上下文切换数，计算进程被内核抢占的次数，其值仅当进程从内核返回的时候才增加。 4）进程地址空间和文件系统 struct mm_struct *mm,*active_mm mm是一个指向地址空间和内存管理相关的信息，active_mm是一个指向最近最常使用的地址空间的指针。 struct fs_struct *fs,*files fs保存了进程本身与VFS的关系信息，files包含了进程当前所打开的文件列表。 5）进程的信号管理 sigset_t saved_sigmask 进程所能接收信号的位掩码。置位表示屏蔽，复位表示不屏蔽。 struct sigpending pending 存放进程中所有挂起的信号，即记录进程所有已经触发但是还未处理的信号 struct signal_struct *signal 指向进程信号的描述符 struct sughand_struct *sighand 指向信号的处理标识符 int pdeath_signal 是父进程死亡时设置的信号 6）进程的访问权限 uid和gid 该进程的用户ID，通常是进程的创建者。因为每个用户可能属于多个组，所以还需要gid来表示该进程属于哪个用户组。 euid和egid 有效的uid和gid,处于系统安全权限的考虑，运行程序时要检查euid和egid的合法性。通常，uid等于euid，gid等于egid。有时候，系统会赋予一般用户暂时拥有root的uid和gid，以便于进行运作。 suid和sgid 根据POSIX标准引入的，在系统调用改变uid和gid时，用于保留真正的uid和gid fsuid和fsgid 文件系统的uid和gid，用于对文件系统操作时的合法性检查，是Linux独特的标识类型。它们一般分别和euid和egid一致，但在NFS文件系统中NFS服务器需要一个特殊的进程访问文件，这时只修改客户进程的fsuid和fsgid以便确保对于该文件的访问权限。 struct group_info *group_info 一个Linux进程可以属于多个用户组，group_info保存与这些组相关的信息。 二、进程的组织形式&emsp;&emsp;为了高效地对进程进行管理，内核中采用了不同的数据结构将系统中的进程通过不同方式组织起来，以满足进程管理子系统中各种不同需求。 进程链表Linux采用了双向链表将系统中的所有进程连接起来，该双向链表基于进程描述符中类型为struct list_head的成员变量tasks。 Linux内核提供了宏定义for_each_process()用于遍历系统中的每一个进程，该宏定义在需要对系统中每一个进程进行操作时非常有用。 12#define for_each_process(p)\ for(p=&amp;init_task;(p=next_task(p))!=&amp;init_task;) 其中，init_task是系统初始化过程中创建的第一个进程的进程描述符，宏定义next_task表示链表的下一个进程。 函数原型 说明 next_task(p) 当前进程p的下一进程 add_task(p) 从p的父进程孩子链表中添加该进程 remove_task(p) 从p的父进程孩子链表中删除该进程 哈希链表&emsp;&emsp;内核中使用一个进程描述符来表示一个进程，因此通过进程描述符的地址来访问一个进程再方便不过了。但是POSIX规范中规定，每一个进程要有进程号，而且POSIX规范中规定的系统调用kill()是基于进程号向其他进程发送信号的。这就需要一种机制来高效地完成从进程号到进程描述符地址的转换。Linux内核引入了哈希表来完成进程号到进程描述符task_struct结构的映射。 &emsp;&emsp;根据进程类型的不同以及效率上的考虑，内核设置了PIDTYPE_MAX（默认值为3）个不同用途的哈希表，哈希表的类型使用枚举类型pid_type进行定义。 1234567enum pid_type&#123; PIDTYPE_PID, PIDTYPE_PGID, PIDTYPE_SID, PIDTYPE_MAX&#125;; &emsp;&emsp;其中，PIDTYPE_PID代表了进程号（Process ID）哈希表，系统中所有进程（包括线程）的进程号都在该哈希表中有相应的存储位置。PIDTYPE_PGID代表了进程组号（Process）哈希表。PIDTYPE_SID代表了会话号（Session ID）哈希表。 &emsp;&emsp;为了查找哈希表，需要知道进程号（pid）与哈希表中位置之间的映射函数——哈希函数，定义如下： 12#define pid_hashfn(nr,ns) Hash_long((unsigned long)nr+(unsigned long)ns,pidhash_shift) &emsp;&emsp;其中nr表示进程的pid，ns表示进程的pid命名空间结构pid_namespace,pidhash_shift表示哈希表的大小（1&lt;&lt;pidhash_shift). &emsp;&emsp;Linux把通过哈希函数计算得到的哈希值作为数组pid_Hash的下标，并且把哈希值相同的进程组成哈希链表，我们称该链表为哈希链表的主链表。链表中的每个哈希结点（hlist_node结构）表示进程的pid。 (1)相关的数据结构&emsp;&emsp;随着在Linux内核2.6.24中引入了pid命名空间，结构pid被分割成结构pid和结构upid，其定义如下： 123456789101112131415struct upid&#123; int nr;/*pid值*/ struct pid_namespace *ns;/*所在的命名空间*/ struct hlist_node pid_chain;/*哈希链表节点*/&#125;;struct pid&#123; atomic_t count;/*引用计数*/ struct hlist_head tasks[PIDTYPE_MAX];/*保存所有使用此pid的进程*/ struct rcu_head rcu;/*读写锁*/ int level;/*包含upid结构的个数*/ struct upid numbers[1];/*包含的upid结构*/&#125;; &emsp;&emsp;在pid结构中，包含一个struct hlist_head类型的成员变量tasks，该变量把具有相同pid值的进程联系起来，如同一个进程组的进程拥有相同的进程组号pgid，此时可以将同一个进程组的进程通过该变量联系起来，我们称该链表尾哈希链表的从链表。 &emsp;&emsp;在进程描述符task_struct中存在成员变量pids，定义如下所示： 1struct pid_link pids[PIDTYPE_MAX]; 该成员变量的数据类型pid_link的定义如下： 12345struct pid_link&#123; struct hlist_nnode node;/*从哈希表节点*/ struct pid *pid;/*进程对应的pid结构*/&#125;; 该结构是表示进程描述符task_struct与结构pid之间的映射关系。使用这个变量可以根据pid结构找出对应的描述符。 (2)哈希表相关的操作 find_pid()函数根据nr的值，利用哈希函数计算其哈希值，从哈希表pid_Hash中找出哈希链表头节点，然后遍历整个链表，找出哈希值为nr的pid结构。 1struct pid* find_pidd(int nr);/*nr表示进程的pid值*/ pid_task()函数根据pid返回其对应的进程描述符地址 1struct task_struct *fastcall pid(struct pid* pid,enum pid_type type);/*参数type表示pid的类型*/ transfer_pid()函数使用新的继承描述符new替换旧的进程描述符 1void fastcall transfer_pid(struct task_struct *old,struct task_struct *new ,enum pid_type type); attach_pid()函数建立进程描述符task与结构pid之间的映射关系，并将pid添加到相应的哈希链表的开头。 1int fastcall attach_pid(struct task_struct *task,enum pid_type,struct pid* pid); 当进程被销毁时需要将进程在哈希表中的映射关系解除，这一过程通过函数detach_pid()完成。该函数首先解除进程描述符与哈希链表的映射关系，然后检查pid结构中是否还包含别的进程，如果不是，则释放pid结构。 1void fastcall detach_pid(struct task_struct *task,enum pid_type type); 等待队列&emsp;&emsp;当进程等待一个外部事件发生时，就把它从运行队列中删除并放到等待队列上。 &emsp;&emsp;在Linux内核中，使用wait_queue_t结构的双向链表来表示一个等待队列。在每个等待队列链表中，以wait_queue_head_t结构表示等待队列的表头，wait_queue_t表示等待队列中的每一个节点，它记录了等待进程所需要的所有信息。 123456struct _wait_queue_head&#123; spinlock_t lock; struct list_head task_list;&#125;;typedef struct _ wait_queue_head wait_queue_head_t; lock用于保护该等待队列中数据的一致性。 task_list表示睡眠在该等待队列上的所有进程构成的链表的表头 123456789struct _ wait_queue&#123; unsigned int flags;#define WQ_FLAG_EXCLUSIVE 0X01 void *private; wait_queue_func_t func; struct list_head task_list;&#125;;typedef struct _ wait_queue wait_queue_t; flags:它指示了该结点对应进程的环形方式，取值为WQ_FLAG_EXCLUSIVE或0；WQ_FLAG_EXCLUSIVE表示节点对应进程对临界区资源使用是排他性的，即进程是独占式进程。 private:一个私有数据指针，通常保存了睡眠进程的进程描述符task_struct的地址 func:存放函数的一个结构，这个函数用于唤醒等待队列上的进程。这个域的默认值为default_wake_function()函数，该函数负责将变量private指示的进程设置为可运行状态并插入到合适的运行队列中。 当前进程&emsp;&emsp;Linux关于进程管理的大部分代码都需要获得或设置当前进程的信息，因此，是否能快速、高效地找到当前进程的描述符task_struct对系统的性能有很大的影响。Linux内核2.2开始采用了宏定义current来获取当前进程的描述符。硬件体系结构把不同，该宏的定义也不同，它必须针对专门的硬件体系结构作处理。有的硬件体系结构可以拿出一个专门的寄存器来存放指向当前进程描述符task_struct的指针，而像x86这样的体系由于寄存器并不富余，就只能在当前内核栈的尾端创建thread_info结构，通过计算偏移间接地查找task_struct结构。 &emsp;&emsp;在x86体系结构中，每个进程拥有一个内核栈，且通过寄存器%esp即可访问内核栈的元素。基于这种思想，内核首先将当前进程的地址以及需要快速访问的其他状态标记记录在数据结构struct thread info中，然后将该数据结构保存到内核栈空间中的最低地址位置。 12345union thread_union&#123; struct thread_info thread_info; unsigned long stack[THREAD_SIZE/sizeof(long)];&#125;; 从该结构中可以看出，内核栈stack和数据结构thread_info共享同一块内存。]]></content>
      <categories>
        <category>Linux内核</category>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Linux内核</tag>
        <tag>Liinux进程管理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于Linux内核]]></title>
    <url>%2F2019%2F08%2F06%2F%E5%85%B3%E4%BA%8ELinux%E5%86%85%E6%A0%B8%2F</url>
    <content type="text"><![CDATA[一、Linux内核特征&emsp;&emsp;&emsp;Linux操作系统的内核稳定而高效，以独占的方式执行最底层任务，保证其他程序的正常运行。它是整个系统的核心，具有独特的性质。 接口特色&emsp;&emsp;按照POSIX标准，一个可以运行UNIX程序的系统就是UNIX。Linux系统提供和一般UNIX系统相同的标准界面，包括程序级和用户级的界面。 &emsp;&emsp;在程序级，Linux系统提供标准的UNIX函数库，一个在Linux下开发的应用程序，几乎不经过任何改动就可以在其他UNIX系统下编译执行，完成同样的功能。 &emsp;&emsp;Linux系统对用户同时提供图形和文本用户界面，文本界面是shell接口，图形界面是X-Window系统。UNIX下的基本命令在Linux下的功能和使用方式都完全相同。而最早在UNIX平台开发的图形用户界面X-Window系统，在Linux系统下运行良好并可以展示与其他版本UNIX系统下相同甚至更好的效果。 功能特色&emsp;&emsp;Linux系统可以支持多种硬件设备。Linux系统下的驱动程序开发和Windows系统相比简单得多。 &emsp;&emsp;Linux自身使用的专用的文件系统为Ext3，可以提供方便有效的文件共享及保护机制。同时，它可以通过虚拟文件系统的技术，支持包括微软系列操作系统所使用的FAT16、FAT32和NTFS等文件系统在内的几十种现有的文件系统。 &emsp;&emsp;Linux系统具有内置的TCP/IP协议栈，可以提供各种高效的网络功能，包括基本的进程间通信、网络文件服务等。 结构特征&emsp;&emsp;Linux内核基本采用模块结构，单内核模式，这使得系统具有很高的运行效率，但系统的可扩展性及移植性会受到一定的影响。为了解决这个问题，Linux使用了附加模块技术。利用模块技术，可以方便地在内核中添加新的组件或卸载不再需要的内核组件，而且这种装载和卸载可以动态进行。 &emsp;&emsp;内核模块的引入也带来了对系统性能、内存利用和系统稳定性的一些影响，可动态装卸的模块需要系统增加额外的资源来记录、管理，而装入的内核模块和其他内核部分一样，具有相同的访问权限，差的内核模块会导致系统不稳定甚至崩溃，一些恶意的内核模块可能对系统安全造成极大的威胁。 &emsp;&emsp;总的来说，Linux内核基本采用模块式结构构造，同时加入动态的模块技术，在追求系统整体效率的同时，实现了内核的动态可伸缩性。这样的结构给系统移植带来一定的负面影响。 二、Linux内核体系结构&emsp;&emsp;Linux内核主要由5个模块构成，分别是进程调度模块、内存管理模块、虚拟文件系统模块、进程间通信模块和网络接口模块。 &emsp;（1）进程调度模块：进程调度模块程序是内核的重要组成部分，它选择下一个要运行的进程并负责控制进程对CPU资源的使用，调度程序采用一种策略使各个进程能够公平合理地访问CPU，同时保证内核能够实时地执行必要的硬件操作。 &emsp;（2）内存管理模块：内存管理模块负责管理系统，用于确保所有进程能够安全地共享计算机的内存，同时，内存管理模块还支持虚拟内存，使得Linux能够支持进程使用比实际内存空间更大的内存地址空间。 &emsp;（3）虚拟文件系统模块：虚拟文件系统（VFS）模块通过向所有的外部存储设备提供一个通用的文件接口，隐藏了各种硬件的不同细节，从而提供并支持与其他操作系统兼容的多种文件系统。Linux最好的特征之一就是它支持多种文件系统，用户不仅可以从它自己的文件系统如Ext2，Ext3，ReiserFS等查看文件，而且可以从与其他操作相关的文件系统插卡文件。对用户来说，从一种文件系统到另一种文件系统就没有任何差异，只要是Linux支持的文件系统类型，用户就可以很方便地将它安装到Linux系统中使用。 &emsp;（4）进程间通信模块：进程间通信模块主要负责进程之间如何进行信息交换或共享信息等工作，Linux提供了多种进程之间的通信机制，其中信号和管道是最基本的两种。除此之外，Linux还提供了System V特有的进程间通信机制，包括消息队列，信号量，共享内存等，为了支持网络通信，Linux还引入了套接字（Socket）机制。 &emsp;（5）网络接口模块：网络接口模块提供对多种网络通信标准的访问并支持许多网络硬件，网络接口分为网络协议和网络驱动程序，其中网络协议部分负责实现网络传输协议，网络驱动程序部分负责与硬件设备的通信。 &emsp;（6）进程调度与内存管理模块之间的关系：这两个子系统互相依赖。在多道程序环境下，程序要运行必须为之创建进程，而创建进程的第一件事情就是将程序和数据装入内存。 &emsp;（7）进程间通信与内存管理之间的关系：进程间通信子系统要依赖内存管理支持共享内存机制，这种机制允许两个进程除了拥有自己的私有空间，还可以存取共同的内存区域。 &emsp;（8）虚拟文件系统与网络接口和内存管理之间的关系：虚拟文件系统利用网络接口支持网络文件系统（NFS），也利用内存管理支持RAMDISK设备。 &emsp;（9）内存管理与虚拟文件系统之间的关系：内存管理利用虚拟文件系统支持交换，交换进程(swapd)定期由调度程序调度，这也是内存管理依赖于进程调度的唯一原因。当一个进程存取的内存映射被换出时，内存管理向文件系统发出请求，同时，挂起当前正在运行的进程。 三、单内核与微内核&emsp;&emsp;微内核（MicroKernel Kernel）:在微内核中，大部分内核都作为独立的进程在特权状态下运行，它们通过消息传递进行通信。在典型情况下，每个概念模块都有一个进程。因此，如果在设计中有一个系统调用模块，那么就必然有一个相应的进程来接收系统调用，并和能够执行系统调用的其他进程（或模块）通信以完成所需任务。 &emsp;&emsp;微内核设计的一个优点是在不影响系统其他部分的情况下，更高效地实现代替现有的文件系统模块的工作将会更加容易。我们甚至可以在系运行时将开发出的新系统模块或者需要替换现有模块的模块直接而且迅速地加入系统。另外一个优点是不需要的模块将不会被加载到内存中，因此微内核就可以更有效地利用内存。 &emsp;&emsp;单内核（Monolithic kernel):单内核是一个很大的进程。它的内部又可以被分为若干模块（或者是层次或其他）。但是在运行的时候，它是一个独立的二进制大映像。其模块间的通信是通过直接调用其他模块中的函数实现的，而不是消息传递。 &emsp;&emsp;单内核的支持者声称微内核的消息传递开销引起了效率的损失，微内核的支持者则认为因此而增加的内核设计的灵活性和可维护性可以弥补任何损失。 &emsp;&emsp;Linux是一个单内核结构，也就是说，Linux运行在单独的内核地址空间。同时吸收了微内核的优点：模块化设计，支持动态装载内核模块。Linux还避免了微内核设计上的缺陷，让一切都运行在内核态，直接调用函数，无需消息传递。]]></content>
      <categories>
        <category>Linux内核</category>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>微内核</tag>
        <tag>单内核</tag>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[map容器]]></title>
    <url>%2F2019%2F08%2F03%2Fmap%E5%AE%B9%E5%99%A8%2F</url>
    <content type="text"><![CDATA[一、map容器概述&emsp;&emsp;map的特性是，所有元素都会根据元素的键值被自动排序。map所有元素都是pair，同时拥有实值(value)和键值(key)。pair的第一元素被视为键值，第二元素被视为实值。map并不允许两个元素拥有相同的键值。 &emsp;&emsp;我们不可以通过map的迭代器改变map的键值，因为map的键值关系到map元素的排列规则，任意改变map键值将会严重破坏map组织。如果想要修改元素的实值，是可以的。 &emsp;&emsp;map和list拥有相同的某些性质，当对它的容器元素进行新增操作或者删除操作时，操作之前的所有迭代器，在操作完成之后依然有效，当然被删除的那个元素的迭代器必然是个例外。 &emsp;&emsp;multimap和map的操作类似，唯一区别是multimap键值可重复。 &emsp;&emsp;map和multimap都是以RB-tree为底层机制。又由于map所开放的各种操作接口，RB-tree也都提供了，所以几乎所有map操作行为的，都只是转调用RB-tree的操作行为而已。 二、map/multimap容器常用API map构造函数 12map&lt;T1,T2&gt; mapTT;//map默认构造函数map(const map&amp;map);//拷贝构造函数 map赋值操作 12map&amp;operator=(const map&amp;mp);//重载等号操作符swap(mp);//交换两个集合容器 map大小操作 12size();//返回容器中元素的数目empty();//判断容器是否为空 map插入数据元素操作 1234567map.insert(1);//往容器中插入元素，返回pair&lt;iterator,bool&gt;map&lt;int,string&gt;mapStu;//通过pair方式插入对象mapStu.insert(pair&lt;int,string&gt;(3,"Aoki"));//通过pair方式插入对象mapStu.insert(make_pair(-1,"Aoki"));//通过value_type的方式插入对象mapStu.insert(map&lt;int,string&gt;::value_type(1,"Aoki"));mapStu[3]="Aoki";mapStu[5]="青木"; map删除操作 1234clear();//删除所有元素erase(pos);//删除pos迭代器所指元素，返回下一个元素的迭代器erase(beg,end);//删除区间[beg,end)的所有元素，返回下一个元素的迭代器erase(keyElem);//删除容器中key为keyElem的对组 map查找操作 12345find(key);//查找键key是否存在，若存在，返回该键的元素的迭代器，若不存在，返回map.end()count(keyElem);//返回容器中key为keyElem的对组个数。对于map来说，要么是0，要么是1，对于multimap来说，值可能大于1lower_bound(keyElem);//返回第一个key&gt;=keyElem元素的迭代器upper_bound(keyElem);//返回第一个key&gt;keyElem元素的迭代器equal_range(keyElem);//返回容器中key与keyElem相等的上下限的两个迭代器 三、map容器示例123456789101112131415161718192021void test01()&#123; map&lt;int, string&gt; m1; m1.insert(make_pair(1, "张三")); m1.insert(make_pair(2, "李四")); m1.insert(pair&lt;int, string&gt;(3, "李五")); m1.insert(map&lt;int, string&gt;::value_type(4, "张六")); m1[5] = "张四"; for (map&lt;int, string&gt;::iterator it = m1.begin(); it != m1.end(); it++) &#123; cout &lt;&lt; "ID:" &lt;&lt; it-&gt;first &lt;&lt; " 姓名：" &lt;&lt; it-&gt;second &lt;&lt; endl; &#125; if (m1.empty()) &#123; cout &lt;&lt; "map为空" &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; "size=" &lt;&lt; m1.size() &lt;&lt; endl; &#125;&#125; 执行结果： 12345678910111213141516171819202122232425262728293031323334void test02()&#123; map&lt;int, int&gt;m2; m2.insert(make_pair(1, 10)); m2.insert(make_pair(2, 50)); m2.insert(make_pair(3, 40)); m2.insert(make_pair(4, 60)); m2.insert(make_pair(5, 10)); for (map&lt;int, int&gt;::iterator it1 = m2.begin(); it1 != m2.end(); it1++) &#123; cout &lt;&lt; "key:" &lt;&lt; (*it1).first &lt;&lt; " value:" &lt;&lt; (*it1).second &lt;&lt; endl; &#125; m2.erase(3); for (map&lt;int, int&gt;::iterator it1 = m2.begin(); it1 != m2.end(); it1++) &#123; cout &lt;&lt; "key:" &lt;&lt; (*it1).first &lt;&lt; " value:" &lt;&lt; (*it1).second &lt;&lt; endl; &#125; if (m2.find(5) != m2.end()) &#123; cout &lt;&lt; "找到了" &lt;&lt; endl; cout &lt;&lt; "ID:" &lt;&lt; m2.find(5)-&gt;first &lt;&lt; " value:" &lt;&lt; m2.find(5)-&gt;second &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; "没有找到" &lt;&lt; endl; &#125; map&lt;int, int&gt;::iterator pos = m2.lower_bound(4); cout &lt;&lt; "ID:" &lt;&lt; pos-&gt;first &lt;&lt; " value:" &lt;&lt; pos-&gt;second &lt;&lt; endl; map&lt;int, int&gt;::iterator pos1 = m2.upper_bound(4); cout &lt;&lt; "ID:" &lt;&lt; pos-&gt;first &lt;&lt; " value:" &lt;&lt; pos-&gt;second &lt;&lt; endl; pair&lt;map&lt;int, int&gt;::iterator, map&lt;int, int&gt;::iterator&gt;ret = m2.equal_range(4); cout &lt;&lt; "ID:" &lt;&lt; ret.first-&gt;first &lt;&lt; " value:" &lt;&lt; ret.first-&gt;second &lt;&lt; endl; cout &lt;&lt; "ID:" &lt;&lt; ret.second-&gt;first &lt;&lt; " value:" &lt;&lt; ret.second-&gt;second &lt;&lt; endl;&#125; 执行结果： 四、multimap示例12345678910111213void test03()&#123; multimap&lt;int, int&gt;mulmap; mulmap.insert(make_pair(1, 15)); mulmap.insert(make_pair(1, 20)); mulmap.insert(make_pair(1, 25)); mulmap.insert(make_pair(1, 5)); for (multimap&lt;int, int&gt;::iterator it0 = mulmap.begin(); it0 != mulmap.end(); it0++) &#123; cout &lt;&lt; "ID：" &lt;&lt; it0-&gt;first &lt;&lt; " value:" &lt;&lt; it0-&gt;second &lt;&lt; endl; &#125; cout &lt;&lt; "键值为1的对组的个数：" &lt;&lt; mulmap.count(1) &lt;&lt; endl;&#125; 执行结果： 五、源码地址​ map示例源码]]></content>
      <categories>
        <category>STL</category>
      </categories>
      <tags>
        <tag>STL</tag>
        <tag>map容器</tag>
        <tag>multimap</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[set容器]]></title>
    <url>%2F2019%2F08%2F03%2Fset%E5%AE%B9%E5%99%A8%2F</url>
    <content type="text"><![CDATA[一、关联式容器&emsp;&emsp;标准的STL关联式容器分为set(集合)和map(映射表)两大类，以及这两大类的衍生体multiset（多键集合）和multimap（多键映射表）。这些容器的底层机制均以RB-tree(红黑树)完成。RB-tree也是一个独立的容器，但并不开放给外界使用。 &emsp;所谓关联式容器，观念上类似关联式数据库（实际上则简单的多）：每笔数据（每个元素）都有一个键值（key）和一个实值（value）。当元素被插入到关联式容器中时，容器内部结构便依照其键值大小，以某种特定规则将这个元素放置在适当的位置。关联式容器没有所谓头尾，所以不会有所谓push_back()、push_front()、pop_back()、pop_front()、begin()、end()这样的操作行为。 &emsp;&emsp;一般而言，关联式容器的内部结构是一个平衡二叉树，以便获得良好的搜寻效率。平衡二叉树有许多种类型，包括AVL-tree、RB-tree、AA-tree,其中最被广泛运用于STL的是RB-tree(红黑树)。 二、set&emsp;&emsp;set的特性是，所有元素都会根据元素的键值自动被排序。set不像map那样可以同时拥有实值(value)和键值(key)，set元素的键值就是实值，实值就是键值。set不允许两个元素有相同的键值。 &emsp;&emsp;我们不可以通过set的迭代器改变set元素的值，因为set元素的值就是其键值，关系到set元素的排序规则。如果任意改变set元素值，会严重破坏set组织。在set源代码中，set&lt;T&gt;::iterator被定义为底层RB-tree的const_iterator。换句话说，set iterator是一种constanit iterators。 &emsp;&emsp;set拥有与list相同的某些性质：当客户端对它进行元素新增操作(insert)或删除操作(erase)时，操作之前的所有迭代器，在操作完成之后都依然有效。当然被删除的那个元素的迭代器必然是个例外。 &emsp;&emsp;由于RB-tree是一种平衡二叉树，自动排序的效果很不错，所以标准的STL set即以RB-tree为底层机制。又由于set所开放的各种操作接口，RB-tree也都提供了，所以几乎所有的set操作行为，都只是转调RB-tree的操作行为而已。 1）set常用API set构造函数 123set&lt;T&gt; st;//set默认构造函数multiset&lt;T&gt; mst;//multiset默认构造函数set(const set&amp;st);//拷贝构造函数 set赋值操作 12set&amp; operator=(const set&amp; st);//重载等号操作符swap(st);//交换两个集合容器 set大小操作 12size();//返回容器中元素的数目empty();//判断容器是否为空 set插入和删除操作 12345insert(elem);//在容器中插入元素clear();//清除所有元素erase(pos);//删除pos迭代器所指的元素，返回下一个元素的迭代器erase(beg,end);//删除区间[beg,end)的所有元素，返回下一个元素的迭代器erase(elem);//删除容器中值为elem的元素 set查找操作 12345find(key);//查找键key是否存在，若存在，返回该键的元素的迭代器；若不存在，返回set.end()count(key);//查找键key的元素个数lower_bound(keyElem);//返回第一个key&gt;=keyElem元素的迭代器upper_bound(keyElem);//返回第一个key&gt;keyElem元素的迭代器equal_range(keyElem);//返回容器中key与keyElem相等的上下限的两个迭代器 2）示例1234567891011121314151617181920void test01()&#123; set&lt;int&gt; st = &#123; 1,2,3,4,5,6 &#125;; DisplaySet(st);//输出set中的元素 if (st.empty()) &#123; cout &lt;&lt; "set为空" &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; "size=" &lt;&lt; st.size() &lt;&lt; endl; &#125; st.erase(st.begin()); DisplaySet(st); st.erase(6); DisplaySet(st); st.insert(15); st.insert(10); DisplaySet(st);&#125; 执行结果： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869void test02()&#123; set&lt;int&gt;st; st.insert(5); st.insert(1); st.insert(9); st.insert(3); st.insert(7); //查找操作 set&lt;int&gt;::iterator it1 = st.find(3); if (it1 != st.end()) &#123; cout &lt;&lt; "找到了，值为：" &lt;&lt; *it1 &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; "没有找到" &lt;&lt; endl; &#125; set&lt;int&gt;::iterator it0 = st.find(8); if (it0 != st.end()) &#123; cout &lt;&lt; "找到了，值为：" &lt;&lt; *it0 &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; "没有找到" &lt;&lt; endl; &#125; int num = st.count(2);//2的个数 cout &lt;&lt; "2的个数为：" &lt;&lt; num &lt;&lt; endl; //lower_bound(keyElem);//返回第一个key&gt;=keyElem元素的迭代器 set&lt;int&gt;::iterator pos = st.lower_bound(3); if (pos != st.end()) &#123; cout &lt;&lt; "lower_bound(3)的值为：" &lt;&lt; *pos &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; "没有找到" &lt;&lt; endl; &#125; //upper_bound(keyElem);//返回第一个key&gt;keyElem元素的迭代器 set&lt;int&gt;::iterator it2 = st.upper_bound(3); if (it2 != st.end()) &#123; cout &lt;&lt; "找到了upper_bound(3)的值为：" &lt;&lt; *it2 &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; "没有找到" &lt;&lt; endl; &#125; //equal_range(keyElem);//返回容器中key与keyElem相等的上下限的两个迭代器 pair&lt;set&lt;int&gt;::iterator, set&lt;int&gt;::iterator&gt;ret = st.equal_range(3); if (ret.first != st.end()) &#123; cout &lt;&lt; "找到equal_range中lower_bound的值为：" &lt;&lt; *(ret.first) &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; "没有找到" &lt;&lt; endl; &#125; if (ret.second != st.end()) &#123; cout &lt;&lt; "找到equal_range中upper_bound为：" &lt;&lt; *(ret.second) &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; "没有找到" &lt;&lt; endl; &#125;&#125; 执行结果： 三、multiset容器&emsp;&emsp;multiset特性及用于和set完全相同，唯一的差别在于它允许键值重复。 1）示例12345678910void test03()&#123; multiset&lt;int&gt;muset; muset.insert(15); muset.insert(20); muset.insert(15); DisplayMultiset(muset); cout &lt;&lt; "元素个数为："; cout &lt;&lt; muset.size() &lt;&lt; endl;&#125; 执行结果： 四、对组（pair）&emsp;&emsp;对组(pair)将一对值组合成一个值，这一对值可以具有不同的数据类型，两个值可以分别用pair的两个公有属性first和second访问。 1）示例1234567891011121314151617181920212223class Compare&#123;//利用仿函数指定排序规则public: bool operator()(pair&lt;string,int&gt; p1,pair&lt;string,int&gt;p2) &#123; return p1.second &gt; p2.second; &#125;&#125;;void test04()&#123; pair&lt;string, int&gt; p1("Aoki", 23); pair&lt;string, int&gt; p2("张三", 25); pair&lt;string, int&gt; p3("李四", 26); set&lt;pair&lt;string, int&gt;, Compare&gt; pSt;; pSt.insert(p1); pSt.insert(p2); pSt.insert(p3); for (set&lt;pair&lt;string, int&gt;, Compare&gt;::iterator it = pSt.begin(); it != pSt.end(); it++) &#123; cout &lt;&lt; "姓名：" &lt;&lt; it-&gt;first &lt;&lt; " 年龄：" &lt;&lt; it-&gt;second &lt;&lt; endl; &#125;&#125; 执行结果： 五、源码地址​ set示例源码]]></content>
      <categories>
        <category>STL</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>set容器</tag>
        <tag>pair</tag>
        <tag>Multiset</tag>
        <tag>关联式容器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[选择排序——直接选择排序和堆排序的实现]]></title>
    <url>%2F2019%2F08%2F02%2F%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F%E2%80%94%E2%80%94%E7%9B%B4%E6%8E%A5%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F%E5%92%8C%E5%A0%86%E6%8E%92%E5%BA%8F%E7%9A%84%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[一、选择排序概述&emsp;&emsp;选择排序的基本思想是：不断从待排序的对象集合中选取关键码最小的对象放到已排序对象集合的后面，直到集合这两个所有对象都取完为止。 &emsp;&emsp;常用的选择排序方法有直接排序法和堆排序法。 二、直接选择排序的实现&emsp;&emsp;直接选择排序是一种简单且直观的排序方法。直接选择排序的思想是：从待排序的对象集合中选择关键码最小的对象，并将它与原始对象集合中的第一个对象交换位置；然后从不包括第一个位置对象的对象集合中选取关键码最小的对象，并将它与原始对象集合中的第二个元素交换位置；如此重复，直到对象集合中只剩下一个对象为止。 1)直接选择排序的实现1234567891011121314151617181920212223template&lt;class T&gt;void DirectSelectSort(T arr[], int n)&#123;//对arr[0]~arr[n-1]进行排序 T temp; int CurrentMin;//当前最小值的位置 for (int i = 0; i &lt; n ; i++) &#123; CurrentMin = i; for (int j = i + 1; j &lt; n ; j++) &#123; if (arr[j] &lt; arr[CurrentMin]) &#123; CurrentMin = j;//记录当前最小值的下标 &#125; &#125; if (CurrentMin != i) &#123; temp = arr[i]; arr[i] = arr[CurrentMin]; arr[CurrentMin] = temp; &#125; &#125;&#125; 2)测试函数123456789101112131415161718void test()&#123; int arr[] = &#123; 64,55,7,5,89,15,22,25 &#125;; int n = sizeof(arr) / sizeof(arr[0]); cout &lt;&lt; "原始数组为：" &lt;&lt; endl; for (int i = 0; i &lt; n; i++) &#123; cout &lt;&lt; arr[i] &lt;&lt; " "; &#125; cout &lt;&lt; endl; DirectSelectSort&lt;int&gt;(arr, n); cout &lt;&lt; "排序结果为：" &lt;&lt; endl; for (int i = 0; i &lt; n; i++) &#123; cout &lt;&lt; arr[i] &lt;&lt; " "; &#125; cout &lt;&lt; endl;&#125; 3）执行结果 4）时空复杂度分析 时间复杂度 在直接选择排序中，第1次排序要进行n-1次比较，第2次排序要进行n-2次比较，……，第n-1次排序要进行1次比较。所以总比较次数为$\frac{n(n-1)}{2}$ 在各次排序中，对象的移动次数最好为0，最坏为3次。 时间复杂度为O($n^2$) 空间复杂度 直接选择排序算法的空间复杂度为O(1) 直接选择排序算法是一种稳定的排序方法 5）源码地址​ 直接插入排序实现源码 三、堆排序的实现&emsp;&emsp;堆排序是利用堆数据结构进行的排序方法。堆式结点间数据元素的关键码具有层次次序关系的完全二叉树。堆排序算法的思想是：建立一个堆结构的数组对象，不断删除堆顶对象并依次存于数组后面空出的存储单元中，当n个对象的数组中第n-1个对象被这样操作后，数组中的对象即排好序了。 1）堆排序的实现1234567891011template&lt;class T&gt;void HeapSort(T arr[], int n)&#123; MaxHeap&lt;T&gt; heap(arr, n); T temp; for (int i = n - 1; i &gt; 0; i--) &#123; temp = heap.Delete(); arr[i] = temp; &#125;&#125; 堆排序的实现借助了之前实现的最大堆，最大堆的堆顶始终是最大值。 2）测试函数123456789101112131415161718void test()&#123; int arr[] = &#123; 64,55,7,5,89,15,22,25 &#125;; cout &lt;&lt; "原数组元素为：" &lt;&lt; endl; int n = sizeof(arr) / sizeof(arr[0]); for (int i = 0; i &lt; (sizeof(arr) / sizeof(arr[0])); i++) &#123; cout &lt;&lt; arr[i] &lt;&lt; " "; &#125; cout &lt;&lt; endl; HeapSort&lt;int&gt;(arr, (sizeof(arr) / sizeof(arr[0]))); cout &lt;&lt; "利用最大堆排序结果：" &lt;&lt; endl; for (int i = 0; i &lt; n; i++) &#123; cout &lt;&lt; arr[i] &lt;&lt; " "; &#125; cout &lt;&lt; endl;&#125; 3）执行结果 4）时空复杂度分析 堆化数组最坏情况的时间复杂度为O(nlgn)，在堆中删除一个元素最坏情况的时间复杂度为O(lgn)。因此，堆排序算法最坏情况的时间复杂度是O(nlgn) 堆排序算法的空间复杂度为O(1)。 堆排序是一种不稳定的排序方法。 5）源码地址​ 堆排序实现源码]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>排序</tag>
        <tag>选择排序</tag>
        <tag>直接选择排序</tag>
        <tag>堆排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[堆——最小堆和最大堆的实现]]></title>
    <url>%2F2019%2F08%2F02%2F%E5%A0%86%E2%80%94%E2%80%94%E6%9C%80%E5%B0%8F%E5%A0%86%E5%92%8C%E6%9C%80%E5%A4%A7%E5%A0%86%E7%9A%84%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[一、堆概述 堆(Heap)是结点间数据元素的关键码具有层次次序关系的完全二叉树； 堆是二叉树的顺序存储结构的一个应用； 堆可用于应用程序希望能直接访问一个表中的最小或最大数据元素的应用问题； 堆结构的重要价值在于，在所有能直接访问一个表中的最小或最大数据元素的算法中，堆结构方法是时间效率最高的一种。 二、堆定义&emsp;&emsp;设数据元素是一个有多个域的复合结构，其中有一个称为关键码的域，定义n个数据元素$d_0$、$d_1$、$d_2$、……、$d_{n-1}$所对应的关键码域为$k_0$、$k_1$、$k_2$、……、$k_{n-1}$，假设数据元素$d_0$、$d_1$、$d_2$、……、$d_{n-1}$按完全二叉树的顺序存放在一个一维数组中，当2i+1&lt;n时有： $k_i&lt;=k_{2i+1}$($k_i$中的i是元素在数组中的下标) 当2i+2&lt;n时有： $k_i&lt;=k_{2i+2}$($k_i$中的i是元素在数组中的下标) 这样的数据元素集合称为最小堆。 与此类似，当2i+1&lt;n时有： $k_i&gt;=k_{2i+1}$($k_i$中的i是元素在数组中的下标) 当2i+2&lt;n时有： $k_i&gt;=k_{2i+2}$($k_i$中的i是元素在数组中的下标) 这样的数据元素集合称为最大堆。 根据堆的定义可以推知堆有下面两个性质： 最小堆的根结点时堆中值最小的数据元素，最大堆的根结点时堆中值最大的数据元素，我们称之为堆顶元素 对于最小堆，从根结点到每个叶结点的路径上，数据元素组成的的序列都是非递减有序的。对于最大堆，从根结点到每个叶结点的路径上，数据元素组成的序列都是非递增有序的 三、最小堆的实现1）最小堆类1234567891011121314151617181920212223template&lt;class T&gt;class MinHeap&#123;public: MinHeap(int maxsize);//构造函数 MinHeap(T arr[], int n);//拷贝构造函数，将n个arr元素堆化 ~MinHeap();//析构函数 //最小堆的相关操作 void Insert(const T&amp; item);//插入元素item T Delete();//删除堆中最小元素 T GetHeapTop();//获取堆顶元素 int HeapSize();//获取堆中元素个数 bool isHeapEmpty();//堆是否为空 bool isHeapFull();//堆是否已满 void Display();//打印堆private: T* heapArray;//存放数据元素的数组 int markArray;//标记 int MaxHeapSize;//可存元素个数 int heapSize;//当前元素个数 void FilterUp(int i);//插入元素后进行堆化 void FilterDown(int i);//删除元素后进行堆化&#125;; 2)最小堆类部分成员函数的实现&emsp;&emsp;插入成员函数是在原先的数据元素已经是堆的基础上，插入一个数据元素后，调整使之继续维持为一个堆。我们把要插入的数据元素放在堆尾。虽然插入前的数据元素集合构成堆，但是新的数据元素插入后可能违背堆的定义。 &emsp;&emsp;插入新元素后继续维持为一个最小堆的算法是 看新插入元素的值是否小于其双亲的值，如果不小于，则仍维持为一个最小堆，算法结束； 如果小于，则交换两者的值； 交换后有可能在更上一层仍然不能满足最小堆的定义，需继续交换，直到满足最小堆的定义为止。 最小堆插入图示： 123456789101112131415161718192021222324252627282930313233343536373839//插入元素时重新堆化template&lt;class T&gt;void MinHeap&lt;T&gt;::FilterUp(int i)&#123;//调整插入的新元素使之上升到合适的结点位置 int currentPos, parentPos; T target; currentPos = i; target = heapArray[i]; parentPos = (i-1)/2;//获取结点i的双亲结点位置 while (currentPos != 0) &#123;//到根结点为止 if (heapArray[parentPos] &lt;= target) return; else &#123; heapArray[currentPos] = heapArray[parentPos];//双亲结点下降 currentPos = parentPos;//当前结点为双亲结点，重新开始 parentPos = (currentPos - 1) / 2;//计算当前结点的双亲结点 &#125; &#125; heapArray[currentPos] = target;//插入新元素&#125;//插入template&lt;class T&gt;void MinHeap&lt;T&gt;::Insert(const T&amp; item)&#123; if (heapSize == MaxHeapSize) &#123; cout &lt;&lt; "堆已满！" &lt;&lt; endl; return; &#125; else &#123; heapArray[heapSize] = item; FilterUp(heapSize);//新插入结点上移，进行堆化 heapSize++; &#125;&#125; &emsp;&emsp;删除成员函数是删除堆顶的最小的数据元素。删除堆顶元素后，我们用堆中最后一个元素填充堆顶位置，此时必然违反堆的定义。 &emsp;&emsp;删除后继续维持为一个最小堆的算法是： 令堆顶位置为当前位置，看当前位置元素的值时候小于其左右孩子中的最小值，如果不小于，则仍然维持为一个最小堆，算法结束； 如果小于，则交换两者的值； 交换后有可能在更下一层仍然不满足最小堆的定义，需继续交换，直到满足堆的定义为止。 最小堆删除图示： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546//删除元素时重新堆化template&lt;class T&gt;void MinHeap&lt;T&gt;::FilterDown(int i)&#123;//调整第i个结点使之下移到合适的位置 int currentPos, childPos; T target; currentPos = i; childPos = 2 * i + 1;//计算左孩子结点 target = heapArray[i]; while (childPos &lt; heapSize) &#123;//childPos为当前结点的左右孩子中值较小的孩子结点位置 if (childPos &lt; heapSize &amp;&amp; (heapArray[childPos + 1] &lt;= heapArray[childPos])&amp;&amp;childPos+1&lt;heapSize) &#123; childPos = childPos + 1; &#125; if (target &lt; heapArray[childPos]) break;//满足最小堆的定义 else &#123; heapArray[currentPos] = heapArray[childPos];//孩子结点上升 currentPos = childPos;//从孩子结点位置重新开始 childPos = childPos * 2 + 1;//当前结点的孩子结点 &#125; &#125; heapArray[currentPos] = target;//把填充的堆顶元素插入&#125;//删除堆中最小元素template&lt;class T&gt;T MinHeap&lt;T&gt;::Delete()&#123; if (heapSize == 0) &#123; cout &lt;&lt; "堆为空！" &lt;&lt; endl; exit(1); &#125; else &#123; T item = heapArray[0];//保存原堆顶元素 heapArray[0] = heapArray[heapSize - 1];//用最后一个元素填充堆顶位置 heapSize--; FilterDown(0);//下移当前堆顶元素 return item;//返回原堆顶元素 &#125;&#125; &emsp;&emsp;数组的堆化是把一个有n个数据元素的非堆的数组构造为一个堆。 &emsp;&emsp;数组的堆化过程可以设计成递推过程。在完全二叉树形式的数组中，所有叶结点都满足堆的定义，令最后一个叶结点的双亲结点为当前结点，其下标为：currentPos=((n-1)-1)/2 &emsp;&emsp;对于结点currentPos，其左右孩子结点已满足堆的定义，使结点currentPos也满足堆的定义的过程与插入过程中使用的FilterDown相同。因此使用参数currentPos调用FilterDown(currentPos)；在结点currentPos满足最小堆的定义后，使当前结点currentPos=currentPos-1，对于结点currentPos，其左右孩子结点已满足最小堆的定义，再次用参数currentPos调用FilterDown(currentPos)；这样的过程一直进行到当前结点currentPos=0，即到达根结点为止。 数组堆化图示： 1234567891011121314151617181920212223//将数组堆化template&lt;class T&gt;MinHeap&lt;T&gt;::MinHeap(T arr[], int n)&#123; if (n &lt; 0) &#123; cout &lt;&lt; "非法参数!" &lt;&lt; endl; exit(1); &#125; else &#123; MaxHeapSize = n; heapSize = n; heapArray = arr; int currentPos = (n - 1) / 2;//计算第一个非叶子结点 while (currentPos &gt;= 0) &#123; FilterDown(currentPos);//调整结点currentPos使之下移到合适的位置 currentPos--; &#125; markArray = 1;//置构造函数标记 &#125;&#125; 3)测试函数12345678910111213141516void test()&#123; int arr[] = &#123; 24,10,90,77,16,25,33,89,67 &#125;; cout &lt;&lt; "原数组元素为：" &lt;&lt; endl; for (int i = 0; i &lt; (sizeof(arr) / sizeof(arr[0])); i++) &#123; cout &lt;&lt; arr[i] &lt;&lt; " "; &#125; cout &lt;&lt; endl; MinHeap&lt;int&gt; heap(arr, (sizeof(arr) / sizeof(arr[0]))); cout &lt;&lt; "输出堆中元素：" &lt;&lt; endl; heap.Display(); cout &lt;&lt; heap.Delete() &lt;&lt; "已被删除！" &lt;&lt; endl; cout &lt;&lt; "输出堆中元素：" &lt;&lt; endl; heap.Display();&#125; 4）执行结果 5)源码地址​ 最小堆的实现源码 四、最大堆的实现1)最大堆类1234567891011121314151617181920212223template&lt;class T&gt;class MaxHeap&#123;public: MaxHeap(int maxsize);//构造函数 MaxHeap(T arr[], int n);//拷贝构造函数，将n个arr元素堆化 ~MaxHeap();//析构函数 //最小堆的相关操作 void Insert(const T&amp; item);//插入元素item T Delete();//删除堆中最大元素 T GetHeapTop();//获取堆顶元素 int HeapSize();//获取堆中元素个数 bool isHeapEmpty();//堆是否为空 bool isHeapFull();//堆是否已满 void Display();//打印堆private: T* heapArray;//存放数据元素的数组 int markArray;//标记 int MaxHeapSize;//可存元素个数 int heapSize;//当前元素个数 void FilterUp(int i);//插入元素后进行堆化 void FilterDown(int i);//删除元素后进行堆化&#125;; 2)最大堆类部分成员函数的实现最大堆类的成员函数的实现与最小堆类成员函数的实现基本相同，这里只列出部分成员的函数实现，不做解释。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100template&lt;class T&gt;inline MaxHeap&lt;T&gt;::MaxHeap( T arr[], int n)&#123; if (n &lt; 0) &#123; cout &lt;&lt; "非法参数！" &lt;&lt; endl; exit(1); &#125; else &#123; heapArray = arr; heapSize = n; MaxHeapSize = n; markArray = 1; int currentPos = (n - 1) / 2;//计算第一个非叶子结点的位置 while (currentPos &gt;= 0) &#123; FilterDown(currentPos);//下移当前结点到合适的位置 currentPos--; &#125; &#125;&#125;template&lt;class T&gt;inline void MaxHeap&lt;T&gt;::Insert(const T&amp; item)&#123;//插入元素 if (heapSize == MaxHeapSize) &#123; cout &lt;&lt; "非法参数！" &lt;&lt; endl; exit(1); &#125; else &#123; heapArray[heapSize] = item; FilterUp(heapSize); heapSize++; &#125;&#125;template&lt;class T&gt;inline T MaxHeap&lt;T&gt;::Delete()&#123; if (heapSize == 0) &#123; cout &lt;&lt; "堆为空！" &lt;&lt; endl; exit(1); &#125; else &#123; T item = heapArray[0]; heapArray[0] = heapArray[heapSize - 1];//用最后一个元素填充堆顶元素 heapSize--; FilterDown(0); return item; &#125;&#125;template&lt;class T&gt;inline void MaxHeap&lt;T&gt;::FilterUp(int i)&#123; int currentPos, ParentPos; T target = heapArray[i]; currentPos = i; ParentPos = (i - 1) / 2; while (currentPos != 0) &#123; if (heapArray[ParentPos] &gt;= target)//已经是最大堆 break; else &#123; heapArray[currentPos] = heapArray[ParentPos];//双亲结点下移 currentPos = ParentPos;//双亲结点为当前结点 ParentPos = (currentPos - 1) / 2;//找到当前结点的双亲结点 &#125; &#125; heapArray[currentPos] = target;//插入新元素&#125;template&lt;class T&gt;inline void MaxHeap&lt;T&gt;::FilterDown(int i)&#123; int currentPos,childPos; T target = heapArray[i]; currentPos = i; childPos = i * 2 + 1; while (childPos &lt; heapSize) &#123; if (childPos + 1 &lt; heapSize &amp;&amp; (heapArray[childPos + 1] &gt;= heapArray[childPos])&amp;&amp;childPos+1&lt;heapSize) childPos = childPos + 1;//选择两个孩子结点中较大的一个作为孩子结点为位置 if (target &gt;= heapArray[childPos]) break;//满足最大堆的性质 else &#123; heapArray[currentPos] = heapArray[childPos];//孩子结点上移 currentPos = childPos;//当前孩子结点作为当前结点 childPos = childPos * 2 + 1;//当前结点的孩子结点位置 &#125; &#125; heapArray[currentPos] = target;//把填充的堆顶元素插入&#125; 3）测试函数12345678910111213141516void test()&#123; int arr[] = &#123; 24,10,90,77,16,25,33,89,67 &#125;; cout &lt;&lt; "原数组元素为：" &lt;&lt; endl; for (int i = 0; i &lt; (sizeof(arr) / sizeof(arr[0])); i++) &#123; cout &lt;&lt; arr[i] &lt;&lt; " "; &#125; cout &lt;&lt; endl; MaxHeap&lt;int&gt; heap(arr, (sizeof(arr) / sizeof(arr[0]))); cout &lt;&lt; "输出堆中元素：" &lt;&lt; endl; heap.Display(); cout &lt;&lt; heap.Delete() &lt;&lt; "已被删除！" &lt;&lt; endl; cout &lt;&lt; "输出堆中元素：" &lt;&lt; endl; heap.Display();&#125; 4）执行结果 5）源码地址​ 最大堆的实现源码]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>堆</tag>
        <tag>最大堆</tag>
        <tag>最小堆</tag>
        <tag>优先队列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[交换排序——冒泡快速和快速排序的实现]]></title>
    <url>%2F2019%2F08%2F01%2F%E4%BA%A4%E6%8D%A2%E6%8E%92%E5%BA%8F%E2%80%94%E2%80%94%E5%86%92%E6%B3%A1%E5%BF%AB%E9%80%9F%E5%92%8C%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E7%9A%84%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[一、概述&emsp;&emsp;利用交换对象的位置进行排序的方法称之为交换排序。常用的交换排序方法有冒泡排序法和快速排序法。快速排序法是一种分区交换排序方法。 二、冒泡排序 冒泡排序法是一种简单常用的排序方法。 冒泡排序的思想是：对n个对象的对象集合，设第一个对象下标为0，依次把对象下标i定为0,1,2,3,……，n-2，然后依次将待排序对象集合中下标为i对象的关键码与下标为i+1对象的关键码进行比较，若前者大于后者，则交换两者的位置；后者不交换。 当这样的过程完成后，n个对象的数组的最后一个单元中就存放了对象集合中关键码最大的对象。 然后，不考虑这个已排好序对的对象，重新进行这样的过程，当这样的过程完成后，n-1个对象的数组的最后一个单元中就存放了对象集合中关键码最大的对象。当这样的过程进行n-1次，对象集合中就是排好序的对象集合。 1）冒泡排序的实现12345678910111213141516171819202122232425template&lt;class T&gt;void BubbleSort(T arr[], int n)&#123;//对arr数组元素进行排序 int i, j, flag=1; T temp; for (i = 0; i &lt; n &amp;&amp; flag == 1; i++) &#123; flag = 0; /* flag用于标记本次交换排序过程是否 有交换动作，若本次交换排序过程没有交换动作， 则说明对象集合已全部排好序，就可提前结束排序过程 */ for (j = 0; j &lt; n-i; j++) &#123; if (arr[j] &gt; arr[j + 1]) &#123; flag = 1; temp = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = temp; &#125; &#125; &#125;&#125; 2）测试函数123456789101112131415161718void test()&#123; int arr[] = &#123; 5,15,1,48,23,2,5,4,9 &#125;; int n = sizeof(arr) / sizeof(arr[0])-1; cout &lt;&lt; "原数组为：" &lt;&lt; endl; for (int i = 0; i &lt; n; i++) &#123; cout &lt;&lt; arr[i] &lt;&lt; " "; &#125; cout &lt;&lt; endl; BubbleSort(arr, n); cout &lt;&lt; "排序结果为：" &lt;&lt; endl; for (int j = 0; j &lt; n; j++) &#123; cout &lt;&lt; arr[j] &lt;&lt; " "; &#125; cout &lt;&lt; endl;&#125; 3）执行结果 4）时空复杂度分析 时间复杂度: 冒泡排序算法的最好情况是对象集合已全部排好序，这时循环n-1次，每次循环都因没有交换动作而退出，因此冒泡排序最好情况的时间复杂度是O(n); 冒泡排序的最坏情况是对象集合全部逆序存放，这时循环n-1次，整个循环的比较次数和移动次数为： 比较次数=$\sum^{1}_{i=n-1}{i}$=$\frac{n(n-1)}{2}$ 移动次数=3$\sum^{i}_{i=n-1}{i}$=$\frac{3n(n-1)}{2}$ 因此，冒泡排序算法最坏情况的时间复杂度为O($n^2$) 空间复杂度： 冒泡排序算法的空间复杂度为O(1)。显然，冒泡排序算法是一种稳定的排序方法。 5）源码地址​ 冒泡排序实现源码 三、快速排序 快速排序又称为分区交换排序。 快速排序算法的基本思想是：从待排序的对象数组中任取一个个对象（通常是取对象数组中的第一个对象）作为基准，调整对象数组中各个对象在数组中的位置，使排在该对象前面对象的关键码均小于该对象的关键码，使排在该对象后面对象的关键码均大于该对象的关键码。 这样的交换过程结束后，一方面将该对象放在未来排好序的对象数组中该对象应在的位置上；另一方面将该对象数组中的对象以该对象为基准划分成了两个子对象数组，位于该基准对象左边子对象数组中对象的关键码均小于该对象的关键码，位于该基准对象右边子对象数组中对象的关键码均大于等于该对象的关键码。 对于这两个子对象数组中的对象分别再进行方法类同的快速排序，当各个子对象数组中的对象个数均小于1时，排序过程结束。显然，快速排序算法过程是递归的过程。 1）快速排序的实现12345678910111213141516171819202122232425262728293031template&lt;class T&gt;int Partition(T arr[], int low, int high)&#123;//表的划分 T pivot;//基准 Swap(arr, low, (low + high) / 2);//交换第一个元素与中间元素 pivot = arr[low];//将交换过来的中间元素作为基准 int last_small = low; for (int i = low + 1; i &lt;= high; i++) &#123; if (arr[i] &lt; pivot) &#123; last_small = last_small + 1; Swap(arr, last_small, i); &#125; &#125; Swap(arr, low, last_small); return last_small;&#125;template&lt;class T&gt;void QuickSort(T arr[], int low, int high)&#123;//快速排序 int q; if (low &lt; high) &#123; q = Partition&lt;T&gt;(arr, low, high); QuickSort(arr, low, q - 1); QuickSort(arr, q + 1, high); &#125;&#125; 2)快速排序的过程&emsp;&emsp;在快速排序中，Partition函数的构造比较重要。Partition函数的算策略有几种，有的策略比本文中的算法要快，但却复杂并且容易出错。本文中的算法更加简单而且易于理解，当然也不慢。实际上，在所有的算法中，它所进行的键比较的次数可能是最少的。 &emsp;&emsp;对于基准的选择，并非一定要选择顺序表的首个元素作为基准，我们可以选择任意一个元素并在划分表的循环开始之前将它与表中的第一个元素交换。实际上，首个元素作为基准经常是一种拙劣的选择，因为一旦此顺序表是已经排过序的，则不会有其他元素再小于此基准，这将导致其中的一个子表为空表。因此，我们在表的近中央位置处选择了一个基准，希望这种选择可以把关键码划分在基准两边约各占一半。 &emsp;&emsp;给定一个基准pivot，我们必须重新排列表中的元素并计算一个下标pivot_position，使得基准位于pivot_position，在此下标左边的所有元素的关键码均小于pivot，在其右边的所有元素的关键码均大于或等于pivot。 第一趟排序过程： 3）测试函数123456789101112131415161718void test()&#123; int arr[] = &#123; 5,15,1,48,23,2,5,4,9 &#125;; int n = sizeof(arr) / sizeof(arr[0])-1; cout &lt;&lt; "原数组为：" &lt;&lt; endl; for (int i = 0; i &lt; n; i++) &#123; cout &lt;&lt; arr[i] &lt;&lt; " "; &#125; cout &lt;&lt; endl; QuickSort(arr, 0, n); cout &lt;&lt; "排序结果为：" &lt;&lt; endl; for (int i = 0; i &lt; n; i++) &#123; cout &lt;&lt; arr[i] &lt;&lt; " "; &#125; cout &lt;&lt; endl;&#125; 4）执行结果 5）时空复杂度分析 时间复杂度： 快速排序算法的时间复杂度和各次基准对象的值关系很大。如果每次取得的基准对象的值都能使该对象处于当前对象数组的中间位置上，将原来的对象数组分为两个大小相等的子对象数组，这样的快速排序算法过程相当于一个完全二叉树（即每个结点都把当前对象数组分为两个大小相等的子对象数组结点，n个对象数组的根结点的分解次数就构成一棵完全二叉树）。 这时分解次数等于n个结点的完全二叉树的深度lg2n 每次快速排序过程无论把对象数组怎样划分，全部的比较次数都基本等于n次，所以最好情况下快速排序算法的时间复杂度为O(lgn)。 快速排序算法的最坏情况是n个对象数组的根结点的分解次数构成一棵二叉退化树，一棵二叉退化树的深度为n，所以最坏情况下快速排序算法的时间复杂度为O($n^2$). 一般情况下，基准对象值的分布式随机的，而随机的基准对象值的n个对象数组的根结点的分解次数构成一棵二叉树，这样的二叉树的深度接近lgn，所以快速排序算法的平均时间复杂度为O(nlgn)。 空间复杂度： 快速排序算法需要堆栈空间临时保存递归调用参数，堆栈空间的使用个数与递归调用次数（即n个结点的二叉树的深度）有关，和上述时间复杂度分析类似，最好情况下快速排序算法的空间复杂度为O(lgn); 最坏情况下快速排序算法的空间复杂度为O(n)； 快速排序算法的平均空间复杂度为O(lgn) 5）源码地址​ 快速排序实现源码]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>排序</tag>
        <tag>冒泡排序</tag>
        <tag>快速排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[插入排序及其实现]]></title>
    <url>%2F2019%2F08%2F01%2F%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F%E5%8F%8A%E5%85%B6%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[一、排序的基本概念&emsp;&emsp;排序是将一个无序的数据元素集合整理成按关键码递增（或递减）排列的有规律有序集合的过程。关键码是所定义的数据元素类型中的一个域。 关键码要排序的对象集合可能有多个域，关键码是当前排序时进行比较以确定各个对象位置的域。 在对象集合中，不同的对象其关键码值一定不相同的关键码称为主关键码;不同的对象其关键码值有可能相同的关键码称为次关键码。 排序算法的稳定性&emsp;&emsp;任何排序算法在使用主关键码进行排序时，其排序结果是相同的。当排序算法使用次关键码进行排序时，其排序结果可能相同，也可能不同。 &emsp;&emsp;对于有n个对象集合中的次关键码K[i](i=0,1,2……，n-1)，若K[i]等于K[j](j=0,1,2……，n-1,j!=i),其在排序之前，对象R[i]排在对象R[j]之前，如果在排序之后对象R[i]仍在对象R[j]的前面的排序算法称为稳定的排序算法。否则称为不稳定的排序算法。 &emsp;&emsp;显然，对于一组给定的对象集合，所有稳定的排序算法的排序结果都是相同的，不稳定的排序算法的排序结果有可能相同，也有可能不同。稳定的排序算法通常是应用问题所希望的，因此，排序算法的稳定性是衡量排序算法好坏的一个重要标准。 排序算法的时间复杂度&emsp;&emsp;和所有算法一样，时间复杂度是衡量排序算法好坏的一个重要标准。排序算法的时间复杂度主要表现在算法中对象关键码的比较和对象的移动上。对于有n个对象的集合的排序问题，因为从该集合中找出一个最大（或最小）对象一定要遍历该集合，其时间复杂度为O(n),而进一步将n个对象均排列整齐的最理想情况可对应成完全二叉树结果，其时间复杂度为O(nlgn),因此排序算法最好的时间复杂度为O(nlgn) 排序算法的空间复杂度&emsp;&emsp;和所有算法一样，空间复杂度是衡量排序算法好坏的一个重要标准。排序算法的空间复杂度也就是算法中使用的辅助存储单元的多少。当排序算法中使用的存储单元与排序对象的个数n无关时，其空间复杂度为O(1),因此排序算法最好的空间复杂度为O(1)。空间复杂度为O(1)的排序算法也称为原地排序算法。原地排序算法就是在原来存放对象的数组空间中重新按关键码大小排放对象集合。 二、插入排序&emsp;&emsp;插入排序是一种由初始空集开始，不断地把新的对象插入到数组合适位置的排序方法，常用的插入排序法有直接插入排序、链表插入排序、希尔排序。 直接插入排序 直接插入排序的基本思想是：顺序地把待排序的对象按其关键码值的大小插入到已排序对象集合的适当位置。 假设待排序的对象为R[0]、R[1]、R[2]、……、R[n-1],开始排序时对象集合R[0]因只有一个对象，所以已排好序。 第一次循环准备将对象R[1]插入到已排好序的对象集合R[0]中，这只需要比较K[0]和K[1]，若K[0]&lt;=K[1]，则已排好序，否则将R[1]插入到R[0]之前，这样，对象集合R[0],R[1]已排好序。 第二次循环准备将R[2]插入到已排好序的对象集合R[0],R[1]中，这需要先比较K[2]和K[1]以确定是否需要把R[2]插入到R[1]之前，然后比较K[2]和K[0]以确定是否需要把R[2]插入到R[0]之前。 这样的循环过程一直进行到R[n-1]插入完为止。这时对象集合R[0]、R[1]、R[2]、……、R[n-1]就全部排好序了。 1）直接插入排序的实现1234567891011121314151617template&lt;class T&gt;void InsertSort(T a[], int n)&#123; int i, j; T temp; for (int i = 0; i &lt; n - 1; i++) &#123; temp = a[i + 1]; j = i; while (j &gt; -1 &amp;&amp; temp &lt; a[j]) &#123; a[j + 1] = a[j]; j--; &#125; a[j + 1] = temp; &#125;&#125; 2）测试函数 123456789101112131415161718void test()&#123; int sort[] = &#123; 15,22,6,7,2,1,56,89,14 &#125;; int n = sizeof(sort) / sizeof(sort[0])-1; cout &lt;&lt; "原数组为：" &lt;&lt; endl; for (int i = 0; i &lt; n; i++) &#123; cout &lt;&lt; sort[i] &lt;&lt; " "; &#125; cout &lt;&lt; endl; InsertSort(sort, n); cout &lt;&lt; "排序结果为：" &lt;&lt; endl; for (int i = 0; i &lt; n; i++) &#123; cout &lt;&lt; sort[i] &lt;&lt; " "; &#125; cout &lt;&lt; endl;&#125; 3）执行结果 4）时空复杂度分析 直接插入排序算法的时间复杂度分析可分为最好和最坏两种情况考虑： 最好的情况是原始对象集合已全部排好序。此时while循环的循环次数均为0。这样在每次排序过程中关键码的比较次数为1，对象的移动次数为2，因此整个排序过程中关键码的比较次数为n-1，对象的移动次数为2(n-1)，所以最好情况的时间复杂度为O(n) 最坏的情况是原始对象集合逆序排列。这种情况下第i次排序时算法中的while循环的循环次数均为i。这样在整个排序过程中关键码的比较次数和对象移动次数可计算如下： ​ 比较次数=$\sum^{ n-1}_{i=1}{(i+1)}$=$\frac {(n-1)(n+2)}{2}$ ​ 移动次数=$\sum_{i=1}^{n-1}{i+2}$=$\frac{(n-1)(n+4)}{2}$ 因此，最坏情况下其时间复杂度为O($n^2$)。 空间复杂度 直接插入排序算法的空间复杂度为O(1) 直接插入排序算法是一种稳定的排序算法 5）源码地址​ 直接插入排序实现源码 链表插入排序&emsp;&emsp;链表插入排序的最终排序结果将把对象集合按关键码大小依次链接地存储在一个链表中。这时链表中每个结点的结构除数据域外要增加一个指向结点类型的指针域。 链表插入排序的思想是：初始时链表为空，第一个对象R[0]直接插入到链表中。第二个对象R[1]插入到链表中的位置由K[0]和K[1]比较确定：若K[1]&lt;K[0]，则把R[1]插入到R[0]前；否则把R[1]插入到R[0]后. 第三个对象R[2]插入到链表中的位置由K[2]和K[1]、K[0]比较确定。若K[2]&lt;K[0],则把K[2]插入到K[0]前。若K[2]&gt;K[0]，应比较K[2]、K[1]； 若K[2]&lt;K[1]，则把R[2]插入到R[0]后，R[1]前，若K[2]&gt;K[1]，则把R[2]插入到R[1]后。 这样的插入过程进行到R[n-1]插入完成后，则原始对象集合按关键码大小依次链接在一个链表中。 1）链表插入排序的实现链表中结点的数据类型定义：12345678template&lt;class T&gt;struct Node&#123; T data;//数据域 Node* next;//指针域 Node(Node* p = NULL) :next(p) &#123;&#125;//用于构造头结点 Node(T item,Node*p=NULL):data(item),next(p)&#123;&#125;//构造其他存放数据元素的结点&#125;; 链表插入排序的实现： 123456789101112131415161718template&lt;class T&gt;void LinkListInsertSort(T a[], Node&lt;T&gt;*&amp; list, int n)&#123; Node&lt;T&gt;* curr, * pre, * q; for (int i = 0; i &lt; n; i++) &#123; curr = list-&gt;next; pre = list; q = new Node&lt;T&gt;(a[i]); while (curr != NULL &amp;&amp; curr-&gt;data &lt;= a[i]) &#123; pre = curr; curr = curr-&gt;next; &#125; q-&gt;next = pre-&gt;next; pre-&gt;next = q; &#125;&#125; 2）测试函数 1234567891011121314void test()&#123; int arr[]= &#123; 15,22,6,7,2,1,56,89,14 &#125;; int n = sizeof(arr) / sizeof(arr[0])-1; cout &lt;&lt; "原数组为：" &lt;&lt; endl; for (int i = 0; i &lt; n; i++) &#123; cout &lt;&lt; arr[i] &lt;&lt; " "; &#125; cout &lt;&lt; endl; Node&lt;int&gt;* list = new Node&lt;int&gt;; LinkListInsertSort(arr, list, n); Display(list);//输出链表&#125; 3）执行结果 4）时空复杂度分析 最坏时间复杂度 链表插入排序算法不需要移动数据对象，每插入一个对象时，最小关键码比较次数等于1，最大关键码比较次数等于链表中已排好序的对象的个数，即： ​ 最小比较次数=n-1​ ​ 最大比较次数=$\sum^{n-1}_{i=1}{i}$=$\frac{n(n-1)}{2}$ 所以，链表插入排序算法最坏情况的时间复杂度为O($n^2$)。 空间复杂度 链表插入排序算法另外需要n个结点存放排好序的数据对象，所以，链表插入排序算法的空间复杂度为O(n). 链表插入排序算法是一种稳定的排序算法。 5）源码地址​ 链表插入排序实现源码 希尔排序&emsp;&emsp;希尔排序又称作最小增量排序，希尔排序算法的思想是：不断把待排序的对象分成若干个小组，对同一小组内的对象用直接插入法进行排序，当完成了所有对象都分在一个小组内的排序之后，排序过程结束。 &emsp;&emsp;希尔排序是在分组概念上的插入排序，即在不断缩小组的个数时把原各小组的对象插入到新组中的合适位置上。 &emsp;&emsp;原始对象集合越接近有序，直接插入排序算法的时间效率越高，这也是希尔排序算法能够成立的基础。希尔排序算法把待排序对象分成若干小组，在小组内用直接插入排序算法排序，当把小的小组合并为一些大的小组时，其中的对象集合将会接近有序，从而使直接插入排序算法的时间效率很高。 1）希尔排序的实现12345678910111213141516171819202122template&lt;class T&gt;void ShellSort(T arr[], int n, int increment[], int numOfIncrement)&#123; T temp; for (int m = 0; m &lt; numOfIncrement; m++) &#123; for (int k = 0; k &lt; increment[m]; k++) &#123;//每个小组内按直接插入排序算法排序，区别只是每次不是增1，而是increment[m] for (int i = k; i &lt; n - increment[m]; i = i + increment[m]) &#123; temp = arr[i + increment[m]]; int j = i; while (j &gt; -1 &amp;&amp; temp &lt;= arr[j]) &#123; arr[j + increment[m]] = arr[j]; j = j - increment[m]; &#125; arr[j + increment[m]] = temp; &#125; &#125; &#125;&#125; 2）希尔排序过程当增量increment=4时： 当增量increment=3时： 当增量increment=1时： 3）测试函数1234567891011121314151617181920void test()&#123; int arr[]= &#123; 15,22,6,7,2,1,56,89,14 &#125;; cout &lt;&lt; "原数组为：" &lt;&lt; endl; int n = sizeof(arr) / sizeof(arr[0])-1; for (int i = 0; i &lt; n; i++) &#123; cout &lt;&lt; arr[i] &lt;&lt; " "; &#125; cout &lt;&lt; endl; int increment[] = &#123; 4,3,1 &#125;; int numOfIncrement = sizeof(increment) / sizeof(increment[0]); ShellSort(arr, n, increment, numOfIncrement); cout &lt;&lt; "排序结果：" &lt;&lt; endl; for (int i = 0; i &lt; n; i++) &#123; cout &lt;&lt; arr[i] &lt;&lt; " "; &#125; cout &lt;&lt; endl;&#125; 4）执行结果 5）时空复杂度 时间复杂度： 比较希尔排序和直接排序算法可见，直接插入排序算法是两重循环，希尔排序算法是四重循环，但分析希尔排序算法中四重循环的循环数值可以发现，四重循环每重的循环数值都很小，并且当增量递减、小组变大时，小组内的对象数值已经基本有序了，而我们知道，越接近有序的直接插入，排序算法的时间效率越高。因此，希尔排序算法的时间复杂度较直接插入排序算法的时间复杂度改善了很多。 希尔排序算法的时间复杂度分析比较复杂，实际所需的时间取决于各次排序时增量的个数和增量的取值。研究证明，若增量的取值合理，希尔排序算法的时间复杂度约为O(n$({lgn})^2$)。 空间复杂度： 希尔排序算法的空间复杂度为O(1)。由于希尔排序算法是按增量分组进行的排序，所以希尔排序是一种不稳定的排序算法。 5）源码地址​ 希尔排序实现源码]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>排序</tag>
        <tag>插入排序</tag>
        <tag>直接插入排序</tag>
        <tag>链表插入排序</tag>
        <tag>希尔排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二叉搜索树及其实现]]></title>
    <url>%2F2019%2F07%2F31%2F%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E5%8F%8A%E5%85%B6%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[一、二叉搜索树概述&emsp;&emsp;一棵二叉搜索树(Binary Search Tree,BST)是以一棵二叉树来组织的。BST是满足下面条件的二叉树，该条件即二叉搜索树属性： 对于二叉搜索树的一个结点，设其值为K，则该结点左子树任意一个结点的值都小于K 该结点右子树中任意一个结点的值都大于或等于K。 &emsp;二叉查找树的特点是，如果按照中序周游将各个结点打印出来，就会得到由小到大排列结点。 &emsp;&emsp;从根结点开始，在BST中检索值K。如果根结点存储的值为K，则检索结束。如果不是，则必须检索树的更深一层。BST的效率在于只需检索两棵子树之一。如果K小于根结点的值，则只需检索左子树；如果K大于根结点的值，则只需检索右子树。这个过程一直持续到K被找到或遇到一个叶结点为止。如果遇到叶结点仍没有发现K，那么K就不在这个BST中。 二、二叉搜索树的实现&emsp;二叉搜索树结点类的定义：12345678910111213141516171819202122template&lt;class T&gt;class BinarySearchTree;template&lt;class T&gt;class BitreeNode&#123; friend class BinarySearchTree&lt;T&gt;;public: T data;//数据域 BitreeNode() :leftChild(NULL), rightChild(NULL) &#123;&#125;//构造函数 BitreeNode(T item, BitreeNode&lt;T&gt;* left = NULL, BitreeNode&lt;T&gt;* right = NULL) :data(item), leftChild(left), rightChild(right) &#123;&#125; ~BitreeNode() &#123;&#125;//析构函数 BitreeNode&lt;T&gt;*&amp; Left() &#123; return leftChild; &#125; BitreeNode&lt;T&gt;*&amp; Right() &#123; return rightChild; &#125;private: BitreeNode&lt;T&gt;* leftChild;//左子树指针 BitreeNode&lt;T&gt;* rightChild;//右子树指针&#125;; 二叉搜索树是以二叉树来组织的，所以其结点类的定义于二叉树结点类的定义相同。 二叉搜索树类的定义：1234567891011121314151617181920212223242526272829template&lt;class T&gt;class BinarySearchTree&#123;public: BinarySearchTree() :root(NULL) &#123;&#125;//无参构造参数 BinarySearchTree(const BinarySearchTree&amp; rhs);//有参构造函数 ~BinarySearchTree();//析构函数 const T&amp; findMax() const;//寻找最大值 const T&amp; findMin() const;//寻找最小值 bool contains(const T&amp; value) const;//判断value是否存在 bool isEmpty() const;//二叉搜索树是否为空 void InOrder(void(*visit)(T item)) const;//输出树结点 void makeEmpty();//清空树 void insert(const T&amp;value);//插入 void remove(const T&amp;value);//删除值为value的结点private: BitreeNode&lt;T&gt;* root;//根结点 void insert(const T&amp; value, BitreeNode&lt;T&gt;*&amp; t) const;//插入新结点 void remove(const T&amp; value, BitreeNode&lt;T&gt;*&amp; t) const;//删除结点 BitreeNode&lt;T&gt;* finMin(BitreeNode&lt;T&gt;* t) const;//查找二叉搜索树中值最小的结点 BitreeNode&lt;T&gt;* finMax(BitreeNode&lt;T&gt;* t) const;//查找二叉搜索树中值最大的结点 bool contains(const T&amp; value, BitreeNode&lt;T&gt;* t) const;//判断二叉搜索树中是否存在一个值为value的结点 void makeEmpty(BitreeNode&lt;T&gt;*&amp; t);//清空结点 void InOrder(BitreeNode&lt;T&gt;* t, void(*visit)(T item))const;//中序输出结点 void PreOrder(BitreeNode&lt;T&gt;* t, void(*visit)(T item)) const;//前序输出结点 void PostOrder(BitreeNode&lt;T&gt;* t, void(*visit)(T item)) const;//后序输出结点&#125;; 二叉搜索树的一个最重要的应用就是它们在查找中的应用。虽然任意复杂的项在C++中都很容易处理，但是为了简单起见，先假设它们都是整数。 其实现的部分代码如下： 1234567891011121314151617181920212223template&lt;class T&gt;inline bool BinarySearchTree&lt;T&gt;::contains(const T&amp; value) const&#123; return contains(value, root);&#125;template&lt;class T&gt;inline bool BinarySearchTree&lt;T&gt;::contains(const T&amp; value, BitreeNode&lt;T&gt;* t) const&#123; if (t == NULL) return false; else if (value &lt; t-&gt;data) &#123; return contains(value, t-&gt;leftChild); &#125; else if (value &gt; t-&gt;data) &#123; return contains(value, t-&gt;rightChild); &#125; else return true;&#125; contains函数用来判断二叉树中是否存在值为value的结点。如果在树中存在该结点，那么该函数返回true,否则返回false.树的结构使得该操作很简单。如果树为空，则返回false,否则，如果根结点的值为value，则返回true。若以上两种情况都不成立，则根据value与根结点值的大小关系决定对左子树还是右子树进行递归调用。 1234567891011121314151617181920212223242526272829303132template&lt;class T&gt;inline void BinarySearchTree&lt;T&gt;::InOrder(BitreeNode&lt;T&gt;* t,void(*visit)(T item)) const&#123;//中序遍历 if (t != NULL) &#123; printTree(t-&gt;leftChild, visit); visit(t-&gt;data); printTree(t-&gt;rightChild, visit); &#125;&#125;template&lt;class T&gt;inline void BinarySearchTree&lt;T&gt;::PreOrder(BitreeNode&lt;T&gt;* t, void(*visit)(T item)) const&#123;//前序遍历 if (t != NULL) &#123; visit(t-&gt;data); PreOrder(t-&gt;leftChild, visit); PreOrder(t-&gt;rightChild, visit); &#125;&#125;template&lt;class T&gt;inline void BinarySearchTree&lt;T&gt;::PostOrder(BitreeNode&lt;T&gt;* t, void(*visit)(T item)) const&#123;//后序遍历 if (t != NULL) &#123; PostOrder(t-&gt;leftChild,visit); PostOrder(t-&gt;rightChild, visit); visit(t-&gt;data); &#125;&#125; 以上分别为中序遍历，前序遍历和后序遍历。其中，中序遍历的输出结果是从小到大进行排列的，这也是二叉搜索树的一个特点。中序遍历(LDR)、前序遍历(DLR)、后序遍历(LRD)。 12345678910111213141516171819202122232425template&lt;class T&gt;inline BitreeNode&lt;T&gt;* BinarySearchTree&lt;T&gt;::finMin(BitreeNode&lt;T&gt;* t) const&#123; if (t != NULL) &#123; while (t-&gt;leftChild != NULL) &#123; t = t-&gt;leftChild; &#125; &#125; return t;&#125;template&lt;class T&gt;inline BitreeNode&lt;T&gt;* BinarySearchTree&lt;T&gt;::finMax(BitreeNode&lt;T&gt;* t) const&#123; if (t != NULL) &#123; while (t-&gt;rightChild != NULL) &#123; t = t-&gt;rightChild; &#125; &#125; return t;&#125; 以上两个函数是用来查找最大值和最小值。由于二叉搜索函树的性质，所以查找最大值和最小值也比较方便。对于最小值，还需要查找到最左叶子结点，即为最小值；而最大值则需要查找到最右叶子节点，即为最大值。 12345678910111213141516template&lt;class T&gt;inline void BinarySearchTree&lt;T&gt;::insert(const T&amp; value, BitreeNode&lt;T&gt;*&amp; t) const&#123; if (t == NULL) &#123; t = new BitreeNode&lt;T&gt;(value); &#125; else if (value &lt; t-&gt;data) &#123; insert(value, t-&gt;leftChild); &#125; else if (value &gt; t-&gt;data) &#123; insert(value, t-&gt;rightChild); &#125;&#125; 对于一个二叉搜索树来说，insert函数相对来说比较重要，因为二叉搜索树的属性是左孩子始终比双亲结点小，而右孩子始终比双亲结点大。此时需要注意的是，此二叉搜索树并不能处理插入已存在数据的操作，即二叉树结点中的每一项的值是各不相同的。 123456789101112131415161718192021222324252627template&lt;class T&gt;inline void BinarySearchTree&lt;T&gt;::remove(const T&amp; value,BitreeNode&lt;T&gt;*&amp; t) const&#123; if (t == NULL) &#123; return; &#125; if (value &lt; t-&gt;data) &#123; remove(value, t-&gt;leftChild); &#125; else if (value &gt; t-&gt;data) &#123; remove(value, t-&gt;rightChild); &#125; else if (t-&gt;leftChild != NULL &amp;&amp; t-&gt;rightChild != NULL) &#123; t-&gt;data = findMin(t-&gt;right)-&gt;data; remove(t-&gt;data, t-&gt;rightChild); &#125; else &#123; BitreeNode&lt;T&gt;* oldNode = t; t = (t-&gt;leftChild != NULL) ? t-&gt;leftChild : t-&gt;rightChild; delete oldNode; &#125;&#125; 最值得注意的是删除操作，即remove。删除操作需要考虑多种情况。 当要删除的对象为叶子结点时，可以直接删除该叶子结点。 如果结点有一个孩子，则该结点可以在其父结点调整它的链以绕过该结点后被删除。图示如下： ​ 在该树中，我们删除了具有一个孩子的结点4。 复杂的情况是，处理具有两个孩子的结点。一般的删除策略是用其右子树的最小数据代替该结点的数据并递归地删除该结点。因为右子树中的最小的结点不可能有左孩子，所以第二次remove就很容易了。图示如下： ​ 在该树中，我们删除了具有两个孩子的结点4，其中虚线连接的结点代表已经删除了。右边的图是删除后的结果。在删除后，它被右子树中最小的值，即3代替了。 三、主函数及执行结果1234567891011121314151617181920212223242526272829303132333435363738#include&lt;iostream&gt;#include"BST.h"using namespace std;int main()&#123; BinarySearchTree&lt;int&gt; BST; BST.insert(20); BST.insert(18); BST.insert(5); BST.insert(10); BST.insert(25); BST.insert(4); BST.insert(21); BST.insert(18); cout &lt;&lt; "最大值："; cout &lt;&lt; BST.findMax() &lt;&lt; endl; cout &lt;&lt; "最小值："; cout &lt;&lt; BST.findMin() &lt;&lt; endl; int temp = 18; if (BST.contains(temp)) &#123; cout &lt;&lt; "BST中存在" &lt;&lt;temp&lt;&lt; endl; &#125; else cout &lt;&lt; "BST中不存在"&lt;&lt;temp &lt;&lt; endl; BST.InOrder(Visit); cout &lt;&lt; endl; BST.makeEmpty(); if (BST.isEmpty()) &#123; cout &lt;&lt; "BST为空！" &lt;&lt; endl; &#125; else cout &lt;&lt; "BST非空！" &lt;&lt; endl; system("pause"); return EXIT_SUCCESS;&#125; 执行结果： 四、源码地址​ 二叉搜索树的实现源码]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>二叉树</tag>
        <tag>二叉搜索树</tag>
        <tag>BST</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二叉树的实现]]></title>
    <url>%2F2019%2F07%2F31%2F%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[一、二叉树结点类定义1234567891011121314151617181920212223template&lt;class T&gt;class BinaryTree;template&lt;class T&gt;class BiTreeNode&#123; friend class BinaryTree&lt;T&gt;;public: T data;//数据域 BiTreeNode() :leftChild(NULL), rightChild(NULL) &#123;&#125;//构造函数 BiTreeNode(T item,BiTreeNode&lt;T&gt;*left=NULL,BiTreeNode&lt;T&gt;*right=NULL)//构造函数 :data(item),leftChild(left),rightChild(right)&#123;&#125; ~BiTreeNode()&#123;&#125;//析构函数 BiTreeNode&lt;T&gt;*&amp; Left() &#123;//获得左孩子 return leftChild; &#125; BiTreeNode&lt;T&gt;*&amp; Right() &#123;//获得右孩子 return rightChild; &#125;private: BiTreeNode&lt;T&gt;* leftChild;//左子树指针 BiTreeNode&lt;T&gt;* rightChild;//右子树指针&#125;; 二、二叉树类定义123456789101112131415161718192021222324252627282930313233343536template&lt;class T&gt;class BinaryTree&#123;public: BinaryTree() :root(NULL)&#123;&#125;;//构造函数 ~BinaryTree() &#123;&#125;;//析构函数 //构造二叉树 void MakeTree(const T&amp; item); //第一类操作的成员函数 bool Root();//使根结点为当前结点 bool Parent();//使双亲结点为当前结点 bool LeftChild();//使左孩子结点为当前结点 bool RightChild();//使右孩子结点为当前结点 //第二类操作的成员函数 void InsertChild(const T &amp;value);//使根结点为当前结点 void DeleteSubTree(BiTreeNode&lt;T&gt;*&amp; t);//删除以t为根结点的子树 void clear();//清空树 //第三类操作的成员函数 //遍历访问二叉树 void PreOrder(void(*visit)(T item));//前序遍历访问树 void InOrder(void(*visit)(T item));//中序遍历访问树 void PostOrder(void(*visit)(T item));//后序遍历访问树private: BiTreeNode&lt;T&gt;* root;//根结点指针 BiTreeNode&lt;T&gt;* current;//当前结点指针 bool Current(BiTreeNode&lt;T&gt;*&amp; t);//使当前结点为t所指结点 void PreOrder(BiTreeNode&lt;T&gt;*&amp; t, void(*visit)(T item)); void InOrder(BiTreeNode&lt;T&gt;*&amp; t, void(*visit)(T item)); void PostOrder(BiTreeNode&lt;T&gt;*&amp; t, void(*visit)(T item)); //插入 void Insert(const T&amp; value, BiTreeNode&lt;T&gt;*&amp; t); //在树root中回溯查找s的双亲结点 BiTreeNode&lt;T&gt;* SearchParent(BiTreeNode&lt;T&gt;*&amp; root, BiTreeNode&lt;T&gt;*&amp; s);&#125;; 三、二叉树实现的部分代码前序遍历即DLR，也叫做先根遍历、先序遍历、前序周游，记作根左右。前序遍历首先访问根结点，然后遍历左子树，最后遍历右子树。 这里使用visit(item)函数来输出结点数据域值，同时，visit(item)函数经过修改之后，也可以输出自定义数据类型中需要输出的数据。 visit(item)函数的实现如下： 12345template&lt;class T&gt;void Visit(T item)&#123; cout &lt;&lt; item &lt;&lt; " ";&#125; 12345678910111213141516template&lt;class T&gt;inline void BinaryTree&lt;T&gt;::PreOrder(void(*visit)(T item))&#123; PreOrder(root,Visit);&#125;template&lt;class T&gt;inline void BinaryTree&lt;T&gt;::PreOrder(BiTreeNode&lt;T&gt;*&amp; t, void(*visit)(T item))&#123; if (t != NULL) &#123; visit(t-&gt;data); PreOrder(t-&gt;leftChild,visit); PreOrder(t-&gt;rightChild,visit); &#125;&#125; 中序遍历即DLR，也叫中根遍历、中序周游。可记作根左右。在二叉树中，中序遍历首先遍历左子树，然后访问根结点，最后遍历右子树。 12345678910111213141516template&lt;class T&gt;inline void BinaryTree&lt;T&gt;::InOrder(void(*visit)(T item))&#123; InOrder(root,Visit);&#125;template&lt;class T&gt;inline void BinaryTree&lt;T&gt;::InOrder(BiTreeNode&lt;T&gt;*&amp; t, void(*visit)(T item))&#123; if (t != NULL) &#123; InOrder(t-&gt;leftChild, visit); visit(t-&gt;data); InOrder(t-&gt;rightChild, visit); &#125;&#125; 后序遍历即LRD，也叫后根遍历、后序变周游，可记作左右根。在二叉树中，首先遍历左子树，然后遍历右子树，最后访问根结点。 12345678910111213141516template&lt;class T&gt;inline void BinaryTree&lt;T&gt;::PostOrder(void(*visit)(T item))&#123; PostOrder(root,Visit);&#125;template&lt;class T&gt;inline void BinaryTree&lt;T&gt;::PostOrder(BiTreeNode&lt;T&gt;*&amp; t, void(*visit)(T item))&#123; if (t != NULL) &#123; PostOrder(t-&gt;leftChild, visit); PostOrder(t-&gt;rightChild, visit); visit(t-&gt;data); &#125;&#125; 删除子树123456789101112131415161718template&lt;class T&gt;inline void BinaryTree&lt;T&gt;::DeleteSubTree(BiTreeNode&lt;T&gt;*&amp; t)&#123; if (t == NULL) return; else &#123; BiTreeNode&lt;T&gt;* q=t-&gt;leftChild, *p; while (q != NULL) &#123; p = q-&gt;rightChild; DeleteSubTree(q); q = p; &#125; delete t; t = NULL; &#125;&#125; 插入结点在此实现中，对于二叉树结点的插入基本与二叉搜索树相同。当根结点为空时，新插入的结点作为根结点。当新插入的结点值小于根结点值时，插入到左子树；当新插入的结点值大于根结点值时，插入到右子树。 12345678910111213141516171819202122template&lt;class T&gt;inline void BinaryTree&lt;T&gt;::InsertChild(const T&amp; value)&#123; Insert(value, root);&#125;template&lt;class T&gt;inline void BinaryTree&lt;T&gt;::Insert(const T&amp; value, BiTreeNode&lt;T&gt;*&amp; t)&#123; if (t == NULL) t = new BiTreeNode&lt;T&gt;(value); else if (value &lt; t-&gt;data) &#123; Insert(value, t-&gt;leftChild); &#125; else if (value &gt; t-&gt;data) &#123; Insert(value, t-&gt;rightChild); &#125; else return;&#125; 四、主函数及执行结果123456789101112131415161718192021222324int main()&#123; BinaryTree&lt;int&gt;BiTree; BiTree.InsertChild(15); BiTree.InsertChild(5); BiTree.InsertChild(6); BiTree.InsertChild(8); BiTree.InsertChild(20); BiTree.InsertChild(22); BiTree.InsertChild(16); BiTree.InsertChild(18); cout &lt;&lt; "前序：" &lt;&lt; endl; BiTree.PreOrder(Visit); cout &lt;&lt; endl &lt;&lt; "中序:" &lt;&lt; endl; BiTree.InOrder(Visit); cout &lt;&lt; endl &lt;&lt; "后序:" &lt;&lt; endl; BiTree.PostOrder(Visit); cout &lt;&lt; endl; BiTree.clear(); cout &lt;&lt; "前序：" &lt;&lt; endl; BiTree.PreOrder(Visit); system("pause"); return EXIT_SUCCESS;&#125; 执行结果： 五、源码地址​ 二叉树的实现源码]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>二叉树</tag>
        <tag>二叉树的遍历</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[多态]]></title>
    <url>%2F2019%2F07%2F31%2F%E5%A4%9A%E6%80%81%2F</url>
    <content type="text"><![CDATA[一、多态&emsp;多态是面向对象程序设计语言中数据抽象和继承之外的第三个基本特征。 &emsp;多态性(Polymorphism)提供接口与具体实现之间的另一层隔离，从而实现将“what”和“how”分离开来。多态性改善了代码的可读性和组织性，同时也使创建的程序具有可扩展性。项目不仅在最初创建时期可以扩展，而且当项目在需要有新功能时也能扩展。 &emsp;C++支持编译时多态（静态多态）和运行时多态（动态多态），运算符重载和函数重载就是编译时多态，而派生类和虚函数实现运行时多态。 二、静态联编和动态联编静态多态和动态多态的区别就是函数地址是早绑定（静态联编）还是晚绑定（动态联编）。如果函数的调用，在编译阶段就可以确定函数的调用地址，并产生代码，就是静态多态（联编时多态），也就是说地址是早绑定的。而如果函数的调用地址不能在编译期间确定，而需要在运行时才能决定，这就属于晚绑定（运行时多态）。 1234567891011121314151617181920212223242526272829303132#include&lt;iostream&gt;using namespace std;class Animal&#123;public: void speak() &#123; cout &lt;&lt; "动物在说话" &lt;&lt; endl; &#125;&#125;;class Cat:public Animal&#123;public: void speak() &#123; cout &lt;&lt; "喵喵喵" &lt;&lt; endl; &#125;&#125;;void doSpeak(Animal&amp;animal)&#123; animal.speak();&#125;void test01()&#123; Cat cat; doSpeak(cat);&#125; 当主函数调用dospeak()函数时，执行结果如下： &emsp;我们可以看到输出结果为“动物在说话”,这是因为当调用dospeak函数时，speak函数的地址早就绑定好了，早绑定，即动态联编，在编译近阶段就确定好了地址。 &emsp;如果想调用猫的speak函数，就不能提前绑定好地址，所以需要在运行的时候再去确定函数地址，即动态联编，将dospeak方法改为虚函数，写法是在父类上声明虚函数，发生多态。发生多态时，父类的引用或指针指向了子类对象。 12345678class Animal&#123;public: virtual void speak() &#123; cout &lt;&lt; "动物在说话" &lt;&lt; endl; &#125;&#125;; 此时运行结果为： 三、多态原理动态绑定的实现：&emsp;&emsp;当编译器发现我们的类中有虚函数时，编译器会创建一张虚函数表，把虚函数的函数入口地址放到虚函数表中，并且在类中秘密增加一个指针，这个指针就是vfptr，即virtual function pointer，这个指针是指向对象的虚函数表。在多态调用对的时候，根据vfptr指针，找到虚函数表来实现动态绑定。 &emsp;子类Cat写父类的虚函数speak，这中写法为重写。重写要求返回值、参数个数、类型、顺序都相同。 &emsp;当父类中有虚函数后，父类的内部结构就发生了变化。借助开发人员命令提示符为我们可以看到类的内部结构。 改变前的情况下图所示： 改变后的情况如下图所示： 我们可以看到，父类的内部结构发生了明显的变化，内部多了一个vfptr，且其大小也发生了变化。所谓vfptr即virtual function pointer，虚函数表指针，指向虚函数表。 而子类会继承父类的vfptr table，在构造函数中，子类会将虚函数表指针，指向自己的虚函数表。当发生重写时，会替换掉虚函数表中原有的speak，改为&amp;Cat::speak 子类Cat的内部结构如下： 四、抽象基类和纯虚函数&emsp;&emsp;在设计时，常常希望基类仅仅作为其派生类的一个接口。这就是说，仅想对基类进行向上类型转换，使用它的接口，而不希望用户实际地创建一个基类的对象。同时创建一个纯虚函数允许接口中放置成员函数，而不一定要提供一段可能对这个函数毫无意义的代码。 &emsp;&emsp;做到这一点，可以在基类中加入至少一个纯虚函数（pure virtual function)，使得基类称为抽象类(abstract class)。 纯虚函数使用关键字virtual，并在其后面加上=0。如果试图去实例化一个抽象类，编译器会阻止这种操作。 当继承一个抽象类时，必须实现所有的纯虚函数，否则由抽象类派生的类也是一个抽象类。 virtual void func()=0;告诉把编译器在vtable中为函数保留一个位置，但在在这个特定位置不放地址。 创建公共接口的目的是：为了将子类的公共操作抽象出来，可以通过一个公共接口来操纵一组类，且这个公共交界口不需要事先（或者不要完全实现）。可以创建一个公共类。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354class Animal&#123;public: virtual void speak() = 0; virtual void eat() = 0;&#125;;class Cat :public Animal&#123;public: void speak() &#123; cout &lt;&lt; "喵喵喵" &lt;&lt; endl; &#125; void eat() &#123; cout &lt;&lt; "猫在吃饭" &lt;&lt; endl; &#125;&#125;;class Dog :public Animal&#123;public: void speak() &#123; cout &lt;&lt; "汪汪汪" &lt;&lt; endl; &#125; void eat() &#123; cout &lt;&lt; "狗在吃饭" &lt;&lt; endl; &#125;&#125;;void doEat(Animal&amp; animal)&#123; animal.eat();&#125;void doSpeak(Animal&amp; animal)&#123; animal.speak();&#125;void test02()&#123; Cat cat; Dog dog; doSpeak(cat); doEat(cat); doSpeak(dog); doEat(dog);&#125; 执行结果： 多态成立的条件： 有继承 子类重写父类虚函数 返回值、函数名、函数参数必须与父类完全一致 子类中virtual关键字可不写 类型兼容，父类指针或父类引用指向子类对象 五、虚析构和纯虚析构函数 虚析构函数普通的析构函数不会调用子类的析构函数，这可能会导致释放不干净。可以利用虚析构来解决这个问题。 虚析构函数时为了解决基类的指针指向派生类对象，并用基类的指针删除派生类对象。 1234567891011121314151617181920212223242526272829303132333435363738394041class People&#123;public: People() &#123; cout &lt;&lt; "People的构造函数" &lt;&lt; endl; &#125; virtual void showName() = 0; virtual ~People() &#123; cout &lt;&lt; "People的虚析构函数" &lt;&lt; endl; &#125;&#125;;class Worker :public People&#123;public: Worker() &#123; cout &lt;&lt; "Worker的构造函数" &lt;&lt; endl; name = new char[10]; &#125; virtual void showName() &#123; cout &lt;&lt; "打印子类的名字" &lt;&lt; endl; &#125; ~Worker() &#123; cout &lt;&lt; "Worker的析构函数" &lt;&lt; endl; if (name != NULL) delete name; &#125;private: char* name;&#125;;void test03()&#123; People* people = new Worker; people-&gt;~People();&#125; 执行结果: 纯虚析构函数纯虚析构函数在C++是合法的，但是在使用的时候有一个额外的限制：必须为纯虚析构函数提供一个函数体。 那么问题是：如果给虚析构函数提供了函数体，那怎么还能称为纯虚析构函数呢？纯虚析构函数与非纯虚析构函数之间唯一的不同之处在于纯虚析构函数使得基类是抽象类，不能创建基类的对象。 纯虚析构函数需要声明和实现，在类内声明，类外实现。如果函数中出现了纯虚析构函数，那么这个类是抽象类，不可以实例化对象。 六、纯虚函数和多继承&emsp;&emsp;多继承带来了一些争议，但是接口继承可以说是一种毫无争议的运用。 &emsp;&emsp;绝大多数面向对象语言都不支持多继承，但是绝大多数面向对象语言都支持接口的概念，C++没有接口的概念，但是可以通过纯虚函数实现接口 接口类中只有函数原型定义，没有任何数据定义 &emsp;&emsp;多重继承接口不会带来二义性和复杂性问题。接口类知识一个功能声明，并不是功能实现，子类需要根据功能说明定义功能实现。 除了析构函数外，其他声明都是纯虚函数。 123456789101112131415161718192021222324252627282930313233343536373839404142class Animal&#123;public: virtual void speak() &#123; cout &lt;&lt; "动物说话" &lt;&lt; endl; &#125; virtual ~Animal() = 0;&#125;;Animal::~Animal()//纯虚析构函数的实现&#123; cout &lt;&lt; "Animal的纯虚析构函数调用" &lt;&lt; endl;&#125;class Cat :public Animal&#123;public: Cat(const string name) &#123; m_Name = name; &#125; virtual void speak() &#123; cout &lt;&lt; "小猫"&lt;&lt;m_Name&lt;&lt;"在说话" &lt;&lt; endl; &#125; ~Cat() &#123; cout &lt;&lt; "Cat的析构函数调用" &lt;&lt; endl; &#125;private: string m_Name;&#125;;void test04()&#123; //Animal animal;//抽象基类不可实例化 string name = "Mimi"; Cat cat(name); cat.speak();&#125; 执行结果： 七、向上类型转换和向下类型转换基类转派生类，即向下类型转换，是不安全的。 派生类转基类，即向上类型转换，是安全的。 如果发生了多态，就总是安全的。 向下类型转换的可访问性：&emsp;&emsp;派生类向基类的转换是否可以访问由使用该转换的代码决定，同时，派生类的派生访问说明符也会有影响。假定D继承自B： 只有当D公有继承B时，用户代码才能使用派生类向基类的转换；如果D继承B的方式是受保护的或者私有的，则用户代码不能使用该转换。 不论D以什么方式继承B，D的成员函数和友元都能使用派生类向基类的转换；派生类向其直接基类的转换对于派生类的成员和友元来说是永远可访问的。 如果D继承B的方式是公有的，或受保护的，则D的派生类成员可以使用D向B的类型转换，反之，如果D继承B对的方式是私有的，那么不能使用。 八、指向类成员的指针 指向成员变量的指针定义格式 &lt;数据类型&gt;&lt;类名&gt;::*&lt;指针名&gt; 例如：int A::*pPram; 赋值/初始化 &lt;数据类型&gt;&lt;类名&gt;::*&lt;指针名&gt;=&amp;&lt;类名&gt;::&lt;非静态数据成员&gt; 例如：int A::*pParam=&amp;A::param 解引用 &lt;类对象名&gt;.*&lt;非静态数据成员指针&gt; &lt;类对象指针&gt;-&gt;*&lt;非静态数据成员指针&gt; 例如： A a; a.*pParam; a-&gt;*pParam 123456789101112131415161718192021class A&#123;public: A(int param) &#123; mParam = param; &#125; int mParam;&#125;;void test05()&#123; A a1(10); A* a2 = new A(200); int* p1 = &amp;a1.mParam; int A::* p2 = &amp;A::mParam; cout &lt;&lt; "*p1:" &lt;&lt; *p1 &lt;&lt; endl; cout &lt;&lt; "a1.p2:" &lt;&lt; a1.*p2 &lt;&lt; endl; cout &lt;&lt; "a2-&gt;*p2:" &lt;&lt; a2-&gt;*p2 &lt;&lt; endl;&#125; 执行结果： 指向成员函数的指针定义格式化 &lt;返回类型&gt;(&lt;类名&gt;::*&lt;指针名&gt;)(&lt;参数列表&gt;) 例如： void(A::*pFunc)(int,int); 赋值/初始化 &lt;返回类型&gt;(&lt;类名&gt;::*&lt;指针名&gt;)(&lt;参数列表&gt;)=&amp;&lt;类名&gt;::&lt;非静态数据函数&gt; 例如： void(A::pFunc(int,int)=&amp;A::func; 解引用 (&lt;类对象名&gt;.*&lt;非静态成员函数&gt;)(&lt;参数列表&gt;) (&lt;类对象指针&gt;-&gt;*&lt;非静态成员函数&gt;)(&lt;参数列表&gt;) 例如： A a; (a.*pFunc)(10,20); (a-&gt;*pFunc)(10,20); 12345678910111213141516171819202122232425262728class A&#123;public: A() &#123; mParam = 10; &#125; A(int param) &#123; mParam = param; &#125; int func(int a, int b) &#123; return a + b; &#125; int mParam;&#125;;void test06()&#123; A a1; A* a2 = new A; //初始化成员函数指针 int(A:: * pFunc)(int, int) = &amp;A::func; //指针解引用 cout &lt;&lt; "(a1.*pFunc(10,20)=" &lt;&lt; (a1.*pFunc)(10, 20) &lt;&lt; endl; cout &lt;&lt; "(a2-&gt;*pFunc(10,20)=" &lt;&lt; (a2-&gt;*pFunc)(10, 20) &lt;&lt; endl;&#125; 执行结果： 指向静态成员的指针 指向静态数据成员的指针 指向静态数据成员的指针的定义和使用与普通指针相同，在定义时无须和类向关联，在使用时也无须和具体的对象相关联。 指向类静态成员函数的指针 指向静态成员函数的指针和普通指针相同，在定义时无须和类相关联，在使用时也无须和具体的对象相关联。 1234567891011121314151617181920212223242526272829303132class A&#123;public: A() &#123; mParam = 10; &#125; A(int param) &#123; mParam = param; &#125; int func(int a, int b) &#123; return a + b; &#125; static void dis() &#123; cout &lt;&lt; data &lt;&lt; endl; &#125; static int data; int mParam;&#125;;int A::data = 555;void test07()&#123; int* p = &amp;A::data; cout &lt;&lt; *p &lt;&lt; endl; void(*pfunc)() = &amp;A::dis; pfunc();&#125; 执行结果： 九、源码地址​ 多态源码示例]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>多态</tag>
        <tag>虚函数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[树的实现]]></title>
    <url>%2F2019%2F07%2F30%2F%E6%A0%91%E7%9A%84%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[一、树结点类&emsp;这里我们使用使用孩子兄弟结点表示法表示树的每个结点，每个结点包括三个域：数据域、第一个孩子结点指针域和下一个兄弟结点指针域。 1234567891011121314151617181920212223242526#pragma oncetemplate&lt;class T&gt;class Tree;template&lt;class T&gt;class TreeNode&#123; friend class Tree&lt;T&gt;;public: T data;//数据域 //构造函数 TreeNode(T value, TreeNode&lt;T&gt;* fc = nullptr, TreeNode&lt;T&gt;* ns = nullptr) :data(value), firstChild(fc), nextSibling(ns) &#123;&#125; //访问指针域的成员函数 TreeNode&lt;T&gt;*&amp; FirstChild() &#123; return firstChild; &#125; TreeNode&lt;T&gt;*&amp; NextSibling() &#123; return nextSibling; &#125;private: TreeNode&lt;T&gt;* firstChild;//第一个孩子结点指针域 TreeNode&lt;T&gt;* nextSibling;//下一个兄弟结点指针域&#125;; 二、树类&emsp;树类的数据成员有根结点和当前结点指针。树类设计为树结点类的友元，树类成员函数可直接操作树结点内的私有数据成员，所以这里树类的成员函数是直接对树结点类的私有数据成员firstChild和nextSibling进行操作的。对于外部应用，可通过成员函数FirstChild()和NextSilibing()取得树结点类的私有数据成员firstChild和nextSibling的值和修改它们的值。 123456789101112131415161718192021222324252627282930313233#pragma once#include"treeNode.h"using namespace std;template&lt;class T&gt; class Tree&#123;public: Tree() &#123; root = current = nullptr; &#125;//构造函数 ~Tree() &#123; DeleteSubTree(root); &#125;//析构函数 //第一类操作的成员函数 int Root();//使根结点为当前结点 int Parent();//使当前结点的双亲结点为当前结点 int FirstChild();//使当前结点的第一个孩子结点为当前结点 int NextSilibing();//使当前结点的兄弟结点为当前结点 //第二类操作的成员函数 void Insert(T value);//把value插入到当前结点的最后一个结点 void DeleteSubTree(TreeNode&lt;T&gt;*&amp; t);//删除以t为根结点的子树 void DeleteChile(int i);//删除当前结点的第i个孩子结点 //第三类操作的成员函数 void DisplayTree();//按先根遍历次序显示树的数据域值private: TreeNode&lt;T&gt;* root;//根结点指针 TreeNode&lt;T&gt;* current;//当前结点指针 //私有成员函数 void PreOrderTree(TreeNode&lt;T&gt;*&amp; t);//显示以t为根节点的树的数据域，先根遍历 void PosOrderTree(TreeNode&lt;T&gt;*&amp; t);//后根遍历 int Current(TreeNode&lt;T&gt;*&amp; t);//使当前节点为t所指结点 //在树root中回溯查找结点s的双亲结点 TreeNode&lt;T&gt;* SearchParent(TreeNode&lt;T&gt;*&amp; root, TreeNode&lt;T&gt;*&amp; s);&#125;; 三、树类成员函数的实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190template&lt;class T&gt;inline int Tree&lt;T&gt;::Root()&#123; if (root == nullptr) &#123; current = nullptr; return 0; &#125; return Current(root);&#125;template&lt;class T&gt;inline int Tree&lt;T&gt;::Parent()&#123; if (root == nullptr) &#123; current = root; return 0; &#125; TreeNode&lt;T&gt;* p = SearchParent(root, current); if (p == nullptr) return 0; else return Current(p);&#125;template&lt;class T&gt;inline int Tree&lt;T&gt;::FirstChild()&#123; if (current != nullptr &amp;&amp; current-&gt;firstChild != nullptr) &#123; return Current(current-&gt;firstChild); &#125; else return 0;&#125;template&lt;class T&gt;inline int Tree&lt;T&gt;::NextSilibing()&#123; if (current != nullptr &amp;&amp; current-&gt;nextSibling != nullptr) &#123; return Current(current-&gt;nextSibling); &#125; else &#123; return 0; &#125;&#125;template&lt;class T&gt;inline void Tree&lt;T&gt;::Insert(T value)&#123; //把value插入到当前结点的最后一个结点 /* 分为三种情况 1. 空树 2. 当前结点无孩子结点 3. 当前结点已有孩子结点 */ TreeNode&lt;T&gt;* newNode = new TreeNode&lt;T&gt;(value); if (root == nullptr) &#123; root = current = newNode; return; &#125; if (current-&gt;firstChild == nullptr)//当前结点无孩子结点 &#123; current-&gt;firstChild = newNode; &#125; else &#123; TreeNode&lt;T&gt;* p = current-&gt;firstChild; while (p-&gt;nextSibling != nullptr) &#123; p = p-&gt;nextSibling; &#125; p-&gt;nextSibling = newNode; &#125; Current(newNode);//使当前结点为新节点&#125;template&lt;class T&gt;inline void Tree&lt;T&gt;::DeleteSubTree(TreeNode&lt;T&gt;*&amp; t)&#123; if (t == nullptr) return; TreeNode&lt;T&gt;* q = t-&gt;firstChild, * p; while (q != nullptr) &#123; p = q-&gt;nextSibling; DeleteSubTree(q); q = p; &#125; delete t;&#125;template&lt;class T&gt;inline void Tree&lt;T&gt;::DeleteChile(int i)&#123; TreeNode&lt;T&gt;* r = nullptr; if (i == 1)//当删除当前结点的第一棵子树 &#123; r = current-&gt;firstChild; if (r == nullptr) return; current-&gt;firstChild = r-&gt;nextSibling;//脱链要删除的子树 &#125; else &#123; int k = 1; TreeNode&lt;T&gt;* p = current-&gt;firstChild; while (p != nullptr &amp;&amp; k &lt;= i - 1) &#123;//寻找指向要删除子树的指针 p = p-&gt;nextSibling; k++; &#125; if (p != nullptr) &#123; r = p-&gt;nextSibling; if (r != nullptr) &#123; p-&gt;nextSibling = r-&gt;nextSibling;//脱链要删除的子树 &#125; else return;//要删除的子树为空时返回 &#125; else return;//查找失败 &#125; DeleteSubTree(r);//删除找到的要删除的子树 return;//删除成功&#125;template&lt;class T&gt;inline void Tree&lt;T&gt;::DisplayTree()&#123; PreOrderTree(root);&#125;template&lt;class T&gt;inline void Tree&lt;T&gt;::PreOrderTree(TreeNode&lt;T&gt;*&amp; t)&#123; if (t == nullptr) return; cout &lt;&lt; t-&gt;data &lt;&lt; " ";//显示根节点数据 if (t-&gt;firstChild != nullptr) PreOrderTree(t-&gt;firstChild); if (t-&gt;nextSibling != NULL) PreOrderTree(t-&gt;nextSibling);&#125;template&lt;class T&gt;inline void Tree&lt;T&gt;::PosOrderTree(TreeNode&lt;T&gt;*&amp; t)&#123; if (t == nullptr) return; if (t-&gt;firstChild != nullptr) PosOrderTree(t-&gt;firstChild); cout &lt;&lt; t-&gt;data &lt;&lt; " ";//显示根节点 if (t-&gt;nextSibling != nullptr) PosOrderTree(t-&gt;nextSibling);&#125;template&lt;class T&gt;inline int Tree&lt;T&gt;::Current(TreeNode&lt;T&gt;*&amp; t)&#123; if (t == nullptr) return 0; current = t; return 1;&#125;template&lt;class T&gt;inline TreeNode&lt;T&gt;* Tree&lt;T&gt;::SearchParent(TreeNode&lt;T&gt;*&amp; root, TreeNode&lt;T&gt;*&amp; s)&#123; //在树root中回溯查找结点s的双亲结点 //查找到时使current指向s结点的双亲结点 if (current == nullptr) return nullptr; if (root-&gt;firstChild == s || root-&gt;nextSibling == s) return root; TreeNode&lt;T&gt;* p; if ((p = SearchParent(root-&gt;firstChild, s)) != nullptr) return p; if ((p = SearchParent(root-&gt;nextSibling, s)) != nullptr) return p; return nullptr;&#125; 四、源码地址 ​ 树的实现源码]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>树的实现</tag>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二叉树]]></title>
    <url>%2F2019%2F07%2F30%2F%E4%BA%8C%E5%8F%89%E6%A0%91%2F</url>
    <content type="text"><![CDATA[一、二叉树的定义&emsp;二叉树（Binary Tree）是n（n&gt;=0)个有限结点构成的集合。n=0的树称为空二叉树；n&gt;0的二叉树由一个根节点和两个互不相交、分别称作左子树和右子树的子二叉树构成。 &emsp;二叉树是一种有序树。二叉树中某个结点即使只有一个子树，也要区分是左子树还是右子树。 &emsp;二叉树中所有结点的形态共有5种：空结点、无左右子树结点、只有左子树结点、只有右子树结点和左右子树均存在的结点。 &emsp;满二叉树。在一棵二叉树中，如果所有分支结点都存在左子树和右子树，并且所有叶子结点在同一层上，这样的二叉树称为满二叉树。 &emsp;完全二叉树。如果一棵具有n个结点的二叉树的结构与满二叉树的前n个结点的结构相同，这样的二叉树称为完全二叉树。 二、二叉树的性质 性质1：若规定根结点的层次为0，则一棵非空二叉树的第i层上最多有$2^i$(i&gt;=0)个结点。 性质2：若规定空树的深度为-1，则深度为k的二叉树的最大结点数是$2^{k+1}-1$(k&gt;=-1)个。 性质3：对于一棵非空的二叉树，如果叶节点的个数为$n_0$，度为2的结点数为$n_2$,则有$n_0=n_2+1$. 性质4：对于具有n个结点的完全二叉树，如果按照从上至下和从左至右的顺序对所有结点从0开始顺序编号，则对于任意的序号为i的结点，有： 如果i&gt;0,则序号为i结点的双亲结点的序号为（i-1)/2，如果i=0，则序号为i的结点为根结点，无双亲结点。 如果2i+1=n,则序号为i结点无左孩子。 如果2i+2=n,则序号为i的结点无右孩子。 三、二叉树的操作&emsp;二叉树是由一个根结点和两个互不相交的、分别称为左子树和右子树的子二叉树构成。因此，二叉树的操作和树的操作多数及基本类同，只在子树操作上略有不同。 &emsp;二叉树的操作也分为三类：第一类，找满足某种特定关系的结点；第二类，插入或删除某个结点；第三类，遍历树中每个结点。 第一类操作 寻找根结点使之成为当前结点 寻找当前结点的双亲结点使之成为当前结点 寻找当前结点的左孩子结点使之成为当前结点 寻找当前结点的右孩子结点使之成为当前结点 第二类操作 在二叉树的当前结点上插入一个新结点，使新插入的节点称为当前结点的左孩子结点 在二叉树的当前结点上插入一个新结点，使新插入结点成为当前结点的右孩子结点 在二叉树的当前结点插入一个新子树，使新插入子树称为当前结点的左子树 在二叉树的当前结点插入一个新子树，使新插入子树称为当前结点的右子树 删除二叉树的当前结点的左孩子结点 删除二叉树的当前结点的右孩子结点 删除二叉树的当前结点的左子树 删除二叉树的当前结点的右子树 第三类操作 按某种方式遍历一棵二叉树显示二叉树中每个结点的数据域值 按某种方式遍历一棵二叉树寻找数据元素域为某一值的结点 先序遍历（DLR）递归算法 访问根结点 前序遍历根结点的左子树 前序遍历根结点的右子树 中序遍历（LDR）递归算法 中序遍历根结点的左子树 访问根结点 中序遍历根结点的右子树 后序遍历（LRD）递归算法 后序遍历根结点的左子树 后序遍历根结点的右子树 访问根结点 二叉树还有层序遍历。二叉树的层序遍历要求按照从根结点至叶结点、从左子树至右子树的次序访问二叉树的结点。二叉树的层序遍历算法为： 初始化设置一个队列，并把根结点加入队列 当队列非空时，循环下面注明的步骤③到步骤⑤；否则到步骤⑥ 出队列取得一个结点，访问该结点的（步骤③） 若该结点的左子树非空，则将该结点的左子树入队列 若该结点的右子树非空，则将该结点的右子树入队列（步骤⑤） 结束。 四、二叉树的存储结构&emsp;二叉树的存储结构主要有三种：顺序存储结构、链式存储结构和仿真指针存储结构。 二叉树的顺序存储结构 &emsp;对于一般的二叉树，如果按从上至下和从左至右的次序存储在一组从0开始的连续内存单元中，则数据下标之间的关系就不能反映二叉树中结点之间的逻辑关系。此时，可在一般二叉树中增添一些并不存在的空结点使之变成完全二叉树的形态，然后再用二叉树的顺序存储结构存储。 &emsp;完全二叉树使用顺序存储结构存储时，既能节省存储空间，又能使二叉树的操作实现简单。但对于一般二叉树，如果它接近于完全二叉树，需要增加的空结点数目不多时，可采用顺序存储结构存储。但如果需要增加许多空结点时，就不宜采用顺序存储结构存储。最坏的情况是右单只树，一棵深度为k的右单只树只有k个结点，却需分配$2^k$-1个存储单元。 二叉树的链式存储结构 &emsp;二叉树的链式存储结构方式用指针建立二叉树中结点之间的关系。二叉树最常用的链式存储结构是二叉链。二叉链存储结构的每个结点包含三个域：数据域data，左子树指针域leftChild和右子树指针域rightChild。 &emsp;二叉树的二叉链存储结构是一种常用的二叉树存储结构。二叉链存储结构的优点是：结构简单，可以方便地构造任意需要的二叉树，可以方便地实现二叉树操作中的大多数操作。二叉链仓促结构的缺点是查找当前结点的双亲结点操作实现起来比较麻烦。 &emsp;二叉树的另一种常用的存储结构是三叉链。三叉链式在二叉链的基础上再增加一个双亲结点指针域parent。三叉链除基于二叉链的优点外，对于查找当前结点的双亲结点操作实现起来也很容易。相对于二叉链，三叉链的缺点是结构更为复杂，因而每个结点占用的内存单元也更多一些。 二叉树的仿真指针存储结构 &emsp;二叉树的仿真指针存储结构是用数组存储二叉树中的结点，再增加仿真指针域仿真常规指针建立二叉树中结点之间的关系。二叉树的仿真指针存储结构有仿真二叉链存储结构和仿真三叉链存储结构。 &emsp;仿真指针存储结构的最大优点是遍历操作实现非常容易。用for循环或while循环就可实现。仿真指针存储结构的最大缺点是可存储的结点个数受初始化定义的数组元素个数限制。 五、树和二叉树的转换 树转换为二叉树 树中所有相同双亲结点的兄弟结点之间加一条连线 对树中不是双亲结点第一个孩子的结点，只保留它与左兄弟结点之间的连线，删去该结点与双亲结点之间的连线 整理所有保留的和添加的连线，使每个结点的孩子结点连线位于左孩子指针位置，使每个结点的右兄弟结点连线位于右孩子指针位置 二叉树还原为树 若某结点是其双亲结点的左孩子，则把该结点的右孩子、右孩子的右孩子……都与该结点的双亲结点用线连起来 删除原二叉树中所有双亲结点与右孩子结点的连线 整理所有保留的和添加的连线，使每个结点的孩子结点连线顺序位于下方孩子结点位置]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>二叉树</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[树]]></title>
    <url>%2F2019%2F07%2F30%2F%E6%A0%91%2F</url>
    <content type="text"><![CDATA[一、仿真指针&emsp;在链式存储结构中，我们实现数据元素之间的次序关系依靠指针。在使用数据存储数据元素时，我们可在存储数据元素的数组中增加一个或几个数据下标域，这些数据下标域的值表示了该数组中某个数据元素的下标。由于在数据中增加的数据下标域仿真了链式存储结构中的指针域，所以这种存储结构也称为仿真指针。 &emsp;仿真指针也可英语存储如树和二叉树的非线性结构。当仿真指针用于存储树或二叉树时通常需要一个以上的仿真指针域。 二、树的定义树是由n个有限节点构成的集合。n=0的树为空树，对于n&gt;0的树T有： 有一个特殊的节点称为根节点，根节点没有前趋节点 当n&gt;1时，除根节点外其他节点被分成m（m&gt;0）个互不相交的集合T1,T2……,Tm。其中，每一个集合Ti本身又是一棵称为根节点的子树的树。 &emsp;&emsp;显然，树是递归定义的，即在树的定义中用到了树本身，因此，在包含树结构的算法中将会频繁地出现递归。 三、树的常用术语 结点。在树中通常把数据元素和构造数据元素之间的指针合起来称为结点。 结点的度。结点所拥有的子树的个数称为该结点的度。 叶结点。度为0的结点称为叶结点，叶结点也称为终端结点。 分支结点。度不为0的结点会称为分支结点，分支结点也称为非终端结点。显然，一棵树中除了叶结点外的所有节点都是分支结点。 孩子结点。树中一个结点的子树的根节点称为这个节点的孩子结点. 双亲结点。若树中某结点有孩子结点，则该结点就称为它的孩子结点的双亲结点。双亲结点也称为前趋结点。 兄弟结点。具有相同的双亲结点被称为兄弟结点。 祖先结点。从根结点到树中某结点经过的所有分支结点被称为该结点的祖先结点。一个树中根结点是该树中所有其他结点的祖先结点。 子孙结点。某一节点的所有孩子结点，以及这些孩子结点的孩子结点称为该结点的子孙结点。一个树中所有结点都是根结点的子孙结点。 树的度。树中所有结点的度的最大值称为该树的结点。 结点的层次。从根结点到树中某结点所经路径上的分支数称为该结点额层次。通常规定根结点的层次为0，这样其他结点的层次就是它的双亲结点的层次加1. 树的深度。树中所有结点的层次的最大值称为该树的深度。空树的深度规定为0. 无序树。树中任意一个结点的各个子树之间的次序构成无关紧要，即交换树中任意一个结点的各个子树的次序均和原树相同的树称为无序树。树均定义为无序树。 有序树。树中任意一个结点的各个子树都是有次序的树称为有序树。二叉树是一种有序树。 森林。m(m&gt;=0)棵树的集合称为森林。 四、树的基本操作&emsp;&emsp;由于树是非线性结构，节点之间的关系较线性结构复杂得多，所以树的操作也复杂得多。表示一棵树的数据成员一般来说不仅要有树的根节点指针（简称根指针），还应有树的当前操作节点指针（简称当前指针）。当前指针能保证当对树的某个节点操作后，下一次再要对其相邻节点（如该节点的双亲节点或该节点的第一个孩子节点）操作时不至于又从根节点开始查找起。&emsp;&emsp;树的操作主要分为三大类：第一类，寻找满足某种特定关系的节点；第二类，插入或删除某个节点；第三类，遍历树中每个节点。 第一类操作。 寻找根节点使之成为当前节点 寻找当前节点的双亲节点使之成为当前节点 寻找当前节点的第一个孩子节点使之后才能为当前节点 寻找当前节点的下一个兄弟节点使之成为当前节点这一类操作时树的其他两类操作的基础操作，如插入操作就可设计成在当前节点插入一个新节点。 第二类操作 在树的当前节点上插入一个新节点，使新插入节点成为当前节点的第i个孩子节点 删除树的当前节点的第i个孩子节点 在树的当前节点上插入一个新子树，使新插入子树称为当前节点的第i棵子树 删除树的当前节点的第i棵子树 第三类操作 按某种方式遍历一棵树显示树中每个节点的数据域值 按某种方式遍历一棵树寻找数据元素域为某一值的节点 &emsp;&emsp;树的遍历操作是指按照某种方式访问树中的每一个节点且每一个节点只被访问一次。对于线性结构，通过for循环或while循环就可访问其中的每一个数据元素且每一个数据元素只被访问一次。但是对于树这种非线性数据结构，for循环和while循环就无法访问树中的每一个节点且每一个节点只被访问一次。树的遍历操作算法主要有先根遍历和后根遍历两种。下面的先根遍历和后根遍历算法都是递归的。 先根遍历。先根遍历算法为： 访问根节点 按照从左到右的次序先根遍历根节点的每一棵子树 后根遍历。后根遍历算法为： 按照从左导游的次序后根遍历根节点的每一棵子树 访问根节点 &emsp;&emsp;此外，树的遍历算法还有层序遍历。树的层序遍历是要求按照从根节点至叶节点、从第一棵子树到最后一棵子树的次序访问树的节点。 五、树的存储结构计算机中树的存储要求既要存储节点的数据元素，又要存储节点之间的逻辑关系。构造节点之间的逻辑关系的方法可用指针或仿真指针。 1.双亲表示法 &emsp;&emsp;双亲表示法是用仿真指针结构存储树。具体方法是用一组连续的存储单元（数组）存储树中的所有节点，每个节点有两个域，一个域是数据域，一个域是指示其双亲节点在数组中下标序号的仿真指针域。&emsp;&emsp;双亲表示法的仿真指针也可以改为常规的指针域。双亲表示法对于实现前述的树的基本操作中寻找双亲节点和寻找根节点使它们各自成为当前节点操作很方便，但是对于实现寻找第一个孩子节点和循环下一个兄弟节点使它们各自成为当前节点却很不方便。 2.孩子表示法 &emsp;&emsp;由于树中每个节点的子树个数（即节点的度）不同，如果按照各个节点的度设计变长结构，则每个节点的孩子节点指针域个数增加使算法实现非常麻烦。孩子表示法可按树的度（即树中所有节点度的最大值）设计节点的孩子节点指针域的个数。同样，节点的孩子节点指针域可以是仿真指针，也可以是常规指针。 3.双亲孩子表示法 &emsp;&emsp;树的存储结构若把双亲表示法和孩子表示法结合起来可使之兼有这两种存储结构的优点。可有许多种结合双亲表示法和孩子表示法的存储结构方法。一种双亲孩子表示法是在仿真指针双亲表示法的基础上，给数组得到每个节点增加一个指向该节点所有孩子节点链表的常规指针。 4.孩子兄弟表示法 &emsp;&emsp;孩子兄弟表示法是为每个节点设计三个域，一个数据元素域，一个该节点的第一个孩子指针域，一个该节点的下一个兄弟节点指针域。此种孩子兄弟表示法的两个域通常都是常规指针。&emsp;&emsp;由于树的孩子兄弟表示法有两个指针域，并且这两个指针是有序的，所以孩子兄弟表示法是将树转换为二叉树的存储结构。把二叉树转换为二叉树所对应的结构恰好就是这种孩子兄弟表示法结构，所以，孩子兄弟表示法的最大优点是可方便地实现树和二叉树的相互转换。但是，孩子兄弟表示法的缺点也和孩子表示法的缺点一样，就是从当前节点查找双亲节点比较麻烦，需要从树的根节点开始逐个查找。]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[继承]]></title>
    <url>%2F2019%2F07%2F30%2F%E7%BB%A7%E6%89%BF%2F</url>
    <content type="text"><![CDATA[一、继承&emsp;继承是面向对象编程额基本概念之一。继承使我们能在已有类的基础上构造新类。这个新的类拥有或继承已有类的数据成员和成员函数，也可添加新的数据成员和成员函数，对已有的类进行扩充。这个已有的类就称为基类,而这个新类则称为派生类。 &emsp;如果我们需要定义一个个人类和职工类，在不使用继承的情况下，代码重复会比较严重。这时，我们就需要用到继承。 &emsp;下面定义一个基类网页，重复的代码都写到这个网页上。 1234567891011121314151617181920212223242526//基类class BasePage&#123;public: void header() &#123; cout &lt;&lt; "公共头部" &lt;&lt; endl; &#125; void footer() &#123; cout &lt;&lt; "公共底部" &lt;&lt; endl; &#125; void left() &#123; cout &lt;&lt; "公共左侧列表" &lt;&lt; endl; &#125;&#125;;class News :public BasePage//继承BasePage&#123;public: void content() &#123; cout &lt;&lt; "今日新闻" &lt;&lt; endl; &#125;&#125;; 主函数： 12345678910int main()&#123; News news; news.header(); news.left(); news.footer(); news.content(); system("pause"); return EXIT_SUCCESS;&#125; 执行结果： 继承可以减少代码的重复部分，派生类可以继承基类的数据成员和成员函数。 网页中有很多公共部分，导致实现的时候由很多重复的代码。在使用继承之后，基类为公共网页，具体的子类实现把不同的内容，较好地解决了代码的复用。 二、继承方式继承方式主要有： public：公有继承 private：私有继承 protected：保护继承 不管是公有继承、保护继承还是私有继承，基类中的私有属性，都不可以继承下去 在公有继承中，父类的protected属性在子类中是protected属性。父类中的public属性在子类中是public属性 在保护继承中，父类中的protected属性，在子类中是protected属性。父类中的public属性在子类中是protected属性 在私有继承中，父类中的protected属性在子类中是private属性。父类中的public属性在子类中是private属性。 三、继承中的构造和析构顺序123456789101112131415161718192021222324class Base&#123;public: Base() &#123; cout &lt;&lt; "Base默认构造函数调用" &lt;&lt; endl; &#125; ~Base() &#123; cout &lt;&lt; "Base析构函数调用" &lt;&lt; endl; &#125;&#125;;class Son:public Base&#123;public: Son() &#123; cout &lt;&lt; "Son默认构造函数调用" &lt;&lt; endl; &#125; ~Son() &#123; cout &lt;&lt; "Son析构函数调用" &lt;&lt; endl; &#125;&#125;; 12345678//子类会继承父类的成员属性，成员函数//但是子类不会继承父类的构造函数和析构函数//只有父类自己知道如何构造和析构自己的属性，而子类不知道void test02()&#123; Base base; Son son;&#125; 执行结果： 子类在创建对象时，先调用父类的构造函数，然后再调用自身的构造函数 析构顺序与构造顺序相反 子类不会继承父类的构造函数和析构函数 如果父类中没有合适默认构造，那么子类可以利用初始化列表方式显式地调用父类的其他构造函数。 1234567891011121314151617181920212223242526272829303132class Base&#123;public: Base() &#123; cout &lt;&lt; "Base默认构造函数调用" &lt;&lt; endl; &#125; ~Base() &#123; cout &lt;&lt; "Base析构函数调用" &lt;&lt; endl; &#125; Base(int a) &#123; cout &lt;&lt; "有参构造函数调用,参数为：" &lt;&lt; a &lt;&lt; endl; &#125;&#125;;class Son:public Base&#123;public: Son() &#123; cout &lt;&lt; "Son默认构造函数调用" &lt;&lt; endl; &#125; Son(int a) :Base(a) &#123; cout &lt;&lt; "Son初始化列表调用父类带参构造" &lt;&lt; a &lt;&lt; endl; &#125; ~Son() &#123; cout &lt;&lt; "Son析构函数调用" &lt;&lt; endl; &#125;&#125;; 123456789//子类会继承父类的成员属性，成员函数//但是子类不会继承父类的构造函数和析构函数//只有父类自己知道如何构造和析构自己的属性，而子类不知道void test02()&#123; Base base; Son son; Son son2(15);&#125; 执行结果： 四、继承中同名函数的处理 如果子类和父类拥有同名的函数、属性，子类不会覆盖父类的成员 如果子类与父类的成员函数名称相同，子类会把父类的所有同名版本都隐藏掉 如果想调用父类的方法，必须加作用域 成员属性直接调用是子类的，如果想调用父类的成员属性，需要加作用域 成员函数直接调用先调用子类的，父类的所有版本都会被隐藏，除非显式地用作用域运算符去调用。 12345678910111213141516171819class Base0&#123;public: Base0() &#123; m_A = 100; &#125; int m_A;&#125;;class Son0:public Base0&#123;public: Son0() &#123; m_A = 20; &#125; int m_A;&#125;; 12345678void test03()&#123; Son0 s1; cout &lt;&lt; "子类中的属性："; cout &lt;&lt; s1.m_A &lt;&lt; endl; cout &lt;&lt; "父类中的属性："; cout &lt;&lt; s1.Base0::m_A &lt;&lt; endl;&#125; 执行结果： 五、继承中的静态成员处理 如果基类定义了一个静态成员，则在整个继承体系中只存在该成员的唯一定义。不论从基类中派生出多少个派生类，对于每个静态成员来说都只存在唯一的实例。 静态成员遵循通用的访问控制规则，如果基类中的成员是private的，则派生类无权访问它。假设某静态成员是可访问的，则我们既能通过基类使用它，也可以通过派生类使用它。 12345678910111213141516171819class Father&#123;public: static int m_A; static void func() &#123; cout &lt;&lt; "Father func()" &lt;&lt; endl; &#125;&#125;;int Father::m_A = 200;class Son1 :public Father&#123;public: static int A; static void func() &#123; cout &lt;&lt; "Son func()" &lt;&lt; endl; &#125;&#125;; 123456789void test04()&#123; cout &lt;&lt; "Father的静态成员值为："; cout &lt;&lt; Father::m_A &lt;&lt; endl; cout &lt;&lt; "Son1继承的静态成员值为："; cout &lt;&lt; Son1::m_A &lt;&lt; endl; Son1::func(); Father::func();&#125; 执行结果： 六、防止继承的发生有时候我们会定义这样一种类，我们不希望其他类继承它，或者不想考虑它是否合适作为一个基类。为了实现这个目的，C++11新标准提供了一种防止继承发生的方法，即在类后跟一个关键字final。 七、菱形继承（钻石继承）的问题&emsp;两个派生类继承同一个基类，而又有某个类同时继承了两个派生类，这种继承被称为菱形继承，或者钻石继承。 这种继承带来的问题： 羊继承了动物的数据和函数，驼继承了动物的数据和函数，羊驼同时继承了羊和驼的数据和函数。当羊驼调用函数或者数据时，就会产生二义性。 羊驼继承自动物的函数和数据继承了两份，其实我们应该清楚，这份数据我们只需要一份就可以了。 解决办法： 采用虚继承的方式来解决。通过虚继承的方式，可以保证羊驼类中只有一份动物类的属性和函数的赋值，因此可以避免菱形继承的二义性，也就解决了“钻石继承”的问题。 123456789101112131415161718192021//动物类class Animal&#123;public: int m_Age;&#125;;//羊类class Sheep :virtual public Animal&#123; &#125;;//驼类class Tuo :virtual public Animal&#123;&#125;;//羊驼类class SheepTuo :public Tuo, public Sheep&#123;&#125;; 1234567891011121314void test06()&#123; SheepTuo st; st.Sheep::m_Age = 10; st.Tuo::m_Age = 20; st.m_Age = 5; cout &lt;&lt; "驼的年龄为"; cout &lt;&lt; st.Tuo::m_Age &lt;&lt; endl; cout &lt;&lt; "羊的年龄为："; cout &lt;&lt; st.Sheep::m_Age &lt;&lt; endl; cout &lt;&lt; "羊驼的年龄为："; //可以直接访问，没有二义性的可能，只有一份数据 cout &lt;&lt; st.m_Age &lt;&lt; endl;&#125; 执行结果： 八、源码地址​ 继承源码示例]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>继承</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[stack和queue]]></title>
    <url>%2F2019%2F07%2F29%2Fstack%E5%92%8Cqueue%2F</url>
    <content type="text"><![CDATA[stack 一、stack概述 &emsp;stack是一种先进后出（First In Last Out，FILO)的数据结构，它只有一个出口。stack允许新增元素、移除元素、取得最顶端元素。但是除了最顶端外，没有任何其他方法可以存取其他元素，换言之，stack不允许有遍历行为。 二、stack没有迭代器 &emsp;stack所有元素的进出都必须符合“先进后出”的条件，只有stack顶端的元素才有机会被外界取用。stack不提供遍历功能，也不提供迭代器。 三、stack常用API 栈顶top 压栈push 栈顶弹出pop 大小 size 是否empty 示例： 12345678910111213141516171819202122void stest()&#123; stack&lt;int&gt;istack; if (istack.empty()) &#123; cout &lt;&lt; "stack为空!" &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; "stack的大小为：" &lt;&lt; istack.size() &lt;&lt; endl; &#125; for (int i = 0; i &lt; 10; i++) &#123; istack.push(i); &#125; cout &lt;&lt; "stack的大小为：" &lt;&lt; istack.size() &lt;&lt; endl; cout &lt;&lt; "stack的栈顶元素为：" &lt;&lt; istack.top() &lt;&lt; endl; cout &lt;&lt; "弹出栈顶元素后:" &lt;&lt; endl; istack.pop(); cout &lt;&lt; "stack的大小为：" &lt;&lt; istack.size() &lt;&lt; endl; cout &lt;&lt; "stack的栈顶元素为：" &lt;&lt; istack.top() &lt;&lt; endl;&#125; 输出结果： queue 一、queue概述 &emsp;queue是一种先进先出（First In First Out，FIFO）的数据结构。它有两个出口。queue允许新增元素、移除元素、从最低端加入元素、取得最顶端元素。但除了最底端可以加入、最顶端可以取出外，没有任何办法可以存取queue的其他元素。换言之，queue不允许有遍历行为。 二、queue没有迭代器 &emsp;queue所有元素的进出都必须符合“先进先出“的条件，只有queue顶端的元素，才有机会被外界取用。queue不提供遍历功能，也不提供迭代器。 三、queue常用API 先进先出 队头front 队尾back 入队 push 弹出队头 pop 大小 size 为空 empty 示例: 12345678910111213141516void qtest()&#123; queue&lt;int&gt;iqueue; for (int i = 0; i &lt; 10; i++) &#123; iqueue.push(i); &#125; cout &lt;&lt; "队头为：" &lt;&lt; iqueue.front() &lt;&lt; endl; cout &lt;&lt; "队尾为：" &lt;&lt; iqueue.back() &lt;&lt; endl; cout &lt;&lt; "iqueue的大小为：" &lt;&lt; iqueue.size() &lt;&lt; endl; iqueue.pop(); cout &lt;&lt; "弹出队头后：" &lt;&lt; endl; cout &lt;&lt; "队头为：" &lt;&lt; iqueue.front() &lt;&lt; endl; cout &lt;&lt; "队尾为：" &lt;&lt; iqueue.back() &lt;&lt; endl; cout &lt;&lt; "iqueue的大小为：" &lt;&lt; iqueue.size() &lt;&lt; endl;&#125; 输出结果： 四、源码地址 ​ stack and queue示例源码]]></content>
      <categories>
        <category>STL</category>
      </categories>
      <tags>
        <tag>STL</tag>
        <tag>stack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[deque容器]]></title>
    <url>%2F2019%2F07%2F29%2Fdeque%E5%AE%B9%E5%99%A8%2F</url>
    <content type="text"><![CDATA[一、deque概述 &emsp;vector是单向开口的连续线性空间，deque则是一种双向开口的连续线性空间。所谓双向开口，意思是可以在头尾两端分别做元素的插入和删除操作。虽然vector容器也可以在头尾两端插入元素，但是在其头部操作效率奇差，无法被接受。 &emsp;deque容器和vector容器最大的差异在于： deque允许使用常数项时间对头端进行元素的插入和删除 deque没有容量的概念，因为它是动态的以分段连续空间组成的，随时可以增加一段新的空间并链接起来，换句话说，像vector那样“旧空间不足而重新配置一块更大的空间，然后复制元素，再释放旧空间”这样的事情不会在deque发生，也因此，deque没有必要提供所谓的空间保留功能。 虽然deque容器也提供Random Access Iterator，但是它的迭代器并不是普通指针，其复杂度和vector不是一个量级，这当然影响各个运算的层面，除非必要，我们应该尽可能选择vector而不是deque，对deque进行的排序操作，为了最高效率，可将deque先完整复制到一个vector中，将vector排序后，再复制回deque。 二、deque容器的中控器 &emsp;deque是由一段一段定量连续空间构成。一旦有必要在deque的前端或尾端增加新空间，便配置一段定量连续空间，串接在整个deque的头端或尾端，deque的最大任务，便是在这些分段的定量连续空间上，维护其整体连续的假象，并提供随机存取的接口，避开了“重新配置、复制、释放”的轮回，代价则是复杂的迭代器架构。 &emsp;deque为分段连续空间，就必须有中央控制，而为了维持整体连续的假象，数据结构的设计及迭代器前进后退等操作都颇为繁琐。deque的实现代码分量远比vector或list都多得多。 &emsp;采用一块所谓的map（不是STL的map）作为主控。这里所谓的map是一小块连续空间，其中每个元素都是指针，指向另一段（较大的）连续线性空间，称为缓冲区。缓冲区才是deque存储空间主体。 三、deque迭代器 1234T* cur;//此迭代器指向缓冲区中当前的元素T* first;//此迭代器指向缓冲区的头T* last;//此迭代器指向缓冲区的尾map_pointer node;//指向中控器中心 四、deque常用API 1.deque构造函数 1234deque&lt;T&gt; deqT;//默认构造形式deque(beg,end);//构造函数将[beg,end)区间中的元素拷贝给本身deque(n,elem);//构造函数将n个elem拷贝给本身deque(const deque &amp;deq);//拷贝构造函数 示例： 12345678910void test01()&#123; deque&lt;int&gt;deq1(5,10);//构造deq1 deque&lt;int&gt;deq2(deq1);//拷贝构造deq2 displayDeque(deq1);//打印deq1 cout &lt;&lt; endl; displayDeque(deq2); deque&lt;int&gt;deq3(deq2.begin(), deq2.begin() + 3);//区间拷贝方式构造deq3 cout &lt;&lt; endl; displayDeque(deq3); 输出结果： 2.deque赋值操作 1234assign(beg,end);//将[beg,end)区间中的数据拷贝给本身assign(n,elem);//将n个elem拷贝赋值给本身deque&amp; operator=(const deque &amp;deq);//重载等号操作符swap(deq);//将deq与本身的元素互换 示例： 123456789101112131415161718192021222324void test02()&#123; deque&lt;int&gt;deq1(5, 10);//构造deq1 deque&lt;int&gt;deq2(10, 15); deq1.assign(deq2.begin(), deq2.begin() + 3);//将deq2下标为0,1,2的数据拷贝给deq1 cout &lt;&lt; "deq1:"; displayDeque(deq1); cout &lt;&lt; endl; deq1.assign(4, 4); cout &lt;&lt; "deq1:"; displayDeque(deq1); cout &lt;&lt; endl; cout &lt;&lt; "deq2:"; displayDeque(deq2); cout &lt;&lt; endl; deq1.swap(deq2); cout &lt;&lt; "deq1和deq2的数据交换后：" &lt;&lt; endl; cout &lt;&lt; "deq1:"; displayDeque(deq1); cout &lt;&lt; endl; cout &lt;&lt; "deq2:"; displayDeque(deq2); cout &lt;&lt; endl;&#125; 输出结果： 3.deque大小操作 1234deque.size();//返回容器中元素的个数deque.empty();//判断容器是否为空deque.resize(num);//重新指定容器的长度为num，若容器变长，则以默认值填充新位置。如果容器变短，则末尾超出容器长度的元素被删除deque.resize(num,elem);//重新指定容器的长度为num，若容器变长，则以elem值填充新位置，如果容器变短，则末尾超出容器长度的元素被删除 示例： 123456789101112131415161718192021222324252627void test03()&#123; deque&lt;int&gt;deq1(5, 10); cout &lt;&lt; "deq1的长度为：" &lt;&lt; deq1.size() &lt;&lt; endl; if (deq1.empty()) &#123; cout &lt;&lt; "deq1为空!" &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; "deq1非空!长度为：" &lt;&lt; deq1.size() &lt;&lt; endl; displayDeque(deq1); cout &lt;&lt; endl; &#125; deq1.resize(10);//重新指定deq的长度为10, cout &lt;&lt; "指定deq1的长度为10时，其元素为："; displayDeque(deq1); cout &lt;&lt; endl; deq1.resize(15, 100); cout &lt;&lt; "指定deq1的长度为15时，其元素为："; displayDeque(deq1); cout &lt;&lt; endl; deq1.resize(3,100); cout &lt;&lt; "指定deq1的长度为3时，其元素为："; displayDeque(deq1); cout &lt;&lt; endl;&#125; 输出结果： 4.deque双端插入和删除操作 1234push_back(elem);//在容器尾部添加一个数据push_front(elem);//在容器头部插入一个数据pop_back();//删除容器最后一个数据pop_front();//删除容器第一个数据 示例: 1234567891011121314151617181920void test04()&#123; deque&lt;int&gt;deq1(5, 5); cout &lt;&lt; "deq1："; displayDeque(deq1); cout &lt;&lt; endl; deq1.push_back(100); cout &lt;&lt; "deq1.push_back(100)后为："; displayDeque(deq1); cout &lt;&lt; endl; deq1.push_front(15); cout &lt;&lt; "deq1.push_front(15)后为："; displayDeque(deq1); cout &lt;&lt; endl; deq1.pop_back(); deq1.pop_front(); cout &lt;&lt; "deque删头去尾后为："; displayDeque(deq1); cout &lt;&lt; endl;&#125; 输出结果： 5.deque数据存取 1234at(index);//返回索引index所指的数据，如果index越界，抛出out_of_rangeoperator[];//返回索引index所指向的数据，如果index越界，不抛出异常，直接出错front();//返回第一个数据back();//返回最后一个数据 示例： 1234567891011121314void test05()&#123; deque&lt;int&gt; deq1(5, 15); //cout &lt;&lt; "索引为5的元素为：" &lt;&lt; deq1.at(5) &lt;&lt; endl; //上面的输出语句报错，抛出out_of_range cout &lt;&lt; "索引为3的元素为：" &lt;&lt; deq1.at(3) &lt;&lt; endl; deq1.push_front(44); cout &lt;&lt; "索引为0的元素为：" &lt;&lt; deq1.at(0) &lt;&lt; endl; //cout &lt;&lt; deq1[15] &lt;&lt; endl;//越界报错 cout &lt;&lt; "索引为3的元素为：" &lt;&lt; deq1[3] &lt;&lt; endl; cout &lt;&lt; "索引为0的元素为：" &lt;&lt; deq1[0] &lt;&lt; endl; cout &lt;&lt; "deq的首元素为：" &lt;&lt; deq1.front() &lt;&lt; endl; cout &lt;&lt; "deq的尾元素为：" &lt;&lt; deq1.back() &lt;&lt; endl;&#125; 输出结果： 6.deque插入操作 123insert(pos,elem);//在pos位置插入一个elem元素的拷贝，返回新数据的位置insert(pos,n,elem);//在pos位置插入n个elem数据，无返回值insert(pos,beg,end);//在pos位置插入[beg,end)区间的数据，无返回值 示例： 123456789101112131415161718192021222324252627void test06()&#123; deque&lt;int&gt; deq1(5, 15); cout &lt;&lt; "deq1:"; displayDeque(deq1); cout &lt;&lt; endl; deq1.insert(deq1.begin() + 3, 18); cout &lt;&lt; "deq1:"; displayDeque(deq1); cout &lt;&lt; endl; deq1.insert(deq1.begin(),2,20); cout &lt;&lt; "deq1:"; displayDeque(deq1); cout &lt;&lt; endl; deq1.erase(deq1.begin()); cout &lt;&lt; "deq1:"; displayDeque(deq1); cout &lt;&lt; endl; deq1.erase(deq1.begin(), deq1.begin() + 5); cout &lt;&lt; "deq1:"; displayDeque(deq1); cout &lt;&lt; endl; deq1.clear(); cout &lt;&lt; "deq1:"; displayDeque(deq1); cout &lt;&lt; endl;&#125; 输出结果： 7.deque删除操作 123clear();//移除容器的所有数据erase(beg,end);//删除[beg,end)区间的数据，返回下一个数据的位置erase(pos);//删除pos位置的很舒服，返回下一个数据的位置 如上例所示。 五、源码地址 ​ deque容器示例源码]]></content>
      <categories>
        <category>STL</category>
      </categories>
      <tags>
        <tag>STL</tag>
        <tag>deque</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用点对点信道的数据链路层]]></title>
    <url>%2F2019%2F07%2F01%2F%E7%82%B9%E5%AF%B9%E7%82%B9%E4%BF%A1%E9%81%93%E7%9A%84%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%2F</url>
    <content type="text"><![CDATA[一、数据链路层的功能 &emsp;&emsp;数据链路层在物理层提供服务的基础上向网络层提供服务，其主要作用是加强物理层传输原始比特流的功能，将物理层提供的可能出错的物理连接改造为逻辑上无差错的数据链路，使之对网络层表现为一条无差错的链路。 为网络层提供服务 对网络层而言，数据链路层的基本任务是将源机器中来自网络层的数据传输到目标其的网络层。数据链路层通常可为网络层提供如下服务： （1）无确认的无连接服务。员及其发送数据帧时不需先建立链路连接，目的机器收到数据帧时不需发回确认。对丢失的帧，数据链路层不负责重发而交给上层处理。适用于实时通信或误码率较低的通信信道，如以太网 （2）有确认的无连接服务。源机器发送数据帧时不需先建立链路连接，但目的机器收到数据帧时必须发回确认。源机器在所规定的时间内未收到确定信号时，就重传丢失的帧，以提高传输的可靠性。该服务适用于误码率较高的通信信道，如无线通信 （3）有确认的面向连接服务。帧传输过程分为三个阶段：建立数据链路，传输帧，释放数据链路。目的机器对收到的每一帧都要给出确认，源机器收到确认后才能发送下一帧，因而该服务的可靠性最高。该服务适用于通信要求较高的场合 二、使用点对点信道的数据链路层 数据链路和帧 链路，就是从一个结点到相邻结点的一段物理线路，而中间没有任何其他的交换结点。 数据链路，当需要在一条线路上传送数据时，除了必须要有一条物理线路外，还必须要有一些必要的通信协议来控制这些数据的传输。若把实现这些协议的硬件和软件加到链路上，就构成了数据链路。这样的数据链路就不再是简单的物理链路而是个逻辑链路了。现在最常用的方法是使用网络适配器来实现这些协议的硬件和软件。一般的适配器都包括了数据链路层和物理层这两层功能。 帧，数据链路层把网络层交下来的数据构成帧发送到链路上，以及把接收到的帧中的数据报取出并上交给网络层。在因特网中，网络层协议数据单元就是IP数据报 点对点信道的数据链路层在进行通信时的主要步骤： 结点A的数据链路层把网络层交下来的IP数据报添加首部和尾部封装成帧 结点A把封装号的帧发送给结点B的数据链路层 若结点B的数据链路层收到的帧无差错，则从收到的帧中提取出IP数据报上交给上面的网络层，否则就丢弃这个帧 封装成帧 数据链路层以帧为单位传输和处理数据。网络层的IP数据报必须向下传送到数据链路层，成为帧的数据部分，同时它的前面和后面分别添加上首部和尾部，封装成一个完整的帧。帧的长度等于帧的数据部分的长度加上帧首部和帧尾部的长度。 数据链路层的接收方为了能以帧为单位处理接收的数据，必须正确地识别每个帧的开始和结束，即进行帧定界 首部和尾部的作用之一就是进行帧定界，同时也包括其他必要的控制信息。 每一种链路层协议都规定了帧的数据部分长度的上限，即最大传送单元(MTU) PPP协议采用的零比特填充法 在发送端，先扫描整个信息字段。只要发现有5个连续1，则立即填入一个0，经过这种零比特填充后的数据，就可以保证在信息字段中不会出现6个连续1. 接收端在收到一个帧时，先找到帧定界标志“Flag”以确定一个帧的边界，接着再用硬件对其中的比特流进行扫描。每当发现5个连续的1时，就把5个连续1后面的一个0删除，以还原成原来的数据比特流。 这样就保证了透明传输：在所传送的树比特流中可以包含任意组合的比特模式，而不会引起对帧定界的判断错误。 差错检测 现实的通信链路都不会是理想的，比特在传输过程中可能会产生差错：1可能会变为0,0可能会变为1，则就叫做比特差错 传输错误的比特占所传输比特总数的比率称为误码率 为了保证接收到的数据是正确的，在计算机网络传输数据时，必须采用某种差错检测措施。虽然各种差错检测技术的具体方法差别很大，但它们最基本的原理是一样的。 在数据链路层，为了便于硬件检测差错，通常在帧的尾部设置一个差错检验字段存放整个帧的差错检测码，这个差错检验字段常称为帧检验序列（FCS）。因此，要在数据链路层进行差错检验，就必须把数据划分成帧，每一帧都加上差错检验码，一帧接一帧地传送，然后再接收方逐帧进行差错检验。 在数据链路层通常使用循环冗余检验（CRC）技术进行差错检测。 CRC编码额基本原理是，发送方和接收方首先必须协商一个r+1比特的生成式G。算法要求G的最高位和最低位的比特为1,。考虑d比特的数据D，发送方要选择一个合适的r比特冗余码R（即检错码），并将它附加到D上，使得得到的d+r比特模式用模2算术恰好能被G整除。接收方进行差错检测时，用G去除接收到的d+r比特，如果余数非零则检测出差错，否则认为树正确。 模2运算中，加法不进位，减法不错位，等价于按位异或，乘以和除以2等价于左/右移位。 可靠传输 在某些情况下，我们需要数据链路层向上面的网络层提供“可靠传输”的服务。“可靠传输”就是要做到：发送端发送什么，在对应的接收端就收到什么。 为了实现可靠的单向数据传输，可靠传输协议需要进行双向通信，因此底层的不可靠信道必须是双向的。 （1）停止等待协议（SW） 当正确接收到一个分组时，向发送方发送一个确认分组ACK，当接收到的分组出现比特差错时，丢弃该分组并发送一个否认分组NAK。发送方收到ACK则可以发送下一个分组，而收到NAK则要重传原来的分组，直到收到ACK为止。由于发送方每发送完一个分组必须停下来等接收到确认后才能发送下一个分组，该协议被称为停止等待协议（SW） 如果底层的信道会丢失分组，当数据分组或确认分组丢失时，发送方将会一直等待接收方的确认分组。为了解决给问题，可以在发送方发送完一个数据分组时，启动一个超时计数器。若到了超时计数器所设置的重传时间而发送方仍收不到接收方的任何确认分组，则重传原来的分组，这就是超时重传。 当确认分组丢失时，接收方会收到两个同样的数据分组，即重复分组。若接收方不能识别重复分组，则会导致另一种差错——数据重复。为了解决该问题，必须使每个数据分组带上不同的发送序号。每发送一个新的数据分组就把它的发送序号加1.若接收方连续收到发送序号相同的数据分组，就表明出现了重复分组。这时应丢弃重复的分组，此时，接收方还必须向发送方补发一个确认分组ACK。 停止等待协议的优点是简单，但缺点是信道利用率太低。 假设存在发送方A，发送分组需要的时间是$T_D$,接收方B，发送确认分组需要时间$T_A$.如果A处理确认分组的时间可以忽略不计，那么A在经过时间（$T_D$+RTT+$T_A$)后就可以再发送下一个分组，这里的RTT是往返时间。因为仅仅是在时间$T_D$内采用来传送有用的数据，因此，信道的利用率U为：U=$\frac{TD}{TD+RTT+TA}$. 当RTT远大于分组发送时间$T_D$时，信道的利用率就会非常低 当RTT远小于发送时间$T_D$时，信道的利用率较高。 流水线传输方式就是发送方可连续发送多个分组，不必每发完一个分组就停下来等待对方的确认。这样可使得信道上一直有数据不间断地在传送。显然，这种传输方式可以获得很高的信道利用率。 （2）回退N帧协议（GBN） 回退N帧协议在流水线传输的基础上利用发送窗口来限制发送方连续发送分组的个数，是一种连续ARQ协议。 为此，在发送方要维持一个发送窗口。发送窗口时允许发送方已发送但还没有收到的分组序号的范围，窗口大小就是发送方已发送但还没有收到确认的最大分组数。 在协议的工作过程中，发送窗口不断向前滑动，因此，这类协议又称为滑动窗口协议。 GBN采用累积确认的方式。优点是容易实现，即使确认丢失也可能不必重传。但缺点是不能向发送方准确反映出接收方已经正确收到的所有分组的信息。 （3）选择重传协议 GBN协议存在一个缺点：一个分组的差错可能引起大量分组的重传，这些分组可能已经被接收方正确接收了，但由于未按序到达而被抛弃。显然对这些分组的重传是对通信资源的极大浪费。为进一步提高性能，可设法只重传出现差错的分组，但这时接收窗口不再为1，以便先收下失序到达但仍然处在接收窗口中的那些分组，等到所缺分组收齐后再一并送交上层，这就是选择重传（SR）协议。 为了使发送方仅重传出现差错的分组，接收方不能再采用累积确认，而需要对每个正确接收到的分组进行逐一确认。 （4）数据链路层的可靠传输 不可靠的链路加上适当的协议就可以使链路层向上提供可靠传输服务。但付出的代价是数据的传输效率降低了，而且增加了协议的复杂性。因此，应当根据链路的具体情况来决定是否需要让链路层向上提供可靠传输服务。 现在有线网络广泛使用的数据链路层协议一般都不使用确认和重传机制，即不要求数据链路层向上提供可靠传输服务。若数据链路层传输数据偶尔出现了差错，并且需要进行改正，则改正差错的任务就由上层协议来完成。实践证明，这样做可以提高通信效率，降低设备成本。]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>数据链路层</tag>
        <tag>差错检测</tag>
        <tag>可靠传输</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[list容器]]></title>
    <url>%2F2019%2F07%2F01%2Flist%E5%AE%B9%E5%99%A8%2F</url>
    <content type="text"><![CDATA[一、list容器概述 &emsp;&emsp;链表是一种物理存储单元上非连续、非顺序的存储结构，数据元素的逻辑顺序是通过链表中的指针链接次序实现的。链表由一系列结点（链表中每一个元素称为结点）组成，结点可以在运行时动态生成。每个结点包括两部分：一个是存储数据元素的数据域，另一个是存储下一个节点地址的指针域。 &emsp;&emsp;相较于vector的连续线性空间，list就显得复杂许多，它的好处是每次插入或删除一个元素，就配置或释放一个元素空间。因此，list对于空间的运用有绝对的精准，一点也不浪费。而且，对于任何位置的元素插入或移除，list永远都是常数时间。 &emsp;&emsp;list容器是一个双向链表 采用动态存储分配，不会造成内存浪费和溢出 链表执行插入和删除操作十分方便，修改指针即可，不需要移动大量元素 链表灵活，但是空间和时间额外耗费较大 二、list容器的迭代器 &emsp;&emsp;list不再能够像vector一样以普通指针作为迭代器，因为其节点不保证在同一块连续的内存空间上，list迭代器必须有能力指向list结点，并有能力进行正确的递增、递减、取值、成员存储操作。所谓list正确的递增、递减、取值、成员取用是指，递增时指向下一个节点，递减时指向上一个节点，取值时取的是结点的数据值，成员取用时取的是结点成员。 &emsp;&emsp;由于list是一个双向链表，迭代器必须能够具备前移后移的能力，所以list容器提供的是Bidirectional Iterator &emsp;&emsp;list有一个重要的性质，插入操作和删除操作都不会造成原有list迭代器的失效，这在vector中是不成立的，因为vector的插入操作可能会造成记忆体重新配置，导致原有的迭代器全部失效，甚至list元素的删除，也只有被删除的那个元素的迭代器失效，其他迭代器不受任何影响。 三、list的节点 12345678template&lt;class T&gt;struct _list_node&#123; typedef void* void_pointer; void_pointer prve;//型别为void*，其实可设为_list_node&lt;T&gt;* void_pointer next; T data;&#125;; 显然这是一个双向链表。 四、list的元素操作 常用API list lstT;//list采用采用模板类实现,对象的默认构造形式 list(beg,end);//构造函数将[beg, end)区间中的元素拷贝给本身 list(n,elem);//构造函数将n个elem拷贝给本身 list(const list &amp;lst);//拷贝构造函数 push_back(elem);//在容器尾部加入一个元素 pop_back();//删除容器中最后一个元素 push_front(elem);//在容器开头插入一个元素 pop_front();//从容器开头移除第一个元素 insert(pos,elem);//在pos位置插elem元素的拷贝，返回新数据的位置 insert(pos,n,elem);//在pos位置插入n个elem数据，无返回值。 insert(pos,beg,end);//在pos位置插入[beg,end)区间的数据，无返回值。 clear();//移除容器的所有数据 erase(beg,end);//删除[beg,end)区间的数据，返回下一个数据的位置。 erase(pos);//删除pos位置的数据，返回下一个数据的位置。 remove(elem);//删除容器中所有与elem值匹配的元素。 示例如下： 1234567891011121314151617181920212223242526272829303132333435363738394041void test01()&#123; list&lt;int&gt;L1(10, 10); list&lt;int&gt;L2(L1.begin(), L1.end());//使用L1构造L2 DislayList(L1); DislayList(L2); L2.push_back(15);//给L2后面加入一个元素 DislayList(L2); //逆序打印L2 for (list&lt;int&gt;::reverse_iterator it = L2.rbegin(); it != L2.rend(); it++) &#123; cout &lt;&lt; *it &lt;&lt; " "; &#125; cout &lt;&lt; endl; //插入数据 list&lt;int&gt;L3; L3.push_back(15); L3.push_back(20); L3.push_front(10); L3.push_front(5); DislayList(L3);//打印L3中的元素 //删除list两端的元素 L3.pop_front();//头删 L3.pop_back();//尾删 DislayList(L3);//打印L3中的元素 //插入元素 L3.insert(L3.begin(), 333); DislayList(L3); L3.remove(15); DislayList(L3); if (L3.empty()) &#123; cout &lt;&lt; "L3为空" &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; "L3中元素的个数为：" &lt;&lt; L3.size() &lt;&lt; endl; &#125; L3.erase(L3.begin()); DislayList(L3);&#125; 输出结果如下图： 其他操作 resize(num);//重新指定容器的长度为num，若容器变长，则以默认值填充新位置。如果容器变短，则末尾超出容器长度的元素被删除 resize(num, elem);//重新指定容器的长度为num，若容器变长，则以elem值填充新位置。如果容器变短，则末尾超出容器长度的元素被删除 assign(beg, end);//将[beg, end)区间中的数据拷贝赋值给本身 assign(n, elem);//将n个elem拷贝赋值给本身 swap(lst);//将lst与本身的元素互换 reverse();//反转链表 示例如下： 123456789101112131415161718192021222324252627282930void test02()&#123; list&lt;int&gt;L; for (int i = 0; i &lt; 10; i++) &#123; L.push_back(i); &#125; cout &lt;&lt; "初始L为："; DislayList(L); cout &lt;&lt; "指定容器长度为15："; L.resize(15); DislayList(L); L.resize(10); L.resize(15,121212); cout &lt;&lt; "执行操作resize(15,121212)后："; DislayList(L); L.resize(5); cout &lt;&lt; "执行操作resize(5)后："; DislayList(L); list&lt;int&gt;L2; L2.assign(L.begin(), L.end()); cout &lt;&lt; "L2:"; DislayList(L2); cout &lt;&lt; "L2 front:" &lt;&lt; L2.front() &lt;&lt; endl; cout &lt;&lt; "L2 back:" &lt;&lt; L2.back() &lt;&lt; endl; //反转链表 L2.reverse(); cout &lt;&lt; "反转后的L2为："; DislayList(L2);&#125; 输出结果如下图： ==运算符重载 自定义数据类型Person 1234567891011121314151617181920class Person&#123;public: string m_name; int m_age; Person(string name, int age) &#123; this-&gt;m_name = name; this-&gt;m_age = age; &#125; bool operator==(const Person&amp; p)//重载==运算符 &#123; if (this-&gt;m_name == p.m_name &amp;&amp; this-&gt;m_age == p.m_age) &#123; return true; &#125; else return false; &#125;&#125;; 利用重载的==运算符删除其中一个元素 12345678910111213141516171819202122void test03()&#123; list&lt;Person&gt;L; Person p1("Aoki", 23); Person p2("青木", 18); Person p3("张一",20); Person p4("张二", 10); L.push_back(p1); L.push_back(p2); L.push_back(p3); L.push_back(p4); for (list&lt;Person&gt;::iterator it = L.begin(); it != L.end(); it++) &#123; cout &lt;&lt; "姓名：" &lt;&lt; it-&gt;m_name &lt;&lt; "年龄：" &lt;&lt; it-&gt;m_age &lt;&lt; endl; &#125; cout &lt;&lt; "删除张二" &lt;&lt; endl; L.remove(p4); for (list&lt;Person&gt;::iterator it = L.begin(); it != L.end(); it++) &#123; cout &lt;&lt; "姓名：" &lt;&lt; it-&gt;m_name &lt;&lt; "年龄：" &lt;&lt; it-&gt;m_age &lt;&lt; endl; &#125;&#125; 输出结果如下： 自定义规则排序 这里我们借助sort()函数对自定义数据类型进行排序操作。 需要引用一个头文件#include&lt;algorithm&gt; 排序规则： 1234bool ComparePerson(Person&amp; p1, Person&amp; p2)&#123;//自定义排序规则，按年龄从小到大排序 return p1.m_age &lt; p2.m_age;&#125; 根据排序规则对list中的自定义数据类型元素进行排序： 12345678910111213141516171819202122void test04()&#123; list&lt;Person&gt;L; Person p1("Aoki", 23); Person p2("青木", 18); Person p3("张一", 20); Person p4("张二", 10); L.push_back(p1); L.push_back(p2); L.push_back(p3); L.push_back(p4); for (list&lt;Person&gt;::iterator it = L.begin(); it != L.end(); it++) &#123; cout &lt;&lt; "姓名：" &lt;&lt; it-&gt;m_name &lt;&lt; "年龄：" &lt;&lt; it-&gt;m_age &lt;&lt; endl; &#125; L.sort(ComparePerson); cout &lt;&lt; "使用自定义规则排序：" &lt;&lt; endl; for (list&lt;Person&gt;::iterator it = L.begin(); it != L.end(); it++) &#123; cout &lt;&lt; "姓名：" &lt;&lt; it-&gt;m_name &lt;&lt; "年龄：" &lt;&lt; it-&gt;m_age &lt;&lt; endl; &#125;&#125; 输出结果如下： 五、源码地址 list源码示例]]></content>
      <categories>
        <category>STL</category>
      </categories>
      <tags>
        <tag>STL</tag>
        <tag>list</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[交换技术和分组交换的两种方式]]></title>
    <url>%2F2019%2F07%2F01%2F%E4%BA%A4%E6%8D%A2%E6%8A%80%E6%9C%AF%E5%92%8C%E5%88%86%E7%BB%84%E4%BA%A4%E6%8D%A2%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%96%B9%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[一、电路交换 在进行数据传输前，两个结点之间必须建立一条专用（双方独占）的物理通信路径，该路径可能经过许多中间结点。这一路径在整个数据传输期间一直被独占，直到通信结束才被释放。因此，电路交换技术分为三个阶段：连接建立、数据传输、连接释放 从通信资源的分配角度来看，“交换”就是按照某种方式动态地分配传输线路的资源。电路交换的关键点是，在数据传输过程中，用户始终占用端到端的固定传输带宽。 电路交换的优点： 通信时延小。当传输的数据量较大时，这一优点非常明显 有序传输 没有冲突 适用范围广 实用性强 控制简单 电路交换的缺点 建立连接时间长 线路独占 灵活性差 难以规格化 电路建立后，除源结点和目的节点外，电路上的任何结点都采取“直通方式”接收数据和发送数据，即不会存在存储转发所耗费的时间。 二、报文交换 数据交换的单位是报文，报文携带有目标地址、源地址等信息。报文交换在交换结点采用的是存储转发的传输方式 报文交换的优点 无须建立连接 动态分配线路 提高线路可靠性 提高线路利用率 提供多目标服务 报文交换的缺点 由于数据进入交换结点后要经历存储、转发这一过程，因此会引起转发时延 报文交换对报文的大小没有限制，这就要求网络结点需要有较大的缓存空间 三、分组交换 采用存储转发方式，但解决了报文交换中大报文传输的问题。 分组交换限制了每次传送的数据块大小的上限，把大的数据块划分为合理的小的数据块，再加上一些必要的控制信息，构成分组。网络结点根据控制信息把分组送到下一结点，下一结点接收到分组后，暂时保存并排队等待传输，然后根据分组控制信息选择它的下一结点，直到到达目的结点。 分组交换的优点 无建立时延 线路利用率高 简化了存储管理 加速传输 减少了出错概率和重发数据量 分组交换的缺点 存在传输时延 需要传输额外的信息 当分组交换采用数据报服务时，可能会出现失序、丢失或重复分组，分组到达目的结点时，要对分组按编号进行排序等工作，因此很麻烦。若采用虚电路服务，虽无失序问题，但有呼叫建立、数据传输和虚电路释放三个过程。 四、电路交换、分组交换和分组交换 要传送的数据量很大且其传送时间远大于呼叫时间时，采用电路交换较为合适 端到端的通路由多段链路组成时，采用分组交换传送数据较为合适 从提高整个网络的信道利用率上看，报文交换和分组交换优于电路交换，其中分组交换比报文交换的时延小，尤其适合于计算机之间的突发式数据通信。 五、数据报与虚电路 分组交换根据其通信子网向端点系统提供的服务，还可以进一步分为面向连接的虚电路方式和无连接的数据报方式。这两种服务方式都由网络层提供。数据报方式和虚电路方式是分组交换的两种方式。 数据报 作为通信子网用户的端系统发送一个报文时，在端系统中实现的高层协议先把报文拆成若干带有序号的数据单元，并在网络层加上地址等控制信息后形成数据办分组。中间节点存储分组很短一段时间，找到最佳路由后，尽快转发每个分组。不同的分组可以走不同的路径，也可以按不同的顺序到达目的结点。 数据报服务的特点 发送分组前不需要建立连接，发送方可随时发送分组，网络中的结点可随时接收分组 网络尽最大努力交付，传输不保证可靠性，所以可能丢失；为每个分组独立地选择路由，转发的路径可能不同，因而分组不一定按序到达目的结点 发送的分组中要包括发送端和接收端的完整地址，以便可以独立传输 分组在交换结点存储转发时，需要排队等候处理，这会带来一定的时延。通过交换结点的通信量较大或网络发生拥塞时，这种时延会大大增加，交换结点还可根据情况丢弃部分分组 网络具有冗余路径，当某一交换结点或一段链路出现故障时，可相应地更新转发表，寻找另一条路径转发分组，对故障的适应能力强 存储转发的时延一般较小，提高了网络的吞吐量 收发双方不独占某一链路，资源利用率高 虚电路 虚电路方式试图将数据报方式与电路交换方式结合起来，充分发挥两种方法的优点，以达到最佳的数据交换效果。在分组发送之前，要求在发送方和接收方建立一条逻辑上相连的虚电路，并且连接一旦建立，就固定了虚电路所对应的物理路径。与电路交换类似，整个通信过程分为三个阶段：虚电路建立、数据传输与虚电路释放 在虚电路方式中，端系统每次建立虚电路时，选择一个未用过的虚电路号分配给该虚电路以区别于本系统中的ITA虚电路。在传送数据时，每个数据分组不仅要有分组号、校验和等控制信息，还要有它通过的虚电路号，以区别于其他虚电路上的分组。在虚电路网路中的每个结点上都维持一张虚电路表，表中的每项记录了一个打开的虚电路信息，包括在接收链路和发送链路上的虚电路号、前一结点和下一结点的标识。数据传输时双向进行的，上述信息是在建立过程中确定的。 虚电路服务的特点 虚电路通信链路的建立和拆除需要时间开销，对交互式应用和小量的短分组情况显得很浪费，但对长时间、频繁的数据交换效率较高 虚电路的路由选择体现在连接建立阶段，连接建立后，就确定了传输路径 虚电路提供了可靠的通信功能，能保证每个分组正确且有序到达。此外还可以对两个数据端点的流量进行控制，当接收方来不及接收数据时，可以通知发送方暂缓发送 虚电路有一个致命的弱点，即当网络中的某个结点或某条链路出现故障而彻底失效时，所有经过该结点或该链路的虚电路将遭到破坏 分组首部不含目的地址，而包含虚电路标识符，相对数据报方式开销小 虚电路之所以是“虚”的，是因为这条电路不是专用的，每个节点到其他节点之间的链路可能同时有若干虚电路通过，也可能同时与多个结点之间建立虚电路。每天虚电路支持特定的两个端系统之间的数据传输，两个端系统之间也可以有多条虚电路为不同的进程服务，这些虚电路的实际路由可能相同也可能不同。 数据报服务和虚电路服务的比较 数据报服务 虚电路服务 连接的建立 不需要 必须有 目的地址 每个分组都有完整的目的地址 仅在建立连接阶段使用，之后每个分组使用长度较短的虚电路号 路由选择 每个分组独立地进行路由选择和转发 属于同一条虚电路的分组按照同一路由转发 分组顺序 不保证分组的有序到达 保证分组的有序到达 可靠性 不保证可靠通信，可靠性由用户主机来保证 可靠性由网络保证 对网络故障的适应性 出故障的结点丢失分组，其他分组路径选择发生变化时可以正常传输 所有经过故障结点的虚电路均不能正常工作 差错处理和流量控制 由用户主机进行流量控制，不保证数据报的可靠性 可由分组交换网负责，也可由用户主机负责]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>电路交换</tag>
        <tag>报文交换</tag>
        <tag>分组交换</tag>
        <tag>虚电路</tag>
        <tag>数据报</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vector容器]]></title>
    <url>%2F2019%2F06%2F30%2Fvector%E5%AE%B9%E5%99%A8%2F</url>
    <content type="text"><![CDATA[一、序列式容器 所谓序列式容器，其中的元素都是可序的，但未必有序。C++本身体用了一个序列式容器array，STL另外提供了vector,list,deque,stack.priority-queue等序列式容器。 二、vector vector与array的区别 vector的数据安排以及操作方式，与array非常相似，两者的唯一差别在于空间运用的灵活性。 array是静态空间，一旦配置了就不能改变，要更换大一些的空间，就必须执行如下操作： 配置一块新空间 将元素从旧地址一一搬往新地址 把原来的空间释放还给系统 vector是动态空间，随着元素的加入，它的内部机制会自行扩充空间以容纳新元素 vector空间配置 为了降低空间配置时的速度成本，vector实际配置的大小比客户端需求大一些，以备将来可能的扩充。这便是容量（capacity）的概念。换句话说，一个vector的容量永远大于或等于其大小。一旦容量等于大小，便是满载，下次再有新增元素，整个vector就得另觅居所。 所谓动态增加大小，并不是在原空间之后续接新空间，而是一块更大的内存空间，然后将元数据拷贝到新空间，并释放原空间，因此，对vector的任何操作，一旦引起空间的重新配置，指向原vector额度所有迭代器就都失效了。 vector的数据结构 vector所采用的数据结构非常简单：线性连续空间。它以两个迭代器start和finish分别指向配置得来的连续空间中已经使用的范围，并以迭代器end_of_storage指向整块连续空间（含备用空间）的尾端。 123456789template&lt;class T, class Alloc = alloc&gt;class vector &#123; ……protected: iterator start; //表示目前使用空间的头 iterator finish; //表示目前使用空间的尾 iterator end_of_storage; //表示目前可用空间的尾&#125;; push_back操作 12345678910111213void test01()&#123; vector&lt;int&gt;v; cout &lt;&lt; "vector当前使用的空间为：" &lt;&lt; v.size() &lt;&lt; endl; cout &lt;&lt; "vector的容量为：" &lt;&lt; v.capacity() &lt;&lt; endl; for (int i = 0; i &lt; 10; i++) &#123; v.push_back(i); cout &lt;&lt; "vector当前使用的空间为：" &lt;&lt; v.size() &lt;&lt; endl; cout &lt;&lt; "vector的容量为：" &lt;&lt; v.capacity() &lt;&lt; endl; &#125; DisplayVector(v);&#125; 构造一个vector容器 vector中提供的构造函数和拷贝构造函数如下： 12345678910111213vector() :start(0), finish(0), end_of_storage(0) &#123;&#125;vector(size_type n, const T&amp; value)&#123; fill_initialize(n, value);&#125;vector(int n, const T&amp; value)&#123; fill_initialize(n, value);&#125;vector(long n, const T&amp; value)&#123; fill_initialize(n, value);&#125; 下面使用一个vector容器构造另一个vector容器，代码如下： 1234567891011void test02()&#123; vector&lt;int&gt; v1; for (int i = 0; i &lt; 10; i++) &#123; v1.push_back(i); &#125; vector&lt;int&gt; v2(v1.begin(), v1.end()); DisplayVector(v1); DisplayVector(v2);&#125; 输出结果如下图： 使用数组初始化vector 123456void test03()&#123; int array[] = &#123; 1,3,5,7,9,11 &#125;; vector&lt;int&gt;v(array, array + sizeof(array) / sizeof(int)); DisplayVector(v);&#125; 输出结果如下图： 初始化vector容器的一些方式 123456789101112131415161718192021222324void test04()&#123; vector&lt;int&gt;v1(10, 1);//初始化vector容器v为10个1 cout &lt;&lt; "v1:"; DisplayVector(v1); vector&lt;int&gt;v2&#123; 2,4,6,8,10 &#125;;//列表初始化vector容器 cout &lt;&lt; "v2:"; DisplayVector(v2); vector&lt;int&gt;v3; //assign(begin(),end());将[begin,end]区间中的数据拷贝给容器 v3.assign(v1.begin(), v1.end()); cout &lt;&lt; "v3:"; DisplayVector(v3); //assign(n,value);将n个value赋值给容器 v3.assign(10, 100); cout &lt;&lt; "v3:"; DisplayVector(v3); //swap(vector);将vector中的元素与本身的元素交换 v1.swap(v3);//v1与v3的元素进行交换 cout &lt;&lt; "v1:"; DisplayVector(v1); cout &lt;&lt; "v3:"; DisplayVector(v3);&#125; 结果如下图所示： vector的元素操作：insert、push_back、pop_back、erase、clear 对元素操作的说明如下： insert(const_iterator pos, int count,ele);//迭代器指向位置pos 插入count 个元素ele. push_back(ele); //尾部插入元素ele pop_back();//删除最后一个元素 erase(const_iterator start, const_iterator end);//删除迭代器从start 到end 之间的元素 erase(const_iterator pos);//删除迭代器指向的元素 clear();//删除容器中所有元素 size();//返回容器中元素的个数 empty();//判断容器是否为空 resize(int num);//重新指定容器的长度为num，若容器变长，则以默认值填充新位置。如果容器变短，则末尾超出容器长度的元素被删除。 resize(int num, elem);//重新指定容器的长度为num，若容器变长，则以elem 值填充新位置。如果容器变短，则末尾超出容器长&gt;度的元素被删除。 capacity();//容器的容量 reserve(int len);//容器预留len 个元素长度，预留位置不初始化，元素不可访问。 示例如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950void test05()&#123; vector&lt;int&gt;v1&#123; 10,15,16,17,18,19,20 &#125;; if (v1.empty()) &#123; cout &lt;&lt; "v1为空" &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; "v1:"; DisplayVector(v1); cout &lt;&lt; "v1不为空，元素个数为：" &lt;&lt; v1.size() &lt;&lt; endl; &#125; v1.resize(10);//重新指定vector容器的长度 cout &lt;&lt; "v1的元素个数为：" &lt;&lt; v1.size() &lt;&lt; endl; DisplayVector(v1); v1.resize(15, 8888); cout &lt;&lt; "v1的元素个数为：" &lt;&lt; v1.size() &lt;&lt; endl; DisplayVector(v1); v1.resize(4); cout &lt;&lt; "现在v1的元素个数为：" &lt;&lt; v1.size() &lt;&lt; endl; DisplayVector(v1); vector&lt;int&gt;v2; v2.reserve(15);//为v2预留15个元素的长度 for (int i = 0; i &lt; 5; i++) &#123; v2.push_back(i); &#125; DisplayVector(v2); int ret = v1.at(2);//取索引5指向的元素 cout &lt;&lt; "索引为2所指的数据为：" &lt;&lt; ret &lt;&lt; endl; cout &lt;&lt; "v1中的第三个元素为：" &lt;&lt; v1[2] &lt;&lt; endl; cout &lt;&lt; "v1的首元素为：" &lt;&lt; v1.front() &lt;&lt; endl; cout &lt;&lt; "v1的尾元素为：" &lt;&lt; v1.back() &lt;&lt; endl; v1.insert(v1.begin() + 1, 4, 5);//在迭代器v1.begin()+1指向的位置插入4个5 cout &lt;&lt; "v1:"; DisplayVector(v1);//输出 v1.pop_back();//删除v1的尾元素 cout &lt;&lt; "v1:"; DisplayVector(v1); v1.erase(v1.begin());//删除v1的v1.begin指向的元素 cout &lt;&lt; "v1:"; DisplayVector(v1); v1.erase(v1.begin()+1, v1.end());//删除v1.begin()+1,v1.end()之间的元素 cout &lt;&lt; "v1:"; DisplayVector(v1); v1.clear();//清空v1中的元素 cout &lt;&lt; "v1:"; DisplayVector(v1);&#125; 输出结果如下： 使用swap来收缩vector容器的空间 123456789101112131415161718void test06()&#123; vector&lt;int&gt;v; for (int i = 0; i &lt; 10; i++) &#123; v.push_back(i); &#125; cout &lt;&lt; "v的容量为：" &lt;&lt; v.capacity() &lt;&lt; endl; cout &lt;&lt; "v的大小为：" &lt;&lt; v.size() &lt;&lt; endl; v.resize(5); cout &lt;&lt; "调整大小后vector容器的容量和大小如下：" &lt;&lt; endl; cout &lt;&lt; "v的容量为：" &lt;&lt; v.capacity() &lt;&lt; endl; cout &lt;&lt; "v的大小为：" &lt;&lt; v.size() &lt;&lt; endl; cout &lt;&lt; "使用swap收缩vector空间" &lt;&lt; endl; vector&lt;int&gt;(v).swap(v); cout &lt;&lt; "v的容量为：" &lt;&lt; v.capacity() &lt;&lt; endl; cout &lt;&lt; "v的大小为：" &lt;&lt; v.size() &lt;&lt; endl;&#125; 输出结果如下： 源码地址 vector源码示例]]></content>
      <categories>
        <category>STL</category>
      </categories>
      <tags>
        <tag>STL</tag>
        <tag>vector</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[STL概论]]></title>
    <url>%2F2019%2F06%2F30%2FSTL%E6%A6%82%E8%AE%BA%2F</url>
    <content type="text"><![CDATA[长久以来，软件界一直希望建立一种可重复运用的东西，以及一种得以制造出“可重复运用的东西”的方法，让工程师/程序员的心血不致于随时间迁移、人事异动、私心欲念而烟消云散。从子函数、程序、函数、类别、到函数库、类别库、各种组件、从结构化设计、模块化设计、面向对象设计、到模式的归纳整理，无一不是软件工程的慢慢奋斗史。 为的，就是复用性的提升。 ——《STL源码剖析》 为了建立数据结构和算法的一套标准，并且降低他们之间的耦合关系，以提升各自的独立性、弹性、交互操作性、，诞生了STL。 STL（标准模板库），是惠普实验室开发的一系列软件的统称。 STL从广义上分为：容器、算法、迭代器。容器和算法之间通过迭代器进行无缝连接。STL几乎所有的代码都采用了模板类或模板函数，相比于由函数和类组成的库来说提供了更好的代码复用机会。 一、STL六大组件 容器：各种数据结构，如vector,list,deque,set,map，用来存放数据。 算法：各种常用的算法如：sort,search,copy,erase…… 迭代器:扮演了容器和算法之间的胶合剂，是所谓的泛型指针。共有五种类型，以及其他的衍生变化，从实现的角度来看，迭代器是一种将operator*,operator-&gt;,operator++,operator—等指针相关操作予以重载的class template。所有STL容器都附带有自己专属的迭代器，只有容器设计者才知道如何遍历自己的元素。原生指针也是一种迭代器。 仿函数：行为类似函数，可作为算法的某种策略。从实现的角度看，仿函数是一种重载了operator()的class或class template 适配器：一种用来修饰容器或仿函数或得带器接口的东西。 空间配置器：负责空间配置与管理。从实现的角度来看，配置器是一个实现了动态空间配置，空间管理，空间释放的class template。 STL六大组件的交互关系，容器通过空间配置器取得数据存储空间，算法通过迭代器存储容器空间中的内容，仿函数可以协助算法完成不同的策略的变化，适配器可以修饰仿函数 二、STL优点 STL是C++的一部分，因此不用额外安装什么，它被内建在编译器之内 STL的一个重要特性是将数据和操作分离，数据由容器类别加以管理，操作则由可定制的算法定义。迭代器在两者之间充当粘合剂，以使算法可以和容器交互运行。 程序员不用思考STL具体的实现过程，只要能熟练使用STL就可以。这样他们就可以把精力放在程序开发的别的方面 STL具有高复用性、高性能、高移植性、跨平台等优点。 高可重用性：STL中几乎所有的代码都采用了模板类和模板函数的方式实现，这相比于传统的由函数和类组成的库来说提供了更好的代码重用机会。 高性能：如map可以高效地从十万记录里面查找出指定的记录。因为map是采用红黑树的变体实现的 高移植性：如在项目A上用STL编写的模块，可以直接移植到项目B上。 三、STL三大组件介绍 容器 容器，置物之所也。 研究数据的特定排列方式，以利于搜索或排序或其他特殊每亩地，这一门学科就是数据结构。 任何特定的数据结构都是为了实现某种特定的算法。STL容器就是将运用最广泛的一些数据结构实现出来。 常用的数据结构：数组（array），链表（list）、树（tree），栈（stack），队列（queue），集合（set），映射表（map），根据数据在容器这两个排列的特性，这些数据分为序列式容器和关联式容器两种。 序列式容器强调的是值的排序，序列式容器中的每个元素均有固定的位置，除非用删除或插入操作改变这个位置。vector容器，deque容器，list容器 关联式容器是非线性的树结构，更准确的说是二叉树结构，各元素之间没有严格的物理上的顺序关系，也就是说元素在容器中并没有保存元素置入容器时的逻辑顺序。关联式容器另一个显著特点是：在值中选择一个值作为关键字key，这个关键字对值起到了索引的作用，方便查找。set/multiset容器，map/multimap容器 算法 算法，问题之解法也。 以有限的步骤，解决逻辑或数学上的问题，即为算法。 算法分为：质变算法和非质变算法 质变算法：是指在运算过程中会戈恩噶区间内元素的内容，例如拷贝、替换、删除等 非质变算法：是指运算过程中不会更改区间内的元素内容，例如查找、计数、遍历寻找极值等。 迭代器 迭代器（iterator）是一种抽象的设计概念，显示程序语言中并诶呦直接对应于这个概念的实物。设计模式中iterator模式定义如下：提供一种方法，使之能够依序寻访某个容器所含的各个元素，而又无须暴露该容器的内部表示方式。 迭代器的设计思维-STL的关键所在，STL的中心思想在于将容器和算法分开，彼此独立设计，最后再贴胶着剂将他们撮合在一起，从技术角度来看，容器和算法的泛型化并不困难，C++的class template 和function template可分别达到目标，如果设计出这两个之间的良好的胶着剂，才是大难题。 分类 描述 功能 输入迭代器 提供对数据的只读访问 输出迭代器 提供读写操作，并能向前推进迭代器 前向迭代器 提供读写操作，并能向前推进迭代器 读写，支持++，==，~= 双向迭代器 提供读写操作，并能向前和向后操作 读写，只会++，— 随机访问迭代器 提供读写操作，并能以跳跃的方式访问容器的任意数据，是功能最强大的的迭代器 读写，支持++，—，[n],-n,&lt;,&lt;=,&gt;,&gt;=]]></content>
      <categories>
        <category>STL</category>
      </categories>
      <tags>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[软件测试知识点总结]]></title>
    <url>%2F2019%2F06%2F30%2F%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[一、软件测试基本概念 软件测试的定义 使用人工或自动手段来运行或测试某个系统的过程，其目的在于检验它是否满足规定的需求或是否弄清预期结果与实际结果之间的差别。 软件缺陷的定义 软件缺陷，常常被称为bug。所谓软件缺陷，即计算机软件或程序中存在某种破坏正常运行能力的问题、错误，或者隐藏的功能缺陷。缺陷的存在会导致软件产品在某种程度上不能满足用户的需要。 标准定义：从产品内部看，缺陷时软件产品的开发或维护过程中存在的错误、毛病等各种问题；从产品外部看，缺陷是系统所需要实现的某种功能的失效或违背。 软件缺陷的主要类型 (1)软件没有是实现产品说明书中要求的功能模块 (2)软件中出现了产品说明书中指明不应出现的错误 (3)软件实现了产品说明书中没有提到的功能模块 (4)软件没有实现产品说明书中没有明确提到但应该实现的目标 (5)软件难以理解、不易于使用，运行缓慢，或从测试员的角度看，最终用户会认为不好。 软件缺陷的级别 (1)微小的。一些小问题，对功能几乎没有影响，软件产品仍然可以使用 (2)一般的。不太严重的问题，如次要功能模块丧失、提示信息不够准确、用户界面差、操作时间长等 (3)严重的。严重错误，指没有实现功能模块或某个特性，主要功能部分丧失、次要功能全部丧失，或致命的错误声明 (4)致命的。致命的错误，将造成系统崩溃、死机，或造成数据丢失、主要功能完全丧失等 通常情况下，问题越严重，其处理优先级就越高。 软件缺陷的状态 (1)激活状态：问题没有解决，测试人员新报告的缺陷或者验证后的缺陷仍旧存在 (2)已修正状态：已经被开发人员检查、修复过的缺陷，通过单元测试，认为已经解决但还没有被测试人员验证 (3)关闭状态：测试人员经过验证后，确认验证不存在之后的状态 软件缺陷的原因 (1)软件产品说明书 (2)设计方法 (3)编写代码 (4)其他 比例依次减小 软件缺陷修复的代价 依次递增，如下： (1)编制说明书 (2)设计阶段 (3)编写代码 (4)测试 (5)发布 软件测试的分类 (1)按照开发阶段划分 ​ ①单元测试 ​ ②集成测试 ​ ③系统测试 ​ ④验收测试 (2)按测试技术划分 ​ ①白盒测试 ​ ②黑盒测试 ​ ③灰盒测试 (3)按被测软件是否实际运行划分 ​ ①静态测试 ​ ②动态测试 (4)按照测试实施组织划分 ​ ①开发方测试（α测试) ​ ②用户测试（β测试） ​ ③第三方测试 软件测试的原则 （1）完全测试程序是不可能的 （2）软件测试是有风险的 （3）测试无法显示潜伏的软件缺陷 （4）软件缺陷的群集现象 （5）杀虫剂怪事：软件测试越多，其免疫力越强 （6）并非所有的软件缺陷都能被修复 （7）难以描述的软件缺陷 二、黑盒测试用例设计方法 测试用例在软件测试中的作用 （1）推导测试的实施 （2）规划测试数据的准备 （3）编写测试脚本的“设计规格说明书” （4）评估测试结果的度量基准 （5）分析缺陷的标准 设计测试用例的步骤 （1）测试需求分析 （2）业务流程分析 （3）测试用例设计 （4）测试用例评审 （5）测试用例更新完善 等价类划分法 等价类划分法是一种最为常见的黑盒测试方法。 其基本实现是把程序的输入域划分为若干个子集，然后从每个子集中选取少量具有代表性的数据作为测试用例。在该子集合中，各个输入数据对于揭示程序中的错误都是等效的 等价类可以分为两种： （1）有效等价类。指对于程序的规格说明来说，是由合理的、与意义的输入数据构成的集合。主要为了检验程序是否实现了规格说明书中规定的功能和性能 （2）无效等价类。对规格说明书而言，是由无意义的、不合理的输入数据构成的集合。利用无效等价类中的数据，检验程序对错误输入的处理能力。 设计测试用例的步骤 （1）划分等价类 （2）建立等价类表，列出所有划分出的等价类，并为每一个等价类规定一个唯一的编号 （3）从划分出的等价类中按以下原则设计测试用例。设计一个新的测试用例，使其尽可能多地覆盖尚未被覆盖的有效等价类，重复这一步骤，直到所有的有效等价类都被覆盖为止；设计一个新的测试用例，使其仅覆盖一个尚未被覆盖的无效等价类，重复这一步，直到所有的无效等价类都被覆盖为止 边界值分析法 边界值分析法用于考察处于等价划分边界或在边界附近的状态。 通常，软件中边界分为内部边界和外部边界两种。所谓的外部边界是可以在需求规格说明书、设计规格说明书中找到相应的描述的，而内部边界是在程序实现环节存在的、至关重要的界限。 因果图法 等价类划分法和边界值分析方法都着重考虑输入条件，但没有考虑输入条件的各种组合、输入条件之间的相互制约关系。 因果图是一种利用图解法分析输入的各种组合情况，从而设计测试用例的方法，它适合于检查程序输入条件的各种组合情况。 因果图的定义：因果图是一种描述输入和输出之间关系的图，其中出现的基本符号主要有：节点和弧线。 因果图描述的原因和结果之间的关系： （1）恒等 （2）非 （3）或 （4）与 输入条件的约束： （1）E约束（异） （2）I约束（或） （3）O约束（唯一） （4）R约束（要求） 因果图法的基本步骤 （1）分析程序规格说明书中描述的语义内容，找出“原因”和“结果”，将其表示成连接各个原因与结果的“因果图” （2）由于语法或环境限制，有些原因与原因之间或原因与结果之间的组合情况是不可能出现的，可用记号标明约束或限制条件 （3）将因果图转换成判定表 （4）根据判定表中的每一列设计测试用例 决策表法 决策表，也称判定表。在所有的黑盒测试方法中，基于决策表的测试方法被认为是最严格的的，因为决策表具有逻辑严格性。 决策表是分析和表达多逻辑条件下执行不同操作的情况的工具。 决策表的结构 （1）条件桩：列出问题的所有条件 （2）条件项：针对条件桩给出的条件列出所有可能的取值 （3）动作桩：列出问题规定的可能采取的操作 （4）动作项：指出在条件项的各组取值情况下应采取的动作 （5）规则：贯穿条件项和动作项的一列就是一条规则 决策表的化简 初始决策表的条件项的数目很大，若表中有两条以上规则具有相同的动作，并且在条件项之间存在极为相似的关系，便可以将它们合并。合并后的条件项用符号“—”表示，说明执行的动作与该条件的取值无关，称为无关条件。 三、白盒测试用例设计方法 逻辑覆盖测试 白盒测试方法是把测试对象看作一个打开的盒子，测试人员依据程序内部逻辑结构相关信息，设计或选择测试用例，对程序所有逻辑路径进行测试，通过在不同点检查程序的状态，确定实际的状态是否与预期的状态一致。 逻辑覆盖测试是以程序内在逻辑结构为基础的测试，重点关注测试覆盖率。包括以下6种类型：语句覆盖、判定覆盖、条件覆盖、判定/条件覆盖、条件组合覆盖和路径覆盖。 语句覆盖 语句覆盖是指设计若干个测试用例，使程序中的每个可执行语句至少执行一次。在保证每条语句都运行的前提下，测试用例应尽量少。在语句覆盖的基础上可以实现程序覆盖，进而是程序块的覆盖。 语句覆盖是一种较弱的覆盖测试。 判定覆盖 判定覆盖的含义是：设计足够多的测试用例，使程序中的每个判定都至少获得“真值”和“假值”。程序中的判定有：分支判定和循环判定。 为了表示方便，做到理解上的统一，表示某个条件的真假用$T_i$和$F_i$,表示某个判定的真假使用$TD_i$和$FD_i$ 条件覆盖 条件覆盖的含义是:构造一组测试用例，使得每一个判定中每个逻辑条件的可能值至少被满足一次。 判定/条件覆盖 设计足够的测试用例，使得判定中每个条件的所有可能（真/假）至少出现一次，并且每个判定本身的判定结果（真/假）也至少出现一次，即满足判定/条件覆盖的测试用例同时满足条件覆盖和判定覆盖。 组合条件覆盖 组合条件覆盖的含义是：设计足够的测试用例，使得每个判定中条件的各种可能组合都至少出现一次。 显然，满足组合条件覆盖的测试用例是一定满足判定覆盖、条件覆盖和判定/条件覆盖的。 具体的组合策略如下： （1）如果某个条件组合只有一种可能性，则优先确立关系 （2）不可能存在的组合不住要设计测试用例 （3）除了不可能的情况，所有的条件组合都必须至少出现一次 路径覆盖 所谓路径覆盖就是设计足够多的测试用例使每个路径都有可能被执行。 基本路径测试 包括程序控制流图，环形复杂度、独立路径 控制流图 在设计程序时，为了更加突出控制流的结构，可对程序流程图进行简化，简化后的流程图称为控制流图。 控制流图的构成： 控制流线 结点 必须用结点表示的情况： （1）程序流程图中矩形框表示的处理 （2）菱形框表示的两个甚至多个出口判断 （3）多条流线相交的汇合点 环形复杂度 环形复杂度（圈复杂度）是一种为程序逻辑复杂度提供定量尺度的软件度量。也可将该度量用于基本路径测试方法，它可以提供程序基本集的独立路径数量和确保所有语句至少被执行一次的测试数量上界。 计算环形复杂度的方法： （1）流图中区域的数量对应于环形复杂度 （2）给定流图G的环形复杂度为V（G），定义为V(G)=E-N+2,其中，E是流图中边的数量，N是流图中节点的数量 （3）给定流图G的环形复杂度V(G)，定义为V(G)=P+1,P是流图G中判定结点的数量 独立路径 独立路径是指程序中至少引入了一个新的处理语句集合或一个新条件的程序通路，它必须至少包含一条路径在本次定义路径之前不曾用过的边。 程序的环形复杂度是程序基本路径集合中的独立路径条数，这是确定路径中每个可执行语句至少被执行一次所必需的测试用例数目的上界。 代码检查 在实际使用中，静态代码检查比动态测试更有效率，更能快速找到缺陷。 静态测试包括代码检查和静态分析两种途径，它可以由人工进行，充分发挥人的逻辑优势，也可以借助软件工具自动进行。代码检查包括桌面检查、代码审查、代码走查、技术评审等。 主要检查代码的设计是否一致、代码是否遵循标准性和可读性、代码的逻辑表达的正确性，以及代码结构的合理性等。 代码评审也称代码复查，是指通过阅读代码来检查源代码与编码标准的符合性以及代码质量的活动。 代码评审的目的： （1）确保要发布质量可靠的代码，能非常有效地发现所有类型的错误 （2）作为教学工具帮助开发人员学会何时并且如何应用技术来提高代码的质量、一致性和维护性 代码评审是发现缺陷的有效方法。代码评审包括代码审查、代码走查、桌面检查等。 代码审查 代码审查作为质量保证的一部分，是静态测试的主要手段之一。 代码审查的内容： （1）编码规范问题 （2）代码结构问题 （3）工具、框架使用不当 （4）实现问题 （5）测试问题 代码走查 代码走查是以小组为单位进行代码阅读的，同样也是一系列规程和错误检查技术的集合。且代码走查也采用了持续1小时~2小时的不间断会议的形式。 代码走查的任务：就是参与者“使用计算机”。被指定为测试为人员的那个人会带着一些书面的测试用例来参加会议。且在会议期间，每个测试用例都在人们的头脑中进行推演。即把测试数据沿程序的逻辑结构走一遍，并把程序的状态记录以纸上或白板上以供监视。 桌面检查 桌面检查可被视为由担任进行的代码检查或代码走查：由一个人阅读程序，对照错误列表检查程序，对程序推演测试数据。 四、单元测试 单元测试的定义 单元测试又称模块测试，是最小单位的测试，其依据是详细设计规格说明书，对模块内所有重要的控制路径设计测试用例，以便发现模块内部的错误。 单元测试多采用白盒测试技术，系统内多个模块可以并行地进行单元测试 单元测试的对象 一般认为，在结构化程序时代，单元测试所说的单元是指函数，在面向对象编程中，单元测试的单元一般是指类。 但从实践来看，以类作为测试单位，复杂度高、可操作性较差，所以仍然主张以类中的方法作为单元测试的测试单位但可以用一个测试类来组织某个类的所有测试函数 单元测试不应过分强调面向对象，因为局部代码依然是结构化的。单元测试的工作量较大，简单、实用、高效才是硬道理， 单元测试的时间 单元测试当然是越早越好，通常在编码阶段进行。在源程序代码编制完成、经过评审和验证、确定没有语法错误之后，就可以了开始进行单元测试的测试用例设计 单元测试的内容 （1）模块接口测试 （2）模块局部数据结构测试 （3）模块边界条件测试 （4）模块中所有数日执行通路测试 （5）模块的各条错误处理通路测试 模块接口测试是单元测试的基础。只有在数据能正确流入、流出模块的前提下，其他测试才有意义。 单元测试的过程 （1）计划单元测试：确定测试需求，制订测试策略，确定测试所用的资源，创建测试任务的时间表 （2）设计单元测试：根据单元测试计划设计单元测试模型，制订测试方案，确认测试过程，设计具体的测试用例，创建可重用的测试脚本 （3）执行单元测试：根据单元测试的方案、用例对软件单元进行测试，验证测试结果并记录测试过程中出现的缺陷 （4）评估单元测试：对单元测试的结果进行评估，主要从需求覆盖和代码覆盖的角度进行测试完备性的评估 单元测试的模型 在进行单元测试时，如果模块不是独立的程序，需要辅助测试模块，有两种辅助模块： 驱动模块：所测模块的主程序。它接收测试数据，把这些数据传递给所测试模块，最后再输出测试结果。当被测试模块能完成一定功能时，也可以不要驱动模块。 桩模块：用来代替所测模块调用的子模块。被测试模块、驱动模块共同构成了一个测试模型 执行单元测试 （1）设置测试环境 （2）将测试环境初始化，以确保所有构件都处于正确的初始状态 （3）执行测试过程。需要注意的是，测试过程的执行将随着具体情况而变化：测试方式是自动还是人工，以及必需的测试构件是作为驱动程序还是桩模块。自动测试的测试脚本在执行实施测试步骤的过程中创建。而人工测试则是在“构建测试过程”活动中制定的结构化测试过程。 评估单元测试 测试完备性评估 代码覆盖率评估 从覆盖的角度看，。测试应该做到以下覆盖：功能覆盖、输入域覆盖、输出域覆盖、函数交互覆盖和代码执行覆盖 五、集成测试 集成测试的定义 集成测试又称组装测试，是在单元测试的基础上，将所有模块按照设计要求组装成子系统或系统，而进行的测试活动 集成测试的目的是确保各单元组合在一起后能够按照既定意图协作运行，并确保增量的行为正确。 它所测试内容包括单元间的接口以及集成后的功能，通常使用黑盒测试方法测试集成的功能，并且对以前的集成进行回归测试。 集成测试阶段主要检查以下几个方面： （1）在把各个模块连接起来的时候，穿越模块接口的数据是否会丢失 （2）一个模块的功能是否会对另一个模块的功能产生不利的影响 （3）各个子功能组合起来，能否达到预期要求的父功能 （4）全局数据结构是否有问题 （5）单个模块的误差累积起来，是否会被放大，从而达到不能接受的程度 （6）在单元测试的同时可进行集成测试，发现并排除在模块连接中可能出现的问题，最终构成要求的软件系统 集成测试的内容 一个产品的开发过程包括了分层的设计和逐步细化的过程，从最初的产品到最小的单元，由于集成的力度不同，一般可以把集成测试划分为三个级别： （1）模块内集成测试 （2）子系统内集成测试（模块）：先测试子系统内的功能模块（不能单独运行的程序），然后将各个功能模块组合起来确认子系统的功能是否达到预期要求 （3）子系统间集成测试（可执行程序）：测试的单元是子系统之间的接口，这里的子系统是可单独运行的程序或进程。 模块和子系统的区别： 一个完整的软件系统通常包括若干个具有不同功能的子系统。而每个子系统又由多个功能模块组成。 集成测试的原则 （1）要测试所有的公共接口，尤其是那些与系统相关联的外部接口，测试的重点是要检查数据的交换、传递和控制管理过程，还包括处理的次数 （2）必须对关键模块进行充分测试。在集成的过程中应该重点关注一个系统的关键模块。在确定测试需求时，测试人员就要确定系统的关键模块，这些关键模块包含在最希望测试的那些模块中。一般我们将系统中的模块划分成3个等级：高危模块、一般模块、低危模块。一个关键模块应该具有一个或多个下列特性： 和多个软件需求有关，或与关键功能有关 处于程序控制结构的顶层 本身是复杂的或者容易出错的 含有确定性的性能需求 被频繁使用的模块 （3）继承测试应当按一定的层次进行。系统的模块之间是有层次关系的，就像函数之间的相互调用关系。在对系统进行集成时，要按照一定的层次顺序进行集成，避免集成过程中发生错误无法对错误进行定位。 （4）集成测试的策略选择应当综合考虑质量、成本和进度之间的关系。风险分析贯穿整个集成测试过程中，总的原则是花费最小的成本，取得最大的测试效果 （5）集成测试应当尽早开始，并以总体设计为基础 （6）在模块与接口的划分上，测试人员应当和开发人员进行充分沟通 （7）测试执行结果应当被如实记录 集成测试的策略 （1）非增量式集成策略 非增量集成，又称大爆炸式集成，采用一步到位的方法来进行集成，又称一次组装或整体拼装。使用该方法进行集成时，首先分别测试每个模块，即对每个模块都进行独立的单元测试。测试通过后，再把所有模块按设计要求组合在一起构成整体，再对这个整体进行测试。 （2）增量式集成策略 增量式集成方法又被称为渐增式组装，它的集成时逐步实现的。首先对一个个模块进行模块测试，然后按照某种策略，将这些模块逐步组装成较大的系统，在组装的过程中边连接边测试，以发现连接过程中产生的问题。通过增值逐步组装成为满足要求的软件系统。 自顶向下的集成测试 自顶向下增量式集成就是按照模块结构图自上而下进行集成 自底向上的集成测试 自底向上的增量式集成就是按照模块结构图自底向上进行组装，首先从模块结构的底层开始，依次往高层次集成。在集成的过程中，不需要再编写桩模块，只需要为被组装模块编写驱动模块。 混合增量式集成策略 也称“三明治”集成，对软件结构中较上层，使用的是“自顶向下”集成；对软件结构中较下层，使用的是“自底向上”继承，将两种策略的优点结合在一起。 六、功能测试 系统测试 系统测试是通过与系统的需求规格做比较，发现软件与系统需求规格不相符或与之矛盾的地方。它将通过确认测试的软件，作为整个基于计算机系统的一个元素，与计算机硬件、外设、某些支持软件、数据和人员等其他系统元素结合起来，在实际运行（使用）环境下，对软件进行系统测试。 系统测试的依据为需求规格说明书、概要设计说明书和各种规范。通信产品与一般的软件产品不同，其系统测试往往需求依据大量的既定规范；对于海外产品，系统测试依据还包括各个国家自定的规范。 系统测试包括功能测试、性能测试、压力测试、协议一致性测试、容量测试、安全性测试、恢复性测试、备份测试、UI测试、安装和卸载测试、本地化测试、可用性测试等。 功能测试 功能测试又称正确性测试，就是对产品的各项功能进行验证，根据功能测试用例，逐项测试，检查产品是否达到用户要求的功能或者说检查软件的功能是否符合规格说明。由于正确性是软件最重要的质量因素，所以功能测试也非常重要。做功能测试需要首先明确业务和需求。理解了需求和业务，才知道客户想要系统实现什么。然后按照需求来进行测试，不满足要求的都可以被认为是缺陷。 功能测试的策略 测试需求分析 指定测试计划 测试设计和测试用例设计 测试环境搭建 测试实施 缺陷报告 回归测试 功能测试的内容 功能测试包括对用户界面的测试、对各种操作的测试，对不同的数据输入、逻辑思路、数据输出、存储等的测试。不同的应用系统，功能测试的内容差异很大，但一般都可归为界面、数据、操作、逻辑、接口等几个方面，主要包括： （1）程序安装和启动正常，有相应的提示框、适当的错误提示等 （2）每项功能符合实际要求 （3）系统的界面清晰、美观；菜单、按钮操作正常、灵活，能处理一些异常操作 （4）能接受正确的数据输入，对异常数据的输入可以进行提示、容错处理等 （5）数据的输出结果准确、格式清晰，可以保存和读取 （6）功能逻辑清楚，符合使用者习惯 （7）系统的各种状态按照业务流程而变化，并保持稳定 （8）支持各种应用的环境，能配合多种硬件周边设备，与外部应用系统的接口有效 （9）软件升级后，能够继续支持旧版本的数据 七、性能测试 性能测试 性能测试的目的是验证软件系统是否能够达到用户要求的性能指标，同时发现软件系统中出来的性能瓶颈，最后起到优化系统的目的。 性能测试的内容 具体包括以下几个方面： （1）评估系统的能力：测试中得到的负荷和响应时间数据可以用于验证软件系统能力是否符合设计要求 （2）识别系统中的瓶颈：当系统符合被增加到极限水平并继续增加时，可以通过性能指标的变化情况监测系统的瓶颈，从而帮助系统设计者修复系统的瓶颈 （3）系统调优：重复运行测试，验证调整系统的活动得到了预期的结果，从而改进系统性能 （4）验证稳定性与可靠性：在一定的负载压力下执行测试一定时间，是评估系统稳定性和可靠性是否满足要求的有效方法 性能测试的分类 性能测试类型包括负载测试、压力测试、强度测试、容量测试。通常，性能测试通过自动化的测试工具模拟多种正常、峰值以及异常负载条件来对系统的各项性能指标进行测试，负载测试和压力测试都属于性能测试，两者可以结合进行 （1）负载测试，是确定在各种工作负载下系统的性能，目标是测试当负载逐渐增加时，系统各项性能指标的变化情况，例如，吞吐量、响应时间、CPU负载、内存使用等，来确定系统的性能。负载测试是一个分析软件应用程序和支撑架构、模拟真实环境的使用，从而来确定能够接受的性能的过程。 （2）压力测试是通过确定一个系统的瓶颈或者不能接受的性能点，来获得系统能提供的最大服务级别的测试 （3）疲劳测试是采用系统稳定运行情况下，能够支持的最大并发用户数，持续执行一段时间业务，通过综合分析交易执行指标和资源监控指标来确定系统处理最大工作量强度性能的过程。疲劳强度测试可以采用自动化工具进行测试，也可以手工编写程序测试，其中后者占的比例较大 （4）容量测试用于确定系统可处理同时在线的最大用户数 （5）大数据量测试可以分为两种类型：针对某些系统存储、传输、统计、查询等业务进行大数据量的独立数据量测试；与压力性能测试、负载性能测试、疲劳性能测试相结合的综合数据量测试方案。大数据量测试的关键是测试数据的准备，可以依靠工具准备测试数据。 （6）速度测试目前主要针对关键的，有速度要求的业务进行手工测速度，可以在多次测试的基础上求平均值，可以和工具测试得到的响应时间等指标做对比分析。 性能计数器 影响一个系统性能的因素主要有：软件因素，包括系统软件、第三方软件等；硬件因素，如内存、磁盘、CPU、网卡等；网络因素，如网络吞吐量、带宽、网络传输速率等。 性能计数器是描述服务器或操作系统性能的一些数据指标。 （1）内存，内存性能计数器主要检查应用程序是否存在内存泄漏 （2）处理器，监视“处理器”和“系统”对象计数器可以提供关于处理器使用的有价值的信息，帮助测试人员决定是否存在瓶颈 （3）物理磁盘，磁盘性能 性能测试流程 （1）性能测试的计划 （2）性能测试的设计 （3）性能测试的执行 （4）测试结果的分析 八、本地化测试 本地化测试的定义 本地化测试是对软件进行本地化过程中记性的测试 所谓本地化就是将软件版本语言进行就更该。 本地化测试的对象是软件的本地化版本 本地化测试目的是测试待定目标区域设置的软件本地化质量 本地化测试的环境是在本地化的操作系统上安装本地化的软件。 从测试方法上可以分为：基本功能测试、安装或卸载测试、当地区域的软硬件兼容测试。 测试的内容主要包括软件本地化后的界面布局和软件翻译的语言质量，包含软件、文档和在线帮助等部分 本地化测试的目的首先是保证本地化的软件与源语言软件具有相同的功能和性能。其次还要保证本地化的软件在语言、文化、传统观念等方面符合当地用户的习惯。 本地化测试过程中的测试工作集中在： （1）易受本地化影响的方面，如用户界面 （2）区域性或区域设置特定的、语言特定的和地区特定的方面 本地化测试与其他测试的区别 软件本地化测试的测试对象是本地化的软件，需要在本地化的操作系统上进行。虽然本地化的软件是基于源程序软件创建的，但与其他测试的测试内容和重点有很大不同。 不同点 描述 测试顺序 首先要对源程序软件进行测试，然后再创建本地化软件，测试本地化软件 测试内容和重点 源程序软件主要测试功能和性能，结合软件界面的测试；本地化软件的测试，更注重因本地化引起的错误；例如，翻译是否正确，本地化的界面是否美观、本地化后的功能是否与源语言软件保持一致 测试环境 源程序软件测试通常在源语言的操作系统上进行；本地化软件在本地化的操作系统上进行 本地化测试的类型 （1）导航测试，是为了降低软件本地化的风险而进行的一种本地化测试 （2）可接受性测试，也被称为冒烟测试，是指对编译的软件本地化版本的主要特征进行基本测试，从而确定版本是否满足详细测试的条件。 （3）语言质量测试，是软件本地化测试的重要组成部分，贯穿于本地化项目的各个阶段。语言质量测试的主要内容是软件界面和在线帮助等文档的翻译质量，包括正确性，完整性，专业性和一致性。 （4）用户界面测试，也被称为外观测试，主要是对软件的界面文字和控件布局进行测试 （5）功能测试，原始语言开发的软件的功能测试主要测试软件的各项功能是否被实现以及是否正确，而本地化软件的功能测试主要是测试软件经过本地化后，软件的功能是否与源软件一致，是否存在因软件本地化而产生的功能错误 本地化软件缺陷的分类 核心软件缺陷 （1）源语言功能缺陷 （2）源语言国际化缺陷 本地化缺陷 （1）语言质量缺陷 （2）用户界面缺陷 （3）本地化功能缺陷 本地化测试的流程 （1）测试规划 （2）测试设计 （3）测试实施 （4）配置管理 （5）测试管理 本地化测试工程师 基础技能 （1）安装和配置常用操作系统的知识 （2）计算机网络基础知识 （3）通用软件的使用知识 （4）良好的语言技能 专业基础知识 （1）软件本地化或国际化的基本知识 （2）软件本地化工程的基础知识 职业素质 （1）解决问题的专业态度和创新能力 （2）主动迅速学习新知识的能力 （3）执著敬业和团队合作能力 （4）良好的书面和口头交流技能 （5）承受压力的能力 九、软件测试管理 缺陷生命周期 （1）新建：当缺陷被第一次递交的时候，它的状态即为“新建”。这也就是说缺陷未被确认其是否真正是一个缺陷 （2）打开：在测试者提交一个缺陷后，测试组长确认其确实为一个缺陷的时候，会把状态置为“打开” （3）分配：一旦缺陷被测试经理置为“打开”，再把缺陷交给相应的开发人员或开发组。这时缺陷状态变更为“分配” （4）测试：当开发人员修复缺陷后，缺陷提交给测试组进行新一轮的测试，在开发人员公布以修复缺陷的程序之前，缺陷状态被置为“测试”。这时表明缺陷已经被修复并已经提交给了测试组 （5）已确认：当缺陷被修复后就会被置为“测试”，测试员会执行测试。如果缺陷不再出现，这就证明缺陷被修复了的同时其状态被置为“已确认” （6）延期：延期状态被置为“延期”意味着，缺陷将会在下一个版本中被修复 （7）重新打开：如果缺陷被开发人员修复后，问题仍然存在，测试人员会把缺陷状态置为“重新打开”。缺陷即将再次穿越其生命周期 （8）重复：如果同一个缺陷被重复提交或者两个缺陷表明的意思相同，那么这个缺陷状态将会被置为“重复”提交 （9）拒绝：如果开发人员不认为其实一个缺陷，会拒绝此缺陷，缺陷状态被置为“拒绝” （10）关闭：当缺陷被修复后，测试人员会对其进行测试。如果测试人员认为缺陷不存在了，会把缺陷状态置为“关闭”，。这个状态意味着缺陷已被修复，通过了测试并且核实确实如此 缺陷报告的编写 （1）清晰地描述缺陷 （2）使用简洁的语言 （3）重现的步骤和数据 （4）提供参考信息 （5）抓屏截图 团队管理 （1）组织结构 基于技能的组织模式 基于测试流程的组织模式 基于项目的组织模式 （2）素质要求 踏实细心和积极主动 怀疑一切 协作和团队感 自我提高和总结的能力 （3）激励方法 表扬和奖励 信任的力量 提高士气 薪水 职务 工作时间 培训机会 风险管理 （1）需求风险 （2）人员风险 （3）环境风险 （4）回归风险 （5）测试资源 （6）需求变更 （7）用例质量 （8）标准差异 （9）测试工具 过程管理 （1）测试需求分析 测试需求的依据与收集 测试需求的分析 测试需求的优先级 （2）测试计划 （3）测试设计 （4）测试开发 （5）测试执行]]></content>
      <categories>
        <category>软件测试</category>
      </categories>
      <tags>
        <tag>软件测试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机操作系统（第四版）习题四解答]]></title>
    <url>%2F2019%2F06%2F22%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC%E5%9B%9B%E7%89%88%EF%BC%89%E4%B9%A0%E9%A2%98%E5%9B%9B%E8%A7%A3%E7%AD%94%2F</url>
    <content type="text"><![CDATA[为什么要配置层次式存储器？ 设置多个存储器可以使存储器两端的硬件能并行工作； 采用多级存储系统，特别是Cache技术，是减轻存储器带宽对系统性能影响的最佳结构方案； 在微处理机内部设置各种缓冲存储器，减轻对存储器存取的压力 增加CPU中寄存器数量，大大缓解翠存储器压力 可采用哪几种方式将程序装入内存？它们分别适用于何种场合？ 绝对装入方式 只适用于单道程序环境 可重定位装入方式 适用于多道程序环境 动态运行时装入方式 用于多道程序环境 不允许程序运行时在内存中移动位置 何谓静态链接？静态链接时需要解决两个什么问题？ 静态链接是指在程序运行之前，先将各目标模块及它们所需的库函数链接成一个完整的装配模块，以后不再拆开。 需要解决为问题是： 对相对地址进行修改 变换外部调用符号 何谓装入时动态链接？装入时动态链接方式有何优点？ 装入时动态链接是指将用户源程序编译后得到的一组目标模块，在装入内存时，采用边装入边链接的链接方式。 优点： 便于修改和更新 便于实现对目标模块的共享 何谓运行时动态链接？运行时动态链接又何优点？ 运行时动态链接是将对某些模块的链接推迟到程序执行时才运行。 优点： 加快程序的装入过程 节省大量的内存空间 在动态分区分配方式中，应如何将各空闲分区链接成空闲分区链？在每个分区的起始部分设置一些用于控制分区分配的信息，以及用于链接各分区所用的前向指针，在分区尾部则设置一后向指针。通过前、后向链接指针，可将所有的空闲分区链接成一个双向链。 为什么要引入动态重定位？如何实现？ 在程序执行的过程中，每当访问指令或数据时，将要访问的程序或数据的逻辑地址转换成物理地址，所以引入了动态重定位。 实现方法 在系统中增设一个重定位寄存器，用它来存放程序（数据）在内存中的起始地址。程序在执行时，真正访问的内存地址是相对地址与重定位寄存器中的地址相加而形成的。 什么是基于顺序搜索的动态分区分配算法？它可分为哪几种？ 为了实现动态分区分配，通常是将系统中的空闲分区链接成一个链。所谓顺序搜索，是指依次搜索空闲分区链上的空闲分区，去寻找一个其大小能满足要求的分区。 基于顺序搜索的动态分区分配算法可分为： 首次适应算法 循环首次适应算法 最佳适应算法 最坏适应书房 在采用首次适应算法回收内存时，可能出现哪几种情况？应怎样处理？可能会出现四种情况： 回收区与插入点前的一个分区$F_1$相邻接。将回收区与插入点的前一分区合并，不必再为回收分区分配新表项，而只需修改其前一分区$F_1$的大小 回收分区与插入点后的一空闲分区$F_2$相邻接。将两个分区合并，形成新的分区，但用回收区的首址作为新空闲区的首址，大小为两者之和 回收区同时与插入点的前、后两个分区邻接。将三个分区合并，使用$F_1$的表项和$F_1$的首址，取消$F_2$的表项，大小为三者之和。 什么是基于索引搜索的动态分区分配算法？它可分为哪几种？ 基于顺序搜索的动态分区分配算法，比较适用于不太大的系统。当系统很大时，系统中的内存分区可能会很多，相应的空闲分区链就很长，这是采用顺序搜索方法可能会很慢。为了提高搜索空闲分区的速度，在大、中型系统中往往会采用基于索引搜索的动态分区分配算法。 基于索引搜索的动态分区分配算法可分为： 快速适应算法 伙伴系统 哈希算法 令$buddy_k$(x)为大小为$2^k$、地址为x的块的伙伴系统地址，试写出$buddy_k$(x)的通用表达式 分区存储管理中常用哪些分配策略？比较它们的优缺点？ 首次适应算法 保留了高址部分的大空闲区，有利于后来的大型作业分配 地址部分不断被划分，留下很多难以利用的小空闲区，每次查找都从地址开始增加了系统开销 循环首次适应算法 内存空闲分区分布均匀，减少了查找系统开销 缺乏大空闲分区，导致不能装入大型作业 最佳适应算法 每次分配给文件的都是最合适该文件大小的分区，内存中留下了很多难以利用的小空闲区 最坏适应算法 剩下空闲分区不至于太小，产生碎片的可能性最小，对中、小型作业有利 存储器中缺乏大空闲区，对大型文件分区分配不利 查找效率很高 为什么要引入对换？对换可分为哪几种类型？ 在多道程序环境下，一方面，在内存中的某些进程由于某花时间尚未发生而被阻塞运行，但它却占用了大量的内存空间，甚至有时有可能出现在内存中所有进程都被阻塞，而没有可以运行的进程，另一方面，却有着很多作业，因两次了空间不足，一直驻留在外存上，而不能进入内存运行。为了解决这一问题，系统引入了对换。 对换的类型 整体对换 页面（分段）对换 对文件区管理的目标和对对换空间管理的目标有何不同？ 对文件区管理的主要目标： 提高文件存储空间的利用率，然后才是提高对文件的访问速度。因此，对文件区空间的管理采取离散分配方式 对对换空间管理的目标： 提高进程换入和换出的速度，然后才是提高文件存储空间的利用率。为此，对对换空间的管理采取连续分配方式，较少考虑外存中的碎片问题 为实现对换，系统应具备哪几方面的功能？ 对换空间管理 进程换入 进程换出 在以进程为单位进行对换时，每次是否都将整个进程换出？为什么？在以进程为单位进行对换时，并非每次都将整个进程换出，这是因为： 从结构上讲，进程是由程序段、数据段和进程控制块组成的，其中进程控制块中总有部分或全部常驻内存，不被换出 程序段和数据段可能正在被若干进程共享，此时它们也不能换出 基于离散分配时所用的基本单位不同，可将离散分配分为哪几种？ 分页存储管理方式 分段存储管理方式 段页式存储管理方式 什么是页面？什么是物理块？页面的大小应如何确定？ 页面。分页存储管理将进程的逻辑地址空间分为若干个页，并为各页加以编号。 物理块：将内存中的物理地址空间分层若干个块 在分页系统中，若选择过小的页面大小，虽然一方面可以减轻碎片，起到减少内存碎片总空间的作用，有利于内存利用率的提高，但另一方面却会造成每个进程占用较多的页面，从而导致进程的页表过长，占用大量内存。此外，还会降低换进换出的效率。然而，页面选择过大，虽然可以减少页表的长度，提高页面换进换出的速度，但却又会使页内碎片增大。因此，页面的大小应选择适中，且页面大小应是2的幂，通常为1KB-8KB。 什么是页表？页表的作用是什么？ 在分页系统中，允许将进程的各个页面离散地存储在内存的任一地址块中，为了保证进程仍然能够正确地运行，即能在内存中找到每个页面所对应的物理块，系统又为每个进程建立了一张页面映像表，简称页表。 页表的作用是实现从页号到物理块号的地址映射 为实现分页存储管理，需要哪些硬件支持？ 页表寄存器 地址变换机构 联想寄存器 在分页系统中是如何实现地址变换的？&emsp;&emsp;当进程要访问某个逻辑地址中的数据时，分页地址变换机构会自动地将有效地址分为页号和页内地址两部分，再以页号为索引去检索页表。查找操作由硬件执行。在执行检索之前，先将页号与页表长度进行比较，如果页号大于或等于页表长度，则表示本次所访问的地址已超越进程的地址空间。于是，这一错误将被系统发现，并产生一地址越界中断。 &emsp;&emsp;若未出现越界错误，则将页表始址与页号和页表项长度的乘积相加，便得到该表项在页表中的位置，于是可从中得到该页的物理块号，将之装入物理地址寄存器中。与此同时，再将有效地址寄存器中的页内地址送入物理地址寄存器的块内地址字段中。这样便完成了从逻辑地址到物理地址的变换。 具有快表时是如何实现地址变换的？&emsp;&emsp;在CPU给出有效地址后，由地址变换机构自动地将页号P送入高速缓冲寄存器，并将此页号与高速缓存中的所有页号进行比较，若其中有与此相匹配的页号，便表示所要访问的页表项在快表中。于是，可直接从快表中读出该页所对应的物理块号，并送到物理地址寄存器中。 &emsp;&emsp;若在快表中未找到对应的页表项，则还须再访问内存中的页表，找到后，把从页表项中读出的物理块号送往地址寄存器；同时，再将此页表项存入快表的一个寄存器单元中。但如果联想寄存器已满，则OS必须找到一个老的且已被认为是不再需要的页表项，将它换出。 较详细地说明引入分段存储管理是为了满足用户哪几方面的需要。 方便编程。用户通常把自己的作业按照逻辑关系划分为若干段，每段都从0 编址，并有自己名字和长度。因此，希望要访问的逻辑地址是由段名和段内偏移量决定。 信息共享。在实现对程序和数据的共享时，是以信息逻辑单位为基础。分页系统中的页是存放信息的物理单位，无完整意义，不便于共享；段是信息的逻辑单位。为了实现段的共享，希望存储管理能与用户程序分段的组织方式相适应。 信息保护。对信息的逻辑单位进行保护，分段能更有效方便地实现信息保护功能。 动态增长。在实际应用中，有些段特别是数据段，在使用过程中会不断增长，事先又无法确切知道增长多少。分段存储管理方式能较好解决这个问题。 动态链接。运行时先将主程序对应的目标程序装入内存并启动运行，运行过程中又需要调用某段时，才将该段调入内存链接。所以动态链接也要求以段作为管理单位。 在具有快表的段页式存储管理方式中，如何实现地址变换？&emsp;在CPU给出有效地址后，由地址变换机构自动地将页号P送入高速缓冲寄存器，并将此页号与高速缓存中的所有页号进行比较，若其中有与此相匹配的页号，便表示所要访问的页表项在快表中。于是，可直接从快表中读出该页所对应的物理块号，并送到物理地址寄存器中。 &emsp;&emsp;若在快表中未找到对应的页表项，则还须再访问内存中的页表，找到后，把从页表项中读出的物理块号送往地址寄存器；同时，再将此页表项存入快表的一个寄存器单元中。但如果联想寄存器已满，则OS必须找到一个老的且已被认为是不再需要的页表项，将它换出。 为什么说分段系统比分页系统更易于实现信息的共享和保护？ 分页系统的每个页面是分散存储的，为了实现信息共享和保护，页面之间需要一一对应，为此需要建立大量的页表项； 而分段系统的每个段都从0 编址，并采用一段连续的地址空间，在实现共享和保护时，只需为要共享和保护的程序设置一个段表项，将其中的基址与内存地址一一对应就能够实现。 分页和分段存储管理有何区别？ 页是信息的物理单位。采用分页存储管理方式是为了实现离散分配方式，以消减内存的外零头，提高内存的利用率。段则是信息的逻辑单位，它通常包含的是一组意义相对完整的信息。分段的目的主要在于能更好地满足用户的需要。 页的大小固定且由系统决定。在采用分页存储管理方式的系统中，在硬件结构上就把用户程序的逻辑地址划分为页号和页内地址两部分。而段的长度却是不固定的，决定于用户所编写的程序，通常由编译程序在对源程序进行编译时，根据信息的性质来划分 分页的用户程序地址空间是一维的。分页完全是系统的行为，故在分页系统中，用户程序的地址是属于单一的线性地址空间。而段式用户的行为，故在分段系统中，用户程序的地址空间是二维的。 试全面比较连续分配和离散分配方式 连续分配是指为一个用户程序分配一个连续的地址空间，包括单一和分区两种分配方式。单一方式将内存分为系统区和用户区，最简单且只用于单用户单任务操作系统：分区方式分为固定分区和动态分区。 离散分配方式分为分页、分段和段页式存储管理。分页式存储管理旨在提高内存利用率，分段时存储管理旨在满足用户的需要，段页式存储管理则是将两者结合起来，具有分段系统便于实现、可分享、易于保护和动态链接等优点，又能像分页系统一样，很好地解决外部碎片及为各段可离散分配内存等问题，是比较有效的存储管理方式。]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>习题解答</tag>
        <tag>存储器管理</tag>
        <tag>对换</tag>
        <tag>分页存储管理方式</tag>
        <tag>分段存储管理方式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机操作系统（第四版）习题二解答]]></title>
    <url>%2F2019%2F06%2F20%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%AC%E5%9B%9B%E7%89%88%EF%BC%89%E4%B9%A0%E9%A2%98%E4%BA%8C%E8%A7%A3%E7%AD%94%2F</url>
    <content type="text"><![CDATA[为什么程序并发执行会产生间断性特征？程序在并发执行时，由于它们共享系统管理资源，以及为万分同一项任务而相互合作，致使在这些并发执行的程序之间形成了相互制约的关系，而相互制约将导致程序具有“执行——暂停——执行”这种间断性的活动规律，所以说程序并发执行会产生间断性特征。 程序并发执行时为什么会失去封闭性和可再现性？当系统中存在着多个可以并发执行的程序时，系统中的各种资源将为它们所共享，而这些资源的状态也由这些程序来改变，致使其中任一程序在运行时，其环境都必然会受到其他程序的影响，显然，程序的运行已失去了封闭性。而失去封闭性会导致程序失去可再现性。 在操作系统中为什么要引入进程的概念？它会产生什么样的影响?在多道程序环境下，程序的执行属于并发执行，此时它们失去其封闭性，并且具有间断性，以及其运行结果不可再现。这些决定了通常的程序是不能参与并发执行的，否则，程序的运行也就失去了意义。为了能使程序并发执行，并且可以对并发执行的程序加以描述和控制，才操作系统中引入了进程概念. 试从动态性、并发性和独立性上比较进程和程序进程和程序是两个截然不同的概念。 动态性。进程的实质是进程实体的执行过程，因此，动态性是进程的最基本的特征。表现为“由创建而产生，由调度而执行，由撤销而消亡”，进程具有一定的生命期；而程序则只是一组有序指令的集合，并存放于某种介质上，其本身并不具有活动的含义，是静态实体。 并发性是进程的重要特征，同时也是OS的重要特征；而程序是不能参与并发执行的。 独立性是指进程实体是一个能独立运行、独立获得资源和独立接受调度的基本单位（传统OS中）；而对于未建立PCB的程序来说，它不能作为一个独立单位参与运行。 试说明PCB的作用具体表现在哪几个方面，为什么说PCB是进程存在的唯一标志？PCB作为进程实体的一部分，记录了操作系统所需的，用于描述进程当前情况以及管理进程运行的全部信息，是操作系统中最重要的记录型数据结构。 作用是使一个在多道陈存储环境下不能独立运行的程序（包括数据）成为一个能独立运行的基本单位，一个能与其他进程并发执行的进程。 当一个程序（含数据）配置了PCB后，就表示它已是一个能在多道程序环境下独立运行的、合法的基本单位，也就具有取得OS服务的权利。系统时通过PCB感知进程的存在的，所以，PCB已成为进程存在的唯一标志。 PCB提供了进程管理和进程调度所需要的哪些信息？ 进程标识符 处理机状态 进程调度信息 进程状态 进程优先级 进程调度所需的其他信息 事件 进程控制信息 程序和数据的地址 进程同步和通信机制 资源清单 链接指针 进程控制块的组织方式有哪几种？ 线性方式 链接方式 索引方式 何谓操作系统内核？内核的主要功能是是什么？现代操作系统一般将OS划分为若干层次，再将OS的不同功能分别设置在不同的层次中。 通常将一些与硬件紧密相关的模块、各种常用设备的驱动程序以及运行频率较高的模块，都安排在紧靠硬件的软件层次，让它们常驻内存，即OS内核。 OS内核的功能主要是以下两大方面： 支撑功能 中断处理 时钟管理 原语操作 资源管理功能 进程管理 存储器管理 设备管理 试说明进程在三个基本状态之间转换的典型原因 执行状态$\rightarrow$就绪状态：时间片完 就绪状态$\rightarrow$执行状态：进程调度 执行状态$\rightarrow$阻塞状态：I/O请求 阻塞状态$\rightarrow$就绪状态：I/O完成 为什么要引入挂起状态？该状态有哪些性质？引入挂起的原因，是基于系统和用户的如下需要： 终端用户的需要 父进程请求 负荷调节的需要 操作系统的需求 挂起状态的性质是：放弃CPU调度，不接受调度。引入挂起状态后，进程状态转换图增加了活动阻塞、静止阻塞、活动就绪、静止就绪四个状态，并增加了活动就绪与静止就绪，活动阻塞和静止阻塞之间的相互转换。 在进行进程切换时，所要保存的处理机状态信息有哪些？进程进行切换时，需要保存的处理机状态信息有： 进程当前暂存信息 下一指令地址信息 进程状态信息 过程和系统调用参数及调用地址信息 试说明引起进程创建的主要事件 用户登录 作业调度 提供服务 应用请求 试说明引起进程被撤销的主要事件 正常结束 异常结束 越界错 保护错 非法指令 特权指令错 运行超时 等待超时 算术运算错 I/O故障 外界干预 在创建一个进程时所要完成的主要工作是什么？在系统中每当出现了创建新进程的请求后，OS便调用进程创建原语Create按下述步骤创建一个新进程： 申请空白PCB 为新进程分配运行所需的资源 初始化进程控制块 如果进程就绪队列能够接纳新进程，便将新进程插入就绪队列 在撤销一个进程时所要完成的主要工作是什么？如果系统中发生了要求终止进程的某事件，OS便调用进程终止原语，按下述过程去终止指定的进程： 根据被终止进程的标识符，从PCB集合中检索出该进程的PCB，从中读出该进程的状态 若被终止形成正处于执行状态，应立即终止该进程的执行，并置调度标志为真，用于指示该进程被终止后应重新进行调度 若该进程还有子孙进程，还应将其所有子孙进程也都予以终止，以防它们成为不可控进程 将被终止进程所拥有的全部资源或者归还给其父进程，或者归还给系统 将被终止进程（PCB）从所在队列（或链表）移除，等待其他程序来搜集信息 试说明引起进程阻塞或被唤醒的主要事件是什么？ 向系统请求共享资源失败 等待某种操作完成 新数据尚未到达 等待新任务的到达 为什么要在OS中引入线程？在OS中引入线程，是为了减少程序在并发执行时所付出的时空开销，使OS具有更好的并发性。 试说明线程具有哪些属性？ 轻型进程 调度的基本单位 并发性 拥有资源 独立性 系统开销 支持多处理机系统 试从调度性、并发性、拥有资源及系统开销方面对进程和线程进行比较 调度性 在传统的OS中，进程是作为独立调度和分派的基本单位，因而进程是能独立运行的基本单位。在每次调度时，都需要进行上下文切换，开销较大。 在引入线程的OS中，已把线程作为调度和分派的基本单位，因而线程是能独立运行的基本单位。当线程切换时，仅需要保存和设置少量寄存器内容，切换代价远低于进程。在同一进程中，线程的切换不会引起进程的切换，但从一个进程中的线程切换到另一个进程中的线程时，必然会引起进程的切换 并发性 在引入线程的OS中，不仅进程之间可以并发执行，而且在一个进程的多个线程之间亦可并发执行，甚至允许在一个进程中的所有线程都能并发执行。同样，不同进程中的线程也能并发执行。 拥有资源 进程可以拥有资源，并作为系统中拥有资源的一个基本单位。然而，线程本身并不拥有系统资源，而是仅有一点必不可少的、能保证独立运行的资源 线程除了拥有自己的少量资源外，还云溪多个线程共享该进程拥有的资源。 系统开销 在创建或撤销进程时，系统都要为之分配和回收进程控制块、分配或回收其他资源。OS为此所付出的开销，明显大于线程创建或撤销时所付出的开销。类似地，在进程切换时，涉及到进程上下文的切换，而线程的切换代价也远低于进程的。 线程控制块TCB中包含了哪些内容？ 线程标识符 一组寄存器 线程运行状态 优先级 线程专有存储区 信号屏蔽 堆栈指针 何谓用户级线程和内核支持线程？ 用户级线程：用户级线程是在用户空间中实现的。对线程的创建、撤销、同步与通信等功能，都无需内核的支持，即用户级线程是与内核无关的。 内核支持线程：是在内核的支持下运行的，它们的创建、阻塞、撤销和切换等，都是在内核空间实现的 试说明用户级线程的实现方法用户级线程是在用户空间中的实现的，运行在“运行时系统”与“内核控制线程”的中间系统上。运行时系统用于管理和控制线程的函数的集合。内核控制线程或轻型进程LWP可通过系统调用获得内核提供服务，利用LWP进程作为中间系统。 试说明内核支持线程的实现方法系统在创建一个新进程时，便为它分配一个任务数据区PTDA，其中包括若干个线程控制块TCB空间。在每个TCB中可保存线程标识符、优先级、线程运行的CPU状态信息。每当进程要创建一个线程时，便为新线程分配一个TCB，将相关信息填入该TCB中，并为之分配必要的资源；当PTDA中的所有TCB空间已用完，而进程又要创建新的线程时，只要其所创建的线程数目未超过系统允许值，系统可再为之分配新的TCB空间；在撤销一个线程时，也应回收该线程的所有资源和TCB。 多线程模型有哪几种类型？多对一模型有何优缺点？由于用户级线程和内核级线程连接方式的不同，从而形成了三种不同的模型： 多对一模型 一对一模型 多对多模型 多对一模型的优点： 线程管理的开销小，效率高 多对一模型的缺点： 如果一个线程在访问内核时发生阻塞，则整个进程都会被阻塞 在任一时刻，只有一个线程能访问内核，多个线程不能同时在多个处理机上运行]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>习题解答</tag>
        <tag>线程</tag>
        <tag>进程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ASP.NET Core MVC 视图与控制器传值]]></title>
    <url>%2F2019%2F06%2F17%2F%E8%A7%86%E5%9B%BE%E4%B8%8E%E6%8E%A7%E5%88%B6%E5%99%A8%E4%BC%A0%E5%80%BC%2F</url>
    <content type="text"><![CDATA[一、form表单传值 View页面：GetFormValue.cshtml12345678&lt;h1&gt;GetFormValue&lt;/h1&gt;&lt;form asp-action="Home/GetFormValue" method="post"&gt; &lt;div&gt; &lt;input type="text" name="name" placeholder="名字" /&gt; &lt;/div&gt; &lt;button id="submit" type="submit"&gt;提交&lt;/button&gt;&lt;/form&gt; 在这个form表单中，用asp-action=&quot;Home/GetFormValue&quot;指定了表单中的值需要传到什么地方，其中Home代表控制器，GetFromValue代表Action。 Action: GetFormValue12345678910public IActionResult GetFormValue() &#123; return View(); &#125; [HttpPost] public IActionResult GetFormValue(string name) &#123; return View(); &#125; GetFormValue用来接受从视图传过来的值，这次传的是名字。 页面输入 传值结果 二、JS传值 视图页面：GetJsValue.cshtml12345678910111213141516&lt;h1&gt;GetFormValue&lt;/h1&gt;&lt;div&gt; &lt;input id="testdata" type="text"/&gt; &lt;input id="submitButton" type="button" value="提交" /&gt;&lt;/div&gt;&lt;script &gt; var button = document.getElementById('submitButton'); button.onclick = function () &#123; var data = $('#testdata').val(); $.post("Home/GetJsValue", &#123; name: data &#125;, function () &#123; alert("submit data success!"); &#125;); &#125;&lt;/script&gt; Action：GetJsValue123456789public IActionResult GetJsValue() &#123; return View(); &#125; [HttpPost] public IActionResult GetJsValue(string name) &#123; return View(); &#125; 页面输入 传值结果 三、Jquery AJAX方法传值 视图页面：GetJqueryValue.cshtml123456789101112131415161718192021222324&lt;h1&gt;GetJqueryValue&lt;/h1&gt;&lt;div&gt; &lt;input id="testdata" type="text" /&gt; &lt;input id="submitButton" type="button" value="提交" /&gt;&lt;/div&gt;&lt;script type="text/javascript" src="~/js/jQuery.form.js"&gt;&lt;/script&gt;&lt;script type="text/javascript" src="~/js/jquery-1.12.4.min.js"&gt;&lt;/script&gt;&lt;script&gt; $("#submitButton").click(function () &#123; var name = $("#testdata").val(); $.ajax(&#123; type: 'post', url:'/Home/GetJqueryValue', data: &#123; "name": name &#125;, success: function (data) &#123; alert("submit success"); &#125;, error: function (data) &#123; alert("failed"); &#125; &#125;) &#125;);&lt;/script&gt; 在使用jquery的ajax方法传递数据的时候，会出现not defined错误，网上查了一圈也没有解决，最后用上面的方式解决了。 Action:GetJqueryValue123456789public IActionResult GetJqueryValue() &#123; return View(); &#125; [HttpPost] public IActionResult GetJqueryValue(string name) &#123; return View(); &#125; 页面结果 传值结果 四、模型绑定模型绑定就是将表单中的传递来的数据，创建对应的model并把数据赋给model的属性。我们能看到的就是表单传过来的数据是一个对象。 需要注意的是，传递每一项数据的名称和接受的类的属性名称必须相同。 Aoki类：1234567public class Aoki &#123; [Required(ErrorMessage = &quot;尚有未填写项，请先完善&quot;)] public string name &#123; get; set; &#125; [Required(ErrorMessage = &quot;尚有未填写项，请先完善&quot;)] public string description &#123; get; set; &#125; &#125; 对于Aoki类，我添加了模型验证，Required就是说这个属性不能为空，当表单中这个数据没有填写的时候，是无法提交的。当然，我觉得前端的验证有浏览器完成比较好一些。 视图页面：GetModelValue.cshtml1234567891011&lt;h1&gt;GetModelValue&lt;/h1&gt;&lt;form asp-action="Home/GetModelValue" method="post"&gt; &lt;div&gt; &lt;input type="text" name="name" placeholder="名字" /&gt; &lt;/div&gt; &lt;div&gt; &lt;input type="text" name="description" placeholder="描述" /&gt; &lt;/div&gt; &lt;button id="submit" type="submit"&gt;提交&lt;/button&gt;&lt;/form&gt; 这里要注意的是，name必须和原有对象的属性名相同。 Action:GetModelValue123456789public IActionResult GetModelValue() &#123; return View(); &#125; [HttpPost] public IActionResult GetModelValue(Aoki aoki) &#123; return View(); &#125; 在第二个Action中会收到前端传过来的一个对象，这个对象的属性是和前端页面中表单中填写的数据绑定的。 页面输入： 传值结果： 五、定位标记帮助程序标记帮助程序使服务器端代码可以在Razor文件中参与创建和呈现HTML元素。在下面的代码中，AnchorTagHelper从控制器操作方法和路由ID动态生成HTMLhref特性值。 视图页面：GetNum.cshtml1234567891011121314151617181920&lt;h1&gt;GetNum&lt;/h1&gt;&lt;table border="1"&gt; &lt;tr&gt; &lt;th&gt;名字&lt;/th&gt; &lt;th&gt;描述&lt;/th&gt; &lt;th&gt;操作&lt;/th&gt; &lt;/tr&gt; &lt;tr&gt; &lt;th&gt; Aoki &lt;/th&gt; &lt;th&gt; 试举头，一笑问青天、天无语 &lt;/th&gt; &lt;th&gt; &lt;a asp-action="GetNum" asp-controller="Home" asp-route-ID="1"&gt;查看&lt;/a&gt; &lt;/th&gt; &lt;/tr&gt;&lt;/table&gt; 这里需要注意的是asp-action、asp-controller、asp-route-ID是生成URL。在asp-route-ID中值得注意的是，这里面的ID就是传递的参数，控制器里面的参数名字是什么，这里的ID就换成什么。否则会出错 Action:GetNum1234public IActionResult GetNum(int ID) &#123; return View(); &#125; 页面结果 鼠标悬停在查看按钮上，下方会出现URL。如图所示。 在浏览器中“查看源”，生成的HTML的部分如下如图所示。 传值结果 &emsp;&emsp;获得源码]]></content>
      <categories>
        <category>ASP.NET Core MVC</category>
      </categories>
      <tags>
        <tag>ASP.NET Core</tag>
        <tag>视图与控制器</tag>
        <tag>传值</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ASP.NET Core MVC控制器与视图传值]]></title>
    <url>%2F2019%2F06%2F16%2FASP-NET-Core-MVC%E6%8E%A7%E5%88%B6%E5%99%A8%E4%B8%8E%E8%A7%86%E5%9B%BE%E4%BC%A0%E5%80%BC%2F</url>
    <content type="text"><![CDATA[一、传值方式 弱类型参数传递数据 强类型参数传递数据 二、弱类型参数传递数据 ViewData1）派生自ViewDataDictionary，因此它有可用的字典属性，如，ContainsKey、Add、Remove、Clear &emsp; 2）字典中键是字符串，所以允许有空格 &emsp; 3）任何非string类型均须在试图中进行强制转换才能使用ViewData ViewBag1）派生自DynamicViewData，因此它可使用点表示法（ViewBag.name=name)创建动态属性，且无需强制转换 2) ViewBag的语法使控制器到视图的速度更快 3) ViewBag更易于检查NULL值 3. ViewData的使用1）创建Action：Index 123456public IActionResult Index() &#123; ViewData[&quot;name&quot;] = &quot;Aoki&quot;; ViewData[&quot;description&quot;] = &quot;试举头，一笑问青天、天无语&quot;; return View(); &#125; 2）创建视图：Index.cshtml 1234&lt;div class="text-center"&gt; &lt;h1&gt;@ViewData["name"]&lt;/h1&gt; &lt;p&gt;@ViewData["description"]&lt;/p&gt;&lt;/div&gt; 3）实现结果： 4. ViewBag的使用1）创建Action：Index \ASP-NET-Core-MVC控制器与视图传值 1234567public IActionResult Index() &#123; ViewBag.type = &quot;ViewBag&quot;; ViewBag.name = &quot;Aoki&quot;; ViewBag.description = &quot;试举头，一笑问青天、天无语&quot;; return View(); &#125; 2）创建视图：Index.cshtml 12345&lt;div class="text-center"&gt; &lt;h1&gt;@ViewBag.name&lt;/h1&gt; &lt;p&gt;@ViewBag.description&lt;/p&gt; &lt;h4&gt;Pass the value through @ViewBag.type&lt;/h4&gt;&lt;/div&gt; 3）实现结果 三、强类型参数传递数据 强类型参数说明&emsp;&emsp;视图强类型通常称为ViewModel，可以在return View();时指定参数/对象。并在视图文件（.cshtml）中通过@model语法来指定对应的类型。 强类型参数示例1）创建Aoki类 12345public class Aoki &#123; public string name &#123; get; set; &#125; public string description &#123; get; set; &#125; &#125; 2）创建Action：Index 123456789public IActionResult Index() &#123; var aoki = new Aoki &#123; name = "Aoki", description = "试举头，一笑问青天、天无语" &#125;; return View(aoki); &#125; 3）创建视图：Index.cshtml 1234&lt;div class="text-center"&gt; &lt;h1&gt;@Model.name&lt;/h1&gt; &lt;p&gt;@Model.description&lt;/p&gt;&lt;/div&gt; 4）实现结果]]></content>
      <categories>
        <category>ASP.NET Core MVC</category>
      </categories>
      <tags>
        <tag>ASP.NET Core</tag>
        <tag>MVC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[软件管理]]></title>
    <url>%2F2019%2F06%2F16%2F%E7%AE%A1%E7%90%86%2F</url>
    <content type="text"><![CDATA[一、软件过程改进模型CMMI软件组织的产品质量和服务质量，来自组织内部的过程改进状态。而过程改进是要有模型的，模型是实践、理论、方法、经验和技术的结晶，是软件组织的一种企业文化、工作环境和管理理念；模型能够引导企业从杂乱无章的管理状态到有条不紊的管理状态。 目前为止，IT企业界的过程管理和过程改进模型共有三个类型： ISO 9001 模型 CMMI模型 软件企业文化模型 微软企业文化 IBM企业文化 敏捷文化现象 CMMI是什么软件能力成熟度模型CMMI是由美国卡内基-梅隆大学软件工程研究所推出的评估软件能力与成熟度等级的一套标准。 CMMI的作用是什么 软件组织，用它来不断改进自身的软件过程管理能力 评估机构，用它来评估某软件组织当前软件能力成熟度级别 客户，用它来评估某承包商的软件能力 CMMI的实质 以“过程”为核心，抓软件组织的管理，即软件“组织”的过程改进 以“项目”为手段，抓团队开发过程的“活动”，即落实过程改进的措施 以“活动”记录为基础，抓软件过程的“度量”，即“度量”软件组织改进的情况 CMMI阶段模型的成熟度等级 CMMI等级 PA数目 管理特点 ML1:初始级 0 过程不可预测且缺乏控制 ML2：已管理级 7 过程为项目服务，即项目级管理 ML3：已定义级 11 过程为组织服务，即组织级管理 ML4：定量管理级 2 过程已度量和控制，即定量级管理 ML5：优化级 2 集中于过程改进，即优化管理级 ISO 9001与CMMI的联系和区别&emsp;&emsp;与ISO 9001标准相比，CMMI更为软件产业所看好。原因是CMMI专门针对软件工程控制而设置。它不仅进行软件企业工程能力的评估，更致力于软件开发过程的管理，强调对软件开发过程进行持续改进，引导软件开发过程走向成熟。 &emsp;&emsp;两者的相同点是：CMMI和ISO 9001标准都致力于质量和过程管理，都是为了解决同样的问题。 &emsp;&emsp;两者的不同点是：CMMI是动态的、开放的和持续改进的，它强调“没有最好，只有更好”，强调不断改进，强调人在软件开发方面的主动性，非常适用于软件过程改进；ISO 9001是静态的质量控制，只要达到20个关键指标或过程，就能完成质量控制，它更适用于硬件制造行业和第三产业的质量控制。CMMI与IO 9001的设计思路有差异：CMMI是“专用的”，ISO 9001是“通用”的。ISO 9001不覆盖CMMI，CMMI也不覆盖ISO 9001. 二、软件配置管理软件配置管理SCM是对软件开发过程中配置项的一组追踪和控制活动，它开始于软件开发之初，结束于软件淘汰之时。 三、软件质量保证软件质量保证SQA是一个过程，是CMMI和ISO 9001的重要议题，同样也是项目管理的重要议题。 软件质量，是供方提供的软件产品满足用户明确或隐含需求的能力特性的总和。 质量管理的三大支柱 质量标准 配置管理 测试测量 质量管理的三大要素 SQA计划 SQA进度 SQA评审和审计 四、软件项目管理 什么是项目项目，是一次性的多任务工作，它具有确定的开始日期，结束日期，工作范围，经费预算，质量标准，以及特定的功能、性能和接口要求。 什么是项目管理项目管理，是为了实现项目目标，运用相关知识、技能、方法与工具，对项目的计划、进度、质量、成本、资源进行管理和控制的活动。 项目经理的七项职责 抓需求获取与确认 抓计划制订与执行 抓团队分工与协作 抓后勤供应与保障 抓产品测试和交付 抓开发标准与规范 抓员工考核与奖励 项目经理对程序员的八项要求 团队协作精神的训练和要求 数据库和数据结构分析与设计能力的训练和要求 书写文档习惯的训练和要求 规范化代码编写能力的训练和要求 复用性能力与构件技术的训练和要求 测试习惯的训练和要求 学习和总结能力的训练和要求 引导程序员由“丑小鸭”变成“白天鹅”]]></content>
      <categories>
        <category>软件工程</category>
      </categories>
      <tags>
        <tag>CMMI</tag>
        <tag>软件管理</tag>
        <tag>项目管理</tag>
        <tag>软件质量保证</tag>
        <tag>项目经理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[软件实施与维护]]></title>
    <url>%2F2019%2F06%2F16%2F%E5%AE%9E%E6%96%BD%E4%B8%8E%E7%BB%B4%E6%8A%A4-1%2F</url>
    <content type="text"><![CDATA[一、软件产品 软件企业开发的软件可以分为软件项目和软件产品。 软件产品分为三类分别是： 类别 产品特点 举例 1 不需要客户化的产品 系统软件 2 只需要少量客户化工作的产品 专业性特强的应用软件产品 3 需要重新做业务流程规范和需求规格定义的软件产品 分行业ERP 项目与产品的区别与联系 除了上述三类软件产品外，其他软件一般称为软件项目，不能叫软件产品。 软件项目就是为用户定制的软件系统，它的专业性强，通用性差，从需求分析、设计、编码、测试，到安装、试运行、正式运行，直至验收交付，整个开发流程一步都不能省。 软件项目的特点是，业务领域知识所占比重大，工程性强，因此用CMMI模型实现规范化管理和量化控制比较适合。IT企业做软件项目的目的，一般都是为了将软件项目逐步产品化，如同做财务项目是为了做财务产品一样。一方面，只有产品化了才能赚取最大的利润，另一方面，只有拥有自己的软件产品，才能在投标活动中获得更大更好的项目。 项目和产品既有显著的不同，又有紧密的关系。这种关系是：做软件项目是手段，做软件产品是目的，软件项目做多了，软件项目就慢慢变成了软件产品。 二、软件产品的发布&emsp;&emsp;产品的发布时机，是由市场利润、开发进度、产品的功能与质量、客户可接受程度等多方面因素决定的。 三、软件产品的实施软件产品发布以后，销售中心就会获取各种客户信息，并准备用各种方式为客户服务。在服务中，需要各种销售技术人员的支持，这些技术人员包括售前、售中、售后三部分人员。售前技术人员称为售前工程师，售中技术人员称为实施工程师，售后技术人员称为维护工程师。 四、软件维护的传统方法软件维护，是指软件项目或产品爱安装、运行并交付给用户使用后，在新产品升级之前这段时间里，软件厂商向客户提供的服务工作。 软件维护的分类 序号 维护的种类 维护的内容 1 纠错性维护 产品或项目中存在缺陷或错误，在测试和验收时未发现，到了使用过程中逐渐暴露出来，需要改正。 2 适应性维护 这类维护是为了产品或项目适应变化了的硬件、系统软件的运行环境，如系统升级 3 完善性维护 这类维护是为了给软件系统增加一些新的功能，使产品或项目更加完善与合理，又不至于对系统进行伤筋动骨的改造，这类维护占维护的大部分 4 预防性维护 这类维护是为了提高产品或项目的可靠性和可维护性，有利于系统的进一步改造或升级换代 软件维护的副作用 序号 维护的方式 副作用的表现 1 修改编码 使编码更加混乱，程序结构更不清晰，可读性更差，而且会有连锁反应 2 修改数据结构 数据结构是系统的骨架，修改数据结构是对系统伤筋动骨的大手术，在数据冗余与数据不一致方面，可能顾此失彼 3 修改用户数据 需要与用户协商，一旦有疏忽，可使系统发生意外 4 修改文档 对非结构化维护不适应，对结构化维护要严防程序与文档的不匹配 五、软件维护的最新方法 软件维护的最新分类方法 面向缺陷维护——程序级维护 面向功能维护——设计级维护 软件维护的最新方法 基于两层结构（客户机/服务器）划分软件维护的方法 基于三层结构划分软件维护的方法 基于“三种开发方法”，来划分软件维护的方法 软件维护工作流程 流程步骤 流程内容 1 分类整理用户意见 2 提出维护申请 3 评审、审计、批准维护申请 4 修改需求文档 5 维护需求文档评审 6 维护设计文档 7 维护设计文档评审 8 修改源程序 9 回归测试 10 修改软件版本号 11 交付用户运行 12 收集用户反馈意见，准备进行新一轮维护活动，转向流程第1个步骤]]></content>
      <categories>
        <category>软件工程</category>
      </categories>
      <tags>
        <tag>软件维护</tag>
        <tag>软件产品</tag>
        <tag>软件项目</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[软件设计、实现与测试]]></title>
    <url>%2F2019%2F06%2F15%2F%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E3%80%81%E5%AE%9E%E7%8E%B0%E3%80%81%E6%B5%8B%E8%AF%95%2F</url>
    <content type="text"><![CDATA[一、软件设计 三层结构设计1）表示层：也称浏览层，通常采用图形化界面，在客户端PC或工作站上运行。站在“三个模型”的思想上看，系统内部支持表示层的模型是“功能模型”。 &emsp;表示层的主要功能： &emsp;1)接受用户请求，将这些请求反馈给业务逻辑层，等待业务逻辑层的应答信息。 &emsp;2）对业务逻辑层的应答信息进行显示 &emsp;3）有时会兼做一些业务逻辑层的小功能 2）中间层（业务层）：它由许多构件和组件组成，它们完全体现了用户的业务逻辑或业务规则，站在“三个模型”建模思想上看，系统内部支持业务层的模型是“业务模型”。 &emsp;业务层的主要功能： &emsp;1）接受从表示层传来的用户请求信息 &emsp;2）根据用户的请求信息生成SQL语句 &emsp;3)利用生成的SQL语句从数据层取数据、修改数据、删除数据 &emsp;4）将结果返回表示层 中间层也可以分为两个子层，分别是业务逻辑层和数据访问层。 在这段时间的信息系统设计中我深有体会，将虽然三层结构从一定程度上可以降低系统的耦合度，但是如果数据层出现问题，需要进行调整，那么中间层也要进行大规模的调整，这对系统的实现进度是有害的。如果将中间层划分为两个子层，那么，如果数据层出现问题，进行了大规模调整，那么我们的业务逻辑层是不会受到影响的，只需要对数据访问层进行适当的修改。 3）数据层：是数据库服务器上的数据库层，它包括数据库管理系统DBMS和数据库DB两部分。站在“三个模型”建模思想上看，系统内部支持数据层的模型是“数据模型”。 &emsp;数据层的功能： &emsp;1）接受业务层数据处理请求的SQL语句或存储过程 &emsp;2）利用SQL语句或存储过程，对数据库服务器上数据库的相关表进行存储或检索 &emsp;3）将存储或检索的结果传递给业务层。 软件设计原理软件设计原理，就是各种软件设计方法中都应该遵守的共同基本原理。这些原理包括：抽象、模块化、信息隐藏、模块独立性、封装、接口和实现分离。 1）抽象。 在每个阶段中，抽象的层次逐步降低，在软件结构设计中的模块分层也是由抽象到具体分析和构造出来的。抽象就是将几个有区别的物体的共同性质或特性，形象地抽取出来，独立地进行考虑的过程。 常用的抽象技术有：控制抽象、过程抽象、数据抽象 2）模块化。 模块指程序中的数据说明、可执行语句等程序对象的集合，或单独命名和编程的元素。 模块化，就是解决一个复杂问题时，自顶向下、逐步求精地把软件系统划分为若干模块的过程。为了解决复杂的问题，在软件设计中，必须把整个问题分解来降低复杂性，以减小开发工作量，降低开发成本，提高软件生产率。但是模块并不是越多越好，因为这会增加模块之间的接口量。所以划分模块的层次和数量应该避免过多或过少。 3）信息隐藏。 信息隐藏，指在设计和确定模块时，使一个模块内包含的信息，对于不需要这些信息的其他模块来说是不能访问的。 4）模块独立性。 模块独立性指每个模块只完成系统要求的独立的子功能，并且与其他模块的联系最少，且接口简单。模块独立性是抽象、模块化、信息隐藏的直接产物，在概要设计的过程中，就是要设计出具有良好模块独立性的软件结构。用来衡量软件模块独立性的定性度量标准有：高内聚、低耦合 5）封装。 封装是将信息隐藏在一个实体中，使其内部细节对外不可见。封装是实现“低耦合、高内聚”的技术手段之一。要进行正确的封装，必须遵守的原则是： 实体间相互隐藏内部实现 尽量减少全局的共享数据 6）接口和实现分离 将接口与实现分离，对外只提供接口，隐藏具体的实现。接口与实现的分离，保证了实现的独立变化，降低了模块间的耦合。 二、三种设计方法 面向过程设计1）面向过程概要设计的主要方法有： 功能模块分解方法 功能模块调用方法 功能模块转化方法 数据流图转换为层次结构图方法 2）面向过程设计技术，采用“自顶向下、逐步求精”的设计方法和“单入口、单出口”的控制结构，并且只包含顺序、选择和循环三种结构，设计目标之一是使程序的控制流程线性化，即程序的动态执行顺序符合静态书写结构。 3）详细设计的工具有：程序流程图、N-S图、程序设计语言PDL、PAD图等 面向对象设计面向对象设计描述工具： 1）系统静态建模图（结构图） 类图 部件图 部件图比类图在更高层次上体现了系统中部件、部件接口以及部件之间的关系。 部署图 表示运行时处理元素（节点）的物理配置情况。 界面图 2）系统动态建模（行为图） 用例图 顺序图 &emsp;&emsp;顺序图是系统的动态视图，表示系统基于时间序列的操作。在顺序图中可以包括与系统交互的角色。顺序图以一个二维视图展现交互过程，垂直方向上是时间轴，水平方向上是参与交互的对象或角色。 &emsp;&emsp;顺序图是类图的补充，类图是系统的静态视图，顺序图反映了系统的动态视图。通常先绘制用例图，接着根据用例图中涉及的实体绘制类图，再绘制顺序图来展现用例的交互过程。 状态图 &emsp;&emsp;状态图是状态机图形化的表现，用于描述用例、部件或类的行为。状态图对实体的有限状态、事件和状态间的转换进行建模。 活动图 &emsp;&emsp;活动图描述的是执行某个功能的活动。 面向元数据设计&emsp;&emsp;面向元数据设计，以实体-关系模型为基础，按照一定的规则将概念模型CDM转换成为能被某种数据库管理系统接受的物理数据模型PDM，创建物理上的数据库表、索引和视图，并且用存储过程和触发器来实现各种业务规则。 三、软件实现 构件：就是被标识的且可被复用的软件制品。 中间件：是一个非常大的组件（构件），一般在网络上运行，完成批量数据的传递和通信工作，调用方式是通过一组事先约定的格式与参数进行的。 软件实现原则 尽可能简单。在软件实现过程中，应创建简单、容易阅读的代码；相同功能的代码只写一次；简单的代码易于维护；通过采用一些编码规范和标准，可以有效地降低代码的复杂度。 易于验证。无论是在编码、测试和实际操作中，软件工程师应该很容易发现其中的错误；自动化的单元测试可产生易于验证的代码；写代码时，要限制使用复杂的难以理解的语言结构 适应变化。外部环境、软件需求和软件设计，在整个开发过程中可能会随时发生变化，因此要求软件实现时考虑适应这些变化 遵守某一编程规范。尽量使用了标准库函数和公共函数。不要随意定义全局变量，尽量使用局部变量。使用括号避免二义性。 选择项目组成员最熟悉的工具或语言。 除此之外，除了特殊要求之外，任何程序必须遵守”可读性第一、效率第二“的实现原则。 四、软件测试在另外的一些文章或资料中有所涉及和详细解释。]]></content>
      <categories>
        <category>软件工程</category>
      </categories>
      <tags>
        <tag>软件设计</tag>
        <tag>软件实现</tag>
        <tag>三层结构</tag>
        <tag>软件设计原理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[软件建模]]></title>
    <url>%2F2019%2F06%2F15%2F%E8%BD%AF%E4%BB%B6%E5%BB%BA%E6%A8%A1%2F</url>
    <content type="text"><![CDATA[一、三个模型的建模思想 功能模型功能模型，实质上是用户需求模型，用来描述系统能做什么，即对系统的功能、性能、接口和界面进行定义。 从用户角度来看，功能模型就是系统功能需求列表 从设计者的角度看，功能模型就是系统内部功能模块的有机排列和组合 从Rose的角度上看，功能模型就是系统的用例的集合 从产品的角度看，功能模型就是系统的用户操作手册 从操作界面的角度上看，功能模型就是系统的功能菜单 从B/A/S的角度上看，功能模型就对应在浏览层上建模 业务模型业务模型，实质上是业务逻辑模型，用于描述系统在何时、何地、由何角色、按什么业务规则去做、以及做什么的流程或步骤，即对系统的操作流程进行定义。 业务模型反映了系统的业务行为，是算法设计的主要依据。站在B/A/S的角度上看，业务模型就对应在中间层（业务逻辑层或业务应用层）上建模。 数据模型数据模型实质上是实体或类的状态关系模型，用于描述系统工作前的数据来自何处、工作中的数据暂存在什么地方、工作后的数据放到哪儿、以及这些数据的状态及相互之间的关联，即对系统的数据结构进行定义。 二、数据模型设计 什么是好的数据模型？条件有三： 1）满足功能需求 2）满足性能需求 3）该模型能够长期使用，也就是“以不变应万变 数据库的基本表、代码表、中间表和临时表存放元素数据的表，称为基本表 存放信息代码的表，称为代码表 存放统计信息的表，称为中间表（又称查询表） 存放临时数据的表，称为临时表 基本表的4个特性：1）原子性：基本表中的字段是不可再分解的。 2）原始性：基本表中的记录是原始数据记录。 3）演绎性：由基本表与代码表中的数据可以派生出所有的输出数据。 4）稳定性：基本表的结构是相对稳定的，表中的记录需要长期保存。 数据库设计的步骤：1）将原始单据分类整理，理清原始单据与输出数据之间的数据转换关系和算法，澄清一切不确定的问题。 2）从原始单据出发，划分出各个实体，给实体命名，初步分配属性，标识出主键或外键，理清实体之间的关系。 3）进行数据库概念数据模型设计，画出实体关系图ERD，定义完整性约束 4）进行数据库物理数据模型PDM设计，将概念模型CDM转换为物理数据模型PDM 5）在待定对的数据库管理系统上定义表空间，实现物理建表与建索引 6）定义触发器与存储过程 7）定义视图，说明数据库与应用程序之间的关系 8）数据库加载测试：向基表中追加记录，对数据库的功能、性能进行全面测试 9）数据库性能优化：从数据库系统的参数配置、数据库设计的反规范化两个方面，对数据库的性能进行优化 10）数据库设计评审：从数据库的整体功能和性能两个方面，请同行专家评审评价 三、数据库设计理论与方法 数据库范式理论1NF，关系模式中的关系的每个分量都是不可再分的数据项 2NF，满足1NF，且每一非主属性完全函数依赖于候选键 3NF，消除非主属性对候选键的传递依赖 数据库设计中的“第三者插足”设计模式当两个实体之间存在多对关系时，必须在它们之间插入第三个实体，以化解这种多对多关系。 数据库设计中的“列变行”模式就是将第一个表中的某些列，变为第二个表中的某些行。 数据库设计中的四个原子化理论站在数据库设计者的角度看，只要实现属性原子化、实体原子化、主键原子化、联系原子化，数据的所谓更新异常、插入异常、删除异常、数据冗余现象就从根本上消除了。 属性原子化：实体的属性本身不能再分解 实体原子化：实体本身不能再分解 主键原子化：是指实体的主键本身是一个ID（identifier） 联系原子化：是指实体之间的联系都是一对多联系。]]></content>
      <categories>
        <category>软件工程</category>
      </categories>
      <tags>
        <tag>软件建模</tag>
        <tag>功能模型</tag>
        <tag>数据库设计</tag>
        <tag>范式理论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[软件需求分析]]></title>
    <url>%2F2019%2F06%2F15%2F%E8%BD%AF%E4%BB%B6%E9%9C%80%E6%B1%82%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[写在前面&emsp;需求分析的输入是软件的《合同》或《立项建议书》，以及对用户现场的调研、分析和确认，输出是《用户需求报告》。 一、需求分析是什么？&emsp;在对需求分析进行了解之前，得知道需求分析是什么。 &emsp;需求分析的定义如下： 用户解决问题或达到目标所需的条件或能力 系统或系统部件要满足合同、标准、规范或其他正式文档规定所需具有的条件或能力 一种反映1或2所描述的条件或能力的文档说明 &emsp;我对需求分析的定义时理解是，需求分析中的文档说明起到了至关重要的作用。 &emsp;当然对于一个软件系统来说，前期的需求分析是十分重要的，这几乎可以决定软件系统开发的成败。 二、需求获取的三原则&emsp;所谓需求获取，就是开发者与用户共同提取并共同确认需求。“划分、抽象、投影”是需求获取的三要素。 划分，就是捕获问题空间的“整体/部分”关系。 抽象，就是捕获问题空间的“一般/特殊”或“一般/特例”关系。 投影，就是捕获问题空间的多维”视图“。 &emsp;我对这三原则的理解可能欠妥，但这是我在学习过程中的一些想法。首先，划分，就是将整个系统进行划分，将复杂的系统划分为小系统，这样不仅可以简化系统分析的难度，同时，由于对其进行了划分，所以在需求分析的时候，能够对系统的需求细节进行完善。 &emsp;其次是抽象，对于一个软件系统，能够实现功能的复用性是再好不过了，那么就需要对需求中的“特殊”扩展泛华为“一般”，依次来实现复用。 &emsp;最后是投影，程序的实质是对现实世界的投影，是对现实世界中不同角色工作流程或工作业务的抽象处理，而对于一个系统来说，操作它的可能有三种角色，比如，高层领导，中层管理和基层操作人员。而这三种角色的业务流程和工作业务是不同，需要从三维视图进行分析。 三、需求分析的任务是什么？ 画出目标系统的组织结构图，列出各部门的岗位角色表，即组织机构模型。 画出目标系统的业务操作流程图，即业务模型。 画出目标系统的数据流图，即单据和报表的流图，掌握业务规则，获得初步的数据模型 列出目标系统的功能点列表，即功能模型。 列出系统的性能点列表，即性能模型。 确定目标系统的接口列表，即接口模型 确定目标系统的运行环境，即环境模型 目标系统的界面约定，即界面模型 对目标系统的开发工期、费用、开发进度、系统风险等问题进行分析和评估。 四、面向流程分析&emsp;需求分析是面向流程的，而流程是动态的、实时的。系统的功能、性能、接口、界面都是在流程中反映出来的。在所有的流程中，数据流最为很重要，同时也最具代表性。因为在计算机网络系统中，一切流程都表现为数据流。所以，面向流程分析，实质上是面向数据流程分析或面向数据分析。计算机网络只认识数据，其他所有信息必须转化为数据之后才能流动，所以面向流程分析本质上是面向数据流程分析。 五、需求分析的方法有哪些？&emsp;业界存在三种需求分析方法，分别是：面向功能分析、面向对象分析、面向数据分析。 &emsp;面向功能分析，是将软件需求看做一棵倒置的功能树，树根在上，树枝与树叶在下，每个节点都是一项具体的功能，从上到下，功能由粗到细，树根是总功能，树叶是细功能，整棵树就是一个信息系统的全部功能树。功能分析体现了“自顶向下，逐步求精”的思想，适合于“结构化分析、结构化设计、结构化编程、结构化测试、结构化组装、结构化维护”的传统式软件工程思想。 &emsp;面向对象分析，实质上是面向类分析，它也从系统的基本功能入手，或从与系统有关的人和事入手，将所有的功能需求找出来，然后将每一项功能对应一个对象集（类），分析每个对象集的属性、方法和包装方式，最后归并为相同对象集，删除冗余属性，用类与类之间的关联来表示所有的需求。 &emsp;面向数据分析，是面向元数据和中间数据分析。 六、需求分析的描述工具有哪些？ 面向元数据的需求描述工具 实体关系图 面向过程的需求描述工具 数据流图DFD、数据字典DD 面向对象的需求描述工具 用例图、类图、]]></content>
      <categories>
        <category>软件工程</category>
      </categories>
      <tags>
        <tag>需求分析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[软件生命周期模型]]></title>
    <url>%2F2019%2F06%2F15%2F%E8%BD%AF%E4%BB%B6%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E6%A8%A1%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[写在前面&emsp;开发一个软件项目，首先要选择并确定一个适合于该项目的软件生命周期模型，然后按照该软件生命周期模型的开发路线图，进行开发。 软件生命周期模型是指在整个软件生命周期中，软件开发过程应遵循的开发路线图。或者说，软件生命周期模型是软件开发全部过程、活动和任务的结构框架。 软件生命周期的9个阶段1）立项（或签订合同）、下达任务书 2）需求分析 3）概要设计 4）详细设计 5）编码实现 6）软件测试 7）软件发布与实施 8）软件维护 9）版本更新或退役 软件生命周期模型有哪些？瀑布模型、增量模型、原型模型、迭代模型、螺旋模型、喷泉模型、XP模型 瀑布模型是什么？具体的详细定义不再展开。 分为5个阶段：需求、设计、编码、测试、发布。自上而下。 首先，我们需要知道，瀑布模型师最早的软件生命周期模型，时至今日，仍然有强大的生命力，也是唯一被广泛使用的软件开发模型。 项目经理或软件管理人员，只要控制好每级台阶的高度和宽度，在每级台阶处设立里程碑或基线，并组织好对基线的评审，就可以控制好项目的开发成本、进度和质量。 但是，该模型的问题就在于阶梯，瀑布只能向下流，需要向上流的时候就需要付出很大的代价。这就是它的“问题堆积”，错误或发散扩大。 该模型的“问题堆积”并不是不可解决的，只要采用适合的管理方法，就可以控制或避免。比如微软公司采用的严格的里程碑管理制度。 增量模型是什么？增量模型是遵循递增方式来进行软件开发的。 在增量模型中，软件产品被看成了一组增量构件或模块。每次需求分析、设计、实现、集成、测试和交付一块构件。 对于一个复杂的大型系统，采用分解的方式来将大系统分解成小系统，这样虽然可以将大风险分解成多个小风险，并逐步消除小风险。但是，将一个复杂的大型系统进行合理、有效的分解和划分是最难的地方。 同时，对大系统进行有效的分解和划分的前提是，该复杂系统可被分解。若复杂系统的拆卸性和组装性不强，那么，增量模型就不再适合该复杂系统的开发。 原型模型原型模型的本意是在初步需求分析后，立马就向用户展示一个软件产品原型。 原型模型开发的过程中始终是以原型来驱动的，这很适合于那些已经有软件产品积累的公司。 但是，画画之前就已经知道画出来的结果是什么了，那么在画的过程中就很难有创新了。对于软件开发也是，这也是原型模型的主要缺点。 迭代模型迭代模型通过对各个工作流程的多次进行，更好地理解需求，从而可以设计出更为强壮的软件构架，逐步提高开发组织能力。 从宏观上看，迭代模型有4个状态阶段，分别是：先启、精化、构建和产品化。 而它的工作流程共有9个，分别是：1）业务建模 2）需求获取 3）分析设计 4）实施 5）测试 6）部署 7）配置与变更管理 8）项目管理 9）环境 在这9个工作流程中，核心流程是业务建模，因为在迭代模型开发之前一定要有一个初始的业务模型，以便对其进行迭代。 螺旋模型螺旋模型将瀑布模型和原型模型结合起来，特别强调风险分析，特别适用于大型复杂系统。 喷泉模型喷泉模型认为，软件开发过程自上而下的各个阶段是相互重叠和多次反复进行的。 喷泉模型有大量的重叠，所以需要大量的开发人员，不利于项目的管理。 XP模型XP模型即极限编程模型。本是敏捷文化现象。 XP模型通过需求、实现、重构、测试、发布的迭代过程，来实现一种轻量级的软件开发模型。 XP的核心要求是：交流、简单、进取、反馈 XP模型作为一种新的模型，在实际运用中存在较多的问题。同时，它与ISO 9001、CMMI的精神也存在冲突。]]></content>
      <categories>
        <category>软件工程</category>
      </categories>
      <tags>
        <tag>软件生命周期</tag>
        <tag>软件生命周期模型</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[软件工程的内容和方法]]></title>
    <url>%2F2019%2F06%2F14%2F%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E7%9A%84%E5%86%85%E5%AE%B9%E5%92%8C%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[写在前面&emsp;经过一个礼拜的准备，终于结束了软件工程的复习。在复习软件工程的同时也在做信息系统综合设计的课程设计。在做课程设计的过程中，发现了软件工程的重要性和必要性。作为立志成为程序猿的我，软件工程在将来的工作中一定大有用处，故总结如下。 一、软件、软件工程、软件工程学科体系学习软件工程，首先得知道软件是什么。其次，得知道软件工程是做什么的，它研究了什么内容，同时也应该知道软件工程学科体系是什么，与软件工程有什么关系。 软件：最新定义为，软件=知识+程序+数据+文档那么这里面的知识，程序，数据，文档又是指什么呢？ 知识，即各种各样的相关领域的专业知识。 程序，即使对计算机任务的处理对象和处理规则的描述。这里，我们一定要注意，软件并不等于程序，这也是一大误区。 数据，即程序赖以运行的初始化数据。 文档，即为了理解程序所需的详细描述性资料。 软件工程是什么？软件工程是研究软件开发和管理的一门工程学科。 这个定义很短，但是知识点还是挺多的。一强调开发，毕竟开发是软件工程的主体；二强调管理或过程管理，当然，管理是为了更好的开发；三是强调工程，把软件的开发和维护当成一项工程，用工程的办法去开发，按工程的办法去管理；四是强调学科，时至今日，软件工程不只是一门学科，而是一个学科体系。这里也就引出了软件工程学科体系。 软件工程来源于软件危机。软件工程是为了克服软件危机才产生的。 软件工程学科体系 软件工程作为一个学科体系，到21世纪才初步形成。2004年ACM和IEEE-CS联合制订了SWEBOK 2004版，它将软件工程学科体系的知识划分为10个知识域。 对于这10个知识域，我的理解是它覆盖了整个软件生命周期。 1） 软件需求 2）软件设计 3）软件构造 4）软件测试 5）软件维护 6）软件配置管理 7）软件工程管理 8）软件工程过程 9）软件工程工具和方法 10）软件质量 软件工程和软件工程学科体系的关系总体上来说，软件工程是一个局部问题，而软件工程学科体系是一个整体问题。 软件工程研究的内容软件工程研究的内容主要有五个方面。 一是软件生命周期模型 二是软件开发方法 三是软件支持过程 四是软件管理过程 五是软件工程标准与规范 软件工程基本原理软件工程的三要素：方法、工具和过程 有7个基本原理，外加一个二八定律。具体内容见文章末尾的链接。 软件工程在行业中的作用软件工程作为一门工程管理学科，它对软件行业的作用毋庸置疑。那么，这里会有一个问题，既然已经有软件工程了，那么还会不会出现软件危机呢？我的答案是会的。软件工程的产生是为了克服软件危机，但是它的存在并不会完全消除软件危机。这和现实社会中法律存在的意义是相通的。法律的产生是为了消除犯罪，但是法律的存在并不会完全消除犯罪（至少在当前的社会阶段是不会的）。 软件工程可以作用到从业者，也可以作用到项目组，作用到软件公司，甚至作用到整个国家的软件产业1发展。 二、软件工程方法论和软件工程实践论1. 软件工程方法论是什么？软件工程方法论实质上是软件工程中软件开发方法的集合。 那么软件工程方法的集合包括哪些元素呢？ 2. 软件工程方法集合软件工程方法集合包括面向过程方法、面向对象方法、面向元数据方法。 3. 为什么说面向对象方法可以描述无穷的信息世界呢？要搞清楚面向对象为什么可以描述无穷的世界，首先需要知道面向对象方法是什么，其次，需要知道现实世界和软件的普遍联系。 面向对象方法是什么？是一种运用对象、类、消息传递、继承、封装、聚合、多态性等概念构造软件系统的软件开发方法。 我记得高中哲学里面听到的一句话，世界是物质的，物质是运动的，运动是有规律的。而对于软件而言，其实质是对现实人工系统的一种映射、优化和替换。通过对现实世界的分析，我们可以知道，世界是由对象组成的，对象之间时存在普遍联系的，而物质运动则说明了对象的功能。 面向方法是将这现实世界抽象映射为对象的手段。分析设计时由对象抽象出类，程序运行时由类还原到了对象。所以它能够描述无穷的信息世界。 4. 软件工程实践论是什么？软件工程实践论是研究在开发一个大型软件系统时，到底应该怎样选取合适的开发方法。 5. 软件工程实践论指什么？“五个面向”实践论，指面向流程分析、面向元数据设计、面向对象实现、面向功能测试、面向过程管理。 在后面，我们会发现软件工程的“五个面向”实践论在各个软件生命周期模型中都有一定的体现。 三、软件支持过程、软件管理过程 软件过程是什么？软件过程，指软件生命周期中的时间序列 软件支持过程是什么？软件支持过程，由支持软件生命周期模型各个阶段的生产工具组成。 软件生命周期中的生产工具有哪些？CASE工具、软件开发环境SDE、软件工程环境SEE 软件管理是什么？管理过程和支持过程又称为“软件过程工程”。它是软件工程的一部分。 软件管理实质上是过程管理。 软件管理有哪几类？ISO 9001质量管理和质量保证体系 CMMI软件能力成熟度模型 软件企业文化，包括微软企业文化，IBM企业文化，敏捷文化。]]></content>
      <categories>
        <category>软件工程</category>
      </categories>
      <tags>
        <tag>软件工程方法论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[指针，又见指针]]></title>
    <url>%2F2019%2F06%2F10%2F%E6%8C%87%E9%92%88%EF%BC%8C%E5%8F%88%E8%A7%81%E6%8C%87%E9%92%88%2F</url>
    <content type="text"><![CDATA[一、指针简介一般来说，指针是一个其数值为地址的变量（或更一般地说是一个数据对象）。正如char类型的变量用字符作为其数值，而int类型变量的数值是整数，指针变量的数值表示的是地址。 如果你将某个指针变量命名为ptr，就可以使用如下语句： 1ptr=&amp;pooh; //把pooh的地址赋给ptr 对于这个语句，我们称ptr指向pooh。ptr和&amp;pooh的区别在于前者是变量，后者是常量。ptr可以指向任何地方： 1ptr=&amp;bath; //令ptr指向bath 二、间接运算符假定ptr指向bath：ptr=&amp;bath 这时就可以使用间接运算符*（也称取值运算符）来获取bath中存放的数值。 1val=*ptr; //得到ptr指向的值 语句ptr=&amp;bath；以及语句val=*ptr；放在一起等同于下面的语句： 1val=bath; 下面进行举例： 123nurse=22;ptr=&amp;nurse; //指向nurse的指针val=*ptr; //将ptr指向的值赋给val 上述语句实现的功能是把数值22赋给变量val 三、指针声明例如：long和float两种类型的数值可能使用相同大小的存储空间，但是他们的数据存储方式完全不同，指针的声明形式如下： 123int *pi; //pi是指向一个整数变量的指针char *pc; //pc是指向一个字符变量的指针float *pf,*pg; //pf和pg是指向浮点变量的指针 类型标识符表明了被指向变量的类型，而表示该变量是一个指针。声明int pi;的意思是pi是一个指针，而且*pi是int类型的。 *和指针名之间地空格是可选的。通常程序员在声明中用空格，而在指向变量时将其省略。 pc所指向的值（*pc）是char类型的。而pc本身是什么类型的？ 我们将其描述为“指向char的指针”类型。pc的值是一个地址，在大多数系统中，它是由一个无符号整数表示。但是这并不表示可以把指针当做整数类型。一些处理整数的方法不能用来处理指针，反之亦然。例如，可以进行两整数相乘，而指针不能。因此指针的确是一种新的数据类型，而不是整数类型。 四、使用指针在函数间通信在下面的程序中，函数interchange（）只用了指针参数，我们将对该函数进行详细的讨论。 123456789101112131415161718#include&lt;stdio.h&gt;void interchange(int * u, int * v);int main(void)&#123; int x = 5, y = 10; printf("Originally x=%d and y= %d.\n", x, y); interchange(&amp;x, &amp;y); //向函数传送地址 printf("Now x= %d and y=%d.\n", x, y); return 0;&#125;void interchange(int * u, int * v)&#123; int temp; temp = *u;//temp得到u指向的值。 *u = *v; *v = temp;&#125; 下面我们分析以上程序的运行情况。首先，函数调用语句如下： 1interchange(&amp;x, &amp;y); //向函数传送地址 可以看出，函数传递的是x和y的地址而不是他们的值。这就意味着intechange（）函数原型声明和定义中的形式参数u和v将使用地址作为它们的值。因此他们应该声明为指针，由于x和y都是整数，所以u和v是指向整数的指针。其声明如下： 1void interchange(int * u, int * v); 接下来，函数体进行如下声明： 1int temp; 从而提供了所需要的临时变量。为了把x的值存在temp中，需要使用下面语句： 1temp = *u;//temp得到u指向的值。 注意，因为u的值是&amp;x，所以u指向x的地址，这就以意味着*u代表了x的值，而这正是我们需要的数值。 在示例程序中，我们用一个函数实现x和y的数值交换。首先函数使用x和y的地址作为参数，这使得它可以访问x和y变量。通过使用指针和运算符*，函数可以获得相应存储地址的数据，从而就可以改变这些数据。 在ANSI原型中可以省略变量名称。这样，函数原型可以按如下形式进行声明： 1void interchange (int * ,int *); 通常情况下，可以把关于变量的两类信息传递给一个函数，如果函数的调用形式为： 1function1(x); 这时传递的是x的值，但是如果使用下面这种函数调用形式： 1function2(&amp;x); 那么会把x的地址传递给函数。第一种调用形式要求函数定义部分必须包含一个和x具有相同数据类型的形式参数。如下所示： 1int function1(int num); 而第二种形式要求函数定义部分的形式参数必须是指向相应数据类型的指针： 1int function2(int *ptr); 使用函数进行数据计算等操作时，可以使用第一种调用形式。但是如果需要改变调用函数中的多个变量的值时，就需要使用第二种调用形式。 尽管interchange（）只使用局部变量，但是通过使用指针，该函数可以操作main（）中的变量的值。]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>指针</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[软件工程相关名词解释]]></title>
    <url>%2F2019%2F06%2F10%2F%E5%B7%A5%E7%A8%8B%E7%9B%B8%E5%85%B3%E5%90%8D%E8%AF%8D%E8%A7%A3%E9%87%8A-1%2F</url>
    <content type="text"><![CDATA[软件： 一般认为，程序是计算机为完成特定任务而执行的指令的有效集合。站在应用的角度可以通俗地理解为： 面向过程的程序=算法+数据结构 面向对象的程序=对象+消息 面向构件的程序=构件+构架 通常，软件有以下定义： 软件=程序+数据+文档 这里的“程序”，是对计算机任务的处理对象和处理规则的描述；这里的“文档”，是为了理解程序所需的详细描述性资料；这里的“数据”，主要是软件系统赖以运行的初始化数据。 软件的最新定义如下： 软件=知识+程序+数据+文档 定义中增加了“知识”。这里的“知识”,主要指各种各样的相关行业领域的专业知识。实际上，知识只是网络的外在表现，程序，数据，文档才是网络的内在实质。也就是说，知识是通过程序、数据、文档来实现的。 对这一定义的另外一种解释是，软件到底是什么呢？软件就是网络，网络就是知识，知识就是信息。站在网民的角度看，软件就是知识加信息。站在程序员角度看，软件就是程序加数据；站在软件管理者角度看，软件就是数据加文档。 网络是知识的载体，知识是网络的灵魂。 软件工程 软件工程是研究软件开发和管理的一门学科。 这里，以是强调开发。开发是软件工程的主体，开发是在规定的时间、按照规定的成本，开发出符合规定质量要求的软件。二是强调管理或过程管理。当然，开发中有管理，管理是为了更好地开发。所以开发和管理是一个问题的相辅相成的两个方面。许多软件项目的失败，不是在开发技术上出了问题，二是在管理过程上出了问题。所以在某种程度上说，对于一个软件企业，过程管理比开发技术更重要。三十强调工程。要将软件的开发（包括维护）当成一项工程，既要按照工程的办法去开发，又要按照工程的办法去管理。四是强调学科。时至今日，软件工程不止是一门课程，而是一个学科体系，即软件工程知识体系。 软件工程学科体系（swebok2004）： 软件工程作为一个学科体系，到21世纪初才初步形成。2001年4月18日，美国发布了软件工程知识体系指南SWEBOK（guide to the Software Engineering body of Knowledge）0.95版。2004年，软件工程学科体系的内容才基本确立，就在这一年，美国ACM和IEEE-CS联合制订了SWEBOK2004版，它将软件工程学科体系的知识划分为如下10个知识域： （1）软件需求：软件需求是真实世界中的问题而必须展示的特性。软件的需求知识域有7个子域：需求基础、需求过程、需求获取、需求分析、需求规格说明、需求确认、实践考虑。 （2）软件设计：软件设计既是定义一个系统的体系结构，组件，接口和其他特征的过程，又是这个过程的结果，软件设计知识域有6个子域：软件设计基础，软件设计关键问题，软件结构与体系结构，软件设计质量的分析与评价，软件设计符号，软件设计的策略与方法。 （3）软件构造：它指通过编码，验证，单元测试，集成测试和排错的组合，具体创建一个可以工作的，有意义的软件。其知识域有3个子域：软件构造基础，管理构造，实际考虑 （4）软件测试：它由在有限测试用例集合上，根据期望的行为对程序的行为进行的动态验证组成，测试用例是从实际上无限的执行域中适当选择出来的。软件测试知识域有5个子域：软件测试基础和测试级别，测试技术，需求分析，与测试相关的度量，测试过程。 （5）软件维护：软件一旦投入运行，就可能出现异常，运行环境可能发生改变，用户会提出新的需求。生命周期中的软件维护，从软件交付时开始。软件维护的知识域有4个子域：软件维护基础，软件维护的关键问题，维护过程，维护技术。 （6）软件配置管理：软件配置是为了系统地控制配置的变更，维护软件在整个系统生命周期中的完整性及可追踪性，而标志软件在不同时间点上的配置的学科。软件配置管理知识域有6个子域：软件配置管理过程管理，软件配置标志，软件配置控制，软件配置状态统计，软件配置审核，软件发行管理和交付。 （7）软件工程管理：进行软件工程的管理与度量，虽然度量是所有知识域的一个重要方面，但是这里所说的是度量程序的主体。软件工程管理只是域有6个子域：启动和范围定义，软件项目计划，软件项目实施，评审与评价，关闭，软件工程度量。前5个覆盖软件过程工程管理，第6个描述软件度量的程序。 （8）软件工程过程：涉及软件工程过程本身的定义、实现、评定、度量、管理、变更和改进。软件工程过程知识域有4个子域：过程实施与改变、过程定义、过程评定、过程和产品度量。 （9）软件工程工具和方法：它具有软件工程工具、软件工程方法两个子域。 （10）软件质量：处理跨域整个软件生命周期过程的软件质量的考虑，由于软件质量问题在软件工程中无处不在，其他知识领域也涉及到质量问题。软件质量知识域有3个子域：软件质量基础，软件质量过程、时间考虑。 在上述软件工程学科体系中前5个知识域是讲软件开发，后5个知识域是讲软件管理。由此可见，软件工程知识体系包括软件开发和软件管理两大部分，所以软件工程的定义也应该包括软件开发和软件管理两项内容。 软件工程课程 软件工程课程与软件工程学科体系是有区别的：前者是一门或一组课程，后者是一个知识体系；前者是一个局部问题，后者是一个整体问题。 作为一门软件工程客户才能，它研究的内容至今没有统一的说法。可以这么认为，软件工程课程研究的内容应该涵盖“软件生命周期模型、软件开发方法、软件支持过程、软件管理过程、软件工程标准与规范”这5个方面。 序号 研究方向 具体内容 1 软件生命周期模型 如：瀑布模型，增量模型 2 软件开发方法 如：面向过程的方法 3 软件支持过程 如：CASE工具ROSE，北大青鸟系统，Power Designer 4 软件管理过程 如：CMMI，软件企业文化，敏捷（XP）文化现象 5 软件工程标准与规范 如：命名标准与规范，设计标准与规范，编程标准与规范 尽管软件生命周期模型和软件支持过程非常重要，但是现代软件工程研究的重点，仍然是软件开发方法和软件管理过程。在软件管理过程的内容中，除了ISO9001的CMMI之外，还将软件企业文化也列入其中，如微软企业文化，敏捷文化现象和IBM企业文化。 软件工程标准是对软件产品的约束，如软件产品的界面标准，包装标准，文档标准，测试标准，评审标准，鉴定标准等。软件工程规范是对软件开发人员行为的约束，例如命名规范，需求规范，设计规范，编码规范，维护规范等。在软件企业内部，企业管理人员特别重视软件工程的标准与规范。为此，每个大型的软件企业，根据自身的特点，都制订并发布了自己的软件工程标准与规范，在自己企业内部严格执行。 软件工程基本原理 习惯上，人们常常把软件工程方法（开发方法）、工具（支持方法的工具）、过程（管理过程）称为软件工程三要素，而把美国著名的软件工程专家B.W Boehm于1983年提出的7条原理作为软件工程的基本原理。 （1） 用分阶段的生命周期计划严格管理软件开发。阶段划分为计划、分析、设计、编程、测试和运行维护。 （2） 坚持进行阶段评审。若上一阶段评审不通过，则不能进入下一阶段开发 （3） 实行严格的产品版本控制 （4） 采用现代程序设计技术 （5） 结果应能清楚地审查。因此，对文档要有严格的要求 （6） 开发小组的成员要少而精 （7） 要不断地改进软件工程实践的经验和技术，要与时俱进 上述7条原理，虽然是在面向过程设计时代（结构化时代）提出的，但是，直到今天，在面向元数据和面向对象的程序设计新时代，它仍有效。根据“与时俱进”的原则，还有一条基本原理在软件的开发和管理中特别重要，需要补充进去，作为软件工程的第8条基本原理。 （8） 二八定律 在软件工程中，所谓二八定律，就是一般人常常将20%的东西误认为80%的东西，而将80%的东西误认为是20%的东西。 例如，对软件项目进度和工作量的估计：一般人主观上认为已经完成了80%，但实际上只完成了20%；对于程序中存在问题的估计，：一般人不知道80%的问题存在于20%的程序之中；对模块功能的估计：一般人不知道20%的模块，实现了80%的功能；对人力资源的估计：一般人不知道20%的人，解决了程序中80%的问题；对投入资金的估计：一般人不知道信息系统中80%的问题，可以用20%的资金来解决。 研究二八定律的现实意义是，指导软件计划的制订与执行。 软件生命周期模型 软件生命周期模型时指在整个软件生命周期中，软件开发过程应该遵循的开发路线图。或者说，软件生命周期模型是软件开发全部过程、活动和任务的结构框架。 例如：瀑布模型、增量模型、螺旋模型、喷泉模型、XP模型、原型模型和RUP迭代模型，它们都有各自清晰的开发路线图，规定了各自的开发过程、活动和任务的结构框架。 从字面上理解，“软件生命周期”应该涵盖软件产品、项目或系统从产生、投入使用看到被淘汰的全过程。由于早期人们关注的是技术开发活动，还没有考虑到管理活动，因此“软件生命周期模型”主要描述的还是软件开发的过程及其任务。 与人不同的是，软件的生命周期和软件生命周期模型有关：不同的软件生命周期模型，可能对应着不同的生命周期。生命周期不同，该软件的开发阶段划分、评审次数、基线标准都有所不同。软件公司的项目组在开发一个大项目或产品时，首先在技术上必须选择一个软件生命周期模型，使该模型非常适合这个项目或产品的生命周期模型；随后通过对软件生命周期模型的裁剪，给出适用于本项目或产品的软件生命周期定义；以生命周期定义为标准，在需求定义之后，编制详细的软件开发计划；然后项目组按计划进行软件开发，软件工程管理部门按计划进行软件过程跟踪和管理。 软件生命周期模型能清晰、直观地表达软件开发全过程，明确规定了要完成的主要活动和任务，用来作为软件项目工作的基础。一般以时间为序，软件生命周期模型可详细地划分为9个阶段。 序号 周期名称 序号 周期名称 1 立项（或签合同）、下达任务书 6 软件测试 2 需求分析 7 软件发布与实施 3 概要设计 8 软件维护 4 详细设计 9 版本更新或退役 5 编码实现 软件开发方法是指在软件工程开发路线图中，开发人员对软件需求、设计、实现、维护所采用的开发思想开发技术、描述方法、支持工具等。 软件工程中软件开发方法的集合，称为软件工程方法论。 迭代模型及其9个核心流程 针对瀑布模型的缺陷，人们提出了迭代模型。 所谓迭代，是指活动的多次重复。从这个意义法伤来讲，原型不断完善，增量不断产生，都是迭代的过程。因此，快速原型法和增量模型都可以看成局部迭代模型。但这里所讲的迭代模型时RUP推出的一种“逐步求精”的面向对象的软件开发过程模型，被认为是软件界迄今为止最完善、可实现商品化的开发过程模型。 RUP模型的原型图看起来非常简单，其内涵却非常丰富。它表面上是一个二维图，实质上用一张二维图表示了一个多维空间模型。从宏观上看，它是一个大的迭代过程；横坐标表示软件产品所处的4个阶段：先启、精化、构建、产品化（移交），纵坐标表示软件产品在每个阶段的工作流程。从微观上看，任何一个阶段本身，其内部工作流程也是一个小的迭代过程。 为使项目能够顺利地进行，一种较灵活（并且风险更小）的方法是：多次执行各个开发工作流程，从饿了更好地理解需求，设计出更为强壮的软件架构，逐步提高开发组织能力，最终交付一系列逐步完善的实施成果，这就是迭代生命周期模型。每次按顺序完成一系列工作流程就称为一次迭代，每次迭代，均以次要里程碑结束，按照特定的迭代成功标准，对迭代的结果进行评估。每个阶段都可以进一步细分为迭代。迭代是产生可执行的产品发布（内部或外部的）的完整开发循环，所发布的产品是开发过程最终产品的子集，它将通过一次又一次的迭代实现递增成长，最后形成最终的软件系统或产品。 优点： n 在开发的早期或中期，用户需求可以变化； n 在迭代之初，不要求有一个相近的产品原型 n 模型的适用范围很广，几乎适用于所有项目的开发 缺点：传统的组织方法是按顺序（一次且仅一次）完成每个工作流程，即瀑布式生命模型。迭代模型采取循环工作方式，每次循环均使工作产品更靠近目标产品，这要求项目组成员具有很高的水平并掌握先进的开发工具。反之，存在较大的技术和技能风险。 模型的9个核心流程： 迭代声明周期模型包含9个核心流程（需要指出的，采用迭代模型，事先要有一个初始业务模型，以便进行迭代。这就是为什么将“业务建模”作为9个核心流程之首的道理）。 （1） 业务建模：目的是， 了解目标组织的结构和机制；了解目标组织中当前存在的问题，并确定改进的可能性；确保客户、最终用户和开发人员就目标组织达成共识；导出支持目标组织所需的系统需求。通俗地讲，业务建模就是用户业务流程的重新规划与合理改进，即业务流程的优化，目的是使开发出来的系统能反映最优化的业务流程。 （2） 需求获取：目的是，与客户在系统的工作内容方面达成并保持一致；使系统开发人员能够更清楚地了解系统需求；定义系统边界；为计划迭代的内容提供基础；为估算开发系统所需成本和时间提供基础；定义系统的用户界面，重点是用户的需要和目标。 （3） 分析设计：目的是，将需求转换为未来系统的设计；逐步开发强壮的系统构架；使设计适合实施环境，为提高性能而进行设计。 （4） 实施：目的是，对照实施子系统的分层结构定义代码结构；以构件（源文件，二进制文件，可执行文件以及其他文件等）方式实施类和对象；对已开发的构件按单元进行测试；将各实施成员（或团队）完成的结果集成到可执行系统中。 （5） 测试：目的是，核实对象之间的交互；核实软件的所有构件是否正确集成；核实所有需求是否已经正确实施；确定缺陷并确保在部署软件之前将缺陷解决。 （6） 部署：目的是，将构件部署到网络的各个节点上，使最终用户可以使用该软件产品。 （7） 配置与变更管理，目的是，始终保持工作产品的完整性和一致性 （8） 项目管理：目的是，为软件密集型项目的管理提供框架；为项目计划，人员配备，执行和检测提供实用准则；为风险管理提供框架。 （9） 环境：目的是，为软件开发组织提供软件开发环境（流程和工具），该环境将支持开发团队。 XP模型 XP模型，即极限编程模型，它本来是敏捷企业文化现象，但是不少人将它当成一种软件开发模型。 对传统软件开发模型进行重新审视发现，它们太正规、太呆板、太浪费资源，从而提出了省时省力的XP模型。它属于轻量级开发模型，由一组简单规则（需求、实现、重构、测试、发布）组成，它既保持开发人员的自由创造性，又保持对需求变动的适应性，即使在开发的后期，也不怕用户需求的变更。 在需求、实现、重构、测试、发布的迭代过程中，XP模型有4条核心原则：交流、简单、反馈和进取。XP开发小组包括开发人员、管理人员和客户。 优点： l 采用简单策略，不需要长时间计划和复杂管理，开发周期短 l 采用迭代增量开发，反馈修正和反复测试的方法，因而软件质量有保证。 l 适应用户需求变化，因而与用户关系和谐。 缺点： XP模型作为一种新的模型，在实际应用中还存在一些问题，引起了一些争议。它一般适用于小型项目，同时，它与ISO9001、CMMI的精神也存在冲突。 订单软件 与固定的用户签订软件开发合同，由软件公司启动该项目的开发，这类软件被称为“订单软件”，典型的例子有企业资源规划系统ERP和电子商务大型网站。 非订单软件 市场调研之后，认为某产品将会有巨大的市场空间，而软件公司在人力资源、设备资源、抵抗风险、资金和时间上都具备开发该产品的能力，于是决定立项，这类软件被称为“非订单软件”，典型的例子是网上游戏软件 任务书 有一份《任务书》的正文。包括任务下达的对象、内容、要求完成的日期、决定投入的资源、必要时包括任命项目经理（技术经理和产品经理）、其他保证措施、奖惩措施等。《任务书》正文可长可短，若《合同》或《立项建议书》很详细，则正文可短，若《合同》或《立项建议书》很粗很短，则正文应该很长、很详细。 有一份《任务书》的附件。一般情况下，它就是软件《合同》/《立项建议书》，如果是指令性计划，它的格式和内容，也应与《合同》/《立项建议书》基本相同，即附件的内容应覆盖系统的功能点列表、接口列表、资源需求列表、开发进度列表、阶段评审列表等。 《任务书》与《合同》/《立项建议书》一样重要，它是该项目的第二份管理文档。 合同 对于一些大型项目，在签订合同之前，一般有一个招标和投标的过程，只有中标之后才能签订合同。开发“非订单软件”需要“立项”，开发“订单软件”需要签订“合同”。所以“立项”与“合同”是IT企业软件项目（或产品）的两个源头。一旦立项或签订合同，企业领导或软件管理部门就要下达《任务书》，开发部门接到《任务书》后就要组建开发团队，成立项目组。 立项建议书 立项文档就是《立项建议书》，它本身不是软件策划的内容，但是很重要，也很特殊。《立项建议书》的目的，就是在某种程度上代替开发合同或用户需求报告，作为软件策划的基础。《立项建议书》的编制者一般不是软件开发人员，而是软件公司的市场销售人员，因为他们熟悉市场行情及客户需求 需求分析 1997年，IEEE软件工程标准词汇表中定义的需求为： （1） 用户解决问题或达到目标所需的条件或能力 （2） 系统或系统部件要满足合同、标准、规范或其他正式规定文档所具有的条件或能力 （3） 一般反映（1）或（2）所描述的条件或能力的文档说明 一般而言，需求分析阶段位于软件开发的前期，它的基本任务是准确地定义未来系统的目标，确定为了满足用户的需要系统必须做什么。 需求分析分为两个阶段：需求获取阶段和需求规约阶段。需求关系的是系统的目标而不是系统实现。 需求可以分为两类：功能性需求和非功能性需求。前者定义了系统做什么，后者定义了系统工作时的特性。 基线 基线是软件工作产品，它是要经内部和外部评审过的，是下一阶段工作的基础。 审计 审计，是复查评审活动程序的合法性，是否按程序与规范进行等 里程碑 里程碑是一个标记，只需要经过内部评审。一个里程碑是一个检查点，但不一定对应一条基线 定义软件过程 所谓定义软件过程，就是根据选定的生命周期模型，规定软件的开发1模型，以及每一阶段的工作步骤和文档标准等内容。 在项目策划阶段，先要根据项目特性，使用软件生命周期模型，对项目中将要进行的软件工程过程进行描述。根据项目自身的特点，对项目的类型进行详细划分，然后根据软件组织的“生命周期模型裁剪指南”，对标准软件过程进行裁剪，形成项目定义软件过程。再使用项目定义软件过程，指导项目策划活动的进行。 开发计划是对项目定义软件过程的具体描述。软件项目的规模、工作量、成本、进度、质量、人员配置和其他资源等，与项目定义软件过程中的活动紧密相关。由于项目定义软件过程的标准，全部由“生命周期模型裁剪指南”而得到，因此软件项目能共享过程数据，并且吸取软件组织中积累的经验教训。 LOC LOC（line of code），LOC指所有的可执行源代码行数。包括可交付的工作控制语言（job control language，JCL）语句，数据定义，数据类型声明，等价声明，输入/输出格式声明等。一代码行（1LOC）的价值和人月均代码行数可以体现一个软件生产组织的生产能力。组织可以根据对历史项目的审计来核算组织的单行代码价值。 功能模型 （Function Model, FM）。实质上是用户需求模型，用来描述系统能做什么，即对系统的功能，性能，接口和界面进行定义。 业务模型 （Operation Model，OM），实质上是业务逻辑模型，用于描述系统在何时，何地、由何角色、按什么业务规则去做，以及做的步骤或流程，即对系统的操作流程进行定义。 数据模型 （Data Model, DM）,实质上是实体或类的状态关系模型，用于描述系统工作前的数据来自何处，工作中的数据暂存在什么地方，工作后的数据放到何处，以及这些数据的状态以及相互之间的关联，即对系统的数据结构进行定义。 风险分析 软件策划过程，也包括对软件风险进行分析。所谓软件风险分析，指对项目及团队的政策风险、技术风险、技能风险、资源风险等因素，进行逐个分析与分解，将一个大风险分解为若干个小风险，对各个小风险进行排除，最后制订跟踪和监控风险的风险管理计划。软件一般存在5种风险，如下表： 序号 风险名称 风险内容 1 政策风险 IT企业外部和IT企业内部两个方面的政策及政策的变化，将会给项目带来什么风险 2 技术风险 新技术的成熟程度以及难度系数，将会给项目带来什么风险 3 技能风险 项目组成员学习、领会、掌握、运用新技术的能力，将会给项目带来什么风险 4 资源风险 保证项目正常进行所需的各种资源的供应程度，将会给项目带来什么风险 5 其他风险 目前意想不到的风险，即不可预测的风险，如天灾人祸 三层结构设计 三层结构设计通常被划分为表示层、中间层和数据层三层，各个分层之间通过对外接口互相访问。分层的主要目的是，允许各层可以随着需求的变化或技术的变化而独立地升级或替换，如当替换数据库时，只需要变化数据层。 所谓的三层结构，就是在原来两层结构（Client/Server）的客户层和数据层之间，加入一个中间层（也叫业务层），并将应用程序的业务规则、数据访问、合法型校验等工作放到了中间层进行处理，这样就变成了三层结构，也不仅仅有B/S应用才是三层结构，三层是指逻辑上的三层，即使这三层都放置到了一台机器上。当然，这三层也可以放在两台或三台机器上。 （1） 表示层（浏览层） 表示层也称为浏览层，它通常采用图形化用户界面，在客户端PC或工作站上运行。站在“三个模型”建模思想上看，系统内部支持表示层的模型是“功能模型”，尽管“功能模型”中的功能思想组件放在业务层，但是功能组件的表现方式却在表示层上。该层的主要功能是： ​ 1）接受用户请求，将这些请求反馈给业务逻辑层，等待业务逻辑层的应答信息 12） 对业务逻辑层的应答信息，进行显示（不进行任何加工） ​ 3） 有时也会兼做业务逻辑层的一些小功能，比如对用户输入数据的验证，以及操作合法性的检验 （2） 中间层（业务层） 中间层也称业务层，有时又称为应用层，它由许多构建或组件组成，它们完全体现了用户的业务逻辑或业务规则。站在“三个模型”建模思想看，系统内部支持业务层的模型是“业务模型”。尽管Java EE与.NET在实现业务层上的方法略有差异，但是，业务层本质上在表示层与数据层之间起桥梁作用。有时，业务层被划分为两个子层：业务逻辑层和数据访问层。业务层的主要功能是： ​ 1） 接受从表示层传来的用户请求信息 ​ 2） 根据用户的请求信息生成SQL语句 ​ 3） 利用生成的SQL语句从数据层取数据、修改数据、删除数据 ​ 4） 将结果返回给表示层 （3） 数据层 数据层是数据库服务器上的数据库层，它包括数据库管理系统DBMS和数据库DB两部分。站在“三个模型”建模思想看，系统内部支持数据层的模型是“数据模型”，该层的主要功能是： ​ 1）接受业务层数据处理请求的SQL语句或存储过程 ​ 2） 利用SQL语句或存储过程，对数据库服务器上数据库的相关表进行存储或检索 ​ 3） 将存储或检索的结果信息，传递给业务层 构件 所谓构件，就是被标识的且可被复用的软件制品。 构件与部件，组件基本上是一个意思，有时会认为部件和组件的粒度比构件大一些或范围更广一些。上述定义有三个特点：第一个特点是构件要被明确标识，即有一个被调用的名字；第二个特点是应该可服用，不可复用的只能称为模块或子系统，第三个特点是构件是软件制品，在宏观上软件制品可以是项目计划、成本估价、体系结构、需求模型、设计模型、程序代码、窗口界面、文档、数据结构、测试用例等。 中间件 中间件是一个非常大的组件（构件），一般在网络上运行，完成批量数据的传递和通信工作，调用方式是通过一组事先约定的格式与参数进行的。常见的中间件为问价传输中间件，如IBM公司的消息队列中间件MQ，在网络节点之间进行点对点的数据通信和传输。又如城市医疗保险系统中的中间件，它在市医保局节点和全市各家医院节点之间，进行点对点的数据通信和传输，病号每次划价计费，节点之间就交换一次信息。在详细设计说明书中已对新增中间件的功能和算法进行了详述，此处只要将详细设计翻译为源程序即可。 结对编程 在敏捷方法中，成对（或结对）编程时极限编程的实践之一。当进行成对编程时每一个程序员输入代码，另一个在旁边观察代码中是否存在错误，并思考下一步要进行的工作。 优点： 1） 可以提高代码的可读性和可理解性，产生高质量的代码 2） 提高编程效率，使编程速度更快，代码错误更少，后期测试和纠错的工作量就会大大降低 3） 成对编程可以提高开发团队的凝聚力和协作精神 规则： 1） 编码标准 2） 积极参与 3） 非强制性 4） 定期轮换 5） 速度匹配 6） 新老匹配 软件测试 软件测试按照规定的测试规程发现软件缺陷的问题。 为了理解这个定义，有如下解释： 1） 软件测试是一个过程，而且是一个发现软件缺陷，但不包括修复软件缺陷的过程。 2) 软件测试是按照规定的测试规程进行。这些规程包括制定测试计划，搭建测试环境，明确测试任务，规定测试时间、方法和步骤，记录测试数据和产生测试报告 3) 在测试规程中，测试计划最为重要，它指导整个测试计划 4) 在测试计划中，测试需求的定义很重要。如果没有列出明确的测试需求，那么就并不会设计出正确的测试用例，最后必然导致盲目的测试。这样，隐藏的软件缺陷也无法被发现。 5) 软件测试的目的是发现软件缺陷，软件测试的目标是尽可能早地发现软件缺陷，因为缺陷发现越早，其修复成本越低。 软件测试不仅仅局限于测试程序代码，还可以测试软件数据与软件文档。也就是说，软件生命周期中所产生的软件工作产品，都可以作为测试对象，因为它们影响最终软件产品的质量。 软件缺陷 定义如下： 软件未实现产品说明书要求的功能。 软件出现产品说明书指明不应该出现的错误 软件实现了产品说明书未说明的功能 软件未实现产品说明书虽未明确提及但应该实现的目标 软件难以理解，不易使用，运行速度慢，或者软件测员，最终用户认为软件不好。 由于不同的理解方式和中英文翻译问题，软件缺陷的说法很多，如错误、失效、失败等，本书中统称为软件缺陷（bug）。实际测试中，将软件缺陷定义为不同级别，代表不同程度的软件缺陷。 随着软件定义的变化，软件缺陷的定义也应随之更新。软件缺陷不仅仅局限于软件代码，还包括文档缺陷（不符合规范或者不详细，有错误和歧义等）、测试缺陷（测试不充分，或测试方法本身的局限）、过程缺陷（软件生命周期的流程问题造成的产品质量问题）和管理缺陷（由于管理本身不到位导致的产品质量问题）。 软件测试的V模型 早期的软件测试V模型 模型的左侧是开发阶段，右侧是测试阶段。开发阶段从了解并定义软件需求开始，然后要把需求转换到概要设计和详细设计，最后形成程序代码。测试阶段是在代码编写完成之后，先做单元测试，然后做集成测试、系统测试和验收测试。 单元测试：主要检测代码的编写是否符合详细设计中单个模块或组件的要求 集成测试：主要检测此前测试过的单个模块或组件，能否正确地集成到系统，与其他模块一起运行，是否符合概要设计和详细设计说明书的要求。 系统测试：以集成后的完整系统作为测试对象，主要检测其是否符合需求说明书、概要设计说明书和详细设计说明书的要求。 验收测试：主要检测软件产品是否符合用户需求，用户合同和需求说明书中的要求，需要得到用户认可并签字确认。 改进后的V模型： 改进后的V模型，一是加入软件测试分析和测试设计阶段，二是体现“尽早”思想。改进后的V模型，形成了一个没有软件开发过程的、单独的软件测试V模型。它的左边是软件测试需求分析和测试设计，右边是软件测试执行。虽然测试执行过程同样集中在软件编码之后，但是测试需求分析和测试设计已经提前，一直提前到与开发阶段并行开展。一方面可以为后期的测试执行过程做计划和准备，另一方面可以对软件的阶段性产品（软件工作产品）进行测试。前期的软件工作产品主要是文档，如测试需求分析阶段，就是测试软件需求分析过程的工作产品《需求规格说明书》，进而提炼出测试需求。 黑盒测试 黑盒测试又称为不透明盒测试，它给我们的更多启示是它的思考方式，即不考虑（主观上屏蔽）或者不需要（客观条件限制）知道被测对象的内部实现细节，只关心输入输出。在运用黑盒测试方法进行软件测试时，它并不关心软件的内部逻辑结构和实现方法，而是站在使用者的角度，主要测试软件的功能指标，即测试系统的功能模型。黑盒测试的依据是软件的行为描述，是面向功能的穷举输入测试。从理论上讲，只有把所有可能的行为都作为测试用例输入，才能完成黑盒测试工作。黑盒测试的对象可以是软件单元、软件模块、软件组件、软件子系统和软件系统，也可以是发散思维到软件文档，软件管理文档等软件生命周期中的任何可测试对象。 黑盒测试用例设计方法： （1） 等价类划分法 （2） 边界值分析法 （3） 错误推测法 （4） 因果图分析法 （5） 场景分析法 白盒测试 白盒测试又称为透明盒测试，要求测试人员必须清楚被测对象的内部实现细节。白盒测试方法的测定依据是《详细设计说明书》。理论上讲，面向程序执行路径进行穷举代码测试，直至覆盖所有路径，才算完成了白盒测试。白盒测试的测试对象，侧重于软件单元，模块和构件等小规模对象，绝对不适合软件项目或产品的等大规模测试对象。 实用的白盒测试覆盖技术有4种，即语句覆盖，条件覆盖，分支覆盖和组合覆盖。覆盖的主要思想，是从不同角度尽可能提高代码的测试覆盖率。为了减少测试工作量，应该使每一个测试用例满足多个覆盖条件。 等价类 等价类划分的具体做法是：把所有可能的输入数据，即软件的输入域，划分成若干部分（子集），使每部分内的数据都是等效的（对于软件而言，等效可以理解为对数据的处理过程以及处理结果都完全一致），然后从每一个子集中选取少数具有代表性的数据，作为测试用例。 每一个等价类又可以划分为两种不同类别：有效等价类和无效等价类。 边界值 边界值分析方法是对等价类划分方法的补充。 测试工作者已经总结出经验：大量的错误常常发生在输入或输出范围的边界上，因此针对各种边界情况设计测试用例，可以查出更多的错误。 使用边界值分析方法设计测试用例使，首先参考等价类划分法确定边界情况，除了在等价类中选取典型代表数据外，通常还要着重测试边界值情况，应当选取正好等于、刚刚大于、或刚刚小于边界的值作为测试数据。 测试需求 它指软件测试员站在与用户相同角度上理解的需求，主要是确保需求的可测试性。同时找出软件需求和用户需求的偏差，并确保认可的偏差修改后体现在软件需求中，因为测试工作以《软件需求说明书》为基准，测试人员需要尽量保证《软件需求说明书》可以满足测试工作。 Bug 即软件缺陷，如错误，失效，失败等。 CMMI 软件能力成熟度模型CMMI，是由美国卡内基-梅隆大学软件工程研究所退出的评估软件能力与成熟度等级的一套标准。该标准基于众多软件专家的实践经验，侧重于软件开发过程管理能力的提高，是软件生产过程改进的标准和软件企业成熟度等级评估的标准。由于该标准不涉及具体的软件开发方法和技术，所以它具有广泛性、通用性和持久性。 CMMI的作用：概括地讲，过程能力成熟度模型集成CMMI的作用，主要是软件组织的能力评估和过程改进，它的应用领域具体体现在三个方面： 软件组织，用它来不断改进自身的软件过程管理能力 评估机构，用它来评估某软件组织当前软件能力成熟度级别 客户，用它来评价某承包商（软件外包商）的软件能力 CMMI的实质： 为了真正达到持续改进软件过程能力的目的，并以尽量低的成本获得高的效益，首先要弄清楚“过程”、“项目”、“组织”、“度量”等五个基本概念。 以“过程”为核心，抓软件组织的管理，即软件“组织”的过程改进 以“项目”为手段，抓团队开发过程的“活动”，即落实过程改进的措施 以“活动”记录为基础，抓软件过程的“度量”，即“度量”软件组织改进的情况 软件配置管理 软件配置管理SCM，是对软件开发过程中配置项的一组追踪和控制活动，它开始于软件开发之初，结束于软件淘汰之时。软件配置管理在软件过程管理中，占有特殊得到地位，也是项目管理的重要内容。无论是ISO9001、CMMI，还是软件企业文化，都非常强调配置管理。在大中型软件企业内部设置专职的配置管理员，在各个项目组内部设置兼职的配置管理员，引进配置管理电子工具，开展配置管理的日常工作。 CMMI阶段的成熟度等级 阶段模型的5个等级，称为成熟度等级ML，从ML1级到ML5级。 CMMI的等级 PA数目 管理特点 ML1:Initial（初始级） 0 过程不可预测且缺乏控制 ML2：Managed（已管理级） 7 过程为项目服务，即项目级管理 ML3：Defined（以定义级） 11 过程为组织服务，即组织级管理 ML4:Quantitatively Managed(定量管理级) 2 过程已度量和控制，即定量级管理 ML5：Optimizing（优化级） 2 集中于过程改进，即优化级管理 极限编程 极限编程（即XP）是一个周密而严谨的软件开发流程。XP从4个基本方面对软件项目进行改善：交流、简单、反馈和进取。 XP程序员与客户交流、与同事交流； 他们的设计简单而干净； 他们通过测试来得到反馈； 他们根据变化修改代码，并争取尽可能早地将软件交付给客户。 在此基础上，XP程序员能够勇于面对需求变化和技术变化，“船小好调头”，对需求变化和技术变化做出敏捷反应，把那个取得成功，是敏捷文化的特色和本质。 软件质量管理的三大支柱 软件质量保证SQA是一个过程，是CMMI和ISO9001的重要议题，是微软公司和IBM公司的重点课题，同样也是项目管理的重要内容。 软件质量：是供方提供的软件产品满足用户明确和隐含需求的能力特性的总和。 通常，人们将“质量标准”、“配置管理”、“质量测试”作为质量管理的三大支柱。 而将”SQA计划”、“SQA进度”、“SQA评审和审计”作为质量管理三大要素。 软件质量保证是一个质量管理过程，基本思想是“以事先预防为主，以事后纠偏为辅”，采取标本兼治的方法。]]></content>
      <categories>
        <category>软件工程</category>
      </categories>
      <tags>
        <tag>软件工程名词解释</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机网络体系结构]]></title>
    <url>%2F2019%2F06%2F10%2F%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%2F</url>
    <content type="text"><![CDATA[一、计算机网络分层结构两个系统中实体间的通信是一个很复杂的过程，为了降低协议设计和调试过程的复杂性，也为了便于对网络进行研究、实现和维护，促进标准化工作，通常对及时算计网络的体系结构以分层的形式进行建模。 我们将计算机网络的各层及其协议的集合称为网络的体系结构。 网络设计者以分层的方式组织协议以及实现这些协议的网络硬件和软件，每个协议就属于这些层次之一。某层向它的上一层提供服务，即所谓每一层的服务模型。例如，第n层提供的服务可能包括报文从网络的一边到另一边的可靠传送。这可能是通过使用第n-1层的边缘到边缘的不可靠报文传送，加上第n层的检测和重传丢失报文的功能来实现的。 计算机网络的体系结构通常都具有可分层的特性，它将复杂的大系统分为若干个较容易实现的层次。分层的基本原则如下： 每次都实现一种相对独立的功能，降低大系统的复杂度 各层之间界面自然清晰，易于理解，相互交流尽可能少 各层功能的精确定义独立于具体的实现方法，可以采用合适的技术来实现 整个分层结构应该促进标准化工作 在计算机网路的分层结构中，第n层中的活动元素通常被称为n层实体。具体来说，实体指任何可发送或接受信息的硬件或软件进程，通常是一个特定的软件模块。不同机器上的同一层称为对等层，同一层的实体称为对等实体。 在计算机网络体系结构的各个层次中，每个报文都分为两部分：一是数据部分，即SDU；二是控制信息部分，即PCI，它们共同组成PDU。 服务数据单元（SDU）：为完成用户所要求的功能而应传送的是数据。第n层的服务数据单元记为n-SDU。 协议控制信息（PCI）：控制协议操作的信息。第n层的协议控制信息记为n-PCI。 协议数据单元（PDU）：对等层次之间传送的数据单位称为该层的PDU。第n层的协议数据记为n-PDU。在实际的网络中，每层的协议数据单元都有一个通俗的名称，如物理层的PDU称为比特，链路层的PDU称为帧，网络层的PDU称为分组，传输层的PDU称为报文。 在各层间传输数据时，把从第n+1层收到的PDU作为第n层的SDU，加上第n层的PCI，变成了第n层的PDU，交给第n-1层后作为SDU发送，接收方接收时做相反处理。故可知三者的关系是n-SDU+n-PCI=n-PDU=(n-1)-SDU. 二、协议、接口、服务 协议 协议，就是规则的集合。在网络中要做到有条不紊地交换数据，就必须遵循一些事先约定好的规则，这些规则明规定了所交换的数据的格式及有关的同步问题。这些为进行网络中的数据交换而建立的规则、标准或约定称为网络协议。它是控制两个（或多个）对等实体进行通信的规则的集合，是水平的。不对等的实体之间没有协议。 接口 接口是同一结点内相邻两层之间交换信息的连接点，是一个系统内部的规定。每层只能为紧邻的层次之间定义接口，不能跨层定义接口。在典型的接口上，同一结点相邻两层的实体通过服务访问点（SAP）进行交互。服务是通过SAP提供给上层使用的，第n层的SAP就是第n+1层可以访问第n层服务的地方。 服务 服务是指下层为紧邻的上层提供的功能调用，它是垂直的。 上层使用下层所提供的服务时必须与下层交换一些命令，这些命令在OSI中称为服务原语。OSI将原语划分为4类：1）请求：由服务用户发往服务提供者，请求完成某项工作 2）指示：由服务提供者发往服务用户，提示用户做某件事 3）相应：由服务用户发往服务提供者，作为对指示的响应 4）证实：由服务提供者发往服务用户，作为对请求的证实 并非在一层内完成的全部功能都称为服务，只有那些能够被高一层实体“看得见”的功能才称为服务。 计算机网络提供的服务可按以下三种方式分类： （1）面向连接服务于无连接服务 在面向连接服务中，通信前双方必须先建立连接，分配相应的资源，以保证通信能正常进行，传输结束后释放连接和所占用的资源。因此这种服务可分为建立连接、数据传输和释放连接三个阶段。TCP就是一种面向连接服务的协议。 在无连接服务中，通信前双方不需要先建立连接，需要发送数据时可直接发送，把每个带有目的地址的包传送到线路上，由系统选定路线进行传输。这是一种不可靠的服务，这种服务常被描述为“尽最大可能交付”，它不能保证通信的可靠性。例如IP、UDP就是一种无连接服务的协议。 （2）可靠服务与不可靠服务 可靠服务是网络具有检错、纠错、应答机制，能保证数据正确、可靠地传送到目的地。 不可靠服务是指网络只是尽量正确、可靠地传送，而不能保证数据正确、可靠地传送到目的地，是一种尽力而为的服务。 （3）有应答服务和无应答服务 有应答服务是指接收方在收到数据后向发送方给出相应的应答，该应答由传输系统同内部自动实现，而不由用户实现。所发送的应答既可以是可乐定应答，也可以是否定应答，通常在接收到数据有错误时发送否定应答。文件传输服务就是一种有应答服务。 无应答服务是指接收方收到数据后不自动给出应答。若需要应答，则由高层实现。例如，对于WWW服务，客户端收到服务器发送的页面文件不给出应答。 三、ISO/OSI参考模型和TCP/IP模型 OSI参考模型 国际标准化组织（ISO）提出的网络体系结构模型，称为开放系统互联参考模型。通常简称为OSI模型。OSI有7层，自下而上依次是物理层、数据链路层、网络层、传输层、会话层、表示层、应用层。 低三层称为通信子网，它是为了联网而附加的通信设备，完成数据的传输功能；高三层统称为资源子网，它相当于计算机系统，完成数据的处理等功能。 1）物理层 物理层的传输单位是比特，任务是透明的传输比特流，功能是在物理媒体上为数据端设备透明地提供传输原始比特流。 物理层主要定义数据终端设备(DTE)和数据通信设备（DCE）的物理与逻辑连接方法，所以物理层协议也称为物理层接口标准，也称为规程。 2）数据链路层 数据链路层的传输单位是帧，任务是将网络层传来的IP数据报组装成帧。数据链路层的功能可以概括为成帧、差错控制、流量控制和传输管理。 典型的数据链路层协议有SDLC、HDLC、PPP、STP和帧中继等。 3）网络层 网络层的传输单位是数据报，它关心的是通信子网的运行控制，主要任务是把网络层的协议数据单元（分组）从源端传送到目的端，为分组交换网上的不同主机提供通信服务。关键问题是对分组进行路由选择，并实现流量控制、拥塞控制、差错控制和网际互联等功能。 网络层的协议有IP、IPX、ICMP、IGMP、ARP 、RARP、OSPF等 4）传输层 传输层也称为运输层，传输大单位是报文段（TCP）或用户数据报（UDP），传输层负责主机中两个进程之间的通信，功能是为端到端连接提供可靠的传输服务，为端到端连接提供流量控制、差错控制、服务质量、数据传输管理等服务。 数据链路层提供的是点对点的通信，传输层提供的是端到端的通信。 传输层的协议有TCP、UDP 5）会话层 会话层允许不同的主机上的各个进程之间进行通信。会话层利用传输层提供的端到端的服务向表示层提供它的增值服务。这种服务主要为表示层实体或用户进程建立连接并在连接上有序地传输数据，这就是会话，也称为建立同步(SYN)。 会话层负责管理主机间的会话进程，包括建立、管理及终止进程间的会话。会话层可以使用校验点使通信会话在通信失效时从校验点继续恢复通信，实现数据同步。 6）表示层 表示层主要用于处理在两个通信系统中交换信息的表示形式。不同机器采用的编码和表示方法不同，使用的数据结构也不同。为了使不同表示方法的数据和信息之间能互相交流，表示层采用抽象的标准方法定义数据结构，并采用标准的编码形式。数据压缩、加密和解密也是表示层可提供的数据表示交换功能。 7）应用层 应用层是OIS模型的最高层，是用户与网络的界面。应用层为特定类型的网络应用提供访问OSI环境的手段。因为用户的实际应用多种多样，这就要求应用层采用不同的应用协议来解决不同类型的应用要求，因此应用层是最复杂的一层，使用的协议也最多。 典型的应用层协议有用于文件传输的FTP、用于电子邮件的SMTP、用于万维网的HTTP等。 TCP/IP模型 TCP/IP模型从低到高依次是网络接口层（对应OSI参考模型中的物理层和数据链路层）、网际层、传输层和应用层（对应OSI模型的会话层、表示层、应用层）。 1）网络接口层 网络接口层的功能类似于OSI的物理层和数据链路层。它表示与物理网络的接口，但实际上TCP/IP本身并未真正描述这一部分，只是指出主机必须使用某种协议和网络连接，以便在其上传递IP分组。 2）网际层 网际层（主机-主机）是TCP/IP体系结构的关键部分。它和OSI网络层在功能上是非常相似的。网际层将分组发往任何网络，并为之独立地选择合适的路由，但它不保证各个分组有序地到达，各个分组的有序交付由高层负责。 3）传输层 传输层（应用-应用或进程-进程）的功能同样与OSI中的传输层类似，使得发送端和目的端主机的对等实体进行会话。传输层主要使用以下两种协议：（1） 传输控制协议（Transmission Control Protocol，TCP）。它是面向连接的，数据传输的单位是报文段，能够提供可靠的交付。 （2）用户数据报协议（User Datagram Protocol，UDP）。它是无连接的，数据传输的单位是用户数据报，不能保证提供可靠的交付，只能提供“尽最大努力交付”。 4）应用层（用户-用户）包含所有的高层协议。IP协议是因特网中的核心协议；TCP/IP可以为各种各样的应用提供服务，同时TCP/IP也允许在由各种网络构成的互联网上运行。 TCP/IP模型与OSI模型的比较 1）二者都采用分层的体系结构，分层的功能也大体相似 2）二者都基于独立的协议栈概念 3）二者都可以解决异构网络的互联，实现世界上不同厂家生产的计算机之间的通信 4）OSI模型最大的贡献是精确地定义了三个主要的概念：服务，协议和接口，与现代的面向对象程序设计思想非常吻合。而TCP/IP模型在这三个概念上却没有明确区分，不符合软件工程的思想 5）OSI模型产生在协议之前，没有偏向于任何特定的协议，通用性良好。TCP/IP模型产生于协议之后，实际是对协议的描述 6）TCP/IP在设计之初就考虑了多种异构网的互联问题，并将网际协议（IP）作为一个单独的重要层次。OSI模型最初只考虑到用一种标准的公用数据网络将不同的系统互联。OSI模型认识到网际协议IP的重要性后，只好在网络层中划分出一个子层来完成类似于TCP/IP模型中的IP功能 7）OSI模型在网络层支持无连接和面向连接的通信，但在传输层仅有面向连接的通信。而TCP/IP模型认为可靠性是端到端的问题，因此它在网际层仅有一种无连接的通信模式，但传输层支持无连接和面向连接两种模式。]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>网络体系结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[通信基础]]></title>
    <url>%2F2019%2F06%2F10%2F%E9%80%9A%E4%BF%A1%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[写在前面 物理层协议的主要任务就是确定与传输媒体的接口有关的一些特性，如下所述： 机械特性：指明接口所用接线器的形状和尺寸、引脚数目和排列、固定和锁定装置等。 电气特性：指明在接口电缆的各条线上出现的电压范围1. 功能特性：指明某条线上出现的某一电平代表何种意义。 过程特性：指明对于不同功能的各种可能事件的出现顺序。 一、数据通信的模型一个数据通信系统可划分为三大部分，即源系统（或发送端，发送方）、传输系统（或传输网络）和目的系统（或接收方、接收端）。 源系统一般包括两部分： 源点：源点设备产生要传输的数据。 发送器：通常源点生成的数字比特流要通过发送器编码之后才能在传输系统中进行传输。 目的系统一般包括两部分： 接收器：接收传输系统传送过来的信号，并把它转换为能够被目的设备处理的信息。 终点：终点设备从接收器获取传送来的数字比特流，然后进行信息输出。终点又称为目的站或信宿。 在源系统和目的系统之间的传输系统可以是简单的传输线路，也可以是连接在源系统和目的系统之间的复杂网络系统。 通信的目的是传送消息。 数据是消息的实体。 信号是数据的电器或电磁表现。根据信号中代表的消息的参数的取值方式不同，信号可分为两类： 模拟信号（或连续信号）——消息的参数的取值时连续的 数字信号（或离散信号）——消息的参数的取值时离散的。在使用时间域的波形表示数字信号时，代表不同离散数值的基本波形就称为码元。在使用二进制编码时，只有两种不同的码元，一种代表0状态，另一种代表1状态。 速率、波特与带宽 速率也称为数据率，指的是数据的传输速率，表示单位之间内传输的数据量。可以用码元传输速率和信息传输速率表示。 码元传输速率。又称码元速率，波形速率等，它表示单位时间内数字通信系统所传输的码元个数，单位是波特（Baud）。1波特表示数字通信系统每秒传输一个码元。这里的码元可以是多进制的，也可以是二进制的，但码元速率与进制数无关。 信息传输速率。又称信息速率，比特率等。它表示单位时间内数字通信系统传输的二进制码元数（即比特数），单位是比特/秒（b/s). 二、编码与调制 常用编码方式 要利用信道传输数据，必须将数据转换为能在传输媒体媒体上传送的信号。信道可以分为传送模拟信号的模拟信道和传送数字信号的数字信道两大类。 将数字数据转换为数字信号的过程称为编码。 将数字信号转换为模拟信号的过程称为调制。 归零制：正脉冲代表1，负脉冲代表0； 不归零制：正电平代表1，负电平代表0； 曼彻斯特编码：位周期中心的是上跳变代表0，位周期中心的下跳变代表1； 差分曼彻斯特编码：在每一位的中心处始终有跳变。位开始边界有跳变代表0，而位边界没有跳变代表1； 基本的调制方法 矩形脉冲波形的数字信号包含从直流开始的低频分量，被称为基带信号 在数字信道上直接传输基带信号的方法称为基带传输 基带信号往往包含较多的低频成分，甚至直流成分。而许多模拟信道仅能通过某一频率范围的信号，不能直接传输这种基带信号。因此必须对基带信号进行调制，使它能够在模拟信道中传输。 在很多情况下，需要使用载波进行调制，把基带信号的频率范围搬移到较高的频段以便在信道中传输。经过载波调制后的信号称为带通信号，而使用载波的调制称为带通调制。 最基本的带通调制的方法有：1）调幅（AM），即载波的增幅随基带数字信号而变化。 2）调频（FM），即载波的频率随着基带数字信号的变化而变化。 3）调相（PM），即载波的初始相位随基带数字信号而变化。 在数字通信中，调幅、调频和调相相应地称为幅移键控、频移键控和相移键控。实现调制和解调功能的设备称为调制解调器。 三、奈奎斯特定理与香农定理 奈奎斯特定理 奈奎斯特定理又称奈氏准则。它指出在理想低通（没有噪声、带宽有限）的信道中，极限码元速率为2W波特，其中W是理想低通信道的带宽，单位是Hz。若用V表示每个码元离散电平的数目（码元的离散电平数目是指有多少种不同的码元，比如有16种不同的码元，则需要有4位二进制位，因此数据传输率是码元传输率的4倍），则极限速率为 ​ 理想低通信道下的极限数据传输率=$2Wlog_2V$（单位为b/s) 对于奈氏准则，可以得出以下结论： 1）在任何信道中，码元传输的速率是有上限的。若传输速率超过此上限，就会出现严重的码间串扰问题，使得接收端不可能完全正确地识别码元。 2）信道的频带越宽(即通过的信号高频分量越多)，就可用更高的速率进行码元的有效传输。 3）奈氏准则给出了码元传输速率的限制，但是并未对信息传输速率给出限制，即未对一个码元可以对应多少个二进制位给出限制。 由于码元的传输速率受奈氏准则的制约，所以要提高数据的传输速率，就必须设法使每个码元携带更多个比特的信息量，此时就需要多元制的调制方法。 香农定理 香农定理给出了带宽受限且有高斯白噪声干扰的信道的极限数据传输率，当用此速率进行传输时，可以做到不产生误差。香农定理定义为： ​ 信道的极限数据传输率=$Wlog_2(1+S/N)$ 单位为b/s 式中，W为信道带宽，S为信道所传输信号的平均功率，N为信道内部的高斯噪声功率，$S/N$为信噪比，即信号的平均功率与噪声的平均功率之比。 对于香农定理，可以得出以下的结论：1）信道的带宽或信道中的信噪比越大，信息的极限传输速率越高。 2）对一定的传输带宽和一定的信噪比，信息传输速率的上限是确定的。 3）只要信息的传输速率低于信道的极限传输速率，就能找到某种方法来实现无差错的传输。 4）香农定理得出的是极限信息传输速率，实际信道能达到的传输速率比它低不少。 从香农定理可以看出，若信道带宽W或信噪比S/N没有上限，则信道的极限信息传输速率也没有上限。 奈氏准则只考虑了带宽与极限码元速率的关系，而香农定义不仅考虑了带宽，而且考虑到了信噪比。这从另一个侧面表明，一个码元对应的二进制位数是有限的。 四、传输方式 并行传输与串行传输 并行传输，是指一次发送n个比特而不是一个比特，为此，在发送端和接收端之间需要有n条传输线路。 串行传输，是指数据是一个比特一个比特发送的，为此，发送端和接收端之间只需要一条传输线路。 异步传输与同步传输 异步传输以字节为独立的传输单位，字节之间的时间间隔不是固定的，接收端仅在每个字节的起始处对字节内的比特实现同步。为此，通常需要在每个字节前后分别加上起始位和结束位，这里的异步是指在字节级上的异步，但是字节中的每个比特仍然要同步，它们的持续时间是相同的。 采用同步传输方式时，数据块以稳定的比特流形式传输，字节之间没有间隔，也没有起始位和结束位。由于不同设备的时钟频率存在一定差异，为避免在传输大量数据的过程中累积误差所导致的错误，要采取技术使得收发双方的时钟保持同步。实现收发双方时钟同步的方法有两种，即外同步和内同步。 外同步，是在发送端和接收端之间提供一条单独的时钟线，发送端在发送数据信号的同时，另外发送一条时钟同步信号。接收端根据接收到的时钟同步信号来校正时间基准，实现收发双方之间的同步。 内同步，是发送端将时钟同步信号编码到发送数据中一起传输，如曼彻斯特编码与差分曼彻斯特编码都含有时钟编码，具有自同步能力。 单工、半双工、全双工 1）单向通信，又称为单工通信，即只能有一个方向的通信而没有反方向的交互。如广播等。 2）双向交替通信，又称半双工通信，即通信的双方都可以发送信息，但不能双方同时发送。这种通信方式是一方发送另一方接收，过一段时间再反回来。 3）双向同时通信，又称为全双工通信，即通信的双方可以同时发送和接收信息。]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>通信</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机网络概述]]></title>
    <url>%2F2019%2F06%2F10%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%A6%82%E8%BF%B0%2F</url>
    <content type="text"><![CDATA[写在前面一般认为，计算机网路是一个将分散的、具有独立功能的计算机系统，通过通信设备与线路连接在一起，由功能完善的软件实现资源共享和信息传递的系统。简言之，计算机网络就是一些互联的、自治的计算机系统的集合。 一、计算机网络在计算机的不同发展阶段，网络有不同的定义，这些定义反映了当时网络技术的发展水平。分为三类： 广义观点 广义观点认为，只要是能实现远程信息处理的系统或能进一步达到资源共享的系统，，都是计算机网络。 资源共享观点 资源共享观点认为，计算机网络是“以能够相互共享资源的方式互联起来的自治计算机系统的集合”。这个定义符合目前计算机网络的基本特征。 用户透明性观点 这种观点认为，存在一个能为用户自动管理资源的网络操作系统。它能够调用用户所需要的资源，而整个网络就像是一个大的计算机系统一样对用户是透明的。用户透明性观点的定义描述了一个分布式系统，它是网络未来发展追求的目标。 二、计算机网络的组成从不同的角度，可以将计算机网路的组成分为以下几类： 从组成部分上来看，一个完整的计算机网络主要由硬件、软件、协议散发部分组成。硬件主要由主机（端系统）、通信链路（如双绞线、光纤）、交换设备（如交换机、路由器）和通信处理机（如网卡）等组成。软件主要包括各种实现资源共享的软件和方便用户使用的各种工具软件。软件部分多属于应用层。协议是计算机网络的核心。 从工作方式看，计算机网络可分为边缘部分和核心部分。边缘部分由所有连接到因特网上、供用户使用的端系统组成，用来进行通信和资源共享。核心部分由大量的网络和连接这些网络的路由器组成，为边缘部分提供连通性和交换服务。 从功能组成上看，计算机网络由通信子网和资源子网构成。通信子网由各种传输介质、通信设备和相应的网络协议组成，它使网络具有数据传输、交换、控制和存储的能力，实现联网计算机之间的数据通信。资源子网是实现资源共享功能的设备及其软件的集合，向用户提供共享其他其他计算机上的硬件资源、软件资源和数据资源的服务。 三、计算机网络的功能计算机网路的功能很多，现如今的很多应用都与网络有关。主要有下面5个部分。 数据通信 它是计算机网络最基本也是最重要的功能，用来实现联网计算机之间的各种信息的传输，并将分散在不同地理位置的计算机联系起来，进行统一的调配、控制和管理。 资源共享 资源共享可以是软件共享、数据共享，也可以是硬件共享。使计算机网络中的资源互通有无，分工协作，从而极大地提高了硬件资源、软件资源和数据资源的利用率 分布式处理 当计算机网络中的某个计算机负荷过重时，可以将其处理的某个复杂的任务分配给网络中的其他计算机系统，从而利用空闲资源以提高整个系统的利用率 提高可靠性 计算机网络中的各台计算机通过网络互为替代机 负载均衡 将工作任务均衡地分配给计算机网络中的各台计算机。 四、计算机网络的分类 按分布范围分： 1) 广域网（WAN）。任务是提供长距离通信，运送主机所发送的数据。 2）城域网（MAN）。城域网的覆盖范围可以跨越几个街区甚至几个城市，大多采用以太网技术。 3）局域网（LAN）。局域网一般用微机或工作站通过高速线路相连，覆盖范围较小。传统上，局域网使用广播技术，而广域网使用交换技术。 4）个人局域网（PAN）。在个人工作的地方将消费电子设备用无线技术连接起来的网络。 按传输技术分： 1）广播式网络。所有联网计算机都共享一个公共通信信道。当一台计算机利用共享通信信道发送报文分组时，所有其他的计算机都会“收听”到这个分组。接收到该分组的计算机将通过检查目的地址来决定是否接收该分组。 局域网基本上都采用广播式通信技术，广域网中的无线，卫星通信网络也采用广播式通信技术。 2）点对点网络。每条物理线路连接一对计算机。如果通信的两台计算机之间没有直接连接线路，那么它们之间的分组传输就要通过中间结点的接收、存储和转发，直至目的结点。 是否采用分组存储转发与路由选择机制是点对点网络与广播式网络的重要区别，广域网基本都属于点对点网络。 按拓扑结构分: 网络拓扑结构是指由网中结点（路由器、主机等）与通信线路（网线）之间的几何关系表示的网络结构，主要指通信子网的拓扑结构。 按网络的拓扑结构，主要分为星形、总线形、环形和网状形网络等。星形、总线形和环形网络多用于局域网，网状网络多用于广域网。 1）星形网络。每个终端或计算机都以单独的线路与中央设备相连。中央设备早期是计算机，现在一般是交换机或路由器。星形网络便于集中控制和管理，因为端用户之间的通信必须通过中间设备。缺点是成本高，中心节点对故障敏感。 2）总线形网络。用单根传输线将计算机连接起来。总线形网络的优点是建网容易，增减节点方便，节省线路。缺点是重负载时通信效率不高，总线任意一处对故障敏感。 3）环形网络。所有计算机接口设备连接成一个环。环形网络最典型的例子是令牌环局域网。环可以是单环，也可以是双环，环中信号是单向传输的。 4）网状网络。一般情况下，每个结点至少有两条路径与其他节点相连，多用于广域网中。有规则型和非规则型。其优点是可靠性高，缺点是控制复杂，线路成本高。 按使用者分: 1）公用网。指电信公司出资建造的大型网络。 2）专用网。指某个部门为了满足本单位特殊业务的需要而建造的网络，这种网络不对单位以外的人开放。 按交换技术分： 1）电路交换网络。在源结点和目的结点之间建立一条专用的通路用于传送数据，包括建立连接、传输数据和断开连接三个阶段。最典型的电路交换网络是传统电话网络。 该类网络的主要特点是整个报文的比特流连续地从源点直达终点，好像是在一条管道中传送。优点是数据直接传送，时延小。缺点是线路利用率低、不能充分利用线路容量，不便于进行差错控制。 2）报文交换网络。用户数据加上源地址、目的地址、校验码等辅助信息，然后封装成报文。整个报文传送到相邻结点全部存储后，再转发到下一个结点，重复这一过程直到到达目的结点。每个报文可以单独选择到达目的结点的路径。 报文交换网络也称存储-转发网络，主要特点是整个报文先传送到相邻结点，全部存储后查找转发表，转发到下一个结点。优点是可以较为充分的利用线路容量，可以实现不同链路之间不同数据率的转换，可以实现格式转换，可以实现一对多，多对一的访问，可以实现差错控制。缺点是增大了资源开销，增加了缓冲时延，需要额外的控制机制来保证多个报文的顺序不乱序，缓冲区难以管理。 3）分组交换网络。也称包交换网络。其原理是将数据分为较短的固定长度的数据块，在每个数据块中加上目的地址、源地址等辅助信息组成分组（包），以存储-转发方式传输。 其主要特点是单个分组传送到相邻结点，存储后查找转发表，转发到下一个结点。除具备报文交换网络的优点外，分组交换网络还具有自身的优点：缓冲易于管理；包的平均时延更小，网络占用的平均缓冲更少；易于标准化；更适合应用。现在的主流网络基本上都可视为分组交换网络。 按传输介质分： 传输介质可分为有线和无线两大类，故网络可分为有线网络和无线网络。有线网络又分为双绞线网络，同轴电缆网络等。无线网络可分为蓝牙、微波、无线电等。 五、计算机网络的的性能指标性能指标从不同的方面来度量计算机网络的性能。 速率 速率是数据的传送速率，它也称为数据率或比特率。 带宽 本来表示某个信号具有的频带宽度，单位是赫兹（Hz），而在计算机网络分钟，带宽用来表示网络的通信线路所能传送数据的能力，单位是比特/秒（b/s） 吞吐量 也称为吞吐率，表示单位时间内通过某个网络（或信道、接口）的数据量。 时延 时延是指一个数据（一个报文或分组，甚至比特）从网路（或链路）的一端传送到另一端所需要的时间。时延有时称为延迟或迟延。 1）发送时延，是主机或路由器将分组发送到通信线路上所需要的时间。 1发送时延=分组长度/发送速率 2）传播时延，是电磁波在信道中传播需要一定的距离而花费的时间。 1传播时延=信道长度/电磁波在信道上的传播速率 3）处理时延，主机或路由器收到分组时要花费一定的时间进行处理，例如，分析分组的首部、从分组中提取数据部分、进行差错检验或查找适当的路由等，这就产生了处理时延。 4）排队时延，分组在进入路由器后要先在输入队列在排队等待处理。路由器确定转发端口后，还要在输出队列中排队等待转发，这就产生了排队时延。 这样，分组从一个结点转发到另一个结点转发到另一个结点所经历的时延就是以上4种时延之和。 1总时延=发送时延+传播时延+处理时延+排队时延 丢包率 即分组丢失率，是指在一定的时间范围内，分组在传输过程中丢失的分组数量和总的分组数量的比率。 分组丢失的两种情况：一是因为传输过程中出现比特级差错被结点丢弃。二是因为分组交换机队列溢出。 利用率 令D0表示网络空闲时的时延，D表示网络当前时延，那么在适当的假定条件下，利用率可表示为：D=D0/1-U。 信道或网络利用率过高会产生非常大的时延。 时延带宽积 指发送端连续发送数据且发送的第一个比特即将到达终点时，发送端已经发出的比特数，即时延带宽积=传播时延*信道带宽。]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[顺序循环链表的实现]]></title>
    <url>%2F2019%2F03%2F31%2F%E9%A1%BA%E5%BA%8F%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8%E7%9A%84%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[写在前面&emsp;&emsp;队列（Queue)是一种特殊的线性表，是一种只允许在表的一端进行插入操作，在表的另一端进行删除操作的线性表。表中允许进行插入操作的一端称为队尾，允许进行删除操作的一端为队头。队头和队尾分别由队头指示器和队尾指示器指示。队列的插入操作通常称为入队，队列的删除操作通常称为出队。当队列中没有元素时，为空队列。&emsp;&emsp;根据队列的定义，每次进队列的数据元素都放在原来的队尾之后成为新的队尾元素，每次出队列得到数据元素都是原来的队头元素。这样，最先入队的数据元素总是最先出队，所以队列也被称为先进先出表。&emsp;&emsp;对队列的操作主要有：初始化建立队列、入队列、出队列、取队头元素、判断队列是否为空等操作。 1.顺序队列的类定义 123456789101112131415161718192021const int maxsize = 10;template&lt;class T&gt;class Queue&#123;public: Queue();//构造函数 ~Queue() &#123;&#125;;//析构函数 void insert(const T&amp;item);//入队 T delet();//出队列 T readFront() const;//读队头元素 bool empty() const;//判断队列是否为空 void clearQueue();//清空队列 int getsize() const;//获取队列长度 void display() const;//输出队列中的元素private: T data[maxsize]; int front; int rear; int count;&#125;; 2.顺序队列类的实现 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970template&lt;class T&gt;inline Queue&lt;T&gt;::Queue()&#123; front = 0; rear = 0; count = 0;&#125;template&lt;class T&gt;inline void Queue&lt;T&gt;::insert(const T &amp; item)&#123; if (count == maxsize) &#123; cout &lt;&lt; "Queue is full" &lt;&lt; endl; exit(1); &#125; count++; data[rear] = item; rear = ((rear + 1) == maxsize) ? 0 : (rear + 1); &#125;template&lt;class T&gt;inline T Queue&lt;T&gt;::delet()&#123; if (count&lt;=0) &#123; cout &lt;&lt; "Queue is empty" &lt;&lt; endl; &#125; count--; T p = data[front]; front = ((front + 1) == maxsize) ? 0 : (front + 1); return p;&#125;template&lt;class T&gt;inline T Queue&lt;T&gt;::readFront() const&#123; return data[front];&#125;template&lt;class T&gt;inline bool Queue&lt;T&gt;::empty() const&#123; return (count == 0);&#125;template&lt;class T&gt;inline void Queue&lt;T&gt;::clearQueue()&#123; count = 0; front = rear = 0;&#125;template&lt;class T&gt;inline int Queue&lt;T&gt;::getsize() const&#123; return count;&#125;template&lt;class T&gt;inline void Queue&lt;T&gt;::display() const&#123; int i = 0; while (i != count) &#123; cout &lt;&lt; i &lt;&lt; "号元素：" &lt;&lt; data[i] &lt;&lt; endl; i++; &#125;&#125; 3.测试主函数 1234567891011121314151617181920void test()&#123; Queue&lt;int&gt; queue; for (int i = 0; i &lt; 10; i++) &#123; queue.insert(i); &#125; cout &lt;&lt;"队列的长度为："&lt;&lt; queue.getsize() &lt;&lt; endl; queue.display(); cout &lt;&lt;"队头元素为："&lt;&lt; queue.readFront() &lt;&lt; endl; cout &lt;&lt; "元素："&lt;&lt;queue.delet()&lt;&lt;"已删除" &lt;&lt; endl;&#125;int main()&#123; test(); system("pause"); return EXIT_SUCCESS;&#125; 输出结果如下：]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>顺序循环链表</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[链式队列的实现]]></title>
    <url>%2F2019%2F03%2F31%2F%E9%93%BE%E5%BC%8F%E9%98%9F%E5%88%97%E7%9A%84%E5%AE%9E%E7%8E%B0-1%2F</url>
    <content type="text"><![CDATA[写在前面&emsp;&emsp;链式队列是队列的链式存储结构表示。队列是操作受限的表，队列有队头和队尾，插入元素的一端称为队尾，删除元素的一端称为队头。这和一般排队的概念一样，后来的人排在队尾，首先对队头的人进行服务，对队头的人服务后，原当前队头后的人就排在了当前队头。新来的人排在队尾后，原队尾的人就不再是当前队尾了，新来的人就成了当前队尾。&emsp;&emsp;链式队列的队头指针指在队列的当前队头节点位置，队尾指针指在队列的当前队尾节点位置。不带头节点的链式队列，出队列时可直接删除头指针所指的节点，因此，链式队列不带头指针时更加方便。 1.链式队列节点类的定义和实现 12345678910111213141516171819202122template&lt;class T&gt;class LinkQueue;template&lt;class T&gt;class QueueNode&#123; friend class LinkQueue&lt;T&gt;;public: T data; QueueNode&lt;T&gt;(const T&amp; item, QueueNode&lt;T&gt; *ptrNext = NULL); ~QueueNode() &#123;&#125;;private: QueueNode&lt;T&gt; *next;&#125;;template&lt;class T&gt;inline QueueNode&lt;T&gt;::QueueNode(const T &amp; item, QueueNode&lt;T&gt;* ptrNext)&#123; this-&gt;data = item; this-&gt;next = ptrNext;&#125; 2.链式队列类的定义 1234567891011121314151617181920template&lt;class T&gt;class LinkQueue&#123;public: LinkQueue();//构造函数 ~LinkQueue();//析构函数 void insert(const T&amp; item);//入队 T delet();//出队 T readFront() const;//读队头元素 bool empty() const;//判断队列是否为空 void clearQueue();//清空队列 int getSize() const;//取队列长度 void display() const;//输出队列元素private: QueueNode&lt;T&gt; *front;//指向队头的指针 QueueNode&lt;T&gt; *rear;//指向队尾的指针 int size;&#125;; 3.链式队列类的实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990template&lt;class T&gt;inline LinkQueue&lt;T&gt;::LinkQueue()&#123; size = 0; front = rear = NULL;&#125;template&lt;class T&gt;inline LinkQueue&lt;T&gt;::~LinkQueue()&#123; clearQueue(); front = rear = NULL;&#125;template&lt;class T&gt;inline void LinkQueue&lt;T&gt;::insert(const T &amp; item)&#123; QueueNode&lt;T&gt; *new_node = new QueueNode&lt;T&gt;(item); if (rear != NULL) &#123; rear-&gt;next = new_node; &#125; rear = new_node; if (front == NULL) &#123; front = new_node; &#125; size++;&#125;template&lt;class T&gt;inline T LinkQueue&lt;T&gt;::delet()&#123; if (size == 0) &#123; cout &lt;&lt; "Queue is empty" &lt;&lt; endl; exit(1); &#125; T member = front-&gt;data; QueueNode&lt;T&gt; *p = front-&gt;next; delete front; front = p; size--; return member;&#125;template&lt;class T&gt;inline T LinkQueue&lt;T&gt;::readFront() const&#123; return front-&gt;data;&#125;template&lt;class T&gt;inline bool LinkQueue&lt;T&gt;::empty() const&#123; return (size==0);&#125;template&lt;class T&gt;inline void LinkQueue&lt;T&gt;::clearQueue()&#123; QueueNode&lt;T&gt; *p1, *p2; p1 = front; while (p1 != NULL) &#123; p2 = p1; p1 = p1-&gt;next; delete p2; &#125; size = 0;&#125;template&lt;class T&gt;inline int LinkQueue&lt;T&gt;::getSize() const&#123; return size;&#125;template&lt;class T&gt;inline void LinkQueue&lt;T&gt;::display() const&#123; QueueNode&lt;T&gt; *p = front; int i = 0; while (p != NULL) &#123; cout &lt;&lt; "第" &lt;&lt; i &lt;&lt; "号元素为：" &lt;&lt; p-&gt;data &lt;&lt; endl; i++; p = p-&gt;next; &#125;&#125; 4.测试主函数 123456789101112131415161718192021222324252627282930313233343536373839404142434445void test()&#123; LinkQueue&lt;int&gt; queue; for (int i = 0; i &lt; 10; i++) &#123; queue.insert(i * 10); &#125; cout &lt;&lt; "队列长度为：" &lt;&lt; queue.getSize() &lt;&lt; endl; queue.display(); cout &lt;&lt; "栈顶元素为：" &lt;&lt; queue.readFront() &lt;&lt; endl; for (int i = 0; i &lt; 10; i++) &#123; cout &lt;&lt; "元素：" &lt;&lt; queue.delet() &lt;&lt; "被删除" &lt;&lt; endl; &#125; cout &lt;&lt; "队列长度为：" &lt;&lt; queue.getSize() &lt;&lt; endl;&#125;int main()&#123; test(); system("pause"); return EXIT_SUCCESS;&#125;void test()&#123; LinkQueue&lt;int&gt; queue; for (int i = 0; i &lt; 10; i++) &#123; queue.insert(i * 10); &#125; cout &lt;&lt; "队列长度为：" &lt;&lt; queue.getSize() &lt;&lt; endl; queue.display(); cout &lt;&lt; "栈顶元素为：" &lt;&lt; queue.readFront() &lt;&lt; endl; for (int i = 0; i &lt; 10; i++) &#123; cout &lt;&lt; "元素：" &lt;&lt; queue.delet() &lt;&lt; "被删除" &lt;&lt; endl; &#125; cout &lt;&lt; "队列长度为：" &lt;&lt; queue.getSize() &lt;&lt; endl;&#125;int main()&#123; test(); system("pause"); return EXIT_SUCCESS;&#125; 输出结果如下：]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>队列</tag>
        <tag>链式队列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[双向循环链表]]></title>
    <url>%2F2019%2F03%2F28%2F%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[写在前面&emsp;&emsp;双向循环链表（Double Circular Linked List)是每个节点有前趋指针和后继指针，且后继指针和前趋指针各自构成自己的单循环链表的链表。&emsp;&emsp;在单链表中查找当前节点的后继节点并不困难，可以通过当前节点的next指针进行，但要查找当前节点的前趋节点就要从头指针head开始重新进行。对于一个要进行频繁查找当前节点的后继节点和当前节点的前趋节点的应用来说，使用单链表的时间效率是非常低的，双向链表是有效解决这类问题的选择。&emsp;&emsp;在双向链表中，每个节点包括三个域，分别是data,next,prior。其中data为数据域，next为后继节点指针，prior为前趋节点指针。&emsp;&emsp;双向链表通常均为双向循环链表，这是因为读双向循环链表，不论是插入还是删除，对第一个节点、最后一个节点的操作和对链表中间任意一个节点的操作过程是一样的。而双向非循环链表对这些节点的操作是不同的。 1.节点类的定义和实现 1234567891011121314151617181920212223242526template&lt;class T&gt;class DCirlist;template&lt;class T&gt;class DLnode&#123; friend class DCirlist&lt;T&gt;;public: T data; //构造函数，无数据域的头结点 DLnode&lt;T&gt;(DLnode&lt;T&gt; *ptrn = NULL, DLnode&lt;T&gt; *ptrp = NULL)&#123;&#125;; //构造函数，非头节点的节点 DLnode&lt;T&gt;( T item, DLnode&lt;T&gt; *ptrn = NULL, DLnode&lt;T&gt; *ptrp = NULL); //析构函数 ~DLnode() &#123;&#125;;private: DLnode&lt;T&gt; *next; DLnode&lt;T&gt; *prior;&#125;;template&lt;class T&gt;inline DLnode&lt;T&gt;::DLnode(T item, DLnode&lt;T&gt;* ptrn, DLnode&lt;T&gt;* ptrp)&#123; this-&gt;data = item; this-&gt;next = ptrn; this-&gt;prior = ptrp;&#125; &emsp;&emsp;双向循环链表只是在单循环链表的基础上又增加了一个指向前趋节点的指针，而且指向前趋节点指针也构成了自己的单循环链表。双循环链表的定义与单循环链表的定义非常相似。 2.双向循环链表类的定义 1234567891011121314151617181920212223242526272829template &lt;class T&gt;class DCirlist&#123;public: DCirlist();//构造函数 ~DCirlist();//析构函数 int listsize() const;//返回链表长度 bool empty() const;//判断链表是否为空 DLnode&lt;T&gt; *index(int pos) const;//返回指向第pos个节点的指针 void insert(const T &amp;item, int pos);//在第pos个节点插入item T del(int pos);//删除第pos个节点，并返回数据域 T getdata(int pos) const;//返回第pos个节点的值 void clearlist();//清空表 DLnode&lt;T&gt; *reset(int pos = 0); DLnode&lt;T&gt; *next(); DLnode&lt;T&gt; *prior(); bool EndOfList() const;//是否到链表尾 bool nextEndoflist() const;//currPtr-&gt;next是否到链表尾 bool PriorEndoflist() const;//currPtr-&gt;prior是否到链表尾 T deleprior();//删除currPtr节点，新currPtr是原currPtr的前趋，返回数据域private: DLnode&lt;T&gt; *head; DLnode&lt;T&gt; *currPtr; int size;&#125;; 3.双向循环链表类的实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178template&lt;class T&gt;inline DCirlist&lt;T&gt;::DCirlist()&#123; head = new DLnode&lt;T&gt;(); head-&gt;next = head; head-&gt;prior = head; size = 0;&#125;template&lt;class T&gt;inline DCirlist&lt;T&gt;::~DCirlist()&#123; clearlist(); delete head; head = NULL;&#125;template&lt;class T&gt;inline int DCirlist&lt;T&gt;::listsize() const&#123; return size;&#125;template&lt;class T&gt;inline bool DCirlist&lt;T&gt;::empty() const&#123; return (size == 0);&#125;template&lt;class T&gt;inline DLnode&lt;T&gt;* DCirlist&lt;T&gt;::index(int pos) const&#123; if (pos == -1) &#123; return head; &#125; if (pos&lt;0 || pos&gt;size) &#123; cout &lt;&lt; "illegal operator" &lt;&lt; endl; exit(1); &#125; int i = 0; DLnode&lt;T&gt; *p = head-&gt;next; while (i &lt; pos&amp;&amp;p != head) &#123; p = p-&gt;next; i++; &#125; return p;&#125;template&lt;class T&gt;inline void DCirlist&lt;T&gt;::insert(const T &amp; item, int pos)&#123; DLnode&lt;T&gt; *p = index(pos-1); DLnode&lt;T&gt; *new_node = new DLnode&lt;T&gt;(item, NULL, NULL); new_node-&gt;prior = p; p-&gt;next-&gt;prior = new_node; new_node-&gt;next = p-&gt;next; p-&gt;next = new_node; size++;&#125;template&lt;class T&gt;inline T DCirlist&lt;T&gt;::del(int pos)&#123; if (size == 0) &#123; cout &lt;&lt; "list is empty" &lt;&lt; endl; exit(1); &#125; if (pos&lt;0 || pos&gt;size) &#123; cout &lt;&lt; "illegal operator" &lt;&lt; endl; exit(1); &#125; DLnode&lt;T&gt; *p = index(pos); p-&gt;prior-&gt;next = p-&gt;next; p-&gt;next-&gt;prior = p-&gt;prior; T data = p-&gt;data; delete p; size--; return data;&#125;template&lt;class T&gt;inline T DCirlist&lt;T&gt;::getdata(int pos) const&#123; DLnode&lt;T&gt; *p = index(pos); return p-&gt;data;&#125;template&lt;class T&gt;inline void DCirlist&lt;T&gt;::clearlist()&#123; DLnode&lt;T&gt; *p1, *p2; p1 = head-&gt;next; while (p1 != head) &#123; p2 = p1; p1 = p1-&gt;next; delete p2; &#125; size = 0;&#125;template&lt;class T&gt;inline DLnode&lt;T&gt;* DCirlist&lt;T&gt;::reset(int pos)&#123; if (pos == -1) &#123; return head; &#125; if (pos&lt;0 || pos&gt;size) &#123; cout &lt;&lt; "illegal operator" &lt;&lt; endl; exit(1); &#125; int i = 0; currPtr = head-&gt;next; while (i &lt; pos&amp;&amp;currPtr != head) &#123; currPtr = currPtr-&gt;next; i++; &#125; return currPtr;&#125;template&lt;class T&gt;inline DLnode&lt;T&gt;* DCirlist&lt;T&gt;::next()&#123; if (currPtr!= NULL) &#123; currPtr = currPtr-&gt;next; &#125; return currPtr; &#125;template&lt;class T&gt;inline DLnode&lt;T&gt;* DCirlist&lt;T&gt;::prior()&#123; if (currPtr != NULL) &#123; currPtr = currPtr-&gt;prior; &#125; return currPtr;&#125;template&lt;class T&gt;inline bool DCirlist&lt;T&gt;::EndOfList() const&#123; return (currPtr == head);&#125;template&lt;class T&gt;inline bool DCirlist&lt;T&gt;::nextEndoflist() const&#123; return (currPtr-&gt;next == head);&#125;template&lt;class T&gt;inline bool DCirlist&lt;T&gt;::PriorEndoflist() const&#123; return (currPtr-&gt;prior == head);&#125;template&lt;class T&gt;inline T DCirlist&lt;T&gt;::deleprior()&#123;//删除当前节点的前一节点 DLnode&lt;T&gt; *p = currPtr-&gt;prior; currPtr-&gt;prior-&gt;next = currPtr-&gt;next; currPtr-&gt;next-&gt;prior = currPtr-&gt;prior; T data = currPtr-&gt;data; delete currPtr; size--; currPtr = p; return currPtr;&#125; 4.测试主函数 1234567891011121314151617181920212223242526272829303132void test()&#123; DCirlist&lt;int&gt; list; for (int i = 0; i &lt; 10; i++) &#123; list.insert(i * 10, i); &#125; cout &lt;&lt; "list中元素的个数为：" &lt;&lt; list.listsize() &lt;&lt; endl; DLnode&lt;int&gt; *p = list.reset(); while (!list.EndOfList()) &#123; cout &lt;&lt; p-&gt;data &lt;&lt; endl; p = list.next(); &#125; p = list.next(); cout &lt;&lt; list.del(1) &lt;&lt; "已被删除" &lt;&lt; endl; cout &lt;&lt; "list中元素的个数为：" &lt;&lt; list.listsize() &lt;&lt; endl; while (!list.EndOfList()) &#123; cout &lt;&lt; p-&gt;data &lt;&lt; endl; p = list.next(); &#125; cout &lt;&lt; list.getdata(1) &lt;&lt; endl; cout &lt;&lt; list.index(2)-&gt;data &lt;&lt; endl;&#125;int main()&#123; test(); system("pause"); return EXIT_SUCCESS;&#125; 输出结果如下：]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>双向循环链表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[单循环链表]]></title>
    <url>%2F2019%2F03%2F28%2F%E5%8D%95%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[写在前面&emsp;&emsp;单循环链表，简称循环链表（circular linked list)，是表的一种链式存储结构。&emsp;&emsp;设p是指向循环链表的指针，currPtr是当前指向对的循环链表的指针，head是指向循环链表的头指针，与链表判断是否到达链尾相比，循环链表中判断是否到达链表尾的条件是：p!=head或者是currPtr!=head。所以，循环链表类中成员函数的实现与链表类中的成员函数的实现差别不大，只是把p!=null换成了p!=head，把currPtr!=null换成了currptr!=head. 1.节点类的定义和实现 1234567891011121314151617181920212223242526template&lt;class T&gt;class CirList;template&lt;class T&gt;class ListNode&#123; friend class CirList&lt;T&gt;;//声明友元类public: T data;//数据域 ListNode(ListNode&lt;T&gt; *ptrNext = NULL);//构造函数，用于构造头节点，头节点没有data参数 ListNode(const T &amp;item, ListNode&lt;T&gt; *ptrNext = NULL);//构造函数，主要用于构造非头节点的节点 ~ListNode() &#123;&#125;;//析构函数private: ListNode&lt;T&gt; *next;//指向下一节点的指针&#125;;template&lt;class T&gt;inline ListNode&lt;T&gt;::ListNode(ListNode&lt;T&gt;* ptrNext) :next(ptrNext)&#123;&#125;template&lt;class T&gt;inline ListNode&lt;T&gt;::ListNode(const T &amp; item, ListNode&lt;T&gt;* ptrNext)&#123; this-&gt;data = item; this-&gt;next = ptrNext;&#125; 2.循环链表类的定义 12345678910111213141516171819202122232425262728template &lt;class T&gt;class CirList&#123;public: CirList();//构造函数 ~CirList();//析构函数 int listsize();//长度 bool listempty() const;//是否为空 ListNode&lt;T&gt; *index(int pos);//返回指向位置pos的指针 void insert(const T&amp; item, int pos);//在pos节点前插入一个节点 T del(int pos);//删除第pos个节点 T getdata(int pos) const;//返回pos节点的值域 void clearlist();//清空表为初始状态 ListNode&lt;T&gt; *reset();//currptr指向节点pos并返回currptr ListNode&lt;T&gt; *next();//currptr指向下一节点并返回currptr bool EndOfList() const;//判断是否到了尾部 ，currptr==head bool nextEndofList() const;//currptr-&gt;next是否链表尾 T delAfter();//删除currptr-&gt;next所指节点并返回被删除节点的dataprivate: ListNode&lt;T&gt; *head;//表头指针 int size;//链表的节点个数 ListNode&lt;T&gt; *currPtr;//当前节点指针&#125;; 3.循环链表类的实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146template&lt;class T&gt;inline CirList&lt;T&gt;::CirList()&#123; head = new ListNode&lt;T&gt;(); size = 0; head-&gt;next = head;&#125;template&lt;class T&gt;inline CirList&lt;T&gt;::~CirList()&#123; clearlist(); delete head; head = NULL; &#125;template&lt;class T&gt;inline int CirList&lt;T&gt;::listsize()&#123; return size;&#125;template&lt;class T&gt;inline bool CirList&lt;T&gt;::listempty() const&#123; return (size == 0);&#125;template&lt;class T&gt;inline ListNode&lt;T&gt;* CirList&lt;T&gt;::index(int pos)&#123; if (pos == -1) &#123; return head; &#125; if (pos&lt;0 || pos&gt;size) &#123; cout &lt;&lt; "illegal operator" &lt;&lt; endl; exit(1); &#125; currPtr = head-&gt;next; int i = 0; while (currPtr != NULL &amp; i &lt; pos) &#123; currPtr = currPtr-&gt;next; i++; &#125; return currPtr;&#125;template&lt;class T&gt;inline void CirList&lt;T&gt;::insert(const T &amp; item, int pos)&#123; if (pos&lt;0 || pos&gt;size) &#123; cout &lt;&lt; "illegal operator" &lt;&lt; endl; exit(1); &#125; ListNode&lt;T&gt; *p = index(pos - 1); ListNode&lt;T&gt; *newnode = new ListNode&lt;T&gt;(item, p-&gt;next); p-&gt;next = newnode; size++;&#125;template&lt;class T&gt;inline T CirList&lt;T&gt;::del(int pos)&#123; if (pos&lt;0 || pos&gt;size) &#123; cout &lt;&lt; "illegal operator" &lt;&lt; endl; exit(1); &#125; ListNode&lt;T&gt; *p = index(pos-1); ListNode&lt;T&gt; *q; q = p-&gt;next; p-&gt;next = q-&gt;next; T data = q-&gt;data; delete q; size--; return data;&#125;template&lt;class T&gt;inline T CirList&lt;T&gt;::getdata(int pos) const&#123; ListNode&lt;T&gt; *p = index(pos); return p-&gt;data;&#125;template&lt;class T&gt;inline void CirList&lt;T&gt;::clearlist()&#123; ListNode&lt;T&gt; *p, *p1; p = head-&gt;next; while (p != head) &#123; p1 = p; p= p-&gt;next; delete p1; &#125; size = 0;&#125;template&lt;class T&gt;inline ListNode&lt;T&gt;* CirList&lt;T&gt;::reset()&#123; currPtr = head-&gt;next; return currPtr;&#125;template&lt;class T&gt;inline ListNode&lt;T&gt;* CirList&lt;T&gt;::next()&#123; if (currPtr != NULL) &#123; currPtr = currPtr-&gt;next; &#125; return currPtr;&#125;template&lt;class T&gt;inline bool CirList&lt;T&gt;::EndOfList() const&#123; return (currPtr == head);&#125;template&lt;class T&gt;inline bool CirList&lt;T&gt;::nextEndofList() const&#123; return (currPtr-&gt;next == head);&#125;template&lt;class T&gt;inline T CirList&lt;T&gt;::delAfter()&#123;//删除currpter-&gt;next,并返回currptr-&gt;next-&gt;data if (currPtr-&gt;next != NULL) &#123; ListNode&lt;T&gt; *p = currPtr-&gt;next; currPtr-&gt;next = p-&gt;next; T data = p-&gt;data; delete p; size--; return data; &#125;&#125; 4.测试主函数 1234567891011121314151617181920212223242526272829303132void test()&#123; CirList&lt;int&gt; list; cout &lt;&lt; "当前链表中的元素有" &lt;&lt; list.listsize() &lt;&lt; endl; for (int i = 0; i &lt; 10; i++) &#123; list.insert(10 * i, i); &#125; list.insert(100, 0); cout &lt;&lt; "当前链表中的元素有" &lt;&lt; list.listsize() &lt;&lt; endl; ListNode&lt;int&gt; *p = list.reset(); while (!list.EndOfList()) &#123; cout &lt;&lt; p-&gt;data &lt;&lt; endl; p = list.next(); &#125; cout&lt;&lt; list.del(1)&lt;&lt;"已被删除"&lt;&lt;endl; while (!list.EndOfList()) &#123; cout &lt;&lt; p-&gt;data &lt;&lt; endl; p = list.next(); &#125; cout &lt;&lt; list.index(5)-&gt;data &lt;&lt; endl;&#125;int main()&#123; test(); system("pause"); return EXIT_SUCCESS;&#125; 输出结果如下：]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>单循环链表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[顺序表的简单实现]]></title>
    <url>%2F2019%2F03%2F27%2F%E9%A1%BA%E5%BA%8F%E8%A1%A8%E7%9A%84%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[写在前面 &emsp;&emsp;数据结构是一个数据对象，同时这个对象的实例以及构成实例的元素都存在着联系，而且这些联系是由相关函数来规定的。&emsp;&emsp;研究数据结构，关心的是数据对象（实际上是实例）的描述以及相关函数的具体实现。数据对象描述得好，函数的实现就会高效。&emsp;&emsp;最常用的数据对象以及操作都已经在C++中作为基本数据类型而实现，如整数对象，布尔对象等。其他数据对象均可以用基本数据类型以及由C++的类、数组和指针所提供的组合功能来实现。 1.线性表的数据结构 &emsp;&emsp;线性表（linear list)也称有序表，它的每一个实例都是元素的一个有序集合。&emsp;&emsp;对线性表实施的操作有： 创建一个线性表 撤销一个线性表 确定线性表是否为空 确定线性表的长度 按给定的索引查找一个元素 按一个给定的元素查找其索引 按一个给定的索引删除一个元素 按一个给定的索引插入一个元素 从左至右顺序输出线性表元素 &emsp;&emsp;用顺序存储结构存储的表称为顺序表（sequent list）。顺序表中任意数据元素的存取和访问都可以通过它的位置指针来（即数组下标）进行访问。对顺序表中元素访问的效率是一个比较重要的问题。通常情况下，有序顺序表的访问效率大大高于无序顺序表的访问效率。 2.顺序表的类定义 12345678910111213141516171819typedef int Seqlist_Entry;const int maxsize = 10;class Seqlist&#123;public: Seqlist();//构造函数 ~Seqlist();//析构函数 int listsize()const;//返回元素的个数 bool listempty() const;//判断表是否为空 int find(const Seqlist_Entry &amp;item);//返回元素item在表中的位置 Seqlist_Entry getdata(int pos) const;//返回位置pos的元素 void insert(const Seqlist_Entry &amp;item, int pos);//在位置pos处插入元素item Seqlist_Entry Delete(const int pos);//删除位置pos的元素并返回 void clearlist();//清空表 void showall() const;//输出表private: Seqlist_Entry data[maxsize]; int size;//数据元素的个数&#125;; 3.顺序表的类实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104//构造函数Seqlist::Seqlist()&#123; size = 0;&#125;//析构函数Seqlist::~Seqlist() &#123;&#125;//返回顺序表元素的个数int Seqlist::listsize() const&#123; return size;&#125;//判断顺序表是否为空bool Seqlist::listempty() const&#123; return (size == 0);&#125;//查找item，并返回位置索引int Seqlist::find(const Seqlist_Entry &amp; item)&#123; if (size == 0) &#123; cout &lt;&lt; "list is empty " &lt;&lt; endl; &#125; int i = 0; while (i &lt; size&amp;&amp;item != data[i]) &#123; i++; &#125; if (i &lt; size) return i; else cout &lt;&lt; "illegal operator" &lt;&lt; endl;&#125;//取出pos位置上的元素Seqlist_Entry Seqlist::getdata(int pos) const&#123; if (pos&lt;0 || pos&gt;size - 1) &#123; cout &lt;&lt; "illegal operator" &lt;&lt; endl; exit(1); &#125; return data[pos];&#125;//在pos位置插入元素itemvoid Seqlist::insert(const Seqlist_Entry &amp; item, int pos)&#123; if (size == maxsize) &#123; cout &lt;&lt; "list is full" &lt;&lt; endl; return; &#125; if (pos&lt;0 || pos&gt;size ) &#123; cout &lt;&lt; "illegal operator" &lt;&lt; endl; return; &#125; for (int i = size; i &gt; pos; i--) &#123; data[i] = data[i - 1]; &#125; data[pos] = item; size++;&#125;//删除pos位置的元素Seqlist_Entry Seqlist::Delete(const int pos)&#123; Seqlist_Entry tmp=data[pos]; if (size == 0) &#123; cout &lt;&lt; "list is empty" &lt;&lt; endl; exit(1); &#125; if (pos&lt;0 || pos&gt;size - 1) &#123; cout &lt;&lt; "illegal operator" &lt;&lt; endl; exit(1); &#125; for (int i = pos; i &lt; size-1; i++) &#123; data[i] = data[i + 1]; &#125; size--; return tmp;&#125;//置顺序表为空void Seqlist::clearlist()&#123; size = 0; cout &lt;&lt; "已清空" &lt;&lt; endl;&#125;//输出顺序表中所有元素void Seqlist::showall() const&#123; if (size == 0) &#123; cout &lt;&lt; "list is empty" &lt;&lt; endl; &#125; for (int i = 0; i &lt; size; i++) &#123; cout &lt;&lt;i&lt;&lt;"号元素:"&lt;&lt; data[i] &lt;&lt; endl; &#125;&#125; 4.测试主函数 123456789101112131415161718192021222324void test()&#123; Seqlist list; for (int i = 0; i &lt; 10; i++) &#123; list.insert(i * 12, i); &#125; for (int i = 0; i &lt; 10; i++) &#123; cout &lt;&lt; list.getdata(i) &lt;&lt; endl; &#125; int tmp = list.Delete(2); cout &lt;&lt; "元素" &lt;&lt; tmp &lt;&lt; "已经被删除了" &lt;&lt; endl; list.showall(); cout&lt;&lt;"84在顺序表的"&lt;&lt;list.find(84)&lt;&lt;"号位置"&lt;&lt;endl; list.clearlist(); list.showall();&#125;int main()&#123; test();&#125; 输出结果如下图：]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>顺序表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[栈的实现]]></title>
    <url>%2F2019%2F03%2F27%2F%E6%A0%88%E7%9A%84%E5%AE%9E%E7%8E%B0-1%2F</url>
    <content type="text"><![CDATA[写在前面&emsp;栈（Stack)是一种特殊的线性表，是一种只允许在表的一端进行插入和删除操作的线性表。栈中允许进行插入和删除操作的一端称为栈顶，另一端为栈底。栈顶的当前位置是动态的，标识栈顶当前位置的称为栈顶指示器（或栈顶指针）。栈的插入和删除操作通常称为入栈或进栈，栈的删除操作称为出栈或退栈。当栈中没有数据元素时称为空栈。&emsp;&emsp;根据栈的定义，每次进栈的数据元素都放在原当前栈顶元素之前而成为新的栈顶元素，每次退栈的数据元素都是当前栈顶元素，这样，最后进入堆栈的数据元素总是最先出栈，因此栈也被成为后进先出表。 1.栈的基本运算 初始化栈 销毁栈 判断栈是否为空 进栈 出栈 取栈顶元素 2.顺序栈四要素 栈空条件： top==-1 栈满条件： top==max_stack - 1 item进栈操作：top++,将item放在top处 退栈操作：从top处取出元素item，top— 3.类说明 &emsp;对于顺序栈Stack的实现，应创建一个数组来存放栈中的元素，并用一个始终指向栈顶的变量top来表示栈顶的位置。类定义如下： 12345678910111213141516171819202122232425typedef int Stack_Entry;const int max_stack = 10;class Stack&#123;public: Stack(); //构造函数 ~Stack() &#123;&#125;; //析构函数 bool empty() const; //判断栈是否为空 Stack_Entry pop(); //出栈数据元素 Stack_Entry Top(Stack_Entry &amp;item) const; //返回栈顶元素 void push(const Stack_Entry &amp;item); //数据元素item进栈 int getsize() const; //获取栈中元素的个数 void clearstack(); //清空栈private: int top;//栈顶位置指示器 Stack_Entry entry[max_stack];//Stack_Entry类型的数组&#125;; 4.具体实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748Stack::Stack()&#123; top=-1;&#125;bool Stack::empty() const&#123; return (top==-1);&#125;Stack_Entry Stack::pop()&#123; if (top==-1) &#123; cout &lt;&lt; "Stack is empty" &lt;&lt; endl; &#125; return entry[top--]; &#125;Stack_Entry Stack::Top(Stack_Entry &amp; item) const&#123; if (top == -1) &#123; cout &lt;&lt; "Stack is empty" &lt;&lt; endl; &#125; return entry[top];&#125;void Stack::push(const Stack_Entry &amp; item)&#123; if (top == max_stack - 1) &#123; cout &lt;&lt; "Stack is full" &lt;&lt; endl; &#125; top++; entry[top] = item;&#125;int Stack::getsize() const&#123; return top+1;&#125;void Stack::clearstack()&#123; top = -1;&#125; 5.主函数 12345678910111213141516171819202122232425262728293031void test()&#123; Stack stack; for (int i = 0; i &lt; 10; i++) &#123; stack.push(i+10*i); &#125; cout &lt;&lt; "当前栈中元素数为：" &lt;&lt; stack.getsize() &lt;&lt; endl; for (int i = 0; i &lt; 10; i++) &#123; Stack_Entry tmp; tmp = stack.pop(); cout &lt;&lt; "我是" &lt;&lt; i &lt;&lt; "号元素:"&lt;&lt;tmp &lt;&lt; endl; &#125; cout &lt;&lt; "当前栈中元素数为：" &lt;&lt; stack.getsize() &lt;&lt; endl; if (stack.empty()) &#123; cout &lt;&lt; "Stack is empty" &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; "Stack is not empty" &lt;&lt; endl; &#125;&#125;int main()&#123; test(); system("pause"); return EXIT_SUCCESS;&#125; 输出结果如下图：]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>数据结构</tag>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[单链表的实现]]></title>
    <url>%2F2019%2F03%2F27%2F%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[写在前面&emsp;链式存储结构是计算机中另一种最基本和最主要的数据存储结构。和顺序存储结构不同，初始化时链式存储结构为空链，每当有新的元素需要存储时用户向系统动态申请所需的存储空间插入链中。所有高级程序设计语言都为用户提供了向系统动态申请和动态释放存储空间的办法。C++提供了new和delete运算符，分别用于向系统动态申请所需存储空间和动态释放用new申请的存储空间。new能自动计算要分配的类型大小并自动返回正确的指针类型。delete能自动释放由new分配的存储空间。&emsp;&emsp;在顺序存储结构中，用户向系统申请一块地址连续的有限空间用于存储数据元素，这样任意两个在逻辑上相邻的数据元素在物理上也必然相邻。但在链式存储结构中，由于它在初始化时为空链，每当有新的数据元素需要存储时用户才向系统动态申请所需的存储空间插入链中，而这些在不同时刻向系统动态申请的存储空间在内存上很可能是不连续的。因此，在链式存储结构中，任意两个在逻辑上相邻的数据元素在物理上不一定相邻，数据元素的逻辑次序是通过链中的指针连接实现的。 &emsp;&emsp;链式存储结构存储线性结构数据元素集合的方法是用节点（Node)构造链。线性结构数据元素的特点是：除第一个和最后一个元素外，每个元素只有一个唯一的前驱和一个唯一的后继。链式结构中每个节点除数据域外，还有一个或两个以上的指针域，数据域用来存放数据元素，指针域用来构造数据元素之间的关系。 1.单链表 &emsp;单链表简称链表（linked list)，是表数据元素的单链结构存储。链表使用一个一个的节点链接构成的。&emsp;&emsp;表要求允许在任意位置进行插入和删除。当选用带头节点的单链表时，在第一个位置插入节点和在其他位置插入节点一样不会改变头指针head的值，此时改变的是head-&gt;next的值。&emsp;在第一个位置删除节点和在其他位置删除节点一样也不会改变头指针head的值，此时改变的也是head-&gt;next的值。 2.节点类的定义和实现 &emsp;在单链表中，每个节点构成包括数据域和指针域两部分。每个节点的基本操作包括构造一个节点对象、建立一个新节点、给出当前节点的下一个节点指针等。 1234567891011121314151617181920212223template&lt;class T&gt;class ListNode&#123; friend class LinList&lt;T&gt;;//声明友元类public: T data;//数据域 ListNode(ListNode&lt;T&gt; *ptrNext = NULL);//构造函数，用于构造头节点，头节点没有data参数 ListNode(const T &amp;item, ListNode&lt;T&gt; *ptrNext = NULL);//构造函数，主要用于构造非头节点的节点 ~ListNode() &#123;&#125;;//析构函数private: ListNode&lt;T&gt; *next;//指向下一节点的指针&#125;;template&lt;class T&gt;inline ListNode&lt;T&gt;::ListNode(ListNode&lt;T&gt;* ptrNext):next(ptrNext)&#123;&#125;//构造函数，用于构造头节点，头节点没有值template&lt;class T&gt;inline ListNode&lt;T&gt;::ListNode(const T &amp; item, ListNode&lt;T&gt;* ptrNext)&#123;//构造函数，用于构造非头节点的节点 data = item; next = ptrNext;&#125; &emsp;节点类的成员有data域和next域。data域中存放了该节点的数据值，由于应用问题中需要使用链表中的data值，所以定义为公有数据成员方便使用；next域定义为私有数据成员。节点类的成员函数由两个不同参数的构造函数和空的析构函数。析构函数为空是因为节点类中没有用new函数向系统申请空间，而节点对象本身分配的空间，系统可自动识别释放。 3.单链表类的定义 12345678910111213141516171819202122232425template&lt;class T&gt;class LinList&#123;public: LinList();//构造函数 ~LinList();//析构函数 //表操作成员函数 int listsize() const;//返回链表中元素的个数 bool listempty() const;//链表是否为空 ListNode&lt;T&gt; *index(int pos);//返回指向第pos个节点的指针 void insert(const T&amp; item, int pos);//在pos节点前插入一个data域为item的元素 T Delete(int pos);//删除第pos个节点并返回被删除节点的data域 T getdata(int pos);//返回第pos个节点的data值 void clearlist();//清空表为初始化状态 //遍历链表的成员函数 ListNode&lt;T&gt; *Reset(int pos = 0);//currPtr指向节点pos并返回currPtr ListNode&lt;T&gt; *Next();//currPtr指向下一个节点并返回currPtr bool endOfList() const;//currPtr==head？private: ListNode&lt;T&gt; *head;//指向头节点的指针 ListNode&lt;T&gt; *currPtr;//当前指针 int size;//单链表中元素的个数&#125;; &emsp;单链表类的数据成员有头指针、元素个数和当前节点指针。头指针指向头结点，任何对单链表中节点的操作都要从头指针进入。初始化状态下，节点个数为0.当前节点指针是遍历链表成员函数使用的数据成员，遍历链表成员函数通过控制当前节点指针来遍历链表。&emsp;&emsp;单链表类的成员函数由三组：构造函数和析构函数、表操作的成员函数和遍历链表的成员函数。由于单链表类中的节点是通过new函数向系统申请的，在释放单链表类对象的时候，系统无法自行释放这些空间，所以析构函数不能为空，析构函数必须用delete函数逐个释放这些空间。表操作成员函数时对表操作的基本成员函数，这与顺序表类中对表进行操作的成员函数意义相同，但是实现方法不同。链表的遍历操作是每次寻找当前节点的下一个节点，由于每次对链表类中节点的操作都要从头指针进入后寻找到相应的节点后才可完成，这样的单链表类遍历操作的时间复杂度返回大大增加，在单链表中增加一组遍历链表的成员函数可使单链表遍历操作的时间复杂度不增加。 4.单链表类的实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141template&lt;class T&gt;inline LinList&lt;T&gt;::LinList()&#123; head = new ListNode&lt;T&gt;();//头指针指向头结点 size = 0;&#125;template&lt;class T&gt;inline LinList&lt;T&gt;::~LinList()&#123; clearlist(); delete head; head = NULL;&#125;template&lt;class T&gt;inline int LinList&lt;T&gt;::listsize() const//返回单链表中元素的个数&#123; return size;&#125;template&lt;class T&gt;inline bool LinList&lt;T&gt;::listempty() const&#123; return size == 0;&#125;template&lt;class T&gt;inline ListNode&lt;T&gt;* LinList&lt;T&gt;::index(int pos)&#123; if (pos == -1) return head; if (pos&lt;0 || pos&gt;size) &#123; cout &lt;&lt; "illegal operator" &lt;&lt; endl; exit(1); &#125; ListNode&lt;T&gt; *p = head-&gt;next;//p指向第一个节点 int i = 0; while (p != NULL &amp;&amp; i &lt; pos) &#123; p = p-&gt;next; i++; &#125; return p;&#125;template&lt;class T&gt;inline void LinList&lt;T&gt;::insert(const T &amp; item, int pos)&#123; ListNode&lt;T&gt; *p = index(pos - 1); ListNode&lt;T&gt; *newnode = new ListNode&lt;T&gt;(item, p-&gt;next); p-&gt;next = newnode; size++;&#125;template&lt;class T&gt;inline T LinList&lt;T&gt;::Delete(int pos)&#123; if (size == 0) &#123; cout &lt;&lt; "list is empty" &lt;&lt; endl; exit(1); &#125; ListNode&lt;T&gt;*q, *p = index(pos - 1);//p为指向第pos-1个节点的指针 q = p-&gt;next;//q指向要删除节点 p-&gt;next = p-&gt;next-&gt;next;//p指向要删除节点的后一节点 T data = q-&gt;data; //data保存要删除节点值 delete q; size--; return data;&#125;template&lt;class T&gt;inline T LinList&lt;T&gt;::getdata(int pos)&#123; ListNode&lt;T&gt; *p = index(pos);//指针p指向第pos个节点 return p-&gt;data;&#125;template&lt;class T&gt;inline void LinList&lt;T&gt;::clearlist()&#123; ListNode&lt;T&gt; *p, *p1; p = head-&gt;next; while (p != NULL) &#123;//delete所有new出来的空间 p1 = p; p = p-&gt;next; delete p1; &#125; size = 0;&#125;template&lt;class T&gt;inline ListNode&lt;T&gt;* LinList&lt;T&gt;::Reset(int pos)&#123; if (head == NULL) return NULL; if (pos &lt; -1 || pos&gt;size) &#123; cout &lt;&lt; "mistake" &lt;&lt; endl; exit(1); &#125; if (pos == -1) return head; if (pos == 0) &#123; currPtr = head-&gt;next; &#125; else &#123; currPtr = head-&gt;next; ListNode&lt;T&gt; prevPtr = head; for (int i = 0; i &lt; pos; i++) &#123; prevPtr = currPtr; currPtr = currPtr-&gt;next; &#125; &#125; return currPtr;&#125;template&lt;class T&gt;inline ListNode&lt;T&gt;* LinList&lt;T&gt;::Next()&#123; if (currPtr != NULL) &#123; currPtr = currPtr-&gt;next; &#125; return currPtr;&#125;template&lt;class T&gt;inline bool LinList&lt;T&gt;::endOfList() const&#123; return currPtr == NULL;&#125; &emsp;&emsp;这些成员函数基本上实现了单链表所需的基本操作。 5.主函数测试 测试主函数如下： 123456789101112131415161718192021222324252627void test()&#123; LinList&lt;int&gt; list; cout &lt;&lt; "单链表中的元素个数为："&lt;&lt;list.listsize() &lt;&lt; endl; for (int i = 0; i &lt; 10; i++) &#123; list.insert(15 * i, i); &#125; cout &lt;&lt; "单链表中的元素个数为：" &lt;&lt; list.listsize() &lt;&lt; endl; cout &lt;&lt; "5号为：" &lt;&lt; list.getdata(5) &lt;&lt; endl; cout&lt;&lt;list.Delete(5)&lt;&lt;"已被删除"&lt;&lt;endl; cout &lt;&lt; "5号为：" &lt;&lt; list.getdata(5) &lt;&lt; endl; ListNode&lt;int&gt; *p = list.Reset(); while (!list.endOfList()) &#123; cout &lt;&lt; p-&gt;data &lt;&lt; endl; p = list.Next(); &#125;&#125;int main()&#123; test(); system("pause"); return EXIT_SUCCESS;&#125; 输出结果如下：]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>数据结构</tag>
        <tag>单链表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[运算符重载（2）]]></title>
    <url>%2F2019%2F03%2F24%2F%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD%EF%BC%882%EF%BC%89%2F</url>
    <content type="text"><![CDATA[5.左移(输出）运算符重载 &emsp;&emsp;如我们所知，IO标准库分别使用&gt;&gt;和&lt;&lt;执行输入输出操作。对于这两个运算符来说，IO库定义了其用读写内置类型的版本，但是类则需自定义适合其对象的新版本支持IO操作。&emsp;&emsp;通过情况下左移运算符的第一形参是一个非常量ostream的引用。而ostream是非常量的原因是向流写入内容会改变其状态。而该形参是引用，是因为我们无法直接复制一个ostream对象。&emsp;&emsp;第二个形参一般来说是一个常量的引用，该常量是我们想要打印的类类型。第二个形参是引用的原因是我们希望避免复制实参，而形参为常量是因为打印对象不会改变对象的内容。举例如下： 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;iostream&gt;#include&lt;string&gt;using namespace std;class Person&#123; friend ostream &amp;operator&lt;&lt;(ostream &amp;cout, const Person &amp;p);public: Person(string name, int age);private: string m_name; int m_age;&#125;;Person::Person(string name, int age)&#123; this-&gt;m_name = name; this-&gt;m_age = age;&#125;ostream &amp;operator&lt;&lt;(ostream &amp;cout, const Person &amp;p)&#123; cout &lt;&lt; p.m_name &lt;&lt; "的年龄为：" &lt;&lt; p.m_age &lt;&lt; endl; return cout;&#125;void test()&#123; Person p("Aoki", 20); cout &lt;&lt; p; cout &lt;&lt; "Hello world" &lt;&lt; endl;&#125;int main()&#123; test(); system("pause"); return EXIT_SUCCESS;&#125; 输出结果如下： 6.右移（输入）运算符重载 &emsp;&emsp;通常情况下，输入运算符的第一个形参是运算符简要读取的流的引用，第二个形参是将要读入的非常量对象的引用。该运算符通常会返回某个给定流的引用。第二个形参之所以必须是个非常量是因为输入运算符本身的目的就是将数据读入到这个对象中。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include &lt;iostream&gt;#include&lt;string&gt;using namespace std;class Person&#123; friend istream &amp;operator&gt;&gt;(istream &amp;cin, Person &amp;p);public: Person ()&#123;&#125; Person(string name, int age); void Show();private: string m_name; int m_age;&#125;;Person::Person(string name, int age)&#123; this-&gt;m_name = name; this-&gt;m_age = age;&#125;istream &amp; operator&gt;&gt;(istream &amp; cin, Person &amp; p)&#123; string name; int age; cin &gt;&gt; name &gt;&gt; age; if (cin) &#123; p.m_name = name; p.m_age = age; &#125; else &#123; p = Person();//如果输入失败，对象被赋予默认状态 &#125; return cin;&#125;void Person::Show()&#123; cout &lt;&lt; this-&gt;m_name &lt;&lt; "的年龄是：" &lt;&lt; this-&gt;m_age &lt;&lt; endl;&#125;void test()&#123; Person p1; cin &gt;&gt; p1; p1.Show();&#125;int main()&#123; test(); system("pause"); return EXIT_SUCCESS;&#125; 输出结果如下：&emsp;&emsp;可以注意到，在输入运算符重载中，有输入失败的处理。那么输入时可能会发生什么错误呢？ 当流含有错误类型的数据时读取操作可能失败 当读取操作到达文件末尾或遇到输入流的其他错误时也会失败 &emsp;&emsp;在程序中我们没有逐个检查每个读取操作，而是等读取了所有数据之后赶在使用这些数据前面进行了一次性的检查。&emsp;&emsp;如果在发生错误之前对象已经有一部分改变，则适时地将对象置为合法状态显得异常重要。&emsp;&emsp;通过将对象置为合法状态，我们能保护使用者免受到输入错误的影响。此时的对象处于可用状态，即它的成员都是被正确定义的。而且该对象也不会产生误导性结果，因为它的数据本质上是一致的。 7.指针运算符重载 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879#include &lt;iostream&gt;#include&lt;string&gt;using namespace std;class Person&#123;public: Person(string name, int age); void Display();private: string m_name; int m_age;&#125;;class SmartPointer&#123;public: SmartPointer(Person *person); Person* operator-&gt;(); Person&amp; operator*(); ~SmartPointer();public: Person *pPerson;&#125;;Person::Person(string name, int age)&#123; this-&gt;m_name = name; this-&gt;m_age = age;&#125;void Person::Display()&#123; cout &lt;&lt; this-&gt;m_name &lt;&lt; "的年龄是：" &lt;&lt; this-&gt;m_age &lt;&lt; endl;&#125;SmartPointer::SmartPointer(Person * person)&#123; this-&gt;pPerson = person;&#125;Person * SmartPointer::operator-&gt;()&#123; //重载指针的-&gt;运算符 return pPerson;&#125;Person &amp; SmartPointer::operator*()&#123; //重载指针的*运算符 return *pPerson;&#125;SmartPointer::~SmartPointer()&#123; if (pPerson != NULL) &#123; delete pPerson; &#125;&#125;void test()&#123; Person *person = new Person("Aoki", 20); //如果忘记释放，那么就会造成内存泄漏 SmartPointer poiner(new Person("Aoki", 20)); poiner-&gt;Display();&#125;int main()&#123; test(); system("pause"); return EXIT_SUCCESS;&#125; 输出结果如下： 8.赋值运算符重载 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#define _CRT_SECURE_NO_WARNINGS#include &lt;iostream&gt;#include&lt;string&gt;using namespace std;class Person&#123;public: Person(const char *name); Person&amp; operator=(const Person &amp;p); ~Person();public: char *name;&#125;;Person::Person(const char * name)&#123; this-&gt;name = new char[strlen(name) + 1]; strcpy(this-&gt;name, name);&#125;Person &amp; Person::operator=(const Person &amp; p)&#123; if (this-&gt;name != NULL) &#123;//判断原来堆区中是否有内容，如果有，先释放 delete[] this-&gt;name; this-&gt;name = NULL; &#125; this-&gt;name = new char[strlen(p.name) + 1]; strcpy(this-&gt;name, p.name); return *this;&#125;Person::~Person()&#123; if (this-&gt;name != NULL) &#123; delete[] this-&gt;name; this-&gt;name = NULL; &#125;&#125;void test()&#123; Person p1("Aoki"); Person p2("青木"); p1 = p2; cout &lt;&lt; p1.name &lt;&lt; endl; cout &lt;&lt; p2.name &lt;&lt; endl;&#125;int main()&#123; test(); system("pause"); return EXIT_SUCCESS;&#125; 输出结果如下：]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>运算符重载</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[运算符的重载（1）]]></title>
    <url>%2F2019%2F03%2F24%2F%E8%BF%90%E7%AE%97%E7%AC%A6%E7%9A%84%E9%87%8D%E8%BD%BD%EF%BC%881%EF%BC%89%2F</url>
    <content type="text"><![CDATA[写在前面 &emsp;&emsp;运算符重载，就是对已有的运算符重新进行定义，赋予其另一种功能，以适应不同的数据类型。&emsp;&emsp;运算符重载（operator overloading)只是一种“语法上的方便”,也就它只是另一种函数调用的方式。&emsp;&emsp;在C++中，可以定义一个处理类的新运算符。这种定义很像一个普通的函数定义，只是函数的名字由关键字operator及其紧跟的运算符组成。差别仅此而已。它像任何其他函数一样也是一个函数，当编译器遇到适当的模式时，就会调用这个函数。&emsp;&emsp;重载运算符的参数数量与该运算符作用的对象数量一样多。一元运算符有一个参数，二元运算符有两个参数。对于二元运算符来说，左侧运算符对象传递给第一个参数，而右侧运算符对象传递给第二个参数。除了重载的函数调用运算符operator()之外，其他重载运算符不能含有默认实参。&emsp;&emsp;如果一个重载运算符函数时成员函数，则它的第一个（左侧）运算符对象绑定到隐式地this指针上，因此，成员运算符函数的（显式）参数数量比运算符的运算对象总数少一个。 1.关系运算符重载 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include &lt;iostream&gt;#include&lt;string&gt;using namespace std;class Person&#123;public: Person(string name, int age); bool operator==(Person &amp;p);//==运算符重载 bool operator!=(Person &amp;p);//！=运算符重载 private: string m_Name; int m_Age;&#125;;Person::Person(string name, int age)&#123; this-&gt;m_Name = name; this-&gt;m_Age = age;&#125;bool Person::operator==(Person &amp; p)&#123; if (this-&gt;m_Name == p.m_Name&amp;&amp;this-&gt;m_Age == p.m_Age) &#123; return true; &#125; return false;&#125;bool Person::operator!=(Person &amp; p)&#123; if (this-&gt;m_Name == p.m_Name&amp;&amp;this-&gt;m_Age == p.m_Age) &#123; return false; &#125; return true;&#125;void test()&#123; Person p1("Aoki", 22); Person p2("Aoki", 22); Person p3("Aoki", 20); if (p1 == p2) &#123; cout &lt;&lt; "p1和p2相等" &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; "p1和p2不相等" &lt;&lt; endl; &#125; if (p1 != p3) &#123; cout &lt;&lt; "p1和p3不相等" &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; "p1和p3相等" &lt;&lt; endl; &#125;&#125;int main()&#123; test();&#125; 输出结果如下： 2.自增自减运算符重载 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#include &lt;iostream&gt;#include&lt;string&gt;using namespace std;class Person&#123;public: Person()&#123;&#125; Person(string name, int age); Person operator++();//前置++运算符 Person operator--();//前置--运算符重载 Person operator++(int);//后置++运算符重载 Person operator--(int);//后置--运算符重载 void show();private: string m_Name; int m_Age;&#125;;Person::Person(string name, int age)&#123; this-&gt;m_Name = name; this-&gt;m_Age = age;&#125;Person Person::operator++()&#123; m_Age++; return *this;&#125;Person Person::operator--()&#123; m_Age--; return *this;&#125;Person Person::operator++(int)&#123; Person tmp; tmp.m_Age = this-&gt;m_Age; m_Age++; return tmp;&#125;Person Person::operator--(int)&#123; Person tmp; tmp.m_Age = this-&gt;m_Age; m_Age--; return tmp;&#125;void Person::show()&#123; cout &lt;&lt; this-&gt;m_Name &lt;&lt; "的年龄为" &lt;&lt; this-&gt;m_Age &lt;&lt; endl;&#125;void test()&#123; Person p1("Aoki",22); p1++; p1.show(); p1--; p1.show(); --p1; p1.show(); ++p1; p1.show();&#125;int main()&#123; test(); return 0;&#125; 输出结果如下：优先使用++和—的标准形式，优先调用前置++&emsp;&emsp;如果定义了++c，也要定义c++，递增操作符比较麻烦，因为他们都有前缀和后缀形式，而两种语义略有不同。重载123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&amp;emsp;&amp;emsp;对于++和--而言，后置形式是先返回，然后对象++或--，返回的是对象的原值。前置形式，对象先++或--，然后返回当前对象，返回的是新对象。 &amp;emsp;&amp;emsp;调用代码的时候，要优先使用前缀形式，除非确实需要后缀形式返回的原值，，前缀和后缀形式语义上是等价的，输入工作量也相当，只是效率经常会略高一些，由于前缀形式少创建了一个临时对象。 &lt;br /&gt;&lt;br /&gt;&gt; # 3.加号运算符重载 &lt;br /&gt;```c++#include &lt;iostream&gt;#include&lt;string&gt;using namespace std;class Person&#123;public: Person() &#123;&#125;; Person(string a, int b) :m_name(a), m_age(b) &#123;&#125; Person operator+(Person &amp;p);public: string m_name; int m_age;&#125;;Person Person::operator+(Person &amp; p)&#123; Person tmp; tmp.m_age = this-&gt;m_age + p.m_age; tmp.m_name = this-&gt;m_name + p.m_name; return tmp;&#125;void test()&#123; Person p1(&quot;Ao&quot;, 20); Person p2(&quot;ki&quot;,10); Person p3 = p1 + p2; cout &lt;&lt; &quot;p3的名字为：&quot; &lt;&lt; p3.m_name &lt;&lt; &quot;,p3的年龄为&quot; &lt;&lt; p3.m_age &lt;&lt; endl;&#125;int main()&#123; test(); return 0;&#125; 输出结果如下： 下面也是加号运算符重载的一些方法： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include &lt;iostream&gt;#include&lt;string&gt;using namespace std;class Person&#123;public: Person() &#123;&#125;; Person(string a, int b) :m_name(a), m_age(b) &#123;&#125; //Person operator+(Person &amp;p);public: string m_name; int m_age;&#125;;////Person Person::operator+(Person &amp; p)//&#123;// Person tmp;// tmp.m_age = this-&gt;m_age + p.m_age;// tmp.m_name = this-&gt;m_name + p.m_name;// return tmp;//&#125;Person operator+(Person &amp;p1, Person &amp;p2)&#123; Person tmp; tmp.m_age = p1.m_age + p2.m_age; tmp.m_name = p1.m_name + p2.m_name; return tmp;&#125;Person operator+(Person &amp;p1, int a)&#123; Person tmp; tmp.m_age = p1.m_age + a; tmp.m_name = p1.m_name; return tmp;&#125;void test()&#123; Person p1("Ao", 20); Person p2("ki",10); Person p3 = p1 + p2; Person p4 = p2 + 10; cout &lt;&lt; "p3的名字为：" &lt;&lt; p3.m_name &lt;&lt; ",p3的年龄为" &lt;&lt; p3.m_age &lt;&lt; endl; cout &lt;&lt; "p4的名字为：" &lt;&lt; p4.m_name &lt;&lt; ",p4的年龄为" &lt;&lt; p4.m_age &lt;&lt; endl;&#125;int main()&#123; test(); return 0;&#125; 输出结果如下： 4.减号运算符重载 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include &lt;iostream&gt;#include&lt;string&gt;using namespace std;class Person&#123;public: Person() &#123;&#125;; Person(string a, int b) :m_name(a), m_age(b) &#123;&#125; //Person operator+(Person &amp;p);public: string m_name; int m_age;&#125;;//Person Person::operator+(Person &amp; p)//&#123;// Person tmp;// tmp.m_age = this-&gt;m_age + p.m_age;// tmp.m_name = this-&gt;m_name + p.m_name;// return tmp;//&#125;Person operator-(Person &amp;p1, Person &amp;p2)&#123; Person tmp; tmp.m_age = p1.m_age - p2.m_age; tmp.m_name = p1.m_name + p2.m_name; return tmp;&#125;Person operator-(Person &amp;p1, int a)&#123; Person tmp; tmp.m_age = p1.m_age - a; tmp.m_name = p1.m_name; return tmp;&#125;void test()&#123; Person p1("Ao", 20); Person p2("ki",10); Person p3 = p1 - p2; Person p4 = p2 -1; cout &lt;&lt; "p3的名字为：" &lt;&lt; p3.m_name &lt;&lt; ",p3的年龄为" &lt;&lt; p3.m_age &lt;&lt; endl; cout &lt;&lt; "p4的名字为：" &lt;&lt; p4.m_name &lt;&lt; ",p4的年龄为" &lt;&lt; p4.m_age &lt;&lt; endl;&#125;int main()&#123; test(); return 0;&#125; 输出结果如下:]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>运算符重载</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[友元]]></title>
    <url>%2F2019%2F03%2F23%2F%E5%8F%8B%E5%85%83%2F</url>
    <content type="text"><![CDATA[写在前面 &emsp;&emsp;类的主要特点之一就是数据隐藏，即类的私有成员无法在类的外部（作用域之外）访问。但是，有时候需要在类的外部访问类的私有数据成员，怎么办呢？&emsp;&emsp;解决办法是使用友元函数，友元函数时一种特权函数c，C++允许这个特权函数访问私有成员。这一点我们可以用生活中的例子来看：&emsp;&emsp;比如你的家有客厅，有卧室，客厅是public的，所有来的客人都可以进去，但是你的卧室是私有的，也就是说只有你能进去，但是，你可以允许你的好朋友进去。&emsp;&emsp;程序员可以把一个全局函数、某个类中的成员函数、甚至整个类声明为友元。 1.全局函数做友元函数 友元语法 friend关键字只出现在声明处 其他类、类成员函数、全局函数都可以声明为友元 友元函数不是类的成员，不带this指针 1234567891011121314151617181920212223242526272829303132#include &lt;iostream&gt;#include&lt;string&gt;using namespace std;class Home&#123;public: friend void test(Home *home); Home() &#123; this-&gt;bedroom = "卧室"; this-&gt;sittingroom = "客厅"; &#125; string sittingroom;//客厅private: string bedroom;//卧室 &#125;;void test(Home *home)&#123; cout &lt;&lt; "你的好友正在访问" &lt;&lt; home-&gt;sittingroom &lt;&lt; endl; cout &lt;&lt; "你的好友正在访问" &lt;&lt; home-&gt;bedroom &lt;&lt; endl;&#125;int main()&#123; Home *home=new Home; test(home);&#125; 输出结果如下： 从输出结果可以看出，当全局函数作为声明为友元函数之后，全局函数也可以访问类的私有成员。 2.整个类做友元类 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;iostream&gt;#include&lt;string&gt;using namespace std;class Home&#123;public: friend class Good_Friend; Home() &#123; this-&gt;bedroom = "卧室"; this-&gt;sittingroom = "客厅"; &#125; string sittingroom;//客厅private: string bedroom;//卧室 &#125;;class Good_Friend&#123;public: Good_Friend(string name) &#123; this-&gt;name = name; &#125; void visit() &#123; cout &lt;&lt; "好友"&lt;&lt;this-&gt;name&lt;&lt;"正在拜访" &lt;&lt; this-&gt;home.sittingroom &lt;&lt; endl; cout &lt;&lt; "好友"&lt;&lt;this-&gt;name&lt;&lt;"正在拜访" &lt;&lt; this-&gt;home.bedroom &lt;&lt; endl; &#125;private: Home home; string name;&#125;;void test()&#123; Good_Friend frend("Aoki"); frend.visit();&#125;int main()&#123; test();&#125; &emsp;&emsp;输出结果如下：&emsp;&emsp;将好友类声明为友元类之后，好友类的对象可以访问Home类的私有成员。&emsp;&emsp;在友元类中我们应当注意： 友元关系不能被继承 友元关系是单向的 友元关系不具有传递性 C++是纯面向对象的吗？&emsp;&emsp;如果一个类被声明为friend，意味着它不是这个类的成员函数，却可以是修改这个类的私有成员，而且必须列在类的定义中，因此它是一个特权函数。C++不是完全的面向对象语言，而是一个混合产品。增加friend关键字只是用来解决一些实际问题，这也说明这种语言是不纯的。毕竟C++设计的目的是为了实用性，而不是追求理想的抽象。 -———《Think in C++》 &lt;/br&gt; 3.成员函数做友元函数 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include &lt;iostream&gt;#include&lt;string&gt;using namespace std;class Home;class Good_Friend&#123;public: Good_Friend(string name); void visit(); void visit2();private: Home *home; string name;&#125;;class Home&#123; friend void Good_Friend::visit();public: Home();public: string sittingroom;private: string bedroom;&#125;;Good_Friend::Good_Friend(string name)&#123; home = new Home; this-&gt;name = name;&#125;void Good_Friend::visit()&#123; cout &lt;&lt; "你的好友" &lt;&lt; this-&gt;name &lt;&lt; "正在访问" &lt;&lt; this-&gt;home-&gt;sittingroom &lt;&lt; endl; cout &lt;&lt; "你的好友" &lt;&lt; this-&gt;name &lt;&lt; "正在访问" &lt;&lt; this-&gt;home-&gt;bedroom &lt;&lt; endl;&#125;void Good_Friend::visit2()&#123; cout &lt;&lt; "你的好友"&lt;&lt;this-&gt;name&lt;&lt;"正在访问" &lt;&lt; this-&gt;home-&gt;sittingroom &lt;&lt; endl; //cout &lt;&lt; "你的好友" &lt;&lt; this-&gt;name &lt;&lt; "正在访问" &lt;&lt; this-&gt;home-&gt;bedroom &lt;&lt; endl;&#125;Home::Home()&#123; this-&gt;sittingroom = "客厅"; this-&gt;bedroom = "卧室";&#125;void test()&#123; Good_Friend frien("Aoki"); frien.visit(); frien.visit2();&#125;int main()&#123; test(); return 0;&#125; &emsp;&emsp;当我们试图使用一个没有声明为Home类友元的成员函数去访问Home的私有成员时，编译器报错如下：正确是输出结果如下：&emsp;&emsp;虽然我现在将visit()函数定义为Home类的友元，但是事情并没有这么简单地结束，因为当我第一次定义友元函数时，编译器莫名其妙地报错。那么，编译器报错的原因是什么呢？&emsp;&emsp;当我尝试着把成员函数的声明与定义分开的时候，编译器显示没有错误。这也就告诉我们，在声明成员函数的时候，将声明与定义分开放，编译器会更好地处理。]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>友元函数</tag>
        <tag>友元类</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++对象模型初探]]></title>
    <url>%2F2019%2F03%2F23%2FC-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B%E5%88%9D%E6%8E%A2%2F</url>
    <content type="text"><![CDATA[1.成员变量和函数的存储 在C语言中，分开来声明，也就说，语言本身并没有支持“数据”和“函数”之间的关联性，我们把这种程序方法称为“程序性的”，由一组“分布在各个以功能为导向的函数中的算法驱动，它们处理的是共同的外部数据。C++实现了“封装”，那么数据（成员属性）和操作（成员函数）是什么样的呢？“数据”和“处理数据的操作（函数）”是分开存储的。 C++中的非静态数据成员直接内含在类对象中，就像C struct一样 成员函数（member function）虽然内含正在class声明之内，却不出现在对象中 每一个非内联成员函数只会的诞生一份函数实例 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include &lt;iostream&gt;using namespace std;class Myclass&#123;public: int m_A;&#125;;class Myclass1&#123;public: int m_A; static int m_B;&#125;;class Myclass2&#123;public: void test01() &#123; cout &lt;&lt; "001" &lt;&lt; endl; &#125;public: static int m_A;&#125;;class Myclass3&#123;public: static void test02() &#123; cout &lt;&lt; "002" &lt;&lt; endl; &#125;public: int m_A; static int m_B;&#125;;class Myclass4&#123;public: void test03() &#123; cout &lt;&lt; "003" &lt;&lt; endl; &#125; static void test04() &#123; cout &lt;&lt; "004" &lt;&lt; endl; &#125;public: int m_A; static int m_B;&#125;;int main()&#123; Myclass myclass; Myclass1 myclass1; Myclass2 myclass2; Myclass3 myclass3; Myclass4 myclass4; cout &lt;&lt; "size of myclass:" &lt;&lt; sizeof(myclass) &lt;&lt; endl; cout &lt;&lt; "size of myclass1:" &lt;&lt; sizeof(myclass1) &lt;&lt; endl; cout &lt;&lt; "size of myclass2:" &lt;&lt; sizeof(myclass2) &lt;&lt; endl; cout &lt;&lt; "size of myclass3:" &lt;&lt; sizeof(myclass3) &lt;&lt; endl; cout &lt;&lt; "size of myclass4:" &lt;&lt; sizeof(myclass4) &lt;&lt; endl; return 0;&#125; 输出结果如下：从输出结果我们可以看出，C++中成员变量和成员属性是分开存储的。 而且，只有非静态成员才属于对象身上。 2.this指针 通过上面的例子我们知道，C++的数据和操作时分开存储的，并且每个非内联成员函数只会诞生一份函数实例，也就是说多个同类型的对象会共用一块代码。那么问题是，这块代码是如何区分是哪个对象调用自己的呢？C++通过提供特殊的对象指针，this指针，来解决上述问题。this指针指向被调用的成员函数所属的对象。C++规定，this指针是隐含在对象成员函数内的一种指针。当一个对象被创建后，它的每一个成员函数都含有一个系统自动生成的隐含指针this，用以保存这个对象的地址。也就是说，虽然我们没有写上this指针，编译器在编译的时候也会加上的。因此，this指针也被称为“指向本对象的指针”，this指针不并不是对象的一部分，并不会影响sizeof（对象）对的结果。this指针是C++实现封装的一种机制，它将对象和该对象调用的非成员函数连接在一起，在外部看来，每个对象都拥有自己的成员函数。一般情况下，并不写this，而是让系统进行默认设置。this指针永远指向当前对象。 成员函数通过this指针即可知道操作的是哪个对象的数据。this指针是一种隐含指针，它隐含于每个类的非静态成员函数中，this指针无须定义，直接使用即可。静态成员函数内部没有this指针，静态成员函数不能操作非静态成员变量。 3.this指针的使用 当形参和成员变量同名时，可用this指针区分 在类的非静态成员函数中返回对象本身，可用return *this 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;iostream&gt;#include&lt;string&gt;using namespace std;class Person&#123;public: Person(string name, int age) &#123;//当形参与成员变量名相同时，可以使用this指针来区分 this-&gt;age = age; this-&gt;name = name; &#125; Person Person_Plus(Person &amp;person) &#123; string newname = this-&gt;name + person.name; int newage = this-&gt;age + person.age; Person newperson(newname, newage); return newperson; &#125; void show() &#123; cout &lt;&lt; "Name:" &lt;&lt; name &lt;&lt; ",Age:" &lt;&lt; age &lt;&lt; endl; &#125;public: int age; string name;&#125;;void test()&#123; Person person("Aoki", 20); person.show(); Person p1("Aoki", 20); Person p2("青木", 15); Person p3 = p1.Person_Plus(p2); p3.show();&#125;int main()&#123; test();&#125; 输出结果如下： 4.const修饰成员函数（常函数） 用const修饰成员函数时，const修饰this指针指向的内存区域，成员函数体内不可以修改本类中的任何普通变量 当成员变量类型符前面用mutable修饰时例外 12345678910111213141516171819202122232425262728293031323334#include &lt;iostream&gt;using namespace std;class Person&#123;public: Person() &#123; this-&gt;m_A = 0; this-&gt;m_B = 0; &#125; void showinfor () const &#123; //this-&gt;m_B = 10; this-&gt;m_A=100; cout &lt;&lt; "m_A=" &lt;&lt;m_A&lt;&lt; endl; cout &lt;&lt; "m_B=" &lt;&lt; m_B&lt;&lt;endl; &#125; mutable int m_A;//如果需要使用常函数修改变量，加mutable关键字 int m_B;&#125;;void test()&#123; Person p1; p1.showinfor();&#125;int main()&#123; test();&#125; 当我们试图使用常函数对成员变量进行修改时，编译器会报错。报错结果如下图：由此可知，常函数不能修改this指针指向的值。那么，当我们需要使用常函数对成员变量进行修改时呢？那么，我们可以在变量前面加mutable关键字。输出结果如下： 5.const修饰对象（常对象） 常对象只能调用const的成员函数 常对象可访问const或非const数据成员，但是不能修改，除非成员用mutable修饰 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;iostream&gt;using namespace std;class Person&#123;public: Person() &#123; this-&gt;m_A = 0; this-&gt;m_B = 0; &#125; void showinfor () const &#123; //this-&gt;m_B = 10; this-&gt;m_A = 100; cout &lt;&lt; "m_A=" &lt;&lt;m_A&lt;&lt; endl; cout &lt;&lt; "m_B=" &lt;&lt; m_B&lt;&lt;endl; &#125; void show() &#123; cout &lt;&lt; "m_A=" &lt;&lt; this-&gt;m_A &lt;&lt; endl; cout &lt;&lt; "m_B=" &lt;&lt; this-&gt;m_B &lt;&lt; endl; &#125; mutable int m_A;//如果需要使用常函数修改变量，加mutable关键字 int m_B;&#125;;void test()&#123; const Person p1; Person p2; p2.show(); p2.showinfor(); p1.showinfor(); //p1.m_B = 100; p1.m_A = 20; //p1.show(); cout &lt;&lt; "m_A=" &lt;&lt; p1.m_A &lt;&lt; endl; cout &lt;&lt; "m_B=" &lt;&lt; p1.m_B &lt;&lt; endl;&#125;int main()&#123; test();&#125; 当我试图使用常对象来对成员变量进行修改时，编译器报错如下：常对象不能修改没有关键字mutable修饰的成员变量，也就是说，如果一个变量被关键字mutable修改时，那么常对象可以对其进行修改。当我试图使用常对象来访问普通成员函数时，编译器报错如下：也就说，常对象不能调用普通成员函数，它只能调用常函数。最终输出结果如下所示： 5.常函数与常对象的总结 常函数 常函数格式：返回类型 函数名（）const{} 常函数不能修改this指针指向的值 如果需要修改，就必须用关键字mutable来修饰成员变量 常对象 常对象就是在对象前加上const修饰符，如 const Person p1 常对象不可以调用普通成员函数 常对象可以调用常函数 常对象可以修改用mutable关键字修饰的成员变量]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>this指针</tag>
        <tag>常函数</tag>
        <tag>常对象</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[静态成员]]></title>
    <url>%2F2019%2F03%2F21%2F%E9%9D%99%E6%80%81%E6%88%90%E5%91%98%2F</url>
    <content type="text"><![CDATA[写在前面 在类定义中，它的成员（包括成员变量和成员函数），这些成员可以用关键字static声明为静态的，称为静态成员。不管这个类创建了多少个对象，静态成员只有一个拷贝，这个拷贝被所有属于这个类的对象共享。 1.静态成员变量 在一个类中，若将一个成员变量声明为static，这种成员变量称为静态成员变量。与一般的数据成员不同，无论建立多少个对象，都只有一个静态数据的拷贝。静态成员变量，属于某个类，所有对象共享。静态变量，是在编译阶段就分配空间，对象还没创建，就已经分配空间。 静态成员变量必须在类中声明，在类外定义 静态数据成员不属于某个对象，在为对象分配空间中不包括静态成员所占的空间 静态数据成员可以通过类名或者对象名来引用 123456789101112131415161718192021222324252627282930313233#include &lt;iostream&gt;using namespace std;class Person&#123;public: static int m_Age;private: static int m_other;&#125;;int Person::m_Age = 100;int Person::m_other = 20;void test()&#123; Person p1; p1.m_Age = 10; cout &lt;&lt; "p1=" &lt;&lt; p1.m_Age &lt;&lt; endl; cout &lt;&lt; "p1的地址为：" &lt;&lt; &amp;p1.m_Age &lt;&lt; endl; Person p2; p2.m_Age = 20; cout &lt;&lt; "p1=" &lt;&lt; p1.m_Age &lt;&lt; endl; cout &lt;&lt; "p2=" &lt;&lt; p2.m_Age &lt;&lt; endl; cout &lt;&lt; "p2的地址为：" &lt;&lt; &amp;p2.m_Age &lt;&lt; endl;&#125;int main()&#123; test();&#125; 输出结果如下图：通过输出结果我们可以很清除地看到，静态成员变量是所有对象共享的。任何一个对象都可以改变静态变量的值，但是静态变量不属于任何一个对象。下面我们看一下对象的大小，以此来说明静态数据成员不属于某个对象，在为对象分配的空间中不包括静态成员所占的空间。 12345678910111213141516171819202122232425#include &lt;iostream&gt;using namespace std;class Person&#123;public: static int m_Age;private: static int m_other;&#125;;int Person::m_Age = 100;int Person::m_other = 20;void test()&#123; Person p; cout &lt;&lt; sizeof(p) &lt;&lt; endl; cout &lt;&lt; sizeof(p.m_Age) &lt;&lt; endl;&#125;int main()&#123; test();&#125; 输出结果如下图：我们可以看出，对象的大小为1，而静态成员佰利联的大小为4。当我们尝试去访问m_other时，编译器会报错，因为它是一个私有数据成员，这也说明了静态成员变量是有权限控制机制的。 2.静态成员变量 在类定义中，前面有static说明的成员函数称为静态成员函数。静态成员函数使用方式和静态变量一样，同样在对象没有创建前创建，即可他通过类名调用。静态成员函数主要为了访问静态变量，但是不能访问普通成员变量。静态成员函数的意义，不在于信息共享，数据沟通，而在于管理静态数据成员，完成对静态数据成员的封装。 静态成员函数只能访问静态变量，不能访问普通成员变量 静态成员函数的使用和静态成员变量一样 静态成员函数也有访问权限 普通成员函数可以访问静态成员变量，也可以访问非静态变量 如上图所示，当我们使用静态成员函数试图访问非静态成员变量时，编译器会报错，提示信息如上图所示。在上图中，我试图使用类名来访问私有的静态成员函数，编译器报错，因为静态成员函数也有自己的权限。 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;iostream&gt;using namespace std;class Person&#123;public: static void func()//静态成员函数 &#123; m_Age = 100; //m_A = 20;//作用域 cout &lt;&lt; "静态成员函数调用" &lt;&lt; endl; &#125; static int m_Age; int m_A;private: static int m_other; static void func01() &#123; cout &lt;&lt; "静态成员函数func2调用" &lt;&lt; endl; &#125;&#125;;int Person::m_Age = 100;int Person::m_other = 20;void test()&#123; Person p1; Person p2; p1.func(); p2.func(); Person::func(); //Person::func01();//作用域&#125;int main()&#123; test();&#125; 输出结果如下图： 3.总结 静态成员变量 编译阶段分配内存 所有对象共享数据 通过对象访问，通过类名访问 有权限控制 类内声明，类外初始化 静态成员函数 可以访问静态成员变量，不可以访问普通成员变量 普通成员函数都可以访问 静态成员函数也有权限 可以通过对象访问，也可以通过类名访问]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>静态成员变量</tag>
        <tag>静态成员函数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[拷贝构造函数]]></title>
    <url>%2F2019%2F03%2F21%2F%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[写在前面 默认情况下，C++编译器至少会为我们写的类增加三个函数 默认构造函数（无参，函数体为空） 默认析构函数（无参，函数体为空） 默认拷贝构造函数，对类中非静态成员属性进行简单的值拷贝 如果用户定义了拷贝构造函数，C++不会再提供任何默认的构造函数 如果用户定义了普通构造函数（非拷贝），C++不再提提供默认无参构造，但是会提供默认拷贝构造。 在之前的博文中，我介绍了构造函数和析构函数，这一篇里面，我会对拷贝构造函数单独进行介绍，并介绍深拷贝、浅拷贝等。 1.拷贝构造函数的调用时机 拷贝构造函数的调用时机如下： 用一个对象初始化另一个对象 对象以值传递的方式给函数参数 函数局部对象以值传递的方式从函数返回 下面，我举例说明： 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;iostream&gt;using namespace std;class MyClass&#123;public: MyClass() &#123; cout &lt;&lt; "默认构造函数" &lt;&lt; endl; &#125; MyClass(int a) &#123; cout &lt;&lt; "有参构造函数" &lt;&lt; endl; &#125; MyClass(const MyClass &amp;m) &#123; cout &lt;&lt; "拷贝构造函数调用" &lt;&lt; endl; &#125; ~MyClass() &#123; cout &lt;&lt; "析构函数调用" &lt;&lt; endl; &#125; int ak;&#125;;void test()&#123; MyClass m1; m1.ak = 10; MyClass m2(m1);//用已经创建好的对象来初始化新的对象&#125;int main()&#123; test();&#125; 输出结果如下图:在上面的例子中，我使用了一个已经创建好的对象来初始化一个新的对象。 这也就是拷贝构造函数对的第一个调用时机。下面是第二个调用时机，即对象以值传递的方式给函数参数。 1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;iostream&gt;using namespace std;class MyClass&#123;public: MyClass() &#123; cout &lt;&lt; "默认构造函数" &lt;&lt; endl; &#125; MyClass(int a) &#123; cout &lt;&lt; "有参构造函数" &lt;&lt; endl; &#125; MyClass(const MyClass &amp;m) &#123; cout &lt;&lt; "拷贝构造函数调用" &lt;&lt; endl; &#125; ~MyClass() &#123; cout &lt;&lt; "析构函数调用" &lt;&lt; endl; &#125; int ak;&#125;;void dowork(MyClass m)//以值传递方式给函数传参&#123;&#125;void test()&#123; MyClass m1; m1.ak = 10; dowork(m1);&#125;int main()&#123; test();&#125; 输出结果如下图: 最后，是函数局部对象以值传递的方式从函数返回。 12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;iostream&gt;using namespace std;class MyClass&#123;public: MyClass() &#123; cout &lt;&lt; "默认构造函数" &lt;&lt; endl; &#125; MyClass(int a) &#123; cout &lt;&lt; "有参构造函数" &lt;&lt; endl; &#125; MyClass(const MyClass &amp;m) &#123; cout &lt;&lt; "拷贝构造函数调用" &lt;&lt; endl; &#125; ~MyClass() &#123; cout &lt;&lt; "析构函数调用" &lt;&lt; endl; &#125; int ak;&#125;;MyClass dowork()//函数局部对象以值传递的方式从函数返回&#123; MyClass m1; return m1;&#125;void test()&#123; MyClass m = dowork();&#125;int main()&#123; test();&#125; 输出结果如下： 2.浅拷贝和深拷贝 浅拷贝同一个类型的对象之间可以赋值，使得两个对象的成员变量的值相同，两个对象仍然是独立的两个对象，这种情况被称为浅拷贝。一般情况下，浅拷贝没有任何副作用，但是当类中有指针，并且指针指向动态内存分配的内存空间，析构函数做了动态内存释放的处理，会导致内存问题。 1234567891011121314151617181920212223242526272829303132333435363738394041424344#define _CRT_SECURE_NO_WARNINGS#include &lt;iostream&gt;using namespace std;class Person&#123;public: Person() &#123; &#125; Person(const char *name, int age) &#123; Name = (char*)malloc(strlen(name) + 1); strcpy (Name, name); Age = age; &#125; ~Person() &#123; cout &lt;&lt; "析构函数调用" &lt;&lt; endl; if (Name != NULL) &#123; free(Name); Name = NULL; &#125; &#125;//系统提供默认拷贝构造函数 char *Name; int Age;&#125;;void test()&#123; Person p1("Aoki", 20); Person p2(p1);&#125;int main()&#123; test();&#125; 输出结果如下：我们可以看到，错误提示信息中提到了heap.cpp。此外，输出结果中出现了两次析构函数的调用。下面，我尝试尽可能地解释清楚原因。我们创建了一个对象p1，它有两个属性，一个存放在堆区，一个在栈区，当编译器进行简单的值拷贝时，只是将堆区内容的地址给了新对象p2，接着调用析构函数，释放p1的空间，而存放在堆区的数据也就消失了，紧接着，对象p2也调用析构函数来进行释放。那么，堆区的同一个地址就被释放了两次，引发了异常。图示如下：这时候，我们就要用到深拷贝了。深拷贝当类中有指针，并且此指针有动态分配空间，析构函数做了释放处理，往往需要自定义拷贝构造函数，自行给指针动态分配空间，深拷贝。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#define _CRT_SECURE_NO_WARNINGS#include &lt;iostream&gt;using namespace std;class Person&#123;public: Person() &#123; &#125; Person(const char *name, int age) &#123; Name = (char*)malloc(strlen(name) + 1); strcpy (Name, name); Age = age; &#125; Person(const Person &amp;p)//深拷贝 &#123; Age = p.Age; Name = (char*)malloc(strlen(p.Name) + 1); strcpy(Name, p.Name); &#125; ~Person() &#123; cout &lt;&lt; "析构函数调用" &lt;&lt; endl; if (Name != NULL) &#123; free(Name); Name = NULL; &#125; &#125; char *Name; int Age;&#125;;void test()&#123; Person p1("Aoki", 20); Person p2(p1);&#125;int main()&#123; test();&#125; 输出结果如下：]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>拷贝构造函数</tag>
        <tag>深拷贝</tag>
        <tag>浅拷贝</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[函数重载]]></title>
    <url>%2F2019%2F03%2F21%2F%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD%2F</url>
    <content type="text"><![CDATA[写在前面 如果同一个作用域内的几个函数名字相同，但是形参列表不同，我们称之为重载函数。实现函数重载的条件： 同一个作用域 参数个数不同 参数类型不同 参数顺序不同 函数的名字仅仅是让编译器知道它调用的是哪个函数，而函数重载在一定程度上可以减轻程序员起名字、记名字的负担。 1.定义重载函数 下面是一个函数重载的例子。函数重载使得我们可以定义一组函数，名字都为func。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;iostream&gt;#include&lt;string&gt;using namespace std;namespace A&#123; void func() &#123; cout &lt;&lt; "没有参数" &lt;&lt; endl; &#125; void func(int a) &#123; cout &lt;&lt; "a=" &lt;&lt; a &lt;&lt; endl; &#125; void func(string a) &#123; cout &lt;&lt; "a=" &lt;&lt; a &lt;&lt; endl; &#125; void func(int a, float b) &#123; cout &lt;&lt; "a=" &lt;&lt; a &lt;&lt; " b=" &lt;&lt; b &lt;&lt; endl; &#125; void func(string a, int b) &#123; cout &lt;&lt; "a=" &lt;&lt; a &lt;&lt; " b=" &lt;&lt; b &lt;&lt; endl; &#125;&#125;void test()&#123; A::func(); A::func(15); A::func("Aoki"); A::func(12, 3.12); A::func("Aoki", 15);&#125;int main()&#123; test();&#125; 输出结果如下：虽然我们定义的是五个函数各不相同，但是它们都有同一个名字。编译器根据实参的类型来决定应该调用哪一个函数。对于重载的函数来说，它们应该在形参数量或形参类型上有所不同。对于函数的重载，我们不能以函数的返回值作为重载的条件，这是为什么呢？当编译器能从上下文中确定唯一的函数时，如int ret=func(),这样就不会有问题。但是我们在编写程序的过程中还可以忽略它的返回值，那么这个时候，一个函数为 void fun(int x),另一个为 int func(int x),当我们直接调用func(10)，这时候编译器就不确定该调用哪个函数。所以，在C++中禁止使用返回值作为重载的条件。 对于函数重载，我们还应当注意避免二义性。举例如下： 1234567891011121314151617181920212223242526272829#include &lt;iostream&gt;#include&lt;string&gt;using namespace std;namespace A&#123; void func(string a) &#123; cout &lt;&lt; "a=" &lt;&lt; a &lt;&lt; endl; &#125; void func(string a, int b=10) &#123; cout &lt;&lt; "a=" &lt;&lt; a &lt;&lt; " b=" &lt;&lt; b &lt;&lt; endl; &#125;&#125;void test()&#123; //A::func("Aoki");//出现二义性&#125;int main()&#123; test();&#125; 错误提示如下：在使用函数重载的同时，我们应该注意避免这种情况出现。 2.调用重载的函数 定义了一组重载函数之后，我们需要以合理的实参来调用它们。函数匹配是指一个过程，在这个过程中我们把函数调用与一组重载函数中的某一个关联起来，函数匹配也叫重载确定。编译器首先将调用的实参与重载集合中对的每一个函数的形参进行比较，然后根据比较的结果决定到底调用哪个函数。在很多情况下，我们很容易判断某次调用是不是合法对的，以及当调用合法时该调用哪个函数。通常，重载集中的函数区别明显，它们要不然是参数的数量不同，要不然就是参数类型毫无关系。此时，确定调用哪个函数比较容易。但是在另外一些情况下要想选择函数就比较困难了。比如当两个重载函数参数数量相同，且参数类型可以相互转换。当调用重载函数时有三种可能的结果： 编译器找到一个与实参最佳匹配的函数，并生成了调用该函数的代码。 找不到任何一个函数与调用的实参匹配，此时编译器发出无匹配的错误信息。 有多于一个函数可以匹配，但是每一个都不是明显的最佳选择。此时也发生错误，称为二义性调用。 3.函数重载实现原理 编译器为了实现函数重载，为我们做了一些幕后的工作，编译器用不同的参数类型来修饰不同的函数名，比如 void func();编译器可能会将函数名修饰成—func，当编译器碰到void func(int x)，编译器可能会将函数名修饰为_func_int,当编译器碰到void func(int x,char c)，编译器可能会将函数名修饰为_func_int_char，这里使用可能，是因为编译器如何修饰重载的函数名称并没有一个统一的标准，所以不同的编译器可能会产生不同的内部名。]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>函数重载</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[构造函数和析构函数]]></title>
    <url>%2F2019%2F03%2F20%2F%E5%87%BD%E6%95%B0%E5%92%8C%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[1.初始化和清理 C++中OO思想也是来源于现实，是对现实事物的抽象模拟，具体来说，当我们常见对象的时候，这个对象应该有一个初始状态，当对象销毁之前应该销毁自己创建的一些数据。对象的初始化和清理也是两个非常重要的安全问题，一个对象或者变量没有初始化时，对其使用后果是未知的，同样的使用完一个变量，，没有及时清理，也会造成一定的安全问题。C++为了给我们提供这种问题的解决方案，构造函数和析构函数。这两个函数将会被编译器自动调用，完成对象初始化和对象清理工作。无论我们是否喜欢这种方式，对象的初始化和清理工作是编译器强制我们必须要做的事情，即使我们不提供初始化操作和清理操作，编译器也会给我们增加默认对的操作，只是这个默认初始化操作不会做任何事，所以编写类就应该顺便提供初始化函数。为什么初始化操作时自动调用而不是手动调用？既然是必然操作，那么自动调用会更好，如果靠我们自觉，那么就会存在遗漏初始化的情况出现。 2.构造函数 构造函数主要作用在于创建时为对象的成员属性赋值，构造函数由编译器自动调用，无须手动调用。构造函数语法： 构造函数函数名和类名相同，没有返回值，不能有void，但可以有参数。 ClassName(){} 3.析构函数 析构函数主要用于对象销毁前系统自动调用，执行一些清理工作。析构函数语法： 析构函数函数名是类名前面加”~”组成，没有返回值，不能有void，不能有参数，不能重载。 ~ClassName（）{} 下面我举例说明构造函数与析构函数。 12345678910111213141516171819202122232425#include &lt;iostream&gt;using namespace std;class Person&#123;public: Person() &#123; cout &lt;&lt; "构造函数调用" &lt;&lt; endl; &#125; ~Person() &#123; cout &lt;&lt; "析构函数调用" &lt;&lt; endl; &#125;&#125;;void test()&#123; Person p1;&#125;int main()&#123; test();&#125; 输出结果如下：从输出结果我们可以看出，在创建对象时，构造函数调用。当对象销毁之前，又调用了析构函数。 4.构造函数的分类及调用 按参数类型：分为无参构造函数和有参构造函数 按类型分类：分为普通构造函数和拷贝构造函数（复制构造函数） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;iostream&gt;using namespace std;class Person&#123;public: Person()//默认，无参构造函数 &#123; cout &lt;&lt; "默认构造函数调用" &lt;&lt; endl; &#125; Person(int a)//有参构造函数调用 &#123; cout &lt;&lt; "有参构造函数调用" &lt;&lt; endl; &#125; //拷贝构造函数 Person(const Person&amp; p) &#123; m_age = p.m_age; cout &lt;&lt; "拷贝构造函数调用" &lt;&lt; endl; &#125; ~Person() &#123; cout &lt;&lt; "析构函数调用" &lt;&lt; endl; &#125; long m_age; static int n_age; &#125;;static int n_age = 100;void test()&#123; Person p1(1);//有参拷贝构造函数调用 p1.m_age = 10; cout &lt;&lt; "p1的年龄为：" &lt;&lt; p1.m_age &lt;&lt; endl; Person p2(p1);//拷贝构造函数调用 cout &lt;&lt; "p2的年龄为：" &lt;&lt; p2.m_age &lt;&lt; endl; Person(100);//匿名对象，当本行代码执行完毕就释放对象 Person p3 = 100;//隐式类型转换，相当于调用了Person p7=Person(100) Person p4 = p3;//拷贝构造函数调用，相当于Person p4=Person(p3)&#125;int main()&#123; test(); return 0;&#125; 输出结果如下：这里，我们需要注意的是，析构函数和构造函数必须写在public下才可以调用。同时，对于无参构造函数（默认构造）、有参构造函数在创建对象时的调用应当注意。当我们我们没有定义构造函数时，系统会给我们提供一个空的默认构造函数，但是当我们定义了无参构造函数时，系统使用我们的构造函数。除此之外，当我们定义了一个有参构造函数，但是并没有提供无参构造函数时，在创建对象的时候必须使用有参构造。原因是，当我们声明一个有参构造函数之后，系统不再提供默认构造函数。]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>析构函数</tag>
        <tag>构造函数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于C语言下的封装和C++语言封装的区别]]></title>
    <url>%2F2019%2F03%2F19%2FC%E8%AF%AD%E8%A8%80%E4%B8%8B%E7%9A%84%E5%B0%81%E8%A3%85%E5%92%8CC-%E8%AF%AD%E8%A8%80%E5%B0%81%E8%A3%85%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[1.封装 我们编写程序来解决现实中的问题，而这些问题的是由各种事物组成的。我们解决这个问题的前提就是将事和物抽象得到计算机程序中，也就是用程序语言表示现实的事物。现实世界的事物所具有的共性就是每个事物都具有自身的属性和行为，所以如果我们能把这些事物的属性和行为表示出来，那么就可以抽象出这个事物。属性和行为应该放在一起，一起来表示一个具有属性和行为的对象。为什么需要这样做呢？我稍后解释。假如某对象的某项属性不想被外界获知，比如女孩子的体重，那么对于体重这个属性，就应该是只有女孩自己知道的属性，或者女孩的某些行为，比如暗恋某个男生，不想让外界知道，只能让自己知道，那么在这种情况下，封装应该提供一种机制，能够给属性和行为的访问权限控制住。所以说封装特性包含两方面，一个是属性和变量合成一个整体，一个是给属性和函数增加访问权限。 封装 把变量（属性）和函数（操作）合成一个整体，封装在一个类中。 对变量和函数进行访问控制。 访问权限 在类的内部（作用域范围之内），没有访问权限之分，所有成员可以相互访问。 在类的外部（作用域范围外），访问权限才有意义：public,private,protected 在类的外部，只有public修饰的成员才能被访问，在没有涉及继承和派生时，private和protected是同等级的，外界不可以访问。 访问属性 属性 对象内部 对象外部 public 公有 可访问 可访问 protected 保护 可访问 不可访问 private 私有 可访问 不可访问 其中，potected为保护权限，类内部可以访问，当前类的子类可以访问，类外部不可以。而private是对象的私有数据，子类和类外部都不可以访问。 下面，我们对比以下C语言下的封装和C++语言下封装的区别。 2.C语言下的封装 在C语言中我们可以定义一个结构体来表示一个对象所包含的属性，函数用来表示出来一个事物，在C语言中，结构体中不能定义函数，所以行为和定义方式分开的，也就是说吃饭这个属性不属于某个对象，而属于所有的共同数据。 1234567891011121314151617181920212223242526272829303132333435363738394041424344#define _CRT_SECURE_NO_WARNINGS#include&lt;stdio.h&gt;#include&lt;string.h&gt;#include&lt;stdlib.h&gt;struct person &#123; char name[10]; int age;&#125;;void PersonEat(struct person *p)&#123; printf("%s在吃饭\n", p-&gt;name);&#125;struct Dog&#123; char name[10]; int age;&#125;;void DogEat(struct Dog *d)&#123; printf("%s在狗粮\n", d-&gt;name);&#125;void test01()&#123; struct Dog one; strcpy(one.name, "旺财"); DogEat(&amp;one); struct person two; strcpy(two.name, "Aoki"); DogEat(&amp;two);&#125;void main()&#123; test01(); system("pause");&#125; 输出结果如下：从输出结果我们可以看出，小狗旺财和Aoki这个人正在一块吃狗粮，但是正常情况下，Aoki怎么可能吃狗粮呢？从这里，我们可以看出在C中封装一个对象造成了什么样的后果。那么，在C++中的封装呢？ 123456789101112131415161718192021222324252627282930313233343536373839#define _CRT_SECURE_NO_WARNINGS#include &lt;iostream&gt;using namespace std;struct Person&#123; char name[10]; int age; void PersonEat() &#123; cout &lt;&lt; name &lt;&lt; "在吃饭" &lt;&lt; endl; &#125;&#125;;struct Dog&#123; char name[10]; int age; void DogEat() &#123; cout &lt;&lt; name &lt;&lt; "在吃狗粮" &lt;&lt; endl; &#125;&#125;;void test()&#123; Person one; strcpy(one.name, "Aoki"); one.PersonEat(); //one.DogEat();&#125;int main()&#123; test();&#125; 刚开始，我尝试了使用one这个对象来调用DogEat这个函数，编译器报错，不允许我们使用它，因为DogEat并不是Person的成员函数。编译器报错如下：在注释掉报错语句之后，正确输出结果如下：从上面的例子中，我们可以看到，C++中的封装，有着严格的类型转换检测，C++让属性和行为绑定在一起。属性和行为作为一个整体来表示生活中的事物。]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>封装</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[宏缺陷和内联函数]]></title>
    <url>%2F2019%2F03%2F18%2F%E5%AE%8F%E7%BC%BA%E9%99%B7%E5%92%8C%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[写在前面 C++从C中继承的一个重要特征就是效率。 在C中我们经常把一些短并且执行频繁的计算写成宏，而不是函数，这样做的理由方式为了执行效率，宏可以避免函数调用的开销，这些都由预处理来完成。 但是在C++出现以后，使用宏处理会出现两个问题： 第一个在C中也会出现，宏看起来像是一个函数调用，但是会隐藏一些难以发现的错误。 第二个问题是C++特有的，预处理器不允许访问类的成员，也就是说预处理器宏不能用作类的成员的函数。 为了保持预处理宏的效率又增加安全性，而且能像一般成员函数那样在类里访问自如，C++引入了内联函数。 内联函数为了继承宏函数的效率，没有函数调用的开销，然后又可以像普通函数那样，可以进行参数、返回值类型的安全检查，又可以作为成员函数。 1.预处理宏的缺陷 预处理器宏存在问题的关键是我们可能认为预处理器的行为和编译器时一样的。当然也是由于宏函数调用和函数调用在外表看起来是一样的，因此也容易混淆。但是其中会有一些微妙的问题出现。 例112345678910111213141516171819202122232425262728293031323334353637#include &lt;iostream&gt;using namespace std;#define ADD(x,y) x+yvoid test()&#123; int ret = ADD(10, 10); int ret0 = ADD(10, 10) * 10;//预期结果为200 cout &lt;&lt; "ret=" &lt;&lt; ret &lt;&lt; endl; cout &lt;&lt; "ret0=" &lt;&lt; ret0 &lt;&lt; endl;&#125;int main()&#123; test();&#125; 输出结果如下： 在输出结果里，我们可以看到，实际输出结果为110，并不是我们想要的结果。它实际进行运算时，运算式应该是：10+10*10。 对于这个微小的问题，我们可以通过加括号的方式来解决它。源代码和输出结果如下： 123456789101112131415161718192021222324252627282930313233#include &lt;iostream&gt;using namespace std;#define ADD(x,y) ((x)+(y))void test()&#123; int ret = ADD(10, 10); int ret0 = ADD(10, 10) * 10;//预期结果为200 cout &lt;&lt; "ret=" &lt;&lt; ret &lt;&lt; endl; cout &lt;&lt; "ret0=" &lt;&lt; ret0 &lt;&lt; endl;&#125;int main()&#123; test();&#125; 输出结果如下： 我们可以看到，加括号之后，输出结果和预期相同。 例2为了防止出现例1中的问题，这次，我特意对三目运算符加了括号。代码如下： 1234567891011121314151617181920212223242526272829303132333435#include &lt;iostream&gt;using namespace std;#define compare(a,b) ((a)&lt;(b))?(a):(b)void test()&#123; int a = 10; int b = 20; int ret = compare(a, b); cout &lt;&lt; "ret=" &lt;&lt; ret &lt;&lt; endl; int ret0 = compare(++a, b); cout &lt;&lt; "ret0=" &lt;&lt; ret0 &lt;&lt; endl;&#125;int main()&#123; test();&#125; 输出结果如下: 这次出现的问题让人有点摸不到头脑，因此++运算符表示在进行运算之前加1，但是输出结果中，实际输出为12，相当于加了两次。 除此之外，我们还应当注意的是，预定义宏函数没有作用域概念，无法作为一个类的成员函数，也就是说，预定义宏没办法表示类的范围。 2.内联函数 在C++中，预定义宏额概念是用内联函数来实现的，而内联函数本身也是一个真正的函数。内联函数具有普通函数的所有行为。唯一不同之处在于内联函数会在适当得到地方像预定义宏一样展开，所以不需要函数调用的开销。因此应该不使用宏，使用内联函数。 普通函数（非成员函数）函数前面加上inline关键字使之成为内联函数。但是必须注意函数体和声明结合在一起，否则编译器会把它当成普通函数对待。 1inline void func(int a); 上面的这种写法没有任何效果，仅仅是声明函数，应该像下面这样的方式来定义。 1234567inline void func(int a)&#123; return ++;&#125; 注意：编译器将会检查函数参数列表使用是否正确，并返回值（进行必要的转换）。这些事预处理器是无法完成的。 内联函数的确占用空间，但是内联函数相对于普通函数的优势只是省去了函数调用是否的压栈、跳转、返回的开销。我们可以理解为内联函数是以空间换时间。 内联说明只是向编译器发出一个请求，编译器可以选择忽略这个请求。 一般来说，内联机制用于优化规模较小、流程直接、频繁调用的函数。很多编译器都不支持内联函数递归函数，而且一个75行的函数也不太可能在调用点内联地展开。]]></content>
      <tags>
        <tag>宏缺陷</tag>
        <tag>内联函数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[函数默认参数及占位参数]]></title>
    <url>%2F2019%2F03%2F18%2F%E5%87%BD%E6%95%B0%E9%BB%98%E8%AE%A4%E5%8F%82%E6%95%B0%E5%8F%8A%E5%8D%A0%E4%BD%8D%E5%8F%82%E6%95%B0%2F</url>
    <content type="text"><![CDATA[1.函数默认参数C++在声明函数原型时可为一个或多个参数指定默认（缺省）的参数值，当函数调用的时候如果没有指定这个值，编译器会自动用默认值代替。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;iostream&gt;using namespace std;void func01(int a = 10, int b = 100)&#123; cout &lt;&lt; "a+b=" &lt;&lt; a + b &lt;&lt; endl;&#125;void func02(int a, int b = 12, int c = 11)&#123; cout &lt;&lt; "a=" &lt;&lt; a &lt;&lt; ",b=" &lt;&lt; b &lt;&lt; ",c=" &lt;&lt; c &lt;&lt; endl;&#125;void func03(int a = 0, int b = 0);void func03(int a, int b)&#123; cout &lt;&lt; "a=" &lt;&lt; a &lt;&lt; ",b=" &lt;&lt; b &lt;&lt; endl;&#125;int main()&#123; func01();//使用默认参数 func01(100, 100);//使用现在传入的参数 func01(110);//只传入一个参数，第二个参数使用默认参数 func02(12);//b，c使用默认参数 func03();//没有传参数，使用默认参数 return 0;&#125; 输出结果如下： 注意点： 函数的默认常数函数从左往右，如果一个参数设置了默认参数，那么这个参数之后的参数都必须设置默认参数。 如果函数声明和函数定义分开写，函数声明与函数定义不能同时设置默认参数。 2.函数的占位符 C++在声明函数时，可以使用占位参数。占位参数只有类型声明，而没有参数名声明。一般情况下，在函数体内无法使用占位参数。 12345678910111213141516171819202122232425262728293031323334353637#include &lt;iostream&gt;using namespace std;void func01(int a,int b,int) &#123; //函数内部无法使用占位参数 cout &lt;&lt; a + b &lt;&lt; endl;&#125;void func02(int a, int b, int = 10)&#123; //无法使用占位参数 cout &lt;&lt; a + b &lt;&lt; endl;&#125;int main()&#123; func01(10, 15, 20); func02(10, 25);//占位参数使用默认参数 return 0;&#125; 输出结果如下：]]></content>
      <tags>
        <tag>默认参数</tag>
        <tag>占位参数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++命名空间及using的使用]]></title>
    <url>%2F2019%2F03%2F16%2FC-%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%E5%8F%8Ausing%E7%9A%84%E4%BD%BF%E7%94%A8-1%2F</url>
    <content type="text"><![CDATA[一、C++命名空间&emsp;在C++中，名称（name）可以是符号常量、变量、函数、结构、枚举、类和对象。工程越大，名称相互冲突性的可能性越大。另外，在使用多个厂商的类库时，也可能导致名称冲突。为了避免冲突，在大规模的设计中，以及程序员使用1各种各样的C++库时，这些标识符的命名发生冲突，标准C++引入关键字namesapce（命名空间/名字空间/名称空间），可以更好的控制标识符得到作用域。 12345678910111213141516171819202122232425262728293031323334353637#include &lt;iostream&gt;using namespace std;//创建一个命名空间namespace study&#123; int a = 10;&#125;namespace learn&#123; int a = 20;&#125;int main()&#123; cout &lt;&lt; "命名空间study的a="&lt;&lt;study::a &lt;&lt; endl; cout &lt;&lt;"命名空间learn的a="&lt;&lt; learn::a &lt;&lt; endl;&#125; 运行结果输出： 在命名空间下，可以定义函数，变量、结构体、类；除此之外，对于命名空间的定义还应当注意，它必须定义在全局作用域下。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include &lt;iostream&gt;#include&lt;string&gt;using namespace std;namespace study&#123; int a = 10; namespace A &#123; int a = 100; void sayhi() &#123; cout &lt;&lt; "hi,Aoki" &lt;&lt; endl; &#125; struct Student &#123; string name; &#125;; &#125;&#125;namespace learn&#123; int a = 20;&#125;int main()&#123; //cout &lt;&lt; "命名空间study的a="&lt;&lt;study::a &lt;&lt; endl; //cout &lt;&lt;"命名空间learn的a="&lt;&lt; learn::a &lt;&lt; endl; study::A::sayhi(); cout &lt;&lt; "作用域A下的a=" &lt;&lt; study::A::a &lt;&lt; endl;&#125; 输出结果： 下面是对命名空间错误定义的举例： 对于命名空间，我们还可以定义无名命名空间，意味着命名空间中的标识符只能在本文件中访问，相当于给这个标识符加上了static，使得其可以作为内部连接。 除此之外，还有就是给命名空间起别名，我们为命名空间A起别名为b，源码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;iostream&gt;#include&lt;string&gt;using namespace std;namespace A&#123; int a = 100; void test() &#123; namespace b = A;//给命名空间起别名为b cout &lt;&lt;"A作用域内a="&lt;&lt; b::a &lt;&lt; endl; &#125;&#125;namespace //无名（匿名）命名空间&#123; int c = 15; int d = 16;&#125;int main()&#123; cout &lt;&lt; "c=" &lt;&lt; c &lt;&lt; endl; cout &lt;&lt; "d=" &lt;&lt; d &lt;&lt; endl; A::test();&#125; 运行结果如下图： 下面对命名空间namespace的用法总结如下： 命名空间的用途：解决名称冲突问题 命名空间下可以定义函数、变量、结构、类 命名空间必须定义在全局作用域下 命名空间可以嵌套命名空间 命名空间是开放的，可以随时给原先的命名空间添加内容 定义另个名字相同的命名空间时，两个命名空间会合并，但是不会覆盖 当我们定义了无名空间时，相当于写了static intc=15，static int d=16，只能在当前文件内使用 二、using声明using声明可使得指定的标识符可用 1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;iostream&gt;using namespace std;namespace One&#123; int test = 100;&#125;void test()&#123; int test = 100; using One::test;//using声明 cout &lt;&lt; "test=" &lt;&lt; test &lt;&lt; endl;&#125;int main()&#123; test();&#125; 此处我们使用了using声明，但是编译却发生了错误。因为在test()中我们定义了一个整型数test，并赋予了初值。当我们使用using声明时，编译器有就近原则，它会选择输出test中定义的整型数，但是又发现有using声明，出现二义性问题，编译器不知道怎么处理，所有报错。报错信息如下： 所以，在using声明中，我们应当注意避免二义性问题。 1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;iostream&gt;using namespace std;namespace One&#123; int test = 100;&#125;void test()&#123; int test = 100; //using One::test;//using声明 cout &lt;&lt; "test=" &lt;&lt; test &lt;&lt; endl;&#125;int main()&#123; test();&#125; 输出结果如下图： using声明的一个例子： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include &lt;iostream&gt;using namespace std;namespace One&#123; int test = 100; int a = 99; int b = 30; void func() &#123; cout &lt;&lt; "hi,Aoki!" &lt;&lt; endl; &#125; void func1() &#123; cout &lt;&lt; "hello,Aoki!" &lt;&lt; endl; &#125;&#125;void test()&#123; cout &lt;&lt; "test=" &lt;&lt; One::a &lt;&lt; endl; //using声明 using One::a; using One::func1; using One::func; cout &lt;&lt; "a=" &lt;&lt; a &lt;&lt; endl; func1(); func();&#125;int main()&#123; test();&#125; 运行结果如下图： 下面是using声明遇到函数重载的一个例子： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include &lt;iostream&gt;using namespace std;namespace Two&#123; void func() &#123; cout &lt;&lt; "Nothing!" &lt;&lt; endl; &#125; void func(int x) &#123; cout &lt;&lt; x &lt;&lt; endl; &#125; void func(int x, int y) &#123; cout &lt;&lt; "x=" &lt;&lt; x ; cout &lt;&lt; ",y=" &lt;&lt; y &lt;&lt; endl; &#125;&#125;void test1()&#123; using Two::func; func(); func(15); func(15, 20);&#125;int main()&#123; test1();&#125; 输出结果如下图： 如果命名空间包含一组用相同名字重载的函数，using声明就声明了这个重载函数的所有集合。 三、using编译指令using编译指令使整个命名空间标识符可用。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879#include &lt;iostream&gt;using namespace std;namespace One&#123; int a = 99; int b = 30; void func() &#123; cout &lt;&lt; "hi,Aoki!" &lt;&lt; endl; &#125; void func1() &#123; cout &lt;&lt; "hello,Aoki!" &lt;&lt; endl; &#125;&#125;void test()&#123; using namespace One; cout &lt;&lt; a &lt;&lt; endl; cout &lt;&lt; b &lt;&lt; endl; func(); func1(); int a = 100;//没有产生二义性 cout &lt;&lt; a &lt;&lt; endl;&#125;namespace Two&#123; int a = 1; int b = 2;&#125;;void test1()&#123; //产生二义性 using namespace One; using namespace Two; cout &lt;&lt; a &lt;&lt; endl;&#125; 当我们像上面一样使用using编译指令时，会出现二义性问题，编译器无法通过编译。错误信息如下： 当我们使用using声明或using编译指令时，会增加命名冲突的可能性。也就是说，如果有命名空间，并在代码中使用作用域解析运算符，则不会出现二义性问题。 例子如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091#include &lt;iostream&gt;using namespace std;namespace One&#123; int a = 99; int b = 30; void func() &#123; cout &lt;&lt; "hi,Aoki!" &lt;&lt; endl; &#125; void func1() &#123; cout &lt;&lt; "hello,Aoki!" &lt;&lt; endl; &#125;&#125;void test()&#123; using namespace One; cout &lt;&lt; a &lt;&lt; endl; cout &lt;&lt; b &lt;&lt; endl; func(); func1(); int a = 100; cout &lt;&lt; a &lt;&lt; endl;&#125;namespace Two&#123; int a = 1; int b = 2;&#125;;void test1()&#123; using namespace One; using namespace Two; //cout &lt;&lt; a &lt;&lt; endl;&#125;int main()&#123; test(); test1();&#125; 输出结果如下： 当我们引入一个全局的using编译指令时，就为该文件打开了命名空间，它不会影响其他的文件，所以可以再每一个实现文件中调整对命名空间的控制。比如，如果发现某一个实现文件中有太多using指令而产生命名冲突，就要对该文件做个简单的改变，通过明确限定或者using声明来消除名字冲突，这样不需要修改其他实现文件。]]></content>
      <tags>
        <tag>命名空间</tag>
        <tag>using的使用</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于const限定符的一些总结]]></title>
    <url>%2F2019%2F03%2F11%2Fconst%E9%99%90%E5%AE%9A%E7%AC%A6%2F</url>
    <content type="text"><![CDATA[写在前面 有时候我们希望定义这样一种变量，它的值不能被改变。例如，用一个变量表示缓冲区的大小。使用变量的好处是我们觉得缓冲区不再合适的时候，很容易对其进行调整。另一方面，也应随时警惕，防止程序一不小心修改了这个值。为了满足这一要求，可以用关键词const对变量的类型加以限定。 在C++中，一个const不必创建内存空间，而在C中，const总是需要一块内存空间。在C++中，是否为const常量分配内存空间依赖于如何使用。一般来说，如果一个const仅仅用来把一个名字用一个值来代替，那么该存储空间就不必创建。 在存储空间没有分配内存的话，在进行完数据类型检查后，为了代码更加有效，值也许会折叠到代码中。不过取一个const地址，或者把它定义为extern，则会为该const创建内存空间。 在C++中，出现在所有函数之外的const作用于整个文件（也就是说它在该文件外部不可见，默认为内部连接，C++中其他标识符一般默认为外部连接。 1.初始化和const &lt;/br&gt;&lt;/br&gt;const类型的对象能完成非const类型所能完成的大部分操作，但是对于const类型对象的主要限制就是只能在const类型对的对象上执行不改变其内容的操作。 在不改变const对象的操作中还有一种是初始化，如果利用一个对象去初始化另外一个对象，则它们是不是const都无关紧要。 123456789101112#include &lt;iostream&gt;using namespace std;int main()&#123; int i = 12; const int ci = i;//i的值拷贝给了ci int j = ci; cout &lt;&lt; "i=" &lt;&lt; i &lt;&lt; endl; cout &lt;&lt; "ci=" &lt;&lt; ci &lt;&lt; endl; cout &lt;&lt; "j=" &lt;&lt; j &lt;&lt; endl;&#125; &lt;/br&gt;输出结果如下： &lt;/br&gt;&lt;/br&gt; 2.const引用 &lt;/br&gt;可以把引用绑定到const对象上，就像绑定到其他对象上一样，我们称之为——常量引用。 与普通引用不同的是，对常量的引用不能被用作修改它所绑定的对象。 错误示范如下： 3.初始化和对const的引用 &lt;/br&gt;引用的类型必须与其所引用对象的类型一致，但是有两个情况例外。第一个例外情况就是在初始化常量引用时，允许用任意表达式作为初始值，只要该表达式的结果能转化成引用的类型即可。 允许一个常量引用绑定非常量的对象、字面值、甚至是一般表达式。 123456789101112131415#include &lt;iostream&gt;using namespace std;int main()&#123; int i = 42; const int &amp;r1 = i;//允许将const int &amp;绑定到一个普通int对象上 const int &amp;r2 = 42;//r1是一个常量引用 const int &amp;r3 = r1 * 2;//r3是一个常量引用 cout &lt;&lt; "i=" &lt;&lt; i &lt;&lt; endl; cout &lt;&lt; "r1=" &lt;&lt; r1 &lt;&lt; endl; cout &lt;&lt; "r2=" &lt;&lt; r2 &lt;&lt; endl; cout &lt;&lt; "r3=" &lt;&lt; r3 &lt;&lt; endl;&#125; 输出结果如下： &lt;/br&gt;&lt;/br&gt; 4.对cons的引用可能引用一个并非const的对象 &lt;/br&gt; 12345678910111213141516171819#include &lt;iostream&gt;using namespace std;int main()&#123; int i = 42; int &amp;r1 = i;//引用r1绑定对象i const int &amp;r2 = i;//常量引用r2绑定i，但是r2不能修改i的值 cout &lt;&lt; "i=" &lt;&lt; i &lt;&lt; endl; cout &lt;&lt; "r1=" &lt;&lt; r1 &lt;&lt; endl; cout &lt;&lt; "r2=" &lt;&lt; r2 &lt;&lt; endl; r1 = 10; cout &lt;&lt; "i=" &lt;&lt; i &lt;&lt; endl; cout &lt;&lt; "r1=" &lt;&lt; r1 &lt;&lt; endl; cout &lt;&lt; "r2=" &lt;&lt; r2 &lt;&lt; endl; //r2 = 5;//此处报错，因为r2是一个常量引用&#125; 输出结果如下：&lt;/br&gt;&lt;/br&gt; 对于常量引用来说，一般情况下是没有办法来对它进行修改的，但是可以使用下面的方法来尝试对常量引用进行修改。代码图如下： 1234567891011#include &lt;iostream&gt;using namespace std;int main()&#123; const int &amp;ref = 10; cout &lt;&lt; "ref=" &lt;&lt; ref &lt;&lt; endl; int *p = (int *)&amp;ref; *p = 100; cout &lt;&lt; "ref=" &lt;&lt; ref &lt;&lt; endl;&#125; 输出结果如下：&lt;/br&gt;&lt;/br&gt;这里我们使用了一个指针来对常量引用进行修改。首先，我们要知道的是，常量引用不是一个对象，编译器并没有给它分配内存空间。当我们使用指针指向常量引用时，编译器会给常量引用临时开辟一块内存空间。代码示意如下： 12int tmp=ref;//tmp有内存int *p=(int *)&amp;ref;//*p指向的是那块临时空间，临时空间看不到 &lt;/br&gt;&lt;/br&gt; 5.指针和const &lt;/br&gt;与引用一样，也可以令指针指向常量或非常量。类似于常量引用，指向常量的指针不能改变其所指对象的值。要想存放常量对象的地址，只能使用指向常量的指针。实例代码如下： 123456789101112131415#include &lt;iostream&gt;using namespace std;int main()&#123; const int i = 10; //int *r1 = &amp;i;//报错，r1是一个普通指针，并不能指向一个常量 const int *r2 = &amp;i;//常量指针指向常量 //常量指针可以指向常量，但是并不能修改常量的值 cout &lt;&lt; "常量i的地址为：" &lt;&lt; &amp;i &lt;&lt; endl; cout &lt;&lt; "r2指向的地址为：" &lt;&lt; r2 &lt;&lt; endl; cout &lt;&lt; "i=" &lt;&lt; i &lt;&lt; endl; cout &lt;&lt; "r2=" &lt;&lt; *r2 &lt;&lt; endl;&#125; 输出结果如下：&lt;/br&gt;&lt;/br&gt; 6.const指针 &lt;/br&gt;指针是对象而引用不是，就像其他对象类型一样，允许把指针本身定义为常量。常量指针必须初始化，而且一旦初始化完成，则它的值（也就是存放在指针中的那个地址）就不能再修改。把*放在const关键字之前用以说明指针是一个常量。这样书写的意味着，不变的是指针本身的值，而不是指向的那个值。 12345678910111213141516#include &lt;iostream&gt;using namespace std;int main()&#123; int i = 10; int *const r1 = &amp;i;//r1将一直指向i const int i1 = 11; const int *const r2 = &amp;i1;//r2是指向常量的常量指针 cout &lt;&lt; "i=10时地址为：" &lt;&lt; &amp;i &lt;&lt; endl; cout &lt;&lt; "常量指针r1指向的地址为：" &lt;&lt; r1 &lt;&lt; endl; i = 100; cout &lt;&lt; "i=100时地址为：" &lt;&lt; &amp;i &lt;&lt; endl; cout &lt;&lt; "常量指针r1指向的地址为：" &lt;&lt; r1 &lt;&lt; endl;&#125; 输出结果如下： &lt;/br&gt;&lt;/br&gt; 7.顶层const &lt;/br&gt;指针本身就是一个对象，它又可以指向1另外一个对象。因此指针本身是不是常量，以及指针指向的对象是不是一个常量是两个独立的问题。 顶层const表示指针本身是一个常量。 底层const表示指针所指的对象时一个常量。 更一般地，顶层const可以表示任意的对象时常量，这一点对任何数据类型都适用，如算术类型、类、指针等。底层const则与指针和引用等符合类型的基本类型有关。比较特殊的是，指针类型既可以是顶层const，也可以是底层const。 &lt;/br&gt;&lt;/br&gt; 8.尽量使用const代替#define &lt;/br&gt;在旧版本的C中，如果想建立一个常量，必须使用预处理器。 1#define MAX 1024; 这里我们定义的宏MAX从未被编译器看到过，因为在预处理阶段，所有的MAX已经全部被替换成了1024，于是MAX并没有将其加入符号表中。但是我们使用这个常量获得一个编译错误信息时，可能会带来一些困扰，因为这个信息可能会提到1024，但是并没有提到MAX。如果MAX被定义在一个不是我们自己写的头文件中，我们可能并不知道1024代表着什么，也许解决这个问题需要很长的时间。解决这个问题的办法就是用一个常量来替换掉上面的宏： 1const int MAX=1024； 1#undef A //卸载宏常量A const和#define的区别 const有类型，可进行编译器类型安全检查，#define无类型，不可进行类型检查 const有作用域，而#define不重视作用域，默认定义处到文件末尾，如果定义在指定作用域下有效的常量，那么#define就不能用。]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>限定符</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++复合类型]]></title>
    <url>%2F2019%2F03%2F09%2FC-%E5%A4%8D%E5%90%88%E7%B1%BB%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[复合类型是指基于其他类型定义的类型。C++有几种复合类型，下面主要是引用和指针。定义复合类型的变量复杂很多，通用的描述为：一条声明语句由一个基本数据类型和紧随其后的一个声明符列表组成。每个声明符命名了一个变量并指定该变量为与基本数据类型有关的某种类型。 引用 C++11中新增加了一种引用，为右值引用，主要用于内置类。这里，我们使用引用时，指的是左值引用。引用为对象起了另外一个名字，引用类型引用另外一种类型。通过将声明符写成&amp;d的形式来定义引用类型，其中d是声明的变量名。引用即别名，并非对象，它只是为一个已经存在的对象所起的另外一个名字。下面是引用的一个例子。123456789101112#include &lt;iostream&gt;using namespace std;int main()&#123; int vale = 1024; int &amp;vale00 = vale; //注意：引用必须进行初始化 cout &lt;&lt; "vale的值为：" &lt;&lt; vale &lt;&lt; endl; cout &lt;&lt; "vale00的值为：" &lt;&lt; vale00 &lt;&lt; endl; cout &lt;&lt; "vale00是vale的引用。" &lt;&lt; endl;&#125; 定义了一个引用之后，对其进行的所有操作都是在与之绑定的对象上进行的。为引用赋值，实际上是把值赋给了与引用绑定的对象。获取引用的值，实际上是获取到了与之绑定的对象的值。同理，以引用作为初始值，实际上是以引用绑定的对象作为初始值。1234567891011121314#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;int main()&#123; string name = "青木"; string &amp;name_ = name; string name0 = "Aoki"; cout &lt;&lt; "大家好，我的名字是" &lt;&lt; name_ &lt;&lt; endl; cout &lt;&lt; "大家好，我是" &lt;&lt; name0 &lt;&lt; endl; name0 = name_;//为引用赋值 cout &lt;&lt; "大家好，我现在是" &lt;&lt; name0 &lt;&lt; endl;&#125; 输出结果为： 引用 指针是指向另外一种类型的复合类型。与引用类似，指针也实现了对其他对象的间接访问，但是指针与引用也有很多不同点，如下： 指针本身就是个对象，允许对指针赋值和拷贝，在指针的生命周期内，它可以先后指向几个不同的对象 指针无须在定义时赋初值。和其他内置类型一样，在块作用域内定义的指针如果没有定义，也将拥有一个不确定的值。 获取对象的地址 指针存放某个对象的地址，要向获取该地址，就要使用取地址符（&amp;）。在声明语句中，指针的类型实际上被用于它所指向的对象的类型，所以二者必须匹配。如果指针指向了一个其他类型的对象，对该对象的操作将会发生错误。123456789101112#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;int main()&#123; string name = "青木"; string* name_=&amp;name;//name_存放变量name的地址，或者说name_是指向变量name的指针 cout &lt;&lt; "大家好，我的名字是" &lt;&lt; name &lt;&lt; endl; cout &lt;&lt; "name的地址为:" &lt;&lt; name_ &lt;&lt; endl; cout &lt;&lt; "大家好，我的名字是" &lt;&lt; name_ &lt;&lt; endl;&#125; 输出结果为： 指针值 指针的值（即地址）应属于下列4中状态之一： 指向一个对象 指向紧邻对象所占空间的下一个位置 空指针，意味着指针没有指向任何值 无效指针，就是上述状态之外的其他值。 对于无效指针，试图拷贝或以其他方式访问无效指针的值都将引发错误。 利用指针访问对象 如果一个指针指向了一个对象，则允许使用解引用符（*）来访问该对象。对指针解引用会得到所指的对象，因此如果给解引用的结果赋值，实际上也就是给指针所指的内容赋值。 注意：解引用操作仅适用于那些确实指向了某个对象的有效指针。 12345678910111213141516#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;int main()&#123; string name = "青木"; string name0 = "Aoki"; string* name_=&amp;name;//name_存放变量name的地址，或者说name_是指向变量name的指针 cout &lt;&lt; "大家好，我的名字是" &lt;&lt; name &lt;&lt; endl; cout &lt;&lt; "name的地址为:" &lt;&lt; name_ &lt;&lt; endl; cout &lt;&lt; "大家好，我的名字是" &lt;&lt; *name_ &lt;&lt; endl;//指针解引用，获取对象的值 *name_ = name0;//经由指针为name赋值 cout &lt;&lt; "大家好，我的名字是" &lt;&lt; name &lt;&lt; endl; cout &lt;&lt; "大家好，我的名字是" &lt;&lt; *name_ &lt;&lt; endl;&#125; 空指针 空指针不指向任何对象，在试图使用一个指针之前，代码可以首先检查它是否为空。生成空指针的方法：12int* p1=nullptr;//等价于int* ptr=0int* p2=0;//直接将p2初始化为字面常量0 得到空指针最直接的办法是使用字面值nullptr来初始化指针。nullptr是一种特殊的指针，它可以被转换成任意其他指针类型。 赋值和指针 指针额引用都能够提供对其他的对象的间接访问，但是在具体的实现细节上两者有很大不同，其中最主要的又掉了是引用本身并不是一个对象。指针和它存放的地址之间没有这种限制。和其他任何变量一样，给指针赋值就是令它存放一个新地址，从而指向一个新对象。对于指针的赋值，前文已经给出。 其他指针操作 只要指针拥有一个合法值，就能将它用在条件表达式中。和采用算术值作为条件遵循的规则一样，如果指针的值是0，条件取false。对于两个类型相同的合法指针，可以用相等操作符或不相等操作符来比较它们，比较的结果是布尔类型。两个指针存放的地址值相同（两个指针相等），有三种可能： 它们都为空 都指向同一个对象 都指向同一个对象的下一个地址 1234567891011121314#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;int main()&#123; string name = "青木"; string* name_=&amp;name;//name_存放变量name的地址，或者说name_是指向变量name的指针 int* a = nullptr; if (name_&amp;&amp;a) //与运算，一真一假为假 cout &lt;&lt; "大家好，我是指向" &lt;&lt; name &lt;&lt; "的指针，我不为空" &lt;&lt; endl; else cout &lt;&lt; "大家好，我是空指针a，我的地址是" &lt;&lt; &amp;a &lt;&lt; endl;&#125; 输出结果如下： 最后是void*指针。 void* 指针 void 指针是一种特殊的指针类型，可用于存放任意对象的指针，一个void指针存放着一个地址。利用void*指针可以做的事有： 拿它和别的指针比较 作为函数的输入和输出 赋值给另外一个void*指针 但是我们不能直接操作void 指针，因为它的类型未知。以void的视角来看内存空间也仅仅是内存空间，没办法访问内存空间中所存的对象。12345678910111213#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;int main()&#123; int a = 10; int* name_=&amp;a;//name_存放变量a的地址，或者说name_是指向变量a的指针 void* names; names = name_; cout &lt;&lt; "name_指向的值为：" &lt;&lt; *name_ &lt;&lt;",地址为："&lt;&lt;name_&lt;&lt; endl; cout &lt;&lt; "names地址为：" &lt;&lt; names &lt;&lt; endl;&#125; 输出结果： 对于void 指针，我还有许多不解的地方，在网上搜索之后发现了一个比较详细解释void 指针的博文——void及void指针含义的深刻解析]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>引用</tag>
        <tag>指针</tag>
        <tag>复合类型</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++变量]]></title>
    <url>%2F2019%2F03%2F08%2F%E5%8F%98%E9%87%8F%2F</url>
    <content type="text"><![CDATA[变量定义 1.初始值不是赋值。初始化的含义是创建变量时赋予其一个初始值。而赋值的含义是把对象当前值擦除，以一个新值来代替。 2.定义可以为分为列表初始化和默认初始化。 变量声明与定义的关系 为了允许把程序拆分成多个逻辑部分来编写，C++语言支持分离式编译机制，该机制允许将程序分隔为若干个文件，每个文件可被独立编译。为了支持分离式编译，C++语言将声明和定义区别开来 声明使得名字为变量所知 定义负责创建与名字关联的实体 123extern int i; //声明i，不是定义 int j;//声明并定义j extern double pi=3.1416;//定义 标识符 C++标识符由字母、数字和下划线组成，其中必须以字母或者下划线开头，标识符的长度没有限制，但是对大小写字母敏感。 以下为变量命名规范： 标识符要能体现实际含义 变量名一般用小写字母，如index 用户自定义类名一般以大写字母开头 如果标识符由多个单词组成，则单词之间要有明显区分 名字的作用域 作用域是程序的一部分，在其中名字有其特定的含义。C++语言中，大多数作用域都以花括号为分隔。 同一个名字在不同的作用域中可能指向不同的实体，名字的有效区域始于名字的声明语句，以声明语句所在的作用域末端为结束。 嵌套的作用域 内层作用域：作用域能彼此包含，被包含的作用域为内层作用域。 外层作用域：包含着别的作用域的作用域。]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>变量</tag>
      </tags>
  </entry>
</search>
